.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Alien::Base::ModuleBuild::FAQ 3"
.TH Alien::Base::ModuleBuild::FAQ 3 "2020-10-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Alien::Base::ModuleBuild::FAQ \- Frequently Asked Questions about Alien::Base::ModuleBuild
.SH "VERSION"
.IX Header "VERSION"
version 1.15
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& perldoc Alien::Base::FAQ
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1NOTE\s0\fR: Please consider for new development of Aliens that you use
Alien::Build and alienfile instead.  Like Alien::Base::ModuleBUild they work
with Alien::Base.  Unlike Alien::Base::Module::Build they are more easily customized
and handle a number of corner cases better.  For a good place to start,
please see Alien::Build::Manual::API.  Although the 
Alien-Base / Alien-Build team will continue to maintain this module,
(we will continue to fix bugs where appropriate), we aren't adding any
new features to this module.
.PP
This document serves to answer the most frequently asked questions made by Alien::Base authors.
.SS "What is Alien and Alien::Base?"
.IX Subsection "What is Alien and Alien::Base?"
Alien is a Perl namespace for defining dependencies in \s-1CPAN\s0 for libraries and tools which are not \*(L"native\*(R"
to \s-1CPAN.\s0  For a manifesto style description of the Why, and How see Alien.  Alien::Base is a base
class and framework for creating Alien distributions.  The idea is to address as many of the common challenges
to developing Alien modules in the base class to simplify the process.
.SS "How do I specify a minimum or exact version requirement for packages that use pkg-config?"
.IX Subsection "How do I specify a minimum or exact version requirement for packages that use pkg-config?"
The \f(CW\*(C`alien_version_check\*(C'\fR attribute to Alien::Base::ModuleBuild will be executed to determine if
the library is provided by the operating system.  The default for this is \f(CW\*(C`%{pkg_config} \-\-modversion %n\*(C'\fR
which simply checks to see if any version of that package is available, and prints the version
number.  You can use the \f(CW\*(C`\-\-atleast\-version\*(C'\fR, \f(CW\*(C`\-\-exact\-version\*(C'\fR options to require a specific range of versions,
but these flags do not work with the \f(CW\*(C`\-\-modversion\*(C'\fR flag, so be sure to invoke separately.
.PP
.Vb 8
\& use Alien::Base::ModuleBuild;
\& Alien::Base::ModuleBuild\->new(
\&   dist_name           => \*(AqAlien::Foo\*(Aq,
\&   alien_name          => \*(Aqfoo\*(Aq,
\&   configure_requires  => { \*(AqAlien::Base::ModuleBuild\*(Aq => \*(Aq0.022\*(Aq }, # required for %{pkg_config}
\&   alien_version_check => \*(Aq%{pkg_config} \-\-atleast\-version 1.2.3 %n && %{pkg_config} \-\-modversion %n\*(Aq,
\&   ...
\& )\->create_build_script;
.Ve
.PP
It is better to use the built in \f(CW\*(C`%{pkg_config}\*(C'\fR helper as it will use the system provided pkg-config
if it is available and fallback on the pure perl PkgConfig if not.
.PP
You can also use \f(CW\*(C`\-\-exact\-version\*(C'\fR to specify an exact version.
.SS "How to create an Alien module for packages that do not support pkg-config?"
.IX Subsection "How to create an Alien module for packages that do not support pkg-config?"
Although Alien::Base and Alien::Base::ModuleBuild assume packages come with a \f(CW\*(C`pkg\-config\*(C'\fR
\&\f(CW\*(C`.pc\*(C'\fR file to determine compiler and linker flags by default, you can implement an Alien module
for packages that do use \f(CW\*(C`pkg\-config\*(C'\fR by following these tasks:
.ie n .IP "subclass Alien::Base::ModuleBuild and implement ""alien_check_installed_version""" 4
.el .IP "subclass Alien::Base::ModuleBuild and implement \f(CWalien_check_installed_version\fR" 4
.IX Item "subclass Alien::Base::ModuleBuild and implement alien_check_installed_version"
Create a subclass of Alien::Base::ModuleBuild and put it in the \f(CW\*(C`inc\*(C'\fR directory of your distribution so
that it can be used during install but won't \fIbe installed\fR.
.Sp
.Vb 2
\& # inc/My/ModuleBuild.pm
\& package My::ModuleBuild;
\& 
\& use parent \*(AqAlien::Base::ModuleBuild\*(Aq;
\& 
\& sub alien_check_installed_version {
\&   my($class) = @_;
\&   
\&   # determine if your library is already provided by the system
\&   my $version = ...;
\&   
\&   # return false if the library is NOT provided by the system
\&   return unless defined $version;
\&   
\&   # otherwise return the version detected
\&   # (if you cannot determine the version it
\&   #  is usually sufficient to return a true value)
\&   return $version;
\& }
.Ve
.Sp
There are number of methods you can use to determine if the system provides your library.  From Perl
methods include Devel::CheckLib, ExtUtils::CBuilder, ExtUtls::CChecker, Config::AutoConf,
FFI::CheckLib among others.  It is also frequently possible to determine if a library is installed
using a \f(CW\*(C`\-config\*(C'\fR suffixed program.  For example \f(CW\*(C`libxml2\*(C'\fR comes with xml2\-config which provides the
existence, compiler and linker flags it needs.  In my experience, however, most packages that provide a
\&\f(CW\*(C`\-config\*(C'\fR suffixed program also provide a \f(CW\*(C`pkg\-config\*(C'\fR interface as well.
.ie n .IP "implement ""alien_check_built_version"" in your Alien::Base::ModuleBuild subclass" 4
.el .IP "implement \f(CWalien_check_built_version\fR in your Alien::Base::ModuleBuild subclass" 4
.IX Item "implement alien_check_built_version in your Alien::Base::ModuleBuild subclass"
You should also implement \f(CW\*(C`alien_check_build_version\*(C'\fR which will be executed from the package build
root once the package is successfully built.
.Sp
.Vb 2
\& # inc/My/ModuleBuild.pm
\& package My::ModuleBuild;
\& 
\& ...
\& 
\& sub alien_check_built_version {
\&   my($self) = @_;
\&   
\&   my $version = ...
\&   
\&   # (Again, if you cannot determine the version,
\&   #  it is usually sufficent to return a true value)
\&   return $version;
\& }
.Ve
.ie n .IP "set ""alien_provides_cflags"" and ""alien_provides_libs"" in ""Build.PL""." 4
.el .IP "set \f(CWalien_provides_cflags\fR and \f(CWalien_provides_libs\fR in \f(CWBuild.PL\fR." 4
.IX Item "set alien_provides_cflags and alien_provides_libs in Build.PL."
Add something like this to your \f(CW\*(C`Build.PL\*(C'\fR:
.Sp
.Vb 3
\& # Build.PL
\& use lib \*(Aqinc\*(Aq;
\& use My::ModuleBuild;
\& 
\& My::ModuleBuild\->new(
\&   ...
\&   alien_provides_cflags => \*(Aq\-I/usr/include/foo\*(Aq,
\&   alien_provides_libs   => \*(Aq\-L/usr/lib/foo \-lfoo\*(Aq,
\&   ...
\& );
.Ve
.Sp
Note that it is frequently sufficient to provide \f(CW\*(C`alien_provides_libs\*(C'\fR and the appropriate \f(CW\*(C`\-l\*(C'\fR flag.
These flags will be used in the event that the system package can be found.  It is a good idea to verify
that these flags do indeed work in \f(CW\*(C`alien_check_installed_version\*(C'\fR above.
.PP
For a fully implemented example, see Alien::Libbz2.
.SS "How do I test my package once it is built (before it is installed)?"
.IX Subsection "How do I test my package once it is built (before it is installed)?"
There are many ways to test Alien modules before (or after) they are installed, but instead
of rolling your own, consider using Test::Alien which is light on dependencies and will
test your module very closely to the way that it will actually be used.  That is to say by
building a mini \s-1XS\s0 or \s-1FFI\s0 extension and using it.  It even has tests for tool oriented Alien
distributions (like Alien::gmake and Alien::patch).  Here is a short example, there
are many others included with the Test::Alien documentation:
.PP
.Vb 3
\& use Test2::V0;
\& use Test::Alien 0.05;
\& use Alien::Editline;
\& 
\& alien_ok \*(AqAlien::Editline\*(Aq;
\& my $xs = do { local $/; <DATA> };
\& xs_ok $xs, with_subtest {
\&   my($module) = @_;
\&   ok $module\->version;
\& };
\& 
\& done_testing;
\& 
\& _\|_DATA_\|_
\& 
\& #include "EXTERN.h"
\& #include "perl.h"
\& #include "XSUB.h"
\& #include <editline/readline.h>
\& 
\& /* having a string parameter that we ignore
\&    allows us to call this as a class method */
\& const char *
\& version(const char *class)
\& {
\&   return rl_library_version;
\& }
\& 
\& MODULE = TA_MODULE PACKAGE = TA_MODULE
\& 
\& const char *version(class);
\&     const char *class;
.Ve
.SS "How do I patch packages that need minor (or major) alterations?"
.IX Subsection "How do I patch packages that need minor (or major) alterations?"
One approach is to create a unified diff for patches that you want to apply and simply run patch on them.  The
Alien::patch and the \f(CW\*(C`%{patch}\*(C'\fR helper can be used like this:
.PP
.Vb 2
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& 
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_bin_requires => {
\&     \*(AqAlien::patch\*(Aq => 0.06, # needed for %{patch} helper
\&   },
\&   alien_build_commands => [
\&     \*(Aq%{patch} \-p1 < ../../patch/mypackage.patch\*(Aq,
\&     ...
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.PP
Create a folder in your distribution root called \f(CW\*(C`patch\*(C'\fR and place the \f(CW\*(C`mypackage.patch\*(C'\fR file in there.  Since 
the \f(CW\*(C`patch\*(C'\fR command will be executed in the package root instead of the distribution root, you need to use a 
relative path prefixed by \f(CW\*(C`../..\*(C'\fR.  Here we use Alien::patch to provide patch even in environments where it
is not provided.
.PP
A more powerful approach to patching is to write a perl subroutine to modify the source after it has been 
extracted.  One way to do this is to create a module in your distribution's inc directory that does the 
patching (modules in inc can be used during build/test but won't be installed):
.PP
.Vb 2
\& # inc/My/AlienPatch.pm
\& package My::AlienPatch;
\& 
\& # add this sub to the main namespace
\& # so we don\*(Aqt need to quote or escape
\& # anything below
\& sub main::alien_patch {
\&   # is executed in the package root,
\&   # make what ever changes you need to
\&   # to the source here.
\& }
\& 
\& 1;
\&
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& 
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_build_commands => [
\&     # %x will be replaced by path for calling Perl
\&     # from the command line
\&     "%x \-I../../inc \-MMy::AlienPatch \-e alien_patch",
\&     ...
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.SS "How do I build a package that uses \fIbuild system\fP?"
.IX Subsection "How do I build a package that uses build system?"
\fIautoconf\fR
.IX Subsection "autoconf"
.PP
By default Alien::Base::ModuleBuild assumes a package with an autoconf style \f(CW\*(C`configure\*(C'\fR script.  The 
default is
.PP
.Vb 10
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_build_commands => [
\&     \*(Aq%c \-\-prefix=%s\*(Aq,
\&     \*(Aqmake\*(Aq,
\&   ],
\&   alien_install_commands => [
\&     \*(Aqmake install\*(Aq,
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.PP
There are a couple of short cuts here, \f(CW%c\fR indicates the platform independent method for executing the 
\&\f(CW\*(C`configure\*(C'\fR script, plus any normal autoconf flags that are appropriate for Perl Alien libraries. The \f(CW%c\fR 
also tells Alien::Base::ModuleBuild to use Alien::MSYS on Windows platforms and to add that as a 
dependency.  The \f(CW%s\fR is a placeholder for the location to which the package will be installed.  This is 
normally in a share directory specific to your distribution.
.PP
\fIautoconf-like\fR
.IX Subsection "autoconf-like"
.PP
If you see an error like this:
.PP
.Vb 1
\& Unknown option "\-\-with\-pic".
.Ve
.PP
It may be because your package provides a \f(CW\*(C`configure\*(C'\fR script that provides an autoconf-style interface, but is 
not actually autoconf.  Alien::Base::ModuleBuild is aggressive in using the \f(CW\*(C`\-\-with\-pic\*(C'\fR option because when 
supported by autoconf it produces position independent code (important for reliably building \s-1XS\s0 extensions), and 
when not supported autoconf simply ignores the option. Unfortunately some autoconf-style \f(CW\*(C`configure\*(C'\fR scripts 
consider it an error when they see options that they do not recognize.  You can tell Alien::Base::ModuleBuild 
to not use the \f(CW\*(C`\-\-with\-pic\*(C'\fR option via the \f(CW\*(C`alien_autoconf_with_pic\*(C'\fR property:
.PP
.Vb 7
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_autoconf_with_pic => 0,
\&   ...
\& )\->create_build_script;
.Ve
.PP
\fI\s-1CMAKE\s0\fR
.IX Subsection "CMAKE"
.PP
You probably cannot count on CMake being available on most platforms.  Fortunately, there is an alien 
distribution Alien::CMake which will either use the CMake provided by the operating system, or download and 
install it for you.  You can use this from your \f(CW\*(C`Build.PL\*(C'\fR with the \f(CW\*(C`alien_bin_requires\*(C'\fR property:
.PP
.Vb 10
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& use Config;
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_bin_requires => {
\&     \*(AqAlien::CMake\*(Aq => 0.07,
\&   },
\&   alien_build_commands => [
\&     # acutal required arguments may vary
\&     "cmake \-G \*(AqUnix Makefiles\*(Aq \-DCMAKE_MAKE_PROGRAM=$Config{make} \-DCMAKE_INSTALL_PREFIX:PATH=%s",
\&     "$Config{make}",
\&   ],
\&   alien_install_commands => [
\&     "$Config{make} install",
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.PP
\fIvanilla Makefiles?\fR
.IX Subsection "vanilla Makefiles?"
.PP
If you want to use the same \f(CW\*(C`make\*(C'\fR as Perl, you can use Config:
.PP
.Vb 10
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& use Config;
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_build_commands => [
\&     "$Config{make}",
\&   ],
\&   alien_install_commands => [
\&     "$Config{make} install",
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.PP
\fI\s-1GNU\s0 Makefiles?\fR
.IX Subsection "GNU Makefiles?"
.PP
Some packages require \s-1GNU\s0 Make's unique syntax.  Perl's Config provides an entry for \f(CW\*(C`gmake\*(C'\fR, but it is 
frequently wrong.  Do not depend on it.  Instead you can use Alien::gmake to provide a real \s-1GNU\s0 Make (either 
from the operating system, or built from source):
.PP
.Vb 2
\& # Build.PL
\& use Alien::Base::ModuleBuild;
\& 
\& Alien::Base::ModuleBuild\->new(
\&   ...
\&   alien_bin_requires => {
\&     \*(AqAlien::gmake\*(Aq => 0.11, # needed for %{gmake} helper
\&   },
\&   alien_build_commands => [
\&     "%{gmake}",
\&   ],
\&   alien_install_commands => [
\&     "%{gmake} install",
\&   ],
\&   ...
\& )\->create_build_script;
.Ve
.SS "When debugging my package build, I get different results!"
.IX Subsection "When debugging my package build, I get different results!"
If you get results from running the commands in your shell different to what happens when your \f(CW\*(C`Alien::\*(C'\fR 
distribution attempts to build, it may be because your environment is different than the one that your 
distribution is using.  For example, if you use Alien::CMake or Alien::gmake to build with specific tools 
that are provided by your operating system, Alien::Build::ModuleBuild will adjust the path before executing 
build and install commands.
.PP
In the alien build directory (usually \f(CW\*(C`_alien\*(C'\fR) you will find environment files that you can source
into your shell (\f(CW\*(C`env.csh\*(C'\fR for tcsh and \f(CW\*(C`env.sh\*(C'\fR for bourne based shells), which should provide the 
identical environment used by the build process in order to troubleshoot the build manually.
.PP
.Vb 1
\& % source _alien/env.sh
.Ve
.ie n .SS "Can/Should I write a tool oriented Alien module using ""Alien::Base"" that provides executables instead of a library?"
.el .SS "Can/Should I write a tool oriented Alien module using \f(CWAlien::Base\fP that provides executables instead of a library?"
.IX Subsection "Can/Should I write a tool oriented Alien module using Alien::Base that provides executables instead of a library?"
Certainly.  The original intent was to provide libraries, but tools are also quite doable using the 
\&\f(CW\*(C`Alien::Base\*(C'\fR tool set.  A simple minded example of this which is fairly easy to replicate is Alien::m4.
.PP
In general, this means specifying a subclass in your \f(CW\*(C`Build.PL\*(C'\fR and bundling it in your distribution \f(CW\*(C`inc\*(C'\fR directory.
.PP
\&\f(CW\*(C`Build.PL\*(C'\fR:
.PP
.Vb 3
\& ...
\& use lib \*(Aqinc\*(Aq;
\& use My::ModuleBuild;
\& 
\& My::ModuleBuild\->new(
\&   ...
\& )\->create_build_script;
.Ve
.PP
\&\f(CW\*(C`inc/My/ModuleBuild.pm\*(C'\fR:
.PP
.Vb 1
\& package My::ModuleBuild;
\& 
\& use strict;
\& use warnings;
\& use parent \*(AqAlien::Base::ModuleBuild\*(Aq;
\& use Capture::Tiny qw( capture );
\& 
\& sub alien_check_installed_version
\& {
\&   # see Alien::Base::ModuleBuild#alien_check_installed_version for details
\&   
\&   my($self) = @_;
\&   my($stdout, $stderr) = capture { system \*(Aqmytool\*(Aq, \*(Aq\-\-version\*(Aq };
\&   
\&   # return empty list if the tool is unavailable on the system,
\&   # or unacceptable.
\&   return if $! || ...;
\&
\&   # parse from stdout or stderr
\&   my $version = ...;
\&   return $version;
\& }
\& 
\& sub alien_check_built_version
\& {
\&   # see Alien::Base::ModuleBuild#alien_check_built_version for details
\&   
\&   # return empty list if the tool version cannot be found, or if it
\&   # is unacceptable.  Note that this will cause a failure, so "unknown"
\&   # may be reasonable if the tool version cannot be determined.
\&   return if ...;
\&   
\&   # determine from the tool itself, or the current directory.
\&   my $version = ...;
\&   return $version;
\& }
\& 
\& 1;
.Ve
.PP
As usual your \f(CW\*(C`Alien::MyTool\*(C'\fR class will simply be a subclass of Alien::Base.
If you tool is installed in a \f(CW\*(C`bin\*(C'\fR directory, you are done, the default \f(CW\*(C`bin_dir\*(C'\fR
implementation should work for you.  Otherwise you may need to provide an alternate
implementation:
.PP
.Vb 1
\& package Alien::MyTool;
\& 
\& use strict;
\& use warnings;
\& use parent \*(AqAlien::Base\*(Aq;
\& 
\& sub bin_dir
\& {
\&   # see Alien::Base#bin_dir for details
\&   # You only need to override the default implementation if your tool
\&   # does not install into the standard "bin" directory.
\&
\&   my($class) = @_;
\&   
\&   # normally for system installs the tool should already be in your
\&   # PATH, so return an empty list.
\&   return if $class\->install_type eq \*(Aqsystem\*(Aq;
\&   
\&   # install_type = share
\&   my $dist_dir = $class\->dist_dir;
\&   return ("$dist_dir/some/bin", "$dist_dir/some/other/bin");
\& }
\& 
\& 1;
.Ve
.PP
Now once your tool based Alien is installed you can use the \f(CW\*(C`bin_dir\*(C'\fR method to
update the \f(CW\*(C`PATH\*(C'\fR as necessary:
.PP
.Vb 2
\& use Alien::MyTool;
\& use Env qw( @PATH );
\& 
\& unshift @PATH, Alien::MyTool\->bin_dir;
\& system \*(Aqmytool\*(Aq;
.Ve
.ie n .SS "How do I use ""Alien::Base"" from ""Dist::Zilla"""
.el .SS "How do I use \f(CWAlien::Base\fP from \f(CWDist::Zilla\fP"
.IX Subsection "How do I use Alien::Base from Dist::Zilla"
For creating Alien::Base based dists from Dist::Zilla you can use the plugin 
Dist::Zilla::Plugin::Alien.
.ie n .SS "How do I check the built version if my library doesn't provide a "".pc"" file."
.el .SS "How do I check the built version if my library doesn't provide a \f(CW.pc\fP file."
.IX Subsection "How do I check the built version if my library doesn't provide a .pc file."
The default implementation of \f(CW\*(C`alien_check_built_version\*(C'\fR uses several heuristics,
but leans heavily on \f(CW\*(C`pkg\-config\*(C'\fR style \f(CW\*(C`.pc\*(C'\fR files, so if your library or tool
does not provide a \f(CW\*(C`.pc\*(C'\fR, the version may not be detected and your build may fail.
.PP
A lot of libraries are bundled as tarballs with the version in the directory name
that they are extracted into, and the current directory when \f(CW\*(C`alien_check_built_version\*(C'\fR
is called is the build root, so you can use \f(CW\*(C`File::chdir\*(C'\fR as an easy way to determine
the version number:
.PP
.Vb 1
\& package My::ModuleBuild;
\& 
\& use strict;
\& use warnings;
\& use parent \*(AqAlien::Base::ModuleBuild\*(Aq;
\& use File::chdir; # provides @CWD
\& 
\& sub alien_check_built_version
\& {
\&   my $dir_name = $CWD[\-1];
\&   
\&   if($dir_name =~ /^libfoo\-([0\-9\e.]+)$/) {
\&     return $1;
\&   } else {
\&     # Note that this will trigger a build failure
\&     return;
\&   }
\& }
\& 
\& 1;
.Ve
.PP
Using File::chdir and \f(CW@CWD\fR is a common idiom in Alien::Base, because File::chdir
is already a dependency of Alien::Base.  For packages that do not provide a version number
in the extracted directory, you may require some creativity.
.SS "I have question not listed here!"
.IX Subsection "I have question not listed here!"
There are a number of forums available to people working on Alien and Alien::Base modules:
.ie n .IP """#native"" on irc.perl.org" 4
.el .IP "\f(CW#native\fR on irc.perl.org" 4
.IX Item "#native on irc.perl.org"
This is intended for native interfaces in general and so is a good place for questions about Alien
generally or Alien::Base specifically.
.IP "mailing list" 4
.IX Item "mailing list"
The \f(CW\*(C`perl5\-alien\*(C'\fR google group is intended for Alien issues generally, including Alien::Base.
.Sp
<https://groups.google.com/forum/#!forum/perl5\-alien>
.IP "Open a support ticket" 4
.IX Item "Open a support ticket"
If you have an issue with Alien::Base itself, then please open a support ticket on the
project's GitHub issue tracker.
.Sp
<https://github.com/PerlAlien/Alien\-Base\-ModuleBuild/issues>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Alien::Base
.IP "\(bu" 4
Alien::Base::ModuleBuild
.IP "\(bu" 4
Alien::Base::ModuleBuild::API
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author: Joel A Berger <joel.a.berger@gmail.com>
.PP
Current maintainer: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
David Mertens (run4flat)
.PP
Mark Nunberg (mordy, mnunberg)
.PP
Christian Walde (Mithaldu)
.PP
Brian Wightman (MidLifeXis)
.PP
Graham Ollis (plicease)
.PP
Zaki Mughal (zmughal)
.PP
mohawk2
.PP
Vikas N Kumar (vikasnkumar)
.PP
Flavio Poletti (polettix)
.PP
Salvador Fandin\*~o (salva)
.PP
Gianni Ceccarelli (dakkar)
.PP
Pavel Shaydo (zwon, trinitum)
.PP
Kang-min Liu (\s-1XXX,\s0 gugod)
.PP
Nicholas Shipp (nshp)
.PP
Petr Pisar (ppisar)
.PP
Alberto Simo\*~es (ambs)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012\-2020 by Joel A Berger.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
