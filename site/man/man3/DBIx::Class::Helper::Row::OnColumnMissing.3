.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Helper::Row::OnColumnMissing 3"
.TH DBIx::Class::Helper::Row::OnColumnMissing 3 "2020-03-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Helper::Row::OnColumnMissing \- Configurably handle access of missing columns
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package MyApp::Schema::Result::Account;
\&
\& use parent \*(AqDBIx::Class::Core\*(Aq;
\&
\& _\|_PACKAGE_\|_\->load_components(qw(Helper::Row::OnColumnMissing));
\&
\& _\|_PACKAGE_\|_\->table(\*(AqAccount\*(Aq);
\&
\& _\|_PACKAGE_\|_\->add_columns(
\&    id => {
\&       data_type         => \*(Aqinteger\*(Aq,
\&       is_auto_increment => 1,
\&    },
\&    name => {
\&       data_type => \*(Aqvarchar\*(Aq,
\&       size => 25,
\&    },
\&    book => { data_type => \*(Aqtext\*(Aq },
\& );
\&
\& sub on_column_missing { \*(Aqdie\*(Aq }
\&
\& 1;
.Ve
.PP
Or with DBIx::Class::Candy:
.PP
.Vb 1
\& package MyApp::Schema::Result::Account;
\&
\& use DBIx::Class::Candy \-components => [\*(AqHelper::Row::OnColumnMissing\*(Aq];
\&
\& table \*(AqAccount\*(Aq;
\&
\& column id => {
\&    data_type         => \*(Aqinteger\*(Aq,
\&    is_auto_increment => 1,
\& };
\&
\& column amount => {
\&    data_type          => \*(Aqfloat\*(Aq,
\&    keep_storage_value => 1,
\& };
\&
\& column book => { data_type => \*(Aqtext\*(Aq };
\&
\& sub on_column_missing { \*(Aqdie\*(Aq }
\&
\& 1;
.Ve
.PP
Elsewhere:
.PP
.Vb 1
\& my $row = $rs\->search(undef, { columns => [qw( id name )] })\->one_row;
\&
\& $row\->book # dies
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is written to handle the odd condition where you have limited the
columns retrieved from the database but accidentally access one of the ones not
included.  It is configurable by tweaking the \f(CW\*(C`on_column_missing\*(C'\fR return value.
.SH "MODES"
.IX Header "MODES"
You specify the \f(CW\*(C`mode\*(C'\fR by returning the \f(CW\*(C`mode\*(C'\fR from the \f(CW\*(C`on_column_missing\*(C'\fR
method.  By default the \f(CW\*(C`mode\*(C'\fR returned is \f(CW\*(C`warn\*(C'\fR.
.PP
The predefined modes are:
.ie n .IP """die""" 2
.el .IP "\f(CWdie\fR" 2
.IX Item "die"
Dies with \f(CW\*(C`Column $name has not been loaded\*(C'\fR.
.ie n .IP """warn""" 2
.el .IP "\f(CWwarn\fR" 2
.IX Item "warn"
Warns with \f(CW\*(C`Column $name has not been loaded\*(C'\fR.
.ie n .IP """nothing""" 2
.el .IP "\f(CWnothing\fR" 2
.IX Item "nothing"
Does nothing
.PP
You can predefine more modes by defining methods named \f(CW\*(C`on_column_$mode\*(C'\fR, and
also override the default modes by overriding the corresponding methods.  If you
need ad-hoc behavior you can return a code reference and that will be called as
a method on the object.
.SS "\s-1ADVANCED USAGE\s0"
.IX Subsection "ADVANCED USAGE"
If for some reason you find that you need to change your \f(CW\*(C`mode\*(C'\fR at runtime, you
can always replace the \f(CW\*(C`on_column_missing\*(C'\fR with an accessor.  For example:
.PP
.Vb 2
\& _\|_PACKAGE_\|_\->mk_group_accessors(inherited => \*(Aqon_column_missing\*(Aq);
\& _\|_PACKAGE_\|_\->on_column_missing(\*(Aqwarn\*(Aq);
.Ve
.PP
Elsewhere:
.PP
.Vb 1
\& $row\->on_column_missing(\*(Aqdie\*(Aq);
.Ve
.PP
If you are especially crazy you could even do something like this:
.PP
.Vb 2
\& $row\->on_column_missing(sub {
\&    my ($self, $column) = @_;
\&
\&    $self
\&       \->result_source
\&       \->resultset
\&       \->search({ id => $self\->id })
\&       \->get_column($column)
\&       \->single
\& });
.Ve
.PP
Though if you do that I would make it a named mode (maybe \f(CW\*(C`retrieve\*(C'\fR?)
.SH "THANKS"
.IX Header "THANKS"
Thanks ZipRecruiter <https://www.ziprecruiter.com> for funding the development
of this module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Arthur Axel \*(L"fREW\*(R" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Arthur Axel \*(L"fREW\*(R" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
