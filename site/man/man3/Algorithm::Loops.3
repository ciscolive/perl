.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Algorithm::Loops 3"
.TH Algorithm::Loops 3 "2016-07-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Algorithm::Loops \- Looping constructs:
NestedLoops, MapCar*, Filter, and NextPermute*
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 6
\&    use Algorithm::Loops qw(
\&        Filter
\&        MapCar MapCarU MapCarE MapCarMin
\&        NextPermute NextPermuteNum
\&        NestedLoops
\&    );
\&
\&    my @copy= Filter {tr/A\-Z\*(Aq.,"()/a\-z/d} @list;
\&    my $string= Filter {s/\es*$/ /} @lines;
\&
\&    my @transposed= MapCarU {[@_]} @matrix;
\&
\&    my @list= sort getList();
\&    do {
\&        usePermutation( @list );
\&    } while(  NextPermute( @list )  );
\&
\&    my $len= @ARGV ? $ARGV[0] : 3;
\&    my @list= NestedLoops(
\&        [  ( [ 1..$len ] ) x $len  ],
\&        sub { "@_" },
\&    );
.Ve
.PP
If you want working sample code to try, see below in the section specific
to the function(s) you want to try.  The above samples only give a
\&\fIfeel\fR for how the functions are typically used.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Algorithm::Loops provides the functions listed below.  By default, no
functions are exported into your namespace (package / symbol table) in
order to encourage you to list any functions that you use in the \f(CW\*(C`use
Algorithm::Loops\*(C'\fR statement so that whoever ends up maintaining your code
can figure out which module you got these functions from.
.IP "Filter" 4
.IX Item "Filter"
Similar to \f(CW\*(C`map\*(C'\fR but designed for use with s/// and other reflexive
operations.  Returns a modified copy of a list.
.IP "MapCar, MapCarU, MapCarE, and MapCarMin" 4
.IX Item "MapCar, MapCarU, MapCarE, and MapCarMin"
All similar to \f(CW\*(C`map\*(C'\fR but loop over multiple lists at the same time.
.IP "NextPermute and NextPermuteNum" 4
.IX Item "NextPermute and NextPermuteNum"
Efficiently find all (unique) permutations of a list, even if it contains
duplicate values.
.IP "NestedLoops" 4
.IX Item "NestedLoops"
Simulate \f(CW\*(C`foreach\*(C'\fR loops nested arbitrarily deep.
.SS "Filter(\e&@)"
.IX Subsection "Filter(&@)"
\fIOverview\fR
.IX Subsection "Overview"
.PP
Produces a modified copy of a list of values.  Ideal for use with s///.
If you find yourself trying to use s/// or tr/// inside of map (or grep),
then you should probably use Filter instead.
.PP
For example:
.PP
.Vb 1
\&    use Algorithm::Loops qw( Filter );
\&
\&    @copy = Filter { s/\e\e(.)/$1/g } @list;
\&    $text = Filter { s/^\es+// } @lines;
.Ve
.PP
The same process can be accomplished using a careful and more complex
invocation of map, grep, or foreach.  However, many incorrect ways to
attempt this seem rather seductively appropriate so this function helps
to discourage such (rather common) mistakes.
.PP
\fIUsage\fR
.IX Subsection "Usage"
.PP
Filter has a prototype specification of (\e&@).
.PP
This means that it demands that the first argument that you pass to it be
a \s-1CODE\s0 reference.  After that you can pass a list of as many or as few
values as you like.
.PP
For each value in the passed-in list, a copy of the value is placed into
\&\f(CW$_\fR and then your \s-1CODE\s0 reference is called.  Your subroutine is expected
to modify \f(CW$_\fR and this modified value is then placed into the list of
values to be returned by Filter.
.PP
If used in a scalar context, Filter returns a single string that is the
result of:
.PP
.Vb 1
\&    $string= join "", @results;
.Ve
.PP
Note that no arguments are passed to your subroutine (so don't bother
with \f(CW@_\fR) and any value \f(CW\*(C`return\*(C'\fRed by your subroutine is ignored.
.PP
Filter's prototype also means that you can use the \*(L"map \s-1BLOCK\s0\*(R"\-like
syntax by leaving off the \f(CW\*(C`sub\*(C'\fR keyword if you also leave off the
comma after the block that defines your anonymous subroutine:
.PP
.Vb 3
\&        my @copy= Filter sub {s/\es/_/g}, @list;
\&  # becomes:            v^^^       v   ^
\&        my @copy= Filter {s/\es/_/g} @list;
.Ve
.PP
Most of our examples will use this shorter syntax.
.PP
Note also that by importing Filter via the \f(CW\*(C`use\*(C'\fR statement:
.PP
.Vb 1
\&    use Algorithm::Loops qw( Filter );
.Ve
.PP
it gets declared before the rest of our code is compiled so we don't have
to use parentheses when calling it.  We \fIcan\fR if we want to, however:
.PP
.Vb 1
\&        my @copy= Filter( sub {s/\es/_/g}, @list );
.Ve
.PP
\fINote on \*(L"Function \s-1BLOCK LIST\*(R"\s0 bugs\fR
.IX Subsection "Note on Function BLOCK LIST bugs"
.PP
Note that in at least some versions of Perl, support for the \*(L"Filter
\&\s-1BLOCK ...\*(R"\s0 syntax is somewhat fragile.  For example:
.PP
.Vb 1
\&    ... Filter( {y/aeiou/UAEIO/} @list );
.Ve
.PP
may give you this error:
.PP
.Vb 1
\&    Array found where operator expected
.Ve
.PP
which can be fixed by dropping the parentheses:
.PP
.Vb 1
\&    ... Filter {y/aeiou/UAEIO/} @list;
.Ve
.PP
So if you need or want to use parentheses when calling Filter, it is best
to also include the \f(CW\*(C`sub\*(C'\fR keyword and the comma:
.PP
.Vb 3
\&    #         v <\-\-\-\-\-\-\-\-\- These \-\-\-\-\-\-\-\-\-> v
\&    ... Filter( sub {y/aeiou/UAEIO/}, @list );
\&    # require   ^^^ <\-\-\- these \-\-\-> ^ (sometimes)
.Ve
.PP
so your code will be portable to more versions of Perl.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Good code ignores \*(L"invisible\*(R" characters.  So
instead of just \fBchomp()\fRing, consider removing
all trailing whitespace:
.PP
.Vb 1
\&    my @lines= Filter { s/\es+$// } <IN>;
.Ve
.PP
or
.PP
.Vb 1
\&    my $line= Filter { s/\es+$// } scalar <IN>;
.Ve
.PP
[ Note that Filter can be used in a scalar
context but always puts its arguments in a
list context.  So we need to use \f(CW\*(C`scalar\*(C'\fR or
something similar if we want to read only one
line at a time from \f(CW\*(C`IN\*(C'\fR above. ]
.PP
Want to sort strings that contain mixtures of
letters and natural numbers (non-negative
integers) both alphabetically and numerically
at the same time?  This simple way to do a
\&\*(L"natural\*(R" sort is also one of the fastest.
Great for sorting version numbers, file names,
etc.:
.PP
.Vb 5
\&    my @sorted= Filter {
\&        s#\ed{2}(\ed+)#\e1#g
\&    } sort Filter {
\&        s#(\ed+)# sprintf "%02d%s", length($1), $1 #g
\&    } @data;
.Ve
.PP
[ Note that at least some versions of Perl have a bug that breaks \f(CW\*(C`sort\*(C'\fR
if you write \f(CW\*(C`sub {\*(C'\fR as part of building the list of items to be sorted
but you don't provide a comparison routine.  This bug means we can't
write the previous code as:
.PP
.Vb 5
\&    my @sorted= Filter {
\&        s#\ed{2}(\ed+)#\e1#g
\&    } sort Filter sub {
\&        s#(\ed+)# sprintf "%02d%s", length($1), $1 #g
\&    }, @data;
.Ve
.PP
because it will produce the following error:
.PP
.Vb 1
\&    Undefined subroutine in sort
.Ve
.PP
in some versions of Perl.  Some versions of Perl may even require you
to write it like this:
.PP
.Vb 5
\&    my @sorted= Filter {
\&        s#\ed{2}(\ed+)#\e1#g
\&    } sort &Filter( sub {
\&        s#(\ed+)# sprintf "%02d%s", length($1), $1 #g
\&    }, @data );
.Ve
.PP
Which is how I wrote it in ex/NaturalSort.plx. ]
.PP
Need to sort names?  Then you'll probably want to ignore letter case and
certain punctuation marks while still preserving both:
.PP
.Vb 3
\&    my @compare= Filter {tr/A\-Z\*(Aq.,"()/a\-z/d} @names;
\&    my @indices= sort {$compare[$a] cmp $compare[$b]} 0..$#names;
\&    @names= @names[@indices];
.Ve
.PP
You can also roll your own simple \s-1HTML\s0 templating:
.PP
.Vb 5
\&    print Filter {
\&        s/%(\ew*)%/expand($1)/g
\&    }   $cgi\->...,
\&        ...
\&        $cgi\->...;
.Ve
.PP
Note that it also also works correctly if you change how you output your
    \s-1HTML\s0 and accidentally switch from list to scalar context:
.PP
.Vb 7
\&    my $html= \*(Aq\*(Aq;
\&    ...
\&    $html .= Filter {
\&        s/%(\ew*)%/expand($1)/g
\&    }   $cgi\->...,
\&        ...
\&        $cgi\->...;
.Ve
.PP
\fIMotivation\fR
.IX Subsection "Motivation"
.PP
A reasonable use of map is:
.PP
.Vb 1
\&    @copy= map {lc} @list;
.Ve
.PP
which sets \f(CW@copy\fR to be a copy of \f(CW@list\fR but with all of the elements
converted to lower case.  But it is too easy to think that that could
also be done like this:
.PP
.Vb 1
\&    @copy= map {tr/A\-Z/a\-z/} @list;  # Wrong
.Ve
.PP
The reason why these aren't the same is similar to why we write:
.PP
.Vb 1
\&    $str= lc $str;
.Ve
.PP
not
.PP
.Vb 1
\&    lc $str;  # Useless use of \*(Aqlc\*(Aq in void context
.Ve
.PP
and we write:
.PP
.Vb 1
\&    $str =~ tr/A\-Z/a\-z/;
.Ve
.PP
not
.PP
.Vb 1
\&    $new= ( $old =~ tr/A\-Z/a\-z/ );  # Wrong
.Ve
.PP
That is, many things (such as lc) return a modified copy of what they are
given, but a few things (such as tr///, s///, chop, and chomp) modify
what they are given \fIin-place\fR.
.PP
This distinction is so common that we have several ways of switching
between the two forms.  For example:
.PP
.Vb 3
\&        $two= $one + $other;
\&  # vs.
\&        $one += $other;
.Ve
.PP
or
.PP
.Vb 3
\&        $two= substr($one,0,4);
\&  # vs.
\&        substr($one,4)= \*(Aq\*(Aq;
.Ve
.PP
I've even heard talk of adding some syntax to Perl to allow you to make
things like \f(CW\*(C`lc\*(C'\fR become reflexive, similar to how += is the reflexive
form of +.
.PP
But while many non-reflexive Perl operations have reflexive counterparts,
there are a few reflexive Perl operations that don't really have
non-reflexive counterparts: s///, tr///, chop, chomp.
.PP
You can write:
.PP
.Vb 4
\&        my $line= <STDIN>;
\&        chomp( $line );
\&  # or
\&        chomp( my $line= <STDIN> );
.Ve
.PP
but it somehow seems more natural to write:
.PP
.Vb 1
\&        my $line= chomp( <STDIN> );  # Wrong
.Ve
.PP
So, if you dislike hiding the variable declaration inside of a function
call or dislike using two lines and repeating the variable name, then you
can now use:
.PP
.Vb 1
\&        my $line= Filter {chomp} \*(Aq\*(Aq.<STDIN>;
.Ve
.PP
[ I used \f(CW\*(C`\*(Aq\*(Aq.\*(C'\fR to provide a scalar context so that only one line is read
from \s-1STDIN.\s0 ]
.PP
Or, for a better example, consider these valid alternatives:
.PP
.Vb 4
\&        my @lines= <STDIN>;
\&        chomp( @lines );
\&  # or
\&        chomp( my @lines= <STDIN> );
.Ve
.PP
And what you might expect to work (but doesn't):
.PP
.Vb 1
\&        my @lines= chomp( <STDIN> );  # Wrong
.Ve
.PP
And what you can now use instead:
.PP
.Vb 1
\&        my @lines= Filter {chomp} <STDIN>;
.Ve
.PP
Here are some examples of ways to use map/grep correctly to get Filter's
functionality:
.PP
.Vb 5
\&        Filter { CODE } @list
\&  # vs
\&        join "", map { local($_)= $_; CODE; $_ } @list
\&  # vs
\&        join "", grep { CODE; 1 } @{ [@list] }
.Ve
.PP
Not horribly complex, but enough that it is very easy to forget part of
the solution, making for easy mistakes.  I see mistakes related to this
quite frequently and have made such mistakes myself several times.
.PP
Some (including me) would even consider the last form above to be an
abuse (or misuse) of \f(CW\*(C`grep\*(C'\fR.
.PP
You can also use \f(CW\*(C`for\*(C'\fR/\f(CW\*(C`foreach\*(C'\fR to get the same results as Filter:
.PP
.Vb 8
\&        my @copy= Filter { CODE } @list;
\&  # vs
\&        STATEMENT  foreach  my @copy= @list;
\&  # or
\&        my @copy= @list;
\&        foreach(  @copy  ) {
\&            CODE;
\&        }
.Ve
.SS "MapCar*"
.IX Subsection "MapCar*"
.IP "MapCar(\e&@)" 4
.IX Item "MapCar(&@)"
.PD 0
.IP "MapCarU(\e&@)" 4
.IX Item "MapCarU(&@)"
.IP "MapCarE(\e&@)" 4
.IX Item "MapCarE(&@)"
.IP "MapCarMin(\e&@)" 4
.IX Item "MapCarMin(&@)"
.PD
.PP
\fIUsage\fR
.IX Subsection "Usage"
.PP
The MapCar* functions are all like \f(CW\*(C`map\*(C'\fR except they each loop over more
than one list at the same time.
.PP
[ The name \*(L"mapcar\*(R" comes from \s-1LISP.\s0 As I understand it, 'car' comes from
the acronym for a register of the processor where \s-1LISP\s0 was first
developed, one of two registers used to implement lists in \s-1LISP.\s0  I only
mention this so you won't waste too much time trying to figure out what
\&\*(L"mapcar\*(R" is supposed to mean. ]
.PP
The MapCar* functions all have prototype specifications of (\e&@).
.PP
This means that they demand that the first argument that you pass be a
\&\s-1CODE\s0 reference.  After that you should pass zero or more array references.
.PP
Your subroutine is called (in a list context) and is passed the first
element of each of the arrays whose references you passed in (in the
corresponding order).  Any value(s) returned by your subroutine are
pushed onto an array that will eventually be returned by MapCar*.
.PP
Next your subroutine is called and is passed the \fBsecond\fR element of
each of the arrays and any value(s) returned are pushed onto the results
array.  Then the process is repeated with the \fBthird\fR elements.
.PP
This continues until your subroutine has been passed all elements [except
for some cases with \fBMapCarMin()\fR].  If the longest array whose reference
you passed to \fBMapCar()\fR or \fBMapCarU()\fR contained \f(CW$N\fR elements, then your
subroutine would get called \f(CW$N\fR times.
.PP
Finally, the MapCar* function returns the accumulated list of values.  If
called in a scalar context, the MapCar* function returns a reference to
an array containing these values.
.PP
[ I feel that having \f(CW\*(C`map\*(C'\fR return a count when called in a scalar
context is quite simply a mistake that was made when this feature was
copied from \f(CW\*(C`grep\*(C'\fR without properly considering the consequences.
Although it does make for the impressive and very impractical golf
solution of:
.PP
.Vb 1
\&    $sum=map{(1)x$_}@ints;
.Ve
.PP
for adding up a list of natural numbers. q\-: ]
.PP
\fIDifferences\fR
.IX Subsection "Differences"
.PP
The different MapCar* functions are only different in how they deal with
being pqssed arrays that are not all of the same size.
.PP
If not all of your arrays are the same length, then \fBMapCarU()\fR will pass
in \f(CW\*(C`undef\*(C'\fR for any values corresponding to arrays that didn't have
enough values.  The \*(L"U\*(R" in \*(L"MapCarU\*(R" stands for \*(L"undef\*(R".
.PP
In contrast, \fBMapCar()\fR will simply leave out values for short arrays (just
like I left the \*(L"U\*(R" out of its name).
.PP
\&\fBMapCarE()\fR will croak without ever calling your subroutine unless all of
the arrays are the same length.  It considers it an Error if your arrays
are not of Equal length and so throws an Exception.
.PP
Finally, \fBMapCarMin()\fR only calls your subroutine as many times as there
are elements in the \fBshortest\fR array.
.PP
In other words,
.PP
.Vb 1
\&    MapCarU \e&MySub, [1,undef,3], [4,5], [6,7,8]
.Ve
.PP
returns
.PP
.Vb 4
\&    ( MySub( 1, 4, 6 ),
\&      MySub( undef, 5, 7 ),
\&      MySub( 3, undef, 8 ),
\&    )
.Ve
.PP
While
.PP
.Vb 1
\&    MapCar \e&MySub, [1,undef,3], [4,5], [6,7,8]
.Ve
.PP
returns
.PP
.Vb 4
\&    ( MySub( 1, 4, 6 ),
\&      MySub( undef, 5, 7 ),
\&      MySub( 3, 8 ),
\&    )
.Ve
.PP
While
.PP
.Vb 1
\&    MapCarMin \e&MySub, [1,undef,3], [4,5], [6,7,8]
.Ve
.PP
returns
.PP
.Vb 3
\&    ( MySub( 1, 4, 6 ),
\&      MySub( undef, 5, 7 ),
\&    )
.Ve
.PP
And
.PP
.Vb 1
\&    MapCarE \e&MySub, [1,undef,3], [4,5], [6,7,8]
.Ve
.PP
dies with
.PP
.Vb 1
\&    MapCarE: Arrays with different sizes (3 and 2)
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Transposing a two-dimensional matrix:
.PP
.Vb 1
\&    my @transposed= MapCarE {[@_]} @matrix;
.Ve
.PP
or, using references to the matrices and allowing for different row
lengths:
.PP
.Vb 1
\&    my $transposed= MapCarU {[@_]} @$matrix;
.Ve
.PP
Formatting a date-time:
.PP
.Vb 5
\&    my $dateTime= join \*(Aq\*(Aq, MapCarE {
\&        sprintf "%02d%s", pop()+pop(), pop()
\&    } [ (localtime)[5,4,3,2,1,0] ],
\&      [ 1900, 1, (0)x4 ],
\&      [ \*(Aq// ::\*(Aq =~ /./g, \*(Aq\*(Aq ];
.Ve
.PP
Same thing but not worrying about warnings for using undefined values:
.PP
.Vb 5
\&    my $dateTime= join \*(Aq\*(Aq, MapCarU {
\&        sprintf "%02d%s", pop()+pop(), pop()
\&    } [ (localtime)[5,4,3,2,1,0] ],
\&      [ 1900, 1 ],
\&      [ \*(Aq// ::\*(Aq =~ /./g ];
.Ve
.PP
Combine with \f(CW\*(C`map\*(C'\fR to do matrix multiplication:
.PP
.Vb 10
\&    my @X= (
\&        [  1,  3 ],
\&        [  4, \-1 ],
\&        [ \-2,  2 ],
\&    );
\&    my @Y= (
\&        [ \-6,  2, 5, \-3 ],
\&        [  4, \-1, 3,  1 ],
\&    );
\&    my @prod= map {
\&        my $row= $_;
\&        [
\&            map {
\&                my $sum= 0;
\&                $sum += $_   for  MapCarE {
\&                    pop() * pop();
\&                } $row, $_;
\&                $sum;
\&            } MapCarE {\e@_} @Y;
\&        ]
\&    } @X;
.Ve
.PP
Report the top winners:
.PP
.Vb 4
\&    MapCarMin {
\&        print pop(), " place goes to ", pop(), ".\en";
\&    } [qw( First Second Third Fourth )],
\&      \e@winners;
.Ve
.PP
Same thing (scalar context):
.PP
.Vb 4
\&    my $report= MapCarMin {
\&        pop(), " place goes to ", pop(), ".\en";
\&    } [qw( First Second Third Fourth )],
\&      \e@winners;
.Ve
.PP
Displaying a duration:
.PP
.Vb 10
\&    my $ran= time() \- $^T;
\&    my $desc= join \*(Aq, \*(Aq, reverse MapCar {
\&        my( $unit, $mult )= @_;
\&        my $part= $ran;
\&        if(  $mult  ) {
\&            $part %= $mult;
\&            $ran= int( $ran / $mult );
\&        }
\&        $unit .= \*(Aqs\*(Aq   if  1 != $part;
\&        $part ? "$part $unit" : ();
\&    } [ qw( sec min hour day week year ) ],
\&      [     60, 60, 24,   7,  52 ];
\&    $desc ||= \*(Aq< 1 sec\*(Aq;
\&    print "Script ran for $desc.\en";
.Ve
.SS "NextPermute*"
.IX Subsection "NextPermute*"
.IP "NextPermute(\e@)" 4
.IX Item "NextPermute(@)"
.PD 0
.IP "NextPermuteNum(\e@)" 4
.IX Item "NextPermuteNum(@)"
.PD
.PP
\fIIntroduction\fR
.IX Subsection "Introduction"
.PP
If you have a list of values, then a \*(L"permutation\*(R" of that list is the
same values but not (necessarily) in the same order.
.PP
\&\fBNextPermute()\fR and \fBNextPermuteNum()\fR each provide very efficient ways of
finding all of the (unique) permutations of a list (even if the list
contains duplicate values).
.PP
\fIUsage\fR
.IX Subsection "Usage"
.PP
Each time you pass an array to a NextPermute* routine, the elements of
the array are shifted around to give you a new permutation.  If the
elements of the array are in reverse-sorted order, then the array is
reversed (in-place, making it sorted) and a false value is returned.
Otherwise a true value is returned.
.PP
So, if you start out with a sorted array, then you can use that as your
first permutation and then call NextPermute* to get the next permutation
to use, until NextPermute* returns a false value (at which point your
array has been returned to its original, sorted order).
.PP
So you would use \fBNextPermute()\fR like this:
.PP
.Vb 4
\&    my @list= sort GetValuesSomehow();
\&    do {
\&        DoSomethingWithPermutation( @list );
\&    } while(  NextPermute( @list )  );
.Ve
.PP
or, if your list only contains numbers, you could use \fBNextPermuteNum()\fR
like this:
.PP
.Vb 4
\&    my @list= sort {$a<=>$b} GetNumbersSomehow();
\&    do {
\&        DoSomethingWithPermutation( @list );
\&    } while(  NextPermuteNum( @list )  );
.Ve
.PP
\fINotes\fR
.IX Subsection "Notes"
.PP
The NextPermute* functions each have a prototype specifications of (\e@).
This means that they demand that you pass them a single array which they
will receive a reference to.
.PP
If you instead have a reference to an array, you'll need to use \f(CW\*(C`@{ }\*(C'\fR
when calling a NextPermute* routine:
.PP
.Vb 1
\&    } while(  NextPermute( @{$av} )  );
.Ve
.PP
(or use one of several other techniques which I will leave the
consideration of as an \*(L"exercise\*(R" for the more advanced readers
of this manual).
.PP
Note that this particular use of a function prototype is one that I am
not completely comfortable with.  I am tempted to remove the prototype
and force you to create the reference yourself before/when calling these
functions:
.PP
.Vb 1
\&    } while(  NextPermute( \e@list )  );   # Wrong
.Ve
.PP
because
.IP "\(bu" 4
It makes it obvious to the reader of the code that a reference to the
array is what is being used by the routine.  This makes the reader more
likely to realize/suspect that the array is being modified in-place.
.IP "\(bu" 4
Many/most uses of Perl function prototypes are more trouble than they are
worth.  This makes using even the less problematic cases often not a good
idea.
.PP
However, I have decided to use a prototype here because:
.IP "\(bu" 4
Several other functions from this module already use prototypes to good
advantage, enough advantage that I'd hate to lose it.
.IP "\(bu" 4
Removing the prototype would require the addition of argument-checking
code that would get run each time a permutation is computed, somewhat
slowing down what is currently quite fast.
.IP "\(bu" 4
The compile-time checking provided by the prototype can save develop time
over a run-time check by pointing out mistakes sooner.
.PP
\fIFeatures\fR
.IX Subsection "Features"
.PP
There are several features to NextPermute* that can be advantages over
other methods of finding permutations.
.IP "Iterators \- No huge memory requirements" 4
.IX Item "Iterators - No huge memory requirements"
Some permutation generators return the full set of all permutations (as a
huge list of lists).  Your input list doesn't have to be very big at all
for the resulting set to be too large to fit in your available memory.
.Sp
So the NextPermute* routines return each permutation, one at a time, so
you can process them all (eventually) without the need for lots of memory.
.Sp
A programming object that gives you access to things one-at-a-time is
called an \*(L"iterator\*(R".
.IP "No context \- Hardly any memory required" 4
.IX Item "No context - Hardly any memory required"
The NextPermute* routines require no extra memory in the way of context
or lists to keep track of while constructing the permutations.
.Sp
Each call to a NextPermute* routine shuffles the items in the list
\&\fBin-place\fR, never making copies of more than a couple of values at a
time (when it swaps them).
.Sp
[ This also means you don't have to bother with creating an object to do
the iterating. ]
.IP "Handles duplicate values" 4
.IX Item "Handles duplicate values"
Unlike most permutation generators you are likely to find in Perl, both
NextPermute* routines correctly deal with lists containing duplicate
values.
.Sp
The following example:
.Sp
.Vb 4
\&    my @list= ( 3, 3, 3, 3 );
\&    do {
\&        print "@list\en";
\&    } while(  NextPermute( @list )  );
.Ve
.Sp
will only print the one line, \*(L"3 3 3 3\en\*(R", because \fBNextPermute()\fR quickly
determines that there are no other unique permutations.
.Sp
Try out the demonstration program included in the \*(L"ex\*(R" subdirectory of
the source distribution of this module:
.Sp
.Vb 10
\&    > perl ex/Permute.plx tool
\&    1: loot
\&    2: loto
\&    3: ltoo
\&    4: olot
\&    5: olto
\&    6: oolt
\&    7: ootl
\&    8: otlo
\&    9: otol
\&    10: tloo
\&    11: tolo
\&    12: tool
.Ve
.Sp
Most permutation generators would have listed each of those twice
(thinking that swapping an \*(L"o\*(R" with another \*(L"o\*(R" made a new permutation). 
Or consider:
.Sp
.Vb 7
\&    > perl ex/Permute.plx noon
\&    1: nnoo
\&    2: nono
\&    3: noon
\&    4: onno
\&    5: onon
\&    6: oonn
.Ve
.Sp
Most permutation generators would have listed each of those \fBfour\fR
times.
.Sp
Note that using a hash to eliminate duplicates would require a hash table
big enough to hold all of the (unique) permutations and so would defeat
the purpose of iterating.  NextPermute* does not use a hash to avoid
duplicates.
.IP "Generated in sorted order" 4
.IX Item "Generated in sorted order"
If you were to run code like:
.Sp
.Vb 4
\&    my @list= sort GetValuesSomehow();
\&    do {
\&        print join(\*(Aq\*(Aq,@lista, $/);
\&    } while(  NextPermute( @list )  );
.Ve
.Sp
then the lines output would be sorted (assuming none of the values in
\&\f(CW@list\fR contained newlines.  This may be convenient in some corcumstances.
.Sp
That is, the permutations are generated in sorted order.  The first
permutations have the lowest values at the front of the list.  As you
iterate, larger values are shifted to be in front of smaller values,
starting at the back of the list.  So the value at the very front of the
list will change the fewest times (once for each unique value in the
list), while the value at the very end of the list changes between most
iterations.
.IP "Fast" 4
.IX Item "Fast"
If you don't have to deal with duplicate values, then Algorithm::Permute
provides some routines written in C (which makes them harder to install
but about twice as fast to run as the NextPermute* routines) that you can
use.
.Sp
Algorithm::Permute also includes some fun benchmarks comparing different
Perl ways of finding permutations.  I found NextPermute to be faster than
any of the routines included in those benchmarks except for the ones
written in C that I mentioned above.  Though none of the benchmarked
routines deal with duplicates.
.PP
\fINotes\fR
.IX Subsection "Notes"
.PP
Note that \fBNextPermute()\fR considers two values (say \f(CW$x\fR and \f(CW$y\fR) to be
duplicates if (and only if) \f(CW\*(C`$x eq $y\*(C'\fR.
.PP
\&\fBNextPermuteNum()\fR considers \f(CW$x\fR and \f(CW$y\fR to be duplicates if \f(CW\*(C`$x == $y\*(C'\fR.
.PP
If you have a list of floating point numbers to permute, you might want
to use \fBNextPermute()\fR [instead of \fBNextPermuteNum()\fR] as it is easy to end
up with \f(CW$x\fR and \f(CW$y\fR that both display the same (say as \*(L"0.1\*(R") but are
\&\fBjust barely\fR not equal numerically.  Thus \f(CW$x\fR and \f(CW$y\fR would \fIlook\fR equal
and it would be true that \f(CW\*(C`$x eq $y\*(C'\fR but also true that \f(CW\*(C`$x != $y\*(C'\fR.  So
\&\fBNextPermute()\fR would consider them to be duplicates but \fBNextPermuteNum()\fR
would not.
.PP
For example, \f(CW$x\fR could be slightly more than 1/10, likely about
0.1000000000000000056, while \f(CW$y\fR is slightly more at about
0.0999999999999999917 (both of which will be displayed as \*(L"0.1\*(R" by Perl
and be considered \f(CW\*(C`eq\*(C'\fR (on most platforms):
.PP
.Vb 12
\&    > perl \-w \-Mstrict
\&    my $x= 0.1000000000000000056;
\&    my $y= 0.0999999999999999917;
\&    print "x=$x\eny=$y\en";
\&    print "are eq\en"   if  $x eq $y;
\&    print "are ==\en"   if  $x == $y;
\&    print "are !=\en"   if  $x != $y;
\&    <EOF>
\&    x=0.1
\&    y=0.1
\&    are eq
\&    are !=
.Ve
.SS "NestedLoops"
.IX Subsection "NestedLoops"
\fIIntroduction\fR
.IX Subsection "Introduction"
.PP
Makes it easy to simulate loops nested to an arbitrary depth.
.PP
It is easy to write code like:
.PP
.Vb 7
\&    for my $a (  0..$N  ) {
\&     for my $b (  $a+1..$N  ) {
\&      for my $c (  $b+1..$N  ) {
\&          Stuff( $a, $b, $c );
\&      }
\&     }
\&    }
.Ve
.PP
But what if you want the user to tell you how many loops to nest
together?  The above code can be replaced with:
.PP
.Vb 1
\&    use Algorithm::Loops qw( NestedLoops );
\&
\&    my $depth= 3;
\&    NestedLoops(
\&        [   [ 0..$N ],
\&            ( sub { [$_+1..$N] } ) x ($depth\-1),
\&        ],
\&        \e&Stuff,
\&    );
.Ve
.PP
Then you only have to change \f(CW$depth\fR to 4 to get the same results as:
.PP
.Vb 9
\&    for my $a (  0..$N  ) {
\&     for my $b (  $a+1..$N  ) {
\&      for my $c (  $b+1..$N  ) {
\&       for my $d (  $c+1..$N  ) {
\&          Stuff( $a, $b, $c, $d );
\&       }
\&      }
\&     }
\&    }
.Ve
.PP
\fIUsage\fR
.IX Subsection "Usage"
.PP
The first argument to \fBNestedLoops()\fR is required and must be a reference
to an array.  Each element of the array specifies the values for a single
loop to iterate over.  The first element describes the outermost loop. 
The last element describes the innermost loop.
.PP
If the next argument to NestedLoops is a hash reference, then it
specifies more advanced options.  This argument can be omitted if you
don't need it.
.PP
If the last argument to NestedLoops is a code reference, then it will be
run inside the simulated loops.  If you don't pass in this code
reference, then NestedLoops returns an iterator (described later) so you
can iterate without the restrictions of using a call-back.
.PP
So the possible ways to call NestedLoops are:
.PP
.Vb 4
\&    $iter= NestedLoops( \e@Loops );
\&    $iter= NestedLoops( \e@Loops, \e%Opts );
\&    ...    NestedLoops( \e@Loops, \e%Opts, \e&Code );
\&    ...    NestedLoops( \e@Loops,         \e&Code );
.Ve
.PP
The \*(L"...\*(R"s above show that, when the final code reference is provided,
NestedLoops can return a few different types of information.
.PP
In a void context, NestedLoops simply iterates and calls the provided
code, discarding any values it returns.  (Calling NestedLoops in a void
context without passing a final code reference is a fatal error.)
.PP
In a list context, NestedLoops \f(CW\*(C`push\*(C'\fRes the values returned by each call
to \e&Code onto an array and then returns (copies of the values from) that
array.
.PP
In a scalar contetx, NestedLoops keeps a running total of the number of
values returned by each call to \e&Code and then returns this total.  The
value is the same as if you had called NestedLoops in a list context and
counted the number of values returned (except for using less memory).
.PP
Note that \e&Code is called in a list context no matter what context
NestedLoops was called in (in the current implementation).
.PP
In summary:
.PP
.Vb 3
\&    NestedLoops( \e@loops, \e%opts, \e&code );
\&    $count= NestedLoops( \e@loops, \e%opts, \e&code );
\&    @results= NestedLoops( \e@loops, \e%opts, \e&code );
.Ve
.PP
\e@Loops
.IX Subsection "@Loops"
.PP
Each element of \f(CW@Loops\fR can be
.IP "an array refernce" 4
.IX Item "an array refernce"
which means the loop will iterate over the elements of that array,
.IP "a code refernce" 4
.IX Item "a code refernce"
to a subroutine that will return a reference to the array to loop over.
.PP
You don't have to use a reference to a named array.  You can, of course,
construct a reference to an anonymous array using \f(CW\*(C`[...]\*(C'\fR, as shown in
most of the examples.  You can also use any other type of expression that
rerurns an array reference.
.PP
\e%Opts
.IX Subsection "%Opts"
.PP
If \f(CW%Opts\fR is passed in, then it should only zero or more of the following
keys.  How NestedLoops interprets the values associated with each key are
described below.
.ie n .IP "OnlyWhen => $Boolean" 4
.el .IP "OnlyWhen => \f(CW$Boolean\fR" 4
.IX Item "OnlyWhen => $Boolean"
.PD 0
.IP "OnlyWhen => \e&Test" 4
.IX Item "OnlyWhen => &Test"
.PD
Value must either be a Boolean value or a reference to a subroutine that
will return a Boolean value.
.Sp
Specifying a true value is the same as specifying a routine that always
returns a true value.  Specifying a false value gives you the default
behavior (as if you did not include the OnlyWhen key at all).
.Sp
If it is a code reference, then it is called each time a new item is
selected by any of the loops.  The list of selected items is passed in.
.Sp
The Boolean value returned says whether to use the list of selected
values.  That is, a true value causes either \e&Code to be called (if
specified) or the list to be returned by the iterator (if \e&Code was not
specified).
.Sp
If this key does not exist (or is specified with a false value), then a
default subroutine is used, like:
.Sp
.Vb 1
\&    sub { return @_ == @Loops }
.Ve
.Sp
That is, only complete lists are used (by default).  So:
.Sp
.Vb 5
\&    my @list= NestedLoops(
\&        [  ( [ 1..3 ] ) x 3  ],
\&        {  OnlyWhen => 0  },
\&        sub { "@_" },
\&    );
.Ve
.Sp
is similar to:
.Sp
.Vb 1
\&    my @list= qw/ 111 112 113 121 122 123 131 132 133 211 212 ... /;
.Ve
.Sp
while
.Sp
.Vb 5
\&    my @list= NestedLoops(
\&        [  ( [ 1..3 ] ) x 3  ],
\&        {  OnlyWhen => 1  },
\&        sub { "@_" },
\&    );
.Ve
.Sp
is similar to:
.Sp
.Vb 2
\&    my @list= qw/ 1 11 111 112 113 12 121 122 123
\&                  13 131 132 133 2 21 211 212 ... /;
.Ve
.Sp
Another example:
.Sp
.Vb 5
\&    NestedLoops(
\&        [  ( [ 1..3 ] ) x 3  ],
\&        { OnlyWhen => 1 },
\&        \e&Stuff,
\&    );
.Ve
.Sp
is similar to:
.Sp
.Vb 9
\&    for my $a (  1..3  ) {
\&        Stuff( $a );
\&        for my $b (  1..3  ) {
\&            Stuff( $a, $b );
\&            for my $c (  1..3  ) {
\&                Stuff( $a, $b, $c );
\&            }
\&        }
\&    }
.Ve
.Sp
Last example:
.Sp
.Vb 5
\&    NestedLoops(
\&        [  ( [ 1..3 ] ) x 3  ],
\&        { OnlyWhen => \e&Test },
\&        \e&Stuff,
\&    );
.Ve
.Sp
is similar to:
.Sp
.Vb 10
\&    for my $a (  1..3  ) {
\&        Stuff( $a )   if  Test( $a );
\&        for my $b (  1..3  ) {
\&            Stuff( $a, $b )   if  Test( $a, $b );
\&            for my $c (  1..3  ) {
\&                Stuff( $a, $b, $c )
\&                    if  Test( $a, $b, $c );
\&            }
\&        }
\&    }
.Ve
.PP
\e&Code
.IX Subsection "&Code"
.PP
The subroutine that gets called for each iteration.
.PP
Iterator
.IX Subsection "Iterator"
.PP
If you don't pass in a final code reference to NestedLoops, then
NestedLoops will return an iterator to you (without having performed
any iterations yet).
.PP
The iterator is a code reference.  Each time you call it, it returns the
next list of selected values.  Any arguments you pass in are ignored (at
least in this release).
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Finding non-repeating sequences of digits.
.IX Subsection "Finding non-repeating sequences of digits."
.PP
One way would be to loop over all digit combinations but only selecting
ones without repeats:
.PP
.Vb 10
\&    use Algorithm::Loops qw/ NestedLoops /;
\&    $|= 1;
\&    my $len= 3;
\&    my $verbose= 1;
\&    my $count= NestedLoops(
\&        [   ( [0..9] ) x $len  ],
\&        {   OnlyWhen => sub {
\&                    $len == @_
\&                &&  join(\*(Aq\*(Aq,@_) !~ /(.).*?\e1/;
\&            #or &&  @_ == keys %{{@_,reverse@_}};
\&            }
\&        },
\&        sub {
\&            print "@_\en"   if  $verbose;
\&            return 1;
\&        },
\&    );
\&    print "$count non\-repeating $len\-digit sequences.\en";
\&
\&    0 1 2
\&    0 1 3
\&    0 1 4
\&    0 1 5
\&    0 1 6
\&    0 1 7
\&    0 1 8
\&    0 1 9
\&    0 2 1
\&    ...
\&    9 8 5
\&    9 8 6
\&    9 8 7
\&    720 non\-repeating 3\-digit sequences.
.Ve
.PP
But it would be nice to not waste time looping over, for example
(2,1,2,0,0) through (2,1,2,9,9).  That is, don't even pick 2 as the
third value if we already picked 2 as the first.
.PP
A clever way to do that is to only iterate over lists where the digits
\&\fIincrease\fR from left to right.  That will give us all \fIsets\fR of
non-repeating digits and then we find all permutations of each:
.PP
.Vb 10
\&    use Algorithm::Loops qw/ NestedLoops NextPermute /;
\&    $|= 1;
\&    my $len= 3;
\&    my $verbose= 1;
\&    my $iter= NestedLoops(
\&        [   [0..9],
\&            ( sub { [$_+1..9] } ) x ($len\-1),
\&        ],
\&    );
\&    my $count= 0;
\&    my @list;
\&    while(  @list= $iter\->()  ) {
\&        do {
\&            ++$count;
\&            print "@list\en"   if  $verbose;
\&        } while( NextPermute(@list) );
\&    }
\&    print "$count non\-repeating $len\-digit sequences.\en";
\&
\&    0 1 2
\&    0 2 1
\&    1 0 2
\&    1 2 0
\&    2 0 1
\&    2 1 0
\&    0 1 3
\&    0 3 1
\&    1 0 3
\&    1 3 0
\&    3 0 1
\&    3 1 0
\&    0 1 4
\&    0 4 1
\&    ...
\&    9 6 8
\&    9 8 6
\&    7 8 9
\&    7 9 8
\&    8 7 9
\&    8 9 7
\&    9 7 8
\&    9 8 7
\&    720 non\-repeating 3\-digit sequences.
.Ve
.PP
A third way is to construct the list of values to loop over by excluding
values already selected:
.PP
.Vb 10
\&    use Algorithm::Loops qw/ NestedLoops /;
\&    $|= 1;
\&    my $len= 3;
\&    my $verbose= 1;
\&    my $count= NestedLoops(
\&        [   [0..9],
\&            ( sub {
\&                my %used;
\&                @used{@_}= (1) x @_;
\&                return [ grep !$used{$_}, 0..9 ];
\&            } ) x ($len\-1),
\&        ],
\&        sub {
\&            print "@_\en"   if  $verbose;
\&            return 1;
\&        },
\&    );
\&    print "$count non\-repeating $len\-digit sequences.\en";
\&
\&    0 1 2
\&    0 1 3
\&    0 1 4
\&    0 1 5
\&    0 1 6
\&    0 1 7
\&    0 1 8
\&    0 1 9
\&    0 2 1
\&    0 2 3
\&    ...
\&    9 7 8
\&    9 8 0
\&    9 8 1
\&    9 8 2
\&    9 8 3
\&    9 8 4
\&    9 8 5
\&    9 8 6
\&    9 8 7
\&    720 non\-repeating 3\-digit sequences.
.Ve
.PP
Future releases of this module may add features to makes these last two
methods easier to write.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 955:" 4
.IX Item "Around line 955:"
\&'=item' outside of any '=over'
