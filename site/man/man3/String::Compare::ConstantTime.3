.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "String::Compare::ConstantTime 3"
.TH String::Compare::ConstantTime 3 "2019-06-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Compare::ConstantTime \- Timing side\-channel protected string compare
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use String::Compare::ConstantTime;
\&
\&    if (String::Compare::ConstantTime::equals($secret_data, $user_supplied_data)) {
\&      ## The strings are eq
\&    }
.Ve
.PP
An example with HMACs:
.PP
.Vb 2
\&    use String::Compare::ConstantTime;
\&    use Digest::HMAC_SHA1; ## or whatever
\&
\&    my $hmac_ctx = Digest::HMAC_SHA1\->new($key);
\&    $hmac_ctx\->add($data);
\&    my $digest = $hmac_ctx\->digest;
\&
\&    if (String::Compare::ConstantTime::equals($digest, $candidate_digest)) {
\&      ## The candidate digest is valid
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides one function, \f(CW\*(C`equals\*(C'\fR (not exported by default).
.PP
You should pass this function two strings of the same length. Just like perl's \f(CW\*(C`eq\*(C'\fR, it will return true if they are string-wise identical and false otherwise. However, comparing any two differing strings of the same length will take a fixed amount of time. If the lengths of the strings are different, \f(CW\*(C`equals\*(C'\fR will return false right away.
.PP
\&\fB\s-1NOTE\s0\fR: This does byte-wise comparison of the underlying string storage, meaning that comparing strings with non-ASCII data with different states of the internal \s-1UTF\-8\s0 flag is not reliable.  You should always encode your data to bytes before comparing.
.SH "TIMING SIDE-CHANNEL"
.IX Header "TIMING SIDE-CHANNEL"
Some programs take different amounts of time to run depending on the input values provided to them. Untrusted parties can sometimes learn information you might not want them to know by measuring this time. This is called a \*(L"timing side-channel\*(R".
.PP
Most routines that compare strings (like perl's \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`cmp\*(C'\fR and C's \f(CW\*(C`strcmp\*(C'\fR and \f(CW\*(C`memcmp\*(C'\fR) start scanning from the start of the strings and terminate as soon as they determine the strings won't match. This is good for efficiency but bad because it opens a timing side-channel. If one of the strings being compared is a secret and the other is controlled by some untrusted party, it is sometimes possible for this untrusted party to learn the secret using a timing side-channel.
.PP
If the lengths of the strings are different, because \f(CW\*(C`equals\*(C'\fR returns false right away the size of the secret string may be leaked (but not its contents).
.SH "HMAC"
.IX Header "HMAC"
HMACs are \*(L"Message Authentication Codes\*(R" built on top of cryptographic hashes. The \s-1HMAC\s0 algorithm produces digests that are included along with a message in order to verify that whoever created the message knows a particular secret password, and that this message hasn't been tampered with since.
.PP
To verify a candidate digest included with a message, you re-compute the digest using the message and the secret password. If this computed digest is is the same as the candidate digest then the message is considered authenticated.
.PP
A common side-channel attack against services that verify unlimited numbers of messages automatically is to create a forged message and then just send some random junk as the candidate digest. Continue sending this message and junk digests that vary by the first character. Repeat many times. If you find a particular digest that statistically takes a longer time to be rejected than the other digests, it is probably because this particular digest has the first character correct and the service's final string comparison is running slightly longer.
.PP
At this point, you keep this first character fixed and start varying the second character until it is solved. Repeat until all the characters are solved or until the amount of remaining possibilities are so small you can brute force it. At this point, your candidate digest is considered valid and you have forged a message.
.PP
Note that this particular attack doesn't allow the attacker to recover the secret input key to the \s-1HMAC\s0 but nevertheless can produce a valid digest for any message given enough time because the service that validates the \s-1HMAC\s0 is acting as an \*(L"oracle\*(R".
.PP
\&\fB\s-1NOTE\s0\fR: Although this module protects against a common attack against applications that store state in browser cookies, it is in no way an endorsement of this practise.
.SH "LOCK-PICKING ANALOGY"
.IX Header "LOCK-PICKING ANALOGY"
Pin tumbler locks are susceptible to being picked in a similar way to an attacker forging \s-1HMAC\s0 digests using a timing side-channel.
.PP
The traditional way to pick cheap pin tumbler locks is to apply torque to the lock cylinder so that the pins are pressed against the cylinder. However, because of slight manufacturing discrepancies one particular pin will be the widest by a slight margin and will be pressed against the cylinder tighter than the others (the cheaper the lock, the higher the manufacturing tolerances). The attacker lifts this pin until the cylinder gives a little bit, indicating that this pin has been solved and the next widest pin is now the one being pressed against the cylinder the tightest. This process is repeated until all the pins are solved and the lock opens.
.PP
Just like an attacker trying to solve \s-1HMAC\s0 digests can work on one character at a time, a lock pick can work on each pin in isolation. To protect against this, quality locks force all pins to be fixed into place before the cylinder rotation can be attempted, just as secure \s-1HMAC\s0 verifiers force attackers to guess the entire digest on each attempt.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The String-Compare-ConstantTime github repo <https://github.com/hoytech/String-Compare-ConstantTime>
.PP
Authen::Passphrase has a good section on side-channel cryptanalysis such as it pertains to password storage (mostly, it doesn't).
.PP
The famous \s-1TENEX\s0 password bug <https://web.archive.org/web/20150913074712/http://www.meadhbh.org/services/passwords>
.PP
Example of a timing bug <http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/>
.PP
\&\s-1QSCAN\s0 <http://hcsw.org/nmap/QSCAN>
.PP
Practical limits of the timing side channel <http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf>
.PP
NaCl: Crypto library designed to prevent side channel attacks <http://nacl.cr.yp.to/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Hoyte, \f(CW\*(C`<doug@hcsw.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2012\-2018 Doug Hoyte.
.PP
Contributions from Paul Cochrane.
.PP
This module is licensed under the same terms as perl itself.
