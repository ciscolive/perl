.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "displaytable 3"
.TH displaytable 3 "2020-08-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SNMP \- The Perl5 'SNMP' Extension Module v3.1.0 for the UCD SNMPv3 Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use DBI;
\& use displaytable;
\&
\& $dbh = DBI\->connect(...);
\& $numshown = displaytable($dbh, \*(Aqtablename\*(Aq, [options]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The displaytable and displaygraph functions format the output of a \s-1DBI\s0
database query into an html or graph output.
.SH "DISPLAYTABLE OPTIONS"
.IX Header "DISPLAYTABLE OPTIONS"
.IP "\-select => \s-1VALUE\s0" 4
.IX Item "-select => VALUE"
Selects a set of columns, or functions to be displayed in the resulting table.
.Sp
Example: \-select => 'column1, column2'
.Sp
Default: *
.IP "\-title => \s-1VALUE\s0" 4
.IX Item "-title => VALUE"
Use \s-1VALUE\s0 as the title of the table.
.IP "\-notitle => 1" 4
.IX Item "-notitle => 1"
Don't print a title for the table.
.IP "\-noheaders => 1" 4
.IX Item "-noheaders => 1"
Don't print a header row at the top of the table.
.IP "\-selectorder => 1" 4
.IX Item "-selectorder => 1"
.PD 0
.IP "\-selectorder => [qw(column1 column2)]" 4
.IX Item "-selectorder => [qw(column1 column2)]"
.PD
Defines the order of the columns.  A value of 1 will use the order of
the \-select statement by textually parsing it's comma seperated list.
If an array is passed containing the column names, that order will be
used.
.Sp
Example:
.Sp
.Vb 1
\&  \-select => distinct(column1) as foo, \-selectorder => [qw(foo)]
.Ve
.IP "\-maxrows => \s-1NUM\s0" 4
.IX Item "-maxrows => NUM"
Limits the number of display lines to \s-1NUM.\s0
.IP "\-tableparms => \s-1PARAMS\s0" 4
.IX Item "-tableparms => PARAMS"
.PD 0
.IP "\-headerparms => \s-1PARAMS\s0" 4
.IX Item "-headerparms => PARAMS"
.PD
The parameters to be used for formating the table contents and the
header contents.
.Sp
Defaults:
.Sp
.Vb 1
\&  \-tableparms  => "border=1 bgcolor=\*(Aq#c0c0e0\*(Aq"
\&
\&  \-headerparms => "border=1 bgcolor=\*(Aq#b0e0b0\*(Aq"
.Ve
.IP "\-dolink => \e&FUNC" 4
.IX Item "-dolink => &FUNC"
If passed, \s-1FUNC\s0(name) will be called on the tablename or header.  The
function should return a web url that the header/table name should be
linked to.
.IP "\-datalink => \e&FUNC" 4
.IX Item "-datalink => &FUNC"
Identical to \-dolink, but called for the data portion of the table.
Arguments are the column name and the data element for that column.
.IP "\-printer => \e&FUNC" 4
.IX Item "-printer => &FUNC"
Calls \s-1FUNC\s0(\s-1COLUMNNAME, COLUMNDATA, DATA\s0) to print the data from each
column.  \s-1COLUMNDATA\s0 is the data itself, and \s-1DATA\s0 is a reference to the
hash for the entire row (\s-1IE, COLUMNDATA\s0 = \f(CW$DATA\fR\->{$COLUMNNAME}).
.IP "\-beginhook => \e&FUNC" 4
.IX Item "-beginhook => &FUNC"
.PD 0
.IP "\-endhook => \e&FUNC" 4
.IX Item "-endhook => &FUNC"
.PD
displaytable will call these functions at the beginning and end of the
printing of a row.  Useful for inserting new columns at the beginning
or end of the table.  When the headers to the table are being printed,
they will be called like \s-1FUNC\s0($dbh, \s-1TABLENAME\s0).  When the data is
being printed, they will be called like \s-1FUNC\s0($dbh, \s-1TABLENAME, DATA\s0),
which \s-1DATA\s0 is a reference to the hash containing the row data.
.Sp
Example:
.Sp
.Vb 8
\&  \-endhook => sub { 
\&      my ($d, $t, $data) = @_; 
\&      if (defined($data)) { 
\&          print "<td>",(100 * $data\->{\*(Aqcolumn1\*(Aq} / $data\->{\*(Aqcolumn2\*(Aq}),"</td>";
\&      } else { 
\&          print "<td>Percentage</td>"; 
\&      } 
\&  }
.Ve
.IP "\-clauses => sql_clauses" 4
.IX Item "-clauses => sql_clauses"
Adds clauses to the sql expression.
.Sp
Example: \-clauses => \*(L"where column1 = 'value' limit 10 order by column2\*(R"
.IP "\-xlat => xlattable" 4
.IX Item "-xlat => xlattable"
Translates column headers and the table name by looking in a table for
the appropriate translation.  Essentially uses:
.Sp
.Vb 1
\&  SELECT newname FROM xlattable where oldname = ?
.Ve
.Sp
to translate everything.
.IP "\-editable => 1" 4
.IX Item "-editable => 1"
.PD 0
.IP "\-indexes   => [qw(\s-1INDEX_COLUMNS\s0)]" 4
.IX Item "-indexes => [qw(INDEX_COLUMNS)]"
.IP "\-CGI      => \s-1CGI_REFERENCE\s0" 4
.IX Item "-CGI => CGI_REFERENCE"
.PD
If both of these are passed as arguments, the table is printed in
editable format.  The \s-1INDEX_COLUMNS\s0 should be a list of columns that
can be used to uniquely identify a row.  They will be the non-editable
columns shown in the table.  Everything else will be editable.  The
form and the submit button written by the rest of the script must loop
back to the same displaytable clause for the edits to be committed to
the database.  \s-1CGI_REFERENCE\s0 should be a reference to the \s-1CGI\s0 object
used to query web parameters from ($CGI_REFERENCE = new \s-1CGI\s0);
.IP "\-mark     => 1" 4
.IX Item "-mark => 1"
.PD 0
.IP "\-indexes  => [qw(\s-1INDEX_COLUMNS\s0)]" 4
.IX Item "-indexes => [qw(INDEX_COLUMNS)]"
.IP "\-CGI      => \s-1CGI_REFERENCE\s0" 4
.IX Item "-CGI => CGI_REFERENCE"
.IP "\-onmarked => \e&FUNC" 4
.IX Item "-onmarked => &FUNC"
.PD
When the first three of these are specified, the left hand most column
will be a check box that allows users to mark the row for future work.
.Sp
\&\s-1FUNC\s0($dbh, \s-1TABLENAME, DATA\s0) will be called for each marked entry when
a submission data has been processed.  \f(CW$DATA\fR is a hash reference to
the rows dataset.  See \-editable above for more information.
.Sp
\&\-onmarked => \e&FUNC implies \-mark => 1.
.SH "Author"
.IX Header "Author"
wjhardaker@ucdavis.edu
