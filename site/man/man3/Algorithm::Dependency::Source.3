.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Algorithm::Dependency::Source 3"
.TH Algorithm::Dependency::Source 3 "2020-04-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Algorithm::Dependency::Source \- Implements a source of hierarchy items
.SH "VERSION"
.IX Header "VERSION"
version 1.112
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Algorithm::Dependency::Source class provides an abstract parent class for
implementing sources for the hierarchy data the algorithm will use. For an
example of an implementation of this, see
Algorithm::Dependency::Source::File, which is bundled with the main
Algorithm::Dependency package.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new @arguments"
.el .SS "new \f(CW@arguments\fP"
.IX Subsection "new @arguments"
Although you cannot directly use the \f(CW\*(C`new\*(C'\fR constructor for
\&\f(CW\*(C`Algorithm::Dependency::Source\*(C'\fR, it will work the same in all subclasses.
.PP
The constructor takes zero or more subclass specific arguments to define the
location of the source of the items, and returns a new object. Although it
may check that the arguments you passed are valid, the source will usually
\&\s-1NOT\s0 actually load the items from the source, instead deferring the loading
until you need to use the items.
.PP
Returns a new object on success, or \f(CW\*(C`undef\*(C'\fR on error.
.SS "load"
.IX Subsection "load"
The \f(CW\*(C`load\*(C'\fR method is the public method used to actually load the items from
their storage location into the the source object. The method will
automatically called, as needed, in most circumstances. You would generally
only want to use \f(CW\*(C`load\*(C'\fR manually if you think there may be some uncertainty
that the source will load correctly, and want to check it will work.
.PP
Returns true if the items are loaded successfully, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .SS "item $name"
.el .SS "item \f(CW$name\fP"
.IX Subsection "item $name"
The \f(CW\*(C`item\*(C'\fR method fetches and returns the item object specified by the
name argument.
.PP
Returns an Algorithm::Dependency::Item object on success, or \f(CW\*(C`undef\*(C'\fR if
the named item does not exist in the source.
.SS "items"
.IX Subsection "items"
The \f(CW\*(C`items\*(C'\fR method returns, as a list of objects, all of the items
contained in the source. The item objects will be returned in the same order
as that in the storage location.
.PP
Returns a list of Algorithm::Dependency::Item objects on success, or
\&\f(CW\*(C`undef\*(C'\fR on error.
.SS "missing_dependencies"
.IX Subsection "missing_dependencies"
By default, we are lenient with missing dependencies if the item is never 
used. For systems where having a missing dependency can be very bad, the 
\&\f(CW\*(C`missing_dependencies\*(C'\fR method checks all Items to make sure their 
dependencies exist.
.PP
If there are any missing dependencies, returns a reference to an array of
their ids. If there are no missing dependencies, returns 0. Returns 
\&\f(CW\*(C`undef\*(C'\fR on error.
.SH "EXTENDING"
.IX Header "EXTENDING"
\&\f(CW\*(C`Algorithm::Dependency::Source\*(C'\fR itself is a fairly thin module, and it
is intended that you will probably need to extend it to be able to
extract item data from whatever location you have stored them.
.PP
This is usually a fairly simple two step process.
.ie n .IP "Overload the ""new"" method." 4
.el .IP "Overload the \f(CWnew\fR method." 4
.IX Item "Overload the new method."
Assuming your subclass takes some form or argument on creation, you will
need to overload the \f(CW\*(C`new\*(C'\fR method to accept the arguments, validate them,
and store them in the source object.
.ie n .IP "Define the method ""_load_item_list""." 4
.el .IP "Define the method \f(CW_load_item_list\fR." 4
.IX Item "Define the method _load_item_list."
Leaving our parent's \f(CW\*(C`load\*(C'\fR method to take care of conflict, errors, and
whatever, the \f(CW\*(C`_load_item_list\*(C'\fR method is used to simply create a list of
Algorithm::Dependency::Item objects from wherever you store the item,
and return them as a list.
.PP
Having completed these two things, your subclass should be completed. For
an example of the code, have a look at the source for the simple subclass
Algorithm::Dependency::Source::File.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Algorithm::Dependency, Algorithm::Dependency::Source::File
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Algorithm-Dependency>
(or bug\-Algorithm\-Dependency@rt.cpan.org <mailto:bug-Algorithm-Dependency@rt.cpan.org>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2003 by Adam Kennedy.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
