.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Shell::Cmd 3"
.TH Shell::Cmd 3 "2019-08-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Shell::Cmd \- run shell commands with enhanced support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Shell::Cmd;
\&
\&   $obj = new Shell::Cmd;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A very common use of perl is to act as a wrapper around shell commands
where perl is used to prepare the shell commands, execute them, and
deal with the resulting output.  Even where the bulk of the work is
actually done in the perl script, creating small shell scripts within
it to do some portion of the task is common.
.PP
In the simplest form, running shell commands can be done very simply
using the \f(CW\*(C`system()\*(C'\fR call, backticks, or several other ways, but I
usually find myself wanting to do a bit (and sometimes a lot) more,
especially when I am writing a long-term script that I want to be
robust.  In these cases, I frequently ended up writing a subroutine to
run the shell command(s) for me with added functionality.
.PP
This module is designed to take a list of shell commands and
automatically turn them into a shell script (using only basic shell
commands which are available in any bourne shell variation) which adds
some common desirable functionality including:
.IP "Handle \s-1STDOUT/STDERR\s0" 4
.IX Item "Handle STDOUT/STDERR"
Commonly, I want to treat \s-1STDOUT\s0 and \s-1STDERR\s0 in some way.  I may want
to keep one or both of them, or discard one or both of them, or merge
them.
.IP "Command echoing" 4
.IX Item "Command echoing"
A common option I want to set is command echoing where the commands I
run are echoed as they are run.  I want to be able to easily turn this
on or off (typically with a command line option in the calling script).
.IP "Dry-run" 4
.IX Item "Dry-run"
Another common option is to create a dry-run environment where the
shell commands may be printed, but not actually run.  Again, I want to
be able to turn this on and off easily.
.IP "Error trapping" 4
.IX Item "Error trapping"
Even though I may combine a number of shell commands into a single
script (so that it all runs in one shell), I still want to have built
in error trapping at a per-command basis.  I want to take a series of
commands and know exactly which one failed.  If I execute the commands
one at a time, I can get that information, but typically, I want to
combine multiple commands in a single script but still have that
ability.
.Sp
I also want to be able to control what happens to commands that are
listed after a failed command.  I may want to ignore an error and
continue to run the remaining commands.  I may want to simply exit.
Or I may want to echo, but not run the remaining commands so that I
can see what didn't get completed.
.IP "Shell environment" 4
.IX Item "Shell environment"
I sometimes want to set up some environment for the script such as
what directory it will be run in and what environment variables should
be set in advance.
.IP "Command alternates" 4
.IX Item "Command alternates"
Sometimes, especially if you are running the script on multiple
platforms, you may not know which command you should use.  You can of
course generate a platform specific script, but an alternative is to
specify alternate commands.  If \s-1ANY\s0 of those commands succeed, then
that portion of the script succeeds.
.IP "Command retrying" 4
.IX Item "Command retrying"
Occasionally you have a command that may fail, but on retrying, it
will succeed.  This is especially true when some effect from a
previous command takes some amount of time to actually go into effect.
By allowing a certain number of retries, you can often work around
this situation.
.IP "Remote execution" 4
.IX Item "Remote execution"
Sometimes you want to run the commands locally.  Other times, you want
to run it remotely using ssh.  When running remotely, you may want to
run the same script on multiple hosts.
.IP "\s-1SSH\s0 handling" 4
.IX Item "SSH handling"
When running on multiple hosts using \s-1SSH,\s0 sometimes you need to run
the script serially (i.e. one host at a time), but other times, it
would be nice to run it in parallel to speed up execution.  When
running in parallel, you should be able specify how many instances to
run at at time.
.IP "Quoting and special characters" 4
.IX Item "Quoting and special characters"
Since shell commands often have quotes, dollar signs, and other special
characters, this module can handle that for you by properly escaping them
as necessary.
.PP
This module is designed to run multiple commands in a single shell,
wrapping them in very simple, standard shell commands to automatically
add all of this functionality.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&   $obj = new Shell::Cmd;
.Ve
.Sp
This creates a new object containing commands.
.IP "\fBversion\fR" 4
.IX Item "version"
.Vb 1
\&   $vers = $obj\->version();
.Ve
.Sp
Returns the version of this module.
.IP "\fBcmd\fR" 4
.IX Item "cmd"
.Vb 1
\&   $err = $obj\->cmd($cmd [,\e%options], $cmd [,\e%options], ...);
.Ve
.Sp
This is used to add one or more commands to the list of commands that
will be executed.
.Sp
Here, each \f(CW$cmd\fR is either a string containing a command, or a
listref where each element in the list is a string containing a
command.
.Sp
In the listref form, the list of commands are alternates to try until
one succeeds, and the command only fails if all of the alternates
fail.  This might be used to specify different paths to an executable,
or different executables that perform essentially the same function,
but which might not all be available on all platforms.
.Sp
For example, if you wanted to run a command to get the contents of a
web site, and you didn't know which of curl, wget, or lftp were
available, you might use something like this:
.Sp
.Vb 1
\&   $err = $obj\->cmd([ "wget $URL", "curl $URL", "lftp $URL"]);
.Ve
.Sp
and in this case, it would try wget, and if that failed, it would try
curl, and if that failed, it would try lftp.  The command will only
fail if all three alternates fail.
.Sp
Each command (or list of alternates) can have options passed in.
These options apply only to this command (or list), and are described
in the \*(L"PER-COMMAND \s-1OPTIONS\*(R"\s0 section below.
.Sp
All of the commands stored in \f(CW$obj\fR will be run in a single shell,
so it is fine to gather information in one command and store it in a
shell variable for use in a later command.  Commands must not include
a trailing semi-colon as these will interfere with I/O redirection,
and will be added automatically as needed.
.Sp
An error is returned if any of the arguments are invalid.
.Sp
It should be noted that no attempt is made to see if the syntax of the
shell command is correct.  That is beyond the scope of this module.
.Sp
If only simple lists of commands are used, handling them is relatively
straightforward, but trying to include commands that affect the flow
of the script (such as \f(CW\*(C`while...done\*(C'\fR, \f(CW\*(C`if...else\*(C'\fR, and the like)
then handling can be much more complicated.  Refer to the \*(L"\s-1FLOW
COMMANDS\*(R"\s0 section below.  Defining functions is \s-1NOT\s0 supported.
.IP "\fBrun\fR" 4
.IX Item "run"
.Vb 1
\&   $ret = $obj\->run();
.Ve
.Sp
This prepares a shell script based on the commands and options entered
and runs it as appropriate.  The script is stored in a temporary file that
can be set using the \fBtmp_script\fR option (refer to the \*(L"\s-1GLOBAL OPTIONS\*(R"\s0
section below).
.Sp
There are several different ways in which the commands can be run, and
these are described in the \fBoptions\fR method below.  The most
important option is the \fBmode\fR option which determines the form of
the script, and how it is run.
.Sp
If the mode is \fBrun\fR, the method is called as:
.Sp
.Vb 1
\&   $err = $obj\->run();
.Ve
.Sp
In this mode, the script is run, and output is sent directly to \s-1STDOUT\s0
and \s-1STDERR\s0 as appropriate for the options specified.  In essence, this
generates a script and runs it with the \f(CW\*(C`system()\*(C'\fR call.
.Sp
The error code returned is described below in the \*(L"\s-1ERROR CODES\*(R"\s0 section.
.Sp
In \fBdry-run\fR mode, the method is called as:
.Sp
.Vb 1
\&   $script = $obj\->run();
.Ve
.Sp
In this mode, the commands are not actually executed.  Instead, the
script is built and returned.  The form of the script is determined by
the \fBscript\fR option described below.
.Sp
In \fBscript\fR mode, the method is called as:
.Sp
.Vb 1
\&   $err = $obj\->run();
.Ve
.Sp
In this case, the output from the commands are kept for further
analysis.  The \f(CW\*(C`$obj\-\*(C'\fRoutput(...)> method may then be used to examine
the resulting output.
.Sp
The error codes are described in the \*(L"\s-1ERROR CODES\*(R"\s0 section below.
.IP "\fBssh\fR" 4
.IX Item "ssh"
This behaves similar to the \f(CW\*(C`run\*(C'\fR method except it will run the commands on
each host in \f(CW@hosts\fR using ssh.  The return values for each mode are
identical to the return methods from the \f(CW\*(C`run\*(C'\fR method except that for both
the \fBrun\fR mode and \fBscript\fR mode, the output is returned as a hash where
the keys are the hosts and the values are the value for that host.
.Sp
For example, in \fBrun\fR mode, the call would be:
.Sp
.Vb 1
\&   %err = $obj\->ssh(@hosts)
.Ve
.Sp
In \fBdry-run\fR mode, the call is identical to the \fBrun\fR method, and it
will return the script that would be run on each host.
.Sp
.Vb 1
\&   $script = $obj\->ssh(@hosts);
.Ve
.Sp
Note that when running in parallel in \fBrun\fR mode, the output that is
printed to the terminal will be a mix of the output from each of the
hosts the commands are being run on.
.IP "\fBoutput\fR" 4
.IX Item "output"
.Vb 3
\&   $ret = $obj\->output(%options);
\&   @ret = $obj\->output(%options);
\&   %ret = $obj\->output(%options);
.Ve
.Sp
This will return the output produced by running the commands in \fBscript\fR
mode depending on the options passed in.
.Sp
The \f(CW%options\fR argument is described below in the \fB\s-1OUTPUT OPTIONS\s0\fR section.
.IP "\fBflush\fR" 4
.IX Item "flush"
.Vb 1
\&   $obj\->flush( [@opts] );
.Ve
.Sp
If \f(CW@opts\fR is not given, it removes all the data stored in the object,
resetting it to a clean object.  If \f(CW@opts\fR is given, you can clear specific
parts of the object.  Any of the following options can be given:
.Sp
.Vb 5
\&   commands   : clears all commands and their options
\&   env        : clears the environment
\&   opts       : clears all options
\&   out        : clears the output from running the command
\&                in B<script> mode
.Ve
.IP "\fBdire\fR" 4
.IX Item "dire"
.Vb 1
\&   $err = $obj\->dire($dire);
.Ve
.Sp
This method is used to set the \fBdire\fR option.  For a description, please
see the entry in \*(L"\s-1GLOBAL OPTIONS\*(R"\s0 below.  This is a shortcut for:
.Sp
.Vb 1
\&   $err = $obj\->options(\*(Aqdire\*(Aq,$dire);
.Ve
.Sp
You can also check the value that is set using:
.Sp
.Vb 1
\&   $dire = $obj\->dire();
.Ve
.IP "\fBmode\fR" 4
.IX Item "mode"
.Vb 1
\&   $err = $obj\->mode($mode);
.Ve
.Sp
This method is used to set the \fBmode\fR option.  For a description, please
see the entry in \*(L"\s-1GLOBAL OPTIONS\*(R"\s0 below.  This is a shortcut for:
.Sp
.Vb 1
\&   $err = $obj\->options(\*(Aqmode\*(Aq,$dire);
.Ve
.Sp
You can also check the value that is set using:
.Sp
.Vb 1
\&   $mode = $obj\->mode();
.Ve
.IP "\fBenv\fR" 4
.IX Item "env"
.Vb 1
\&   $obj\->env($var1, $val1, $var2, $val2, ...);
.Ve
.Sp
This can be called any number of times to set some environment
variables.  If \f(CW$val\fR is undef, the environment variable will be
explicitly unset.
.Sp
You can also query the environment variables with:
.Sp
.Vb 1
\&   %env = $obj\->env();
.Ve
.IP "\fBoptions\fR" 4
.IX Item "options"
.Vb 1
\&   $err = $obj\->options(%options);
.Ve
.Sp
This can be used to set some options about what will be done when the
commands are run.
.Sp
The hash is of the form:
.Sp
.Vb 2
\&   %options = ( OPTION => VALUE,
\&                OPTION => VALUE, ...)
.Ve
.Sp
The options are defined in the \*(L"\s-1GLOBAL OPTIONS\*(R"\s0 section below.
.SH "ERROR CODES"
.IX Header "ERROR CODES"
The error code returned by the \fBrun\fR or \fBssh\fR methods are described
in the following table:
.PP
.Vb 10
\&   0       No error
\&   1\-200   The number of the command that failed.
\&           Commands entered with the B<cmd> method
\&           are numbered starting at 1.  If 200 or
\&           less commands are entered, the error code
\&           will correspond to the command that
\&           failed.
\&   201     If more than 200 commands are entered,
\&           and any of them beyond the 200th fail,
\&           the error code will be 201.
\&   252     An error in the script.  Usually this
\&           indicates that flow commands not correctly
\&           nested/closed.
\&   253     If the temporary script cannot
\&           be copied to a remote host (for use in
\&           the B<ssh> method), this is returned.
\&   254     If a temporary script could not be
\&           created, this will be returned.
\&   255     If a global directory was specified that
\&           does not exist, this will be returned.
.Ve
.SH "GLOBAL OPTIONS"
.IX Header "GLOBAL OPTIONS"
The following global options exist can can be set using the \fBoptions\fR
method:
.IP "\fBmode\fR" 4
.IX Item "mode"
The \fBmode\fR option determines how the commands will be handled by the \fBrun/ssh\fR
methods.  The following values are available.
.Sp
.Vb 3
\&   run      (default)
\&   dry\-run
\&   script
.Ve
.Sp
The \fBrun\fR mode is the standard way to run commands in an interactive
setting.  It will run the commands in real-time and allow you to watch
\&\s-1STDOUT\s0 and/or \s-1STDERR\s0 (depending on the options you choose) as they run.
.Sp
The \fBdry-run\fR mode will not execute any commands.  Instead, it will generate
a script that \s-1WOULD\s0 have been run and returns it.  The script can take
several different forms, and is described in the \fBscript\fR option below.
.Sp
The \fBscript\fR mode is more appropriate for running in an unattended
script.  It gathers the output and post-processes it allowing for more
useful handling of the output.  For example, you could discard the output
from commands that succeed and keep only the output for the one that
failed, or a number of other options.
.Sp
The \fBmode\fR option can also be set using the \fBmode\fR method.
.IP "\fBdire\fR" 4
.IX Item "dire"
The \fBdire\fR option is use to specify the directory where all of the
the commands should be run.  This can be overridden on a per-command
basis using per-command options in the \fBcmd\fR method, but all commands
not specifically set will run in this directory.
.Sp
This does \s-1NOT\s0 check the existence of the directory until the commands
are actually run since the commands may be run via. ssh.
.Sp
The \fBdire\fR option can also be set using the \fBdire\fR method.
.IP "\fBoutput\fR" 4
.IX Item "output"
The \fBoutput\fR option can be one of the following:
.Sp
.Vb 5
\&   both     (default)
\&   merged
\&   stdout
\&   stderr
\&   quiet
.Ve
.Sp
In the \fBrun\fR mode, these determine what output will be displayed.  In
\&\fBscript\fR mode, it determines which output is stored in the object.
Obviously, if output is not kept, it will not be available to examine
using the \f(CW\*(C`output\*(C'\fR method.
.Sp
It can display only \s-1STDOUT,\s0 only \s-1STDERR,\s0 or both, or both can be
discarded with the 'quiet' option.  The default is to include 'both'.
The 'merged' option is used to display both but merge \s-1STDERR\s0 into
\&\s-1STDOUT\s0 (using a \f(CW\*(C`2>&1\*(C'\fR redirection).
.IP "\fBscript\fR" 4
.IX Item "script"
The \fBscript\fR option is used only in \fBdry-run\fR mode.
.Sp
When commands are run in \fBdry-run\fR mode, a script is produced.  The form
of that script is controlled by this option.  The value may be any of:
.Sp
.Vb 3
\&   run     (default)
\&   script
\&   simple
.Ve
.Sp
If the value is \fBrun\fR or \fBscript\fR, the script produced will be exactly
the script produced in those modes, including all of the wrapping shell
structure to add the requested functionality.
.Sp
If the value is \fBsimple\fR, the script will simply be the list of commands
with the minimum necessary additions to handle directory and environment
variables.  No additional scripting will be added to do error checking
or add other functionality.
.IP "\fBecho\fR" 4
.IX Item "echo"
The \fBecho\fR option is used only in \fBrun\fR mode.  With it, you can choose
whether or not the commands should be displayed when they are run.
.Sp
The values are:
.Sp
.Vb 3
\&   echo
\&   noecho
\&   failed
.Ve
.Sp
With \fBecho\fR and \fBnoecho\fR values, commands will be displayed or \s-1NOT\s0
displayed respectively.  With \fBecho\fR the commands will be displayed
before they are run.
.Sp
If the value is \fBfailed\fR, a command that failed will be displayed.  Since
it has already run, the command will be echoed after execution rather than
before.
.Sp
Note that flow commands are not echoed.
.IP "\fBfailure\fR" 4
.IX Item "failure"
The \fBfailure\fR option is used in \fBrun\fR and \fBscript\fR modes.  When a
command fails, there are several alternatives that can be done.
Values for this option are:
.Sp
.Vb 3
\&   exit
\&   display
\&   continue
.Ve
.Sp
The default is \fBexit\fR.  With this option, the script will stop
executing commands once one has failed.
.Sp
The \fBdisplay\fR option is only used in \fBrun\fR mode.  With it, if any
command fails, a simple script will be displayed showing what commands
failed to run.
.Sp
With the \fBcontinue\fR option, remaining command are executed, but the
overall exit values is still set to point at the first failed command.
.IP "\fBtmp_script, tmp_script_keep\fR" 4
.IX Item "tmp_script, tmp_script_keep"
The \fBtmp_script\fR option is used to specify a temporary script name.
.Sp
The script that is generated by this module may exceed the length of a
string that can be passed directly to a shell.  In order to avoid this
problem, the script will be stored in a temporary script file (set with
the \fBtmp_script\fR option) which will be executed.  If not set, the
default value for \fBtmp_script\fR will be:
.Sp
.Vb 1
\&   /tmp/.cmd.shell.$$
.Ve
.Sp
Once execution is complete, the temporary script file will be removed
unless the \fBtmp_script_keep\fR option is set.
.IP "\fBssh_script, ssh_script_keep\fR" 4
.IX Item "ssh_script, ssh_script_keep"
These are related to the \fBtmp_script\fR and \fBtmp_script_keep\fR options.
If \fBtmp_script\fR is created, then when the \fBssh\fR method is used to
run the script remotely, it is copied to the remote host (via. scp)
to a temporary location (given by \fBssh_script\fR).  The remote script
is then removed (unless \fBssh_script_keep\fR is passed in).
.Sp
If \fBtmp_script\fR is set but \fBssh_script\fR is \s-1NOT,\s0 \fBssh_script\fR
defaults to the same value as \fBtmp_script\fR.
.Sp
\&\fBssh_script_keep\fR defaults to 0, even if \fBtmp_script_keep\fR is set.
.IP "\fBssh_num\fR" 4
.IX Item "ssh_num"
When running a command on multiple hosts via \s-1SSH,\s0 it is possible to run
them serially (one at a time) or in parallel.
.Sp
This option can be set to a number 0 or more.  If the number is 1, then
only a single ssh connection will be made at a time so the hosts will all
be contacted serially.
.Sp
If the option is set to 0, all of the hosts will be run simultaneously.
.Sp
If the option is set to N, N simultaneous connections will be allowed
and additional hosts will be run only after others have completed.
.IP "\fBssh_sleep\fR" 4
.IX Item "ssh_sleep"
When running a command on multiple hosts via \s-1SSH,\s0 it is sometimes
desirable to stagger them slightly so multiple copies are running at
the same time, but not at \s-1EXACTLY\s0 the same time.
.Sp
If this option is set to 0 (the default), all of the commands will be
run with no delay.  If it is set to the value N, commands will sleep
a random amount of time (from 0 to N seconds) before running.  If it is
set to a negative value \-N, it will sleep for exactly N seconds.
.IP "\fBssh:XXX\fR" 4
.IX Item "ssh:XXX"
When running a command on a remote host via. ssh, the Net::OpenSSH module
is used.
.Sp
Every option that can be passed to the \f(CW\*(C`Net::OpenSSH::new\*(C'\fR method can
be set here.  For example, if you want to call Net::OpenSSH as:
.Sp
.Vb 1
\&   $ssh = Net::OpenSSH\->new($host, user => $user_name);
.Ve
.Sp
just set the option:
.Sp
.Vb 1
\&   ssh:user = $user_name
.Ve
.SH "PER-COMMAND OPTIONS"
.IX Header "PER-COMMAND OPTIONS"
The following options exists that can be applied to individual commands.
They can be set in the \fBcmd\fR method.
.IP "\fBdire\fR" 4
.IX Item "dire"
The \fBdire\fR option refers to the directory which this single command
should be executed in.  The value of the option is the directory.
.Sp
This will basically wrap a command in:
.Sp
.Vb 4
\&   CURR_DIR=\`pwd\`
\&   cd $dire
\&   COMMAND
\&   cd $CURR_DIR
.Ve
.IP "\fBnoredir\fR" 4
.IX Item "noredir"
If the \fBnoredir\fR option is included, no command line redirection is
done for this command.  Most commands automatically redirect \s-1STDOUT\s0
and \s-1STDERR\s0 based on the \fBoutput\fR global option.
.Sp
If the command explicitly sends these to somewhere (such as a log file
or temporary file), use the \fBnoredir\fR option so automatic redirection
is not done.
.Sp
Since the command is not parsed to see whether or not redirection is
handled by the command, this option must be used with every shell
command which includes any type of I/O redirection.
.IP "\fBretry\fR, \fBsleep\fR" 4
.IX Item "retry, sleep"
The \fBretry\fR and \fBsleep\fR options can be used to retry a command.
.Sp
Sometimes, a command may fail but running it a second time can succeed.
Often, a command completes, but for various reasons, it takes a
certain amount of time after the command completes for the full results
to take effect.  A later command might be run before those results have
taken effect, but rerunning it a few seconds later would succeed.
.Sp
With the \fBretry\fR option, you can retry a command.  The value of the
\&\fBretry\fR option should be an integer (N).  If N is greater than 1,
the command will be run up to N times total.  Any other value of N
will be ignored, and the command will run only a single time.
.Sp
There can be an optional sleep time between running the command.  The
optional \fBsleep\fR option (which should also be an integer) sets the
number of seconds between retries.  If the value is 0, or not an
integer, there will be no delay between retries.
.Sp
This command will be marked as failed only if all of the retries fail.
.Sp
You cannot retry a flow command.
.IP "\fBcheck\fR" 4
.IX Item "check"
Sometimes, a command is written such that the exit code does not
accurately reflect whether the command failed or not.  It may produce
a zero exit code but still have failed, or it may have succeeded but
still produce an error code.
.Sp
In these cases, you can supply a command with this option which will
check the result of the command and set the error flag appropriately.
.Sp
If the command succeeded, the error flag should be set to zero.  If
it failed, it should be set to something non-zero.
.Sp
If this is given for a command which has alternatives, it will be run
after every alternative.
.IP "\fBlabel\fR" 4
.IX Item "label"
Each command can have a label attached to it which will allow you
to refer to that command by the label.  This is useful in analyzing
the output.
.Sp
The label should not consist only of digits (i.e. be an integer).
.SH "FLOW COMMANDS"
.IX Header "FLOW COMMANDS"
When simple shell commands are given, there is no ambiguity about how
to treat each, so handling them is relatively simple.  Simple commands
are fully supported, and all of the functionality described above can
be added.
.PP
In order to add the desired functionality, the commands are wrapped
with some enclosing shell structure using very basic shell command
which add the requested features.  Simple command are very easy to
wrap in a basic enclosing shell structure.  For example, it is easy to
turn:
.PP
.Vb 1
\&   mycommand arg1 arg2
.Ve
.PP
into
.PP
.Vb 5
\&   if [ SOME_CONDITION ]; then
\&      DO_SOMETHING
\&      mycommand arg1 arg2
\&      DO_SOMETHING
\&   fi
.Ve
.PP
However, when commands are added which affect the flow of the script,
they must be handled differently than simple commands in order to deal
with them properly.  Wrapping them in other shell structure would
produce invalid shell scripts.  As a result, each type of flow must be
considered carefully.
.PP
Currently, the supported flow commands are:
.ie n .IP """if...elsif...else...fi""" 4
.el .IP "\f(CWif...elsif...else...fi\fR" 4
.IX Item "if...elsif...else...fi"
In order to recognize them, the commands will be partially parsed, and they
must be of the forms:
.Sp
.Vb 4
\&   if ... ; then
\&   elif ... ; then
\&   else
\&   fi
.Ve
.Sp
where '...' may be any string.  In other words, the first line must start with
if, followed by whitespace, and end with a ';' followed by optional whitespace,
followed by 'then'.
.Sp
The alternate formatting of:
.Sp
.Vb 3
\&   if ...
\&   then
\&   fi
.Ve
.Sp
is not supported.
.ie n .IP """while...done""" 4
.el .IP "\f(CWwhile...done\fR" 4
.IX Item "while...done"
.PD 0
.ie n .IP """until...done""" 4
.el .IP "\f(CWuntil...done\fR" 4
.IX Item "until...done"
.ie n .IP """for...done""" 4
.el .IP "\f(CWfor...done\fR" 4
.IX Item "for...done"
.PD
The commands must be of the form:
.Sp
.Vb 4
\&   while ... ; do
\&   until ... ; do
\&   for ... ; do
\&   done
.Ve
.PP
If flow commands are entered, but not correctly closed and/or nested,
an error will be returned.
.PP
Also, flow commands must generally be simple tests.  If complex shell
commands are entered which produce output, this output will \s-1NOT\s0 be
handled correctly, and may actually break things when running in
\&\fBscript\fR mode.
.PP
At some point, the \f(CW\*(C`select\*(C'\fR and \f(CW\*(C`case\*(C'\fR structures may be supported, but
this in not yet available.
.PP
Also, shell functions are not currently supported.
.SH "OUTPUT OPTIONS"
.IX Header "OUTPUT OPTIONS"
When commands are run in the 'script' mode, the output is stored in the
object.
.PP
To access the output, use one of the following calls to the \fBoutput\fR
method:
.PP
.Vb 1
\&   $obj\->output(%options);
.Ve
.PP
Each call to the method will return one part of the output.  To following
options may be used to determine what is returned.
.IP "\fBhost=HOST\fR" 4
.IX Item "host=HOST"
If the output was generated using the \fBssh\fR method, this option is required
(since it is possible to run the commands both locally and remotely, and the
output is stored separately).
.Sp
\&\fB\s-1HOST\s0\fR can be any of:
.Sp
.Vb 2
\&   all      The output for all hosts will be returned.  The return value
\&            will be a hash of the form:
\&
\&               %ret = ( HOST1 => OUTPUT1, HOST2 => OUTPUT2, ...)
\&
\&   HOST1,HOST2,...
\&            The output for all of the hosts listed will be returned in a
\&            hash
\&
\&   HOST     If only a single host is specified, the output for only
\&            that host will be returned.  It will not be returned as a hash.
.Ve
.IP "\fBoutput=TYPE\fR" 4
.IX Item "output=TYPE"
This tells what output will be returned.  \fB\s-1TYPE\s0\fR can be any of:
.Sp
.Vb 2
\&   stdout   STDOUT will be returned for the command(s) selected.
\&            This is the default.
\&
\&   stderr   STDERR will be returned for the command(s) selected.
\&
\&   command  The command itself will be returned.
\&
\&   num      The command number will be returned.
\&
\&   label    The command label (if any) will be returned.
\&
\&   exit     The exit code will be returned for the command(s) selected.
\&            The exit code is the one returned by the final alternative
\&            on the final try.
.Ve
.IP "\fBcommand=COMMAND\fR" 4
.IX Item "command=COMMAND"
This tells which commands will be included in the output.  \fB\s-1COMMAND\s0\fR can
be any of:
.Sp
.Vb 3
\&   curr     An internal flag is kept which starts at the 1st command
\&            which produced any type of output. The value is returned
\&            for this command.  This is the default.
\&
\&   next     The internal flag is incremented, and that becomes the new
\&            current command.
\&
\&   all      The value for all commands will be returned in the order they
\&            occurred.
\&
\&   CMD_NUM  The commands are numbered starting at 1.  This will return the
\&            output for only the command given.  Note however that a command
\&            may occur multiple times (due to retries, being in a loop, etc.)
\&            so the output will be a list of values, one per occurrence.
\&
\&   LABEL    This will return the output for all commands assigned the
\&            given label (using the per\-command B<label> option).  Multiple
\&            commands may be assigned the same label, so the output from
\&            all occurrences of all commands with this label will be returned
\&            as a list.
\&
\&   fail     This will return the output for the command that failed (if any).
.Ve
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
.IP "\fBMinimal support for complex scripts\fR" 4
.IX Item "Minimal support for complex scripts"
These methods work best for simple lists of commands.  Using simple command
flow (<if...then...else>, etc.) is allowed, but must be used carefully.  The
use of functions is \s-1NOT\s0 supported and will not work.
.IP "\fBMaximum of 200 commands fully supported\fR" 4
.IX Item "Maximum of 200 commands fully supported"
In order to determine which command fails, a unique error code is
assigned to each command.  Since exit codes must be between 0\-255, and
some are reserved, there is a limit of 200 commands that can be
entered if accurate error tracking is needed.
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
