.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object::Space 3"
.TH Data::Object::Space 3 "2020-07-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object::Space \- Namespace Class
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Namespace Class for Perl 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/bar\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides methods for parsing and manipulating package namespaces.
.SH "INHERITS"
.IX Header "INHERITS"
This package inherits behaviors from:
.PP
Data::Object::Name
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Types::Standard
.SH "METHODS"
.IX Header "METHODS"
This package implements the following methods:
.SS "all"
.IX Subsection "all"
.Vb 1
\&  all(Str $name, Any @args) : ArrayRef[Tuple[Str, Any]]
.Ve
.PP
The all method executes any available method on the instance and all instances
representing packages inherited by the package represented by the invocant.
.IP "all example #1" 4
.IX Item "all example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqdata/object/space\*(Aq);
\&
\&  $space\->all(\*(Aqid\*(Aq);
\&
\&  # [
\&  #   [\*(AqData::Object::Space\*(Aq, \*(AqData_Object_Space\*(Aq],
\&  #   [\*(AqData::Object::Name\*(Aq, \*(AqData_Object_Name\*(Aq],
\&  # ]
.Ve
.SS "append"
.IX Subsection "append"
.Vb 1
\&  append(Str @args) : Object
.Ve
.PP
The append method modifies the object by appending to the package namespace
parts.
.IP "append example #1" 4
.IX Item "append example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->append(\*(Aqbaz\*(Aq);
\&
\&  # \*(AqFoo/Bar/Baz\*(Aq
.Ve
.IP "append example #2" 4
.IX Item "append example #2"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->append(\*(Aqbaz\*(Aq, \*(Aqbax\*(Aq);
\&
\&  # $space\->package;
\&
\&  # \*(AqFoo/Bar/Baz/Bax\*(Aq
.Ve
.SS "array"
.IX Subsection "array"
.Vb 1
\&  array(Str $arg1) : ArrayRef
.Ve
.PP
The array method returns the value for the given package array variable name.
.IP "array example #1" 4
.IX Item "array example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our @handler = \*(Aqstart\*(Aq;
\&
\&  package main;
\&
\&  $space\->array(\*(Aqhandler\*(Aq)
\&
\&  # [\*(Aqstart\*(Aq]
.Ve
.SS "arrays"
.IX Subsection "arrays"
.Vb 1
\&  arrays() : ArrayRef
.Ve
.PP
The arrays method searches the package namespace for arrays and returns their
names.
.IP "arrays example #1" 4
.IX Item "arrays example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our @handler = \*(Aqstart\*(Aq;
\&  our @initial = (\*(Aqnext\*(Aq, \*(Aqprev\*(Aq);
\&
\&  package main;
\&
\&  $space\->arrays
\&
\&  # [\*(Aqhandler\*(Aq, \*(Aqinitial\*(Aq]
.Ve
.SS "authority"
.IX Subsection "authority"
.Vb 1
\&  authority() : Maybe[Str]
.Ve
.PP
The authority method returns the \f(CW\*(C`AUTHORITY\*(C'\fR declared on the target package,
if any.
.IP "authority example #1" 4
.IX Item "authority example #1"
.Vb 1
\&  package Foo::Boo;
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/boo\*(Aq);
\&
\&  $space\->authority
\&
\&  # undef
.Ve
.IP "authority example #2" 4
.IX Item "authority example #2"
.Vb 1
\&  package Foo::Boo;
\&
\&  our $AUTHORITY = \*(Aqcpan:AWNCORP\*(Aq;
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/boo\*(Aq);
\&
\&  $space\->authority
\&
\&  # \*(Aqcpan:AWNCORP\*(Aq
.Ve
.SS "base"
.IX Subsection "base"
.Vb 1
\&  base() : Str
.Ve
.PP
The base method returns the last segment of the package namespace parts.
.IP "base example #1" 4
.IX Item "base example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->base
\&
\&  # Bar
.Ve
.SS "bless"
.IX Subsection "bless"
.Vb 1
\&  bless(Any $arg1 = {}) : Object
.Ve
.PP
The bless method blesses the given value into the package namespace and returns
an object. If no value is given, an empty hashref is used.
.IP "bless example #1" 4
.IX Item "bless example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  sub import;
\&
\&  package main;
\&
\&  $space\->bless
\&
\&  # bless({}, \*(AqFoo::Bar\*(Aq)
.Ve
.IP "bless example #2" 4
.IX Item "bless example #2"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  sub import;
\&
\&  package main;
\&
\&  $space\->bless({okay => 1})
\&
\&  # bless({okay => 1}, \*(AqFoo::Bar\*(Aq)
.Ve
.SS "build"
.IX Subsection "build"
.Vb 1
\&  build(Any @args) : Object
.Ve
.PP
The build method attempts to call \f(CW\*(C`new\*(C'\fR on the package namespace and if successful returns the resulting object.
.IP "build example #1" 4
.IX Item "build example #1"
.Vb 1
\&  package Foo::Bar::Baz;
\&
\&  sub new {
\&    bless {}, $_[0]
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/bar/baz\*(Aq);
\&
\&  $space\->build
\&
\&  # bless({}, \*(AqFoo::Bar::Baz\*(Aq)
.Ve
.IP "build example #2" 4
.IX Item "build example #2"
.Vb 1
\&  package Foo::Bar::Bax;
\&
\&  sub new {
\&    bless $_[1], $_[0]
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/bar/bax\*(Aq);
\&
\&  $space\->build({okay => 1})
\&
\&  # bless({okay => 1}, \*(AqFoo::Bar::Bax\*(Aq)
.Ve
.SS "call"
.IX Subsection "call"
.Vb 1
\&  call(Any @args) : Any
.Ve
.PP
The call method attempts to call the given subroutine on the package namespace
and if successful returns the resulting value.
.IP "call example #1" 4
.IX Item "call example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo;
\&
\&  sub import;
\&
\&  sub start {
\&    \*(Aqstarted\*(Aq
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  $space = Data::Object::Space\->new(\*(Aqfoo\*(Aq);
\&
\&  $space\->call(\*(Aqstart\*(Aq)
\&
\&  # started
.Ve
.IP "call example #2" 4
.IX Item "call example #2"
.Vb 1
\&  # given: synopsis
\&
\&  package Zoo;
\&
\&  sub import;
\&
\&  sub AUTOLOAD {
\&    bless {};
\&  }
\&
\&  sub DESTROY {
\&    ; # noop
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  $space = Data::Object::Space\->new(\*(Aqzoo\*(Aq);
\&
\&  $space\->call(\*(Aqstart\*(Aq)
\&
\&  # bless({}, \*(AqZoo\*(Aq)
.Ve
.SS "chain"
.IX Subsection "chain"
.Vb 1
\&  chain(Str | Tuple[Str, Any] @steps) : Any
.Ve
.PP
The chain method chains one or more method calls and returns the result.
.IP "chain example #1" 4
.IX Item "chain example #1"
.Vb 1
\&  package Chu::Chu0;
\&
\&  sub import;
\&
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(AqChu::Chu0\*(Aq);
\&
\&  $space\->chain(\*(Aqbless\*(Aq);
.Ve
.IP "chain example #2" 4
.IX Item "chain example #2"
.Vb 1
\&  package Chu::Chu1;
\&
\&  sub import;
\&
\&  sub new {
\&    bless pop;
\&  }
\&
\&  sub frame {
\&    [@_]
\&  }
\&
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(AqChu::Chu1\*(Aq);
\&
\&  $space\->chain([\*(Aqbless\*(Aq, {1..4}], \*(Aqframe\*(Aq);
\&
\&  # [ bless( { \*(Aq1\*(Aq => 2, \*(Aq3\*(Aq => 4 }, \*(AqChu::Chu1\*(Aq ) ]
.Ve
.IP "chain example #3" 4
.IX Item "chain example #3"
.Vb 1
\&  package Chu::Chu2;
\&
\&  sub import;
\&
\&  sub new {
\&    bless pop;
\&  }
\&
\&  sub frame {
\&    [@_]
\&  }
\&
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(AqChu::Chu2\*(Aq);
\&
\&  $space\->chain(\*(Aqbless\*(Aq, [\*(Aqframe\*(Aq, {1..4}]);
\&
\&  # [ bless( {}, \*(AqChu::Chu2\*(Aq ), { \*(Aq1\*(Aq => 2, \*(Aq3\*(Aq => 4 } ]
.Ve
.SS "child"
.IX Subsection "child"
.Vb 1
\&  child(Str $arg1) : Object
.Ve
.PP
The child method returns a new Data::Object::Space object for the child
package namespace.
.IP "child example #1" 4
.IX Item "child example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->child(\*(Aqbaz\*(Aq);
\&
\&  # $space\->package;
\&
\&  # Foo::Bar::Baz
.Ve
.SS "children"
.IX Subsection "children"
.Vb 1
\&  children() : ArrayRef[Object]
.Ve
.PP
The children method searches \f(CW%INC\fR and \f(CW@INC\fR and retuns a list of
Data::Object::Space objects for each child namespace found (one level deep).
.IP "children example #1" 4
.IX Item "children example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqc_p_a_n\*(Aq);
\&
\&  $space\->children
\&
\&  # [
\&  #   \*(AqCPAN/Author\*(Aq,
\&  #   \*(AqCPAN/Bundle\*(Aq,
\&  #   \*(AqCPAN/CacheMgr\*(Aq,
\&  #   ...
\&  # ]
.Ve
.SS "cop"
.IX Subsection "cop"
.Vb 1
\&  cop(Any @args) : CodeRef
.Ve
.PP
The cop method attempts to curry the given subroutine on the package namespace
and if successful returns a closure.
.IP "cop example #1" 4
.IX Item "cop example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  sub import;
\&
\&  sub handler {
\&    [@_]
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  $space = Data::Object::Space\->new(\*(Aqfoo/bar\*(Aq);
\&
\&  $space\->cop(\*(Aqhandler\*(Aq, $space\->bless)
\&
\&  # sub { Foo::Bar::handler(..., @_) }
.Ve
.SS "data"
.IX Subsection "data"
.Vb 1
\&  data() : Str
.Ve
.PP
The data method attempts to read and return any content stored in the \f(CW\*(C`DATA\*(C'\fR
section of the package namespace.
.IP "data example #1" 4
.IX Item "data example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo\*(Aq);
\&
\&  $space\->data; # \*(Aq\*(Aq
.Ve
.SS "destroy"
.IX Subsection "destroy"
.Vb 1
\&  destroy() : Object
.Ve
.PP
The destroy method attempts to wipe out a namespace and also remove it and its
children from \f(CW%INC\fR. \fB\s-1NOTE:\s0\fR This can cause catastrophic failures if used
incorrectly.
.IP "destroy example #1" 4
.IX Item "destroy example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqdata/dumper\*(Aq);
\&
\&  $space\->load; # Data/Dumper
\&
\&  $space\->destroy;
.Ve
.SS "eval"
.IX Subsection "eval"
.Vb 1
\&  eval(Str @args) : Any
.Ve
.PP
The eval method takes a list of strings and evaluates them under the namespace
represented by the instance.
.IP "eval example #1" 4
.IX Item "eval example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo\*(Aq);
\&
\&  $space\->eval(\*(Aqour $VERSION = 0.01\*(Aq);
.Ve
.SS "functions"
.IX Subsection "functions"
.Vb 1
\&  functions() : ArrayRef
.Ve
.PP
The functions method searches the package namespace for functions and returns
their names.
.IP "functions example #1" 4
.IX Item "functions example #1"
.Vb 1
\&  package Foo::Functions;
\&
\&  use routines;
\&
\&  fun start() {
\&    1
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/functions\*(Aq);
\&
\&  $space\->functions
\&
\&  # [\*(Aqstart\*(Aq]
.Ve
.SS "hash"
.IX Subsection "hash"
.Vb 1
\&  hash(Str $arg1) : HashRef
.Ve
.PP
The hash method returns the value for the given package hash variable name.
.IP "hash example #1" 4
.IX Item "hash example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our %settings = (
\&    active => 1
\&  );
\&
\&  package main;
\&
\&  $space\->hash(\*(Aqsettings\*(Aq)
\&
\&  # {active => 1}
.Ve
.SS "hashes"
.IX Subsection "hashes"
.Vb 1
\&  hashes() : ArrayRef
.Ve
.PP
The hashes method searches the package namespace for hashes and returns their
names.
.IP "hashes example #1" 4
.IX Item "hashes example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our %defaults = (
\&    active => 0
\&  );
\&
\&  our %settings = (
\&    active => 1
\&  );
\&
\&  package main;
\&
\&  $space\->hashes
\&
\&  # [\*(Aqdefaults\*(Aq, \*(Aqsettings\*(Aq]
.Ve
.SS "id"
.IX Subsection "id"
.Vb 1
\&  id() : Str
.Ve
.PP
The id method returns the fully-qualified package name as a label.
.IP "id example #1" 4
.IX Item "id example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->id
\&
\&  # Foo_Bar
.Ve
.SS "included"
.IX Subsection "included"
.Vb 1
\&  included() : Str
.Ve
.PP
The included method returns the path of the namespace if it exists in \f(CW%INC\fR.
.IP "included example #1" 4
.IX Item "included example #1"
.Vb 1
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(AqData/Object/Space\*(Aq);
\&
\&  $space\->included;
\&
\&  # lib/Data/Object/Space.pm
.Ve
.SS "inherits"
.IX Subsection "inherits"
.Vb 1
\&  inherits() : ArrayRef
.Ve
.PP
The inherits method returns the list of superclasses the target package is
derived from.
.IP "inherits example #1" 4
.IX Item "inherits example #1"
.Vb 1
\&  package Bar;
\&
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqbar\*(Aq);
\&
\&  $space\->inherits
\&
\&  # []
.Ve
.IP "inherits example #2" 4
.IX Item "inherits example #2"
.Vb 1
\&  package Foo;
\&
\&  package Bar;
\&
\&  use base \*(AqFoo\*(Aq;
\&
\&  package main;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqbar\*(Aq);
\&
\&  $space\->inherits
\&
\&  # [\*(AqFoo\*(Aq]
.Ve
.SS "init"
.IX Subsection "init"
.Vb 1
\&  init() : Str
.Ve
.PP
The init method ensures that the package namespace is loaded and, whether
created in-memory or on-disk, is flagged as being loaded and loadable.
.IP "init example #1" 4
.IX Item "init example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqkit\*(Aq);
\&
\&  $space\->init
\&
\&  # Kit
.Ve
.SS "inject"
.IX Subsection "inject"
.Vb 1
\&  inject(Str $name, Maybe[CodeRef] $coderef) : Any
.Ve
.PP
The inject method monkey-patches the package namespace, installing a named
subroutine into the package which can then be called normally, returning the
fully-qualified subroutine name.
.IP "inject example #1" 4
.IX Item "inject example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqkit\*(Aq);
\&
\&  $space\->inject(\*(Aqbuild\*(Aq, sub { \*(Aqfinished\*(Aq });
\&
\&  # *Kit::build
.Ve
.SS "load"
.IX Subsection "load"
.Vb 1
\&  load() : Str
.Ve
.PP
The load method checks whether the package namespace is already loaded and if
not attempts to load the package. If the package is not loaded and is not
loadable, this method will throw an exception using confess. If the package is
loadable, this method returns truthy with the package name. As a workaround for
packages that only exist in-memory, if the package contains a \f(CW\*(C`new\*(C'\fR, \f(CW\*(C`with\*(C'\fR,
\&\f(CW\*(C`meta\*(C'\fR, or \f(CW\*(C`import\*(C'\fR routine it will be recognized as having been loaded.
.IP "load example #1" 4
.IX Item "load example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqc_p_a_n\*(Aq);
\&
\&  $space\->load
\&
\&  # CPAN
.Ve
.SS "loaded"
.IX Subsection "loaded"
.Vb 1
\&  loaded() : Int
.Ve
.PP
The loaded method checks whether the package namespace is already loaded
returns truthy or falsy.
.IP "loaded example #1" 4
.IX Item "loaded example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqdata/dumper\*(Aq);
\&
\&  $space\->loaded;
\&
\&  # 0
.Ve
.IP "loaded example #2" 4
.IX Item "loaded example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqdata/dumper\*(Aq);
\&
\&  $space\->load;
\&
\&  $space\->loaded;
\&
\&  # 1
.Ve
.SS "locate"
.IX Subsection "locate"
.Vb 1
\&  locate() : Str
.Ve
.PP
The locate method checks whether the package namespace is available in
\&\f(CW@INC\fR, i.e. on disk. This method returns the file if found or an empty
string.
.IP "locate example #1" 4
.IX Item "locate example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqbrianne_spinka\*(Aq);
\&
\&  $space\->locate;
\&
\&  # \*(Aq\*(Aq
.Ve
.IP "locate example #2" 4
.IX Item "locate example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqdata/dumper\*(Aq);
\&
\&  $space\->locate;
\&
\&  # /path/to/Data/Dumper.pm
.Ve
.SS "methods"
.IX Subsection "methods"
.Vb 1
\&  methods() : ArrayRef
.Ve
.PP
The methods method searches the package namespace for methods and returns their
names.
.IP "methods example #1" 4
.IX Item "methods example #1"
.Vb 1
\&  package Foo::Methods;
\&
\&  use routines;
\&
\&  method start() {
\&    1
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/methods\*(Aq);
\&
\&  $space\->methods
\&
\&  # [\*(Aqstart\*(Aq]
.Ve
.SS "name"
.IX Subsection "name"
.Vb 1
\&  name() : Str
.Ve
.PP
The name method returns the fully-qualified package name.
.IP "name example #1" 4
.IX Item "name example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->name
\&
\&  # Foo::Bar
.Ve
.SS "parent"
.IX Subsection "parent"
.Vb 1
\&  parent() : Object
.Ve
.PP
The parent method returns a new Data::Object::Space object for the parent
package namespace.
.IP "parent example #1" 4
.IX Item "parent example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->parent;
\&
\&  # $space\->package;
\&
\&  # Foo
.Ve
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  parse() : ArrayRef
.Ve
.PP
The parse method parses the string argument and returns an arrayref of package
namespace segments (parts).
.IP "parse example #1" 4
.IX Item "parse example #1"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(AqFoo::Bar\*(Aq);
\&
\&  $space\->parse;
\&
\&  # [\*(AqFoo\*(Aq, \*(AqBar\*(Aq]
.Ve
.IP "parse example #2" 4
.IX Item "parse example #2"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(AqFoo/Bar\*(Aq);
\&
\&  $space\->parse;
\&
\&  # [\*(AqFoo\*(Aq, \*(AqBar\*(Aq]
.Ve
.IP "parse example #3" 4
.IX Item "parse example #3"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(AqFoo\eBar\*(Aq);
\&
\&  $space\->parse;
\&
\&  # [\*(AqFoo\*(Aq, \*(AqBar\*(Aq]
.Ve
.IP "parse example #4" 4
.IX Item "parse example #4"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(Aqfoo\-bar\*(Aq);
\&
\&  $space\->parse;
\&
\&  # [\*(AqFooBar\*(Aq]
.Ve
.IP "parse example #5" 4
.IX Item "parse example #5"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(Aqfoo_bar\*(Aq);
\&
\&  $space\->parse;
\&
\&  # [\*(AqFooBar\*(Aq]
.Ve
.SS "parts"
.IX Subsection "parts"
.Vb 1
\&  parts() : ArrayRef
.Ve
.PP
The parts method returns an arrayref of package namespace segments (parts).
.IP "parts example #1" 4
.IX Item "parts example #1"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(Aqfoo\*(Aq);
\&
\&  $space\->parts;
\&
\&  # [\*(AqFoo\*(Aq]
.Ve
.IP "parts example #2" 4
.IX Item "parts example #2"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/bar\*(Aq);
\&
\&  $space\->parts;
\&
\&  # [\*(AqFoo\*(Aq, \*(AqBar\*(Aq]
.Ve
.IP "parts example #3" 4
.IX Item "parts example #3"
.Vb 1
\&  my $space = Data::Object::Space\->new(\*(Aqfoo_bar\*(Aq);
\&
\&  $space\->parts;
\&
\&  # [\*(AqFooBar\*(Aq]
.Ve
.SS "prepend"
.IX Subsection "prepend"
.Vb 1
\&  prepend(Str @args) : Object
.Ve
.PP
The prepend method modifies the object by prepending to the package namespace
parts.
.IP "prepend example #1" 4
.IX Item "prepend example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->prepend(\*(Aqetc\*(Aq);
\&
\&  # \*(AqEtc/Foo/Bar\*(Aq
.Ve
.IP "prepend example #2" 4
.IX Item "prepend example #2"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->prepend(\*(Aqetc\*(Aq, \*(Aqtmp\*(Aq);
\&
\&  # \*(AqEtc/Tmp/Foo/Bar\*(Aq
.Ve
.SS "rebase"
.IX Subsection "rebase"
.Vb 1
\&  rebase(Str @args) : Object
.Ve
.PP
The rebase method returns an object by prepending the package namespace
specified to the base of the current object's namespace.
.IP "rebase example #1" 4
.IX Item "rebase example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->rebase(\*(Aqzoo\*(Aq);
\&
\&  # Zoo/Bar
.Ve
.SS "reload"
.IX Subsection "reload"
.Vb 1
\&  reload() : Str
.Ve
.PP
The reload method attempts to delete and reload the package namespace using the
\&\*(L"load\*(R" method. \fBNote:\fR Reloading is additive and will overwrite existing
symbols but does not remove symbols.
.IP "reload example #1" 4
.IX Item "reload example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  # Foo::Gen is generate with $VERSION as 0.01
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/gen\*(Aq);
\&
\&  $space\->reload;
\&
\&  # Foo::Gen
\&  # Foo::Gen\->VERSION is 0.01
.Ve
.IP "reload example #2" 4
.IX Item "reload example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  # Foo::Gen is regenerated with $VERSION as 0.02
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/gen\*(Aq);
\&
\&  $space\->reload;
\&
\&  # Foo::Gen
\&  # Foo::Gen\->VERSION is 0.02
.Ve
.SS "require"
.IX Subsection "require"
.Vb 1
\&  require(Str $target) : Any
.Ve
.PP
The require method executes a \f(CW\*(C`require\*(C'\fR statement within the package namespace
specified.
.IP "require example #1" 4
.IX Item "require example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->require(\*(AqMoo\*(Aq);
\&
\&  # 1
.Ve
.SS "root"
.IX Subsection "root"
.Vb 1
\&  root() : Str
.Ve
.PP
The root method returns the root package namespace segments (parts). Sometimes
separating the \f(CW\*(C`root\*(C'\fR from the \f(CW\*(C`parts\*(C'\fR helps identify how subsequent child
objects were derived.
.IP "root example #1" 4
.IX Item "root example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->root;
\&
\&  # Foo
.Ve
.SS "routine"
.IX Subsection "routine"
.Vb 1
\&  routine(Str $arg1) : CodeRef
.Ve
.PP
The routine method returns the subroutine reference for the given subroutine
name.
.IP "routine example #1" 4
.IX Item "routine example #1"
.Vb 1
\&  package Foo;
\&
\&  sub cont {
\&    [@_]
\&  }
\&
\&  sub abort {
\&    [@_]
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo\*(Aq);
\&
\&  $space\->routine(\*(Aqcont\*(Aq)
\&
\&  # sub { ... }
.Ve
.SS "routines"
.IX Subsection "routines"
.Vb 1
\&  routines() : ArrayRef
.Ve
.PP
The routines method searches the package namespace for routines and returns
their names.
.IP "routines example #1" 4
.IX Item "routines example #1"
.Vb 1
\&  package Foo::Routines;
\&
\&  sub start {
\&    1
\&  }
\&
\&  sub abort {
\&    1
\&  }
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/routines\*(Aq);
\&
\&  $space\->routines
\&
\&  # [\*(Aqstart\*(Aq, \*(Aqabort\*(Aq]
.Ve
.SS "scalar"
.IX Subsection "scalar"
.Vb 1
\&  scalar(Str $arg1) : Any
.Ve
.PP
The scalar method returns the value for the given package scalar variable name.
.IP "scalar example #1" 4
.IX Item "scalar example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our $root = \*(Aq/path/to/file\*(Aq;
\&
\&  package main;
\&
\&  $space\->scalar(\*(Aqroot\*(Aq)
\&
\&  # /path/to/file
.Ve
.SS "scalars"
.IX Subsection "scalars"
.Vb 1
\&  scalars() : ArrayRef
.Ve
.PP
The scalars method searches the package namespace for scalars and returns their
names.
.IP "scalars example #1" 4
.IX Item "scalars example #1"
.Vb 1
\&  # given: synopsis
\&
\&  package Foo::Bar;
\&
\&  our $root = \*(Aqroot\*(Aq;
\&  our $base = \*(Aqpath/to\*(Aq;
\&  our $file = \*(Aqfile\*(Aq;
\&
\&  package main;
\&
\&  $space\->scalars
\&
\&  # [\*(Aqroot\*(Aq, \*(Aqbase\*(Aq, \*(Aqfile\*(Aq]
.Ve
.SS "sibling"
.IX Subsection "sibling"
.Vb 1
\&  sibling(Str $arg1) : Object
.Ve
.PP
The sibling method returns a new Data::Object::Space object for the sibling
package namespace.
.IP "sibling example #1" 4
.IX Item "sibling example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $space\->sibling(\*(Aqbaz\*(Aq)
\&
\&  # Foo::Baz
.Ve
.SS "siblings"
.IX Subsection "siblings"
.Vb 1
\&  siblings() : ArrayRef[Object]
.Ve
.PP
The siblings method searches \f(CW%INC\fR and \f(CW@INC\fR and retuns a list of
Data::Object::Space objects for each sibling namespace found (one level
deep).
.IP "siblings example #1" 4
.IX Item "siblings example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqencode/m_i_m_e\*(Aq);
\&
\&  $space\->siblings
\&
\&  # [
\&  #   \*(AqEncode/Alias\*(Aq,
\&  #   \*(AqEncode/Config\*(Aq
\&  #   ...
\&  # ]
.Ve
.SS "tryload"
.IX Subsection "tryload"
.Vb 1
\&  tryload() : Bool
.Ve
.PP
The tryload method attempt to \f(CW\*(C`load\*(C'\fR the represented package using the
\&\*(L"load\*(R" method and returns truthy/falsy based on whether the package was
loaded.
.IP "tryload example #1" 4
.IX Item "tryload example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqc_p_a_n\*(Aq);
\&
\&  $space\->tryload
\&
\&  # 1
.Ve
.IP "tryload example #2" 4
.IX Item "tryload example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqbrianne_spinka\*(Aq);
\&
\&  $space\->tryload
\&
\&  # 0
.Ve
.SS "use"
.IX Subsection "use"
.Vb 1
\&  use(Str | Tuple[Str, Str] $target, Any @params) : Object
.Ve
.PP
The use method executes a \f(CW\*(C`use\*(C'\fR statement within the package namespace
specified.
.IP "use example #1" 4
.IX Item "use example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/goo\*(Aq);
\&
\&  $space\->use(\*(AqMoo\*(Aq);
\&
\&  # $self
.Ve
.IP "use example #2" 4
.IX Item "use example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/hoo\*(Aq);
\&
\&  $space\->use(\*(AqMoo\*(Aq, \*(Aqhas\*(Aq);
\&
\&  # $self
.Ve
.IP "use example #3" 4
.IX Item "use example #3"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/ioo\*(Aq);
\&
\&  $space\->use([\*(AqMoo\*(Aq, 9.99], \*(Aqhas\*(Aq);
\&
\&  # $self
.Ve
.SS "used"
.IX Subsection "used"
.Vb 1
\&  used() : Str
.Ve
.PP
The used method searches \f(CW%INC\fR for the package namespace and if found returns
the filepath and complete filepath for the loaded package, otherwise returns
falsy with an empty string.
.IP "used example #1" 4
.IX Item "used example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/xyz\*(Aq);
\&
\&  $space\->used
\&
\&  # \*(Aq\*(Aq
.Ve
.IP "used example #2" 4
.IX Item "used example #2"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqc_p_a_n\*(Aq);
\&
\&  $space\->load;
\&  $space\->used
\&
\&  # \*(AqCPAN\*(Aq
.Ve
.IP "used example #3" 4
.IX Item "used example #3"
.Vb 1
\&  package Foo::Bar;
\&
\&  sub import;
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/bar\*(Aq);
\&
\&  $space\->used
\&
\&  # \*(AqFoo/Bar\*(Aq
.Ve
.SS "variables"
.IX Subsection "variables"
.Vb 1
\&  variables() : ArrayRef[Tuple[Str, ArrayRef]]
.Ve
.PP
The variables method searches the package namespace for variables and returns
their names.
.IP "variables example #1" 4
.IX Item "variables example #1"
.Vb 1
\&  package Etc;
\&
\&  our $init = 0;
\&  our $func = 1;
\&
\&  our @does = (1..4);
\&  our %sets = (1..4);
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqetc\*(Aq);
\&
\&  $space\->variables
\&
\&  # [
\&  #   [\*(Aqarrays\*(Aq, [\*(Aqdoes\*(Aq]],
\&  #   [\*(Aqhashes\*(Aq, [\*(Aqsets\*(Aq]],
\&  #   [\*(Aqscalars\*(Aq, [\*(Aqfunc\*(Aq, \*(Aqinit\*(Aq]],
\&  # ]
.Ve
.SS "version"
.IX Subsection "version"
.Vb 1
\&  version() : Maybe[Str]
.Ve
.PP
The version method returns the \f(CW\*(C`VERSION\*(C'\fR declared on the target package, if
any.
.IP "version example #1" 4
.IX Item "version example #1"
.Vb 1
\&  package Foo::Boo;
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/boo\*(Aq);
\&
\&  $space\->version
\&
\&  # undef
.Ve
.IP "version example #2" 4
.IX Item "version example #2"
.Vb 1
\&  package Foo::Boo;
\&
\&  our $VERSION = 0.01;
\&
\&  package main;
\&
\&  use Data::Object::Space;
\&
\&  my $space = Data::Object::Space\->new(\*(Aqfoo/boo\*(Aq);
\&
\&  $space\->version
\&
\&  # \*(Aq0.01\*(Aq
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object-space/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object-space/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object-space>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object-space/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object-space/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object-space/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object-space/issues>
