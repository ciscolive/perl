.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tree 3"
.TH Tree 3 "2019-06-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree \- An N\-ary tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $tree = Tree\->new( \*(Aqroot\*(Aq );
\&  my $child = Tree\->new( \*(Aqchild\*(Aq );
\&  $tree\->add_child( $child );
\&
\&  $tree\->add_child( { at => 0 }, Tree\->new( \*(Aqfirst child\*(Aq ) );
\&  $tree\->add_child( { at => \-1 }, Tree\->new( \*(Aqlast child\*(Aq ) );
\&
\&  $tree\->set_value( \*(Aqtoor\*(Aq );
\&  my $value = $tree\->value;
\&
\&  my @children = $tree\->children;
\&  my @some_children = $tree\->children( 0, 2 );
\&
\&  my $height = $tree\->height;
\&  my $width  = $tree\->width;
\&  my $depth  = $tree\->depth;
\&  my $size   = $tree\->size;
\&
\&  if ( $tree\->has_child( $child ) ) {
\&      $tree\->remove_child( $child );
\&  }
\&
\&  $tree\->remove_child( 0 );
\&
\&  my @nodes = $tree\->traverse( $tree\->POST_ORDER );
\&  my $clone = $tree\->clone; # See remarks under clone() re deep cloning.
\&  my $mirror = $tree\->clone\->mirror;
\&
\&  $tree\->add_event_handler({
\&      add_child    => sub { ... },
\&      remove_child => sub { ... },
\&      value        => sub { ... },
\&  });
\&
\&  my $old_default_error_handler = $tree\->error_handler(Tree\->DIE);
\&  my $old_object_error_handler  = $tree\->error_handler($tree\->DIE);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is meant to be a full-featured N\-ary tree representation with
configurable error-handling and a simple events system that allows for
transparent persistence to a variety of datastores. It is derived from
Tree::Simple, but has a simpler interface and much, much more.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.SS "new([$value])"
.IX Subsection "new([$value])"
Here, [] indicate an optional parameter.
.PP
This will return a \f(CW\*(C`Tree\*(C'\fR object. It will accept one parameter which, if passed,
will become the \fIvalue\fR (accessible by \f(CW\*(C`value()\*(C'\fR). All other parameters will be
ignored.
.PP
If you call \f(CW\*(C`$tree\->new([$value])\*(C'\fR, it will instead call \f(CW\*(C`clone()\*(C'\fR, then set
the \fIvalue\fR of the clone to \f(CW$value\fR.
.SS "\fBclone()\fP"
.IX Subsection "clone()"
This will return a clone of \f(CW$tree\fR. The clone will be a root tree, but all
children will be cloned.
.PP
If you call \f(CW\*(C`Tree\->clone([$value])\*(C'\fR, it will instead call \f(CW\*(C`new($value)\*(C'\fR.
.PP
\&\fB\s-1NOTE:\s0\fR the \f(CW\*(C`value\*(C'\fR is merely a shallow copy. This means that all references
will be kept, but the \f(CW\*(C`meta\*(C'\fR data attached to each node is not copied.
.PP
See Tree::DeepClone and t/Tree_DeepClone/*.t if you want deep cloning, which is defined to
mean that the \f(CW\*(C`meta\*(C'\fR data attached to each node is also copied into the clone.
.SS "Behaviors"
.IX Subsection "Behaviors"
.ie n .SS "add_child([$options], @nodes)"
.el .SS "add_child([$options], \f(CW@nodes\fP)"
.IX Subsection "add_child([$options], @nodes)"
This will add all the \f(CW@nodes\fR as children of \f(CW$tree\fR. \f(CW$options\fR is a optional
unblessed hashref that specifies options for \f(CW\*(C`add_child()\*(C'\fR. The optional
parameters are:
.IP "\(bu" 4
at
.Sp
This specifies the index to add \f(CW@nodes\fR at. If specified, this will be passed
into \fBsplice()\fR. The only exceptions are if this is 0, it will act as an
\&\fBunshift()\fR. If it is unset or undefined, it will act as a \fBpush()\fR. Lastly, if it is out of range
(too negative or too big [beyond the number of children]) the child is not added, and an error msg
will be available in \*(L"\fBlast_error()\fR\*(R".
.PP
\&\fBadd_child()\fR resets \fBlast_error()\fR upon entry.
.ie n .SS "remove_child([$options], @nodes)"
.el .SS "remove_child([$options], \f(CW@nodes\fP)"
.IX Subsection "remove_child([$options], @nodes)"
Here, [] indicate an optional parameter.
.PP
This will remove all the \f(CW@nodes\fR from the children of \f(CW$tree\fR. You can either
pass in the actual child object you wish to remove, the index of the child you
wish to remove, or a combination of both.
.PP
\&\f(CW$options\fR is a optional unblessed hashref that specifies parameters for
\&\fBremove_child()\fR. Currently, no parameters are used.
.PP
\&\fBremove_child()\fR resets \fBlast_error()\fR upon entry.
.SS "\fBmirror()\fP"
.IX Subsection "mirror()"
This will modify the tree such that it is a mirror of what it was before. This
means that the order of all children is reversed.
.PP
\&\fB\s-1NOTE\s0\fR: This is a destructive action. It \fIwill\fR modify the internal structure
of the tree. If you wish to get a mirror, yet keep the original tree intact, use
\&\f(CW\*(C`my $mirror = $tree\->clone\->mirror\*(C'\fR.
.PP
\&\fBmirror()\fR does not reset \fBlast_error()\fR because it (\fBmirror()\fR ) is implemented in Tree::Fast,
which has no error handling.
.SS "traverse([$order])"
.IX Subsection "traverse([$order])"
Here, [] indicate an optional parameter.
.PP
This will return a list of the nodes in the given traversal order. The default
traversal order is pre-order.
.PP
The various traversal orders do the following steps:
.IP "\(bu" 4
Pre-order
.Sp
This will return the node, then the first sub tree in pre-order traversal,
then the next sub tree, etc.
.Sp
Use \f(CW\*(C`$tree\->PRE_ORDER\*(C'\fR as the \f(CW$order\fR.
.IP "\(bu" 4
Post-order
.Sp
This will return the each sub-tree in post-order traversal, then the node.
.Sp
Use \f(CW\*(C`$tree\->POST_ORDER\*(C'\fR as the \f(CW$order\fR.
.IP "\(bu" 4
Level-order
.Sp
This will return the node, then the all children of the node, then all
grandchildren of the node, etc.
.Sp
Use \f(CW\*(C`$tree\->LEVEL_ORDER\*(C'\fR as the \f(CW$order\fR.
.PP
\&\fBtraverse()\fR does not reset \fBlast_error()\fR because it (\fBtraverse()\fR ) is implemented in Tree::Fast,
which has no error handling.
.SS "tree2string($options)"
.IX Subsection "tree2string($options)"
Returns an arrayref of lines, suitable for printing. These lines do not end in \*(L"\en\*(R".
.PP
Draws a nice ASCII-art representation of the tree structure.
.PP
The tree looks like:
.PP
.Vb 11
\&        Root. Attributes: {uid => "0"}
\&            |\-\-\- H. Attributes: {uid => "1"}
\&            |    |\-\-\- I. Attributes: {uid => "2"}
\&            |    |    |\-\-\- J. Attributes: {uid => "3"}
\&            |    |\-\-\- K. Attributes: {uid => "4"}
\&            |    |\-\-\- L. Attributes: {uid => "5"}
\&            |\-\-\- M. Attributes: {uid => "6"}
\&            |\-\-\- N. Attributes: {uid => "7"}
\&                 |\-\-\- O. Attributes: {uid => "8"}
\&                      |\-\-\- P. Attributes: {uid => "9"}
\&                           |\-\-\- Q. Attributes: {uid => "10"}
.Ve
.PP
Or, without attributes:
.PP
.Vb 11
\&        Root
\&            |\-\-\- H
\&            |    |\-\-\- I
\&            |    |    |\-\-\- J
\&            |    |\-\-\- K
\&            |    |\-\-\- L
\&            |\-\-\- M
\&            |\-\-\- N
\&                 |\-\-\- O
\&                      |\-\-\- P
\&                           |\-\-\- Q
.Ve
.PP
See scripts/print.tree.pl.
.PP
Example usage:
.PP
.Vb 1
\&  print map("$_\en", @{$tree \-> tree2string});
.Ve
.PP
If you do not wish to supply options, use \f(CW\*(C`tree2string()\*(C'\fR or \f(CW\*(C`tree2string({})\*(C'\fR.
.PP
Possible keys in the \f(CW$options\fR hashref (which defaults to {}):
.ie n .IP "o no_attributes => $Boolean" 4
.el .IP "o no_attributes => \f(CW$Boolean\fR" 4
.IX Item "o no_attributes => $Boolean"
If 1, the node attributes are not included in the string returned.
.Sp
Default: 0 (include attributes).
.PP
Calls \*(L"node2string($options, \f(CW$node\fR, \f(CW$vert_dashes\fR)\*(R".
.SS "State Queries"
.IX Subsection "State Queries"
.SS "\fBis_root()\fP"
.IX Subsection "is_root()"
This will return true if \f(CW$tree\fR has no parent and false otherwise.
.SS "\fBis_leaf()\fP"
.IX Subsection "is_leaf()"
This will return true if \f(CW$tree\fR has no children and false otherwise.
.SS "has_child(@nodes)"
.IX Subsection "has_child(@nodes)"
This will return true if \f(CW$tree\fR has each of the \f(CW@nodes\fR as a child.
Otherwise, it will return false.
.PP
The test to see if a node is in the tree uses \fBrefaddr()\fR from Scalar::Util, not the \fIvalue\fR of the node.
This means \f(CW@nodes\fR must be an array of \f(CW\*(C`Tree\*(C'\fR objects.
.SS "get_index_for(@nodes)"
.IX Subsection "get_index_for(@nodes)"
This will return the index into the children list of \f(CW$tree\fR for each of the \f(CW@nodes\fR
passed in.
.SS "Accessors"
.IX Subsection "Accessors"
.SS "\fBparent()\fP"
.IX Subsection "parent()"
This will return the parent of \f(CW$tree\fR.
.ie n .SS "children( [ $idx, [$idx, ..] ] )"
.el .SS "children( [ \f(CW$idx\fP, [$idx, ..] ] )"
.IX Subsection "children( [ $idx, [$idx, ..] ] )"
Here, [] indicate optional parameters.
.PP
This will return the children of \f(CW$tree\fR. If called in list context, it will
return all the children. If called in scalar context, it will return the
number of children.
.PP
You may optionally pass in a list of indices to retrieve. This will return the
children in the order you asked for them. This is very much like an
arrayslice.
.SS "\fBroot()\fP"
.IX Subsection "root()"
This will return the root node of the tree that \f(CW$tree\fR is in. The root of
the root node is itself.
.SS "\fBheight()\fP"
.IX Subsection "height()"
This will return the height of \f(CW$tree\fR. A leaf has a height of 1. A parent
has a height of its tallest child, plus 1.
.SS "\fBwidth()\fP"
.IX Subsection "width()"
This will return the width of \f(CW$tree\fR. A leaf has a width of 1. A parent has
a width equal to the sum of all the widths of its children.
.SS "\fBdepth()\fP"
.IX Subsection "depth()"
This will return the depth of \f(CW$tree\fR. A root has a depth of 0. A child has
the depth of its parent, plus 1.
.PP
This is the distance from the root. It is useful for things like
pretty-printing the tree.
.SS "\fBsize()\fP"
.IX Subsection "size()"
This will return the number of nodes within \f(CW$tree\fR. A leaf has a size of 1.
A parent has a size equal to the 1 plus the sum of all the sizes of its
children.
.SS "\fBvalue()\fP"
.IX Subsection "value()"
This will return the value stored in the node.
.SS "set_value([$value])"
.IX Subsection "set_value([$value])"
Here, [] indicate an optional parameter.
.PP
This will set the \fIvalue\fR stored in the node to \f(CW$value\fR, then return \f(CW$self\fR.
.PP
If \f(CW$value\fR is not provided, undef is used.
.SS "\fBmeta()\fP"
.IX Subsection "meta()"
This will return a hashref that can be used to store whatever metadata the
client wishes to store. For example, Tree::Persist::DB uses this to store
database row ids.
.PP
It is recommended that you store your metadata in a subhashref and not in the
top-level metadata hashref, keyed by your package name. Tree::Persist does
this, using a unique key for each persistence layer associated with that tree.
This will help prevent clobbering of metadata.
.ie n .SS "format_node($options, $node)"
.el .SS "format_node($options, \f(CW$node\fP)"
.IX Subsection "format_node($options, $node)"
Returns a string consisting of the node's name and, optionally, it's attributes.
.PP
Possible keys in the \f(CW$options\fR hashref:
.ie n .IP "o no_attributes => $Boolean" 4
.el .IP "o no_attributes => \f(CW$Boolean\fR" 4
.IX Item "o no_attributes => $Boolean"
If 1, the node attributes are not included in the string returned.
.Sp
Default: 0 (include attributes).
.PP
Calls \*(L"hashref2string($hashref)\*(R".
.PP
Called by \*(L"node2string($options, \f(CW$node\fR, \f(CW$vert_dashes\fR)\*(R".
.PP
You would not normally call this method.
.PP
If you do not wish to supply options, use format_node({}, \f(CW$node\fR).
.SS "hashref2string($hashref)"
.IX Subsection "hashref2string($hashref)"
Returns the given hashref as a string.
.PP
Called by \*(L"format_node($options, \f(CW$node\fR)\*(R".
.ie n .SS "node2string($options, $node, $vert_dashes)"
.el .SS "node2string($options, \f(CW$node\fP, \f(CW$vert_dashes\fP)"
.IX Subsection "node2string($options, $node, $vert_dashes)"
Returns a string of the node name and attributes, with a leading indent, suitable for printing.
.PP
Possible keys in the \f(CW$options\fR hashref:
.ie n .IP "o no_attributes => $Boolean" 4
.el .IP "o no_attributes => \f(CW$Boolean\fR" 4
.IX Item "o no_attributes => $Boolean"
If 1, the node attributes are not included in the string returned.
.Sp
Default: 0 (include attributes).
.PP
Ignore the parameter \f(CW$vert_dashes\fR. The code uses it as temporary storage.
.PP
Calls \*(L"format_node($options, \f(CW$node\fR)\*(R".
.PP
Called by \*(L"tree2string($options)\*(R".
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Describe what the default error handlers do and what a custom error handler is
expected to do.
.SS "Error-related methods"
.IX Subsection "Error-related methods"
.ie n .SS "error_handler( [ $handler ] )"
.el .SS "error_handler( [ \f(CW$handler\fP ] )"
.IX Subsection "error_handler( [ $handler ] )"
This will return the current error handler for the tree. If a value is passed
in, then it will be used to set the error handler for the tree.
.PP
If called as a class method, this will instead work with the default error
handler.
.ie n .SS "error( $error, [ arg1 [, arg2 ...] ] )"
.el .SS "error( \f(CW$error\fP, [ arg1 [, arg2 ...] ] )"
.IX Subsection "error( $error, [ arg1 [, arg2 ...] ] )"
Call this when you wish to report an error using the currently defined
error_handler for the tree. The only guaranteed parameter is an error string
describing the issue. There may be other arguments, and you may certainly
provide other arguments in your subclass to be passed to your custom handler.
.SS "\fBlast_error()\fP"
.IX Subsection "last_error()"
If an error occurred during the last behavior, this will return the error
string. It is reset only by \fBadd_child()\fR and \fBremove_child()\fR.
.SS "Default error handlers"
.IX Subsection "Default error handlers"
.IP "\s-1QUIET\s0" 4
.IX Item "QUIET"
Use this error handler if you want to have quiet error-handling. The
\&\*(L"\fBlast_error()\fR\*(R" method will retrieve the error from the last operation, if there
was one. If an error occurs, the operation will return undefined.
.IP "\s-1WARN\s0" 4
.IX Item "WARN"
.PD 0
.IP "\s-1DIE\s0" 4
.IX Item "DIE"
.PD
.SH "EVENT HANDLING"
.IX Header "EVENT HANDLING"
Tree provides for basic event handling. You may choose to register one or
more callbacks to be called when the appropriate event occurs. The events
are:
.IP "\(bu" 4
add_child
.Sp
This event will trigger as the last step in an \*(L"add_child([$options], \f(CW@nodes\fR)\*(R" call.
.Sp
The parameters will be \f(CW\*(C`( $self, @args )\*(C'\fR where \f(CW@args\fR is the arguments
passed into the \fBadd_child()\fR call.
.IP "\(bu" 4
remove_child
.Sp
This event will trigger as the last step in an \*(L"remove_child([$options], \f(CW@nodes\fR)\*(R" call.
.Sp
The parameters will be \f(CW\*(C`( $self, @args )\*(C'\fR where \f(CW@args\fR is the arguments
passed into the \fBremove_child()\fR call.
.IP "\(bu" 4
value
.Sp
This event will trigger as the last step in a \fBset_value()\fR call.
.Sp
The parameters will be \f(CW\*(C`( $self, $old_value )\*(C'\fR where
\&\f(CW$old_value\fR is what the value was before it was changed. The new value can
be accessed through \f(CW\*(C`$self\->value()\*(C'\fR.
.SS "Event handling methods"
.IX Subsection "Event handling methods"
.ie n .SS "add_event_handler( {$type => $callback [, $type => $callback, ... ]} )"
.el .SS "add_event_handler( {$type => \f(CW$callback\fP [, \f(CW$type\fP => \f(CW$callback\fP, ... ]} )"
.IX Subsection "add_event_handler( {$type => $callback [, $type => $callback, ... ]} )"
You may choose to add event handlers for any known type. Callbacks must be
references to subroutines. They will be called in the order they are defined.
.ie n .SS "event( $type, $actor, @args )"
.el .SS "event( \f(CW$type\fP, \f(CW$actor\fP, \f(CW@args\fP )"
.IX Subsection "event( $type, $actor, @args )"
This will trigger an event of type \f(CW$type\fR. All event handlers registered on
\&\f(CW$tree\fR will be called with parameters of \f(CW\*(C`($actor, @args)\*(C'\fR. Then, the
parent will be notified of the event and its handlers will be called, on up to
the root.
.PP
This allows you specify an event handler on the root and be guaranteed that it
will fire every time the appropriate event occurs anywhere in the tree.
.SH "NULL TREE"
.IX Header "NULL TREE"
If you call \f(CW\*(C`$self\->parent\*(C'\fR on a root node, it will return a Tree::Null
object. This is an implementation of the Null Object pattern optimized for
usage with Tree. It will evaluate as false in every case (using
\&\fIoverload\fR) and all methods called on it will return a Tree::Null object.
.SS "Notes"
.IX Subsection "Notes"
.IP "\(bu" 4
Tree::Null does \fBnot\fR inherit from Tree. This is so that all the
methods will go through \s-1AUTOLOAD\s0 vs. the actual method.
.IP "\(bu" 4
However, calling \fBisa()\fR on a Tree::Null object will report that it is-a
any object that is either Tree or in the Tree:: hierarchy.
.IP "\(bu" 4
The Tree::Null object is a singleton.
.IP "\(bu" 4
The Tree::Null object \fIis\fR defined, though. I could not find a way to
make it evaluate as undefined. That may be a good thing.
.SH "CIRCULAR REFERENCES"
.IX Header "CIRCULAR REFERENCES"
Please q.v. Forest for more info on this topic.
.SH "FAQ"
.IX Header "FAQ"
.SS "Which is the best tree processing module?"
.IX Subsection "Which is the best tree processing module?"
Tree::DAG_Node. More details: \*(L"\s-1SEE ALSO\*(R"\s0.
.SS "How do I implement the visitor pattern?"
.IX Subsection "How do I implement the visitor pattern?"
I have deliberately chosen to not implement the Visitor pattern as described
by Gamma et al. Given a sufficiently powerful \f(CW\*(C`traverse()\*(C'\fR and the capabilities
of Perl, an explicit visitor object is almost always unneeded. If you
want one, it is easy to write one yourself. Here is a simple one I wrote in 5
minutes:
.PP
.Vb 1
\&  package My::Visitor;
\&
\&  sub new {
\&      my $class = shift;
\&      my $opts  = @_;
\&
\&      return bless {
\&          tree => $opts\->{tree},
\&          action => $opts\->{action},
\&      }, $class;
\&  }
\&
\&  sub visit {
\&      my $self = shift;
\&      my ($mode) = @_;
\&
\&      foreach my $node ( $self\->{tree}\->traverse( $mode ) ) {
\&          $self\->{action}\->( $node );
\&      }
\&  }
.Ve
.SS "Should I implement the visitor pattern?"
.IX Subsection "Should I implement the visitor pattern?"
No. You are better off using the \*(L"walk_down($options)\*(R" in Tree::DAG_Node method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "o Tree::Binary" 4
.IX Item "o Tree::Binary"
Lightweight.
.IP "o Tree::DAG_Node" 4
.IX Item "o Tree::DAG_Node"
Lightweight, and with a long list of methods.
.IP "o Tree::DAG_Node::Persist" 4
.IX Item "o Tree::DAG_Node::Persist"
Lightweight.
.IP "o Tree::Persist" 4
.IX Item "o Tree::Persist"
Lightweight.
.IP "o Forest" 4
.IX Item "o Forest"
Uses Moose.
.PP
\&\f(CW\*(C`Tree\*(C'\fR itself is also lightweight.
.SH "CODE COVERAGE"
.IX Header "CODE COVERAGE"
These statistics are as of V 1.01.
.PP
We use Devel::Cover to test the code coverage of our tests. Below is the
Devel::Cover report on the test suite of this module.
.PP
.Vb 8
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&  File                           stmt   bran   cond    sub    pod   time  total
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&  blib/lib/Tree.pm              100.0  100.0   94.4  100.0  100.0   67.3   99.7
\&  blib/lib/Tree/Binary.pm        96.4   95.0  100.0  100.0  100.0   10.7   96.7
\&  blib/lib/Tree/Fast.pm          99.4   95.5   91.7  100.0  100.0   22.0   98.6
\&  Total                          98.9   96.8   94.9  100.0  100.0  100.0   98.5
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "\(bu" 4
Stevan Little for writing Tree::Simple, upon which Tree is based.
.SH "Repository"
.IX Header "Repository"
<https://github.com/ronsavage/Tree>
.SH "SUPPORT"
.IX Header "SUPPORT"
The mailing list is at TreeCPAN@googlegroups.com. I also read
<http://www.perlmonks.com> on a daily basis.
.SH "AUTHORS"
.IX Header "AUTHORS"
Rob Kinyon <rob.kinyon@iinteractive.com>
.PP
Stevan Little <stevan.little@iinteractive.com>
.PP
Thanks to Infinity Interactive for generously donating our time.
.PP
Co-maintenance since V 1.02 is by Ron Savage <rsavage@cpan.org>.
Uses of 'I' in previous versions is not me, but will be hereafter.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004, 2005 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
