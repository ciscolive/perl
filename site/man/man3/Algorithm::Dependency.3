.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Algorithm::Dependency 3"
.TH Algorithm::Dependency 3 "2020-04-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Algorithm::Dependency \- Base class for implementing various dependency trees
.SH "VERSION"
.IX Header "VERSION"
version 1.112
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Typical Usage: Ordering based on dependency requirements
.PP
.Vb 2
\&  use Algorithm::Dependency::Ordered;
\&  use Algorithm::Dependency::Source::HoA;
\&  
\&  my $deps = {
\&    core  => [ ],
\&    a     => [ \*(Aqcore\*(Aq ],
\&    b     => [ \*(Aqa\*(Aq ]
\&    this  => [ ],
\&    that  => [ ],
\&  };
\&  my $deps_source = Algorithm::Dependency::Source::HoA\->new( $deps );
\&
\&  my $dep = Algorithm::Dependency::Ordered\->new(
\&    source   => $deps_source,
\&    selected => [ \*(Aqthis\*(Aq, \*(Aqthat\*(Aq ], # Items we have processed elsewhere or have already satisfied
\&  )
\&  or die \*(AqFailed to set up dependency algorithm\*(Aq;
\&
\&  my $also = $dep\->schedule_all();
\&  # Returns: [\*(Aqcore\*(Aq, \*(Aqa\*(Aq, \*(Aqb\*(Aq] \-\- ie: installation\-order. Whereas using base
\&  # Algorithm::Dependency would return sorted [\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqcore\*(Aq]
\&
\&  my $also = $dep\->schedule( \*(Aqb\*(Aq );
\&  # Returns: [\*(Aqcore\*(Aq, \*(Aqa\*(Aq, \*(Aqb\*(Aq] \-\- installation order, including ourselves
\&
\&  my $also = $dep\->depends( \*(Aqb\*(Aq );
\&  # Returns: [\*(Aqa\*(Aq, \*(Aqcore\*(Aq] \-\- sorted order, not including ourselves
.Ve
.PP
Base Classes
.PP
.Vb 2
\&  use Algorithm::Dependency;
\&  use Algorithm::Dependency::Source::File;
\&  
\&  # Load the data from a simple text file
\&  my $data_source = Algorithm::Dependency::Source::File\->new( \*(Aqfoo.txt\*(Aq );
\&  
\&  # Create the dependency object, and indicate the items that are already
\&  # selected/installed/etc in the database
\&  my $dep = Algorithm::Dependency\->new(
\&      source   => $data_source,
\&      selected => [ \*(AqThis\*(Aq, \*(AqThat\*(Aq ]
\&  ) or die \*(AqFailed to set up dependency algorithm\*(Aq;
\&  
\&  # For the item \*(AqFoo\*(Aq, find out the other things we also have to select.
\&  # This WON\*(AqT include the item we selected, \*(AqFoo\*(Aq.
\&  my $also = $dep\->depends( \*(AqFoo\*(Aq );
\&  print $also
\&        ? "By selecting \*(AqFoo\*(Aq, you are also selecting the following items: "
\&                . join( \*(Aq, \*(Aq, @$also )
\&        : "Nothing else to select for \*(AqFoo\*(Aq";
\&  
\&  # Find out the order we need to act on the items in.
\&  # This WILL include the item we selected, \*(AqFoo\*(Aq.
\&  my $schedule = $dep\->schedule( \*(AqFoo\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Algorithm::Dependency is a framework for creating simple read-only
dependency hierarchies, where you have a set of items that rely on other
items in the set, and require actions on them as well.
.PP
Despite the most visible of these being software installation systems like
the \s-1CPAN\s0 installer, or Debian apt-get, they are useful in other situations.
This module intentionally uses implementation-neutral words, to avoid
confusion.
.SS "Terminology"
.IX Subsection "Terminology"
The term \f(CW\*(C`ITEM\*(C'\fR refers to a single entity, such as a single software
package, in the overall set of possible entities. Internally, this is a
fairly simple object. See Algorithm::Dependency::Item for details.
.PP
The term \f(CW\*(C`SELECT\*(C'\fR means that a particular item, for your purposes, has
already been acted up in the required way. For example, if the software
package had already been installed, and didn't need to be re-installed,
it would be \f(CW\*(C`SELECTED\*(C'\fR.
.PP
The term \f(CW\*(C`SOURCE\*(C'\fR refers to a location that contains the master set of
items. This will be very application specific, and might be a flat file,
some form of database, the list of files in a folder, or generated
dynamically.
.SS "General Description"
.IX Subsection "General Description"
Algorithm::Dependency implements algorithms relating to dependency
hierarchies. To use this framework, all you need is a source for the master
list of all the items, and a list of those already selected. If your
dependency hierarchy doesn't require the concept of items that are already
selected, simply don't pass anything to the constructor for it.
.PP
Please note that the class Algorithm::Dependency does \s-1NOT\s0 implement an
ordering, for speed and simplicity reasons. That is, the \f(CW\*(C`schedule\*(C'\fR it
provides is not in any particular order. If item 'A' depends on item 'B',
it will not place B before A in the schedule. This makes it unsuitable for
things like software installers, as they typically would need B to be
installed before A, or the installation of A would fail.
.PP
For dependency hierarchies requiring the items to be acted on in a particular
order, either top down or bottom up, see Algorithm::Dependency::Ordered.
It should be more applicable for your needs. This is the the subclass you
would probably use to implement a simple ( non-versioned ) package
installation system. Please note that an ordered hierarchy has additional
constraints. For example, circular dependencies \s-1ARE\s0 legal in a
non-ordered hierarchy, but \s-1ARE NOT\s0 legal in an ordered hierarchy.
.SS "Extending"
.IX Subsection "Extending"
A module for creating a source from a simple flat file is included. For
details see Algorithm::Dependency::Source::File. Information on creating
a source for your particular use is in Algorithm::Dependency::Source.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new %args"
.el .SS "new \f(CW%args\fP"
.IX Subsection "new %args"
The constructor creates a new context object for the dependency algorithms to
act in. It takes as argument a series of options for creating the object.
.ie n .IP "source => $Source" 4
.el .IP "source => \f(CW$Source\fR" 4
.IX Item "source => $Source"
The only compulsory option is the source of the dependency items. This is
an object of a subclass of Algorithm::Dependency::Source. In practical terms,
this means you will create the source object before creating the
Algorithm::Dependency object.
.IP "selected => [ 'A', 'B', 'C', etc... ]" 4
.IX Item "selected => [ 'A', 'B', 'C', etc... ]"
The \f(CW\*(C`selected\*(C'\fR option provides a list of those items that have already been
\&'selected', acted upon, installed, or whatever. If another item depends on one
in this list, we don't have to include it in the output of the \f(CW\*(C`schedule\*(C'\fR or
\&\f(CW\*(C`depends\*(C'\fR methods.
.IP "ignore_orphans => 1" 4
.IX Item "ignore_orphans => 1"
Normally, the item source is expected to be largely perfect and error free.
An 'orphan' is an item name that appears as a dependency of another item, but
doesn't exist, or has been deleted.
.Sp
By providing the \f(CW\*(C`ignore_orphans\*(C'\fR flag, orphans are simply ignored. Without
the \f(CW\*(C`ignore_orphans\*(C'\fR flag, an error will be returned if an orphan is found.
.PP
The \f(CW\*(C`new\*(C'\fR constructor returns a new Algorithm::Dependency object on success,
or \f(CW\*(C`undef\*(C'\fR on error.
.SS "source"
.IX Subsection "source"
The \f(CW\*(C`source\*(C'\fR method retrieves the Algorithm::Dependency::Source object
for the algorithm context.
.SS "selected_list"
.IX Subsection "selected_list"
The \f(CW\*(C`selected_list\*(C'\fR method returns, as a list and in alphabetical order,
the list of the names of the selected items.
.ie n .SS "selected $name"
.el .SS "selected \f(CW$name\fP"
.IX Subsection "selected $name"
Given an item name, the \f(CW\*(C`selected\*(C'\fR method will return true if the item is
selected, false is not, or \f(CW\*(C`undef\*(C'\fR if the item does not exist, or an error
occurs.
.ie n .SS "item $name"
.el .SS "item \f(CW$name\fP"
.IX Subsection "item $name"
The \f(CW\*(C`item\*(C'\fR method fetches and returns the item object, as specified by the
name argument.
.PP
Returns an Algorithm::Dependency::Item object on success, or \f(CW\*(C`undef\*(C'\fR if
an item does not exist for the argument provided.
.ie n .SS "depends $name1, ..., $nameN"
.el .SS "depends \f(CW$name1\fP, ..., \f(CW$nameN\fP"
.IX Subsection "depends $name1, ..., $nameN"
Given a list of one or more item names, the \f(CW\*(C`depends\*(C'\fR method will return
a reference to an array containing a list of the names of all the \s-1OTHER\s0
items that also have to be selected to meet dependencies.
.PP
That is, if item A depends on B and C then the \f(CW\*(C`depends\*(C'\fR method would
return a reference to an array with B and C. ( \f(CW\*(C`[ \*(AqB\*(Aq, \*(AqC\*(Aq ]\*(C'\fR )
.PP
If multiple item names are provided, the same applies. The list returned
will not contain duplicates.
.PP
The method returns a reference to an array of item names on success, a
reference to an empty array if no other items are needed, or \f(CW\*(C`undef\*(C'\fR
on error.
.PP
\&\s-1NOTE:\s0 The result of \f(CW\*(C`depends\*(C'\fR is ordered by an internal \f(CW\*(C`sort\*(C'\fR
irrespective of the ordering provided by the dependency handler.  Use
Algorithm::Dependency::Ordered and \f(CW\*(C`schedule\*(C'\fR to use the most
common ordering (process sequence)
.ie n .SS "schedule $name1, ..., $nameN"
.el .SS "schedule \f(CW$name1\fP, ..., \f(CW$nameN\fP"
.IX Subsection "schedule $name1, ..., $nameN"
Given a list of one or more item names, the \f(CW\*(C`depends\*(C'\fR method will
return, as a reference to an array, the ordered list of items you
should act upon in whichever order this particular dependency handler
uses \- see Algorithm::Dependency::Ordered for one that implements
the most common ordering (process sequence).
.PP
This would be the original names provided, plus those added to satisfy
dependencies, in the preferred order of action. For the normal algorithm,
where order it not important, this is alphabetical order. This makes it
easier for someone watching a program operate on the items to determine
how far you are through the task and makes any logs easier to read.
.PP
If any of the names you provided in the arguments is already selected, it
will not be included in the list.
.PP
The method returns a reference to an array of item names on success, a
reference to an empty array if no items need to be acted upon, or \f(CW\*(C`undef\*(C'\fR
on error.
.SS "schedule_all;"
.IX Subsection "schedule_all;"
The \f(CW\*(C`schedule_all\*(C'\fR method acts the same as the \f(CW\*(C`schedule\*(C'\fR method, but 
returns a schedule that selected all the so-far unselected items.
.SH "TO DO"
.IX Header "TO DO"
Add the \f(CW\*(C`check_source\*(C'\fR method, to verify the integrity of the source.
.PP
Possibly add Algorithm::Dependency::Versions, to implement an ordered
dependency tree with versions, like for perl modules.
.PP
Currently readonly. Make the whole thing writable, so the module can be
used as the core of an actual dependency application, as opposed to just
being a tool.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Algorithm::Dependency::Ordered, Algorithm::Dependency::Item,
Algorithm::Dependency::Source, Algorithm::Dependency::Source::File
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Algorithm-Dependency>
(or bug\-Algorithm\-Dependency@rt.cpan.org <mailto:bug-Algorithm-Dependency@rt.cpan.org>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Adam Kennedy <adam@ali.as>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Mark Murawski <markm@intellasoft.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2003 by Adam Kennedy.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
