.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::OAuth2::AccessToken 3"
.TH Net::OAuth2::AccessToken 3 "2019-10-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Net::OAuth2::AccessToken \- OAuth2 bearer token
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $auth    = Net::OAuth2::Profile::WebServer\->new(...);
\&
\&  my $session = $auth\->get_access_token($code, ...);
\&  # $session is a Net::OAuth2::AccessToken object
\&  if($session\->error)
\&  {   print $session\->error_description;
\&  }
\&
\&  my $response = $session\->get($request);
\&  my $response = $session\->get($header, $content);
\&  print $session\->to_string;  # JSON
\&
\&  # probably better to set new(auto_refresh), but you may do:
\&  $session\->refresh if $session\->expired;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object represents a received (bearer) token, and offers ways to use it
and maintain it.  A better name for this module would include \fBclient
or session\fR.
.PP
A \*(L"bearer token\*(R" is an abstract proof of your existence: different
services or potentially different physical servers are able to exchange
information about your session based on this, for instance whether
someone logged-in while showing the token.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Net::OAuth2::AccessToken\->\fBnew\fR(%options)" 4
.IX Item "Net::OAuth2::AccessToken->new(%options)"
.Vb 10
\& \-Option           \-\-Default
\&  access_token       undef
\&  auto_refresh       <false>
\&  changed            <false>
\&  error              undef
\&  error_description  <value of error>
\&  error_uri          undef
\&  expires_at         undef
\&  expires_in         undef
\&  profile            <required>
\&  refresh_always     BOOLEAN
\&  refresh_token      false
\&  scope              undef
\&  token_type         undef
.Ve
.RS 4
.IP "access_token => \s-1STRING\s0" 2
.IX Item "access_token => STRING"
.PD 0
.IP "auto_refresh => \s-1BOOLEAN\s0" 2
.IX Item "auto_refresh => BOOLEAN"
.PD
Refresh the token when expired.
.IP "changed => \s-1BOOLEAN\s0" 2
.IX Item "changed => BOOLEAN"
[0.52] The token (session) needs to be saved.
.IP "error => \s-1STRING\s0" 2
.IX Item "error => STRING"
Set when an error has occured, the token is not valid.  This is not
numerical.
.IP "error_description => \s-1STRING\s0" 2
.IX Item "error_description => STRING"
A humanly readible explanation on the error.  This defaults to the
string set with the \f(CW\*(C`error\*(C'\fR option, which is not nice to read.
.IP "error_uri => \s-1URI\s0" 2
.IX Item "error_uri => URI"
Where to find more details about the error.
.IP "expires_at => \s-1TIMESTAMP\s0" 2
.IX Item "expires_at => TIMESTAMP"
Expire this token after \s-1TIMESTAMP\s0 (as produced by the \fBtime()\fR function)
.IP "expires_in => \s-1SECONDS\s0" 2
.IX Item "expires_in => SECONDS"
Expire the token \s-1SECONDS\s0 after the initiation of this object.
.IP "profile => Net::OAuth2::Profile object" 2
.IX Item "profile => Net::OAuth2::Profile object"
.PD 0
.IP "refresh_always => \s-1BOOLEAN\s0" 2
.IX Item "refresh_always => BOOLEAN"
.PD
[0.53] Auto-refresh the token at each use.
.IP "refresh_token => \s-1STRING\s0" 2
.IX Item "refresh_token => STRING"
[0.53] Token which can be used to refresh the token, after it has
expired or earlier.
.IP "scope => \s-1URL\s0" 2
.IX Item "scope => URL"
.PD 0
.IP "token_type => \s-1TYPE\s0" 2
.IX Item "token_type => TYPE"
.RE
.RS 4
.RE
.ie n .IP "Net::OAuth2::AccessToken\->\fBsession_thaw\fR($session, %options)" 4
.el .IP "Net::OAuth2::AccessToken\->\fBsession_thaw\fR($session, \f(CW%options\fR)" 4
.IX Item "Net::OAuth2::AccessToken->session_thaw($session, %options)"
.PD
Pass in the output of a \fBsession_freeze()\fR call in the past (maybe even
for an older version of this module) and get the token object revived. This
\&\f(CW$session\fR is a \s-1HASH.\s0
.Sp
You may pass any of the parameters for \fBnew()\fR as \f(CW%options\fR, to overrule
the values inside the \f(CW$session\fR.
.Sp
.Vb 2
\& \-Option \-\-Default
\&  profile  <required>
.Ve
.RS 4
.IP "profile => Net::OAuth2::Profile object" 2
.IX Item "profile => Net::OAuth2::Profile object"
.RE
.RS 4
.Sp
example:
.Sp
.Vb 9
\&  my $auth    = Net::OAuth2::Profile::WebServer\->new(...);
\&  my $token   = $auth\->get_access_token(...);
\&  my $session = $token\->session_freeze;
\&  # now save $session in database or file
\&  ...
\&  # restore session
\&  my $auth    = Net::OAuth2::Profile::WebServer\->new(...);
\&  my $token   = Net::OAuth2::AccessToken\->session_thaw($session
\&    , profile => $auth);
.Ve
.RE
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaccess_token\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaccess_token\fR()" 4
.IX Item "$obj->access_token()"
Returns the (base64 encoded version of the) access token.  The token
will get updated first, if it has expired and refresh_token is enabled,
or when new(auto_refresh) is set.
.Sp
It does not matter that the token is base64 encoded or not: it will
always need to be base64 encoded during transport.
.ie n .IP "$obj\->\fBattribute\fR(\s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBattribute\fR(\s-1NAME\s0)" 4
.IX Item "$obj->attribute(NAME)"
[0.58] Sometimes, the token gets attributes which are not standard; they
have no official accessor (yet?).  You can get them with this generic
accessor.
.ie n .IP "$obj\->\fBchanged\fR( [\s-1BOOLEAN\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBchanged\fR( [\s-1BOOLEAN\s0] )" 4
.IX Item "$obj->changed( [BOOLEAN] )"
[0.52] The session (token) needs to be saved, because any of the crucial
parameters have been modified and \f(CW\*(C`auto_save\*(C'\fR is not defined by
the profile.
.ie n .IP "$obj\->\fBhd\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhd\fR()" 4
.IX Item "$obj->hd()"
.PD 0
.ie n .IP "$obj\->\fBprofile\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBprofile\fR()" 4
.IX Item "$obj->profile()"
.ie n .IP "$obj\->\fBscope\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBscope\fR()" 4
.IX Item "$obj->scope()"
.ie n .IP "$obj\->\fBstate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstate\fR()" 4
.IX Item "$obj->state()"
.ie n .IP "$obj\->\fBtoken_type\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoken_type\fR()" 4
.IX Item "$obj->token_type()"
.PD
.PP
\fIerrors\fR
.IX Subsection "errors"
.PP
When the token is received (hence this object created) it be the
result of an error.  It is the way the original code was designed...
.ie n .IP "$obj\->\fBerror\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerror\fR()" 4
.IX Item "$obj->error()"
.PD 0
.ie n .IP "$obj\->\fBerror_description\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerror_description\fR()" 4
.IX Item "$obj->error_description()"
.ie n .IP "$obj\->\fBerror_uri\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerror_uri\fR()" 4
.IX Item "$obj->error_uri()"
.PD
.PP
\fIExpiration\fR
.IX Subsection "Expiration"
.ie n .IP "$obj\->\fBauto_refresh\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBauto_refresh\fR()" 4
.IX Item "$obj->auto_refresh()"
.PD 0
.ie n .IP "$obj\->\fBexpired\fR( [$after] )" 4
.el .IP "\f(CW$obj\fR\->\fBexpired\fR( [$after] )" 4
.IX Item "$obj->expired( [$after] )"
.PD
Returns true when the token has an expiration set and that time has
passed.  We use this token \f(CW$after\fR this check: to avoid the token to
timeout inbetween, we take (by default 15 seconds) margin.
.ie n .IP "$obj\->\fBexpires_at\fR( [$timestamp] )" 4
.el .IP "\f(CW$obj\fR\->\fBexpires_at\fR( [$timestamp] )" 4
.IX Item "$obj->expires_at( [$timestamp] )"
Returns the expiration timestamp of this token (true) or \f(CW\*(C`undef\*(C'\fR (false)
when it is not set.
.ie n .IP "$obj\->\fBexpires_in\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBexpires_in\fR()" 4
.IX Item "$obj->expires_in()"
Returns the number of seconds left, before the token is expired.  That
may be negative.
.ie n .IP "$obj\->\fBrefresh_always\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrefresh_always\fR()" 4
.IX Item "$obj->refresh_always()"
.PD 0
.ie n .IP "$obj\->\fBrefresh_token\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrefresh_token\fR()" 4
.IX Item "$obj->refresh_token()"
.ie n .IP "$obj\->\fBupdate_token\fR( $token, $tokentype, $expires_at, [$refresh_token] )" 4
.el .IP "\f(CW$obj\fR\->\fBupdate_token\fR( \f(CW$token\fR, \f(CW$tokentype\fR, \f(CW$expires_at\fR, [$refresh_token] )" 4
.IX Item "$obj->update_token( $token, $tokentype, $expires_at, [$refresh_token] )"
.PD
Change the token.
.SS "Actions"
.IX Subsection "Actions"
.ie n .IP "$obj\->\fBrefresh\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrefresh\fR()" 4
.IX Item "$obj->refresh()"
Refresh the token, even if it has not expired yet.  Returned is the
new access_token value, which may be undef on failure.
.ie n .IP "$obj\->\fBsession_freeze\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBsession_freeze\fR(%options)" 4
.IX Item "$obj->session_freeze(%options)"
This returns a \s-1SESSION\s0 (a flat \s-1HASH\s0) containing all token parameters which
needs to be saved to be able to restore this token later.  This \s-1SESSION\s0
can be passed to \fBsession_thaw()\fR to get revived.
.Sp
The \f(CW\*(C`changed\*(C'\fR flag will be cleared by this method.
.Sp
Be sure that your storage is character-set aware.  For instance, you
probably want to set 'mysql_enable_utf8' when you store this in a
MySQL database.  Perl's \s-1JSON\s0 module will output utf8 by default.
.ie n .IP "$obj\->\fBto_json\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBto_json\fR()" 4
.IX Item "$obj->to_json()"
Freeze this object into \s-1JSON.\s0  The \s-1JSON\s0 syntax is also used by the OAuth2
protocol, so a logical choice to provide.  However, generically, the
\&\fBsession_freeze()\fR method provided.
.PP
\fI\s-1HTTP\s0\fR
.IX Subsection "HTTP"
.PP
The token can be encoded in transport protocol in different ways. Using
these method will add the token to the \s-1HTTP\s0 messages sent.
.ie n .IP "$obj\->\fBdelete\fR( $uri, [$header, [$content]] )" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR( \f(CW$uri\fR, [$header, [$content]] )" 4
.IX Item "$obj->delete( $uri, [$header, [$content]] )"
.PD 0
.ie n .IP "$obj\->\fBget\fR( $uri, [$header, [$content]] )" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR( \f(CW$uri\fR, [$header, [$content]] )" 4
.IX Item "$obj->get( $uri, [$header, [$content]] )"
.ie n .IP "$obj\->\fBpost\fR( $uri, [$header, [$content]] )" 4
.el .IP "\f(CW$obj\fR\->\fBpost\fR( \f(CW$uri\fR, [$header, [$content]] )" 4
.IX Item "$obj->post( $uri, [$header, [$content]] )"
.ie n .IP "$obj\->\fBput\fR( $uri, [$header, [$content]] )" 4
.el .IP "\f(CW$obj\fR\->\fBput\fR( \f(CW$uri\fR, [$header, [$content]] )" 4
.IX Item "$obj->put( $uri, [$header, [$content]] )"
.ie n .IP "$obj\->\fBrequest\fR($request)" 4
.el .IP "\f(CW$obj\fR\->\fBrequest\fR($request)" 4
.IX Item "$obj->request($request)"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Net\-OAuth2 distribution version 0.66,
built on October 01, 2019. Website: \fIhttp://perl.overmeer.net/CPAN/\fR.
.SH "COPYRIGHTS"
.IX Header "COPYRIGHTS"
Copyrights 2013\-2019\-2018 on the perl code and the related documentation
 by [Mark Overmeer <markov@cpan.org>] for SURFnet bv, The Netherlands.  For other contributors see ChangeLog.
.PP
Copyrights 2011\-12 by Keith Grennan.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
