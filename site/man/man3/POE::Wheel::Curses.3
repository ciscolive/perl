.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "POE::Wheel::Curses 3"
.TH POE::Wheel::Curses 3 "2020-02-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Wheel::Curses \- non\-blocking input for Curses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Curses;
\&  use POE qw(Wheel::Curses);
\&
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        $_[HEAP]{console} = POE::Wheel::Curses\->new(
\&          InputEvent => \*(Aqgot_keystroke\*(Aq,
\&        );
\&      },
\&      got_keystroke => sub {
\&        my $keystroke = $_[ARG0];
\&
\&        # Make control and extended keystrokes printable.
\&        if ($keystroke lt \*(Aq \*(Aq) {
\&          $keystroke = \*(Aq<\*(Aq . uc(unctrl($keystroke)) . \*(Aq>\*(Aq;
\&        }
\&        elsif ($keystroke =~ /^\ed{2,}$/) {
\&          $keystroke = \*(Aq<\*(Aq . uc(keyname($keystroke)) . \*(Aq>\*(Aq;
\&        }
\&
\&        # Just display it.
\&        addstr($keystroke);
\&        noutrefresh();
\&        doupdate;
\&
\&        # Gotta exit somehow.
\&        delete $_[HEAP]{console} if $keystroke eq "<^C>";
\&      },
\&    }
\&  );
\&
\&  POE::Kernel\->run();
\&  exit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Wheel::Curses implements non-blocking input for Curses programs.
.PP
POE::Wheel::Curses will emit an \*(L"InputEvent\*(R" of your choosing whenever
an input event is registered on a recognized input device (keyboard
and sometimes mouse, depending on the curses library).  Meanwhile,
applications can be doing other things like monitoring network
connections or child processes, or managing timers and stuff.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
POE::Wheel::Curses is rather simple.
.SS "new"
.IX Subsection "new"
\&\fBnew()\fR creates a new POE::Wheel::Curses object.  During construction,
the wheel registers an input watcher for \s-1STDIN\s0 (via \fBselect_read()\fR) and
registers an internal handler to preprocess keystrokes.
.PP
\&\fBnew()\fR accepts only one parameter \f(CW\*(C`InputEvent\*(C'\fR.  \f(CW\*(C`InputEvent\*(C'\fR
contains the name of the event that the wheel will emit whenever there
is input on the console or terminal.  As with all wheels, the event
will be sent to the session that was active when the wheel was
constructed.
.PP
It should be noted that an application may only have one active
POE::Wheel::Curses object.
.SH "EVENTS AND PARAMETERS"
.IX Header "EVENTS AND PARAMETERS"
These are the events sent by POE::Wheel::Curses.
.SS "InputEvent"
.IX Subsection "InputEvent"
\&\f(CW\*(C`InputEvent\*(C'\fR defines the event that will be emitted when
POE::Wheel::Curses detects and reads console input.  This event
includes two parameters:
.PP
\&\f(CW$_[ARG0]\fR contains the raw keystroke as received by \fBCurses::getch()\fR.
An application may process the keystroke using \fBCurses::unctrl()\fR and
\&\fBCurses::keyname()\fR on the keystroke.
.PP
\&\f(CW$_[ARG1]\fR contains the POE::Wheel::Curses object's \s-1ID.\s0
.PP
Mouse events aren't portable.  As of October 2009, it's up to the
application to decide whether to call \fBmousemask()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Curses documents what can be done with Curses.  Also see the man
page for whichever version of libcurses happens to be installed
(curses, ncurses, etc.).
.PP
POE::Wheel describes wheels in general.
.PP
The \s-1SEE ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.SH "BUGS"
.IX Header "BUGS"
None known, although curses implementations vary widely.
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Please see \s-1POE\s0 for more information about authors and contributors.
