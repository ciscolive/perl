.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Factory 3"
.TH Workflow::Factory 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Factory \- Generates new workflow and supporting objects
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.18 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # Import the singleton for easy access
\& use Workflow::Factory qw( FACTORY );
\&
\& # Add XML configurations to the factory
\& FACTORY\->add_config_from_file( workflow  => \*(Aqworkflow.xml\*(Aq,
\&                                action    => [ \*(Aqmyactions.xml\*(Aq, \*(Aqotheractions.xml\*(Aq ],
\&                                validator => [ \*(Aqvalidator.xml\*(Aq, \*(Aqmyvalidators.xml\*(Aq ],
\&                                condition => \*(Aqcondition.xml\*(Aq,
\&                                persister => \*(Aqpersister.xml\*(Aq );
\&
\& # Create a new workflow of type \*(AqMyWorkflow\*(Aq
\& my $wf = FACTORY\->create_workflow( \*(AqMyWorkflow\*(Aq );
\&
\& # Fetch an existing workflow with ID \*(Aq25\*(Aq
\& my $wf = FACTORY\->fetch_workflow( \*(AqMyWorkflow\*(Aq, 25 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Public"
.IX Subsection "Public"
The Workflow Factory is your primary interface to the workflow
system. You give it the configuration files and/or data structures for
the Workflow, Workflow::Action, Workflow::Condition,
Workflow::Persister, and Workflow::Validator objects and then
you ask it for new and existing Workflow objects.
.SS "Internal"
.IX Subsection "Internal"
Developers using the workflow system should be familiar with how the
factory processes configurations and how it makes the various
components of the system are instantiated and stored in the factory.
.SH "METHODS"
.IX Header "METHODS"
.SS "Public Methods"
.IX Subsection "Public Methods"
\fI\f(BIinstance()\fI\fR
.IX Subsection "instance()"
.PP
The factory is a singleton, this is how you get access to the
instance. You can also just import the '\s-1FACTORY\s0' constant as in the
\&\*(L"\s-1SYNOPSIS\*(R"\s0.
.PP
\fIcreate_workflow( \f(CI$workflow_type\fI, \f(CI$context\fI, \f(CI$wf_class\fI )\fR
.IX Subsection "create_workflow( $workflow_type, $context, $wf_class )"
.PP
Create a new workflow of type \f(CW$workflow_type\fR. This will create a
new record in whatever persistence mechanism you have associated with
\&\f(CW$workflow_type\fR and set the workflow to its initial state.
.PP
The \f(CW$context\fR argument is optional, you can pass an exisiting instance
of Workflow::Context to be reused. Otherwise a new instance is created.
.PP
The \f(CW$wf_class\fR argument is optional. Pass it the name of a class to be
used for the workflow to be created. By default, all workflows are of the
\&\fIWorkflow\fR class.
.PP
Any observers you've associated with this workflow type will be
attached to the returned workflow object.
.PP
This fires a 'create' event from the just-created workflow object. See
\&\f(CW\*(C`WORKFLOWS ARE OBSERVABLE\*(C'\fR in Workflow for more.
.PP
Returns: newly created workflow object.
.PP
\fIfetch_workflow( \f(CI$workflow_type\fI, \f(CI$workflow_id\fI, \f(CI$context\fI, \f(CI$wf_class\fI )\fR
.IX Subsection "fetch_workflow( $workflow_type, $workflow_id, $context, $wf_class )"
.PP
Retrieve a workflow object of type \f(CW$workflow_type\fR and \s-1ID\s0
\&\f(CW$workflow_id\fR. (The \f(CW$workflow_type\fR is necessary so we can fetch
the workflow using the correct persister.) If a workflow with \s-1ID\s0
\&\f(CW$workflow_id\fR is not found \f(CW\*(C`undef\*(C'\fR is returned.
.PP
The \f(CW$context\fR argument is optional, you can pass an exisiting instance
of Workflow::Context to be reused. Otherwise a new instance is created.
.PP
The \f(CW$wf_class\fR argument is optional. Pass it the name of a class to be
used for the workflow to be created. By default, all workflows are of the
\&\fIWorkflow\fR class.
.PP
Any observers you've associated with this workflow type will be
attached to the returned workflow object.
.PP
This fires a 'fetch' event from the retrieved workflow object. See
\&\f(CW\*(C`WORKFLOWS ARE OBSERVABLE\*(C'\fR in Workflow for more.
.PP
Throws exception if no workflow type \f(CW$workflow_type\fR available.
.PP
Returns: Workflow object
.PP
\fIadd_config_from_file( \f(CI%config_declarations\fI )\fR
.IX Subsection "add_config_from_file( %config_declarations )"
.PP
Pass in filenames for the various components you wish to initialize
using the keys 'action', 'condition', 'persister', 'validator' and
\&'workflow'. The value for each can be a single filename or an arrayref
of filenames.
.PP
The system is familiar with the 'perl' and 'xml' configuration formats
\&\*(-- see the 'doc/configuration.txt' for what we expect as the format
and will autodetect the types based on the file extension of each
file. Just give your file the right extension and it will be read in
properly.
.PP
You may also use your own custom configuration file format \*(-- see
\&\f(CW\*(C`SUBCLASSING\*(C'\fR in Workflow::Config for what you need to do.
.PP
You can also read it in yourself and add the resulting hash reference
directly to the factory using \f(CW\*(C`add_config()\*(C'\fR. However, you need to
ensure the configurations are added in the proper order \*(-- when you
add an 'action' configuration and reference 'validator' objects, those
objects should already be read in. A good order is: 'validator',
\&'condition', 'action', 'workflow'. Then just pass the resulting hash
references to \f(CW\*(C`add_config()\*(C'\fR using the right type and the behavior
should be exactly the same.
.PP
Returns: nothing; if we run into a problem parsing one of the files or
creating the objects it requires we throw a Workflow::Exception.
.PP
\fIadd_config( \f(CI%config_hashrefs\fI )\fR
.IX Subsection "add_config( %config_hashrefs )"
.PP
Similar to \f(CW\*(C`add_config_from_file()\*(C'\fR \*(-- the keys may be 'action',
\&'condition', 'persister', 'validator' and/or 'workflow'. But the
values are the actual configuration hashrefs instead of the files
holding the configurations.
.PP
You normally will only need to call this if you are programmatically
creating configurations (e.g., hot-deploying a validator class
specified by a user) or using a custom configuration format and for
some reason do not want to use the built-in mechanism in
Workflow::Config to read it for you.
.PP
Returns: nothing; if we encounter an error trying to create the
objects referenced in a configuration we throw a
Workflow::Exception.
.PP
\fIget_persister_for_workflow_type\fR
.IX Subsection "get_persister_for_workflow_type"
.PP
\fIget_persisters\fR
.IX Subsection "get_persisters"
.PP
#TODO
.PP
\fIget_validators\fR
.IX Subsection "get_validators"
.PP
#TODO
.SS "Internal Methods"
.IX Subsection "Internal Methods"
#TODO
.PP
\fIsave_workflow( \f(CI$workflow\fI )\fR
.IX Subsection "save_workflow( $workflow )"
.PP
Stores the state and current datetime of the \f(CW$workflow\fR object. This
is normally called only from the Workflow \f(CW\*(C`execute_action()\*(C'\fR
method.
.PP
This method respects transactions if the selected persister supports it.
Currently, the DBI-based persisters will commit the workflow transaction
if everything executes successfully and roll back if something fails.
Note that you need to manage any Workflow::Persister::DBI::ExtraData
transactions yourself.
.PP
Returns: \f(CW$workflow\fR
.PP
\fIget_workflow_history( \f(CI$workflow\fI )\fR
.IX Subsection "get_workflow_history( $workflow )"
.PP
Retrieves all Workflow::History objects related to \f(CW$workflow\fR.
.PP
\&\fB\s-1NOTE\s0\fR: Normal users get the history objects from the Workflow
object itself. Under the covers it calls this.
.PP
Returns: list of Workflow::History objects
.PP
\fIget_action( \f(CI$workflow\fI, \f(CI$action_name\fI )\fR
.IX Subsection "get_action( $workflow, $action_name )"
.PP
Retrieves the action \f(CW$action_name\fR from workflow \f(CW$workflow\fR. Note
that this does not do any checking as to whether the action is proper
given the state of \f(CW$workflow\fR or anything like that. It is mostly an
internal method for Workflow (which \fBdoes\fR do checking as to the
propriety of the action) to instantiate new actions.
.PP
Throws exception if no action with name \f(CW$action_name\fR available.
.PP
Returns: Workflow::Action object
.PP
\fIget_persister( \f(CI$persister_name\fI )\fR
.IX Subsection "get_persister( $persister_name )"
.PP
Retrieves the persister with name \f(CW$persister_name\fR.
.PP
Throws exception if no persister with name \f(CW$persister_name\fR
available.
.PP
\fIget_condition( \f(CI$condition_name\fI )\fR
.IX Subsection "get_condition( $condition_name )"
.PP
Retrieves the condition with name \f(CW$condition_name\fR.
.PP
Throws exception if no condition with name \f(CW$condition_name\fR
available.
.PP
\fIget_validator( \f(CI$validator_name\fI )\fR
.IX Subsection "get_validator( $validator_name )"
.PP
Retrieves the validator with name \f(CW$validator_name\fR.
.PP
Throws exception if no validator with name \f(CW$validator_name\fR
available.
.SS "Internal Configuration Methods"
.IX Subsection "Internal Configuration Methods"
\fI_add_workflow_config( \f(CI@config_hashrefs\fI )\fR
.IX Subsection "_add_workflow_config( @config_hashrefs )"
.PP
Adds all configurations in \f(CW@config_hashrefs\fR to the factory. Also
cycles through the workflow states and creates a Workflow::State
object for each. These states are passed to the workflow when it is
instantiated.
.PP
We also require any necessary observer classes and throw an exception
if we cannot. If successful the observers are kept around and attached
to a workflow in \*(L"\fBcreate_workflow()\fR\*(R" and \*(L"\fBfetch_workflow()\fR\*(R".
.PP
Returns: nothing
.PP
\fI_add_action_config( \f(CI@config_hashrefs\fI )\fR
.IX Subsection "_add_action_config( @config_hashrefs )"
.PP
Adds all configurations in \f(CW@config_hashrefs\fR to the factory, doing a
\&'require' on the class referenced in the 'class' attribute of each
action.
.PP
Throws an exception if there is no 'class' associated with an action
or if we cannot 'require' that class.
.PP
Returns: nothing
.PP
\fI_add_persister_config( \f(CI@config_hashrefs\fI )\fR
.IX Subsection "_add_persister_config( @config_hashrefs )"
.PP
Adds all configurations in \f(CW@config_hashrefs\fR to the factory, doing a
\&'require' on the class referenced in the 'class' attribute of each
persister.
.PP
Throws an exception if there is no 'class' associated with a
persister, if we cannot 'require' that class, or if we cannot
instantiate an object of that class.
.PP
Returns: nothing
.PP
\fI_add_condition_config( \f(CI@config_hashrefs\fI )\fR
.IX Subsection "_add_condition_config( @config_hashrefs )"
.PP
Adds all configurations in \f(CW@config_hashrefs\fR to the factory, doing a
\&'require' on the class referenced in the 'class' attribute of each
condition.
.PP
Throws an exception if there is no 'class' associated with a
condition, if we cannot 'require' that class, or if we cannot
instantiate an object of that class.
.PP
Returns: nothing
.PP
\fI_add_validator_config( \f(CI@config_hashrefs\fI )\fR
.IX Subsection "_add_validator_config( @config_hashrefs )"
.PP
Adds all configurations in \f(CW@config_hashrefs\fR to the factory, doing a
\&'require' on the class referenced in the 'class' attribute of each
validator.
.PP
Throws an exception if there is no 'class' associated with a
validator, if we cannot 'require' that class, or if we cannot
instantiate an object of that class.
.PP
Returns: nothing
.PP
\fI_commit_transaction\fR
.IX Subsection "_commit_transaction"
.PP
Calls the commit method in the workflow's persister.
.PP
Returns: nothing
.PP
\fI_rollback_transaction\fR
.IX Subsection "_rollback_transaction"
.PP
Calls the rollback method in the workflow's persister.
.PP
\fIassociate_observers_with_workflow\fR
.IX Subsection "associate_observers_with_workflow"
.PP
Add defined observers with workflow.
.PP
The workflow has to be provided as the single parameter accepted by this
method.
.PP
The observers added will have to be of the type relevant to the workflow type.
.PP
\fInew\fR
.IX Subsection "new"
.PP
The new method is a dummy constructor, since we are using a factory it makes
no sense to call new \- and calling new will result in a Workflow::Exception
.PP
\&\*(L"instance\*(R" should be called or the imported '\s-1FACTORY\s0' should be utilized.
.SH "DYNAMIC CONFIG LOADING"
.IX Header "DYNAMIC CONFIG LOADING"
If you have either a large set of config files or a set of very large
config files then you may not want to incur the overhead of loading
each and every one on startup if you cannot predict which set you will
use in that instance of your application.
.PP
This approach doesn't make much sense in a persistent environment such
as mod_perl but it may lower startup costs if you have regularly
scheduled scripts that may not need to touch all possible types of
workflow.
.PP
To do this you can specify a callback that the factory will use to
retrieve batched hashes of config declarations. Whenever an unknown
workflow name is encountered the factory will first try to load your
config declarations then continue.
.PP
The callback takes one argument which is the workflow type. It should
return a reference to a hash of arguments in a form suitable for
\&\f(CW\*(C`add_config_from_file\*(C'\fR.
.PP
For example:
.PP
.Vb 2
\& use Workflow::Factory qw(FACTORY);
\& use My::Config::System;
\&
\& sub init {
\&   my $self = shift;
\&
\&   FACTORY\->config_callback(
\&     sub {
\&       my $wf_type = shift;
\&       my %ret = My::Config::System\->get_files_for_wf( $wf_type ) || ();
\&       return \e%ret;
\&     }
\&   );
\& }
.Ve
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Implementation and Usage"
.IX Subsection "Implementation and Usage"
You can subclass the factory to implement your own methods and still
use the useful facade of the \f(CW\*(C`FACTORY\*(C'\fR constant. For instance, the
implementation is typical Perl subclassing:
.PP
.Vb 1
\& package My::Cool::Factory;
\&
\& use strict;
\& use base qw( Workflow::Factory );
\&
\& sub some_cool_method {
\&     my ( $self ) = @_;
\&     ...
\& }
.Ve
.PP
To use your factory you can just do the typical import:
.PP
.Vb 1
\& #!/usr/bin/perl
\&
\& use strict;
\& use My::Cool::Factory qw( FACTORY );
.Ve
.PP
Or you can call \f(CW\*(C`instance()\*(C'\fR directly:
.PP
.Vb 1
\& #!/usr/bin/perl
\&
\& use strict;
\& use My::Cool::Factory;
\&
\& my $factory = My::Cool::Factory\->instance();
.Ve
.SH "GLOBAL RUN-TIME OPTIONS"
.IX Header "GLOBAL RUN-TIME OPTIONS"
Setting package variable \fB\f(CB$VALIDATE_ACTION_CONFIG\fB\fR to a true value (it
is undef by default) turns on optional validation of extra attributes
of Workflow::Action configs.  See Workflow::Action for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Workflow
.PP
Workflow::Action
.PP
Workflow::Condition
.PP
Workflow::Config
.PP
Workflow::Persister
.PP
Workflow::Validator
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2010 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonas B. Nielsen (jonasbn) <jonasbn@cpan.org> is the current maintainer.
.PP
Chris Winters E <lt> chris \f(CW@cwinters\fR . comE <gt>, original author .
