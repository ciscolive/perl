.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "HTML::ParseBrowser 3"
.TH HTML::ParseBrowser 3 "2020-08-25" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::ParseBrowser \- Simple interface for User\-Agent string parsing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTML::ParseBrowser;
\&
\&  # Opera 6 on Windows 98, French
\&  my $uastring = \*(AqMozilla/4.0 (compatible; MSIE 5.0; Windows 98) Opera 6.0  [fr]\*(Aq;
\&
\&  my $ua = HTML::ParseBrowser\->new($uastring);
\&  print "Browser  : ", $ua\->name, "\en";
\&  print "Version  : ", $ua\->v, "\en";
\&  print "OS       : ", $ua\->os, "\en";
\&  print "Language : ", $ua\->language, "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
HTML::ParseBrowser is a module for parsing a User-Agent string, and providing access to
parts of the string, such as browser name, version, and operating system.
Some of the returned values are exactly as they appeared in the User-Agent string,
and others are interpreted; for example Internet Explorer identifies itself as \fB\s-1MSIE\s0\fR,
but the \fBname\fR method will return \fBInternet Explorer\fR.
.PP
It provides the following methods:
.IP "\fBnew()\fR (constructor method)" 4
.IX Item "new() (constructor method)"
Accepts an optional User Agent string as an argument. If present, the string
will be parsed and the object populated. Either way the base object will be
created.
.IP "\fBParse()\fR" 4
.IX Item "Parse()"
Intended to be given a User Agent string as an argument. If present, it will be
parsed and the object repopulated.
.Sp
If called without a true argument or with the argument '\-' \fBParse()\fR will simply
depopulate the object and return undef. (This is useful for parsing logs, which
often fill in a '\-' for a null value.)
.IP "Access methods" 4
.IX Item "Access methods"
The following methods are used to access different parts of the User-Agent string.
.Sp
If the particular piece of information wasn't included in the User-Agent string
provided, or it couldn't be parsed, then the relevant method will return undef.
.Sp
Also, not that some browsers let the user change the User-Agent string,
as do many libraries. So there is no guarantee that a User-Agent string you
find in a logfile is valid, or makes sense.
.IP "\fBuser_agent()\fR" 4
.IX Item "user_agent()"
The original User-Agent string you passed to \fBParse()\fR or \fBnew()\fR.
.IP "\fBlanguages()\fR" 4
.IX Item "languages()"
Returns an arrayref of all languages recognised by placement and context in the
User-Agent string. Uses English names of languages encountered where
comprehended, or the \s-1ISO\s0 two-letter language code otherwise.
.IP "\fBlanguage()\fR" 4
.IX Item "language()"
Returns the language of the browser, interpreted as an English language name if
possible, as above. If more than one language are uncovered in the string,
chooses the one most repeated or the first encountered on any tie.
.IP "\fBlangs()\fR" 4
.IX Item "langs()"
Like \fBlanguages()\fR above, except uses \s-1ISO\s0 standard language codes always.
.IP "\fBlang()\fR" 4
.IX Item "lang()"
Like \fBlanguage()\fR above, but only containing the \s-1ISO\s0 language code.
.IP "\fBdetail()\fR" 4
.IX Item "detail()"
The stuff inside any parentheses encountered. If the User-Agent string contains
more than one set of parentheses, this method will return the result of concatenating
all of the. This seems sub-optimal, but works for the moment.
.IP "\fBuseragents()\fR" 4
.IX Item "useragents()"
Returns an arrayref of all intelligible standard User Agent engine/version
pairs, and Opera's, to, if applicable. (Please note that this is despiute the
fact that Opera's is \fInot\fR intelligible.)
.IP "\fBproperties()\fR" 4
.IX Item "properties()"
Returns an arrayref of the stuff in \fBdetails()\fR broken up by /;\es+/
.IP "\fBname()\fR" 4
.IX Item "name()"
The \fIinterpreted\fR name of the browser. This value may not actually appear
anywhere inside the string you handed it. For example, Internet Explorer identifies
itself in the User-Agent string as \fB\s-1MSIE\s0\fR,
but this method will return \fBInternet Explorer\fR.
.IP "\fBversion()\fR" 4
.IX Item "version()"
Returns a hashref containing v, major, and minor, as explained below and keyed as such.
.IP "v()" 4
.IX Item "v()"
The full version of the useragent (i.e. '5.6.0').
.IP "\fBmajor()\fR" 4
.IX Item "major()"
The Major version number. For Safari 5.1 this method would return 5.
.IP "\fBminor()\fR" 4
.IX Item "minor()"
The Minor version number. For Opera 9.0.1, this method would return 0.
.IP "\fBos()\fR" 4
.IX Item "os()"
The Operating System the browser is running on.
.IP "\fBostype()\fR" 4
.IX Item "ostype()"
The \fIinterpreted\fR type of the Operating System.
For instance, 'Windows' rather than 'Windows 9x 4.90'
For 'Android', \f(CW\*(C`os()\*(C'\fR returns 'Android' and \f(CW\*(C`ostype()\*(C'\fR returns 'Linux'.
.IP "\fBosvers()\fR" 4
.IX Item "osvers()"
The \fIinterpreted\fR version of the Operating System. For instance, '\s-1ME\s0' rather than '9x 4.90'
.Sp
Note: Windows \s-1NT\s0 versions below 5 will show up with ostype 'Windows \s-1NT\s0' and
osvers as appropriate. Windows \s-1NT\s0 version 5 will show up as ostype
\&'Windows \s-1NT\s0' and osvers '2000'. Windows \s-1NT 5.1+\s0 will show up as osvers '\s-1XP\s0',
until it gets to 6, where it will become Vista, until 6.06 which will be reported
as 'Server 2008'.
.IP "\fBosarc()\fR" 4
.IX Item "osarc()"
While rarely defined, some User-Agent strings happily announce some detail or
another about the Architecture they are running under. If this happens, it will
be reflected here. Linux ('i686') and Mac ('\s-1PPC\s0') are more likely than Windows
to do this, strangely.
.Sp
Apparently, Firefox 3 reports the wrong \s-1OS\s0 version on Vista,
so it's impossible to tell \s-1FF3\s0 on Vista from \s-1FF3\s0 on \s-1XP.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I have done a review of all \s-1CPAN\s0 modules for parsing the User-Agent string.
If you have a specific need, it may be worth reading the review, to find
the best match:
.PP
http://blogs.perl.org/users/neilb/2011/10/cpan\-modules\-for\-parsing\-user\-agent\-strings.html
.PP
In brief, the following modules are worth considering.
.PP
Parse::HTTP::UserAgent has best overall coverage of different browsers
and other user agents.
.PP
HTTP::DetectUserAgent doesn't have as good coverage,
but handles modern browsers well, and is the
fastest module, so if you're processing large logfiles, this might
be the best choice.
.PP
HTTP::UserAgentString::Parser is by far the fastest, and has good
coverage of modern browsers.
.PP
Woothee is available for a number of programming languages, not just Perl.
It is faster than most of the modules, and has good coverage of the most
popular browsers, but not as good overall coverage.
.PP
HTTP::BrowserDetect has poorest coverage of the modules listed here,
and doesn't do well at
recognising version numbers. It's the best module for detecting whether
a given agent is a robot/crawler though.
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/neilbowers/HTML\-ParseBrowser>
.SH "AUTHOR"
.IX Header "AUTHOR"
Dodger (aka Sean Cannon)
.PP
Recent changes by Neil Bowers.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
The HTML::ParseBrowser module and code therein is
Copyright (c) 2001\-2008 Sean Cannon
.PP
Changes in 1.01 and later are Copyright (C) 2012\-2014, Neil Bowers.
.PP
All rights reserved. All rights reversed.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public
License or the Artistic License, as specified in the Perl \s-1README\s0 file.
