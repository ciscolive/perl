.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Types::Core 3"
.TH Types::Core 3 "2019-10-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Types::Core \- Core types defined as tests and literals (ease of use)
.SH "VERSION"
.IX Header "VERSION"
Version \*(L"0.2.7\*(R";
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my @data_types = (ARRAY CODE GLOB HASH IO REF SCALAR);
\&  my $ref = $_[0];
\&  P "Error: expected %s", HASH unless HASH $ref;
.Ve
.PP
Syntax symplifier for type checking.
.PP
Allows easy, unquoted use of var types (\s-1ARRAY, SCALAR,\s0 etc.) 
as literals, and allows standard type names to be used as boolean 
checks of the type of a reference as well as passing through the value
of the reference.  For example: \f(CW\*(C`HASH $href\*(C'\fR will return true
if the reference points to a \s-1HASH\s0 or a HASH-based object.
For example, \*(L"\s-1HASH\s0 \f(CW$href\fR\*(R" 
check routines of references.
.SH "USAGE"
.IX Header "USAGE"
.RS 4
\&\fB\f(CB\*(C`TYPE <Ref\*(C'\fB\fR>  \-  Check if \fIRef\fR has underlying type, \fI\s-1TYPE\s0\fR
.Sp
\&\fB\f(CB\*(C`TYPE\*(C'\fB\fR  \-  Literal usage equal to itself
.RE
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&  printf "type = %s\en", HASH if HASH $var;
.Ve
.PP
Same as:
.PP
.Vb 1
\&  printf "type = %s\en", \*(AqHASH\*(Aq if ref $var eq \*(AqHASH\*(Aq;)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
For the most basic functions listed in the Synopsis, they take
either 0 or 1 arguments.  If 1 parameter, then they test it
to see if the \f(CW\*(C`ref\*(C'\fR is of the given \fItype\fR (blessed or not).
If false, \fI\f(CI\*(C`undef\*(C'\fI\fR is returned, of true, the ref, itself is returned.
.PP
For no args, they return literals of themselves, allowing the 
named strings to be used as Literals w/o quotes.
.SH "MORE EXAMPLES"
.IX Header "MORE EXAMPLES"
Initialization
.IX Subsection "Initialization"
.PP
.Vb 1
\&  our %field_types = (Paths{type => ARRAY, ...});
.Ve
.PP
Flow Routing
.IX Subsection "Flow Routing"
.PP
.Vb 5
\&    ...
\&    my $ref_arg = ref $arg;
\&    return  ARRAY $ref_arg              ? statAR_2_Ino_t($path,$arg)  :
\&            InClass(\*(Aqstat_t\*(Aq, $ref_arg) ? stat_t_2_Ino_t($path, $arg) :
\&            _path_2_Ino_t($path); }
.Ve
.PP
Data Verification
.IX Subsection "Data Verification"
.PP
.Vb 7
\&  sub Type_check($;$) { ...
\&    if (ARRAY $cfp) { 
\&      for (@$cfp) { 
\&        die P "Field %s does not exist", $_ unless exists $v\->{$_}; 
\&        my $cls_ftpp = $class."::field_types"; 
\&        if (HASH $cls_ftpp) { 
\&          if ($cls_ftpp\->{type} eq ARRAY) {  ...
.Ve
.PP
Param Checking
.IX Subsection "Param Checking"
.PP
.Vb 3
\&  sub popable (+) { 
\&    my $ar = $_[0]; 
\&    ARRAY $ar or die P "popable only works with arrays, not %s", ref $ar; }
.Ve
.PP
Return Value Checks and Dereference Protection
.IX Subsection "Return Value Checks and Dereference Protection"
.PP
.Vb 2
\&  my $Inos = $mp\->get_sorted_Ino_t_Array; 
\&  return undef unless ARRAY $Inos and @$Inos >= 2;
.Ve
.ie n .SS "Non-instantiating existence checks in references: ""ErV""."
.el .SS "Non-instantiating existence checks in references: \f(CWErV\fP."
.IX Subsection "Non-instantiating existence checks in references: ErV."
 
.PP
.Vb 2
\&     ErV $ref, FIELDNAME;        # Exist[in]reference? Value : C<undef>
\&     ErV $hashref, FIELDNAME;    # Exist[in]hashref?   Value : C<undef>
.Ve
.Sp
.RS 4
If fieldname exists in the ref pointed to by the reference, return the value,
else return undef.
.RE
.SS "Note: What's EhV? (Deprecated)"
.IX Subsection "Note: What's EhV? (Deprecated)"
.Vb 3
\&  You may see older code using C<EhV>.  M<Types::Core> only had this checker
\&  for hashes, but given combinations of various references, the more
\&  general C<ErV> replaced it.
.Ve
.ie n .SH "OPTIONAL FUNCTIONS:  ""typ"" & ""blessed"""
.el .SH "OPTIONAL FUNCTIONS:  \f(CWtyp\fP & \f(CWblessed\fP"
.IX Header "OPTIONAL FUNCTIONS: typ & blessed"
 
.PP
.Vb 1
\&     typ REF;                    #return underlying type of REF
.Ve
.PP
Once you bless a reference to an object, its type becomes hidden
from \f(CW\*(C`ref\*(C'\fR.  \f(CW\*(C`typ\*(C'\fR allows you to peek into a class reference to
see the basic perl type that the class is based on.
.PP
Most users of a class won't have a need for that information, 
but a 'friend' of the class might in order to offer helper functions.
.PP
.Vb 1
\&    blessed REF;                #test if REF is blessed or not
.Ve
.PP
Included for it's usefulness in type checking.  Similar functionality
as implemented in Scalar::Util. This version of \f(CW\*(C`blessed\*(C'\fR
will use the \f(CW\*(C`Scalar::Util\*(C'\fR version if it is already present.
Otherwise it uses a pure-perl implementation.
.ie n .SH "EXAMPLE:  ""ErV"""
.el .SH "EXAMPLE:  \f(CWErV\fP"
.IX Header "EXAMPLE: ErV"
 
.PP
To prevent automatic creation of variables when accessed
or tested for \f(CW\*(C`undef\*(C'\fR, (i.e. autovivification), one must test
for existence first, before attempting to read or test the
\&'defined'\-ness of the value.
.PP
This results in a 2 step process to retrive a value:
.PP
.Vb 1
\&  exists $name{$testname} ? $name{testname} : undef;
.Ve
.PP
If you have multiple levels of hash tables say retrieving \s-1SSN\s0's
via {$lastname}{$firstname} in object member 'name2ssns' but
don't know if the object member is valid or not, the safe way
to write this would be:
.PP
.Vb 11
\&  my $p = $this;
\&  if (exists $p\->{name2ssns} && defined $p\->{name2ssns}) {
\&    $p = $p\->{name2ssns};
\&    if (exists $p\->{$lastname} && defined $p\->{$lastname}) {
\&      $p = $p\->{$lastname};
\&      if (exists $p\->{$firstname}) {
\&        return $p\->{$firstname};
\&      }
\&    }
\&  }
\&  return undef;
.Ve
.PP
\&\f(CW\*(C`ErV\*(C'\fR saves some steps.  Instead of testing for existence, 'definedness',
and then use the value to go deeper in the structuer, \f(CW\*(C`ErV\*(C'\fR does the
testing and returns the value (or undef) in one step.
Thus, the above could be written:
.PP
.Vb 4
\&  my $p = $this;
\&  return $p = ErV $p, name2ssns      and
\&             $p = ErV $p, $lastname  and 
\&                  ErV $p, $firstname;
.Ve
.PP
This not only saves coding space & time, but allows faster
comprehension of what is going on (presuming familiarity 
with \f(CW\*(C`ErV\*(C'\fR).
.PP
Multiple levels of hashes or arrays may be tested in one usage. Example:
.PP
.Vb 5
\&  my $nested_refs = {};
\&  $nested_refs\->{a}{b}{c}{d}[2]{f}[1] = 7;
\&  P "\-\-\-\enval=%s", ErV $nested_refs, a, b, c, d, e, f, g;
\&  \-\-\-
\&  val=7
\&
\&  The current ErV handles around thirty levels of nested hashing.
.Ve
.ie n .SS "\s-1MORE OPTIONAL FUNCTIONS\s0 ""mk_array"" and ""mk_hash"""
.el .SS "\s-1MORE OPTIONAL FUNCTIONS\s0 \f(CWmk_array\fP and \f(CWmk_hash\fP"
.IX Subsection "MORE OPTIONAL FUNCTIONS mk_array and mk_hash"
$<  >
.PP
.Vb 1
\&    mk_array $p\->ar;
.Ve
.PP
without \f(CW\*(C`mk_array\*(C'\fR, the following generates a runtime error (can't
use an undefined value as an \s-1ARRAY\s0 reference):
.PP
.Vb 2
\&    my $ar;
\&    printf "items in ar:%s\en", 0+@{$ar};
.Ve
.PP
but using mk_array will ensure there is an \s-1ARRAY\s0 ref there if there
is not one there already:
.PP
.Vb 3
\&    my $ar;
\&    mk_array $ar;
\&    printf "items in ar:%s\en", 0+@{$ar};
.Ve
.PP
While the above would be solved by initalizing \f(CW$ar\fR when defined,
expicit initialization might be useful to protect against the same
type of error in dynamically allocated variables.
.ie n .SH "UTILITY FUNCTIONS:  ""isnum"" & ""Cmp"""
.el .SH "UTILITY FUNCTIONS:  \f(CWisnum\fP & \f(CWCmp\fP"
.IX Header "UTILITY FUNCTIONS: isnum & Cmp"
 
.PP
.Vb 1
\&     isnum STR              #return <NUM> if it starts at beginning of STR
\&
\&     Cmp [$p1,$p2]          # C<cmp>\-like function for nested structures
\&                            # uses C<$a>, C<$b> as default inputs
\&                            # can be used in sort for well\-behaved data
\&                            # (incompare\-able data will return undef)
\&                            # builtin debug to see where compare fails
\&#
.Ve
.PP
\&\f(CW\*(C`isnum\*(C'\fR checks for a number (int, float, or with exponent) at the 
beginning of the string passed in.  With no argument uses \f(CW$_\fR
as the parameter.  Returns the number with any non-number suffix
stripped off or \f(CW\*(C`undef\*(C'\fR if no num is found at the beginning
of the string.  \f(CW\*(C`isnum\*(C'\fR is an optional import that must be included
via \f(CW@EXPORTS_OK\fR.  Note: to determine if false, you must use
\&\f(CW\*(C`defined(isnum)\*(C'\fR since numeric '0' can be returned and would also
evaluate to false.
.PP
The existence of \f(CW\*(C`Cmp\*(C'\fR is a \fBside effect of testing\fR needs.  To compare
validity of released functions, it was necessary to recursively 
compare nested data structures.  To support development, debug
output was added that can be toggled on at runtime to see where
a compare fails.
.PP
Normally you only use two parameters \f(CW$a\fR and \f(CW$b\fR that are references
to the data structures to be compared.  If debugging is wanted,
a third (or first if \f(CW$a\fR and \f(CW$b\fR are used) parameter can be 
pass with a non-zero value to enable primitive debug output.
.PP
Additionally, if the compare \fIfails\fR and does not return an integer
value (returning \f(CW\*(C`undef\*(C'\fR instead), a 2nd return value can tell you
where in the compare it failed.  To grab that return value,
use a two element list or an array to catch the status, like
.PP
.Vb 1
\&  C<my ($result, $err)=Cmp; (pointers passed in C<$a> and C<$b>)
.Ve
.PP
If the compare was successful, it will return \-1, 0 or 1 as 'cmp'
does. If it fails, \f(CW$result\fR will contain \f(CW\*(C`undef\*(C'\fR and \f(CW$err\fR will
contain a number indicating what test failed.
.PP
Failures can occur if Cmp is asked to compare different object with
different refs ('blessed' refname), or same blessed class and different
underlying types.  Unbless values and those in the same classes can
be compared.
.SH "NOTE on INCLUDING OPTIONAL (EXPORT_OK) FUNCTIONS"
.IX Header "NOTE on INCLUDING OPTIONAL (EXPORT_OK) FUNCTIONS"
Importing optional functions \fBdoes not\fR cancel default imports 
as this module uses Xporter. To dselect default exports, add
\&'\f(CW\*(C`\-\*(C'\fR' (\fIminus\fR or \fIdash\fR) at the beginning of argument list to 
\&\f(CW\*(C`Types::Core\*(C'\fR as in \f(CW\*(C`use Types::Core qw(\- blessed);\*(C'\fR.
See Xporter for more details.
.PP
\fI\s-1COMPATIBILITY NOTE:\s0 with Perl 5.12.5 and earlier\fR
.IX Subsection "COMPATIBILITY NOTE: with Perl 5.12.5 and earlier"
.Sp
.RS 4
In order for earlier perls to parse things correctly parentheses are needed
for two or more arguments after a \fBErV\fR test verb.
.RE
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 594:" 4
.IX Item "Around line 594:"
=back without =over
.IP "Around line 598:" 4
.IX Item "Around line 598:"
=over without closing =back
