.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::RoboCop 3"
.TH WWW::RoboCop 3 "2020-07-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RoboCop \- Police your URLs!
.SH "VERSION"
.IX Header "VERSION"
version 0.000100
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use feature qw( state );
\&
\&    use WWW::RoboCop;
\&
\&    my $robocop = WWW::RoboCop\->new(
\&        is_url_allowed => sub {
\&            state $count = 0;
\&            return $count++ < 5; # just crawl 5 URLs
\&        },
\&    );
\&
\&    $robocop\->crawl( \*(Aqhttp://host.myhost.com/start\*(Aq );
\&
\&    my %history = $robocop\->get_report;
\&
\&    # %history = (
\&    #    \*(Aqhttp://myhost.com/one\*(Aq => { status => 200, ... },
\&    #    \*(Aqhttp://myhost.com/two\*(Aq => { status => 404, ... },
\&    #    ...
\&    # )
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1BETA BETA BETA\s0!
.PP
\&\f(CW\*(C`WWW::RoboCop\*(C'\fR is a dead simple, somewhat opinionated robot.  Given a starting
page, this module will crawl only URLs which have been allowed by the
\&\f(CW\*(C`is_url_allowed\*(C'\fR callback.  It then creates a report of all visited pages,
keyed on \s-1URL.\s0  You are encouraged to provide your own report creation callback
so that you can collect all of the information which you require for each \s-1URL.\s0
.SH "CONSTRUCTOR AND STARTUP"
.IX Header "CONSTRUCTOR AND STARTUP"
.SS "\fBnew()\fP"
.IX Subsection "new()"
Creates and returns a new \f(CW\*(C`WWW::RoboCop\*(C'\fR object.
.PP
Below are the arguments which you may pass to \f(CW\*(C`new\*(C'\fR when creating an object.
.PP
\fIis_url_allowed\fR
.IX Subsection "is_url_allowed"
.PP
This argument is required.  You must provide an anonymous subroutine which will
return true or false based on some arbitrary criteria which you provide.  The
two arguments to this anonymous subroutine will be a WWW::Mechanize::Link
object as well as the referring \s-1URL,\s0 in the form of a \s-1URI\s0 object.
.PP
Your sub might look something like this:
.PP
.Vb 1
\&    use feature qw( state );
\&
\&    use URI;
\&    use WWW::RoboCop;
\&
\&    my $robocop = WWW::RoboCop\->new(
\&        is_url_allowed => sub {
\&            my $link          = shift;
\&            my $referring_url = shift;
\&
\&            my $upper_limit = 100;
\&            my $host = \*(Aqsome.host.com\*(Aq;
\&
\&            state $limit = 0;
\&
\&            return 0 if $limit > $upper_limit;
\&            my $uri = URI\->new( $link\->url_abs );
\&
\&            # if the referring_url matches the host then this is a 1st degree
\&            # outbound web link
\&
\&            if ( $uri\->host eq $host || $referring_url\->host eq $host ) {
\&                ++$limit;
\&                return 1;
\&            }
\&            return 0;
\&        }
\&    );
.Ve
.PP
\fIreport_for_url\fR
.IX Subsection "report_for_url"
.PP
This argument is not required, but is highly recommended. The arguments to this
anonymous subroutine will be an HTTP::Response object as well as the
referring \s-1URL\s0 in the form of a \s-1URI\s0 object.  Your sub might look something
like this:
.PP
.Vb 12
\&    my $reporter = sub {
\&        my $response      = shift;    # HTTP::Response object
\&        my $referring_url = shift;    # URI object
\&        return {
\&            redirects => [
\&                map { +{ status => $_\->code, uri => $_\->base\->as_string } }
\&                    $res\->redirects
\&            ],
\&            referrer => $referring_url,
\&            status   => $res\->code,
\&        };
\&    };
\&
\&    my $robocop = WWW::RoboCop\->new(
\&        is_url_allowed => sub { ... },
\&        report_for_url     => $reporter,
\&    );
.Ve
.PP
That would give you a HashRef with the status code for each link visited (200,
404, 500, etc) as well as the referring \s-1URL\s0 (the page on which the link was
found) and a list of any redirects which were followed in order to get to this
\&\s-1URL.\s0
.PP
The default \f(CW\*(C`report_for_url\*(C'\fR sub will already provide something like the
above, but you should only treat this as a stub method while you get up and
running.  Since it's only meant to be an example, the format of the default
report could change at some future date without notice.  You should not rely on
or expect it to remain consistent in future.  If you are going to rely on this
module, you should provide your own reporting logic.
.PP
\fIua( WWW::Mechanize )\fR
.IX Subsection "ua( WWW::Mechanize )"
.PP
You can provide your own UserAgent object to this class.  It should be of the
WWW::Mechanize family.  If you're looking for a significant speed boost
while under development, consider providing a WWW::Mechanize::Cached object.
This can give you enough of a speedup to save you from getting distracted
and going off to read Hacker News while you wait.
.PP
.Vb 3
\&    use CHI;
\&    use WWW::Mechanize::Cached;
\&    use WWW::RoboCop;
\&
\&    my $cache = CHI\->new(
\&        driver => \*(AqFile\*(Aq,
\&        root_dir => /tmp/cache\-example\*(Aq,
\&    );
\&
\&    my $robocop = WWW::RoboCop\->new(
\&        is_url_allowed => sub { ... },
\&        ua => WWW::Mechanize::Cached\->new( cache => $cache ),
\&    );
.Ve
.PP
If you're not using a Cached agent, be sure to disable autocheck.
.PP
.Vb 4
\&    my $robocop = WWW::RoboCop\->new(
\&        is_url_allowed => sub { ... },
\&        ua => WWW::Mechanize\->new( autocheck => 0 ),
\&    );
.Ve
.ie n .SS "crawl( $url )"
.el .SS "crawl( \f(CW$url\fP )"
.IX Subsection "crawl( $url )"
This method sets the \f(CW\*(C`WWW::RoboCop\*(C'\fR in motion.  The robot will only come to a
halt once has exhausted all of the allowed URLs it can find.
.SS "get_report"
.IX Subsection "get_report"
This method returns a Hash of crawling results, keyed on the URLs visited.
By default, it returns a very simple Hash, containing only the status code
of the visited \s-1URL.\s0  You are encouraged to provide your own callback so that
you can get a detailed report returned to you.  You can do this by providing a
\&\f(CW\*(C`report_for_url\*(C'\fR callback when instantiating the object.
.PP
The default report looks something like this:
.PP
.Vb 4
\&    # %history = (
\&    #    \*(Aqhttp://myhost.com/one\*(Aq => { status => 200, ... },
\&    #    \*(Aqhttp://myhost.com/two\*(Aq => { status => 404, ... },
\&    # )
.Ve
.PP
See examples/crawl\-host.pl, which is included with this distribution, to get a
dump of the default report.
.SH "AUTHOR"
.IX Header "AUTHOR"
Olaf Alders <olaf@wundercounter.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2015 by MaxMind, Inc.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
