.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Semantics 3"
.TH Marpa::R2::Semantics 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Semantics \- How the SLIF evaluates parses
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&    use Marpa::R2;
\&
\&    my $grammar = Marpa::R2::Scanless::G\->new(
\&        {   bless_package => \*(AqMy_Nodes\*(Aq,
\&            source        => \e(<<\*(AqEND_OF_SOURCE\*(Aq),
\&    :default ::= action => [values] bless => ::lhs
\&    lexeme default = action => [ start, length, value ]
\&        bless => ::name latm => 1
\&
\&    :start ::= Script
\&    Script ::= Expression+ separator => comma
\&    comma ~ [,]
\&    Expression ::=
\&        Number bless => primary
\&        | \*(Aq(\*(Aq Expression \*(Aq)\*(Aq bless => paren assoc => group
\&       || Expression \*(Aq**\*(Aq Expression bless => exponentiate assoc => right
\&       || Expression \*(Aq*\*(Aq Expression bless => multiply
\&        | Expression \*(Aq/\*(Aq Expression bless => divide
\&       || Expression \*(Aq+\*(Aq Expression bless => add
\&        | Expression \*(Aq\-\*(Aq Expression bless => subtract
\&
\&    Number ~ [\ed]+
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    # allow comments
\&    :discard ~ <hash comment>
\&    <hash comment> ~ <terminated hash comment> | <unterminated
\&       final hash comment>
\&    <terminated hash comment> ~ \*(Aq#\*(Aq <hash comment body> <vertical space char>
\&    <unterminated final hash comment> ~ \*(Aq#\*(Aq <hash comment body>
\&    <hash comment body> ~ <hash comment char>*
\&    <vertical space char> ~ [\ex{A}\ex{B}\ex{C}\ex{D}\ex{2028}\ex{2029}]
\&    <hash comment char> ~ [^\ex{A}\ex{B}\ex{C}\ex{D}\ex{2028}\ex{2029}]
\&    END_OF_SOURCE
\&        }
\&    );
\&
\&
\&    my $recce = Marpa::R2::Scanless::R\->new( { grammar => $grammar } );
\&
\&    my $input = \*(Aq42*2+7/3, 42*(2+7)/3, 2**7\-3, 2**(7\-3)\*(Aq;
\&    $recce\->read(\e$input);
\&    my $value_ref = $recce\->value();
\&    die "No parse was found\en" if not defined $value_ref;
\&
\&    # Result will be something like "86.33... 126 125 16"
\&    # depending on the floating point precision
\&    my $result = ${$value_ref}\->doit();
\&
\&    package My_Nodes;
\&
\&    sub My_Nodes::primary::doit { return $_[0]\->[0]\->doit() }
\&    sub My_Nodes::Number::doit  { return $_[0]\->[2] }
\&    sub My_Nodes::paren::doit   { my ($self) = @_; $self\->[1]\->doit() }
\&
\&    sub My_Nodes::add::doit {
\&        my ($self) = @_;
\&        $self\->[0]\->doit() + $self\->[2]\->doit();
\&    }
\&
\&    sub My_Nodes::subtract::doit {
\&        my ($self) = @_;
\&        $self\->[0]\->doit() \- $self\->[2]\->doit();
\&    }
\&
\&    sub My_Nodes::multiply::doit {
\&        my ($self) = @_;
\&        $self\->[0]\->doit() * $self\->[2]\->doit();
\&    }
\&
\&    sub My_Nodes::divide::doit {
\&        my ($self) = @_;
\&        $self\->[0]\->doit() / $self\->[2]\->doit();
\&    }
\&
\&    sub My_Nodes::exponentiate::doit {
\&        my ($self) = @_;
\&        $self\->[0]\->doit()**$self\->[2]\->doit();
\&    }
\&
\&    sub My_Nodes::Script::doit {
\&        my ($self) = @_;
\&        return join q{ }, map { $_\->doit() } @{$self};
\&    }
.Ve
.SH "About this document"
.IX Header "About this document"
This document describes the semantics for
Marpa's primary interface, the \s-1SLIF.\s0
.SH "What is semantics?"
.IX Header "What is semantics?"
A parser is an algorithm
that takes a string of symbols (tokens or characters) and finds a structure
in it.
Traditionally, that structure is a tree.
.PP
Rarely is an application interested only in the tree.
Usually the idea is that the string \*(L"means\*(R" something:
the idea is that the string has a \fBsemantics\fR.
Traditionally and most often, the tree
is an intermediate step in producing a value,
a value which represents the \*(L"meaning\*(R" or \*(L"semantics\*(R" of the string.
.PP
\&\*(L"Evaluating\*(R" a tree means finding its semantics.
The rest of this document describes Marpa's methods for evaluating trees.
Those of you who have dealt with other traditional parsers, such as yacc and bison,
will find Marpa's approach familiar.
.SH "Instances"
.IX Header "Instances"
At the start of evaluation, semantics is associated with instances
of rule alternatives or of lexemes.
An \fBinstance\fR is an occurrence in terms of G1 locations.
Every instance has two locations: a start location and
an end location.
.PP
A rule alternative is the \s-1LHS\s0 of a rule, together with one of its
\&\s-1RHS\s0 alternatives.
Unless a rule is a prioritized rule, it has exactly one rule alternative.
.PP
Prioritized rules very often only have one rule alternative,
in which case they are called trivial prioritized rules.
But prioritized rules may have many rule alternatives.
.PP
When a rule has only one rule alternative,
or when context makes it clear what is meant,
a rule alternative is often simply called a rule.
In particular, a \fBrule alternative instance\fR is almost always
called simply a \fBrule instance\fR.
.SH "Nodes"
.IX Header "Nodes"
In a parse tree, nodes are points where the tree branches or terminates.
Tree terminations are also called terminals or \*(L"leaves\*(R".
.PP
Every rule instance in a Marpa parse is represented by a branch point (or \*(L"node\*(R")
in the tree.
The topmost node of a tree is its \*(L"root node\*(R".
(Trees are easiest to draw upside down, so traditionally in programming,
the top of a tree is its root.)
.PP
A node, or branch point, \*(L"branches\*(R" into zero or more \*(L"child nodes\*(R".
The node just above a child node,
the one from which the child node branches out,
is called its parent node.
.PP
If the node is for a non-quantified rule instance,
the parent node is the \s-1LHS\s0 of the rule,
and the child nodes are the \s-1RHS\s0 of the rule alternative.
If the node is for a quantified rule,
the parent node is the \s-1LHS\s0 of the quantified rule,
and the child nodes are the items of the sequence of symbols on the
right hand side.
If the node is for a lexeme,
the node represents the lexeme's symbol
and there will be no child nodes.
.PP
A parent node can have zero or more children.
Rule instances with zero children are nulled rule instances,
and are \*(L"leaf nodes\*(R".
Leaf nodes are also called \fBterminals\fR.
In Marpa's parse trees, every terminal is either
a lexeme or a nulled rule instance.
.PP
In Marpa,
evaluation only takes place within the structural (G1) subgrammar,
and the descriptions of the behaviors of rule and lexeme instances below
applies only to the G1 subgrammar.
L0 rule alternatives and terminal symbols do not become nodes
in the parse tree,
and are never evaluated.
.SH "The order of node evaluation"
.IX Header "The order of node evaluation"
The nodes of a Marpa parse tree are
evaluated recursively, left-to-right and bottom-up.
This means that,
when a parent node is evaluated,
the values of all child nodes are known
and available for use by the semantics.
The final value of a parse is the value of the top node
of the parse tree.
.SH "Parse trees"
.IX Header "Parse trees"
The calls of the
\&\f(CW\*(C`value()\*(C'\fR method
by a \s-1SLIF\s0 recognizer produce a series of zero
or more parses trees,
called a \fBparse series\fR.
A recognizer will have only one parse series,
unless it calls
the \f(CW\*(C`series_restart()\*(C'\fR method.
.PP
There may be zero parses in a parse series,
because there may be no valid parse of a virtual input.
There may be more than one parse in a parse series,
because Marpa allows ambiguous parsing.
Full details about the life cycle of a Marpa
recognizer,
including a full treatment of parse series
can be found in
another document.
.SH "Nulled subtrees"
.IX Header "Nulled subtrees"
A nulled subtree is a subtree of the parse tree formed by a nulled node and its direct and
indirect child nodes.
(All these child nodes will also be nulled nodes.)
Before evaluation,
Marpa prunes all nulled subtrees back to their topmost nulled
node.
Of all the ways of dealing with nulled subtrees, this is the
simplest and
Marpa's users have found it a natural approach.
More detail on the semantics of nulled symbols and subtrees
can be found in
a separate document.
.SH "Actions and how Marpa finds them"
.IX Header "Actions and how Marpa finds them"
The way in which the \s-1SLIF\s0 finds the value of a node is called that node's \fBaction\fR.
Actions can be explicit or implicit.
An explicit action is one that is explicitly specified by the application,
in one of the ways
to be described below.
A node's implicit action is the one it performs if it has no
explicit action.
.SS "Lexeme actions"
.IX Subsection "Lexeme actions"
The implicit action for a lexeme is to return
its literal value in the input stream, as a string.
An explicit default action name for lexemes may be set using the
the lexeme default statement.
A lexeme action cannot be a Perl closure action \*(--
it must be one of the built-in actions that are
appropriate for lexemes.
.SS "Rule actions"
.IX Subsection "Rule actions"
The implicit action for a rule instance is to return a Perl \f(CW\*(C`undef\*(C'\fR.
An explicit action for a \s-1RHS\s0 alternative can be specified using
the \f(CW\*(C`action\*(C'\fR adverb
for the its \s-1RHS\s0 alternative.
A default explicit action for \s-1RHS\s0 alternatives can be specified with a
default pseudo-rule.
.SS "Nulled symbol actions"
.IX Subsection "Nulled symbol actions"
As mentioned, nulled subtrees are pruned back to their topmost symbol.
Lexemes are never nulled, so a nulled symbol is always the \s-1LHS\s0 of a rule instance,
and the action is determined from the rule alternative,
as just described.
.PP
A complication arises if the symbol appears on the \s-1LHS\s0 of more than one
nullable rule alternative.  Because the symbol is nulled, the input is no help in determining
which rule alternative to use.  The rule alternative whose semantics are used for a nulled symbol
is determined as follows:
.IP "\(bu" 4
If all nullable rule alternatives have the same semantics, that semantics is used.
.IP "\(bu" 4
If one of the nullable rule alternatives
is empty (that is, has a zero-length \s-1RHS\s0),
then the empty alternative's semantics are used.
.IP "\(bu" 4
In the remaining case,
two or more of the rule alternatives have different action names,
but none of the alternatives has a zero-length \s-1RHS.\s0
When this happens, Marpa throws an exception.
One easy way
to fix the issue,
is to add an empty rule with the intended semantics.
.PP
In determining whether the semantics of two nullable rule alternatives
are \*(L"the same\*(R",
the blessing is taken into account.
Two rule alternatives are considered to have different semantics if
they are blessed differently.
The \s-1SLIF\s0's null semantics are described in more detail
in a separate document.
.SH "Blessings"
.IX Header "Blessings"
Part of a rule alternative's or lexeme's action may be a blessing.
A blessing is the name of a Perl package.
In the case of a rule evaluation closure,
the argument containing its child values will be blessed
into that package.
.PP
Not all actions are rule evaluation closures.
An action may be, for example, an array descriptor action.
In cases where the action is not a rule evaluation closure,
the value
of the action will be blessed into that package.
.PP
Only Perl objects pointed to by references can be blessed.
It is a fatal error to try to use a blessing with an inappropriate
action.
.PP
Implicitly
(that is, if no blessing was explicitly specified),
an action is not blessed.
The implicit action itself cannot be blessed \*(--
an attempt to do so is a fatal error.
.PP
Explicit blessings are made using 
the \f(CW\*(C`bless\*(C'\fR adverb.
The \f(CW\*(C`bless\*(C'\fR adverb is allowed
.IP "\(bu" 4
for \s-1RHS\s0 alternatives;
.IP "\(bu" 4
for lexemes;
.IP "\(bu" 4
for the default lexeme statement;
.IP "\(bu" 4
and for the default pseudo-rule.
.PP
An L0 \s-1RHS\s0 alternative cannot have a \f(CW\*(C`bless\*(C'\fR adverb.
.PP
The value of a \f(CW\*(C`bless\*(C'\fR adverb is called a \fBblessing\fR.
If the blessing is a Perl word
(a string of alphanumerics or underscores),
the name of the class will be formed by prepending
the value of the \f(CW\*(C`bless_package\*(C'\fR
named argument, followed
by a double colon ("\f(CW\*(C`::\*(C'\fR").
.PP
If the blessing begins with a double colon ("\f(CW\*(C`::\*(C'\fR"), it is a
reserved blessing.
The reserved blessings are as follows:
.ie n .IP """::undef""" 4
.el .IP "\f(CW::undef\fR" 4
.IX Item "::undef"
The \s-1RHS\s0 alternatives or lexemes will not be
blessed.
When this document
states that a \s-1RHS\s0 alternative or lexeme has a blessing
of \f(CW\*(C`::undef\*(C'\fR,
it means exactly the same thing as when it states
that a \s-1RHS\s0 alternative or lexeme will not be blessed.
For both \s-1RHS\s0 alternatives and lexemes,
the implicit blessing is \f(CW\*(C`::undef\*(C'\fR.
.ie n .IP """::lhs""" 4
.el .IP "\f(CW::lhs\fR" 4
.IX Item "::lhs"
The \s-1RHS\s0 alternative is blessed into
a class whose name is based on the \s-1LHS\s0 of the \s-1RHS\s0 alternative.
A blessing of \f(CW\*(C`::lhs\*(C'\fR is not allowed for a lexeme.
.Sp
The class will be the name of the \s-1LHS\s0 with whitespace
changed to an underscore.
(As a reminder, the whitespace in symbol names will have been normalized,
with leading and trailing whitespace removed,
and all other whitespace sequences changed to a single \s-1ASCII\s0 space.)
When a \f(CW\*(C`::lhs\*(C'\fR blessing value applies to a rule alternative, it is a fatal
error if the \s-1LHS\s0 contains anything other than alphanumerics
and whitespace.
In particular, the \s-1LHS\s0 cannot already contain an underscore ("\f(CW\*(C`_\*(C'\fR").
The \f(CW\*(C`::lhs\*(C'\fR blessing is most useful in a default pseudo-rule.
.ie n .IP """::name""" 4
.el .IP "\f(CW::name\fR" 4
.IX Item "::name"
The lexeme
is blessed into
a class whose name is based on the name of the lexeme.
The \f(CW\*(C`::name\*(C'\fR blessing is not allowed for a \s-1RHS\s0 alternative.
.Sp
The class is derived from the symbol name in the same way,
and subject to the same restrictions,
as described above for deriving a class name from the \s-1LHS\s0
of a rule alternative.
The \f(CW\*(C`::name\*(C'\fR reserved blessing is most useful in
the lexeme default statement.
.PP
If any rule alternative or lexeme of a \s-1SLIF\s0 grammar has
a blessing other than \f(CW\*(C`::undef\*(C'\fR,
a \f(CW\*(C`bless_package\*(C'\fR is required,
and failure to specify one results in
a fatal error.
.SH "Explicit actions"
.IX Header "Explicit actions"
There are four kinds of explicit action names:
.IP "\(bu" 4
Array descriptors
.IP "\(bu" 4
Reserved action names
.IP "\(bu" 4
Perl identifiers
.IP "\(bu" 4
Perl names
.PP
An explicit action is either a built-in action
or a Perl closure action.
Array descriptors and reserved action names
are \fBbuilt-in actions\fR.
The other actions are \fBPerl closure actions\fR.
.SH "Array descriptor actions"
.IX Header "Array descriptor actions"
.Vb 2
\&    lexeme default = action => [ start, length, value ]
\&        bless => ::name latm => 1
.Ve
.PP
If an action is enclosed in square brackets, it is an \fBarray descriptor\fR,
and the value of the lexeme or rule alternative will be an array.
Inside the array descriptor is a comma separated list of zero or more array item
descriptors.
The \fBarray item descriptors\fR are keywords that describe how the array is to be filled
out.
.PP
If the array descriptor is an empty pair of square brackets ("\f(CW\*(C`[]\*(C'\fR"),
then there are zero array item descriptors,
and the value will be an empty array.
Otherwise the array item descriptors are interpreted as lists
and those lists are used to fill out the 
array.
.ie n .IP """g1length""" 4
.el .IP "\f(CWg1length\fR" 4
.IX Item "g1length"
The \f(CW\*(C`g1length\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element will be the length of the rule or lexeme instance,
in G1 locations.
.ie n .IP """g1start""" 4
.el .IP "\f(CWg1start\fR" 4
.IX Item "g1start"
The \f(CW\*(C`g1start\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element will be
the G1 start location of the rule or lexeme instance.
Together
the \f(CW\*(C`g1length\*(C'\fR and \f(CW\*(C`g1start\*(C'\fR array item descriptors
describe a G1 location
span.
.Sp
Typical applications will prefer to use
the \f(CW\*(C`start\*(C'\fR and \f(CW\*(C`length\*(C'\fR array item descriptors,
which report their results in terms of
physical input stream locations,
instead of G1 locations.
G1 locations are useful in special cases,
for example with application which do not scan
monotonically forward in the physical input,
but instead jump backwards in it.
G1 locations are described in detail
in another document.
.ie n .IP """length""" 4
.el .IP "\f(CWlength\fR" 4
.IX Item "length"
The \f(CW\*(C`length\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element will be the length of the rule or lexeme instance.
Length is in characters.
.ie n .IP """lhs""" 4
.el .IP "\f(CWlhs\fR" 4
.IX Item "lhs"
The \f(CW\*(C`lhs\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element will be the \s-1LHS\s0 symbol \s-1ID\s0 of 
the rule.
Because of historical reasons,
for a lexeme instance,
it will the symbol \s-1ID,\s0
but for a nulling symbol it will be a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The \f(CW\*(C`name\*(C'\fR array item descriptor puts
a single-element list into the array.
This will always be a string.
For a rule whose name is defined,
that one element will be the rule name.
For an unnamed rule,
it will be the name of the \s-1LHS\s0 symbol.
For a lexeme,
it will be the symbol name of the lexeme.
For a nulling symbol
it will be the name of that symbol.
.ie n .IP """rule""" 4
.el .IP "\f(CWrule\fR" 4
.IX Item "rule"
The \f(CW\*(C`rule\*(C'\fR array item descriptor puts
a single-element list into the array.
For a rule,
that one element will be the rule \s-1ID.\s0
In other cases, that one element will be a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """start""" 4
.el .IP "\f(CWstart\fR" 4
.IX Item "start"
The \f(CW\*(C`start\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element will be
the start location of the rule or lexeme instance.
The start location is an offset in the input string.
The elements of the \f(CW\*(C`length\*(C'\fR and \f(CW\*(C`start\*(C'\fR item descriptors are defined
such that the end location
is always start location plus length.
.ie n .IP """symbol""" 4
.el .IP "\f(CWsymbol\fR" 4
.IX Item "symbol"
The \f(CW\*(C`symbol\*(C'\fR array item descriptor puts
a single-element list into the array.
This will always be the name of a symbol.
For a rule,
it will be the name of the \s-1LHS\s0 symbol.
For a lexeme,
it will be the symbol name of the lexeme.
For a nulling symbol
it will be the name of that symbol.
.ie n .IP """value""" 4
.el .IP "\f(CWvalue\fR" 4
.IX Item "value"
For a rule alternative,
the \f(CW\*(C`value\*(C'\fR array item descriptor puts
a list of zero or more elements into the array.
The list will contain
the values of
the rule instance's children, in left-to-right order.
.Sp
For a lexeme,
the \f(CW\*(C`value\*(C'\fR array item descriptor puts
a single-element list into the array.
That one element
will be a list
containing a single element,
the token value of the lexeme.
.ie n .IP """values""" 4
.el .IP "\f(CWvalues\fR" 4
.IX Item "values"
The \f(CW\*(C`value\*(C'\fR and \f(CW\*(C`values\*(C'\fR array item descriptors are synonyms,
and may be used interchangeably for both rule alternatives and lexemes.
.SS "Example"
.IX Subsection "Example"
The array item descriptors fill out the array in
the order in which they appear in the array descriptor.
For example, if we are dealing with a rule,
and the array descriptor is "\f(CW\*(C`[ start, length, value ]\*(C'\fR",
then the return value is an reference to an array,
whose length will vary, but which will contain at least
two elements.
The first element will be the start location in the
input string of this rule instance,
and the second will be its length.
The remaining elements will be
the values of the rule instance's \s-1RHS\s0 children,
in lexical order.
If the rule instance is nulled, the array will contain only two elements:
start location and length.
.SH "Reserved action names"
.IX Header "Reserved action names"
If the action value begins with a double colon ("\f(CW\*(C`::\*(C'\fR"),
it is a reserved action.
The following are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`::array\*(C'\fR
.Sp
\&\f(CW\*(C`::array\*(C'\fR is equivalent to \f(CW\*(C`[values]\*(C'\fR.
This means that, for both lexeme and rule instances,
the actions \f(CW\*(C`[values]\*(C'\fR, \f(CW\*(C`[value]\*(C'\fR and \f(CW\*(C`::array\*(C'\fR
will do exactly the same thing.
.IP "\(bu" 4
\&\f(CW\*(C`::first\*(C'\fR
.Sp
The value of the rule instance is that of the rule instance's first child.
If there is no such child, the value is a Perl \f(CW\*(C`undef\*(C'\fR.
It is a fatal error if a 
\&\s-1RHS\s0 alternative with a \f(CW\*(C`::first\*(C'\fR action
is blessed.
It is also a fatal error to use a \f(CW\*(C`::first\*(C'\fR action
with a lexeme.
.IP "\(bu" 4
\&\f(CW\*(C`::undef\*(C'\fR
.Sp
The value of the rule or lexeme instance will be
a Perl \f(CW\*(C`undef\*(C'\fR.
It is a fatal error if a 
\&\s-1RHS\s0 alternative with an \f(CW\*(C`::undef\*(C'\fR action
is blessed.
.SH "Perl identifiers as action names"
.IX Header "Perl identifiers as action names"
An action name is considered to be
a Perl identifier, if it is a sequence of one or more alphanumerics
and underscores.
If the action name is a Perl identifier,
it is treated as the name of a Perl variable.
To successfully resolve to actions,
Perl identifiers must be resolved to Perl names,
as described below.
.SH "Perl names as action names"
.IX Header "Perl names as action names"
For this purpose, a Perl name
is a series of two or more Perl identifiers
separated by double colons ("\f(CW\*(C`::\*(C'\fR").
Note that, by this definition, a Perl name cannot start with a double colon.
Action names starting with double colons
are always treated as reserved
action names.
.PP
Action names which are Perl names by this definition are
treated as if they were fully qualified Perl names.
Fully qualified Perl names are resolved to variables in Perl's namespace,
as described below.
.SH "The semantics package"
.IX Header "The semantics package"
To resolve Perl identifiers to Perl names,
a semantics package must be defined.
The semantics package can be defined using the
\&\s-1SLIF\s0 recognizer's \f(CW\*(C`semantics_package\*(C'\fR named
argument,
or it can be taken from the argument to the first \f(CW\*(C`value()\*(C'\fR
call of the parse series.
(All of a recognizer's \f(CW\*(C`value()\*(C'\fR method calls
refer to a single parse series unless
the recognizer calls
the
\&\f(CW\*(C`series_restart()\*(C'\fR method.)
The \f(CW\*(C`semantics_package\*(C'\fR named argument takes precedence.
.PP
If the arguments to the \f(CW\*(C`value()\*(C'\fR method are used to specify
the semantics package, within a parse series they must consistently
specify the same package.
For details, see the description of
\&\s-1SLIF\s0 recognizer's \f(CW\*(C`value()\*(C'\fR
method.
.PP
If the user wants the Perl variables implementing the semantics
in the \f(CW\*(C`main\*(C'\fR namespace,
she can specify
\&\f(CW"main"\fR
as the semantics package.
This is fine for small scripts and applications.
For a large project,
it is usually good practice to keep
Perl variables intended for use by Marpa's semantics
in their own namespace.
.SH "Resolving Perl identifiers to Perl names"
.IX Header "Resolving Perl identifiers to Perl names"
A Perl identifier is resolved to a Perl name by prepending
the semantic package, followed by a double colon ("\f(CW\*(C`::\*(C'\fR").
For a Perl identifier to resolve successfully
to a Perl name,
a semantics package must be defined.
.PP
For example, if the action name
is "\f(CW\*(C`some_var\*(C'\fR\*(L", the action name will be regarded as a Perl identifer.
If the semantics package is \*(R"\f(CW\*(C`My_Actions\*(C'\fR\*(L", Marpa will convert the action
name to \*(R"\f(CW\*(C`My_Actions::some_var\*(C'\fR", and hand
it on for processing as a fully qualified Perl name.
.SH "Resolving Perl names to Perl variables"
.IX Header "Resolving Perl names to Perl variables"
Once Marpa has a fully qualified Perl name, it looks in Perl's symbol tables for
a Perl variable with that name,
either the name of a subroutine, or of a scalar.
It is important to note that for the purposes of Perl's symbol tables,
and therefore for the purposes of Marpa's resolution of Perl names,
references are scalars.
.PP
If Marpa finds a Perl subroutine with that fully qualified Perl name,
the action name is resolved to that subroutine,
which then becomes a \fBrule evaluation closure\fR.
If Marpa does not find
a Perl subroutine with that name,
but does find a Perl scalar with that name,
the action name is resolved to that Perl scalar.
(Again, for this purpose a Perl reference is a kind of Perl scalar.)
.SH "Executing rule evaluation closures"
.IX Header "Executing rule evaluation closures"
A rule evaluation closure action is always called in scalar context,
and its return value will be used as the value of its node.
Arguments to the rule evaluation closure will be as follows:
.IP "\(bu" 4
If the rule instance is not nulled and
the rule alternative is not blessed,
the second and subsequent arguments are the values of its child nodes, in lexical order.
.IP "\(bu" 4
If the rule instance is nulled, there will be only one argument:
the per-parse argument.
.IP "\(bu" 4
If the rule alternative is blessed, and
the rule instance is not nulled,
the closure will always have exactly two arguments.
The first will be the per-parse argument,
and the second will be a blessed array that contains
the child values in lexical order.
(The grouping of child values into an array
is required in order to allow the blessing to take effect.)
.PP
Note that, in every case,
the first argument of a rule evaluation closure is the per-parse argument.
.SH "Quantified rule nodes"
.IX Header "Quantified rule nodes"
Everything just said about rule nodes
applies to nodes for
quantified
rules.
But there is a difference between quantified rules
and others, and it a big one if you are writing a rule
evaluation closure.
.PP
In other rules, the right hand side
is fixed in length,
and therefore the number of child nodes is known in advance.
This is not the case with a quantified rule.
The rule evaluation closure
for a quantified rule
must be capable of
dealing with
a variable number of child nodes.
.SH "Action context"
.IX Header "Action context"
.Vb 10
\&    sub do_S {
\&        my ($action_object) = @_;
\&        my $rule_id         = $Marpa::R2::Context::rule;
\&        my $slg             = $Marpa::R2::Context::slg;
\&        my ( $lhs, @rhs ) =
\&            map { $slg\->symbol_display_form($_) } $slg\->rule_expand($rule_id);
\&        $action_object\->{text} =
\&              "rule $rule_id: $lhs ::= "
\&            . ( join q{ }, @rhs ) . "\en"
\&            . "locations: "
\&            . ( join q{\-}, Marpa::R2::Context::location() ) . "\en";
\&        return $action_object;
\&    } ## end sub do_S
.Ve
.PP
In addition to the per-parse argument
and their child values,
rule evaluation closures also have access
to \fBcontext variables\fR.
.IP "\(bu" 4
\&\f(CW$Marpa::R2::Context::slg\fR is set to
the \s-1SLIF\s0 grammar being parsed.
.IP "\(bu" 4
\&\f(CW$Marpa::R2::Context::rule\fR is the \s-1ID\s0 of the
current rule alternative.
Given the rule alternative \s-1ID,\s0 an application can find
its \s-1LHS\s0 and \s-1RHS\s0 symbols using
the \s-1SLIF\s0 grammar's \f(CW\*(C`rule_expand()\*(C'\fR method.
.IP "\(bu" 4
\&\f(CW\*(C`Marpa::R2::Context::location()\*(C'\fR returns the start
and end G1 locations of the current rule instance.
Note that these are
G1 locations,
not input stream locations.
.SH "Bailing out of parse evaluation"
.IX Header "Bailing out of parse evaluation"
.Vb 1
\&    my $bail_message = "This is a bail out message!";
\&
\&    sub do_bail_with_message_if_A {
\&        my ($action_object, $terminal) = @_;
\&        Marpa::R2::Context::bail($bail_message) if $terminal eq \*(AqA\*(Aq;
\&    }
\&
\&    sub do_bail_with_object_if_A {
\&        my ($action_object, $terminal) = @_;
\&        Marpa::R2::Context::bail([$bail_message]) if $terminal eq \*(AqA\*(Aq;
\&    }
.Ve
.PP
The \f(CW\*(C`Marpa::R2::Context::bail()\*(C'\fR static method is used to
\&\*(L"bail out\*(R" of the evaluation of a parse tree.
It will cause an exception to be thrown.
If its first and only argument is a reference,
that reference is the exception object.
Otherwise, an exception message is created
by converting the method's arguments to strings,
concatenating them,
and prepending them with a message indicating
the file and line number at which the
\&\f(CW\*(C`Marpa::R2::Context::bail()\*(C'\fR method was called.
.SH "Perl scalars as actions"
.IX Header "Perl scalars as actions"
If a Perl scalar is the action,
it becomes the value of the node, as is.
References are scalars in this context so that,
for example, the value of the node could be a reference to an array.
.PP
Another possibility is that the Perl scalar action is a reference to code.
What happens in this case is very different from the case where the action
is a rule evaluation closure.
A rule evaluation closure is executed to produce the value of the node.
In contrast, the reference to a subroutine is \fB\s-1NOT\s0\fR executed \*(-- it becomes the
value of the node directly.
.PP
Assuming no trickery, such as use of Perl's \f(CW\*(C`local\*(C'\fR keyword, takes place,
resolution to a Perl scalar will always resolve to a single, global scalar.
Any modification of this scalar will be seen
by other nodes of the current parse,
and by other parses.
All this suggests that,
as a matter of good practice,
Perl scalar actions should only be used as constants.
.PP
For example,
assume that actions are in a package named \f(CW\*(C`My_Actions\*(C'\fR,
which contains a hash reference named \f(CW\*(C`empty_hash\*(C'\fR,
.PP
.Vb 2
\&        package My_Actions;
\&        our $empty_hash = {};
.Ve
.PP
It can be tempting, in building objects which are hashes,
to start with a left node whose action is \f(CW\*(C`empty_hash\*(C'\fR
and to add contents to it as the object is passed up the evaluation
tree.
But \f(CW$empty_hash\fR points to a single hash object.
This single hash object will shared by all nodes,
with all nodes seeing each other's changes.
Worse, all Marpa parsers which use the same \f(CW\*(C`My_Actions\*(C'\fR
namespace will share the same hash object.
The correct way to define an
\&\f(CW\*(C`empty_hash\*(C'\fR action that
initializes an empty hash is as a rule
evaluation closure 
that returns \f(CW\*(C`{}\*(C'\fR.
.PP
.Vb 1
\&        sub My_Actions::empty_hash { return {}; }
.Ve
.SH "Visibility of Perl object actions"
.IX Header "Visibility of Perl object actions"
Most applications do not manipulate the Perl symbol table at runtime,
and do not make use of Perl's \f(CW\*(C`local\*(C'\fR keyword for declarations.
Applications which use the Perl global namespace in conventional ways,
and which use the same names to point to the same variables
throughout Marpa execution,
can ignore questions about the visibility
of the Perl variables used in actions.
.PP
Less conventional applications should be aware that,
for resolution from a Perl name to a Perl variable to take place,
that Perl name must
refer to the intended variable,
and this variable must be visible,
at the time when actions are resolved.
The timing of action resolution
is specified in
a separate document.
.SH "The per-parse argument"
.IX Header "The per-parse argument"
The first argument of every rule evaluation closure is
the \fBper-parse\fR argument.
This is initialized
.IP "\(bu" 4
To the argument to the \s-1SLIF\s0 recognizer's \f(CW\*(C`value()\*(C'\fR method, if that
argument is defined.
.IP "\(bu" 4
Otherwise, to the result returned by the per-parse constructor,
if there is a per-parse constructor.
.IP "\(bu" 4
Otherwise, as a last resort, to an empty hashref.
.PP
The per-parse argument is destroyed once the evaluation of the parse tree is finished.
Between creation and destruction, the per-parse argument is not touched by Marpa's internals \*(--
it is reserved for use by the application.
.PP
The primary way of passing data while evaluating a parse tree is purely functional \*(--
results from child nodes are passed up to parent nodes.
Applications can use
the per-parse argument for data which does not conveniently fit the functional model.
Symbol tables are
one common example of data that is best handled outside the functional model.
.SH "The per-parse constructor"
.IX Header "The per-parse constructor"
The per-parse constructor
is the \f(CW\*(C`new()\*(C'\fR method of the semantics package.
If there is no semantics package, or if it has no \f(CW\*(C`new()\*(C'\fR method,
there is no per-parse constructor.
The per-parse constructor is called with one argument:
the name of the semantics package.
.PP
The per-parse constructor is called
in the
Parse Tree Setup Subphase.
The Parse Tree Setup Subphase occurs during
the first call to a recognizer's \f(CW\*(C`value()\*(C'\fR
method in a parse series.
(All of a recognizer's \f(CW\*(C`value()\*(C'\fR method calls
refer to a single parse series unless
the recognizer calls
the
\&\f(CW\*(C`series_restart()\*(C'\fR method.)
More details about
Parse Tree Setup Subphase
can be found in
the document that describes the processing phases of Marpa's
semantics.
.SH "Parse order"
.IX Header "Parse order"
If a parse is ambiguous, all parses are returned,
with no duplication.
By default, the order is arbitrary, but
it is also possible to control the order.
Details are in the document
on parse order.
.SH "Infinite loops"
.IX Header "Infinite loops"
Grammars with infinite loops (cycles)
are generally regarded as useless in practical applications.
Due to lack of interest,
the \s-1SLIF\s0 does not currently support them,
although Libmarpa itself, Marpa's thin interface and the \s-1NAIF\s0 all do.
Those interested in knowing more can look at the
document on the \s-1NAIF\s0's support of infinitely ambiguous
grammars.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
