.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Event 3"
.TH Marpa::R2::Event 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Event \- SLIF parse events
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 3
\&    my $input = q{a b c "insert d here" e e f h};
\&    my $length = length $input;
\&    my $pos    = $slr\->read( \e$input );
\&
\&    my $actual_events = q{};
\&
\&    READ: while (1) {
\&
\&        my @actual_events = ();
\&
\&        my $next_lexeme;
\&        EVENT:
\&        for my $event ( @{ $slr\->events() } ) {
\&            my ($name) = @{$event};
.Ve
.PP
.Vb 2
\&            push @actual_events, $name;
\&        }
\&
\&        if (@actual_events) {
\&            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
\&            $actual_events .= "\en";
\&        }
.Ve
.PP
.Vb 6
\&        if ($pos < $length) {
\&            $pos = $slr\->resume();
\&            next READ;
\&        }
\&        last READ;
\&    } ## end READ: while (1)
.Ve
.PP
The synopsis is extracted from an example given in full
below.
.SH "About this document"
.IX Header "About this document"
This document is an overview of \fB\s-1SLIF\s0 parse events\fR.
\&\s-1SLIF\s0 parse events
\&\fBtrigger\fR based on conditions declared in the \s-1DSL.\s0
Typical events are the prediction or recognition
of a symbol.
.PP
\&\s-1SLIF\s0 parse events are often used to allow an application to
switch over to its own custom procedural logic.
Among other things,
an application can do its own \*(L"external\*(R" scanning of lexemes.
An application may ask Marpa to resume internal scanning at
any point.
.PP
\&\s-1SLIF\s0 parse events may be named or unnamed.
Use of unnamed events is discouraged, and should be reserved for legacy
code.
New applications should only use named events.
When not otherwise specified,
this document is talking about named events.
Unnamed events are described
below,
in a section dedicated to them.
.SH "Terminology"
.IX Header "Terminology"
\&\s-1SLIF\s0 parse events are called \fBparse events\fR
or simply \fBevents\fR,
in contexts where the meaning is clear.
.PP
\&\s-1SLIF\s0 parse events evolved over time from simpler
mechanisms,
and the term \s-1SLIF\s0 parse event was introduced late
in the development of Marpa::R2.
In previous versions of Marpa::R2,
\&\s-1SLIF\s0 parse events and their precursors are called \*(L"pauses\*(R" or simply \*(L"events\*(R".
For historical reasons,
some of the method names dealing with \s-1SLIF\s0 parse events
still have the word \*(L"pause\*(R" as part of their name.
.PP
In this document, an \fBinstance\fR of a symbol
in a parse
means an occurrence
of the symbol in that parse
with a specific start location and length.
An instance of a symbol is also called
a \fBsymbol instance\fR.
A consequence of this definition
is that every symbol instance
has exactly one end location.
.PP
For some string and grammar,
we say that a parse is \fBvalid\fR
if the parse of the string
is valid according to the grammar.
In a parse,
a nulled symbol instance,
or \fBnulled symbol\fR, is a symbol instance with a length of zero.
A non-nulled symbol instance, non-nulled instance,
or \fBnon-nulled symbol\fR, is a symbol instance which is not
nulled.
A symbol in a grammar is 
a \fBnullable symbol\fR if it has
at least one nulled instance
in at least one valid parse of at least one string.
A symbol in a grammar is 
a \fBnulling symbol\fR if,
for all strings,
all of its instances in valid parses are nulled instances.
A symbol is \fBnon-nulling\fR if it is not nulling.
.PP
Intuitively, a string is actual to \fIL\fR if we
know the actual input as far as \fIL\fR,
and the string is consistent with the input.
More formally,
let \f(CW\*(C`A\*(C'\fR be the actual input to a parse.
Let \f(CW\*(C`S\*(C'\fR be an arbitrary string in the same alphabet.
Let \f(CW\*(C`prefix(A, L)\*(C'\fR be the prefix of length \fIL\fR
that is of length \f(CW\*(C`L\*(C'\fR,
and let \f(CW\*(C`prefix(S, L)\*(C'\fR be defined in the same way.
If \f(CW\*(C`prefix(A, L) = prefix(S, L)\*(C'\fR,
then we say that
string \f(CW\*(C`S\*(C'\fR is \fBconsistent with
the actual input up to location L\fR.
For brevity,
we will often say
that \f(CW\*(C`S\*(C'\fR is \fBactual to L\fR.
.PP
If an instance of symbol \fIS\fR
that starts at location \fIL\fR is in a valid parse
of some string actual to \fIL\fR,
we say that a symbol \fIS\fR is \fBacceptable\fR at
a location \fIL\fR.
We say that a symbol
is \fBacceptable\fR at
a location \fIL\fR if it is the symbol of
a symbol instance acceptable at location \fIL\fR.
.PP
If an instance of symbol \fIS\fR
that ends at location \fIL\fR is in a valid parse
of some string actual to \fIL\fR,
we say that a symbol \fIS\fR is \fBrecognized\fR at
a location \fIL\fR.
We say that a symbol
is \fBrecognized\fR at
a location \fIL\fR if it is the symbol of
a symbol instance recognized at location \fIL\fR.
.SH "The life cycle of events"
.IX Header "The life cycle of events"
.IP "\(bu" 4
An \s-1SLIF\s0 parse event must be \fBdeclared\fR.
.IP "\(bu" 4
A declared event may \fBtrigger\fR.
.IP "\(bu" 4
Once an event triggers, it may be \fBaccessed\fR.
.PP
Parse events are declared in the \s-1SLIF DSL.
A\s0 parse event is either a lexeme event
or a non-lexeme event.
A lexeme event is declared using a
\&\f(CW\*(C`:lexeme\*(C'\fR pseudo-rule.
A non-lexeme event is declared using a
named event statement.
The various types of parse events are described in detail
below.
The description of
each type of parse event
will state whether it is a lexeme or a non-lexeme event.
.PP
Once declared, a parse event
may trigger during any event-triggering \s-1SLIF\s0
recognizer method.
The event-triggering \s-1SLIF\s0 recognizer methods are
\&\f(CW\*(C`read()\*(C'\fR,
\&\f(CW\*(C`resume()\*(C'\fR,
\&\f(CW\*(C`lexeme_read()\*(C'\fR and
\&\f(CW\*(C`lexeme_complete()\*(C'\fR.
.PP
The location at which a parse event triggers is the \fBevent location\fR.
An event may trigger at any location, including location 0.
When an event triggers, it causes the event-triggering
method to return immediately, with the current location
at the \fBtrigger location\fR.
The trigger location is the same as the event location,
except in the case of
pre-lexeme events.
.PP
A non-lexeme event may trigger during any of the event-triggering
methods.
A lexeme event will only trigger during calls of the
\&\f(CW\*(C`$slr\->read()\*(C'\fR and \f(CW\*(C`$slr\->resume()\*(C'\fR methods.
.PP
The triggering of events may be controlled with
the \fBactivate()\fR method.
An event will only trigger if activated.
All events are automatically activated when declared.
.PP
Events may be accessed using
the Scanless recognizer's \fBevents()\fR
method.
The beginning and end of the lexeme triggering a lexeme event
may be found using
the Scanless recognizer's \fBpause_span()\fR
method.
.SH "Types of parse event"
.IX Header "Types of parse event"
.SS "Completion events"
.IX Subsection "Completion events"
Completion events are declared in the \s-1SLIF DSL\s0
using the
named event statement:
.PP
.Vb 4
\&    event \*(Aqa\*(Aq = completed A
\&    event \*(Aqb\*(Aq=off = completed B
\&    event \*(Aqc\*(Aq=on = completed C
\&    event \*(Aqd\*(Aq = completed D
.Ve
.PP
A completion \s-1SLIF\s0 parse event can be specified for any
symbol that is not a lexeme.
Completion events are non-lexeme events.
A completion event triggers
whenever a non-nulled instance of its symbol
is recognized at the current location.
.PP
When a completion event triggers,
its trigger location and its event location
are set to the current location,
which will be the end location
of the instance that triggered the event.
The event is called a \*(L"completion\*(R"
because, at the trigger location,
the recognition of its symbol
is \*(L"complete\*(R".
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
the name of completed event is the only element.
.SS "Discard events"
.IX Subsection "Discard events"
.Vb 5
\&    :discard ~ ws event => ws
\&    ws ~ [\es]+
\&    :discard ~ [,] event => comma=off
\&    :discard ~ [;] event => \*(Aqsemicolon\*(Aq=on
\&    :discard ~ [.] event => period
.Ve
.PP
Discard events are specified in
discard pseudo-rules.
They are non-lexeme events.
This may seem counter-intuitive,
but a lexeme must be a symbol visible to the G1
grammar and discarded symbols
are discarded
before the G1 grammar can see them.
.PP
When a discard event triggers, its trigger location and its event location are set to the current location.
This will be the end location of the discarded text.
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
there will be 4 elements:
.IP "\(bu" 4
The name of the discard event.
.IP "\(bu" 4
The start location of the discarded text,
as an offset in the physical input stream.
.IP "\(bu" 4
The end location of the discarded text,
as an offset in the physical input stream.
.IP "\(bu" 4
The G1 location of the last lexeme read.
.PP
An intended purpose of the G1 location is to allow
the synchronization of data taken from a series of discard events,
with data taken from a parse tree.
Physical input stream locations can often
be used for this purpose,
but an application is allowed to move around
in the physical input stream.
If an application does not move monotonically
through the physical input stream,
physical input stream locations will not
necessarily indicate the order from the point
of view of the parse tree,
and of the virtual input stream.
G1 locations are always in left-to-right order
from the point of view of parse tree,
and of the virtual input stream on which it is based.
.PP
Since discarded text is not seen by G1,
it does not really have a G1 location, so the G1 location
reported with the event
is that of the last lexeme read.
All lexemes have G1 locations.
If the discarded text is at the beginning of the parse,
before any lexemes have been read,
the G1 location is reported as zero.
.SS "Nulling events"
.IX Subsection "Nulling events"
A nulling event is declared in the \s-1SLIF DSL\s0
using the
named event statement:
.PP
.Vb 4
\&    event \*(Aq!a\*(Aq = nulled A
\&    event \*(Aq!b\*(Aq=off = nulled B
\&    event \*(Aq!c\*(Aq=on = nulled C
\&    event \*(Aq!d\*(Aq = nulled D
.Ve
.PP
A nulling \s-1SLIF\s0 parse event occurs whenever a nulled instance
of its symbol is recognized at the current location.
When a completion event triggers,
its trigger location and its event location
are set to the current location,
which will be
the location where the triggering instance both begins and ends.
.PP
A nulling event is a non-lexeme event.
A nulling \s-1SLIF\s0 parse event can be specifed for any
symbol that is not a lexeme.
A nulled symbol may derive other null symbols,
producing one or more nulled trees;
because a null derivation may be ambiguous,
a nulled symbol may derive more than one nulled
tree.
A set of one or more nulled trees
is called a nulled forest.
.PP
When a nulling event triggers for a symbol instance,
all activated nulling events declared
for symbols derived
from the triggered symbol instance will
also trigger.
The triggering of nulling events is recursive,
so that when a nulled symbol instance
triggers an event, it triggers all the events
in the nulled forest derived
from the triggering symbol instance.
Nulled forests are described in more detail
in a separate
section.
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
the name of nulling event is the only element.
.SS "Prediction events"
.IX Subsection "Prediction events"
A prediction event is declared in the \s-1SLIF DSL\s0
using the
named event statement:
.PP
.Vb 1
\&    event \*(Aq^a\*(Aq = predicted A
.Ve
.PP
A prediction event triggers whenever
a non-nulling symbol is acceptable at the current location.
When a prediction event triggers,
its trigger location and its event location
are set to the current location.
A prediction may not result in an actual instance of the symbol,
but no actual symbol instance can start
at the event location unless a prediction,
if properly declared and activated,
would trigger at that location.
.PP
Prediction \s-1SLIF\s0 parse events may be defined for any symbol,
whether it is a lexeme or not.
But prediction events are non-lexeme events,
even when their symbol is a lexeme.
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
the name of prediction event is the only element.
.SS "Post-lexeme events"
.IX Subsection "Post-lexeme events"
.Vb 1
\&    :lexeme ~ <a> pause => after event => \*(Aq"a"\*(Aq
.Ve
.PP
A post-lexeme event is a lexeme event.
It triggers if the lexeme is scanned at the current location.
The \s-1SLIF\s0 recognizer will have
already read the lexeme
when its post-lexeme event triggers.
.PP
When a post-lexeme event triggers,
its trigger location and its event location
are set to the current location,
which will also be the location where the lexeme ends.
A post-lexeme event also sets the
\&\f(CW\*(C`pause span\*(C'\fR and
\&\f(CW\*(C`pause lexeme\*(C'\fR.
Post-lexeme events which trigger during
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR calls are discarded.
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
the name of post-lexeme event is the only element.
.SS "Pre-lexeme events"
.IX Subsection "Pre-lexeme events"
.Vb 1
\&    :lexeme ~ <insert d> pause => before event => \*(Aqinsert d\*(Aq
.Ve
.PP
A pre-lexeme event is a lexeme event.
It triggers if the lexeme is scanned at the current location.
When a pre-lexeme event triggers,
its event location
is set to the current location.
Its trigger location is set to the location where the lexeme starts,
which will be before the event location.
A pre-lexeme event also sets the
\&\f(CW\*(C`pause span\*(C'\fR and
\&\f(CW\*(C`pause lexeme\*(C'\fR.
.PP
The \s-1SLIF\s0 recognizer will \fBnot\fR have
read the lexeme
when its pre-lexeme event triggers.
In effect, it \*(L"rewinds\*(R" the scanning.
.PP
For most events, the trigger location is the current location,
but pre-lexeme events are the exception.
Its setting of the trigger location to the start of the lexeme
is consistent with the pre-lexeme event's behavior as a \*(L"rewind\*(R".
An intended use of pre-lexeme events
is catching a lexeme which
is about to be read, and giving it special treatment.
For more on this, see
below.
Pre-lexeme events which trigger during
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR calls are discarded.
.PP
There is a lot of similarity
between pre-lexeme events and predictions,
but there are also very important differences.
.IP "\(bu" 4
A pre-lexeme event does not occur
unless triggering lexeme is actually
found in the input.
On the other hand,
a prediction event is,
as the name suggests, only a prediction \*(--
the triggering lexeme may never
actually be found in the input.
.IP "\(bu" 4
Even though they have the same
trigger location,
pre-lexeme and prediction events
do not occur at the same time,
because pre-lexeme events
require a scan of the lexeme,
while prediction events do not.
If both
are defined for a symbol,
the prediction event will trigger first,
\&\fBbefore\fR the lexeme is scanned.
The pre-lexeme event will trigger next,
\&\fBafter\fR the lexeme is scanned.
.IP "\(bu" 4
Pre-lexeme events can be defined only
for lexemes.
Prediction events can be defined for any
symbol.
.IP "\(bu" 4
Prediction events will occur together
with the other events expected at the trigger location.
Pre-lexeme events will not,
because they do not happen at the trigger location \*(--
the trigger location is moved back to the
start of the lexeme as a convenience.
.PP
In the \s-1SLIF\s0 parse event descriptor returned
by the 
the \f(CW\*(C`$slr\->events()\*(C'\fR
method,
the name of pre-lexeme event is the only element.
.SS "Exhaustion events"
.IX Subsection "Exhaustion events"
.Vb 8
\&        my @shortest_span = ();
\&        my $recce         = Marpa::R2::Scanless::R\->new(
\&            {   grammar    => $g,
\&                exhaustion => \*(Aqevent\*(Aq,
\&            },
\&            $recce_debug_args
\&        );
\&        my $pos = $recce\->read( \e$string, $target_start );
\&
\&        EVENT:
\&        for my $event ( @{ $recce\->events() } ) {
\&            my ($name) = @{$event};
\&            if ( $name eq \*(Aqtarget\*(Aq ) {
\&                @shortest_span = $recce\->last_completed_span(\*(Aqtarget\*(Aq);
\&                diag(
\&                    "Preliminary target at $pos: ",
\&                    $recce\->literal(@shortest_span)
\&                ) if $verbose;
\&                next EVENT;
\&            } ## end if ( $name eq \*(Aqtarget\*(Aq )
\&                # Not all exhaustion has an exhaustion event,
\&                # so we look for exhaustion explicitly below.
\&            next EVENT if $name eq q(\*(Aqexhausted);
\&            die join q{ }, "Spurious event at position $pos: \*(Aq$name\*(Aq";
\&        } ## end EVENT: for my $event ( @{ $recce\->events() } )
.Ve
.PP
An exhaustion parse event triggers on asynchronous parse exhaustion,
if the recognizer's \f(CW\*(C`exhaustion\*(C'\fR setting is "\f(CW\*(C`event\*(C'\fR\*(L".
The name of the event is
\&\*(R"\f(CW\*(C`\*(Aqexhausted\*(C'\fR"
(The initial single quote is part of the event's name,
and indicates it is a reserved name,
which will not conflict with
the name of any user-named event.)
.PP
Intuitively, parse exhaustion events are created only when
needed for control to return to the application.
More precisely,
a parse exhaustion event is called \fBsynchronous\fR if it
occurs at a G1 location where control would return to the application
in any case, either due to end of string or another event.
A parse exhaustion event is called \fBasynchronous\fR if it is not
synchronous.
.PP
The event itself is often simply discarded,
because an application typically
does not care whether
exhaustion is synchronous or asynchronous.
The \f(CW\*(C`exhausted()\*(C'\fR method
can be relied on to report
both asynchronous and synchronous parse exhaustion,
and it is usually used instead.
Exhaustion is discussed further in
a separate document.
.SS "Rejection events"
.IX Subsection "Rejection events"
.Vb 7
\&    my $recce = Marpa::R2::Scanless::R\->new(
\&        {   grammar   => $g,
\&            rejection => \*(Aqevent\*(Aq,
\&        },
\&        $recce_debug_args
\&    );
\&    my $pos = $recce\->read( \e$suffixed_string, 0, $original_length );
\&
\&    READ_LOOP: while (1) {
\&        my $rejection = 0;
\&        my $pos       = $recce\->pos();
\&        EVENT:
\&        for my $event ( @{ $recce\->events() } ) {
\&            my ($name) = @{$event};
\&            if ( $name eq q(\*(Aqrejected) ) {
\&                $rejection = 1;
\&                diag("You fool! you forget the semi\-colon at location $pos!")
\&                    if $verbose;
\&                next EVENT;
\&
\&            } ## end if ( $name eq q(\*(Aqrejected) )
\&            die join q{ }, "Spurious event at position $pos: \*(Aq$name\*(Aq";
\&        } ## end EVENT: for my $event ( @{ $recce\->events() } )
\&
\&        last READ_LOOP if not $rejection;
\&
\&        $recce\->resume( $original_length, 1 );
\&        diag("I fixed it for you.  Now you owe me.") if $verbose;
\&        $recce\->resume( $pos, $original_length \- $pos );
\&    } ## end READ_LOOP: while (1)
.Ve
.PP
A rejection event triggers if
all lexemes at a G1 location are rejected,
and the recognizer's \f(CW\*(C`rejection\*(C'\fR setting is "\f(CW\*(C`event\*(C'\fR\*(L".
The name of the event is
\&\*(R"\f(CW\*(C`\*(Aqrejected"\*(C'\fR
(The initial single quote is part of the event's name,
and indicates it is a reserved name,
which will not conflict with the name
of any user-named event.)
.SH "Lexeme events"
.IX Header "Lexeme events"
\&\s-1SLIF\s0 parse events are divided
into lexeme and non-lexeme events,
based on their type.
The lexeme events are the pre-lexeme event
and post-lexeme event.
.PP
A lexeme event will trigger at the current location
if all of the following criteria,
applied in order, are true:
.IP "\(bu" 4
It is declared in a
\&\f(CW\*(C`:lexeme\*(C'\fR pseudo-rule.
.IP "\(bu" 4
Its lexeme has been scanned by the L0 grammar at that location.
.IP "\(bu" 4
The G1 grammar would accept its lexeme at that location.
.IP "\(bu" 4
The lexeme is not scanned externally,
that is,
it is not scanned
by a call of the
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR method
or of the
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR method
method.
.IP "\(bu" 4
The event is activated.
An event is activated by default when it
is declared.
Deactivation and reactivation of events is
done with the \s-1SLIF\s0 recognizer's
\&\fBactivate()\fR method.
.IP "\(bu" 4
Its lexeme priority is higher than, or equal to,
that of any other lexeme
remaining after the previous criteria
have been applied.
.IP "\(bu" 4
If it is a post-lexeme event,
none of other remaining events are pre-lexeme events.
(In other words, a pre-lexeme event prevents
post-lexeme events from triggering at the same location.)
.PP
Marpa allows ambiguous lexemes and,
even after all the above criteria have been applied,
there may be more than one lexeme event at a G1 location.
.SS "Pause span and pause lexeme"
.IX Subsection "Pause span and pause lexeme"
When a lexeme event triggers, it will set
the \fBpause lexeme\fR to the lexeme symbol.
It will also set
the \fBpause span\fR to the start physical input stream location
and length of the triggering lexeme.
The pause span and pause lexeme are
originally undefined.
Every call
to the \f(CW\*(C`read()\*(C'\fR
or the \f(CW\*(C`resume()\*(C'\fR
methods resets the pause lexeme
and the pause span to undefined.
.PP
The pause span may be accessed directly
with the
\&\f(CW\*(C`$slr\->pause_span()\*(C'\fR
method.
Accessing the pause lexeme
directly
is discouraged,
because multiple lexeme events may occur at the
same G1 location,
but only one pause lexeme, arbitrarily chosen, is recorded.
This is not a problem with the pause span, because
all pause spans at a G1 location will be identical.
.SH "Non-lexeme events"
.IX Header "Non-lexeme events"
Prediction, completion and nulling events are non-lexeme events.
The conditions for a non-lexeme event are simpler than those for
a lexeme event, because they do not involve lexical processing.
.PP
A non-lexeme event will trigger at the current location
if all of the following are true:
.IP "\(bu" 4
It is declared in a
named event statement.
.IP "\(bu" 4
Its \fBtriggering condition\fR is true.  Specifically,
.RS 4
.IP "\(bu" 4
It is a prediction and its symbol is acceptable at the current location; or
.IP "\(bu" 4
it is a completion or a nulling event and its symbol is recognized
at the current location; or
.IP "\(bu" 4
it is an exhaustion event, and asynchronous parse exhaustion,
as defined above,
occurs at the current location; or
.IP "\(bu" 4
it is an rejection event, and all lexeme alternatives are rejected
at the current location.
.RE
.RS 4
.RE
.IP "\(bu" 4
The event is activated.
An event is activated by default when it
is declared.
Deactivation and reactivation of events is
done with the \s-1SLIF\s0 recognizer's
\&\fBactivate()\fR method.
.SH "Techniques"
.IX Header "Techniques"
.SS "External scanning"
.IX Subsection "External scanning"
Switching to external scanning is an intended use case
for all events, other than exhaustion events.
In particular,
the behavior of pre-lexeme events
is most intuitive when thought about with
external scanning in mind.
.PP
The example code for this document
contains an artificially simple example of external
scanning.
The symbol \f(CW\*(C`<insert d>\*(C'\fR has a pre-lexeme event
declared:
.PP
.Vb 1
\&    :lexeme ~ <insert d> pause => before event => \*(Aqinsert d\*(Aq
.Ve
.PP
When this triggers, the code in the example switches to
external scanning:
It reads a \f(CW\*(C`<d>\*(C'\fR symbol externally,
skips over the lexeme actually found
in the physical input,
and resumes internal scanning.
.SS "Markers"
.IX Subsection "Markers"
It is quite reasonable to create \*(L"markers\*(R" \*(--
nulling symbols
whose primary (or sole) purpose
is to have nulling events declared for them.
Markers are the only way to declare events that trigger in
the middle of a rule.
.SS "Rules"
.IX Subsection "Rules"
There are no events explicitly defined in terms of rules,
but every rule event that is wanted can be achieved in
one or more ways.
The most flexible of these, and the best for many purposes,
is to use markers.
.PP
Another method is to use the \s-1LHS\s0 of a rule to track rule
predictions and completions.
This requires that the \s-1LHS\s0 symbol of the rule be unique to that
rule.
.SH "Implications"
.IX Header "Implications"
This section describes 
some implications of the \s-1SLIF\s0 parse events mechanism
that may be unexpected at first.
These implications are Marpa working as designed and,
I hope the reader will agree,
as is desirable.
.SS "Ambiguity"
.IX Subsection "Ambiguity"
If a parse is ambiguous, events trigger for
\&\fBall\fR the possible symbols.
A user thinking in terms of one of the parses,
and unaware of the ambiguity, may find this unexpected.
In the example,
events for both the symbols \f(CW\*(C`<ambig1>\*(C'\fR
and \f(CW\*(C`<ambig2>\*(C'\fR, as well as all their
derived symbols, trigger.
.SS "Tentative events"
.IX Subsection "Tentative events"
Marpa's events are left-eidetic but right-blind.
Left of the event location, Marpa's events are 100% accurate.
Right of the event location, they are totally unaware of
what the actual input will be \*(--
there is no \*(L"lookahead\*(R".
Because events trigger based on input action
only up to the event location,
events are \fBtentative\fR.
.PP
Once the parse is complete,
and the actual input to the right of the event
location is taken into account,
it is quite possible that
none of the parse trees
will actually contain the symbol instance
that triggered an event.
.PP
In the example,
prediction and completion
events are reported for the symbols
\&\f(CW\*(C`<start1>\*(C'\fR,
\&\f(CW\*(C`<start2>\*(C'\fR,
\&\f(CW\*(C`<mid1>\*(C'\fR and
\&\f(CW\*(C`<mid2>\*(C'\fR,
but none of these symbols
winds up in
any of the parse tress.
This is because they are derived from
\&\f(CW\*(C`<ambig1>\*(C'\fR or
\&\f(CW\*(C`<ambig2>\*(C'\fR,
and \f(CW\*(C`<ambig1>\*(C'\fR or
\&\f(CW\*(C`<ambig2>\*(C'\fR will never be fully recognized
in any of the parse trees.
The reason that 
\&\f(CW\*(C`<ambig1>\*(C'\fR and
\&\f(CW\*(C`<ambig2>\*(C'\fR will not be fully recognized
is that their full recognition requires
that there be a 
\&\f(CW\*(C`<z>\*(C'\fR symbol in the input and the
input stream in the example does not contain a
\&\f(CW\*(C`<z>\*(C'\fR symbol.
.PP
Exhaustion events are not tentative.
All other \s-1SLIF\s0 parse events are tentative.
.PP
In the example, the predictions
for 
\&\f(CW\*(C`<mid1>\*(C'\fR and
\&\f(CW\*(C`<mid2>\*(C'\fR do not match anything in
the final parse tree,
because the locations where
\&\f(CW\*(C`<mid1>\*(C'\fR and
\&\f(CW\*(C`<mid2>\*(C'\fR would be predicted are not reached in
those trees.
For similar reasons, nulling events are tentative.
.PP
Lexemes can be ambiguous and
when they are ambiguous
one or more of the lexeme alternatives
may not be used in any final parse tree.
Because of this,
lexeme events are also tentative.
.PP
After rejection events,
input can be,
and typically is,
retried at the same G1 location.
This is what happens when the Ruby Slippers technique
is used.
Often, on the second or later attempt, one or
more lexemes are found that are acceptable
to the grammar.
For this reason,
rejection events are tentative.
.SS "Nulled forests"
.IX Subsection "Nulled forests"
When a symbol is nulled, any symbol which can be null-derived
from it
is also nulled.
In the example,
when the 
symbol \f(CW\*(C`<g>\*(C'\fR is nulled,
derived symbols
\&\f(CW\*(C`<g1>\*(C'\fR,
\&\f(CW\*(C`<g2>\*(C'\fR,
\&\f(CW\*(C`<g3>\*(C'\fR,
\&\f(CW\*(C`<g4>\*(C'\fR
are also nulled.
.PP
Note that what was said about
ambiguity
applies here.
In the example, the symbols
\&\f(CW\*(C`<g1>\*(C'\fR and
\&\f(CW\*(C`<g2>\*(C'\fR are in one derivation,
while \f(CW\*(C`<g3>\*(C'\fR and
\&\f(CW\*(C`<g4>\*(C'\fR are in another,
so that not just a parse tree,
but an entire parse forest
is nulled.
(Pedantically, a nulled tree is a forest
of a single tree.)
.PP
More precisely,
.IP "\(bu" 4
If the grammar allows
any derivation of the symbol
\&\fIY\fR from \fIX\fR in which \fIX\fR and \fIY\fR are both
nulled; and
.IP "\(bu" 4
a nulling \s-1SLIF\s0 parse event
is declared for \fIY\fR and activated; and
.IP "\(bu" 4
a nulled instance of \fIX\fR is encountered
in the parse at location \fIL\fR; then
.IP "\(bu" 4
a nulling \s-1SLIF\s0 parse event for \fIY\fR
will trigger at location \fIL\fR.
.SS "Events and instances"
.IX Subsection "Events and instances"
As stated above, only nulling instances generate nulling events,
and only non-nulled symbols generate prediction events
and completion events.
Since lexemes cannot be zero length, this means that,
for a given symbol instance,
nulling events and all other events,
are mutually exclusive.
In other words, if a nulling event occurs for an
instance, no other event will trigger for that instance.
.PP
Some cases may seem to violate this rule.
For example
at position 23
in the parse in
the code below,
we have four events
of four different types,
all for the symbol \f(CW\*(C`<e>\*(C'\fR.
In addition to
a nulling event, there is
a post-lexeme event,
a prediction event
and a completion event:
.PP
.Vb 1
\&    Events at position 23: "e" e$ e[] ^e ^f
.Ve
.PP
The reason for this is that these events are
for three different symbol instances, all of which
share the same trigger location:
.IP "1." 4
A nulled instance at location 23.
.IP "2." 4
A potential non-nulled instance, which may begin
at location 23.
.IP "3." 4
A non-nulled instance, which begins at location 22
and ends at location 23.
.PP
The prediction of the second instance is, in fact,
fulfilled, as reported at location 25:
.PP
.Vb 1
\&    Events at position 25: "e" e$ ^f
.Ve
.PP
The second instance is length 1 and predicted at location
23, but its completion is reported at location 25.
This is because whitespace delayed its start by one position.
.PP
.Vb 1
\&    Events at position 21: d$ mid1$ mid2$ e[] ^e ^f
.Ve
.PP
The third instance is reported as predicted at position 21,
even though it actually begins at position 22.
The delayed start is
because of whitespace.
.PP
Prediction and completion events exclude
nulled symbols,
because there is no practical distinction between predicting
a nulled symbol, and actually seeing one.
This means that the prediction and completion of a nulled symbol
would always occur together.
This very special nature of nulled symbols motivates their
treatment as a special case.
.SS "Hidden events"
.IX Subsection "Hidden events"
An important aspect of the event mechanism is that
it triggers a return from the event-triggering
method at the trigger location.
It may happen, however, that the method would return
at that location in any case,
and in this circumstance
the triggering
can be said to be \fBhidden\fR.
A event which causes hidden triggering is called
a \fBhidden event\fR.
.PP
As one example,
the
\&\f(CW\*(C`lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`lexeme_read()\*(C'\fR
methods return at every lexeme at which a lexeme is read, so
all triggering in those methods is hidden triggering.
In the example code in this
document,
the events at this location were all caused by hidden
triggering inside a call to \f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR:
.PP
.Vb 1
\&    Events at position 21: d$ mid1$ mid2$ e[] ^e ^f
.Ve
.PP
As another example,
the \f(CW\*(C`$slr\->read()\*(C'\fR and \f(CW\*(C`$slr\->resume()\*(C'\fR methods
return at end of string,
but events may also trigger at end of string.
The events at this location were caused by hidden
triggering inside \f(CW\*(C`$slr\->resume()\*(C'\fR
at end of string:
.PP
.Vb 1
\&    Events at position 29: "h" test$
.Ve
.PP
The example code for this document
is programmed with the possibility of hidden
triggering in mind.
To do this, it is careful to access events after its
calls to the
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR
as well as to make an additional pass through the event-accessing loop
after an end of string is encountered.
.SS "Lexeme events and external scanning"
.IX Subsection "Lexeme events and external scanning"
During external scanning, lexemes are read using the
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR methods.
Non-lexeme events may trigger during these methods, as was discussed
in \*(L"Hidden events\*(R".
However, lexeme events that would occur during the
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR methods are ignored,
and will never trigger.
.PP
This behavior may seem non-orthogonal,
but in fact it is the most consistent course of action.
A pre-lexeme event occuring during 
a \f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR and
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR method call would reverse its effect,
a behavior which is at best pointless.
A post-lexeme event would be less dangerous,
but it would be completely redundant \*(--
its presence or absence
would tell the application only what
the application already knows from the
return of success or failure by the
\&\f(CW\*(C`$slr\->lexeme_complete()\*(C'\fR or
\&\f(CW\*(C`$slr\->lexeme_read()\*(C'\fR methods.
.SH "An example"
.IX Header "An example"
The \s-1SLIF DSL\s0 in this example
is designed to
include the unusual and \*(L"corner\*(R"
cases described in this document.
It is not like any grammar that you are likely
to encounter in normal practice.
.PP
.Vb 1
\&    sub forty_two { return 42; };
\&
\&    use Marpa::R2;
\&
\&    my $dsl = <<\*(AqEND_OF_DSL\*(Aq;
\&    :default ::= action => [name,values]
\&    lexeme default = latm => 1
\&
\&    test ::= a b c d e e f g h action => main::forty_two
\&        | a ambig1 | a ambig2
\&    e ::= <real e> | <null e>
\&    <null e> ::=
\&    g ::= g1 | g3
\&    g1 ::= g2
\&    g2 ::= 
\&    g3 ::= g4
\&    g4 ::= 
\&    d ::= <real d> | <insert d>
\&    ambig1 ::= start1 mid1 z
\&    ambig2 ::= start2 mid2 z
\&    start1 ::= b  mid1 ::= c d
\&    start2 ::= b c  mid2 ::= d
\&
\&    a ~ \*(Aqa\*(Aq b ~ \*(Aqb\*(Aq c ~ \*(Aqc\*(Aq
\&    <real d> ~ \*(Aqd\*(Aq
\&    <insert d> ~ ["] \*(Aqinsert d here\*(Aq ["]
\&    <real e> ~ \*(Aqe\*(Aq
\&    f ~ \*(Aqf\*(Aq
\&    h ~ \*(Aqh\*(Aq
\&    z ~ \*(Aqz\*(Aq
\&
\&    :lexeme ~ <a> pause => after event => \*(Aq"a"\*(Aq
\&    :lexeme ~ <b> pause => after event => \*(Aq"b"\*(Aq
\&    :lexeme ~ <c> pause => after event => \*(Aq"c"\*(Aq
\&    :lexeme ~ <real d> pause => after event => \*(Aq"d"\*(Aq
\&    :lexeme ~ <insert d> pause => before event => \*(Aqinsert d\*(Aq
\&    :lexeme ~ <real e> pause => after event => \*(Aq"e"\*(Aq
\&    :lexeme ~ <f> pause => after event => \*(Aq"f"\*(Aq
\&    :lexeme ~ <h> pause => after event => \*(Aq"h"\*(Aq
\&
\&    event \*(Aq^test\*(Aq = predicted test
\&    event \*(Aqtest$\*(Aq = completed test
\&    event \*(Aq^start1\*(Aq = predicted start1
\&    event \*(Aqstart1$\*(Aq = completed start1
\&    event \*(Aq^start2\*(Aq = predicted start2
\&    event \*(Aqstart2$\*(Aq = completed start2
\&    event \*(Aq^mid1\*(Aq = predicted mid1
\&    event \*(Aqmid1$\*(Aq = completed mid1
\&    event \*(Aq^mid2\*(Aq = predicted mid2
\&    event \*(Aqmid2$\*(Aq = completed mid2
\&
\&    event \*(Aq^a\*(Aq = predicted a
\&    event \*(Aq^b\*(Aq = predicted b
\&    event \*(Aq^c\*(Aq = predicted c
\&    event \*(Aqd[]\*(Aq = nulled d
\&    event \*(Aqd$\*(Aq = completed d
\&    event \*(Aq^d\*(Aq = predicted d
\&    event \*(Aq^e\*(Aq = predicted e
\&    event \*(Aqe[]\*(Aq = nulled e
\&    event \*(Aqe$\*(Aq = completed e
\&    event \*(Aq^f\*(Aq = predicted f
\&    event \*(Aqg[]\*(Aq = nulled g
\&    event \*(Aq^g\*(Aq = predicted g
\&    event \*(Aqg$\*(Aq = completed g
\&    event \*(Aqg1[]\*(Aq = nulled g1
\&    event \*(Aqg2[]\*(Aq = nulled g2
\&    event \*(Aqg3[]\*(Aq = nulled g3
\&    event \*(Aqg4[]\*(Aq = nulled g4
\&    event \*(Aq^h\*(Aq = predicted h
\&
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    END_OF_DSL
\&
\&    my $grammar = Marpa::R2::Scanless::G\->new( { source => \e$dsl } );
\&    my $slr = Marpa::R2::Scanless::R\->new(
\&        { grammar => $grammar, semantics_package => \*(AqMy_Actions\*(Aq } );
\&
\&    my $input = q{a b c "insert d here" e e f h};
\&    my $length = length $input;
\&    my $pos    = $slr\->read( \e$input );
\&
\&    my $actual_events = q{};
\&
\&    READ: while (1) {
\&
\&        my @actual_events = ();
\&
\&        my $next_lexeme;
\&        EVENT:
\&        for my $event ( @{ $slr\->events() } ) {
\&            my ($name) = @{$event};
\&            if ($name eq \*(Aqinsert d\*(Aq) {
\&               my (undef, $length) = $slr\->pause_span();
\&               $next_lexeme = [\*(Aqreal d\*(Aq, \*(Aqd\*(Aq, $length];
\&            }
\&            push @actual_events, $name;
\&        }
\&
\&        if (@actual_events) {
\&            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
\&            $actual_events .= "\en";
\&        }
\&
\&        if ($next_lexeme) {
\&            $slr\->lexeme_read(@{$next_lexeme});
\&            $pos = $slr\->pos();
\&            next READ;
\&        }
\&        if ($pos < $length) {
\&            $pos = $slr\->resume();
\&            next READ;
\&        }
\&        last READ;
\&    } ## end READ: while (1)
\&
\&    my $expected_events = <<\*(Aq=== EOS ===\*(Aq;
\&    Events at position 0: ^test ^a
\&    Events at position 1: "a" ^b ^start1 ^start2
\&    Events at position 3: "b" start1$ ^c ^mid1
\&    Events at position 5: "c" start2$ ^d ^mid2
\&    Events at position 6: insert d
\&    Events at position 21: d$ mid1$ mid2$ e[] ^e ^f
\&    Events at position 23: "e" e$ e[] ^e ^f
\&    Events at position 25: "e" e$ ^f
\&    Events at position 27: "f" g[] g1[] g3[] g2[] g4[] ^h
\&    Events at position 29: "h" test$
\&    === EOS ===
.Ve
.SH "Unnamed events"
.IX Header "Unnamed events"
Use of unnamed events is strongly discouraged.
However, to support legacy code, unnamed events are still supported.
.PP
Unnamed events are declared by
\&\f(CW\*(C`:lexeme\*(C'\fR pseudo-rules,
when
the \f(CW\*(C`pause\*(C'\fR adverb 
is used without
the \f(CW\*(C`event\*(C'\fR adverb.
Since the
the \f(CW\*(C`pause\*(C'\fR adverb
creates a \s-1SLIF\s0 parse event, but
the \f(CW\*(C`event\*(C'\fR adverb
provides the event's name,
this results in a \s-1SLIF\s0 parse event without a name \*(--
an unnamed event.
.PP
Unnamed events cannot be accessed using
the \f(CW\*(C`$slr\->events()\*(C'\fR
method.
The only accessors for unnamed events are
the \f(CW\*(C`$slr\->pause_lexeme()\*(C'\fR
method
and the \f(CW\*(C`$slr\->pause_span()\*(C'\fR
method.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
