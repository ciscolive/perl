.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Set::Light 3"
.TH Set::Light 3 "2020-09-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Set::Light \- (memory efficient) unordered set of strings
.SH "VERSION"
.IX Header "VERSION"
version 0.94
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Set::Light;
\&
\&  my $set = Set::Light\->new( qw/foo bar baz/ );
\&
\&  if (!$set\->is_empty())
\&  {
\&    print "Set has ", $set\->size(), " elements.\en";
\&    for (qw/umpf foo bar baz bam/)
\&    {
\&        print "Set does ";
\&        print " not " unless $set\->has($_);
\&        print "contain \*(Aq$_\*(Aq.\en";
\&    }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Set::Light implements an unordered set of strings. Set::Light
currently uses a hash underneath, and each key of the hash points to
the same scalar, thus saving memory per item.
.SS "Why not use a hash?"
.IX Subsection "Why not use a hash?"
Usually you would use a hash to keep track of a list of items like:
.PP
.Vb 1
\&  my %SEEN;
\&
\&  ...
\&
\&  if (!$SEEN\->{$item}++)
\&  {
\&    # haven\*(Aqt seen item before
\&  }
.Ve
.PP
While this is very fast (both on inserting items, as well as looking them up),
it uses quite a lot of memory, since each key in \f(CW%SEEN\fR needs one scalar.
.SS "Why not use Set::Object or Set::Scalar?"
.IX Subsection "Why not use Set::Object or Set::Scalar?"
These use even more memory and/or are slower than an ordinary hash.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $set = Set::Light\->new( \e%opts, @members );
.Ve
.PP
Creates a new Set::Light object. An optionally passed hash reference can
contain options.
.PP
Any members passed to the constructor will be inserted.
.PP
Currently no options are supported.
.SS "insert"
.IX Subsection "insert"
.Vb 2
\&  $set\->insert( $string );
\&  $set\->insert( @strings );
.Ve
.PP
Inserts one or more strings into the set. Returns the number of insertions
it really did. Elements that are already contained in the set do not
get inserted twice. So:
.PP
.Vb 1
\&  use Set::Light;
\&
\&  my $set = Set::Light\->new();
\&  print $set\->insert(\*(Aqfoo\*(Aq);              # 1
\&  print $set\->insert(\*(Aqfoo\*(Aq);              # 0
\&  print $set\->insert(\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq,\*(Aqfoo\*(Aq);  # 2     (foo already inserted)
.Ve
.SS "is_empty"
.IX Subsection "is_empty"
.Vb 1
\&  if (!$set\->is_empty()) { ... }
.Ve
.PP
Returns true if the set is empty (has zero elements).
.SS "is_null"
.IX Subsection "is_null"
This is an alias to \*(L"is_empty\*(R".
.SS "size"
.IX Subsection "size"
.Vb 1
\&  my $elems = $set\->size();
.Ve
.PP
Returns the number of elements in the set.
.SS "has"
.IX Subsection "has"
.Vb 1
\&  if ($set\->has($member)) { ... }
.Ve
.PP
Returns true if the set contains the string \f(CW$member\fR.
.SS "contains"
.IX Subsection "contains"
This is an alias for \*(L"has\*(R".
.SS "exists"
.IX Subsection "exists"
This is an alias for \*(L"has\*(R".
.SS "delete"
.IX Subsection "delete"
.Vb 2
\&  $set\->delete( $string );
\&  $set\->delete( @strings );
.Ve
.PP
Deletes one or more strings from the set. Returns the number of
deletions it really did. Elements that are not contained in the set
cannot be deleted.  So:
.PP
.Vb 1
\&  use Set::Light;
\&
\&  my $set = Set::Light\->new();
\&  print $set\->insert(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq);      # 2
\&  print $set\->delete(\*(Aqfoo\*(Aq,\*(Aqfoo\*(Aq);      # 1     (only once deleted)
\&  pprint $set\->delete(\*(Aqbar\*(Aq,\*(Aqfoo\*(Aq);     # 1     (only once deleted)
.Ve
.SS "remove"
.IX Subsection "remove"
This is an alias for \*(L"delete\*(R".
.SS "members"
.IX Subsection "members"
.Vb 1
\&  my @members = $set\->members;
.Ve
.PP
This returns an array of set members in an unsorted array.
.PP
This was added in v0.91.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Set::Object, Set::Scalar.
.SH "SOURCE"
.IX Header "SOURCE"
The development version is on github at <https://github.com/robrwo/Set\-Light>
and may be cloned from <git://github.com/robrwo/Set\-Light.git>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://rt.cpan.org/Public/Dist/Display.html?Name=Set\-Light> or by email
to bug\-Set\-Light@rt.cpan.org <mailto:bug-Set-Light@rt.cpan.org>.
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tels <nospam\-abuse@bloodgate.com>
.SH "CONTRIBUTOR"
.IX Header "CONTRIBUTOR"
Robert Rothenberg <rrwo@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2004\-2008, 2019\-2020 by Tels.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
