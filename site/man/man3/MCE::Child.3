.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MCE::Child 3"
.TH MCE::Child 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MCE::Child \- A threads\-like parallelization module compatible with Perl 5.8
.SH "VERSION"
.IX Header "VERSION"
This document describes MCE::Child version 1.874
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use MCE::Child;
\&
\& MCE::Child\->init(
\&     max_workers => \*(Aqauto\*(Aq,   # default undef, unlimited
\&     child_timeout => 20,     # default undef, no timeout
\&     posix_exit => 1,         # default undef, CORE::exit
\&     void_context => 1,       # default undef
\&     on_start => sub {
\&         my ( $pid, $ident ) = @_;
\&         ...
\&     },
\&     on_finish => sub {
\&         my ( $pid, $exit, $ident, $signal, $error, @ret ) = @_;
\&         ...
\&     }
\& );
\&
\& MCE::Child\->create( sub { print "Hello from child\en" } )\->join();
\&
\& sub parallel {
\&     my ($arg1) = @_;
\&     print "Hello again, $arg1\en" if defined($arg1);
\&     print "Hello again, $_\en"; # same thing
\& }
\&
\& MCE::Child\->create( \e&parallel, $_ ) for 1 .. 3;
\&
\& my @procs    = MCE::Child\->list();
\& my @pids     = MCE::Child\->list_pids();
\& my @running  = MCE::Child\->list_running();
\& my @joinable = MCE::Child\->list_joinable();
\& my @count    = MCE::Child\->pending();
\&
\& # Joining is orderly, e.g. child1 is joined first, child2, child3.
\& $_\->join() for @procs;   # (or)
\& $_\->join() for @joinable;
\&
\& # Joining occurs immediately as child processes complete execution.
\& 1 while MCE::Child\->wait_one();
\&
\& my $child = mce_child { foreach (@files) { ... } };
\&
\& $child\->join();
\&
\& if ( my $err = $child\->error() ) {
\&     warn "Child error: $err\en";
\& }
\&
\& # Get a child\*(Aqs object
\& $child = MCE::Child\->self();
\&
\& # Get a child\*(Aqs ID
\& $pid = MCE::Child\->pid();  # $$
\& $pid = $child\->pid();
\& $pid = MCE::Child\->tid();  # tid is an alias for pid
\& $pid = $child\->tid();
\&
\& # Test child objects
\& if ( $child1 == $child2 ) {
\&     ...
\& }
\&
\& # Give other workers a chance to run
\& MCE::Child\->yield();
\& MCE::Child\->yield(0.05);
\&
\& # Return context, wantarray aware
\& my ($value1, $value2) = $child\->join();
\& my $value = $child\->join();
\&
\& # Check child\*(Aqs state
\& if ( $child\->is_running() ) {
\&     sleep 1;
\& }
\& if ( $child\->is_joinable() ) {
\&     $child\->join();
\& }
\&
\& # Send a signal to a child
\& $child\->kill(\*(AqSIGUSR1\*(Aq);
\&
\& # Exit a child
\& MCE::Child\->exit(0);
\& MCE::Child\->exit(0, @ret);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MCE::Child is a fork of MCE::Hobo for compatibility with Perl 5.8.
.PP
A child is a migratory worker inside the machine that carries the asynchronous
gene. Child processes are equipped with \f(CW\*(C`threads\*(C'\fR\-like capability for running
code asynchronously. Unlike threads, each child is a unique process to the
underlying \s-1OS.\s0 The \s-1IPC\s0 is handled via \f(CW\*(C`MCE::Channel\*(C'\fR, which runs on all the
major platforms including Cygwin and Strawberry Perl.
.PP
\&\f(CW\*(C`MCE::Child\*(C'\fR may be used as a standalone or together with \f(CW\*(C`MCE\*(C'\fR including
running alongside \f(CW\*(C`threads\*(C'\fR.
.PP
.Vb 2
\& use MCE::Child;
\& use MCE::Shared;
\&
\& # synopsis: head \-20 file.txt | perl script.pl
\&
\& my $ifh = MCE::Shared\->handle( "<", \e*STDIN  );  # shared
\& my $ofh = MCE::Shared\->handle( ">", \e*STDOUT );
\& my $ary = MCE::Shared\->array();
\&
\& sub parallel_task {
\&     my ( $id ) = @_;
\&     while ( <$ifh> ) {
\&         printf {$ofh} "[ %4d ] %s", $., $_;
\&       # $ary\->[ $. \- 1 ] = "[ ID $id ] read line $.\en" );  # dereferencing
\&         $ary\->set( $. \- 1, "[ ID $id ] read line $.\en" );  # faster via OO
\&     }
\& }
\&
\& my $child1 = MCE::Child\->new( "parallel_task", 1 );
\& my $child2 = MCE::Child\->new( \e&parallel_task, 2 );
\& my $child3 = MCE::Child\->new( sub { parallel_task(3) } );
\&
\& $_\->join for MCE::Child\->list();  # ditto: MCE::Child\->wait_all();
\&
\& # search array (total one round\-trip via IPC)
\& my @vals = $ary\->vals( "val =~ / ID 2 /" );
\&
\& print {*STDERR} join("", @vals);
.Ve
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
.ie n .IP "$child = MCE::Child\->create( \s-1FUNCTION, ARGS\s0 )" 3
.el .IP "\f(CW$child\fR = MCE::Child\->create( \s-1FUNCTION, ARGS\s0 )" 3
.IX Item "$child = MCE::Child->create( FUNCTION, ARGS )"
.PD 0
.ie n .IP "$child = MCE::Child\->new( \s-1FUNCTION, ARGS\s0 )" 3
.el .IP "\f(CW$child\fR = MCE::Child\->new( \s-1FUNCTION, ARGS\s0 )" 3
.IX Item "$child = MCE::Child->new( FUNCTION, ARGS )"
.PD
This will create a new child process that will begin execution with function
as the entry point, and optionally \s-1ARGS\s0 for list of parameters. It will return
the corresponding MCE::Child object, or undef if child creation failed.
.Sp
\&\fI\s-1FUNCTION\s0\fR may either be the name of a function, an anonymous subroutine, or
a code ref.
.Sp
.Vb 5
\& my $child = MCE::Child\->create( "func_name", ... );
\&     # or
\& my $child = MCE::Child\->create( sub { ... }, ... );
\&     # or
\& my $child = MCE::Child\->create( \e&func, ... );
.Ve
.ie n .IP "$child = MCE::Child\->create( { options }, \s-1FUNCTION, ARGS\s0 )" 3
.el .IP "\f(CW$child\fR = MCE::Child\->create( { options }, \s-1FUNCTION, ARGS\s0 )" 3
.IX Item "$child = MCE::Child->create( { options }, FUNCTION, ARGS )"
.PD 0
.ie n .IP "$child = MCE::Child\->create( \s-1IDENT, FUNCTION, ARGS\s0 )" 3
.el .IP "\f(CW$child\fR = MCE::Child\->create( \s-1IDENT, FUNCTION, ARGS\s0 )" 3
.IX Item "$child = MCE::Child->create( IDENT, FUNCTION, ARGS )"
.PD
Options, excluding \f(CW\*(C`ident\*(C'\fR, may be specified globally via the \f(CW\*(C`init\*(C'\fR function.
Otherwise, \f(CW\*(C`ident\*(C'\fR, \f(CW\*(C`child_timeout\*(C'\fR, \f(CW\*(C`posix_exit\*(C'\fR, and \f(CW\*(C`void_context\*(C'\fR may
be set uniquely.
.Sp
The \f(CW\*(C`ident\*(C'\fR option is used by callback functions \f(CW\*(C`on_start\*(C'\fR and \f(CW\*(C`on_finish\*(C'\fR
for identifying the started and finished child process respectively.
.Sp
.Vb 3
\& my $child1 = MCE::Child\->create( { posix_exit => 1 }, sub {
\&     ...
\& } );
\&
\& $child1\->join;
\&
\& my $child2 = MCE::Child\->create( { child_timeout => 3 }, sub {
\&     sleep 1 for ( 1 .. 9 );
\& } );
\&
\& $child2\->join;
\&
\& if ( $child2\->error() eq "Child timed out\en" ) {
\&     ...
\& }
.Ve
.Sp
The \f(CW\*(C`new()\*(C'\fR method is an alias for \f(CW\*(C`create()\*(C'\fR.
.IP "mce_child { \s-1BLOCK\s0 } \s-1ARGS\s0;" 3
.IX Item "mce_child { BLOCK } ARGS;"
.PD 0
.IP "mce_child { \s-1BLOCK\s0 };" 3
.IX Item "mce_child { BLOCK };"
.PD
\&\f(CW\*(C`mce_child\*(C'\fR runs the block asynchronously similarly to \f(CW\*(C`MCE::Child\->create()\*(C'\fR.
It returns the child object, or undef if child creation failed.
.Sp
.Vb 1
\& my $child = mce_child { foreach (@files) { ... } };
\&
\& $child\->join();
\&
\& if ( my $err = $child\->error() ) {
\&     warn("Child error: $err\en");
\& }
.Ve
.ie n .IP "$child\->\fBjoin()\fR" 3
.el .IP "\f(CW$child\fR\->\fBjoin()\fR" 3
.IX Item "$child->join()"
This will wait for the corresponding child process to complete its execution.
In non-voided context, \f(CW\*(C`join()\*(C'\fR will return the value(s) of the entry point
function.
.Sp
The context (void, scalar or list) for the return value(s) for \f(CW\*(C`join\*(C'\fR is
determined at the time of joining and mostly \f(CW\*(C`wantarray\*(C'\fR aware.
.Sp
.Vb 4
\& my $child1 = MCE::Child\->create( sub {
\&     my @res = qw(foo bar baz);
\&     return (@res);
\& });
\&
\& my @res1 = $child1\->join();  # ( foo, bar, baz )
\& my $res1 = $child1\->join();  #   baz
\&
\& my $child2 = MCE::Child\->create( sub {
\&     return \*(Aqfoo\*(Aq;
\& });
\&
\& my @res2 = $child2\->join();  # ( foo )
\& my $res2 = $child2\->join();  #   foo
.Ve
.ie n .IP "$child1\->equal( $child2 )" 3
.el .IP "\f(CW$child1\fR\->equal( \f(CW$child2\fR )" 3
.IX Item "$child1->equal( $child2 )"
Tests if two child objects are the same child or not. Child comparison is based
on process IDs. This is overloaded to the more natural forms.
.Sp
.Vb 7
\& if ( $child1 == $child2 ) {
\&     print("Child objects are the same\en");
\& }
\& # or
\& if ( $child1 != $child2 ) {
\&     print("Child objects differ\en");
\& }
.Ve
.ie n .IP "$child\->\fBerror()\fR" 3
.el .IP "\f(CW$child\fR\->\fBerror()\fR" 3
.IX Item "$child->error()"
Child processes are executed in an \f(CW\*(C`eval\*(C'\fR context. This method will return
\&\f(CW\*(C`undef\*(C'\fR if the child terminates \fInormally\fR. Otherwise, it returns the value
of \f(CW$@\fR associated with the child's execution status in its \f(CW\*(C`eval\*(C'\fR context.
.ie n .IP "$child\->\fBexit()\fR" 3
.el .IP "\f(CW$child\fR\->\fBexit()\fR" 3
.IX Item "$child->exit()"
This sends \f(CW\*(AqSIGQUIT\*(Aq\fR to the child process, notifying the child to exit.
It returns the child object to allow for method chaining. It is important to
join later if not immediately to not leave a zombie or defunct process.
.Sp
.Vb 2
\& $child\->exit()\->join();
\& ...
\&
\& $child\->join();  # later
.Ve
.IP "MCE::Child\->exit( 0 )" 3
.IX Item "MCE::Child->exit( 0 )"
.PD 0
.ie n .IP "MCE::Child\->exit( 0, @ret )" 3
.el .IP "MCE::Child\->exit( 0, \f(CW@ret\fR )" 3
.IX Item "MCE::Child->exit( 0, @ret )"
.PD
A child can exit at any time by calling \f(CW\*(C`MCE::Child\->exit()\*(C'\fR.
Otherwise, the behavior is the same as \f(CW\*(C`exit(status)\*(C'\fR when called from
the main process. The child process may optionally return data, to be
sent via \s-1IPC.\s0
.IP "MCE::Child\->\fBfinish()\fR" 3
.IX Item "MCE::Child->finish()"
This class method is called automatically by \f(CW\*(C`END\*(C'\fR, but may be called
explicitly. An error is emitted via croak if there are active child
processes not yet joined.
.Sp
.Vb 2
\& MCE::Child\->create( \*(Aqtask1\*(Aq, $_ ) for 1 .. 4;
\& $_\->join for MCE::Child\->list();
\&
\& MCE::Child\->create( \*(Aqtask2\*(Aq, $_ ) for 1 .. 4;
\& $_\->join for MCE::Child\->list();
\&
\& MCE::Child\->create( \*(Aqtask3\*(Aq, $_ ) for 1 .. 4;
\& $_\->join for MCE::Child\->list();
\&
\& MCE::Child\->finish();
.Ve
.IP "MCE::Child\->init( options )" 3
.IX Item "MCE::Child->init( options )"
The init function accepts a list of MCE::Child options.
.Sp
.Vb 10
\& MCE::Child\->init(
\&     max_workers => \*(Aqauto\*(Aq,   # default undef, unlimited
\&     child_timeout => 20,     # default undef, no timeout
\&     posix_exit => 1,         # default undef, CORE::exit
\&     void_context => 1,       # default undef
\&     on_start => sub {
\&         my ( $pid, $ident ) = @_;
\&         ...
\&     },
\&     on_finish => sub {
\&         my ( $pid, $exit, $ident, $signal, $error, @ret ) = @_;
\&         ...
\&     }
\& );
\&
\& # Identification given as an option or the 1st argument.
\&
\& for my $key ( \*(Aqaa\*(Aq .. \*(Aqzz\*(Aq ) {
\&     MCE::Child\->create( { ident => $key }, sub { ... } );
\&     MCE::Child\->create( $key, sub { ... } );
\& }
\&
\& MCE::Child\->wait_all;
.Ve
.Sp
Set \f(CW\*(C`max_workers\*(C'\fR if you want to limit the number of workers by waiting
automatically for an available slot. Specify \f(CW\*(C`auto\*(C'\fR to obtain the number
of logical cores via \f(CW\*(C`MCE::Util::get_ncpu()\*(C'\fR.
.Sp
Set \f(CW\*(C`child_timeout\*(C'\fR, in number of seconds, if you want the child process
to terminate after some time. The default is \f(CW0\fR for no timeout.
.Sp
Set \f(CW\*(C`posix_exit\*(C'\fR to avoid all \s-1END\s0 and destructor processing. Constructing
MCE::Child inside a thread implies 1 or if present \s-1CGI, FCGI,\s0 Coro, Curses,
Gearman::Util, Gearman::XS, LWP::UserAgent, Mojo::IOLoop, \s-1STFL,\s0 Tk, Wx,
or Win32::GUI.
.Sp
Set \f(CW\*(C`void_context\*(C'\fR to create the child process in void context for the
return value. Otherwise, the return context is wantarray-aware for
\&\f(CW\*(C`join()\*(C'\fR and \f(CW\*(C`result()\*(C'\fR and determined when retrieving the data.
.Sp
The callback options \f(CW\*(C`on_start\*(C'\fR and \f(CW\*(C`on_finish\*(C'\fR are called in the parent
process after starting the worker and later when terminated. The arguments
for the subroutines were inspired by Parallel::ForkManager.
.Sp
The parameters for \f(CW\*(C`on_start\*(C'\fR are the following:
.Sp
.Vb 2
\& \- pid of the child process
\& \- identification (ident option or 1st arg to create)
.Ve
.Sp
The parameters for \f(CW\*(C`on_finish\*(C'\fR are the following:
.Sp
.Vb 6
\& \- pid of the child process
\& \- program exit code
\& \- identification (ident option or 1st arg to create)
\& \- exit signal id
\& \- error message from eval inside MCE::Child
\& \- returned data
.Ve
.ie n .IP "$child\->\fBis_running()\fR" 3
.el .IP "\f(CW$child\fR\->\fBis_running()\fR" 3
.IX Item "$child->is_running()"
Returns true if a child is still running.
.ie n .IP "$child\->\fBis_joinable()\fR" 3
.el .IP "\f(CW$child\fR\->\fBis_joinable()\fR" 3
.IX Item "$child->is_joinable()"
Returns true if the child has finished running and not yet joined.
.ie n .IP "$child\->kill( '\s-1SIG...\s0' )" 3
.el .IP "\f(CW$child\fR\->kill( '\s-1SIG...\s0' )" 3
.IX Item "$child->kill( 'SIG...' )"
Sends the specified signal to the child. Returns the child object to allow for
method chaining. As with \f(CW\*(C`exit\*(C'\fR, it is important to join eventually if not
immediately to not leave a zombie or defunct process.
.Sp
.Vb 1
\& $child\->kill(\*(AqSIG...\*(Aq)\->join();
.Ve
.Sp
The following is a parallel demonstration comparing \f(CW\*(C`MCE::Shared\*(C'\fR against
\&\f(CW\*(C`Redis\*(C'\fR and \f(CW\*(C`Redis::Fast\*(C'\fR on a Fedora 23 \s-1VM.\s0 Joining begins after all
workers have been notified to quit.
.Sp
.Vb 1
\& use Time::HiRes qw(time);
\&
\& use Redis;
\& use Redis::Fast;
\&
\& use MCE::Child;
\& use MCE::Shared;
\&
\& my $redis = Redis\->new();
\& my $rfast = Redis::Fast\->new();
\& my $array = MCE::Shared\->array();
\&
\& sub parallel_redis {
\&     my ($_redis) = @_;
\&     my ($count, $quit, $len) = (0, 0);
\&
\&     # instead, use a flag to exit loop
\&     $SIG{\*(AqQUIT\*(Aq} = sub { $quit = 1 };
\&
\&     while () {
\&         $len = $_redis\->rpush(\*(Aqlist\*(Aq, $count++);
\&         last if $quit;
\&     }
\&
\&     $count;
\& }
\&
\& sub parallel_array {
\&     my ($count, $quit, $len) = (0, 0);
\&
\&     # do not exit from inside handler
\&     $SIG{\*(AqQUIT\*(Aq} = sub { $quit = 1 };
\&
\&     while () {
\&         $len = $array\->push($count++);
\&         last if $quit;
\&     }
\&
\&     $count;
\& }
\&
\& sub benchmark_this {
\&     my ($desc, $num_procs, $timeout, $code, @args) = @_;
\&     my ($start, $total) = (time(), 0);
\&
\&     MCE::Child\->new($code, @args) for 1..$num_procs;
\&     sleep $timeout;
\&
\&     # joining is not immediate; ok
\&     $_\->kill(\*(AqQUIT\*(Aq) for MCE::Child\->list();
\&
\&     # joining later; ok
\&     $total += $_\->join() for MCE::Child\->list();
\&
\&     printf "$desc <> duration: %0.03f secs, count: $total\en",
\&         time() \- $start;
\&
\&     sleep 0.2;
\& }
\&
\& benchmark_this(\*(AqRedis      \*(Aq, 8, 5.0, \e&parallel_redis, $redis);
\& benchmark_this(\*(AqRedis::Fast\*(Aq, 8, 5.0, \e&parallel_redis, $rfast);
\& benchmark_this(\*(AqMCE::Shared\*(Aq, 8, 5.0, \e&parallel_array);
.Ve
.IP "MCE::Child\->\fBlist()\fR" 3
.IX Item "MCE::Child->list()"
Returns a list of all child objects not yet joined.
.Sp
.Vb 1
\& @procs = MCE::Child\->list();
.Ve
.IP "MCE::Child\->\fBlist_pids()\fR" 3
.IX Item "MCE::Child->list_pids()"
Returns a list of all child pids not yet joined (available since 1.849).
.Sp
.Vb 1
\& @pids = MCE::Child\->list_pids();
\&
\& $SIG{INT} = $SIG{HUP} = $SIG{TERM} = sub {
\&     # Signal workers all at once
\&     CORE::kill(\*(AqKILL\*(Aq, MCE::Child\->list_pids());
\&     exec(\*(Aqreset\*(Aq);
\& };
.Ve
.IP "MCE::Child\->\fBlist_running()\fR" 3
.IX Item "MCE::Child->list_running()"
Returns a list of all child objects that are still running.
.Sp
.Vb 1
\& @procs = MCE::Child\->list_running();
.Ve
.IP "MCE::Child\->\fBlist_joinable()\fR" 3
.IX Item "MCE::Child->list_joinable()"
Returns a list of all child objects that have completed running.
Thus, ready to be joined without blocking.
.Sp
.Vb 1
\& @procs = MCE::Child\->list_joinable();
.Ve
.IP "MCE::Child\->max_workers([ N ])" 3
.IX Item "MCE::Child->max_workers([ N ])"
Getter and setter for max_workers. Specify a number or 'auto' to acquire the
total number of cores via MCE::Util::get_ncpu. Specify a false value to set
back to no limit.
.IP "MCE::Child\->\fBpending()\fR" 3
.IX Item "MCE::Child->pending()"
Returns a count of all child objects not yet joined.
.Sp
.Vb 1
\& $count = MCE::Child\->pending();
.Ve
.ie n .IP "$child\->\fBresult()\fR" 3
.el .IP "\f(CW$child\fR\->\fBresult()\fR" 3
.IX Item "$child->result()"
Returns the result obtained by \f(CW\*(C`join\*(C'\fR, \f(CW\*(C`wait_one\*(C'\fR, or \f(CW\*(C`wait_all\*(C'\fR. If the
process has not yet exited, waits for the corresponding child to complete its
execution.
.Sp
.Vb 2
\& use MCE::Child;
\& use Time::HiRes qw(sleep);
\&
\& sub task {
\&     my ($id) = @_;
\&     sleep $id * 0.333;
\&     return $id;
\& }
\&
\& MCE::Child\->create(\*(Aqtask\*(Aq, $_) for ( reverse 1 .. 3 );
\&
\& # 1 while MCE::Child\->wait_one();
\&
\& while ( my $child = MCE::Child\->wait_one() ) {
\&     my $err = $child\->error() || \*(Aqno error\*(Aq;
\&     my $res = $child\->result();
\&     my $pid = $child\->pid();
\&
\&     print "[$pid] $err : $res\en";
\& }
.Ve
.Sp
Like \f(CW\*(C`join\*(C'\fR described above, the context (void, scalar or list) for the
return value(s) is determined at the time \f(CW\*(C`result\*(C'\fR is called and mostly
\&\f(CW\*(C`wantarray\*(C'\fR aware.
.Sp
.Vb 4
\& my $child1 = MCE::Child\->create( sub {
\&     my @res = qw(foo bar baz);
\&     return (@res);
\& });
\&
\& my @res1 = $child1\->result();  # ( foo, bar, baz )
\& my $res1 = $child1\->result();  #   baz
\&
\& my $child2 = MCE::Child\->create( sub {
\&     return \*(Aqfoo\*(Aq;
\& });
\&
\& my @res2 = $child2\->result();  # ( foo )
\& my $res2 = $child2\->result();  #   foo
.Ve
.IP "MCE::Child\->\fBself()\fR" 3
.IX Item "MCE::Child->self()"
Class method that allows a child to obtain it's own \fIMCE::Child\fR object.
.ie n .IP "$child\->\fBpid()\fR" 3
.el .IP "\f(CW$child\fR\->\fBpid()\fR" 3
.IX Item "$child->pid()"
.PD 0
.ie n .IP "$child\->\fBtid()\fR" 3
.el .IP "\f(CW$child\fR\->\fBtid()\fR" 3
.IX Item "$child->tid()"
.PD
Returns the \s-1ID\s0 of the child.
.Sp
.Vb 2
\& pid: $$  process id
\& tid: $$  alias for pid
.Ve
.IP "MCE::Child\->\fBpid()\fR" 3
.IX Item "MCE::Child->pid()"
.PD 0
.IP "MCE::Child\->\fBtid()\fR" 3
.IX Item "MCE::Child->tid()"
.PD
Class methods that allows a child to obtain its own \s-1ID.\s0
.Sp
.Vb 2
\& pid: $$  process id
\& tid: $$  alias for pid
.Ve
.IP "MCE::Child\->\fBwait_one()\fR" 3
.IX Item "MCE::Child->wait_one()"
.PD 0
.IP "MCE::Child\->\fBwaitone()\fR" 3
.IX Item "MCE::Child->waitone()"
.IP "MCE::Child\->\fBwait_all()\fR" 3
.IX Item "MCE::Child->wait_all()"
.IP "MCE::Child\->\fBwaitall()\fR" 3
.IX Item "MCE::Child->waitall()"
.PD
Meaningful for the manager process only, waits for one or all child processes
to complete execution. Afterwards, returns the corresponding child objects.
If a child doesn't exist, returns the \f(CW\*(C`undef\*(C'\fR value or an empty list for
\&\f(CW\*(C`wait_one\*(C'\fR and \f(CW\*(C`wait_all\*(C'\fR respectively.
.Sp
The \f(CW\*(C`waitone\*(C'\fR and \f(CW\*(C`waitall\*(C'\fR methods are aliases for compatibility with
\&\f(CW\*(C`MCE::Hobo\*(C'\fR.
.Sp
.Vb 2
\& use MCE::Child;
\& use Time::HiRes qw(sleep);
\&
\& sub task {
\&     my $id = shift;
\&     sleep $id * 0.333;
\&     return $id;
\& }
\&
\& MCE::Child\->create(\*(Aqtask\*(Aq, $_) for ( reverse 1 .. 3 );
\&
\& # join, traditional use case
\& $_\->join() for MCE::Child\->list();
\&
\& # wait_one, simplistic use case
\& 1 while MCE::Child\->wait_one();
\&
\& # wait_one
\& while ( my $child = MCE::Child\->wait_one() ) {
\&     my $err = $child\->error() || \*(Aqno error\*(Aq;
\&     my $res = $child\->result();
\&     my $pid = $child\->pid();
\&
\&     print "[$pid] $err : $res\en";
\& }
\&
\& # wait_all
\& my @procs = MCE::Child\->wait_all();
\&
\& for ( @procs ) {
\&     my $err = $_\->error() || \*(Aqno error\*(Aq;
\&     my $res = $_\->result();
\&     my $pid = $_\->pid();
\&
\&     print "[$pid] $err : $res\en";
\& }
.Ve
.IP "MCE::Child\->yield( [ floating_seconds ] )" 3
.IX Item "MCE::Child->yield( [ floating_seconds ] )"
Give other workers a chance to run, optionally for given time. Yield behaves
similarly to \s-1MCE\s0's interval option. It throttles workers from running too fast.
A demonstration is provided in the next section for fetching URLs in parallel.
.Sp
The default \f(CW\*(C`floating_seconds\*(C'\fR is 0.008 and 0.015 on \s-1UNIX\s0 and Windows,
respectively. Pass 0 if simply wanting to give other workers a chance to run.
.Sp
.Vb 1
\& # total run time: 1.00 second
\&
\& MCE::Child\->create( sub { MCE::Child\->yield(0.25) } ) for 1 .. 4;
\& MCE::Child\->wait_all();
.Ve
.SH "THREADS-like DETACH CAPABILITY"
.IX Header "THREADS-like DETACH CAPABILITY"
Threads-like detach capability was added starting with the 1.867 release.
.PP
A threads example is shown first followed by the MCE::Child example. All one
needs to do is set the \s-1CHLD\s0 signal handler to \s-1IGNORE.\s0 Unfortunately, this works
on \s-1UNIX\s0 platforms only. The child process restores the \s-1CHLD\s0 handler to default,
so is able to deeply spin workers and reap if desired.
.PP
.Vb 1
\& use threads;
\&
\& for ( 1 .. 8 ) {
\&     async {
\&         # do something
\&     }\->detach;
\& }
\&
\& use MCE::Child;
\&
\& # Have the OS reap workers automatically when exiting.
\& # The on_finish option is ignored if specified (no\-op).
\& # Ensure not inside a thread on UNIX platforms.
\&
\& $SIG{CHLD} = \*(AqIGNORE\*(Aq;
\&
\& for ( 1 .. 8 ) {
\&     mce_child {
\&         # do something
\&     };
\& }
\&
\& # Optionally, wait for any remaining workers before leaving.
\& # This is necessary if workers are consuming shared objects,
\& # constructed via MCE::Shared.
\&
\& MCE::Child\->wait_all;
.Ve
.PP
The following is another way and works on Windows.
Here, the on_finish handler works as usual.
.PP
.Vb 1
\& use MCE::Child;
\&
\& MCE::Child\->init(
\&     on_finish = sub {
\&         ...
\&     },
\& );
\&
\& for ( 1 .. 8 ) {
\&     $_\->join for MCE::Child\->list_joinable;
\&     mce_child {
\&         # do something
\&     };
\& }
\&
\& MCE::Child\->wait_all;
.Ve
.SH "PARALLEL::FORKMANAGER\-like DEMONSTRATION"
.IX Header "PARALLEL::FORKMANAGER-like DEMONSTRATION"
MCE::Child behaves similarly to threads for the most part. It also provides
Parallel::ForkManager\-like capabilities. The \f(CW\*(C`Parallel::ForkManager\*(C'\fR
example is shown first followed by a version using \f(CW\*(C`MCE::Child\*(C'\fR.
.IP "Parallel::ForkManager" 3
.IX Item "Parallel::ForkManager"
.Vb 2
\& use strict;
\& use warnings;
\&
\& use Parallel::ForkManager;
\& use Time::HiRes \*(Aqtime\*(Aq;
\&
\& my $start = time;
\&
\& my $pm = Parallel::ForkManager\->new(10);
\& $pm\->set_waitpid_blocking_sleep(0);
\&
\& $pm\->run_on_finish( sub {
\&     my ($pid, $exit_code, $ident, $exit_signal, $core_dumped, $resp) = @_;
\&     print "child $pid completed: $ident => ", $resp\->[0], "\en";
\& });
\&
\& DATA_LOOP:
\& foreach my $data ( 1..2000 ) {
\&     # forks and returns the pid for the child
\&     my $pid = $pm\->start($data) and next DATA_LOOP;
\&     my $ret = [ $data * 2 ];
\&
\&     $pm\->finish(0, $ret);
\& }
\&
\& $pm\->wait_all_children;
\&
\& printf STDERR "duration: %0.03f seconds\en", time \- $start;
.Ve
.IP "MCE::Child" 3
.IX Item "MCE::Child"
.Vb 2
\& use strict;
\& use warnings;
\&
\& use MCE::Child 1.843;
\& use Time::HiRes \*(Aqtime\*(Aq;
\&
\& my $start = time;
\&
\& MCE::Child\->init(
\&     max_workers => 10,
\&     on_finish   => sub {
\&         my ($pid, $exit_code, $ident, $exit_signal, $error, $resp) = @_;
\&         print "child $pid completed: $ident => ", $resp\->[0], "\en";
\&     }
\& );
\&
\& foreach my $data ( 1..2000 ) {
\&     MCE::Child\->create( $data, sub {
\&         [ $data * 2 ];
\&     });
\& }
\&
\& MCE::Child\->wait_all;
\&
\& printf STDERR "duration: %0.03f seconds\en", time \- $start;
.Ve
.IP "Time to spin 2,000 workers and obtain results (in seconds)." 3
.IX Item "Time to spin 2,000 workers and obtain results (in seconds)."
Results were obtained on a Macbook Pro (2.6 GHz ~ 3.6 GHz with Turbo Boost).
Parallel::ForkManager 2.02 uses Moo. Therefore, I ran again with Moo loaded
at the top of the script.
.Sp
.Vb 2
\& MCE::Hobo uses MCE::Shared to retrieve data during reaping.
\& MCE::Child uses MCE::Channel, no shared\-manager.
\&
\&          Version  Cygwin   Windows  Linux   macOS  FreeBSD
\&
\& MCE::Child 1.843  19.099s  17.091s  0.965s  1.534s  1.229s
\&  MCE::Hobo 1.843  20.514s  19.594s  1.246s  1.629s  1.613s
\&      P::FM 1.20   19.703s  19.235s  0.875s  1.445s  1.346s
\&
\& MCE::Child 1.843  20.426s  18.417s  1.116s  1.632s  1.338s  Moo loaded
\&  MCE::Hobo 1.843  21.809s  20.810s  1.407s  1.759s  1.722s  Moo loaded
\&      P::FM 2.02   21.668s  25.927s  1.882s  2.612s  2.483s  Moo used
.Ve
.IP "Set posix_exit to avoid all \s-1END\s0 and destructor processing." 3
.IX Item "Set posix_exit to avoid all END and destructor processing."
This is helpful for reducing overhead when workers exit. Ditto if using a Perl
module not parallel safe. The option is ignored on Windows \f(CW\*(C`$^O eq \*(AqMSWin32\*(Aq\*(C'\fR.
.Sp
.Vb 2
\& MCE::Child\->init( posix_exit => 1, ... );
\&  MCE::Hobo\->init( posix_exit => 1, ... );
\&
\&          Version  Cygwin   Windows  Linux   macOS  FreeBSD
\&
\& MCE::Child 1.843  19.815s  ignored  0.824s  1.284s  1.245s  Moo loaded
\&  MCE::Hobo 1.843  21.029s  ignored  0.953s  1.335s  1.439s  Moo loaded
.Ve
.SH "PARALLEL HTTP GET DEMONSTRATION USING ANYEVENT"
.IX Header "PARALLEL HTTP GET DEMONSTRATION USING ANYEVENT"
This demonstration constructs two queues, two handles, starts the
shared-manager process if needed, and spawns four workers.
For this demonstration, am chunking 64 URLs per job. In reality,
one may run with 200 workers and chunk 300 URLs on a 24\-way box.
.PP
.Vb 6
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\& # perl demo.pl              \-\- all output
\& # perl demo.pl  >/dev/null  \-\- mngr/child output
\& # perl demo.pl 2>/dev/null  \-\- show results only
\& #
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\&
\& use strict;
\& use warnings;
\&
\& use AnyEvent;
\& use AnyEvent::HTTP;
\& use Time::HiRes qw( time );
\&
\& use MCE::Child;
\& use MCE::Shared;
\&
\& # Construct two queues, input and return.
\&
\& my $que = MCE::Shared\->queue();
\& my $ret = MCE::Shared\->queue();
\&
\& # Construct shared handles for serializing output from many workers
\& # writing simultaneously. This prevents garbled output.
\&
\& mce_open my $OUT, ">>", \e*STDOUT or die "open error: $!";
\& mce_open my $ERR, ">>", \e*STDERR or die "open error: $!";
\&
\& # Spawn workers early for minimum memory consumption.
\&
\& MCE::Child\->create({ posix_exit => 1 }, \*(Aqtask\*(Aq, $_) for 1 .. 4;
\&
\& # Obtain or generate input data for workers to process.
\&
\& my ( $count, @urls ) = ( 0 );
\&
\& push @urls, map { "http://127.0.0.$_/"   } 1..254;
\& push @urls, map { "http://192.168.0.$_/" } 1..254; # 508 URLs total
\&
\& while ( @urls ) {
\&     my @chunk = splice(@urls, 0, 64);
\&     $que\->enqueue( { ID => ++$count, INPUT => \e@chunk } );
\& }
\&
\& # So that workers leave the loop after consuming the queue.
\&
\& $que\->end();
\&
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\& # Loop for the manager process. The manager may do other work if
\& # need be and periodically check $ret\->pending() not shown here.
\& #
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\&
\& my $start = time;
\&
\& printf {$ERR} "Mngr  \- entering loop\en";
\&
\& while ( $count ) {
\&     my ( $result, $failed ) = $ret\->dequeue( 2 );
\&
\&     # Remove ID from result, so not treated as a URL item.
\&
\&     printf {$ERR} "Mngr  \- received job %s\en", delete $result\->{ID};
\&
\&     # Display the URL and the size captured.
\&
\&     foreach my $url ( keys %{ $result } ) {
\&         printf {$OUT} "%s: %d\en", $url, length($result\->{$url})
\&             if $result\->{$url};  # url has content
\&     }
\&
\&     # Display URLs could not reach.
\&
\&     if ( @{ $failed } ) {
\&         foreach my $url ( @{ $failed } ) {
\&             print {$OUT} "Failed: $url\en";
\&         }
\&     }
\&
\&     # Decrement the count.
\&
\&     $count\-\-;
\& }
\&
\& MCE::Child\->wait_all();
\&
\& printf {$ERR} "Mngr  \- exiting loop\en\en";
\& printf {$ERR} "Duration: %0.3f seconds\en\en", time \- $start;
\&
\& exit;
\&
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\& # Child processes enqueue two items ( $result and $failed ) per each
\& # job for the manager process. Likewise, the manager process dequeues
\& # two items above. Optionally, child processes may include the ID in
\& # the result.
\& #
\& # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\&
\& sub task {
\&     my ( $id ) = @_;
\&     printf {$ERR} "Child $id entering loop\en";
\&
\&     while ( my $job = $que\->dequeue() ) {
\&         my ( $result, $failed ) = ( { ID => $job\->{ID} }, [ ] );
\&
\&         # Walk URLs, provide a hash and array refs for data.
\&
\&         printf {$ERR} "Child $id running  job $job\->{ID}\en";
\&         walk( $job, $result, $failed );
\&
\&         # Send results to the manager process.
\&
\&         $ret\->enqueue( $result, $failed );
\&     }
\&
\&     printf {$ERR} "Child $id exiting loop\en";
\& }
\&
\& sub walk {
\&     my ( $job, $result, $failed ) = @_;
\&
\&     # Yielding is critical when running an event loop in parallel.
\&     # Not doing so means that the app may reach contention points
\&     # with the firewall and likely impose unnecessary hardship at
\&     # the OS level. The idea here is not to have multiple workers
\&     # initiate HTTP requests to a batch of URLs at the same time.
\&     # Yielding behaves similarly like scatter to have the child
\&     # process run solo for a fraction of time.
\&
\&     MCE::Child\->yield( 0.03 );
\&
\&     my $cv = AnyEvent\->condvar();
\&
\&     # Populate the hash ref for the URLs it could reach.
\&     # Do not mix AnyEvent timeout with child timeout.
\&     # Therefore, choose event timeout when available.
\&
\&     foreach my $url ( @{ $job\->{INPUT} } ) {
\&         $cv\->begin();
\&         http_get $url, timeout => 2, sub {
\&             my ( $data, $headers ) = @_;
\&             $result\->{$url} = $data;
\&             $cv\->end();
\&         };
\&     }
\&
\&     $cv\->recv();
\&
\&     # Populate the array ref for URLs it could not reach.
\&
\&     foreach my $url ( @{ $job\->{INPUT} } ) {
\&         push @{ $failed }, $url unless (exists $result\->{ $url });
\&     }
\&
\&     return;
\& }
\&
\& _\|_END_\|_
\&
\& $ perl demo.pl
\&
\& Child 1 entering loop
\& Child 2 entering loop
\& Child 3 entering loop
\& Mngr  \- entering loop
\& Child 2 running  job 2
\& Child 3 running  job 3
\& Child 1 running  job 1
\& Child 4 entering loop
\& Child 4 running  job 4
\& Child 2 running  job 5
\& Mngr  \- received job 2
\& Child 3 running  job 6
\& Mngr  \- received job 3
\& Child 1 running  job 7
\& Mngr  \- received job 1
\& Child 4 running  job 8
\& Mngr  \- received job 4
\& http://192.168.0.1/: 3729
\& Child 2 exiting loop
\& Mngr  \- received job 5
\& Child 3 exiting loop
\& Mngr  \- received job 6
\& Child 1 exiting loop
\& Mngr  \- received job 7
\& Child 4 exiting loop
\& Mngr  \- received job 8
\& Mngr  \- exiting loop
\&
\& Duration: 4.131 seconds
.Ve
.SH "CROSS-PLATFORM TEMPLATE FOR BINARY EXECUTABLE"
.IX Header "CROSS-PLATFORM TEMPLATE FOR BINARY EXECUTABLE"
Making an executable is possible with the PAR::Packer module.
On the Windows platform, threads, threads::shared, and exiting via
threads are necessary for the binary to exit successfully.
.PP
.Vb 5
\& # https://metacpan.org/pod/PAR::Packer
\& # https://metacpan.org/pod/pp
\& #
\& #   pp \-o demo.exe demo.pl
\& #   ./demo.exe
\&
\& use strict;
\& use warnings;
\&
\& use if $^O eq "MSWin32", "threads";
\& use if $^O eq "MSWin32", "threads::shared";
\&
\& # Include minimum dependencies for MCE::Child.
\& # Add other modules required by your application here.
\&
\& use Storable ();
\& use Time::HiRes ();
\&
\& # use IO::FDPass ();  # optional: for condvar, handle, queue
\& # use Sereal ();      # optional: for faster serialization
\&
\& use MCE::Child;
\& use MCE::Shared;
\&
\& # For PAR to work on the Windows platform, one must include manually
\& # any shared modules used by the application.
\&
\& # use MCE::Shared::Array;    # if using MCE::Shared\->array
\& # use MCE::Shared::Cache;    # if using MCE::Shared\->cache
\& # use MCE::Shared::Condvar;  # if using MCE::Shared\->condvar
\& # use MCE::Shared::Handle;   # if using MCE::Shared\->handle, mce_open
\& # use MCE::Shared::Hash;     # if using MCE::Shared\->hash
\& # use MCE::Shared::Minidb;   # if using MCE::Shared\->minidb
\& # use MCE::Shared::Ordhash;  # if using MCE::Shared\->ordhash
\& # use MCE::Shared::Queue;    # if using MCE::Shared\->queue
\& # use MCE::Shared::Scalar;   # if using MCE::Shared\->scalar
\&
\& # Et cetera. Only load modules needed for your application.
\&
\& use MCE::Shared::Sequence;   # if using MCE::Shared\->sequence
\&
\& my $seq = MCE::Shared\->sequence( 1, 9 );
\&
\& sub task {
\&     my ( $id ) = @_;
\&     while ( defined ( my $num = $seq\->next() ) ) {
\&         print "$id: $num\en";
\&         sleep 1;
\&     }
\& }
\&
\& sub main {
\&     MCE::Child\->new( \e&task, $_ ) for 1 .. 3;
\&     MCE::Child\->wait_all();
\& }
\&
\& # Main must run inside a thread on the Windows platform or workers
\& # will fail duing exiting, causing the exe to crash. The reason is
\& # that PAR or a dependency isn\*(Aqt multi\-process safe.
\&
\& ( $^O eq "MSWin32" ) ? threads\->create(\e&main)\->join() : main();
\&
\& threads\->exit(0) if $INC{"threads.pm"};
.Ve
.SH "LIMITATION"
.IX Header "LIMITATION"
MCE::Child emits an error when \f(CW\*(C`is_joinable\*(C'\fR, \f(CW\*(C`is_running\*(C'\fR, and \f(CW\*(C`join\*(C'\fR isn't
called by the managed process, where the child was spawned. This is a limitation
in MCE::Child only due to not involving a shared-manager process for \s-1IPC.\s0
.PP
This use-case is not typical.
.SH "CREDITS"
.IX Header "CREDITS"
The inspiration for \f(CW\*(C`MCE::Child\*(C'\fR comes from wanting \f(CW\*(C`threads\*(C'\fR\-like behavior
for processes compatible with Perl 5.8. Both can run side-by-side including
safe-use by \s-1MCE\s0 workers. Likewise, the documentation resembles \f(CW\*(C`threads\*(C'\fR.
.PP
The inspiration for \f(CW\*(C`wait_all\*(C'\fR and \f(CW\*(C`wait_one\*(C'\fR comes from the
\&\f(CW\*(C`Parallel::WorkUnit\*(C'\fR module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 3
forks
.IP "\(bu" 3
forks::BerkeleyDB
.IP "\(bu" 3
MCE::Hobo
.IP "\(bu" 3
Parallel::ForkManager
.IP "\(bu" 3
Parallel::Loops
.IP "\(bu" 3
Parallel::Prefork
.IP "\(bu" 3
Parallel::WorkUnit
.IP "\(bu" 3
Proc::Fork
.IP "\(bu" 3
Thread::Tie
.IP "\(bu" 3
threads
.SH "INDEX"
.IX Header "INDEX"
\&\s-1MCE\s0, MCE::Channel, MCE::Shared
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario E. Roy, <marioeroy AT gmail DOT com>
