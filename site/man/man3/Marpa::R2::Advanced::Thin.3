.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Advanced::Thin 3"
.TH Marpa::R2::Advanced::Thin 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Advanced::Thin \- Direct access to Libmarpa
.SH "About this document"
.IX Header "About this document"
Most Marpa users can ignore this document.
It describes Marpa's \*(L"thin\*(R" interface,
which
provides efficient access to Marpa's core
library, Libmarpa.
.PP
The \*(L"thin\*(R" interface is very low-level and
is not designed to be convenient to use.
User-friendliness is expected to be provided by
an upper layer.
The \*(L"thin\*(R" interface
is intended for use in writing
those upper layers.
Libmarpa is also intended for writing applications,
when the programmer wants
to eliminate the overhead of an upper layer,
or wants the flexibility provided by direct access to Libmarpa,
and is willing to go to some extra effort.
.SH "How this document is written"
.IX Header "How this document is written"
This document assumes that the reader is familiar with
the other Marpa::R2 documentation,
as well as with the Libmarpa \s-1API\s0 document.
This means its reader will have to know some C language \*(--
at least enough to understand a discussion
written in terms of C functions,
their parameters and return values,
and C language macros.
.PP
This document
avoids
duplicating the material in the Libmarpa
\&\s-1API\s0 document.
Most Marpa thin interface functions correspond
directly to a Libmarpa method,
and their implementation follows a \*(L"general pattern\*(R".
This document describes that \*(L"general pattern\*(R".
.PP
Methods that follow
the general pattern are usually
not mentioned specifically.
Methods that are
exceptions
to the general pattern
are always mentioned,
and behaviors which deviate from the general
pattern are always described in detail.
This document also identifies
those Libmarpa
methods to which
no Marpa thin interface method directly corresponds.
.PP
This style of documentation 
is very efficient,
which is one reason that it is the
standard for C library interfaces to Perl.
Admittedly, however,
it is also very terse.
As an aid to
the reader,
an example of a script using
the Marpa thin interface is presented
below.
While small, the example is non-trival.
It is also full,
in the sense it contains a complete
logic flow, starting with the definition
of the grammar
and continuing all the way to the iteration of
the values of an ambiguous parse.
.SH "Methods in the thin interface"
.IX Header "Methods in the thin interface"
While the thin interface has a few
methods of its own,
most of its methods are wrappers for a method
from the Libmarpa interface.
On the other hand,
many 
Libmarpa methods do not have
Marpa thin interface wrappers.
No internal Libmarpa method is part of the Marpa thin interface.
.PP
Additionally,
many of the
external Libmarpa methods are omitted because their function is performed
by the Marpa thin interface.
No thin interface method corresponds to
the \f(CW\*(C`marpa_check_version()\*(C'\fR static method,
because the Marpa thin interface
interface handles its own version matching.
.PP
No thin interface method corresponds to any
of the Libmarpa configuration class methods.
No Marpa thin interface object corresponds
to Libmarpa's configuration objects.
Configuration in the Marpa thin
interface is done using Perl variables.
.PP
No Marpa thin interface method corresponds to the
\&\f(CW\*(C`marpa_g_ref()\*(C'\fR and \f(CW\*(C`marpa_g_unref()\*(C'\fR methods
because the thin interface handles the
reference counting of the Libmarpa objects it creates.
The application can rely on Libmarpa
objects being cleaned up properly as part of Perl's
usual garbage collection.
For the same reason,
no Marpa thin interface method corresponds to the
\&\*(L"ref\*(R" and \*(L"unref\*(R" methods of the other Libmarpa time
classes.
.PP
Whenever an external Libmarpa method is not mentioned
in this document, the reader can assume that
it has a wrapper that is implemented according
to the general pattern, as
described below.
Where the implementation of an
external Libmarpa method
is an exception to the general pattern,
its implementation will be explicitly described
and any corresponding Marpa thin interface method
will have a section devoted to it
and specifying its differences
from the general pattern.
.SH "Libmarpa time objects and constructors"
.IX Header "Libmarpa time objects and constructors"
As a reminder,
Libmarpa's major classes are,
in sequence,
configuration,
grammar, recognizer, bocage,
ordering, tree and value.
The one-letter abbreviations for these
are, respectively,
\&\f(CW\*(C`c\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`b\*(C'\fR, \f(CW\*(C`o\*(C'\fR, \f(CW\*(C`t\*(C'\fR and \f(CW\*(C`v\*(C'\fR.
.PP
.Vb 7
\&    Marpa_Config        Marpa::R2::Thin::C
\&    Marpa_Grammar       Marpa::R2::Thin::G
\&    Marpa_Recognizer    Marpa::R2::Thin::R
\&    Marpa_Bocage        Marpa::R2::Thin::B
\&    Marpa_Ordering      Marpa::R2::Thin::O
\&    Marpa_Tree          Marpa::R2::Thin::T
\&    Marpa_Value         Marpa::R2::Thin::V
.Ve
.PP
The thin interface implements a Perl class
corresponding to
each of Libmarpa time classes.
The thin interface does not implement a Perl class
corresponding to Libmarpa's configuration class.
.PP
Objects in the thin Marpa classes
should be treated as opaque scalars.
Applications must not define new methods,
constants or variables in a
thin Marpa classes.
Similarly, applications
must not
redefine, overload or remove existing elements.
Thin Marpa classes must not be subclassed.
Applications should restrict their operation on
objects in the Marpa thin classes to assignments;
calling methods of the class; and,
in those cases where
this document states that it is appropriate,
passing them as arguments.
.PP
Constructors for the time objects may be called using
the \f(CW\*(C`new\*(C'\fR method of the corresponding Perl class.
For example,
.PP
.Vb 1
\&    my $recce = Marpa::R2::Thin::R\->new($grammar);
.Ve
.PP
Perl applications can destroy objects of the
Marpa thin classes 
by undefining them,
or by letting them go out of scope.
Application programmers do not need
to concern themselves
with the reference counting of Libmarpa objects.
The Marpa thin interface handles this.
.SH "The throw setting"
.IX Header "The throw setting"
One of the most important functions of
the Marpa thin interface
is to adapt Libmarpa's
error reporting to Perl.
Perl allows two kinds of error reporting.
Perl methods can communicate failure via their return values,
or they can throw exceptions.
.PP
Each has its place.
Throwing failure as an exception is the default in 
the Marpa thin interface because it is safer,
and because
it is convenient for prototyping and the first
cuts at a new application.
On the other hand, for Marpa thin
applications to have access
to the full flexibility and power of Libmarpa,
they must be able to set the Marpa thin
interface to return failure, instead of
throwing failure as an exception.
.PP
In choosing whether or not to throw a failure
as an exception,
almost every Marpa thin method obeys the throw
setting.
If the throw setting is 1, failure is thrown.
If the throw setting is 0, failure is returned.
.PP
The throw setting is 1 in newly created grammar
objects.
Once created, the throw setting of a grammar object
can be changed using the \f(CW\*(C`throw_set()\*(C'\fR
method
The throw setting of other objects is that
of their base grammar.
.PP
Nearly every Marpa thin method always obeys the throw setting.
Only three methods never obey the throw setting.
They are exceptions because their logic
controls the throw setting, so that a problem with them
suggests the throw setting itself may not be correct.
The methods which never obey the throw setting,
are
\&\f(CW\*(C`Marpa::R2::Thin::G\->new()\*(C'\fR,
\&\f(CW\*(C`throw_set()\*(C'\fR
and \f(CW\*(C`ruby_slippers_set()\*(C'\fR.
These methods throw all failures.
.PP
One method allows the throw setting to be overriden.
For convenience in using the Ruby Slippers technique,
the behavior of the \f(CW\*(C`alternative()\*(C'\fR
method
is also affected by a separate \*(L"Ruby Slippers\*(R" flag.
For details, see
the description of that
method.
.SH "Error codes, names and descriptions"
.IX Header "Error codes, names and descriptions"
Errors in the Marpa thin interface come from
two sources:
Libmarpa, and the Marpa thin interface itself.
These will be called Libmarpa errors
and thin interface errors, respectively.
.PP
Internally, Marpa maintains two variables to
track recent errors.
These are the error code and the error description.
For every defined error code,
there is an error name.
Together, the error code, the error name
and the error descriptions are called the
\&\*(L"error variables\*(R".
.PP
When the most recent error was a Libmarpa error,
the error code is the Libmarpa error code, as described
in the Libmarpa \s-1API\s0 document.
A Libmarpa error code is a non-negative integer.
When the most recent error was a thin interface
error, the error code is
a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
Libmarpa's integral error codes are rarely used directly,
either in C or in Perl.
In C, the error codes are referred to using macros.
The macro names are available through the thin interface
as error names.
For details see the section on error methods.
Thin interface errors do not have error names.
.PP
In addition to error names, there are error descriptions.
.IP "\(bu" 4
Error names are short mnemonics.
Error descriptions are typically longer.
.IP "\(bu" 4
Error names and error codes have a one to one correspondence (bijection).
For a given error code, the error name will always
be the same, and vice versa.
Error descriptions 
may contain text relating, not just to the error code,
but to the specific error instance.
.IP "\(bu" 4
The error name is defined if and
only if
the error code is defined.
Error descriptions always exist,
whether or not there is an error code defined.
.IP "\(bu" 4
A thin interface error
will always have an error description.
A thin interface error
will never have an error name.
.IP "\(bu" 4
The programmer may expect error codes and error names
to remain stable and may write code that relies
on the numeric value of the error codes
and the text of the error name.
Applications should treat the text of an error description
as suitable for the purpose of passing it on to a human user,
and should otherwise regard it as opaque.
.PP
Error descriptions, while typically longer than error names,
are intended for situations where
it is most convenient if they fit into a single line,
or at most two.
The Libmarpa \s-1API\s0 document contains a section on the Libmarpa
error codes.
and there the descriptions
are often longer and more detailed.
.PP
Error codes and error descriptions should be considered
valid
only if the most recently called Marpa thin method
indicated that it set the error code.
An application should assume that the
error codes and error descriptions will be overwritten by the
next call to 
any  thin interface method other than the \f(CW\*(C`error()\*(C'\fR
method.
.SS "Failure and the error variables"
.IX Subsection "Failure and the error variables"
A method indicates failure
either by throwing an exception
or by returning a value that indicates failure.
If a method follows the general pattern,
it indicates failure if and only if
its return value is less than or equal to \-2.
Other methods indicate failure as stated in
their descriptions in this document.
.PP
Whenever a method indicates failure, that also
indicates that it has set the error variables.
On Libmarpa failures, the error code is set to the
Libmarpa error code.
On thin interface failure, the error code is
set to a Perl \f(CW\*(C`undef\*(C'\fR.
For both Libmarpa and thin interface failures,
the error description is set to a text
that describes the error.
.SS "Success and the error variables"
.IX Subsection "Success and the error variables"
On success,
a method will take one of the following
three actions
with respect to the error variables:
.IP "Reset the error code" 4
.IX Item "Reset the error code"
A successful method
may set the error code to \f(CW\*(C`MARPA_ERR_NONE\*(C'\fR,
together with an error description that indicates
there is no error.
.IP "Leave the error code as is" 4
.IX Item "Leave the error code as is"
A successful method
may leave the error code and error
description as is.
.IP "Set an informational error code" 4
.IX Item "Set an informational error code"
A successful method may set a
Libmarpa error code to
a value other than \f(CW\*(C`MARPA_ERR_NONE\*(C'\fR.
Error codes of this kind are called
informational error codes.
The phrase \*(L"error code\*(R" in this context
is something of a misnomer.
Informational error codes exist
as a convenience for some applications,
but typically are ignored.
.PP
The Libmarpa \s-1API\s0 document sometimes specifies
what a Libmarpa method does with the error code
on success.
The Libmarpa \s-1API\s0 document always specifies
if and when a method sets an informational error code.
If Libmarpa \s-1API\s0 document is silent,
the application should regard it as unspecified
whether the error code is reset or left as is.
.SH "The general pattern"
.IX Header "The general pattern"
Most Marpa thin interface methods correspond directly
to a Libmarpa method,
and their behaviors are in most cases exactly the same.
These behaviors are called the \*(L"general pattern\*(R"
in this document.
To avoid repetition,
Marpa thin interface methods that follow
the general pattern exactly are
usually not
described explicitly in this document.
.SS "Method names"
.IX Subsection "Method names"
The name of a general pattern method is that of
its corresponding Libmarpa method,
minus the 8\-letter prefix which indicates
its Libmarpa class.
For example,
the Marpa thin interface method that
corresponds to \f(CW\*(C`marpa_g_start_symbol_set\*(C'\fR
is \f(CW\*(C`$g\->start_symbol_set()\*(C'\fR.
The class of the general pattern method
will be the Marpa thin class corresponding
to the time class
of the Libmarpa method.
For example, \f(CW\*(C`$g\->start_symbol_set()\*(C'\fR
will be in
the \f(CW\*(C`Marpa::R2::Thin:G\*(C'\fR Perl class.
.SS "Arguments"
.IX Subsection "Arguments"
Libmarpa's class instance methods
take an object of the their class
as their first (\*(L"self\*(R") argument.
Zero or more non-self arguments follow the self argument.
The arguments of the corresponding general pattern
Marpa thin method will be
the same, converted from C types to Perl as described next.
(This discussion follows
the convention used in perlobj,
and considers the \*(L"self\*(R" object to
be a Perl method's first argument.)
.PP
In the general pattern,
every argument whose type is one
of Libmarpa's time classes is converted
to the corresponding Marpa thin interface class.
Arguments which belong to Libmarpa's numbered 
classes (\f(CW\*(C`Marpa_Earley_Set_ID\*(C'\fR,
\&\f(CW\*(C`Marpa_Rank\*(C'\fR,
\&\f(CW\*(C`Marpa_Rule_ID\*(C'\fR and \f(CW\*(C`Marpa_Symbol_ID\*(C'\fR)
are converted to Perl scalar integers.
C language \f(CW\*(C`int\*(C'\fR's are also
converted to Perl scalar integers.
.PP
The Marpa thin interface does
not recognize booleans, either in 
C or in Perl.
For example,
if a Perl true value is not a numeric
1, it will not be converted to a numeric
1 in C, even in a situation where
the Libmarpa method is clearly
looking for a boolean.
The intent is to allow for future extensions
to the Libmarpa interface that
accept and interpret other numeric values.
.SS "Return values"
.IX Subsection "Return values"
In the general pattern,
the return value from a Libmarpa method
will always either
belong to
one of Libmarpa's numbered classes,
or be a C language \f(CW\*(C`int\*(C'\fR.
If the Libmarpa return value is a non-negative
integer,
the corresponding general pattern Marpa thin method
will return a numeric Perl scalar.
If the Libmarpa method returns \-1,
its corresponding general pattern Marpa thin method
will return a Perl \f(CW\*(C`undef\*(C'\fR.
.SS "General pattern failures"
.IX Subsection "General pattern failures"
General pattern methods consider failure to be
a Libmarpa return value of \-2 or less.
Failure is thrown if the throw setting is 1.
On unthrown failure, the return value
of the Libmarpa method will
be returned by the Marpa thin
method as a numeric Perl scalar.
.SS "An example of a general pattern method"
.IX Subsection "An example of a general pattern method"
Here is an example of a Libmarpa function
whose corresponding Marpa thin method follows the
general pattern.
.PP
.Vb 1
\&  marpa_g_start_symbol_set (grammar, symbol_S);
.Ve
.PP
and here is the corresonding thin Marpa call:
.PP
.Vb 1
\&    $grammar\->start_symbol_set($symbol_S);
.Ve
.SH "Error methods"
.IX Header "Error methods"
The thin interface to Libmarpa provides
error methods
more appropriate to the Perl
environment
than Libmarpa's own.
.ie n .SS """$g\->error()"""
.el .SS "\f(CW$g\->error()\fP"
.IX Subsection "$g->error()"
.Vb 3
\&    my ( $error_code, $error_description ) = $grammar\->error();
\&    my @error_names = Marpa::R2::Thin::error_names();
\&    my $error_name = $error_names[$error_code];
.Ve
.PP
In scalar context,
the \f(CW\*(C`error()\*(C'\fR method returns the error description.
In array context, it returns a 2\-element array.
The first element of the array is the error code,
and the second element is the error description.
Applications should assume that
a call to any other Marpa thin method
will overwrite the error code and error description.
For \f(CW\*(C`error()\*(C'\fR to successfully query
the error code or error description of a method,
\&\f(CW\*(C`error()\*(C'\fR should be
the next Marpa thin interface method called.
.ie n .SS """$g\->error_clear()"""
.el .SS "\f(CW$g\->error_clear()\fP"
.IX Subsection "$g->error_clear()"
The \f(CW\*(C`error_clear()\*(C'\fR method follows the general pattern.
.ie n .SS """$g\->error_names()"""
.el .SS "\f(CW$g\->error_names()\fP"
.IX Subsection "$g->error_names()"
For a synopsis, see the section on
the \f(CW\*(C`$g\->error()\*(C'\fR
method.
The \f(CW\*(C`error_names()\*(C'\fR method returns a
\&\fBreference\fR to an array of error names,
indexed by Libmarpa error code.
.ie n .SS """$g\->throw_set()"""
.el .SS "\f(CW$g\->throw_set()\fP"
.IX Subsection "$g->throw_set()"
.Vb 1
\&    $grammar\->throw_set(0);
.Ve
.PP
The \f(CW\*(C`throw_set()\*(C'\fR method turns the throw flag
for the grammar on or off,
according to whether its argument is 1 or 0.
\&\f(CW\*(C`throw_set()\*(C'\fR fails if its argument is
not a numeric 0 or 1.
\&\f(CW\*(C`throw_set()\*(C'\fR itself never returns failure \*(--
it always throws an exception.
.SS "Omitted configuration methods"
.IX Subsection "Omitted configuration methods"
All of the methods of Libmarpa's configuration
class are omitted in the Marpa thin interface.
The functions performed by Libmarpa's configuration
methods are handled in a more Perl-centric way
by the Marpa thin interface.
.SH "Grammar methods"
.IX Header "Grammar methods"
.ie n .SS """Marpa::R2::Thin::G\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::G\->new()\fP"
.IX Subsection "Marpa::R2::Thin::G->new()"
.Vb 1
\&    my $grammar = Marpa::R2::Thin::G\->new( { if => 1 } );
.Ve
.PP
The one argument to the Marpa thin interface's
grammar constructor,
is a reference to a hash of named arguments.
On success,
the return value is a thin interface grammar object.
\&\f(CW\*(C`new()\*(C'\fR does not obey the throw setting \*(--
errors are always thrown.
.PP
At present the only named argument allowed is \f(CW\*(C`if\*(C'\fR,
the interface number.
This argument is required and currently is required
to have a value of 1,
which specifies interface 1.
The intent of the \f(CW\*(C`if\*(C'\fR argument is to provide
for backward compatibility in the future.
.PP
Although there is no error message or warning if the hash
ref argument
is omitted, new code should treat
the hash ref argument as a required argument.
Calling \f(CW\*(C`new()\*(C'\fR without an argument is deprecated.
If the hash ref argument is omitted, the thin
layer uses interface 0.
Interface 0 cannot be specified directly,
and is deprecated.
The difference between interface 0 and interface 1
is that, in interface 0, the default throw setting
of the newly created grammar object
is unspecified.
(In fact, the interface 0 throw setting depends on an
undocumented and deprecated global variable.)
.ie n .SS """$g\->event()"""
.el .SS "\f(CW$g\->event()\fP"
.IX Subsection "$g->event()"
.Vb 1
\&    my ( $event_type, $value ) = $grammar\->event( $event_ix++ );
.Ve
.PP
The \f(CW\*(C`event()\*(C'\fR method returns a two-element array on success.
The first element is a string naming the event type,
and the second is a scalar representing its value.
The string for an event type is its macro name,
as given in the Libmarpa \s-1API\s0 document.
.PP
Some event types have an event \*(L"value\*(R".
All event values are numeric Perl scalars.
The number is either a symbol \s-1ID\s0 or a count,
as described in the Libmarpa \s-1API\s0 document.
.PP
The permissible range of event indexes can be
found with the Marpa thin interface's \f(CW\*(C`event_count()\*(C'\fR
grammar method,
which corresponds to Libmarpa's
\&\f(CW\*(C`marpa_g_event_count()\*(C'\fR method.
The thin interface's \f(CW\*(C`event_count()\*(C'\fR method 
follows the general pattern.
.PP
Since \f(CW\*(C`event()\*(C'\fR returns the event value whenever it
exists,
the Libmarpa \f(CW\*(C`marpa_g_event_value()\*(C'\fR method is
unneeded.
The Libmarpa \f(CW\*(C`marpa_g_event_value()\*(C'\fR method has
no corresponding Marpa thin interface method.
.PP
\&\f(CW\*(C`event()\*(C'\fR obeys the throw setting.
On unthrown failure, \f(CW\*(C`event()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """$g\->rule_new()"""
.el .SS "\f(CW$g\->rule_new()\fP"
.IX Subsection "$g->rule_new()"
.Vb 1
\&    my $start_rule_id = $grammar\->rule_new( $symbol_S, [$symbol_E] );
.Ve
.PP
The \f(CW\*(C`rule_new()\*(C'\fR grammar method is
the Libmarpa thin interface method corresponding
to the \f(CW\*(C`marpa_g_rule_new()\*(C'\fR method.
It takes two arguments, both required.
The first argument is a symbol \s-1ID\s0 representing the
rule's \s-1LHS,\s0
and the second argument is a reference to an
array of symbol \s-1ID\s0's.
The symbol \s-1ID\s0's in the array represent the \s-1RHS.\s0
On success,
the return value is the \s-1ID\s0 of the new rule.
.PP
\&\f(CW\*(C`rule_new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns \-2.
.ie n .SS """$g\->sequence_new()"""
.el .SS "\f(CW$g\->sequence_new()\fP"
.IX Subsection "$g->sequence_new()"
.Vb 8
\&    my $sequence_rule_id = $grammar\->sequence_new(
\&            $symbol_S,
\&            $symbol_a,
\&            {   separator => $symbol_sep,
\&                proper    => 0,
\&                min       => 1
\&            }
\&        );
.Ve
.PP
The \f(CW\*(C`sequence_new()\*(C'\fR grammar method is
the Libmarpa thin interface method corresponding
to the \f(CW\*(C`marpa_g_sequence_new()\*(C'\fR method.
It takes three arguments, all required.
The first argument is a symbol \s-1ID\s0 representing the
sequence's \s-1LHS.\s0
The second argument is a symbol \s-1ID\s0 representing the
sequence's \s-1RHS.\s0
The third argument is a reference to a hash of named
arguments.
.PP
The hash of named arguments may be empty.
If not empty, its keys, and their values,
must be one of the following:
.ie n .IP """separator""" 4
.el .IP "\f(CWseparator\fR" 4
.IX Item "separator"
The value of the \f(CW\*(C`separator\*(C'\fR named argument
will be treated as an integer,
and passed as the separator \s-1ID\s0 argument
to the \f(CW\*(C`marpa_g_sequence_new()\*(C'\fR method.
It defaults to \-1.
.ie n .IP """proper""" 4
.el .IP "\f(CWproper\fR" 4
.IX Item "proper"
If the value of \f(CW\*(C`proper\*(C'\fR named argument
is a Perl true value,
the \f(CW\*(C`MARPA_PROPER_SEPARATION\*(C'\fR flag
will be set in the flags passed
to the \f(CW\*(C`marpa_g_sequence_new()\*(C'\fR method.
Otherwise, 
the \f(CW\*(C`MARPA_PROPER_SEPARATION\*(C'\fR flag
will not be set.
.ie n .IP """min""" 4
.el .IP "\f(CWmin\fR" 4
.IX Item "min"
The value of the \f(CW\*(C`min\*(C'\fR named argument
will be treated as an integer,
and passed as the \f(CW\*(C`min\*(C'\fR argument
to the \f(CW\*(C`marpa_g_sequence_new()\*(C'\fR method.
The \f(CW\*(C`min\*(C'\fR argument indicates the minimum number of
repetitions of the sequence that are required.
It defaults to 1.
.PP
On success,
the return value is
the rule \s-1ID\s0 of the new sequence.
.PP
Users should be aware that all sequences at
the Marpa thin interface level are \*(L"keep
separation\*(R".
This differs from the higher-level interface,
which discards separators by default.
At the 
Marpa thin interface level, it is up
to the programmer to discard separators,
if that is what is wanted.
.PP
\&\f(CW\*(C`sequence_new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns \-2.
.ie n .SS """$g\->precompute()"""
.el .SS "\f(CW$g\->precompute()\fP"
.IX Subsection "$g->precompute()"
.Vb 1
\&    $grammar\->precompute();
.Ve
.PP
The \f(CW\*(C`precompute()\*(C'\fR method follows the general pattern.
In addition to errors,
\&\f(CW\*(C`precompute()\*(C'\fR also reports events.
Events are queried using the grammar's
\&\f(CW\*(C`event()\*(C'\fR method.
.PP
On success, \f(CW\*(C`precompute()\*(C'\fR returns an event count.
But, even when there is an error,
\&\f(CW\*(C`precompute()\*(C'\fR often reports
one or more events.
It is not safe to assume that no events occurred
unless \f(CW\*(C`precompute()\*(C'\fR succeeds and reports
an event count of zero.
.ie n .SS """$g\->rule_rank()"""
.el .SS "\f(CW$g\->rule_rank()\fP"
.IX Subsection "$g->rule_rank()"
The \f(CW\*(C`rule_rank()\*(C'\fR method is based on
Libmarpa's \f(CW\*(C`marpa_g_rule_rank()\*(C'\fR method.
Its argument is the rule \s-1ID,\s0
and its return value is the rank,
or a \-2 to indicate an unthrown error.
.PP
Note a return value of \-2 is ambiguous \*(-- it can
indicate that the rank was \-2, or that a failure
occurred.
To distinguish the cases, the application can
look at the error code.
The error code
will be \f(CW\*(C`MARPA_ERR_NONE\*(C'\fR if and only
if the call was successful.
The error code can be found using the \f(CW\*(C`error()\*(C'\fR
method.
Applications may find it more convenient to have
\&\f(CW\*(C`rule_rank()\*(C'\fR always throw its errors.
.ie n .SS """$g\->rule_rank_set()"""
.el .SS "\f(CW$g\->rule_rank_set()\fP"
.IX Subsection "$g->rule_rank_set()"
The \f(CW\*(C`rule_rank_set()\*(C'\fR method is based on
Libmarpa's \f(CW\*(C`marpa_g_rule_rank_set()\*(C'\fR method.
Its two arguments are the rule \s-1ID\s0 and a rule rank.
Its return value is the new value of the rank,
or a \-2 to indicate an unthrown error.
.PP
Note a return value of \-2 is ambiguous \*(-- it can
indicate that the rank was \-2, or that a failure
occurred.
To distinguish the cases, the application can
look at the error code.
The error code
will be \f(CW\*(C`MARPA_ERR_NONE\*(C'\fR if and only
if the call was successful.
The error code can be found using the \f(CW\*(C`error()\*(C'\fR
method.
Applications may find it more convenient to have
\&\f(CW\*(C`rule_rank_set()\*(C'\fR always throw its errors.
.SS "Omitted grammar methods"
.IX Subsection "Omitted grammar methods"
The \f(CW\*(C`marpa_g_ref()\*(C'\fR
and \f(CW\*(C`marpa_g_unref()\*(C'\fR methods are omitted
because the Marpa thin interface performs
their function.
The \f(CW\*(C`marpa_g_event_value()\*(C'\fR method is omitted
because its function is absorbed into
the thin interface's \f(CW\*(C`event()\*(C'\fR grammar method.
.SS "General pattern methods"
.IX Subsection "General pattern methods"
All grammar methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Recognizer methods"
.IX Header "Recognizer methods"
.ie n .SS """Marpa::R2::Thin::R\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::R\->new()\fP"
.IX Subsection "Marpa::R2::Thin::R->new()"
.Vb 1
\&    my $recce = Marpa::R2::Thin::R\->new($grammar);
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method takes a Marpa thin grammar object
as its one argument.
On success, it returns a Marpa thin recognizer object.
\&\f(CW\*(C`new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """$r\->ruby_slippers_set()"""
.el .SS "\f(CW$r\->ruby_slippers_set()\fP"
.IX Subsection "$r->ruby_slippers_set()"
.Vb 1
\&    $recce\->ruby_slippers_set(1);
.Ve
.PP
With an argument of 1,
the \f(CW\*(C`ruby_slippers_set()\*(C'\fR method enables \*(L"Ruby Slippers\*(R" mode.
An argument of 0 disables \*(L"Ruby Slippers\*(R" mode.
By default, 
Ruby Slippers mode is disabled.
Note that this default (disabled) is
the opposite of that in the higher level Marpa::R2 interface.
.PP
The \f(CW\*(C`alternative()\*(C'\fR
method
will only throw exceptions when 
\&\*(L"Ruby Slippers\*(R" mode is disabled and the throw flag is on.
One way of describing Ruby Slippers mode is as
an override of the throw setting, one which only applies
to the \f(CW\*(C`alternative()\*(C'\fR method.
.PP
The \f(CW\*(C`ruby_slippers_set()\*(C'\fR method itself does \fBnot\fR
obey the throw setting.
All failures by \f(CW\*(C`ruby_slippers_set()\*(C'\fR are thrown
as exceptions.
.ie n .SS """$r\->alternative()"""
.el .SS "\f(CW$r\->alternative()\fP"
.IX Subsection "$r->alternative()"
.Vb 1
\&    $recce\->alternative( $symbol_number, 2, 1 );
.Ve
.PP
In the Libmarpa \s-1API\s0
the
\&\f(CW\*(C`alternative()\*(C'\fR method returns an error
code,
with 
\&\f(CW\*(C`MARPA_ERR_NONE\*(C'\fR being the code returned if there
was no error.
The \f(CW\*(C`alternative()\*(C'\fR method will
throw the error code as an
exception if and only if all three 
of the following are true:
.IP "\(bu" 4
The base grammar's throw flag is on.
.IP "\(bu" 4
The Ruby Slippers flag is off.
.IP "\(bu" 4
The error code is not \f(CW\*(C`MARPA_ERR_NONE\*(C'\fR.
.PP
Of major interest is the error code
\&\f(CW\*(C`MARPA_ERR_UNEXPECTED_TOKEN_ID\*(C'\fR,
which indicates that a token was not accepted because
its token \s-1ID\s0 was not one of those expected.
Catching and recovering
from this error is the basis of the Ruby Slippers parsing
technique.
For more on the Ruby Slippers flag,
see \f(CW\*(C`ruby_slippers_set()\*(C'\fR.
.ie n .SS """$r\->terminals_expected()"""
.el .SS "\f(CW$r\->terminals_expected()\fP"
.IX Subsection "$r->terminals_expected()"
.Vb 1
\&    my @terminals = $recce\->terminals_expected();
.Ve
.PP
The \f(CW\*(C`terminals_expected()\*(C'\fR method takes no arguments.
On success, it returns an array containing the
symbol \s-1ID\s0's of the expected terminals.
Note that the array of expected terminal \s-1ID\s0's may
be empty, so that an empty array is \s-1NOT\s0 a failure
indicator.
\&\f(CW\*(C`terminals_expected()\*(C'\fR obeys the throw setting.
On unthrown failure,
\&\f(CW\*(C`terminals_expected()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """$r\->progress_item()"""
.el .SS "\f(CW$r\->progress_item()\fP"
.IX Subsection "$r->progress_item()"
.Vb 8
\&    my $ordinal = $recce\->latest_earley_set();
\&    $recce\->progress_report_start($ordinal);
\&    ITEM: while (1) {
\&        my ($rule_id, $dot_position, $origin) = $recce\->progress_item();
\&        last ITEM if not defined $rule_id;
\&        push @{$report}, [$rule_id, $dot_position, $origin];
\&    }
\&    $recce\->progress_report_finish();
.Ve
.PP
The \f(CW\*(C`progress_item()\*(C'\fR method takes no arguments.
On success, it returns an array of 3 elements:
the rule \s-1ID,\s0 the dot position, and the earley set \s-1ID\s0
of the origin.
If there are no more items,
\&\f(CW\*(C`progress_item()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
\&\f(CW\*(C`progress_item()\*(C'\fR obeys the throw setting.
On unthrown failure,
the rule \s-1ID\s0 element in the array returned by
\&\f(CW\*(C`progress_item()\*(C'\fR will have a value of \-2.
.SS "Omitted recognizer methods"
.IX Subsection "Omitted recognizer methods"
Because the Marpa thin interface 
handles reference counting internally,
it does not implement methods
directly corresponding to
Libmarpa's \f(CW\*(C`marpa_r_ref()\*(C'\fR
and \f(CW\*(C`marpa_r_unref()\*(C'\fR methods.
.PP
There are Marpa thin methods
corresponding to
Libmarpa's \f(CW\*(C`marpa_r_earley_set_value()\*(C'\fR
and \f(CW\*(C`marpa_r_earley_set_value_set()\*(C'\fR methods,
but not to
Libmarpa's \f(CW\*(C`marpa_r_earley_set_values()\*(C'\fR
and \f(CW\*(C`marpa_r_earley_set_values_set()\*(C'\fR methods.
The difference between these is that the \*(L"values\*(R" form allows an
integer and a pointer value to be set,
while 
the \*(L"value\*(R" form allows only an integer to be set.
Perl applications which want to associate non-integer data with an Earley set
should create an array, and use the integer to index the array.
The elements of the array can contain arbitrary data.
.PP
The thin interface does not implement a way to set the Earley set pointer
value, because to do so would not add value.
The thin interface would have to track the reference
count of a pointer,
and this can done as easily and efficiently,
and with more flexibility, at the Perl level.
.SS "Methods not mentioned"
.IX Subsection "Methods not mentioned"
All recognizer methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Bocage methods"
.IX Header "Bocage methods"
.ie n .SS """Marpa::R2::Thin::B\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::B\->new()\fP"
.IX Subsection "Marpa::R2::Thin::B->new()"
.Vb 2
\&    my $latest_earley_set_ID = $recce\->latest_earley_set();
\&    my $bocage = Marpa::R2::Thin::B\->new( $recce, $latest_earley_set_ID );
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method takes a Marpa thin recognizer object
as its one argument.
On success, it returns a Marpa thin bocage object.
\&\f(CW\*(C`new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns a Perl \f(CW\*(C`undef\*(C'\fR.
.SS "Omitted bocage methods"
.IX Subsection "Omitted bocage methods"
Because the Marpa thin interface 
handles reference counting internally,
it does not implement methods
directly corresponding to
Libmarpa's \f(CW\*(C`marpa_b_ref()\*(C'\fR
and \f(CW\*(C`marpa_b_unref()\*(C'\fR methods.
.SS "Methods not mentioned"
.IX Subsection "Methods not mentioned"
All bocage methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Ordering methods"
.IX Header "Ordering methods"
.ie n .SS """Marpa::R2::Thin::O\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::O\->new()\fP"
.IX Subsection "Marpa::R2::Thin::O->new()"
.Vb 1
\&    my $order = Marpa::R2::Thin::O\->new($bocage);
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method takes a Marpa thin bocage object
as its one argument.
On success, it returns a Marpa thin ordering object.
\&\f(CW\*(C`new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns a Perl \f(CW\*(C`undef\*(C'\fR.
.SS "Omitted ordering methods"
.IX Subsection "Omitted ordering methods"
Because the Marpa thin interface 
handles reference counting internally,
it does not implement methods
directly corresponding to
Libmarpa's \f(CW\*(C`marpa_o_ref()\*(C'\fR
and \f(CW\*(C`marpa_o_unref()\*(C'\fR methods.
.SS "Methods not mentioned"
.IX Subsection "Methods not mentioned"
All ordering methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Tree methods"
.IX Header "Tree methods"
.ie n .SS """Marpa::R2::Thin::T\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::T\->new()\fP"
.IX Subsection "Marpa::R2::Thin::T->new()"
.Vb 1
\&    my $tree = Marpa::R2::Thin::T\->new($order);
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method takes a Marpa thin ordering object
as its one argument.
On success, it returns a Marpa thin tree object.
\&\f(CW\*(C`new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns a Perl \f(CW\*(C`undef\*(C'\fR.
.SS "Omitted tree methods"
.IX Subsection "Omitted tree methods"
Because the Marpa thin interface 
handles reference counting internally,
it does not implement methods
directly corresponding to
Libmarpa's \f(CW\*(C`marpa_t_ref()\*(C'\fR
and \f(CW\*(C`marpa_t_unref()\*(C'\fR methods.
.SS "Methods not mentioned"
.IX Subsection "Methods not mentioned"
All tree methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Value methods"
.IX Header "Value methods"
.ie n .SS """Marpa::R2::Thin::V\->new()"""
.el .SS "\f(CWMarpa::R2::Thin::V\->new()\fP"
.IX Subsection "Marpa::R2::Thin::V->new()"
.Vb 1
\&    my $valuator = Marpa::R2::Thin::V\->new($tree);
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method takes a Marpa thin tree object
as its one argument.
On success, it returns a Marpa thin value object.
\&\f(CW\*(C`new()\*(C'\fR obeys the throw setting.
On unthrown failure, it returns a Perl \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """$v\->location()"""
.el .SS "\f(CW$v\->location()\fP"
.IX Subsection "$v->location()"
.Vb 10
\&    $type = $valuator\->step_type();
\&    my ( $start, $end ) = $valuator\->location();
\&    if ( $type eq \*(AqMARPA_STEP_RULE\*(Aq ) {
\&        my ($rule_id) = @step_data;
\&        $locations_report .= "Rule $rule_id is from $start to $end\en";
\&    }
\&    if ( $type eq \*(AqMARPA_STEP_TOKEN\*(Aq ) {
\&        my ($token_id) = @step_data;
\&        $locations_report .= "Token $token_id is from $start to $end\en";
\&    }
\&    if ( $type eq \*(AqMARPA_STEP_NULLING_SYMBOL\*(Aq ) {
\&        my ($symbol_id) = @step_data;
\&        $locations_report
\&            .= "Nulling symbol $symbol_id is from $start to $end\en";
\&    }
.Ve
.PP
The \f(CW\*(C`location()\*(C'\fR method takes no arguments.
The \f(CW\*(C`location()\*(C'\fR method always succeeds,
returning either an empty array
or an array of two elements.
.IP "\(bu" 4
If the last step was \f(CW\*(C`MARPA_STEP_RULE\*(C'\fR,
the array contains the locations where the rule starts
and ends,
as returned
by the Libmarpa methods \f(CW\*(C`marpa_v_rule_start_es_id()\*(C'\fR
and \f(CW\*(C`marpa_v_es_id()\*(C'\fR.
.IP "\(bu" 4
It the last step was \f(CW\*(C`MARPA_STEP_TOKEN\*(C'\fR,
the array contains the locations where the token starts
and ends,
as returned
by the Libmarpa methods \f(CW\*(C`marpa_v_token_start_es_id()\*(C'\fR
and \f(CW\*(C`marpa_v_es_id()\*(C'\fR.
.IP "\(bu" 4
It the last step was \f(CW\*(C`MARPA_STEP_NULLING_SYMBOL\*(C'\fR,
the array contains the locations where the token starts
and ends,
as returned
by the Libmarpa methods \f(CW\*(C`marpa_v_token_start_es_id()\*(C'\fR
and \f(CW\*(C`marpa_v_es_id()\*(C'\fR.
.IP "\(bu" 4
In any other case,
the array is empty.
.ie n .SS """$v\->step()"""
.el .SS "\f(CW$v\->step()\fP"
.IX Subsection "$v->step()"
.Vb 1
\&    my ( $type, @step_data ) = $valuator\->step();
.Ve
.PP
The \f(CW\*(C`step()\*(C'\fR method takes no arguments.
On success, \f(CW\*(C`step()\*(C'\fR
returns an array, whose contents are as follows:
.ie n .IP """MARPA_STEP_RULE""" 4
.el .IP "\f(CWMARPA_STEP_RULE\fR" 4
.IX Item "MARPA_STEP_RULE"
If the step type is \f(CW\*(C`MARPA_STEP_RULE\*(C'\fR, \f(CW\*(C`step()\*(C'\fR
returns an array of 4 elements.  These will be,
in order:
.RS 4
.IP "\(bu" 4
The string "\f(CW\*(C`MARPA_STEP_RULE\*(C'\fR".
.IP "\(bu" 4
The rule id, as returned
by the Libmarpa method \f(CW\*(C`marpa_v_rule_id()\*(C'\fR.
.IP "\(bu" 4
The stack location where the child values
of the rule begin,
as returned
by the Libmarpa method \f(CW\*(C`marpa_v_token_arg_0()\*(C'\fR.
This is also the stack location to which the result
should be written.
.IP "\(bu" 4
The stack location where the child values
of the rule end,
as returned
by the Libmarpa method \f(CW\*(C`marpa_v_token_arg_n()\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """MARPA_STEP_TOKEN""" 4
.el .IP "\f(CWMARPA_STEP_TOKEN\fR" 4
.IX Item "MARPA_STEP_TOKEN"
If the step type is \f(CW\*(C`MARPA_STEP_TOKEN\*(C'\fR, \f(CW\*(C`step()\*(C'\fR
returns an array of 4 elements.  These will be,
in order:
.RS 4
.IP "\(bu" 4
The string "\f(CW\*(C`MARPA_STEP_TOKEN\*(C'\fR".
.IP "\(bu" 4
The token id, as returned
by the Libmarpa method \f(CW\*(C`marpa_v_token()\*(C'\fR.
.IP "\(bu" 4
The token value, as returned
by the Libmarpa method \f(CW\*(C`marpa_v_token_value()\*(C'\fR.
.IP "\(bu" 4
The stack location to which the token's
value should be written,
as returned
by the Libmarpa method \f(CW\*(C`marpa_v_result()\*(C'\fR.
.RE
.RS 4
.Sp
As a reminder, Libmarpa's token values are always integers.
Applications will often have a richer or different
semantics for token values.
One approach such applications can take is
to use
Libmarpa's token values as indexes into an array.
.RE
.ie n .IP """MARPA_STEP_NULLING_SYMBOL""" 4
.el .IP "\f(CWMARPA_STEP_NULLING_SYMBOL\fR" 4
.IX Item "MARPA_STEP_NULLING_SYMBOL"
If the step type is \f(CW\*(C`MARPA_STEP_NULLING_SYMBOL\*(C'\fR, \f(CW\*(C`step()\*(C'\fR
returns an array of 3 elements.  These will be,
in order:
.RS 4
.IP "\(bu" 4
The string "\f(CW\*(C`MARPA_STEP_NULLING_SYMBOL\*(C'\fR".
.IP "\(bu" 4
The \s-1ID\s0 of the nulling symbol, as returned
by the Libmarpa method \f(CW\*(C`marpa_v_symbol()\*(C'\fR.
.IP "\(bu" 4
The stack location to which the nulling
symbol's value should be written,
as returned
by the Libmarpa method \f(CW\*(C`marpa_v_result()\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """MARPA_STEP_INACTIVE""" 4
.el .IP "\f(CWMARPA_STEP_INACTIVE\fR" 4
.IX Item "MARPA_STEP_INACTIVE"
If the step type is \f(CW\*(C`MARPA_STEP_INACTIVE\*(C'\fR, \f(CW\*(C`step()\*(C'\fR returns
an empty array.
.PP
\&\f(CW\*(C`step()\*(C'\fR obeys the throw setting.
On unthrown failure,
\&\f(CW\*(C`step()\*(C'\fR returns an array whose only
element is a
string not reserved by Libmarpa.
A string is not reserved by Libmarpa if it does
not begin with "\f(CW\*(C`MARPA_\*(C'\fR" in one of its
capitalization variants.
The string will usually be a description of the error.
.ie n .SS """$v\->step_type()"""
.el .SS "\f(CW$v\->step_type()\fP"
.IX Subsection "$v->step_type()"
.Vb 1
\&    $type = $valuator\->step_type();
.Ve
.PP
The \f(CW\*(C`step_type()\*(C'\fR method takes no arguments.
On success, \f(CW\*(C`step_type()\*(C'\fR
returns the string indicating the type of the last
Libmarpa valuator step.
If the last call of the
\&\f(CW\*(C`step()\*(C'\fR
method succeeded,
the string returned by \f(CW\*(C`step_type()\*(C'\fR will
be the same as the one that was the first
element of the array returned by \f(CW\*(C`step()\*(C'\fR.
.PP
\&\f(CW\*(C`step_type()\*(C'\fR obeys the throw setting.
On unthrown failure,
\&\f(CW\*(C`step()\*(C'\fR returns an array whose only
element is a
string not reserved by Libmarpa.
A string is not reserved by Libmarpa if it does
not begin with "\f(CW\*(C`MARPA_\*(C'\fR" in one of its
capitalization variants.
The string will usually be a description of the error.
.SS "Omitted value methods"
.IX Subsection "Omitted value methods"
Because the Marpa thin interface 
handles reference counting internally,
it does not implement methods
directly corresponding to
Libmarpa's \f(CW\*(C`marpa_v_ref()\*(C'\fR
and \f(CW\*(C`marpa_v_unref()\*(C'\fR methods.
The step accessor macros are folded into the thin interface's
\&\f(CW\*(C`$v\->step()\*(C'\fR
and \f(CW\*(C`$v\->location()\*(C'\fR
methods.
For this reason,
no thin interface macro corresponds directly to most
of the individual step accessors.
.SS "Methods not mentioned"
.IX Subsection "Methods not mentioned"
All value methods that are part of the Libmarpa external interface,
but that are not mentioned explicitly in this document,
are implemented
following the general pattern, as described
above.
.SH "Example"
.IX Header "Example"
.Vb 12
\&    my $grammar = Marpa::R2::Thin::G\->new( { if => 1 } );
\&    $grammar\->force_valued();
\&    my $symbol_S = $grammar\->symbol_new();
\&    my $symbol_E = $grammar\->symbol_new();
\&    $grammar\->start_symbol_set($symbol_S);
\&    my $symbol_op     = $grammar\->symbol_new();
\&    my $symbol_number = $grammar\->symbol_new();
\&    my $start_rule_id = $grammar\->rule_new( $symbol_S, [$symbol_E] );
\&    my $op_rule_id =
\&        $grammar\->rule_new( $symbol_E, [ $symbol_E, $symbol_op, $symbol_E ] );
\&    my $number_rule_id = $grammar\->rule_new( $symbol_E, [$symbol_number] );
\&    $grammar\->precompute();
\&
\&    my $recce = Marpa::R2::Thin::R\->new($grammar);
\&    $recce\->start_input();
\&
\&    # The numbers from 1 to 3 are themselves \-\-
\&    # that is, they index their own token value.
\&    # Important: zero cannot be itself!
\&
\&    my @token_values         = ( 0 .. 3 );
\&    my $zero                 = \-1 + push @token_values, 0;
\&    my $minus_token_value    = \-1 + push @token_values, q{\-};
\&    my $plus_token_value     = \-1 + push @token_values, q{+};
\&    my $multiply_token_value = \-1 + push @token_values, q{*};
\&
\&    $recce\->alternative( $symbol_number, 2, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_op, $minus_token_value, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_number, $zero, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_op, $multiply_token_value, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_number, 3, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_op, $plus_token_value, 1 );
\&    $recce\->earleme_complete();
\&    $recce\->alternative( $symbol_number, 1, 1 );
\&    $recce\->earleme_complete();
\&
\&    my $latest_earley_set_ID = $recce\->latest_earley_set();
\&    my $bocage        = Marpa::R2::Thin::B\->new( $recce, $latest_earley_set_ID );
\&    my $order         = Marpa::R2::Thin::O\->new($bocage);
\&    my $tree          = Marpa::R2::Thin::T\->new($order);
\&    my @actual_values = ();
\&    while ( $tree\->next() ) {
\&        my $valuator = Marpa::R2::Thin::V\->new($tree);
\&        my @stack = ();
\&        STEP: while ( 1 ) {
\&            my ( $type, @step_data ) = $valuator\->step();
\&            last STEP if not defined $type;
\&            if ( $type eq \*(AqMARPA_STEP_TOKEN\*(Aq ) {
\&                my ( undef, $token_value_ix, $arg_n ) = @step_data;
\&                $stack[$arg_n] = $token_values[$token_value_ix];
\&                next STEP;
\&            }
\&            if ( $type eq \*(AqMARPA_STEP_RULE\*(Aq ) {
\&                my ( $rule_id, $arg_0, $arg_n ) = @step_data;
\&                if ( $rule_id == $start_rule_id ) {
\&                    my ( $string, $value ) = @{ $stack[$arg_n] };
\&                    $stack[$arg_0] = "$string == $value";
\&                    next STEP;
\&                }
\&                if ( $rule_id == $number_rule_id ) {
\&                    my $number = $stack[$arg_0];
\&                    $stack[$arg_0] = [ $number, $number ];
\&                    next STEP;
\&                }
\&                if ( $rule_id == $op_rule_id ) {
\&                    my $op = $stack[ $arg_0 + 1 ];
\&                    my ( $right_string, $right_value ) = @{ $stack[$arg_n] };
\&                    my ( $left_string,  $left_value )  = @{ $stack[$arg_0] };
\&                    my $value;
\&                    my $text = \*(Aq(\*(Aq . $left_string . $op . $right_string . \*(Aq)\*(Aq;
\&                    if ( $op eq q{+} ) {
\&                        $stack[$arg_0] = [ $text, $left_value + $right_value ];
\&                        next STEP;
\&                    }
\&                    if ( $op eq q{\-} ) {
\&                        $stack[$arg_0] = [ $text, $left_value \- $right_value ];
\&                        next STEP;
\&                    }
\&                    if ( $op eq q{*} ) {
\&                        $stack[$arg_0] = [ $text, $left_value * $right_value ];
\&                        next STEP;
\&                    }
\&                    die "Unknown op: $op";
\&                } ## end if ( $rule_id == $op_rule_id )
\&                die "Unknown rule $rule_id";
\&            } ## end if ( $type eq \*(AqMARPA_STEP_RULE\*(Aq )
\&            die "Unexpected step type: $type";
\&        } ## end while ( my ( $type, @step_data ) = $valuator\->step() )
\&        push @actual_values, $stack[0];
\&    } ## end while ( $tree\->next() )
.Ve
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
