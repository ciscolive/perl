.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Group::Tester 3"
.TH Test::Group::Tester 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Group::Tester \- Test Test::Group extensions
.SH "VERSION"
.IX Header "VERSION"
Test::Group::Tester version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Test::More tests => 1;
\&  use Test::Group::Tester;
\&
\&  testscript_ok(\*(Aq#line \*(Aq.(_\|_LINE_\|_+1)."\en".<<\*(AqEOSCRIPT\*(Aq, 3);
\&
\&    use Test::More;
\&    use Test::Group;
\&
\&    # Test a passing test group
\&    want_test(\*(Aqpass\*(Aq, "this_should_pass");
\&    test this_should_pass => sub {
\&        ok 1, "1 is true";
\&        ok 2, "2 is true";
\&    };
\&
\&    # Test a failing test group
\&    want_test(\*(Aqfail\*(Aq, "this_should_fail",
\&        fail_diag("0 is true", 0, _\|_LINE_\|_+5),
\&        fail_diag("this_should_fail", 1, _\|_LINE_\|_+5),
\&    );
\&    test this_should_fail => sub {
\&        ok 1, "1 is true";
\&        ok 0, "0 is true";
\&    };
\&
\&    # Test a skipped test group
\&    want_test(\*(Aqskip\*(Aq, "just because I can");
\&    skip_next_test("just because I can");
\&    test this_should_be_skipped => sub {
\&        ok 0;
\&    };
\&
\&  EOSCRIPT
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test the behavior of a Test::Harness compatible test script, by
spawning an external process to run the script and capturing its \s-1STDOUT\s0
and \s-1STDERR.\s0  Includes support for matching the failed test diagnostic
messages produced by Test::Group and Test::Builder.
.PP
Useful when writing tests for Test::Group extension modules, see
Test::Group::Extending.
.PP
This module is used within the test suite of Test::Group itself, so
several usage examples can be found by searching for \f(CW\*(C`testscript_ok\*(C'\fR in
the files in Test::Group's \fIt\fR subdirectory.
.SH "FUNCTIONS EXPORTED BY DEFAULT"
.IX Header "FUNCTIONS EXPORTED BY DEFAULT"
.IP "\fItestscript_ok($source, \f(CI$plan\fI, \f(CI$name\fI)\fR" 4
.IX Item "testscript_ok($source, $plan, $name)"
A test predicate for checking that a test script acts as expected. Runs
the script capturing \s-1STDOUT\s0 and \s-1STDERR\s0 and fails if anything unexpected
happens.
.Sp
The expected behavior of the script is defined by calling \fBwant_test()\fR
from within the script, just before running each test.
.Sp
\&\fI\f(CI$source\fI\fR is the body of the test script, as a single multi-line string.
.Sp
\&\fI\f(CI$plan\fI\fR is the number of tests that the test script will run.
.Sp
\&\fI\f(CI$name\fI\fR is a name for this test.
.Sp
Some code will be prepended to \fI\f(CI$source\fI\fR, to make the \fBwant_test()\fR and
\&\fBfail_diag()\fR functions available and to set the test plan to \fI\f(CI$plan\fI\fR.
.Sp
Tip: include a \f(CW\*(C`#line\*(C'\fR directive in your script source as shown in the
\&\s-1SYNOPSIS\s0 above, so that the reported line numbers for problems will point
to the correct line in your source file.
.SH "TEST SCRIPT FUNCTIONS"
.IX Header "TEST SCRIPT FUNCTIONS"
The following functions are for use from within the script under test.
They are not exported by default.
.IP "\fIwant_test($type, \f(CI$name\fI, \f(CI@diag\fI)\fR" 4
.IX Item "want_test($type, $name, @diag)"
Declares that the next test will pass or fail or be skipped according to
\&\fI\f(CI$type\fI\fR, will have name \fI\f(CI$name\fI\fR and will produce the diagnostic output
lines listed in \fI\f(CI@diag\fI\fR.
.Sp
\&\fI\f(CI$type\fI\fR must be one of the strings 'pass', 'fail', 'skip'. \fI\f(CI$name\fI\fR
can be undef for a test without a name.  The elements of \fI\f(CI@diag\fI\fR can
be strings for an exact match, or regular expressions prefixed with
\&\f(CW\*(C`/\*(C'\fR or compiled with \f(CW\*(C`qr//\*(C'\fR.
.Sp
Note that diagnostic lines consist of a hash character followed by a
space and then the diagnostic message. The strings and patterns passed
to \fBwant_test()\fR must include this prefix.
.IP "\fIfail_diag($test_name [,$from_test_builder] [,$line] [,$file])\fR" 4
.IX Item "fail_diag($test_name [,$from_test_builder] [,$line] [,$file])"
Call only in a list context, and pass the results to \fBwant_test()\fR as
diagnostic line patterns.
.Sp
Returns the diagnostic line pattern(s) to match output from a failed
test. \fI\f(CI$test_name\fI\fR is the name of the test, or undef for a nameless
test.  \fI\f(CI$line\fI\fR should be defined only if a file and line diagnostic
is expected, and should give the expected line number.  \fI\f(CI$file\fI\fR is
the filename for the failed test diagnostic, it defaults to the
current file.
.Sp
\&\f(CW$from_test_builder\fR should be true if Test::Builder will produce
the diagnostic, false if the diagnostic will come from Test::Group.
The expected text will be adjusted according to the version of
Test::Builder or Test::Group in use.
.SH "AUTHORS"
.IX Header "AUTHORS"
Nick Cleaton <ncleaton@cpan.org>
.PP
Dominique Quatravaux <domq@cpan.org>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2009 by Nick Cleaton and Dominique Quatravaux
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.1 or,
at your option, any later version of Perl 5 you may have available.
