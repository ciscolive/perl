.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Frame::Layer 3"
.TH Net::Frame::Layer 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Frame::Layer \- base class for all layer objects
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for all other layer modules. It provides those layers with inheritable attributes, methods, constants and useful subroutines.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "\fBraw\fR" 4
.IX Item "raw"
Stores the raw layer (as captured from the network, or packed to send to network).
.IP "\fBpayload\fR" 4
.IX Item "payload"
Stores what is not part of the layer, that is the encapsulated part to be decoded by upper layers.
.IP "\fBnextLayer\fR" 4
.IX Item "nextLayer"
User definable next layer. It may be used to define custom protocols.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.PD 0
.IP "\fBnew\fR (hash)" 4
.IX Item "new (hash)"
.PD
Object constructor.
.IP "\fBlayer\fR" 4
.IX Item "layer"
Returns the string describing the layer (example: 'IPv4' for a \fBNet::Frame::Layer::IPv4\fR object).
.IP "\fBcomputeLengths\fR" 4
.IX Item "computeLengths"
.PD 0
.IP "\fBcomputeChecksums\fR" 4
.IX Item "computeChecksums"
.PD
Generally, when a layer is built, some attributes are not yet known until all layers that will be assembled are known. Those methods computes various lengths and checksums attributes found in a specific layer. Return 1 on success, undef otherwise. The usage depends from layer to layer, so see related documentation.
.Sp
Also note that in most cases, you will need to call \fBcomputeLength\fR before \fBcomputeChecksums\fR, because checksums may depend upon lengths.
.IP "\fBpack\fR" 4
.IX Item "pack"
Packs all attributes into a raw format, in order to inject to network. Returns the raw packed string on success, undef otherwise. Result is stored into \fBraw\fR attribute.
.IP "\fBunpack\fR" 4
.IX Item "unpack"
Unpacks raw data from network and stores attributes into the object. Returns \fB\f(CB$self\fB\fR on success, undef otherwise.
.IP "\fBencapsulate\fR" 4
.IX Item "encapsulate"
Returns the next layer type (parsed from payload). This is the same string as returned by \fBlayer\fR method.
.IP "\fBgetLength\fR" 4
.IX Item "getLength"
Returns the layer length in bytes.
.IP "\fBgetPayloadLength\fR" 4
.IX Item "getPayloadLength"
Returns the length of layer's payload in bytes.
.IP "\fBprint\fR" 4
.IX Item "print"
Just returns a string in a human readable format describing attributes found in the layer.
.IP "\fBdump\fR" 4
.IX Item "dump"
Just returns a string in hexadecimal format which is how the layer appears on the network.
.SH "USEFUL SUBROUTINES"
.IX Header "USEFUL SUBROUTINES"
Load them: use Net::Frame::Layer qw(:subs);
.IP "\fBgetHostIpv4Addr\fR (hostname)" 4
.IX Item "getHostIpv4Addr (hostname)"
Resolves IPv4 address of specified hostname.
.IP "\fBgetHostIpv4Addrs\fR (hostname)" 4
.IX Item "getHostIpv4Addrs (hostname)"
Same as above, but returns an array of IPv4 addresses.
.IP "\fBgetHostIpv6Addr\fR (hostname)" 4
.IX Item "getHostIpv6Addr (hostname)"
Resolves IPv6 address of specified hostname.
.IP "\fBinet6Aton\fR (IPv6 address)" 4
.IX Item "inet6Aton (IPv6 address)"
Takes IPv6 address and returns the network form.
.IP "\fBinet6Ntoa\fR (IPv6 network form)" 4
.IX Item "inet6Ntoa (IPv6 network form)"
Takes IPv6 address in network format, and returns the IPv6 human form.
.IP "\fBinetAton\fR (IPv4 address)" 4
.IX Item "inetAton (IPv4 address)"
.PD 0
.IP "\fBinetNtoa\fR (IPv4 network form)" 4
.IX Item "inetNtoa (IPv4 network form)"
.PD
Same as for IPv6, but for IPv4 addresses.
.IP "\fBconvertMac\fR (\s-1MAC\s0 network form)" 4
.IX Item "convertMac (MAC network form)"
Takes a \s-1MAC\s0 address from network form, and returns the human form.
.IP "\fBgetRandom16bitsInt\fR" 4
.IX Item "getRandom16bitsInt"
.PD 0
.IP "\fBgetRandom32bitsInt\fR" 4
.IX Item "getRandom32bitsInt"
.PD
Returns respectively a random 16 bits integer, and a random 32 bits integer.
.IP "\fBgetRandomHighPort\fR" 4
.IX Item "getRandomHighPort"
Returns a random high port (> 1024).
.IP "\fBinetChecksum\fR (pseudo header format)" 4
.IX Item "inetChecksum (pseudo header format)"
Will take a frame in pseudo header format, and compute the \s-1INET\s0 checksum.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Load them: use Net::Frame::Layer qw(:consts);
.IP "\fB\s-1NF_LAYER_NONE\s0\fR" 4
.IX Item "NF_LAYER_NONE"
.PD 0
.IP "\fB\s-1NF_LAYER_UNKNOWN\s0\fR" 4
.IX Item "NF_LAYER_UNKNOWN"
.IP "\fB\s-1NF_LAYER_NOT_AVAILABLE\s0\fR" 4
.IX Item "NF_LAYER_NOT_AVAILABLE"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Patrice <GomoR> Auffret
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2006\-2019, Patrice <GomoR> Auffret
.PP
You may distribute this module under the terms of the Artistic license.
See \s-1LICENSE\s0.Artistic file in the source distribution archive.
