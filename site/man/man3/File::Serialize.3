.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "File::Serialize 3"
.TH File::Serialize 3 "2019-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Serialize \- DWIM file serialization/deserialization
.SH "VERSION"
.IX Header "VERSION"
version 1.3.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use File::Serialize { pretty => 1 };
\&
\&    my $data = { foo => \*(Aqbar\*(Aq };
\&
\&    serialize_file \*(Aq/path/to/file.json\*(Aq => $data;
\&
\&    ...;
\&
\&    $data_copy = deserialize_file \*(Aq/path/to/file.json\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIFile::Serialize\fR provides a common, simple interface to
file serialization \*(-- you provide the file path, the data to serialized, and 
the module takes care of the rest. Even the serialization format, unless 
specified
explicitly as part of the options, is detected from the file extension.
.SH "IMPORT"
.IX Header "IMPORT"
\&\fIFile::Serialize\fR imports the three functions 
\&\f(CW\*(C`serialize_file\*(C'\fR, \f(CW\*(C`deserialize_file\*(C'\fR and \f(CW\*(C`transerialize_file\*(C'\fR into the current namespace.
A default set of options can be set for both by passing a hashref as
an argument to the 'use' statement.
.PP
.Vb 1
\&    use File::Serialize { pretty => 1 };
.Ve
.SH "SUPPORTED SERIALIZERS"
.IX Header "SUPPORTED SERIALIZERS"
File::Serialize will pick the serializer to use based on
the extension of the filename or the explicitly given \f(CW\*(C`format\*(C'\fR.
If several serializers are registered for the format,
the available serializer with the highest precedence number will
be used.
.IP "\s-1YAML\s0" 4
.IX Item "YAML"
File::Serialize::Serialize::YAML::Tiny
.IP "\s-1JSON\s0" 4
.IX Item "JSON"
File::Serialize::Serializer::JSON::MaybeXS
.IP "\s-1TOML\s0" 4
.IX Item "TOML"
File::Serialize::Serializer::TOML
.IP "\s-1XML\s0" 4
.IX Item "XML"
File::Serialize::Serializer::XML::Simple
.IP "jsony" 4
.IX Item "jsony"
File::Serialize::Serializer::JSONY
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\fIFile::Serialize\fR recognizes a set of options that, if applicable,
will be passed to the serializer.
.ie n .IP "format => $serializer" 4
.el .IP "format => \f(CW$serializer\fR" 4
.IX Item "format => $serializer"
Explicitly provides the serializer to use.
.Sp
.Vb 1
\&    my $data = deserialize_file $path, { format => \*(Aqjson\*(Aq };
.Ve
.ie n .IP "add_extension => $boolean" 4
.el .IP "add_extension => \f(CW$boolean\fR" 4
.IX Item "add_extension => $boolean"
If true, the canonical extension of the serializing format will be 
appended to the file. Requires the parameter \f(CW\*(C`format\*(C'\fR to be given as well.
.Sp
.Vb 3
\&    # will create \*(Aqfoo.yml\*(Aq, \*(Aqfoo.json\*(Aq and \*(Aqfoo.toml\*(Aq
\&    serialize_file \*(Aqfoo\*(Aq, $data, { format => $_, add_extension => 1 } 
\&        for qw/ yaml json toml /;
.Ve
.ie n .IP "pretty => $boolean" 4
.el .IP "pretty => \f(CW$boolean\fR" 4
.IX Item "pretty => $boolean"
The serialization will be formatted for human consumption.
.ie n .IP "canonical => $boolean" 4
.el .IP "canonical => \f(CW$boolean\fR" 4
.IX Item "canonical => $boolean"
Serializes the data using its canonical representation.
.ie n .IP "utf8 => $boolean" 4
.el .IP "utf8 => \f(CW$boolean\fR" 4
.IX Item "utf8 => $boolean"
If set to a \f(CW\*(C`true\*(C'\fR value, file will be read/written out using Path::Tiny's \f(CW\*(C`slurp_utf8\*(C'\fR and \f(CW\*(C`spew_utf8\*(C'\fR
method ( which sets a \f(CW\*(C`binmode\*(C'\fR of \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR). Otherwise,
Path::Tiny's \f(CW\*(C`slurp\*(C'\fR and \f(CW\*(C`spew\*(C'\fR methods are used.
.Sp
Defaults to being \f(CW\*(C`true\*(C'\fR because, after all, this is the twenty-first century.
.ie n .IP "allow_nonref => $boolean" 4
.el .IP "allow_nonref => \f(CW$boolean\fR" 4
.IX Item "allow_nonref => $boolean"
If set to true, allow to serialize non-ref data.
.Sp
Defaults to \f(CW\*(C`true\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "serialize_file $path, $data, $options"
.el .SS "serialize_file \f(CW$path\fP, \f(CW$data\fP, \f(CW$options\fP"
.IX Subsection "serialize_file $path, $data, $options"
.Vb 1
\&    my $data = { foo => \*(Aqbar\*(Aq };
\&
\&    serialize_file \*(Aq/path/to/file.json\*(Aq => $data;
.Ve
.PP
If the \f(CW$path\fR is '\f(CW\*(C`\-\*(C'\fR', the serialized data will be printed
to \s-1STDOUT.\s0 If it a scalar ref, the serialized data will be assigned
to that variable.
.PP
.Vb 1
\&    serialize_file \emy $serialized => $data;
\&
\&    print $serialized;
.Ve
.ie n .SS "deserialize_file $path, $options"
.el .SS "deserialize_file \f(CW$path\fP, \f(CW$options\fP"
.IX Subsection "deserialize_file $path, $options"
.Vb 1
\&    my $data = deserialize_file \*(Aq/path/to/file.json\*(Aq;
.Ve
.PP
If the \f(CW$path\fR is '\f(CW\*(C`\-\*(C'\fR', the serialized data will be read from
\&\s-1STDIN.\s0 If it a scalar ref, the serialized data will be read
from that variable.
.PP
.Vb 2
\&    my $json = \*(Aq{"foo":1}\*(Aq;
\&    my $data = deserialize_file \e$json;
.Ve
.ie n .SS "transerialize_file $input, @transformation_chain"
.el .SS "transerialize_file \f(CW$input\fP, \f(CW@transformation_chain\fP"
.IX Subsection "transerialize_file $input, @transformation_chain"
\&\f(CW\*(C`transerialize_file\*(C'\fR is a convenient wrapper that allows you to
deserialize a file, apply any number of transformations to its 
content and re-serialize the result.
.PP
\&\f(CW$input\fR can be a filename, a Path::Tiny object or the raw data 
structure to be worked on.
.PP
.Vb 1
\&    transerialize_file \*(Aqfoo.json\*(Aq => \*(Aqfoo.yaml\*(Aq;
\&    
\&    # equivalent to
\&    serialize_file \*(Aqfoo.yaml\*(Aq => deserialize_file \*(Aqfoo.json\*(Aq
.Ve
.PP
Each element of the \f(CW@transformation_chain\fR can be
.ie n .IP "$coderef" 4
.el .IP "\f(CW$coderef\fR" 4
.IX Item "$coderef"
A transformation step. The current data is available both via \f(CW$_\fR and
as the first argument to the sub,
and the transformed data is going to be whatever the sub returns.
.Sp
.Vb 4
\&    my $data = {
\&        tshirt => { price => 18 },
\&        hoodie => { price => 50 },
\&    };
\&
\&    transerialize_file $data => sub {
\&        my %inventory = %$_;
\&
\&        +{ %inventory{ grep { $inventory{$_}{price} <= 20 } keys %inventory } }
\&
\&    } => \*(Aqinexpensive.json\*(Aq;
\&
\&    # chaining transforms
\&    transerialize_file $data 
\&        => sub { 
\&            my %inventory = %$_; 
\&            +{ map { $_ => $inventory{$_}{price} } keys %inventory } }
\&        => sub {
\&            my %inventory = %$_;
\&            +{ %inventory{ grep { $inventory{$_} <= 20 } keys %inventory } }
\&        } => \*(Aqinexpensive.json\*(Aq;
\&
\&    # same as above, but with Perl 5.20 signatures and List::Util pair*
\&    # helpers
\&    transerialize_file $data 
\&        => sub($inventory) { +{ pairmap  { $a => $b\->{price} } %$inventory } }
\&        => sub($inventory) { +{ pairgrep { $b <= 20 }          %$inventory } } 
\&        => \*(Aqinexpensive.json\*(Aq;
.Ve
.IP "\e%destinations" 4
.IX Item "%destinations"
A hashref of destination file with their options. The current state of the data will
be serialized to those destination. If no options need to be passed, the 
value can be \f(CW\*(C`undef\*(C'\fR.
.Sp
.Vb 7
\&    transerialize_file $data => { 
\&        \*(Aqbeginning.json\*(Aq => { pretty => 1 },
\&        \*(Aqbeginning.yml\*(Aq  => undef
\&    } => sub { ... } => {
\&        \*(Aqend.json\*(Aq => { pretty => 1 },
\&        \*(Aqend.yml\*(Aq  => undef
\&    };
.Ve
.IP "[ \e@subchain1, \e@subchain2, ... ]" 4
.IX Item "[ @subchain1, @subchain2, ... ]"
Run the subchains given in \f(CW@branches\fR on the current data. Must be the last
step of the chain.
.Sp
.Vb 1
\&    my @data = 1..10;
\&
\&    transerialize_file \e@data 
\&        => { \*(Aqall.json\*(Aq => undef }
\&        => [
\&           [ sub { [ grep { $_ % 2 } @$_ ] }     => \*(Aqodd.json\*(Aq  ],
\&           [ sub { [ grep { not $_ % 2 } @$_ ] } => \*(Aqeven.json\*(Aq ],
\&        ];
.Ve
.ie n .IP "( $filename, $options )" 4
.el .IP "( \f(CW$filename\fR, \f(CW$options\fR )" 4
.IX Item "( $filename, $options )"
Has to be the final step(s) of the chain. Just like the arguments
of \f(CW\*(C`serialize_file\*(C'\fR. \f(CW$filename\fR can be a string or a Path::Tiny object.
\&\f(CW$options\fR is optional.
.IP "\e$result" 4
.IX Item "$result"
Has to be the final step of the chain. Will assign the transformed data
to \f(CW$result\fR instead of serializing to a file.
.SH "ADDING A SERIALIZER"
.IX Header "ADDING A SERIALIZER"
Serializers are added by creating a \fIFile::Serialize::Serializer::*\fR class that
implement the File::Serialize::Serializer role. See the documentation for the
role for more details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yanick Champoux <yanick@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2019, 2017, 2016, 2015 by Yanick Champoux.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
