.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Auto 3"
.TH Test::Auto 3 "2020-05-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Auto \- Test Automation
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Test Automation, Docs Generation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!/usr/bin/env perl
\&
\&  use Test::Auto;
\&  use Test::More;
\&
\&  my $test = Test::Auto\->new(
\&    \*(Aqt/Test_Auto.t\*(Aq
\&  );
\&
\&  # automation
\&
\&  # my $subtests = $test\->subtests\->standard;
\&
\&  # ...
\&
\&  # done_testing;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package aims to provide, a standard for documenting Perl 5 software
projects, a framework writing tests, test automation, and documentation
generation.
.SH "REASONING"
.IX Header "REASONING"
This framework lets you write documentation in test files using pod-like
comment blocks. By using a particular set of comment blocks (the specification)
this framework can run certain kinds of tests automatically. For example, we
can automatically ensure that the package the test is associated with is
loadable, that the test file comment blocks meet the specification, that any
super-classes or libraries are loadable, and that the functions, methods, and
routines are properly documented.
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Test::Auto::Types
.SH "SCENARIOS"
.IX Header "SCENARIOS"
This package supports the following scenarios:
.SS "exports"
.IX Subsection "exports"
.Vb 2
\&  use Test::Auto;
\&  use Test::More;
\&
\&  my $subtests = testauto \*(Aqt/Test_Auto.t\*(Aq;
\&
\&  # automation
\&
\&  # $subtests\->standard;
\&
\&  # ...
\&
\&  # done_testing;
.Ve
.PP
This package automatically exports the \f(CW\*(C`testauto\*(C'\fR function which uses the
\&\*(L"current file\*(R" as the automated testing source.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
This package has the following attributes:
.SS "data"
.IX Subsection "data"
.Vb 1
\&  data(Data)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(Data)\*(C'\fR values, and is optional.
.SS "file"
.IX Subsection "file"
.Vb 1
\&  file(Str)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(Str)\*(C'\fR values, and is required.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This package implements the following functions:
.SS "testauto"
.IX Subsection "testauto"
.Vb 1
\&  testauto(Str $file) : Subtests
.Ve
.PP
This function is exported automatically and returns a Test::Auto::Subtests
object for the test file given.
.IP "testauto example #1" 4
.IX Item "testauto example #1"
.Vb 1
\&  # given: synopsis
\&
\&  my $subtests = testauto \*(Aqt/Test_Auto.t\*(Aq;
.Ve
.SH "METHODS"
.IX Header "METHODS"
This package implements the following methods:
.SS "document"
.IX Subsection "document"
.Vb 1
\&  document() : Document
.Ve
.PP
This method returns a Test::Auto::Document object.
.IP "document example #1" 4
.IX Item "document example #1"
.Vb 1
\&  # given: synopsis
\&
\&  my $document = $test\->document;
.Ve
.SS "parser"
.IX Subsection "parser"
.Vb 1
\&  parser() : Parser
.Ve
.PP
This method returns a Test::Auto::Parser object.
.IP "parser example #1" 4
.IX Item "parser example #1"
.Vb 1
\&  # given: synopsis
\&
\&  my $parser = $test\->parser;
.Ve
.SS "subtests"
.IX Subsection "subtests"
.Vb 1
\&  subtests() : Subtests
.Ve
.PP
This method returns a Test::Auto::Subtests object.
.IP "subtests example #1" 4
.IX Item "subtests example #1"
.Vb 1
\&  # given: synopsis
\&
\&  my $subtests = $test\->subtests;
.Ve
.SH "SPECIFICATION"
.IX Header "SPECIFICATION"
.Vb 1
\&  # [required]
\&
\&  =name
\&  =abstract
\&  =tagline
\&  =includes
\&  =synopsis
\&  =description
\&
\&  # [optional]
\&
\&  =libraries
\&  =inherits
\&  =integrates
\&  =attributes
\&
\&  # [repeatable; optional]
\&
\&  =scenario $name
\&  =example $name
\&
\&  # [repeatable; optional]
\&
\&  =method $name
\&  =signature $name
\&  =example\-$number $name # [repeatable]
\&
\&  # [repeatable; optional]
\&
\&  =function $name
\&  =signature $name
\&  =example\-$number $name # [repeatable]
\&
\&  # [repeatable; optional]
\&
\&  =routine $name
\&  =signature $name
\&  =example\-$number $name # [repeatable]
\&
\&  # [repeatable; optional]
\&
\&  =type $name
\&  =type\-library $name
\&  =type\-composite $name # [optional]
\&  =type\-parent $name # [optional]
\&  =type\-coercion\-$number $name # [optional]
\&  =type\-example\-$number $name # [repeatable]
.Ve
.PP
The specification is designed to accommodate typical package declarations. It
is used by the parser to provide the content used in the test automation and
document generation. Note: when code blocks are evaluated \fI\*(L"redefined\*(R"\fR
warnings are now automatically disabled.
.SS "name"
.IX Subsection "name"
.Vb 1
\&  =name
\&
\&  Path::Find
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`name\*(C'\fR block should contain the package name. This is tested for
loadability.
.SS "tagline"
.IX Subsection "tagline"
.Vb 1
\&  =tagline
\&
\&  Path Finder
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`tagline\*(C'\fR block should contain a tagline for the package. This is optional
but if present is concatenated with the \f(CW\*(C`name\*(C'\fR during \s-1POD\s0 generation.
.SS "abstract"
.IX Subsection "abstract"
.Vb 1
\&  =abstract
\&
\&  Find Paths using Heuristics
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`abstract\*(C'\fR block should contain a subtitle describing the package. This is
tested for existence.
.SS "includes"
.IX Subsection "includes"
.Vb 1
\&  =includes
\&
\&  function: path
\&  method: children
\&  method: siblings
\&  method: new
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`includes\*(C'\fR block should contain a list of \f(CW\*(C`function\*(C'\fR, \f(CW\*(C`method\*(C'\fR, and/or
\&\f(CW\*(C`routine\*(C'\fR names in the format of \f(CW\*(C`$type: $name\*(C'\fR. Empty lines are ignored.
This is tested for existence. Each function, method, and/or routine is tested
to be documented properly. Also, the package must recognize that each exists.
.SS "synopsis"
.IX Subsection "synopsis"
.Vb 1
\&  =synopsis
\&
\&  use Path::Find \*(Aqpath\*(Aq;
\&
\&  my $path = path; # get path using cwd
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`synopsis\*(C'\fR block should contain the normative usage of the package. This
is tested for existence. This block should be written in a way that allows it
to be evaled successfully and should return a value.
.SS "description"
.IX Subsection "description"
.Vb 1
\&  =description
\&
\&  interdum posuere lorem ipsum dolor sit amet consectetur adipiscing elit duis
\&  tristique sollicitudin nibh sit amet
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`description\*(C'\fR block should contain a thorough explanation of the purpose
of the package. This is tested for existence.
.SS "libraries"
.IX Subsection "libraries"
.Vb 1
\&  =libraries
\&
\&  Types::Standard
\&  Types::TypeTiny
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`libraries\*(C'\fR block should contain a list of packages, each of which is
itself a Type::Library. These packages are tested for loadability, and to
ensure they are type library classes.
.SS "inherits"
.IX Subsection "inherits"
.Vb 1
\&  =inherits
\&
\&  Path::Tiny
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`inherits\*(C'\fR block should contain a list of parent packages. These packages
are tested for loadability.
.SS "integrates"
.IX Subsection "integrates"
.Vb 1
\&  =integrates
\&
\&  Path::Find::Upable
\&  Path::Find::Downable
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`integrates\*(C'\fR block should contain a list of packages that are involved in
the behavior of the main package. These packages are not automatically tested.
.SS "scenarios"
.IX Subsection "scenarios"
.Vb 1
\&  =scenario export\-path\-make
\&
\&  quisque egestas diam in arcu cursus euismod quis viverra nibh
\&
\&  =example export\-path\-make
\&
\&  # given: synopsis
\&
\&  package main;
\&
\&  use Path::Find \*(Aqpath_make\*(Aq;
\&
\&  path_make \*(Aqrelpath/to/file\*(Aq;
\&
\&  =cut
.Ve
.PP
There are situation where a package can be configured in different ways,
especially where it exists without functions, methods or routines for the
purpose of configuring the environment. The scenario directive can be used to
automate testing and documenting package usages and configurations.Describing a
scenario requires two blocks, i.e. \f(CW\*(C`scenario $name\*(C'\fR and \f(CW\*(C`example $name\*(C'\fR. The
\&\f(CW\*(C`scenario\*(C'\fR block should contain a description of the scenario and its purpose.
The \f(CW\*(C`example\*(C'\fR block must exist when documenting a method and should contain
valid Perl code and return a value. The block may contain a \*(L"magic\*(R" comment in
the form of \f(CW\*(C`given: synopsis\*(C'\fR or \f(CW\*(C`given: example $name\*(C'\fR which if present will
include the given code example(s) with the evaluation of the current block.
Each scenario is tested and must be recognized to exist by the main package.
.SS "attributes"
.IX Subsection "attributes"
.Vb 1
\&  =attributes
\&
\&  cwd: ro, req, Object
\&
\&  =cut
.Ve
.PP
The \f(CW\*(C`attributes\*(C'\fR block should contain a list of package attributes in the form
of \f(CW\*(C`$name: $is, $presence, $type\*(C'\fR, where \f(CW$is\fR should be \f(CW\*(C`ro\*(C'\fR (read-only) or
\&\f(CW\*(C`rw\*(C'\fR (read-wire), and \f(CW$presence\fR should be \f(CW\*(C`req\*(C'\fR (required) or \f(CW\*(C`opt\*(C'\fR
(optional), and \f(CW$type\fR can be any valid Type::Tiny expression. Each
attribute declaration must be recognized to exist by the main package and have
a type which is recognized by one of the declared type libraries.
.SS "methods"
.IX Subsection "methods"
.Vb 1
\&  =method children
\&
\&  quis viverra nibh cras pulvinar mattis nunc sed blandit libero volutpat
\&
\&  =signature children
\&
\&  children() : [Object]
\&
\&  =example\-1 children
\&
\&  # given: synopsis
\&
\&  my $children = $path\->children;
\&
\&  =example\-2 children
\&
\&  # given: synopsis
\&
\&  my $filtered = $path\->children(qr/lib/);
\&
\&  =cut
.Ve
.PP
Describing a method requires at least three blocks, i.e. \f(CW\*(C`method $name\*(C'\fR,
\&\f(CW\*(C`signature $name\*(C'\fR, and \f(CW\*(C`example\-1 $name\*(C'\fR. The \f(CW\*(C`method\*(C'\fR block should contain
a description of the method and its purpose. The \f(CW\*(C`signature\*(C'\fR block should
contain a method signature in the form of \f(CW\*(C`$signature : $return_type\*(C'\fR, where
\&\f(CW$signature\fR is a valid typed signature and \f(CW$return_type\fR is any valid
Type::Tiny expression. The \f(CW\*(C`example\-$number\*(C'\fR block is a repeatable block,
and at least one block must exist when documenting a method. The
\&\f(CW\*(C`example\-$number\*(C'\fR block should contain valid Perl code and return a value. The
block may contain a \*(L"magic\*(R" comment in the form of \f(CW\*(C`given: synopsis\*(C'\fR or
\&\f(CW\*(C`given: example\-$number $name\*(C'\fR which if present will include the given code
example(s) with the evaluation of the current block. Each method is tested and
must be recognized to exist by the main package.
.SS "functions"
.IX Subsection "functions"
.Vb 1
\&  =function path
\&
\&  lectus quam id leo in vitae turpis massa sed elementum tempus egestas
\&
\&  =signature children
\&
\&  path() : Object
\&
\&  =example\-1 path
\&
\&  package Test::Path::Find;
\&
\&  use Path::Find;
\&
\&  my $path = path;
\&
\&  =cut
.Ve
.PP
Describing a function requires at least three blocks, i.e. \f(CW\*(C`function $name\*(C'\fR,
\&\f(CW\*(C`signature $name\*(C'\fR, and \f(CW\*(C`example\-1 $name\*(C'\fR. The \f(CW\*(C`function\*(C'\fR block should
contain a description of the function and its purpose. The \f(CW\*(C`signature\*(C'\fR block
should contain a function signature in the form of \f(CW\*(C`$signature :
$return_type\*(C'\fR, where \f(CW$signature\fR is a valid typed signature and
\&\f(CW$return_type\fR is any valid Type::Tiny expression. The \f(CW\*(C`example\-$number\*(C'\fR
block is a repeatable block, and at least one block must exist when documenting
a function. The \f(CW\*(C`example\-$number\*(C'\fR block should contain valid Perl code and
return a value. The block may contain a \*(L"magic\*(R" comment in the form of \f(CW\*(C`given:
synopsis\*(C'\fR or \f(CW\*(C`given: example\-$number $name\*(C'\fR which if present will include the
given code example(s) with the evaluation of the current block. Each function
is tested and must be recognized to exist by the main package.
.SS "routines"
.IX Subsection "routines"
.Vb 1
\&  =routine algorithms
\&
\&  sed sed risus pretium quam vulputate dignissim suspendisse in est ante
\&
\&  =signature algorithms
\&
\&  algorithms() : Object
\&
\&  =example\-1 algorithms
\&
\&  # given: synopsis
\&
\&  $path\->algorithms
\&
\&  =example\-2 algorithms
\&
\&  package Test::Path::Find;
\&
\&  use Path::Find;
\&
\&  Path::Find\->algorithms;
\&
\&  =cut
.Ve
.PP
Typically, a Perl subroutine is declared as a function or a method. Rarely, but
sometimes necessary, you will need to describe a subroutine where the invocant
is either a class or class instance. Describing a routine requires at least
three blocks, i.e. \f(CW\*(C`routine $name\*(C'\fR, \f(CW\*(C`signature $name\*(C'\fR, and \f(CW\*(C`example\-1
$name\*(C'\fR. The \f(CW\*(C`routine\*(C'\fR block should contain a description of the routine and
its purpose. The \f(CW\*(C`signature\*(C'\fR block should contain a routine signature in the
form of \f(CW\*(C`$signature : $return_type\*(C'\fR, where \f(CW$signature\fR is a valid typed
signature and \f(CW$return_type\fR is any valid Type::Tiny expression. The
\&\f(CW\*(C`example\-$number\*(C'\fR block is a repeatable block, and at least one block must
exist when documenting a routine. The \f(CW\*(C`example\-$number\*(C'\fR block should contain
valid Perl code and return a value. The block may contain a \*(L"magic\*(R" comment in
the form of \f(CW\*(C`given: synopsis\*(C'\fR or \f(CW\*(C`given: example\-$number $name\*(C'\fR which if
present will include the given code example(s) with the evaluation of the
current block. Each routine is tested and must be recognized to exist by the
main package.
.SS "types"
.IX Subsection "types"
.Vb 1
\&  =type Path
\&
\&    Path
\&
\&  =type\-parent Path
\&
\&    Object
\&
\&  =type\-library Path
\&
\&  Path::Types
\&
\&  =type\-composite Path
\&
\&    InstanceOf["Path::Find"]
\&
\&  =type\-coercion\-1 Path
\&
\&    # can coerce from Str
\&
\&    \*(Aq./path/to/file\*(Aq
\&
\&  =type\-example\-1 Path
\&
\&    require Path::Find;
\&
\&    Path::Find::path(\*(Aq./path/to/file\*(Aq)
\&
\&  =cut
.Ve
.PP
When developing Perl programs, or type libraries, that use Type::Tiny based
type constraints, testing and documenting custom type constraints is often
overlooked. Describing a custom type constraint requires at least two blocks,
i.e. \f(CW\*(C`type $name\*(C'\fR and \f(CW\*(C`type\-library $name\*(C'\fR. While it's not strictly required,
it's a good idea to also include at least one \f(CW\*(C`type\-example\-1 $name\*(C'\fR. The
optional \f(CW\*(C`type\-parent\*(C'\fR block should contain the name of the parent type. The
\&\f(CW\*(C`type\-composite\*(C'\fR block should contain a type expression that represents the
derived type. The \f(CW\*(C`type\-coercion\-$number\*(C'\fR block is a repeatable block which
is used to validate type coercion. The \f(CW\*(C`type\-coercion\-$number\*(C'\fR block should
contain valid Perl code and return the value to be coerced. The
\&\f(CW\*(C`type\-example\-$number\*(C'\fR block is a repeatable block, and it's a good idea to
have at least one block must exist when documenting a type. The
\&\f(CW\*(C`type\-example\-$number\*(C'\fR block should contain valid Perl code and return a
value. Each type is tested and must be recognized to exist within the package
specified by the \f(CW\*(C`type\-library\*(C'\fR block.
.SH "AUTOMATION"
.IX Header "AUTOMATION"
.Vb 1
\&  $test\->standard;
.Ve
.PP
This is the equivalent of writing:
.PP
.Vb 9
\&  $test\->package;
\&  $test\->document;
\&  $test\->libraries;
\&  $test\->inherits;
\&  $test\->attributes;
\&  $test\->methods;
\&  $test\->routines;
\&  $test\->functions;
\&  $test\->types;
.Ve
.PP
This framework provides a set of automated subtests based on the package
specification, but not everything can be automated so it also provides you with
powerful hooks into the framework for manual testing.
.PP
.Vb 1
\&  my $subtests = $test\->subtests;
\&
\&  $subtests\->synopsis(sub {
\&    my ($tryable) = @_;
\&
\&    ok my $result = $tryable\->result, \*(Aqresult ok\*(Aq;
\&
\&    $result; # for automated testing after the callback
\&  });
.Ve
.PP
The code examples documented can be automatically evaluated (evaled) and
returned using a callback you provide for further testing. Because the code
examples are returned as \f(CW\*(C`Test::Auto::Try\*(C'\fR objects (see Data::Object::Try),
this makes capturing and testing exceptions simple, for example:
.PP
.Vb 1
\&  my $subtests = $test\->subtests;
\&
\&  $subtests\->synopsis(sub {
\&    my ($tryable) = @_;
\&
\&    # catch exception thrown by the synopsis
\&    $tryable\->catch(\*(AqPath::Find::Error\*(Aq, sub {
\&      return $_[0];
\&    });
\&    # test the exception
\&    ok my $result = $tryable\->result, \*(Aqresult ok\*(Aq;
\&    ok $result\->isa(\*(AqPath::Find::Error\*(Aq), \*(Aqexception caught\*(Aq;
\&
\&    $result;
\&  });
.Ve
.PP
Additionally, another manual testing hook (with some automation) is the
\&\f(CW\*(C`example\*(C'\fR method. This hook evaluates (evals) a given example and returns the
result as a \f(CW\*(C`Test::Auto::Try\*(C'\fR object (see Data::Object::Try). The first
argument is the example \s-1ID\s0 (or number), for example:
.PP
.Vb 1
\&  my $subtests = $test\->subtests;
\&
\&  $subtests\->example(\-1, \*(Aqchildren\*(Aq, \*(Aqmethod\*(Aq, sub {
\&    my ($tryable) = @_;
\&
\&    ok my $result = $tryable\->result, \*(Aqresult ok\*(Aq;
\&
\&    $result; # for automated testing after the callback
\&  });
.Ve
.PP
Finally, the lesser-used but useful manual testing hook is the \f(CW\*(C`scenario\*(C'\fR
method. This hook evaluates (evals) a documented scenario and returns the
result as a \f(CW\*(C`Test::Auto::Try\*(C'\fR object (see Data::Object::Try), for example:
.PP
.Vb 1
\&  my $subtests = $test\->subtests;
\&
\&  $subtests\->scenario(\*(Aqexport\-path\-make\*(Aq, sub {
\&    my ($tryable) = @_;
\&
\&    ok my $result = $tryable\->result, \*(Aqresult ok\*(Aq;
\&
\&    $result; # for automated testing after the callback
\&  });
.Ve
.PP
The test automation and document generation enabled through this framework
makes it easy to maintain source/test/documentation parity. This also
increases reusability and reduces the need for complicated state and test setup.
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the
\&\*(L"license file\*(R" <https://github.com/iamalnewkirk/test-auto/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/test-auto/wiki>
.PP
Project <https://github.com/iamalnewkirk/test-auto>
.PP
Initiatives <https://github.com/iamalnewkirk/test-auto/projects>
.PP
Milestones <https://github.com/iamalnewkirk/test-auto/milestones>
.PP
Issues <https://github.com/iamalnewkirk/test-auto/issues>
