.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Applify 3"
.TH Applify 3 "2020-10-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Applify \- Write object oriented scripts with ease
.SH "VERSION"
.IX Header "VERSION"
0.22
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module should keep all the noise away and let you write scripts very
easily. These scripts can even be unit tested even though they are defined
directly in the script file and not in a module.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  #!/usr/bin/perl
\&  use Applify;
\&
\&  option file => input_file => \*(AqFile to read from\*(Aq;
\&  option dir => output_dir => \*(AqDirectory to write files to\*(Aq;
\&  option flag => dry_run => \*(AqUse \-\-no\-dry\-run to actually do something\*(Aq, 1;
\&
\&  documentation _\|_FILE_\|_;
\&  version 1.23;
\&
\&  sub generate_exit_value {
\&    return int rand 100;
\&  }
\&
\&  # app {...}; must be the last statement in the script
\&  app {
\&    my ($app, @extra) = @_;
\&    my $exit_value = 0;
\&
\&    print "Extra arguments: @extra\en" if(@extra);
\&    print "Will read from: ", $app\->input_file, "\en";
\&    print "Will write files to: ", $app\->output_dir, "\en";
\&
\&    if($app\->dry_run) {
\&      die \*(AqWill not run script\*(Aq;
\&    }
\&
\&    return $app\->generate_exit_value;
\&  };
.Ve
.SH "APPLICATION CLASS"
.IX Header "APPLICATION CLASS"
This module will generate an application class, which \f(CW$app\fR inside the
\&\*(L"app\*(R" block is an instance of. The class will have these methods:
.IP "\(bu" 2
\&\f(CW\*(C`new()\*(C'\fR
.Sp
An object constructor. This method will not be auto generated if any of
the classes given to \*(L"extends\*(R" has the method \f(CW\*(C`new()\*(C'\fR.
.IP "\(bu" 2
\&\f(CW\*(C`run()\*(C'\fR
.Sp
This method is basically the code block given to \*(L"app\*(R".
.IP "\(bu" 2
Other methods
.Sp
Other methods defined in the script file will be accesible from \f(CW$app\fR
inside \f(CW\*(C`app{}\*(C'\fR.
.IP "\(bu" 2
\&\f(CW\*(C`_script()\*(C'\fR
.Sp
This is an accessor which return the Applify object which
is refered to as \f(CW$script\fR in this documentation.
.Sp
\&\s-1NOTE:\s0 This accessor starts with an underscore to prevent conflicts
with \*(L"options\*(R".
.IP "\(bu" 2
Other accessors
.Sp
Any \*(L"option\*(R" (application option) will be available as an accessor on the
application object.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "option"
.IX Subsection "option"
.Vb 4
\&  option $type => $name => $documentation;
\&  option $type => $name => $documentation, $default;
\&  option $type => $name => $documentation, $default, @args;
\&  option $type => $name => $documentation, @args;
.Ve
.PP
This function is used to define options which can be given to this
application. See \*(L"\s-1SYNOPSIS\*(R"\s0 for example code. This function can also be
called as a method on \f(CW$script\fR. Additionally, similar to
Moose attributes, a
\&\f(CW\*(C`has_$name\*(C'\fR method will be generated, which can be called on \f(CW$app\fR to
determine if the \*(L"option\*(R" has been set, either by a user or from the
\&\f(CW$default\fR.
.IP "\(bu" 2
\&\f(CW$type\fR
.Sp
Used to define value types for this input. Can be:
.Sp
.Vb 8
\&  | $type | Example             | Attribute value |
\&  |\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | bool  | \-\-foo, \-\-no\-foo     | foo=1, foo=0    |
\&  | flag  | \-\-foo, \-\-no\-foo     | foo=1, foo=0    |
\&  | inc   | \-\-verbose \-\-verbose | verbose=2       |
\&  | str   | \-\-name batwoman     | name=batwoman   |
\&  | int   | \-\-answer 42         | answer=42       |
\&  | num   | \-\-pie 3.14          | pie=3.14        |
.Ve
.IP "\(bu" 2
\&\f(CW$name\fR
.Sp
The name of an application option. This name will also be used as accessor name
inside the application. Example:
.Sp
.Vb 2
\&  # define an application option: 
\&  option file => some_file => \*(Aq...\*(Aq;
\&
\&  # call the application from command line:
\&  > myapp.pl \-\-some\-file /foo/bar
\&
\&  # run the application code:
\&  app {
\&    my $app = shift;
\&    print $app\->some_file # prints "/foo/bar"
\&    return 0;
\&  };
.Ve
.IP "\(bu" 2
\&\f(CW$documentation\fR
.Sp
Used as description text when printing the usage text.
.IP "\(bu" 2
\&\f(CW$default\fR
.Sp
Either a plain value or a code ref that can be used to generate a value.
.Sp
.Vb 2
\&  option str => passwd => "Password file", "/etc/passwd";
\&  option str => passwd => "Password file", sub { "/etc/passwd" };
.Ve
.IP "\(bu" 2
\&\f(CW@args\fR
.RS 2
.IP "\(bu" 2
\&\f(CW\*(C`alias\*(C'\fR
.Sp
Used to define an alias for the option. Example:
.Sp
.Vb 1
\&  option inc => verbose => "Output debug information", alias => "v";
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`required\*(C'\fR
.Sp
The script will not start if a required field is omitted.
.IP "\(bu" 2
\&\f(CW\*(C`n_of\*(C'\fR
.Sp
Allow the option to hold a list of values. Examples: \*(L"@\*(R", \*(L"4\*(R", \*(L"1,3\*(R".
See \*(L"Options-with-multiple-values\*(R" in Getopt::Long for details.
.IP "\(bu" 2
\&\f(CW\*(C`isa\*(C'\fR
.Sp
Can be used to either specify a class that the value should be instantiated
as, or a Type::Tiny object that will be used for coercion and/or type
validation.
.Sp
Example using a class:
.Sp
.Vb 1
\&  option file => output => "output file", isa => "Mojo::File";
.Ve
.Sp
The \f(CW\*(C`output()\*(C'\fR attribute will then later return an object of Mojo::File,
instead of just a plain string.
.Sp
Example using Type::Tiny:
.Sp
.Vb 2
\&  use Types::Standard "Int";
\&  option num => age => "Your age", isa => Int;
.Ve
.IP "\(bu" 2
Other
.Sp
Any other Moose attribute argument may/will be supported in
future release.
.RE
.RS 2
.RE
.SS "documentation"
.IX Subsection "documentation"
.Vb 3
\&  documentation _\|_FILE_\|_; # current file
\&  documentation \*(Aq/path/to/file\*(Aq;
\&  documentation \*(AqSome::Module\*(Aq;
.Ve
.PP
Specifies where to retrieve documentaion from when giving the \f(CW\*(C`\-\-man\*(C'\fR option
to your script.
.SS "version"
.IX Subsection "version"
.Vb 2
\&  version \*(AqSome::Module\*(Aq;
\&  version $num;
.Ve
.PP
Specifies where to retrieve the version number from when giving the
\&\f(CW\*(C`\-\-version\*(C'\fR option to your script.
.SS "extends"
.IX Subsection "extends"
.Vb 1
\&  extends @classes;
.Ve
.PP
Specify which classes this application should inherit from. These
classes can be Moose based.
.SS "hook"
.IX Subsection "hook"
.Vb 2
\&  hook before_exit            => sub { my ($script, $exit_value) = @_ };
\&  hook before_options_parsing => sub { my ($script, $argv) = @_ };
.Ve
.PP
Defines a hook to run.
.IP "\(bu" 2
before_exit
.Sp
Called right before \f(CW\*(C`exit($exit_value)\*(C'\fR is called by Applify. Note that
this hook will not be called if an exception is thrown.
.IP "\(bu" 2
before_options_parsing
.Sp
Called right before \f(CW$argv\fR is parsed by \*(L"option_parser\*(R". \f(CW$argv\fR is an
array-ref of the raw options given to your application. This hook allows you
to modify \*(L"option_parser\*(R". Example:
.Sp
.Vb 3
\&  hook before_options_parsing => sub {
\&    shift\->option_parser\->configure(bundling no_pass_through);
\&  };
.Ve
.SS "subcommand"
.IX Subsection "subcommand"
.Vb 4
\&  subcommand list => \*(Aqprovide a listing objects\*(Aq => sub {
\&    option flag => long => \*(Aqlong listing\*(Aq;
\&    option flag => recursive => \*(Aqrecursively list objects\*(Aq;
\&  };
\&
\&  subcommand create => \*(Aqcreate a new object\*(Aq => sub {
\&    option str => name => \*(Aqname of new object\*(Aq, required => 1;
\&    option str => description => \*(Aqdescription for the object\*(Aq, required => 1;
\&  };
\&
\&  sub command_create {
\&    my ($app, @extra) = @_;
\&    ## do creating
\&    return 0;
\&  }
\&
\&  sub command_list {
\&    my ($app, @extra) = @_;
\&    ## do listing
\&    return 0;
\&  }
\&
\&  app {
\&    my ($app, @extra) = @_;
\&    ## fallback when no command given.
\&    $app\->_script\->print_help;
\&    return 0;
\&  };
.Ve
.PP
This function allows for creating multiple related sub commands within the same
script in a similar fashion to \f(CW\*(C`git\*(C'\fR. The \*(L"option\*(R", \*(L"extends\*(R" and
\&\*(L"documentation\*(R" exported functions may sensibly be called within the
subroutine. Calling the function with no arguments will return the running
subcommand, i.e. a valid \f(CW$ARGV[0]\fR. Non valid values for the subcommand given
on the command line will result in the help being displayed.
.SS "app"
.IX Subsection "app"
.Vb 1
\&  app CODE;
.Ve
.PP
This function will define the code block which is called when the application
is started. See \*(L"\s-1SYNOPSIS\*(R"\s0 for example code. This function can also be
called as a method on \f(CW$script\fR.
.PP
\&\s-1IMPORTANT:\s0 This function must be the last function called in the script file
for unit tests to work. Reason for this is that this function runs the
application in void context (started from command line), but returns the
application object in list/scalar context (from \*(L"do\*(R" in perlfunc).
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "option_parser"
.IX Subsection "option_parser"
.Vb 2
\&  $script = $script\->option_parser(Getopt::Long::Parser\->new);
\&  $parser = $script\->option_parser;
.Ve
.PP
You can specify your own option parser if you have special needs. The default
is:
.PP
.Vb 1
\&  Getopt::Long::Parser\->new(config => [qw(no_auto_help no_auto_version pass_through)]);
.Ve
.SS "options"
.IX Subsection "options"
.Vb 1
\&  $array_ref = $script\->options;
.Ve
.PP
Holds the application options given to \*(L"option\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $script = Applify\->new({options => $array_ref, ...});
.Ve
.PP
Object constructor. Creates a new object representing the script meta
information.
.SS "print_help"
.IX Subsection "print_help"
Will print \*(L"options\*(R" to selected filehandle (\s-1STDOUT\s0 by default) in
a normalized matter. Example:
.PP
.Vb 3
\&  Usage:
\&     \-\-foo      Foo does this and that
\&   * \-\-bar      Bar does something else
\&
\&     \-\-help     Print this help text
\&     \-\-man      Display manual for this application
\&     \-\-version  Print application name and version
.Ve
.SS "print_version"
.IX Subsection "print_version"
Will print \*(L"version\*(R" to selected filehandle (\s-1STDOUT\s0 by default) in
a normalized matter. Example:
.PP
.Vb 1
\&  some\-script.pl version 1.23
.Ve
.SS "import"
.IX Subsection "import"
Will export the functions listed under \*(L"\s-1EXPORTED FUNCTIONS\*(R"\s0. The functions
will act on a Applify object created by this method.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jan Henning Thorsen \- \f(CW\*(C`jhthorsen@cpan.org\*(C'\fR
.PP
Roy Storey \- \f(CW\*(C`kiwiroy@cpan.org\*(C'\fR
