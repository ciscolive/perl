.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Proc::SafeExec 3"
.TH Proc::SafeExec 3 "2013-06-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::SafeExec \- Convenient utility for executing external commands in various ways.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&        use Proc::SafeExec;
\&        $SIG{"CHLD"} = "DEFAULT";  # Not IGNORE, so we can collect exit status.
\&        my $command = Proc::SafeExec\->new({
\&                # Choose just one of these.
\&                "exec" => ["ls", "\-l", "myfile"],  # exec() after forking.
\&                "fork" => 1,                       # Return undef in the child after forking.
\&
\&                # Specify whether to capture each. Specify a file handle ref to dup an existing
\&                # one. Specify "new" to create a new file handle, "default" or undef to keep
\&                # the parent\*(Aqs descriptor, or "close" to close it.
\&                "stdin" => \e*INPUT_PIPE,
\&                "stdout" => \e*OUTPUT_PIPE,
\&                "stderr" => "new",
\&
\&                # Miscellaneous options.
\&                "child_callback" => \e&fref,  # Specify a function to call in the child after fork(), for example, to drop privileges.
\&                "debug" => 1,  # Emit some information via warnings, such as the command to execute.
\&                "no_autowait" => 1,  # Don\*(Aqt automatically call $command\->wait() when $command is destroyed.
\&                "real_arg0" => "/bin/ls",  # Specify the actual file to execute.
\&                "untaint_args" => 1,  # Untaint the arguments before exec\*(Aqing.
\&        });
\&        printf "Child\*(Aqs PID is %s\en", $command\->child_pid() if $command\->child_pid();
.Ve
.PP
The wait method waits for the child to exit or checks whether it already
exited:
.PP
.Vb 5
\&        $command\->wait({
\&                # Optional hash of options.
\&                "no_close" => 1,  # Don\*(Aqt close "new" file handles.
\&                "nonblock" => 1,  # Don\*(Aqt wait if the child hasn\*(Aqt exited (implies no_close).
\&        });
.Ve
.PP
To communicate with the child:
.PP
.Vb 3
\&        # Perl doesn\*(Aqt understand <$command\->stdout()>.
\&        my $command_stdout = $command\->stdout();
\&        my $command_stderr = $command\->stderr();
\&
\&        $line = <$command_stdout>;
\&        $line = <$command_stderr>;
\&        print {$command\->stdin()} "mumble\en";
.Ve
.PP
To check whether the child exited yet:
.PP
.Vb 1
\&        print "Exit status: ", $command\->exit_status(), "\en" if $command\->wait({"nonblock" => 1});
.Ve
.PP
To wait until it exits:
.PP
.Vb 2
\&        $command\->wait();
\&        print "Exit status: ", $command\->exit_status(), "\en";
.Ve
.PP
A convenient quick tool for an alternative to \f(CW$output\fR = `@exec`:
.PP
.Vb 1
\&        ($output, $?) = Proc::SafeExec::backtick(@exec);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Proc::SafeExec provides an easy, safe way to execute external programs. It
replaces all of Perl's questionable ways of accomodating this, including
\&\fBsystem()\fR, \fBopen()\fR with a pipe, \fBexec()\fR, back-ticks, etc. This module will never
automatically invoke /bin/sh. This module is easy enough to use that /bin/sh
should be unnecessary, even for complex pipelines.
.PP
For all errors, this module dies setting $@.
.PP
Errors from \fBexec()\fR in the child are reported gracefully to the parent. This
means that if anything fails in the child, the error is reported through $@
with die just like any other error. This also reports $@ if child_callback
dies when it is called between \fBfork()\fR and \fBexec()\fR. This is accomplished by
passing $@ through an extra pipe that's closed when exec succeeds. Note: A
side-effect of this is $@ is stringified if it isn't a string.
.SH "CAVEATS"
.IX Header "CAVEATS"
When using an existing file handle by passing a reference for stdin, stdout, or
stderr, \fBnew()\fR closes the previously open file descriptor. This is to make sure,
for example, that when setting up a pipeline the child process notices \s-1EOF\s0 on
its stdin. If you need this file handle to stay open, dup it first. For
example:
.PP
.Vb 3
\&        open my $tmp_fh, "<&", $original_fh or die "dup: $!";
\&        my $ls = new Proc::SafeExec({"exec" => ["ls"], "stdout" => $tmp_fh});
\&        # $tmp_fh is now closed.
.Ve
.PP
By default, \f(CW$command\fR\->\fBwait()\fR closes any new pipes opened in the constructor.
This is to prevent a deadlock where the child is waiting to read or write and
the parent is waiting for the child to exit. Pass no_close to \f(CW$command\fR\->\fBwait()\fR
to prevent this (see above). Also, by default the destructor calls
\&\f(CW$command\fR\->\fBwait()\fR if child hasn't finished. This is to prevent zombie processes
from inadvertently accumulating. To prevent this, pass no_autowait to the
constructor. The easiest way to wait for the child is to call the wait method,
but if you need more control, set no_autowait, then call child_pid to get the
\&\s-1PID\s0 and do the work yourself.
.PP
This will emit a warning if the child exits with a non-zero status, and the
caller didn't inspect the exit status, and the caller didn't specify
no_autowait (which may imply the exit status might not be meaningful). It's bad
practice not to inspect the exit status, and it's easy enough to quiet this
warning if you really don't want it by calling \f(CW$command\fR\->\fBexit_status()\fR and
discarding the result.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
It's easy to execute several programs to form a pipeline. For the first
program, specify \*(L"new\*(R" for stdout. Then execute the second one, and specify
stdout from the first one for the stdin of the second one. For example, here's
how to write the equivalent of system(\*(L"ls | sort > output.txt\*(R"):
.PP
.Vb 7
\&        open my $output_fh, ">", "output.txt" or die "output.txt: $!\en";
\&        my $ls = new Proc::SafeExec({"exec" => ["ls"], "stdout" => "new"});
\&        my $sort = new Proc::SafeExec({"exec" => ["sort"], "stdin" => $ls\->stdout(), "stdout" => $output_fh});
\&        $ls\->wait();
\&        $sort\->wait();
\&        printf "ls exited with status %i\en", ($ls\->exit_status() >> 8);
\&        printf "sort exited with status %i\en", ($sort\->exit_status() >> 8);
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
This module has no dependencies besides Perl itself. Follow your favorite
standard installation procedure.
.PP
To test the module, run the following command line:
.PP
.Vb 1
\&        $ perl \-e \*(Aquse Proc::SafeExec; print Proc::SafeExec::test();\*(Aq
.Ve
.SH "VERSION AND HISTORY"
.IX Header "VERSION AND HISTORY"
.IP "\(bu" 4
Version 1.5, released 2013\-06\-14. Fixed bug: Open /dev/null for \s-1STDIN
STDOUT STDERR\s0 instead of leaving closed when \*(L"close\*(R" is specified. Also,
recommend in doc to set \f(CW$SIG\fR{\*(L"\s-1CHLD\*(R"\s0} = \*(L"\s-1DEFAULT\*(R".\s0
.IP "\(bu" 4
Version 1.4, released 2008\-05\-30. Added \fBProc::SafeExec::backtick()\fR
function for convenience. Fixed a couple minor bugs in error handling (not
security related). Invalidate $? after reading it so callers must fetch the
exit status through \f(CW$self\fR\->\fBexit_status()\fR.
.IP "\(bu" 4
Version 1.3, released 2008\-03\-31. Added Proc::SafeExec::Queue. Emit a
warning when non-zero exit status, and the caller didn't inspect the exit
status, and the caller didn't specify no_autowait (which may imply the exit
status might not be meaningful).
.IP "\(bu" 4
Version 1.2, released 2008\-01\-22. Tweaked \fBtest()\fR to handle temp files
correctly, addressing https://rt.cpan.org/Ticket/Display.html?id=32458 .
.IP "\(bu" 4
Version 1.1, released 2008\-01\-09. Fixed obvious bug.
.IP "\(bu" 4
Version 1.0, released 2007\-05\-23.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The source repository is at git://git.devpit.org/Proc\-SafeExec/
.PP
See also Proc::SafeExec::Queue.
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Leif Pedersen, <bilbo@hobbiton.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 1
\& This may be distributed under the terms below (BSD\*(Aqish) or under the GPL.
\& 
\& Copyright (c) 2007
\& All Rights Reserved
\& Meridian Environmental Technology, Inc.
\& 4324 University Avenue, Grand Forks, ND 58203
\& http://meridian\-enviro.com
\& 
\& Redistribution and use in source and binary forms, with or without
\& modification, are permitted provided that the following conditions are
\& met:
\& 
\&  1. Redistributions of source code must retain the above copyright
\&     notice, this list of conditions and the following disclaimer.
\& 
\&  2. Redistributions in binary form must reproduce the above copyright
\&     notice, this list of conditions and the following disclaimer in the
\&     documentation and/or other materials provided with the
\&     distribution.
\& 
\& THIS SOFTWARE IS PROVIDED BY AUTHORS AND CONTRIBUTORS "AS IS" AND ANY
\& EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
\& IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
\& PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AUTHORS OR CONTRIBUTORS BE
\& LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
\& CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
\& SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
\& BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
\& WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
\& OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
\& ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
