.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Abstract 3"
.TH DBIx::Abstract 3 "2014-01-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Abstract \- DBI SQL abstraction
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use DBIx::Abstract;
\&  my $db = DBIx::Abstract\->connect({
\&    driver=>\*(Aqmydriver\*(Aq,
\&    host=>\*(Aqmyhost.org\*(Aq,
\&    dbname=>\*(Aqmydb\*(Aq,
\&    user=>\*(Aqmyuser\*(Aq,
\&    password=>\*(Aqmypassword\*(Aq,
\&    });
\&
\&  if ($db\->select(\*(Aq*\*(Aq,\*(Aqtable\*(Aq)\->rows) {
\&    while (my $data = $db\->fetchrow_hashref) {
\&      # ...
\&    }
\&  }
\&  
\&  my $id = 23;
\&
\&  my ($name) = $db\->select(\*(Aqname\*(Aq,\*(Aqtable\*(Aq,{id=>$id})\->fetchrow_array;
\&
\&  ###
\&  
\&  $db = DBIx::Abstract\->connect( { driver=>\*(Aqcsv\*(Aq, f_name=>\*(Aqfoo/\*(Aq } );
\&  
\&  ###
\&  
\&  $db = DBIx::Abstract\->connect({
\&    dsn=>\*(Aqdbi:someotherdb:so_db_name=mydb\*(Aq,
\&    user=>\*(Aqmyuser\*(Aq,
\&    password=>\*(Aqmypassword\*(Aq,
\&    });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods for doing manipulating database tables This
module provides methods retrieving and storing data in \s-1SQL\s0 databases.
It provides methods for all of the more important \s-1SQL\s0 commands (like
\&\s-1SELECT, INSERT, REPLACE, UPDATE, DELETE\s0).
.PP
It endeavors to produce an interface that will be intuitive to those already
familiar with \s-1SQL.\s0
.PP
Notable features include:
.PP
.Vb 8
\&  * data_source generation for some DBD drivers.
\&  * Can check to make sure the connection is not stale and reconnect
\&    if it is.
\&  * Controls statement handles for you.
\&  * Can delay writes.
\&  * Generates complex where clauses from hashes and arrays.
\&  * Shortcuts (convenience functions) for some common cases. (Like
\&    select_all_to_hashref.)
.Ve
.SH "DEPRICATED"
.IX Header "DEPRICATED"
We highly recommend that you use something like SQL::Abstract, which was
inspired by this module.  Or even DBIx::Class (which uses SQL::Abstract
for it's query syntax).  They're maintained and widely used.
.SH "METHODS"
.IX Header "METHODS"
Unless otherwise mentioned all methods return the database handle.
.SS "connect"
.IX Subsection "connect"
\&\f(CW\*(C`connect($connect_config | $dbihandle [,$options])\*(C'\fR \fI\s-1CONSTRUCTOR\s0\fR
.PP
Open a connection to a database as configured by \f(CW$connect_config\fR.
\&\f(CW$connect_config\fR can either be a scalar, in which case it is a \s-1DBI\s0 data
source, or a reference to a hash with the following keys:
.PP
.Vb 1
\& dsn      \-\- The data source to connect to your database
\& 
\& OR, DBIx::Abstract will try to generate it if you give these instead:
\&
\& driver   \-\- DBD driver to use (defaults to mysql)
\& host     \-\- Host of database server
\& port     \-\- Port of database server
\& dbname   \-\- Name of database
\&
\& Username and password are always valid.
\&
\& user     \-\- Username to connect as
\& password \-\- Password for user
.Ve
.PP
Alternatively you can pass in a \s-1DBI\s0 handle directly.  This will disable
the methods \*(L"reconnect\*(R" and \*(L"ensure_connection\*(R" as they rely on connection
info not available on a \s-1DBI\s0 handle.
.PP
Options is a hash reference.  Each key/value pair is passed on to the opt
method.
.SS "clone"
.IX Subsection "clone"
This clones the object.  For those times when you need a second
connection to the same \s-1DB.\s0  If you need a second connection to a
different \s-1DB,\s0 create a new object with 'connect'.
.PP
This operation is logged at level 5 with the message \*(L"Cloned.\*(R"
.SS "connected"
.IX Subsection "connected"
Check to see if this object is connected to a database.  It checks to see if
it has a database handle and if that handle's \*(L"Active\*(R" attribute is true.
.SS "reconnect"
.IX Subsection "reconnect"
If the object is not connected to a database it will reconnect using the
same parameters connect was originally called with.
.SS "ensure_connection"
.IX Subsection "ensure_connection"
Makes sure that the object is connect to a database.  Makes sure that the
connect is active (by sending a \*(L"\s-1SELECT 1\*(R"\s0).  If there is no connection, or
the connection is not active then it tries to reconnect.  If it fails to
reconnect then it dies.
.SS "opt"
.IX Subsection "opt"
($key[,$value])
.PP
({key=>$key[,value=>$value])
.PP
Set option \f(CW$key\fR to \f(CW$value\fR.  Available keys are:
.PP
.Vb 8
\&  loglevel (default 0)
\&      0 \-\- Fatal errors only
\&      1 \-\- Modifications
\&      2 \-\- And selects
\&      3 \-\- And user created queries
\&      4 \-\- And results of queries
\&      5 \-\- And other misc commands
\&      6 \-\- Internals of commands
\&
\&  logfile (default undef)
\&    Log file
\&
\&  delaymods (default false)
\&    Delay making modifications to the database until
\&    run_delayed is run.
\&    
\&  useCached
\&    If this is true then prepare_cached is used instead of prepare.
\&    Checkout the DBI documentation on this feature before using this
\&    feature.
\&
\&  saveSQL
\&    If this is true then with each query DBIx::Abstract will stuff the generated
\&    SQL into the \*(Aqlastsql\*(Aq key in the self payload.
\&
\&  Additionally you may use any valid DBI attribute.  So, for instance, you
\&  can pass AutoCommit or LongReadLen.
.Ve
.PP
This operation is logged at level 5 with the message \*(L"Option Change\*(R" and the
the key, the old value and new new value.
.SS "query"
.IX Subsection "query"
($sql,@bind_params)
.PP
({sql=>$sql,bind_params=>[@bind_params]})
.PP
This sends \f(CW$sql\fR to the database object's query method.  This should be used
for applications where the existing methods are not able to generate
flexible enough \s-1SQL\s0 for you.
.PP
If you find yourself using this very often with things other then table
manipulation (eg 'create table','alter table','drop table') then please let
me know so I can extend DBIx::Abstract to include the functionality you are using.
.PP
This operation is logged at level 3
.SS "run_delayed"
.IX Subsection "run_delayed"
Execute delayed update/insert/delete queries.
.PP
This operation is logged at level 5 with the message \*(L"Run delayed\*(R".
.SS "delete"
.IX Subsection "delete"
($table[,$where])
.PP
({table=>$table[,where=>$where]})
.PP
Deletes records from \f(CW$table\fR.  See also the documentation on 
\&\*(L"DBIx::Abstract Where Clauses\*(R".
.SS "insert"
.IX Subsection "insert"
($table,$fields)
.PP
({table=>$table,fields=>$fields})
.PP
\&\f(CW$table\fR is the name of the table to insert into.
.PP
\&\f(CW$fields\fR is either a reference to a hash of field name/value or
a scalar containing the \s-1SQL\s0 to insert after the \*(L"\s-1SET\*(R"\s0 portion of the statement.
.PP
These all produce functionally equivalent \s-1SQL.\s0
.PP
.Vb 4
\&  $db\->insert(\*(Aqfoo\*(Aq,{bar=>\*(Aqbaz\*(Aq});
\&  $db\->insert(\*(Aqfoo\*(Aq,q|bar=\*(Aqbaz\*(Aq|);
\&  $db\->insert({table=>\*(Aqfoo\*(Aq,fields=>{bar=>\*(Aqbaz\*(Aq}});
\&  $db\->insert({table=>\*(Aqfoo\*(Aq,fields=>q|bar=\*(Aqbaz\*(Aq|});
.Ve
.PP
We also support literals by making the value in the hash an arrayref:
.PP
.Vb 1
\&  $db\->insert(\*(Aqfoo\*(Aq,{name=>\*(Aqbar\*(Aq,date=>[\*(Aqsubstring(now(),1,10)\*(Aq]});
.Ve
.PP
Would generate something like this:
.PP
.Vb 1
\&  INSERT INTO foo (name,date) VALUES (?,substring(now(),1,10))
.Ve
.PP
With \*(L"bar\*(R" bound to the first parameter.
.SS "replace"
.IX Subsection "replace"
($table,$fields)
.PP
({table=>$table,fields=>$fields})
.PP
\&\f(CW$table\fR is the name of the table to replace into.
.PP
\&\f(CW$fields\fR is either a reference to a hash of field name/value or
a scalar containing the \s-1SQL\s0 to insert after the \*(L"\s-1SET\*(R"\s0 portion of the statement.
.PP
Replace works just like insert, except that if a record with the same
primary key already exists then the existing record is replaced, instead of
producing an error.
.SS "update"
.IX Subsection "update"
($table,$fields[,$where])
.PP
({table=>$table,fields=>$fields[,where=>$where]})
.PP
\&\f(CW$table\fR is the table to update.
.PP
\&\f(CW$fields\fR is a reference to a hash keyed on field name/new value.
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.SS "select"
.IX Subsection "select"
\&\f(CW\*(C`select\*(C'\fR
.PP
($fields,[$table,[$where[,$order]]])
.PP
({fields=>$fields,table=>$table[,where=>$where][,order=>$order][,join=>$join][,group=>$group]})
.PP
The select method returns the DBIx::Abstract object it was invoked with. 
This allows you to chain commands.
.PP
\&\f(CW$fields\fR can be either an array reference or a scalar.  If it is an array
reference then it should be a list of fields to include.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL\s0 after
\&\*(L"\s-1SELECT\*(R".\s0
.PP
\&\f(CW$table\fR can be either an array reference or a scalar. If it is an array
reference then it should be a list of tables to use.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL\s0 after
\&\*(L"\s-1FROM\*(R".\s0
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.PP
\&\f(CW$order\fR is the output order.  If it is a scalar then it is inserted
literally after \*(L"\s-1ORDER BY\*(R".\s0  If it is an arrayref then it is join'd with a
comma and inserted.
.PP
\&\f(CW$join\fR is there to make joining tables more convenient.  It will takes one or
more (as an arrayref) sets of statements to use when joining.  For instance:
.PP
.Vb 6
\&  $dbh\->select({
\&    fields=>\*(Aq*\*(Aq,
\&    table=>\*(Aqfoo,bar\*(Aq,
\&    join=>\*(Aqfoo.id=bar.foo_id\*(Aq,
\&    where=>{\*(Aqfoo.dollars\*(Aq,[\*(Aq>\*(Aq,30]}
\&    });
.Ve
.PP
Would produce:
.PP
.Vb 1
\&  SELECT * FROM foo,bar WHERE (foo.dollars > ?) and (foo.id=foo_id)
.Ve
.PP
And put 30 into the bind_params list.
.PP
\&\f(CW$group\fR is/are the field(s) to group by.  It may be scalar or an arrayref. 
If it is a scalar then it should be a literal to be inserted after \*(L"\s-1GROUP
BY\*(R".\s0  If it is an arrayref then it should be a list of fields to group on.
.SS "select_one_to_hashref"
.IX Subsection "select_one_to_hashref"
($fields,$table[,$where])
.PP
({fields=>$fields,table=>$table[,where=>$where]})
.PP
This returns a hashref to the first record returned by the select. 
Typically this should be used for cases when your where clause limits you to
one record anyway.
.PP
\&\f(CW$fields\fR is can be either a array reference or a scalar.  If it is an array
reference then it should be a list of fields to include.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL.\s0
.PP
\&\f(CW$table\fR is the table to select from.
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.SS "select_one_to_arrayref"
.IX Subsection "select_one_to_arrayref"
($fields,$table[,$where])
.PP
({fields=>$fields,table=>$table[,where=>$where]})
.PP
This returns a arrayref to the first record returned by the select. 
Typically this should be used for cases when your where clause limits you to
one record anyway.
.PP
\&\f(CW$fields\fR is can be either a array reference or a scalar.  If it is an array
reference then it should be a list of fields to include.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL.\s0
.PP
\&\f(CW$table\fR is the table to select from.
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.SS "select_one_to_array"
.IX Subsection "select_one_to_array"
($fields,$table[,$where])
.PP
({fields=>$fields,table=>$table[,where=>$where]})
.PP
This returns a array to the first record returned by the select. 
Typically this should be used for cases when your where clause limits you to
one record anyway.
.PP
\&\f(CW$fields\fR is can be either a array reference or a scalar.  If it is an array
reference then it should be a list of fields to include.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL.\s0
.PP
\&\f(CW$table\fR is the table to select from.
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.SS "select_all_to_hashref"
.IX Subsection "select_all_to_hashref"
($fields,$table[,$where])
.PP
({fields=>$fields,table=>$table[,where=>$where]})
.PP
This returns a hashref to all of the results of the select.  It is keyed on
the first field.  If there are only two fields then the value is just the
second field.  If there are more then two fields then the value is set to an
arrayref that contains all of the fields.
.PP
\&\f(CW$fields\fR is can be either a array reference or a scalar.  If it is an array
reference then it should be a list of fields to include.  If it is a scalar
then it should be a literal to be inserted into the generated \s-1SQL.\s0
.PP
\&\f(CW$table\fR is the table to select from.
.PP
See also the documentation on \*(L"DBIx::Abstract Where Clauses\*(R".
.SS "fetchrow_hashref"
.IX Subsection "fetchrow_hashref"
This is just a call to the \s-1DBI\s0 method.
.SS "fetchrow_hash"
.IX Subsection "fetchrow_hash"
This calls fetchrow_hashref and dereferences it for you.
.SS "fetchrow_array"
.IX Subsection "fetchrow_array"
This method calls the database handle's method of the same name.
.SS "fetchall_arrayref"
.IX Subsection "fetchall_arrayref"
This method calls the database handle's method of the same name.
.SS "rows"
.IX Subsection "rows"
This method calls the database handle's method of the same name.
.SS "quote"
.IX Subsection "quote"
This method is passed to the database handle via \s-1AUTOLOAD.\s0
.SS "disconnect"
.IX Subsection "disconnect"
This method is passed to the database handle via \s-1AUTOLOAD.\s0
.SS "commit"
.IX Subsection "commit"
This method is passed to the database handle via \s-1AUTOLOAD.\s0
.SS "rollback"
.IX Subsection "rollback"
This method is passed to the database handle via \s-1AUTOLOAD.\s0
.SS "trace"
.IX Subsection "trace"
This method is passed to the database handle via \s-1AUTOLOAD.\s0
.SS "finish"
.IX Subsection "finish"
This method is passed to the statement handle via \s-1AUTOLOAD.\s0
.SS "bind_col"
.IX Subsection "bind_col"
This method is passed to the statement handle via \s-1AUTOLOAD.\s0
.SS "bind_columns"
.IX Subsection "bind_columns"
This method is passed to the statement handle via \s-1AUTOLOAD.\s0
.SH "Other things that need explanation"
.IX Header "Other things that need explanation"
.SS "DBIx::Abstract Where Clauses"
.IX Subsection "DBIx::Abstract Where Clauses"
Where clauses in DBIx::Abstract can either be very simple, or highly complex.  They
are designed to be easy to use if you are just typing in a hard coded
statement or have to build a complex query from data.
.PP
Wheres are either a scalar, hash-ref or array-ref:
.PP
If it is a scalar, then it is used as the literal where.
.PP
If it is a hash-ref then the key is the field to check,
the value is either a literal value to compare equality to,
or an array-ref to an array of operator and value.
.PP
.Vb 5
\&  {
\&   first=>\*(Aqjoe\*(Aq,
\&   age=>[\*(Aq>\*(Aq,26],
\&   last=>[\*(Aqlike\*(Aq,q|b\*(Aq%|]
\&  }
.Ve
.PP
Would produce:
.PP
.Vb 1
\& WHERE first = ? AND last like ? AND age > ?
.Ve
.PP
With joe, b'% and 26 passed as bind values.
.PP
If it is an array-ref then it is an array of hash-refs and
connectors:
.PP
.Vb 10
\&  [
\&    {
\&      first=>\*(Aqjoe\*(Aq,
\&      age=>[\*(Aq>\*(Aq,26]
\&    },
\&    \*(AqOR\*(Aq,
\&    {
\&      last=>[\*(Aqlike\*(Aq,q|b\*(Aq%|]
\&    }
\&  ]
.Ve
.PP
Would produce:
.PP
.Vb 1
\& WHERE (first = ? AND age > ?) OR (last like ?)
.Ve
.PP
With joe, 26 and b'% passed as bind values.
.PP
.Vb 12
\&  [
\&    {
\&      first=>\*(Aqjoe\*(Aq,
\&      last=>[\*(Aqlike\*(Aq,\*(Aq%foo%\*(Aq],
\&    },
\&    \*(AqAND\*(Aq,
\&    [
\&      {age=>[\*(Aq>\*(Aq,26]},
\&      \*(AqOR\*(Aq,
\&      {age=>[\*(Aq<\*(Aq,30]}
\&    ]
\&  ]
.Ve
.PP
Would produce:
.PP
.Vb 1
\&  WHERE (first = ? AND last like ?) AND ((age > ?) OR (age < ?))
.Ve
.PP
With joe, \f(CW%foo\fR%, 26 and 30 passed as bind values.
.SH "SUPPORTED DBD DRIVERS"
.IX Header "SUPPORTED DBD DRIVERS"
These drivers have been reported to work:
.IP "\(bu" 4
mysql (development environment)
.IP "\(bu" 4
Pg (development environment)
.IP "\(bu" 4
Oracle
.IP "\(bu" 4
XBase
.SS ""
.IX Subsection ""
Any driver that uses \s-1ODBC\s0 syntax should work using the hash ref method. 
With other drivers you should pass the \s-1DBI\s0 data source instead (this method
will work with all drivers.)
.SH "CHANGES SINCE LAST RELEASE"
.IX Header "CHANGES SINCE LAST RELEASE"
.IP "\(bu" 2
Updated source pointers to github.
.IP "\(bu" 2
Fixed hash randomization related test failure
.SH "AUTHOR"
.IX Header "AUTHOR"
Rebecca Turner <me@re\-becca.org>
.SH "SOURCE"
.IX Header "SOURCE"
The development version is on github at <http://https://github.com/iarna/DBIx\-Abstract>
and may be cloned from <git://https://github.com/iarna/DBIx\-Abstract.git>
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Websites"
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP "\(bu" 4
MetaCPAN
.Sp
A modern, open-source \s-1CPAN\s0 search engine, useful to view \s-1POD\s0 in \s-1HTML\s0 format.
.Sp
<http://metacpan.org/release/DBIx\-Abstract>
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs at <https://github.com/iarna/DBIx\-Abstract/issues>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Rebecca Turner <me@re\-becca.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Portions copyright 2001\-2014 by Rebecca Turner
.PP
Portions copyright 2000\-2001 by Adelphia Business Solutions
.PP
Portions copyright 1998\-2000 by the Maine Internetworks (\s-1MINT\s0)
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.PP
\&\s-1\fBDBI\s0\fR\|(3)
