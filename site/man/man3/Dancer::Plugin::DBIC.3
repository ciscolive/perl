.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer::Plugin::DBIC 3"
.TH Dancer::Plugin::DBIC 3 "2015-11-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::Plugin::DBIC \- DBIx::Class interface for Dancer applications
.SH "VERSION"
.IX Header "VERSION"
version 0.2104
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Dancer;
\&    use Dancer::Plugin::DBIC qw(schema resultset rset);
\&
\&    get \*(Aq/users/:user_id\*(Aq => sub {
\&        my $user_id = param \*(Aquser_id\*(Aq;
\&        my $user;
\&
\&        # all of the following are equivalent:
\&        $user = schema(\*(Aqdefault\*(Aq)\->resultset(\*(AqUser\*(Aq)\->find($user_id);
\&        $user = schema\->resultset(\*(AqUser\*(Aq)\->find($user_id);
\&        $user = resultset(\*(AqUser\*(Aq)\->find($user_id);
\&        $user = rset(\*(AqUser\*(Aq)\->find($user_id);
\&
\&        template user_profile => {
\&            user => $user
\&        };
\&    };
\&
\&    dance;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This plugin makes it very easy to create Dancer applications that interface
with databases.
It automatically exports the keyword \f(CW\*(C`schema\*(C'\fR which returns a
DBIx::Class::Schema object.
You just need to configure your database connection information.
For performance, schema objects are cached in memory
and are lazy loaded the first time they are accessed.
.PP
This plugin is now just a thin wrapper around DBICx::Sugar.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
Configuration can be done in your Dancer config file.
.SS "simple example"
.IX Subsection "simple example"
Here is a simple example. It defines one database named \f(CW\*(C`default\*(C'\fR:
.PP
.Vb 5
\&    plugins:
\&      DBIC:
\&        default:
\&          dsn: dbi:SQLite:dbname=myapp.db
\&          schema_class: MyApp::Schema
.Ve
.SS "multiple schemas"
.IX Subsection "multiple schemas"
In this example, there are 2 databases configured named \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`foo\*(C'\fR:
.PP
.Vb 10
\&    plugins:
\&      DBIC:
\&        default:
\&          dsn: dbi:SQLite:dbname=myapp.db
\&          schema_class: MyApp::Schema
\&        foo:
\&          dsn: dbi:Pg:dbname=foo
\&          schema_class: Foo::Schema
\&          user: bob
\&          password: secret
\&          options:
\&            RaiseError: 1
\&            PrintError: 1
.Ve
.PP
Each database configured must at least have a dsn option.
The dsn option should be the \s-1DBI\s0 driver connection string.
All other options are optional.
.PP
If you only have one schema configured, or one of them is named
\&\f(CW\*(C`default\*(C'\fR, you can call \f(CW\*(C`schema\*(C'\fR without an argument to get the only
or \f(CW\*(C`default\*(C'\fR schema, respectively.
.PP
If a schema_class option is not provided, then DBIx::Class::Schema::Loader
will be used to dynamically load the schema by introspecting the database
corresponding to the dsn value.
You need DBIx::Class::Schema::Loader installed for this to work.
.PP
\&\s-1WARNING:\s0 Dynamic loading is not recommended for production environments.
It is almost always better to provide a schema_class option.
.PP
The schema_class option should be the name of your DBIx::Class::Schema class.
See \*(L"\s-1SCHEMA GENERATION\*(R"\s0
Optionally, a database configuration may have user, password, and options
parameters as described in the documentation for \f(CW\*(C`connect()\*(C'\fR in \s-1DBI\s0.
.SS "connect_info"
.IX Subsection "connect_info"
Alternatively, you may also declare your connection information inside an
array named \f(CW\*(C`connect_info\*(C'\fR:
.PP
.Vb 11
\&    plugins:
\&      DBIC:
\&        default:
\&          schema_class: MyApp::Schema
\&          connect_info:
\&            \- dbi:Pg:dbname=foo
\&            \- bob
\&            \- secret
\&            \-
\&              RaiseError: 1
\&              PrintError: 1
.Ve
.SS "replicated"
.IX Subsection "replicated"
You can also add database read slaves to your configuration with the
\&\f(CW\*(C`replicated\*(C'\fR config option.
This will automatically make your read queries go to a slave and your write
queries go to the master.
Keep in mind that this will require additional dependencies:
DBIx::Class::Optional::Dependencies#Storage::Replicated
See DBIx::Class::Storage::DBI::Replicated for more details.
Here is an example configuration that adds two read slaves:
.PP
.Vb 10
\&    plugins:
\&      DBIC:
\&        default:
\&          schema_class: MyApp::Schema
\&          dsn: dbi:Pg:dbname=master
\&          replicated:
\&            balancer_type: ::Random     # optional
\&            balancer_args:              # optional
\&                auto_validate_every: 5  # optional
\&                master_read_weight:1    # optional
\&            # pool_type and pool_args are also allowed and are also optional
\&            replicants:
\&              \-
\&                \- dbi:Pg:dbname=slave1
\&                \- user1
\&                \- password1
\&                \-
\&                  quote_names: 1
\&                  pg_enable_utf8: 1
\&              \-
\&                \- dbi:Pg:dbname=slave2
\&                \- user2
\&                \- password2
\&                \-
\&                  quote_names: 1
\&                  pg_enable_utf8: 1
.Ve
.SS "alias"
.IX Subsection "alias"
Schema aliases allow you to reference the same underlying database by multiple
names.
For example:
.PP
.Vb 7
\&    plugins:
\&      DBIC:
\&        default:
\&          dsn: dbi:Pg:dbname=master
\&          schema_class: MyApp::Schema
\&        slave1:
\&          alias: default
.Ve
.PP
Now you can access the default schema with \f(CW\*(C`schema()\*(C'\fR, \f(CW\*(C`schema(\*(Aqdefault\*(Aq)\*(C'\fR,
or \f(CW\*(C`schema(\*(Aqslave1\*(Aq)\*(C'\fR.
This can come in handy if, for example, you have master/slave replication in
your production environment but only a single database in your development
environment.
You can continue to reference \f(CW\*(C`schema(\*(Aqslave1\*(Aq)\*(C'\fR in your code in both
environments by simply creating a schema alias in your development.yml config
file, as shown above.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "schema"
.IX Subsection "schema"
.Vb 1
\&    my $user = schema\->resultset(\*(AqUser\*(Aq)\->find(\*(Aqbob\*(Aq);
.Ve
.PP
The \f(CW\*(C`schema\*(C'\fR keyword returns a DBIx::Class::Schema object ready for you to
use.
If you have configured only one database, then you can simply call \f(CW\*(C`schema\*(C'\fR
with no arguments.
If you have configured multiple databases,
you can still call \f(CW\*(C`schema\*(C'\fR with no arguments if there is a database
named \f(CW\*(C`default\*(C'\fR in the configuration.
With no argument, the \f(CW\*(C`default\*(C'\fR schema is returned.
Otherwise, you \fBmust\fR provide \f(CW\*(C`schema()\*(C'\fR with the name of the database:
.PP
.Vb 1
\&    my $user = schema(\*(Aqfoo\*(Aq)\->resultset(\*(AqUser\*(Aq)\->find(\*(Aqbob\*(Aq);
.Ve
.SS "resultset"
.IX Subsection "resultset"
This is a convenience method that will save you some typing.
Use this \fBonly\fR when accessing the \f(CW\*(C`default\*(C'\fR schema.
.PP
.Vb 1
\&    my $user = resultset(\*(AqUser\*(Aq)\->find(\*(Aqbob\*(Aq);
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    my $user = schema\->resultset(\*(AqUser\*(Aq)\->find(\*(Aqbob\*(Aq);
.Ve
.SS "rset"
.IX Subsection "rset"
.Vb 1
\&    my $user = rset(\*(AqUser\*(Aq)\->find(\*(Aqbob\*(Aq);
.Ve
.PP
This is simply an alias for \f(CW\*(C`resultset\*(C'\fR.
.SH "SCHEMA GENERATION"
.IX Header "SCHEMA GENERATION"
Setting the schema_class option and having proper DBIx::Class classes
is the recommended approach for performance and stability.
You can use the dbicdump command line tool provided by
DBIx::Class::Schema::Loader to help you.
For example, if your app were named Foo, then you could run the following
from the root of your project directory:
.PP
.Vb 1
\&    dbicdump \-o dump_directory=./lib Foo::Schema dbi:SQLite:/path/to/foo.db
.Ve
.PP
For this example, your \f(CW\*(C`schema_class\*(C'\fR setting would be \f(CW\*(AqFoo::Schema\*(Aq\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
DBICx::Sugar
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Alexis Sukrieh <sukria@sukria.net>
.IP "\(bu" 4
Dagfinn Ilmari Mannsåker <<https://github.com/ilmari>>
.IP "\(bu" 4
David Precious <davidp@preshweb.co.uk>
.IP "\(bu" 4
Fabrice Gabolde <<https://github.com/fgabolde>>
.IP "\(bu" 4
Franck Cuny <franck@lumberjaph.net>
.IP "\(bu" 4
Steven Humphrey <<https://github.com/shumphrey>>
.IP "\(bu" 4
Yanick Champoux <<https://github.com/yanick>>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Al Newkirk <awncorp@cpan.org>
.IP "\(bu" 4
Naveed Massjouni <naveed@vt.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by awncorp.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
