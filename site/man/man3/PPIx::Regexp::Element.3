.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPIx::Regexp::Element 3"
.TH PPIx::Regexp::Element 3 "2020-10-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPIx::Regexp::Element \- Base of the PPIx::Regexp hierarchy.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
No user-serviceable parts inside.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`PPIx::Regexp::Element\*(C'\fR is not descended from any other class.
.PP
\&\f(CW\*(C`PPIx::Regexp::Element\*(C'\fR is the parent of
PPIx::Regexp::Node and
PPIx::Regexp::Token.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is the base of the PPIx::Regexp
object hierarchy. It provides the same kind of navigational
functionality that is provided by PPI::Element.
.SH "METHODS"
.IX Header "METHODS"
This class provides the following public methods. Methods not documented
here are private, and unsupported in the sense that the author reserves
the right to change or remove them without notice.
.SS "accepts_perl"
.IX Subsection "accepts_perl"
.Vb 2
\& $token\->accepts_perl( \*(Aq5.020\*(Aq )
\&     and say \*(AqThis works under Perl 5.20\*(Aq;
.Ve
.PP
This method returns a true value if the token is acceptable under the
specified version of Perl, and a false value otherwise. Unless the token
(or its contents) have been equivocated on, the result is simply what
you would expect based on testing the results of
\&\fBperl_version_introduced()\fR and
\&\fBperl_version_removed()\fR versus the given Perl
version number.
.PP
This method was added in version 0.051_01.
.SS "ancestor_of"
.IX Subsection "ancestor_of"
This method returns true if the object is an ancestor of the argument,
and false otherwise. By the definition of this method, \f(CW$self\fR is its
own ancestor.
.SS "can_be_quantified"
.IX Subsection "can_be_quantified"
.Vb 2
\& $token\->can_be_quantified()
\&     and print "This element can be quantified.\en";
.Ve
.PP
This method returns true if the element can be quantified.
.SS "class"
.IX Subsection "class"
This method returns the class name of the element. It is the same as
\&\f(CW\*(C`ref $self\*(C'\fR.
.SS "column_number"
.IX Subsection "column_number"
This method returns the column number of the first character in the
element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "comment"
.IX Subsection "comment"
This method returns true if the element is a comment and false
otherwise.
.SS "content"
.IX Subsection "content"
This method returns the content of the element.
.SS "descendant_of"
.IX Subsection "descendant_of"
This method returns true if the object is a descendant of the argument,
and false otherwise. By the definition of this method, \f(CW$self\fR is its
own descendant.
.SS "explain"
.IX Subsection "explain"
This method returns a brief explanation of what the element does. The
return will be either a string or \f(CW\*(C`undef\*(C'\fR in scalar context, but may be
multiple values or an empty array in list context.
.PP
This method should be considered experimental. What it returns may
change without notice as my understanding of what all the pieces/parts
of a Perl regular expression evolves. The worst case is that it will
prove entirely infeasible to implement satisfactorily, in which case it
will be put through a deprecation cycle and retracted.
.SS "error"
.IX Subsection "error"
.Vb 1
\& say $token\->error();
.Ve
.PP
If an element is one of the classes that represents a parse error, this
method \fBmay\fR return a brief message saying why. Otherwise it will
return \f(CW\*(C`undef\*(C'\fR.
.SS "is_matcher"
.IX Subsection "is_matcher"
This method reports on whether the element potentially matches
something. Possible returns are a true value if it does, a false (but
defined) value if it does not, or \f(CW\*(C`undef\*(C'\fR if this can not be
determined.
.PP
The idea is to classify elements based on whether they potentially match
something in the target string.
.PP
This method is overridden to return \f(CW\*(C`undef\*(C'\fR in
PPIx::Regexp::Token::Code,
PPIx::Regexp::Token::Interpolation, and
PPIx::Regexp::Token::Unknown.
.PP
This method is overridden to return a true value in
PPIx::Regexp::Token::Assertion,
PPIx::Regexp::Token::CharClass,
PPIx::Regexp::Token::Literal,
and
PPIx::Regexp::Token::Reference.
.PP
For PPIx::Regexp::Node, this method is
overridden to return a value computed from the node's children.
.PP
For anything else this method returns a false (but defined) value.
.SS "in_regex_set"
.IX Subsection "in_regex_set"
This method returns a true value if the invocant is contained in an
extended bracketed character class (also known as a regex set), and a
false value otherwise. This method returns true if the invocant is a
PPIx::Regexp::Structure::RegexSet.
.SS "is_quantifier"
.IX Subsection "is_quantifier"
.Vb 2
\& $token\->is_quantifier()
\&     and print "This element is a quantifier.\en";
.Ve
.PP
This method returns true if the element is a quantifier. You can not
tell this from the element's class, because a right curly bracket may
represent a quantifier for the purposes of figuring out whether a
greediness token is possible.
.SS "line_number"
.IX Subsection "line_number"
This method returns the line number of the first character in the
element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "location"
.IX Subsection "location"
This method returns a reference to an array describing the position of
the element in the regular expression, or \f(CW\*(C`undef\*(C'\fR if locations were not
indexed.
.PP
The array is compatible with the corresponding
PPI::Element method.
.SS "logical_filename"
.IX Subsection "logical_filename"
This method returns the logical file name (taking \f(CW\*(C`#line\*(C'\fR directives
into account) of the file containing first character in the element, or
\&\f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "logical_line_number"
.IX Subsection "logical_line_number"
This method returns the logical line number (taking \f(CW\*(C`#line\*(C'\fR directives
into account) of the first character in the element, or \f(CW\*(C`undef\*(C'\fR if that
can not be determined.
.SS "main_structure"
.IX Subsection "main_structure"
This method returns the
PPIx::Regexp::Structure::Main that
contains the element. In practice this will be a
PPIx::Regexp::Structure::Regexp or a
PPIx::Regexp::Structure::Replacement,
.PP
If the element is not contained in any such structure, \f(CW\*(C`undef\*(C'\fR is
returned. This will happen if the element is a
PPIx::Regexp or one of its immediate children.
.SS "modifier_asserted"
.IX Subsection "modifier_asserted"
.Vb 2
\& $token\->modifier_asserted( \*(Aqi\*(Aq )
\&     and print "Matched without regard to case.\en";
.Ve
.PP
This method returns true if the given modifier is in effect for the
element, and false otherwise.
.PP
What it does is to walk backwards from the element until it finds a
modifier object that specifies the modifier, whether asserted or
negated. and returns the specified value. If nobody specifies the
modifier, it returns \f(CW\*(C`undef\*(C'\fR.
.PP
This method will not work reliably if called on tokenizer output.
.SS "next_element"
.IX Subsection "next_element"
This method returns the next element, or nothing if there is none.
.PP
Unlike \fBnext_sibling()\fR, this will cross from the content
of a structure into the elements that define the structure, or vice
versa.
.SS "next_sibling"
.IX Subsection "next_sibling"
This method returns the element's next sibling, or nothing if there is
none.
.SS "next_token"
.IX Subsection "next_token"
This method returns the next token, or nothing if there is none.
.PP
Unlike \fBnext_element()\fR, this will walk the parse tree.
.SS "parent"
.IX Subsection "parent"
This method returns the parent of the element, or undef if there is
none.
.SS "perl_version_introduced"
.IX Subsection "perl_version_introduced"
This method returns the version of Perl in which the element was
introduced. This will be at least 5.000. Before 5.006 I am relying on
the \fIperldelta\fR, \fIperlre\fR, and \fIperlop\fR documentation, since I have
been unable to build earlier Perls. Since I have found no documentation
before 5.003, I assume that anything found in 5.003 is also in 5.000.
.PP
Since this all depends on my ability to read and understand masses of
documentation, the results of this method should be viewed with caution,
if not downright skepticism.
.PP
There are also cases which are ambiguous in various ways. For those see
the PPIx::Regexp documentation, particularly
Changes in Syntax.
.PP
Very occasionally, a construct will be removed and then added back. If
this happens, this method will return the \fBlowest\fR version in which the
construct appeared. For the known instances of this, see
the PPIx::Regexp documentation, particularly
Equivocation.
.SS "perl_version_removed"
.IX Subsection "perl_version_removed"
This method returns the version of Perl in which the element was
removed. If the element is still valid the return is \f(CW\*(C`undef\*(C'\fR.
.PP
All the \fIcaveats\fR to
\&\fBperl_version_introduced()\fR apply here also,
though perhaps less severely since although many features have been
introduced since 5.0, few have been removed.
.PP
Very occasionally, a construct will be removed and then added back. If
this happens, this method will return the \f(CW\*(C`undef\*(C'\fR if the construct is
present in the highest-numbered version of Perl (whether production or
development), or the version after the highest-numbered version in which
it appeared otherwise. For the known instances of this, see the
PPIx::Regexp documentation, particularly
Equivocation.
.SS "previous_element"
.IX Subsection "previous_element"
This method returns the previous element, or nothing if there is none.
.PP
Unlike \fBprevious_sibling()\fR, this will cross from
the content of a structure into the elements that define the structure,
or vice versa.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
This method returns the element's previous sibling, or nothing if there
is none.
.PP
This method is analogous to the same-named PPI::Element
method, in that it will not cross from the content of a structure into
the elements that define the structure.
.SS "previous_token"
.IX Subsection "previous_token"
This method returns the previous token, or nothing if there is none.
.PP
Unlike \fBprevious_element()\fR, this will walk the parse tree.
.SS "remove_insignificant"
.IX Subsection "remove_insignificant"
This method returns a new object manufactured from the invocant, but
containing only elements for which \f(CW\*(C`$elem\->significant()\*(C'\fR returns a
true value.
.PP
If you call this method on a PPIx::Regexp::Node
you will get back a deep clone, but without the insignificant elements.
.PP
If you call this method on any other PPIx::Regexp class
you will get back either the invocant or nothing. This may change to a
clone of the invocant or nothing if unforseen problems arise with
returning the invocant, or if objects become mutable (unlikely, but not
impossible.)
.SS "requirements_for_perl"
.IX Subsection "requirements_for_perl"
.Vb 1
\& say $token\->requirements_for_perl();
.Ve
.PP
This method returns a string representing the Perl requirements for a
given module. This should only be used for informational purposes, as
the format of the string may be subject to change.
.PP
At the moment, the returns may be:
.PP
.Vb 4
\& version <= $]
\& version <= $] < version
\& two or more of the above joined by \*(Aq||\*(Aq
\& ! $]
.Ve
.PP
The last means that, although all the components of the regular
expression can be compiled by \fBsome\fR version of Perl, there is no
version that will compile all of them.
.PP
I reiterate: the returned string may be subject to change, maybe without
warning.
.PP
This method was added in version 0.051_01.
.SS "scontent"
.IX Subsection "scontent"
This method returns the significant content of the element. That is, if
called on the parse of \f(CW\*(Aq/ f u b a r /x\*(Aq\fR, it returns \f(CW\*(Aq/fubar/x\*(Aq\fR. If
the invocant contains no insignificant elements, it is the same as
\&\fBcontent()\fR. If called on an insignificant element, it returns
nothing \*(-- that is, \f(CW\*(C`undef\*(C'\fR in scalar context, and an empty list in
list context.
.PP
This method was inspired by jb's question on Perl Monks about stripping
comments and white space from a regular expression:
<https://www.perlmonks.org/?node_id=1207556>
.PP
This method was added in version 0.053_01
.SS "significant"
.IX Subsection "significant"
This method returns true if the element is significant and false
otherwise.
.SS "snext_element"
.IX Subsection "snext_element"
This method returns the next significant element, or nothing if
there is none.
.PP
Unlike \fBsnext_sibling()\fR, this will cross from
the content of a structure into the elements that define the structure,
or vice versa.
.SS "snext_sibling"
.IX Subsection "snext_sibling"
This method returns the element's next significant sibling, or nothing
if there is none.
.PP
This method is analogous to the same-named PPI::Element
method, in that it will not cross from the content of a structure into
the elements that define the structure.
.SS "sprevious_element"
.IX Subsection "sprevious_element"
This method returns the previous significant element, or nothing if
there is none.
.PP
Unlike \fBsprevious_sibling()\fR, this will cross from
the content of a structure into the elements that define the structure,
or vice versa.
.SS "sprevious_sibling"
.IX Subsection "sprevious_sibling"
This method returns the element's previous significant sibling, or
nothing if there is none.
.PP
This method is analogous to the same-named PPI::Element
method, in that it will not cross from the content of a structure into
the elements that define the structure.
.SS "statement"
.IX Subsection "statement"
This method returns the PPI::Statement that contains
this element, or nothing if the statement can not be determined.
.PP
In general this method will return something only under the following
conditions:
.IP "\(bu" 4
The element is contained in a PPIx::Regexp object;
.IP "\(bu" 4
That object was initialized from a PPI::Element;
.IP "\(bu" 4
The PPI::Element is contained in a statement.
.SS "tokens"
.IX Subsection "tokens"
This method returns all tokens contained in the element.
.SS "top"
.IX Subsection "top"
This method returns the top of the hierarchy.
.SS "unescaped_content"
.IX Subsection "unescaped_content"
This method returns the content of the element, unescaped.
.SS "visual_column_number"
.IX Subsection "visual_column_number"
This method returns the visual column number (taking tabs into account)
of the first character in the element, or \f(CW\*(C`undef\*(C'\fR if that can not be
determined.
.SS "whitespace"
.IX Subsection "whitespace"
This method returns true if the element is whitespace and false
otherwise.
.SS "nav"
.IX Subsection "nav"
This method returns navigation information from the top of the hierarchy
to this node. The return is a list of names of methods and references to
their argument lists. The idea is that given \f(CW$elem\fR which is somewhere
under \f(CW$top\fR,
.PP
.Vb 9
\& my @nav = $elem\->nav();
\& my $obj = $top;
\& while ( @nav ) {
\&     my $method = shift @nav;
\&     my $args = shift @nav;
\&     $obj = $obj\->$method( @{ $args } ) or die;
\& }
\& # At this point, $obj should contain the same object
\& # as $elem.
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Support is by the author. Please file bug reports at
<https://rt.cpan.org>, or in electronic mail to the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas R. Wyant, \s-1III\s0 \fIwyant at cpan dot org\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009\-2020 by Thomas R. Wyant, \s-1III\s0
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.10.0. For more details, see the full text
of the licenses in the directory \s-1LICENSES.\s0
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
