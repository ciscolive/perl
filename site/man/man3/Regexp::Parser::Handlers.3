.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Regexp::Parser::Handlers 3"
.TH Regexp::Parser::Handlers 3 "2017-09-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Parser::Handlers \- handlers for Perl 5 regexes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module holds the \fBinit()\fR method for the \fIRegexp::Parser\fR class,
which installs all the handlers for standard Perl 5 regexes.  This
documentation contains a sub-classing tutorial.
.SH "SUB-CLASSING"
.IX Header "SUB-CLASSING"
I will present two example sub-classes, \fIRegexp::NoCode\fR, and
\&\fIRegexp::AndBranch\fR.
.SS "Parser Internals"
.IX Subsection "Parser Internals"
The parser object is a hash reference with the following keys:
.IP "regex" 4
.IX Item "regex"
A reference to the original string representation of the regex.
.IP "len" 4
.IX Item "len"
The length of the original string representation of the regex.
.IP "tree" 4
.IX Item "tree"
During the first pass, \f(CW\*(C`tree\*(C'\fR is undef, which instructs the \fBobject()\fR
method not to actually create any objects.  Afterwards, it is an array
reference of (node) objects.
.IP "stack" 4
.IX Item "stack"
Initially an array reference, used to store the tree as a new scope is
entered and then exited.  The general concept is:
.Sp
.Vb 7
\&  if (into_scope) {
\&    push STACK, TREE;
\&    TREE = CURRENT\->DATA;
\&  }
\&  if (outof_scope) {
\&    TREE = pop STACK;
\&  }
.Ve
.Sp
After the tree has been created, this key is deleted; this gives the
code a way to be sure compilation was successful.
.IP "maxpar" 4
.IX Item "maxpar"
The highest number of parentheses.  It will end up being identical to
\&\f(CW\*(C`nparen\*(C'\fR, but it is incremented during the initial pass, so that on
the second pass (the tree-building), it can distinguish back-references
from octal escapes.  (The source code to Perl's regex compiler does the
same thing.)
.IP "nparen" 4
.IX Item "nparen"
The number of OPENs (capturing groups) in the regex.
.IP "captures" 4
.IX Item "captures"
An array reference to the 'open' nodes.
.IP "flags" 4
.IX Item "flags"
An array reference of flag values.  When a scope is entered, the top
value is copied and pushed onto the stack.  When a scope is left, the
top value is popped and discarded.
.Sp
It is important to do this copy-and-push before you do any flag-parsing,
if you're adding a handle that might parse flags, because you do not
want to accidentally affect the previous scope's flag values.
.Sp
Here is example code from the handler for \f(CW\*(C`(?ismx)\*(C'\fR and \f(CW\*(C`(?ismx:...)\*(C'\fR:
.Sp
.Vb 2
\&  # (?i:...) <\-\- the \*(Aqi\*(Aq is only inside the (?:...)
\&  # (?i)     <\-\- the \*(Aqi\*(Aq affects the rest of this scope
\&
\&  # so if we\*(Aqre a (?:...), copy\-and\-push
\&  if ($type eq \*(Aqgroup\*(Aq) {
\&    push @{ $S\->{flags} }, &Rf;
\&    push @{ $S\->{next} }, qw< c) atom >;
\&  }
\&
\&  for (split //, $on) {
\&    if (my $h = $S\->can("FLAG_$_")) {
\&      my $v = $h\->(1);       # 1 means this is \*(Aqon\*(Aq
\&      if ($v) { &Rf |= $v }  # turn the flag on
\&      else { ... }           # the flag\*(Aqs value is 0
\&      next;
\&    }
\&    # throw an error if the flag isn\*(Aqt supported
\&  }
\&
\&  for (map "FLAG_$_", split //, $off) {
\&    if (my $h = $S\->can("FLAG_$_")) {
\&      my $v = $h\->(0);        # 0 means this is \*(Aqoff\*(Aq
\&      if ($v) { &Rf &= ~$v }  # turn the flag off
\&      else { ... }            # the flag\*(Aqs value is 0
\&      next;
\&    }
\&    # throw an error if the flag isn\*(Aqt supported
\&  }
.Ve
.Sp
You'll probably not be adding handlers that have to parse flags, but if
you do, remember to follow this model correctly.
.IP "next" 4
.IX Item "next"
An array reference of what handles (or \*(L"rules\*(R") to try to match next.
.SS "Devices and Standards"
.IX Subsection "Devices and Standards"
I made a few C\-macro-style functions for easy access to the parser
object's most important attributes:
.PP
.Vb 3
\&  # access to the regex
\&    # reference to the regex string
\&    sub Rx :lvalue          { $_[0]{regex} }
\&
\&    # the position in the regex string
\&    sub RxPOS :lvalue       { pos ${&Rx} }
\&
\&    # the regex string from the current position on
\&    sub RxCUR               { substr ${&Rx}, &RxPOS }
\&
\&    # the length of the regex string
\&    sub RxLEN               { $_[0]{len} }
\&
\&  # access to the flag stack
\&    # the top flag value
\&    sub Rf :lvalue          { $_[0]{flags}[\-1] }
\&
\&  # access to the tree
\&    # is this the first pass?
\&    sub SIZE_ONLY           { ! $_[0]{tree} }
\&
\&    # the most recent addition to the tree
\&    sub LATEST :lvalue      { $_[0]{tree}[\-1] }
.Ve
.PP
You may find it helpful to copy these to your sub-class.  If you're
curious why the \f(CW\*(C`regex\*(C'\fR value is a reference, and thus why I'm using
\&\f(CW\*(C`${&Rx}\*(C'\fR everywhere, it's because an lvalued subroutine returning a
normal scalar doesn't work quite right with a regex that's supposed to
update its target's \f(CW\*(C`pos()\*(C'\fR.  This method, where it returns a
\&\fIreference\fR to a scalar, makes it work (!).
.PP
\&\fBThese functions can only work if called with ampersands, and only if
the parser object is the first value in \f(CB@_\fB.\fR  I made sure of this in
my code; you should make sure in yours.
.PP
Matching against the regex is done in scalar context, globally, like so:
.PP
.Vb 3
\&  if (${&Rx} =~ m{ \eG pattern }xgc) {
\&    # it matched
\&  }
.Ve
.PP
If the match fails, the \f(CW\*(C`pos()\*(C'\fR value won't be reset (due to the \f(CW\*(C`/c\*(C'\fR
modifier).  Remember to use \fIscalar\fR context.  If you need to access
capture groups, use the digit variables, but only if you're sure the
match succeeded.
.SS "Parser Methods"
.IX Subsection "Parser Methods"
.ie n .IP "my $obj = $parser\->object(\s-1TYPE\s0 => \s-1ARGS...\s0)" 4
.el .IP "my \f(CW$obj\fR = \f(CW$parser\fR\->object(\s-1TYPE\s0 => \s-1ARGS...\s0)" 4
.IX Item "my $obj = $parser->object(TYPE => ARGS...)"
This creates a node of package \f(CW\*(C`TYPE\*(C'\fR and sends the constructor whatever
other arguments are included.  This method takes care of building the
proper inheritance for the node; it uses \f(CW%Regexp::Parser::loaded\fR to keep
track of which object classes have been loaded already.
.ie n .IP "$parser\->\fBinit()\fR" 4
.el .IP "\f(CW$parser\fR\->\fBinit()\fR" 4
.IX Item "$parser->init()"
This method installs all the flags and handlers.  \fIRegexp::Parser\fR does
this automatically, but if you are sub-classing it, you'll probably want
to call it in your own module.
.Sp
.Vb 2
\&  package Regexp::AndBranch;
\&  use base \*(AqRegexp::Parser\*(Aq;
\&
\&  sub init {
\&    my $self = shift;
\&
\&    # installs Regexp::Parser\*(Aqs handlers
\&    $self\->SUPER::init();
\&
\&    # now add your own...
\&    $self\->add_handler(\*(Aq&\*(Aq => ...);  # see below
\&  }
.Ve
.ie n .IP "$parser\->add_flag($flag, $code)" 4
.el .IP "\f(CW$parser\fR\->add_flag($flag, \f(CW$code\fR)" 4
.IX Item "$parser->add_flag($flag, $code)"
This method creates a method of the parser \f(CW\*(C`FLAG_$flag\*(C'\fR, and sets it to
the code reference in \f(CW$code\fR.  Example:
.Sp
.Vb 1
\&  $parser\->add_flag("u" => sub { 0x10 });
.Ve
.Sp
This makes 'u' a valid flag for your regex, and creates the method
\&\f(CW\*(C`FLAG_u\*(C'\fR.  This doesn't mean you can use them on \f(CW\*(C`qr//\*(C'\fR, but rather
that you can write \f(CW\*(C`(?u:...)\*(C'\fR or \f(CW\*(C`(?u)\*(C'\fR.  The values 0x01, 0x02, 0x04,
and 0x08 are used for \f(CW\*(C`/m\*(C'\fR, \f(CW\*(C`/s\*(C'\fR, \f(CW\*(C`/i\*(C'\fR, and \f(CW\*(C`/x\*(C'\fR in Perl's regexes.
.Sp
The flag handler gets the parser object and a boolean as arguments.
The boolean is true if the flag is going to be turned on, and false if
it's going to be turned off.  For \f(CW\*(C`(?i\-s)\*(C'\fR, \f(CW\*(C`FLAG_i\*(C'\fR would be called
with a true argument, and \f(CW\*(C`FLAG_s\*(C'\fR would be called with a false one.
.Sp
If the flag handler returns 0, the flag is removed from the resulting
object's visual flag set, so \f(CW\*(C`(?ig\-o)\*(C'\fR becomes \f(CW\*(C`(?i)\*(C'\fR.
.ie n .IP "$parser\->del_flag(@flags)" 4
.el .IP "\f(CW$parser\fR\->del_flag(@flags)" 4
.IX Item "$parser->del_flag(@flags)"
Deletes the handlers for the flags \*(-- you need only pass the flag names,
without the \*(L"\s-1FLAG_\*(R"\s0 prefix.
.ie n .IP "$parser\->add_handler($seq, $code)" 4
.el .IP "\f(CW$parser\fR\->add_handler($seq, \f(CW$code\fR)" 4
.IX Item "$parser->add_handler($seq, $code)"
This method creates a method of the parser named \f(CW$seq\fR, and set it to
the code reference in \f(CW$code\fR.  Example:
.Sp
.Vb 4
\&  # continuing from above...
\&  sub init {
\&    my $self = shift;
\&    $self\->SUPER::init();
\&
\&    $self\->add_handler(\*(Aq&\*(Aq => sub {
\&      # $S will be the Regexp::AndBranch object, $self
\&      my ($S) = @_;
\&      push @{ $S\->{next} }, qw< atom >;
\&      return $S\->object(\*(Aqand\*(Aq);
\&    });
\&  }
.Ve
.Sp
There is a specific scheme to how you must name your handlers.  If you
want to install a handler for '&&', you must first install a handler for
\&'&' that calls the handler for '&&' if it can consume an ampersand.
Handle names that have no \*(L"predecessor\*(R" (that is, a '&&' without a '&')
are pre-consumption: that is, they have not matched something yet.
Handle names that \fIdo\fR have a \*(L"predecessor\*(R" (that is, a '&&' with a
\&'&') are post-consumption: they have already matched what they are
named.
.Sp
The handle 'atom' is pre-consumptive (because there is no 'ato' handle,
basically).  In order for the 'atom' handle to be executed, you must
explicitly add it to the queue (\f(CW\*(C`$parser\->{next}\*(C'\fR).
.Sp
The handle '|' is post-consumptive.  It happens to be executed when
\&'atom' matches a '|'.  This means the handler for '|' does not need
to match it; it has already been consumed.
.Sp
If you created a handle for '&&' without a predecessor, you would have
to add it explicity to the queue for it to ever be executed.  As such,
it would be pre-consumptive.
.Sp
There is an interesting case of the right parenthesis ')'.  There cannot
be one without a matching left parenthesis '('; if there is an extra ')'
a fatal error is thrown.  However, the nature of 'atom' is to match a
character, see if there's a handler installed, and call it if there is.
I don't want atom to handle ')', so the handler is:
.Sp
.Vb 6
\&  $self\->add_handler(\*(Aq)\*(Aq => sub {
\&    my ($S) = @_;
\&    pop @{ $S\->{next} };  # there was an \*(Aqatom\*(Aq there
\&    &RxPOS\-\-;             # this does pos(regex)\-\-
\&    return;
\&  });
.Ve
.Sp
This handler un-consumes the ')' (via \f(CW\*(C`&RxPOS\-\-\*(C'\fR) and returns false, to
pretend it didn't actually match.  The real closing parenthesis handler
is:
.Sp
.Vb 6
\&  $self\->add_handler(\*(Aqc)\*(Aq => sub {
\&    my ($S) = @_;
\&    $S\->error($S\->RPe_LPAREN) if ${&Rx} !~ m{ \eG \e) }xgc;
\&    pop @{ $S\->{flags} };
\&    return $S\->object(close =>);
\&  });
.Ve
.Sp
The name is 'c)' which has no predecessor 'c', so that means it is
pre-consumptive, which is why it must match the right parenthesis
itself.  The handler throws an error if it can't match the ')', because
if the 'c)' handler gets called, it's expected to match!  It pops the
flag stack, and returns an object.
.Sp
Finally, if you want to add a new \s-1POSIX\s0 character class, its handler
must start with \*(L"\s-1POSIX_\*(R".\s0
.ie n .IP "$parser\->del_handler(@handle_names)" 4
.el .IP "\f(CW$parser\fR\->del_handler(@handle_names)" 4
.IX Item "$parser->del_handler(@handle_names)"
This uninstalls the given handles.  You send the names (like '|' or
\&'atom').  Here is a very simple complete sub-class that does not allow
the \f(CW\*(C`(?{ ... })\*(C'\fR and \f(CW\*(C`(??{ ... })\*(C'\fR assertions:
.Sp
.Vb 2
\&  package Regexp::NoCode;
\&  use base \*(AqRegexp::Parser\*(Aq;
\&
\&  sub init {
\&    my $self = shift;
\&    $self\->SUPER::init();
\&    $self\->del_handler(qw<
\&      (?{   (??{   (?p{
\&    >);
\&  }
.Ve
.Sp
For those of you that don't know, \f(CW\*(C`(?p{ ... })\*(C'\fR is a synonym for the
more common \f(CW\*(C`(??{ ... })\*(C'\fR.  Using the 'p' form is deprecated, but is
still allowed, so I delete its handler too.  You can use this class to
ensure that there is are no code-execution statements in a regex:
.Sp
.Vb 2
\&  use Regexp::NoCode;
\&  my $p = Regexp::NoCode\->new;
\&
\&  # if it failed, reject it how you choose
\&  if (! $p\->regex($regex)) {
\&    reject_regex(...);
\&  }
.Ve
.Sp
Any regex containing those assertions will fail to compile and throw an
error (specifically, \fBRPe_NOTREC\fR, \*(L"Sequence (?xx not recognized\*(R").  If
you want to throw your own error, see \*(L"\s-1ERROR HANDLING\*(R"\s0.
.SS "Walking an Object"
.IX Subsection "Walking an Object"
Most objects inherit their \fBender()\fR and \fBwalk()\fR methods from the base
object class; most have no ending node, and most don't need to to do
anything to the walking stack.
.PP
When an object does have an ending node, its \fBender()\fR method should
return an array reference of arguments to \fBobject()\fR that will produce
its ending node:
.PP
.Vb 5
\&  # the \*(Aqopen\*(Aq node\*(Aqs ender:
\&  sub ender {
\&    my $self = shift;
\&    [ \*(Aqclose\*(Aq, $self\->nparen ];
\&  }
.Ve
.PP
That means that when an 'open' node is walked into, after it has
been \fBwalk()\fRed, it will insert the matching 'close' node into the
walking stack.
.PP
The purpose of adding an ending node to the walking stack is that ending
nodes are all omitted from the tree because of the stacked nature of the
tree.  However, having them returned while \fIwalking\fR the tree is
helpful.
.PP
The \fBwalk()\fR method is used to modify the walking stack before the node
is returned.  Here is the \fBwalk()\fR method for all the quantifier and
\&'minmod' nodes:
.PP
.Vb 9
\&  # star, plus, curly, minmod
\&  sub walk {
\&    my ($self, $walk_stack, $depth) = @_;
\&    unshift(@$walk_stack,
\&      sub { \-1 },
\&      $self\->{data},
\&      sub { +1 },
\&    ) if $depth;
\&  }
.Ve
.PP
The two additional arguments sent are the walking stack and the current
depth in the walking stack.  Elements are taken from the \fIfront\fR of the
walking stack, so we add them in the order they are to be encountered
with \fBunshift()\fR.  The two code references are used to go deeper and
shallower in scope; \f(CW\*(C`sub { \-1 }\*(C'\fR is used to go down into a deeper
scope, and \f(CW\*(C`sub{ +1 }\*(C'\fR is used to come up out of it.  In between these
is \f(CW\*(C`$self\->{data}\*(C'\fR, which is the node's child.
.SS "Creating an Object"
.IX Subsection "Creating an Object"
Ok, back to our \fIRegexp::AndBranch\fR example.  Let me explain what the
\&'&' metacharacter will mean.  If you've used \fIvim\fR, you might know
about its '\e&' regex assertion.  It's an \*(L"\s-1AND\*(R",\s0 much like '|' is an
\&\*(L"\s-1OR\*(R".\s0  The vim regex \f(CW\*(C`/x\e&y/\*(C'\fR means "match \fIy\fR if \fIx\fR can be matched
at the same location".  Therefore it would be represented in Perl with a
look-ahead around the left-hand branch: \f(CW\*(C`/(?=x)y/\*(C'\fR.  We can expand this
to any number of branches: \f(CW\*(C`/a\e&b\e&c\e&d/\*(C'\fR in vim would be
\&\f(CW\*(C`/(?=a)(?=b)(?=c)d/\*(C'\fR in Perl.  We will support this with the '&'
metacharacter.
.PP
We have added a handler for the '&' metacharacter, but now we need to
write the supporting class for the \fIRegexp::AndBranch::and\fR object it
creates!
.PP
A method call for a \fIRegexp::MyRx::THING\fR object will look in its own
package first, then in \fIRegexp::MyRx::_\|_object_\|_\fR (if it exists), then
in \fIRegexp::Parser::THING\fR (if it exists), and finally in
\&\fIRegexp::Parser::_\|_object_\|_\fR.
.PP
Here is the definition of \fIRegexp::AndBranch::and\fR:
.PP
.Vb 2
\&  package Regexp::AndBranch::and;
\&  @ISA = qw( Regexp::Parser::branch );
\&
\&  sub new {
\&    my ($class, $rx) = @_;
\&    my $self = bless {
\&      rx => $rx,
\&      flags => $rx\->{flags}[\-1],
\&      data => [ [] ],
\&      family => \*(Aqbranch\*(Aq,
\&      type => \*(Aqand\*(Aq,
\&      raw => \*(Aq&\*(Aq,
\&      branch => 1,
\&    }, $class;
\&    return $self;
\&  }
.Ve
.PP
We inherit the \fBmerge()\fR method defined in \fIRegexp::Parser::branch\fR,
which is used when two of the same node are matched in succession.  We
also inherit \fBvisual()\fRZ and \fBwalk()\fR.
.PP
However, we need to define our own \fBqr()\fR method, because we don't want
to have &'s in our \fIreal\fR regex.  We need to convert \f(CW\*(C`A&B&C\*(C'\fR to
\&\f(CW\*(C`(?=A)(?=B)C\*(C'\fR.
.PP
.Vb 4
\&  # still in Regexp::AndBranch::and
\&  sub qr {
\&    my ($self) = @_;
\&    my @kids = @{ $self\->{data} };
.Ve
.PP
Here, \f(CW@kids\fR is an array that holds array references; each of those array
references is the body of one and-branch.  We will take the last one off
and keep it normal, but the others we will make to be look-aheads.  To
make an object, we need to access \f(CW\*(C`$self\->{rx}\*(C'\fR.
.PP
.Vb 4
\&    my $consume = pop @kids;
\&    for (@kids) {
\&      $_ = $self\->{rx}\->object(ifmatch => 1, @$_);
\&    }
.Ve
.PP
The 'ifmatch' object is a positive looking assertion, and the argument
of 1 means it's a look-ahead.  We send the unrolled contents of the
array reference as the contents of the look-ahead, and we're done.  Now
we just need to return the regex representation of our children:
.PP
.Vb 4
\&    return join "",
\&      map($_\->qr, @kids),
\&      map($_\->qr, @$consume);
\&  }
.Ve
.PP
Here's a sample execution:
.PP
.Vb 2
\&  use Regexp::AndBranch;
\&  my $parser = Regexp::AndBranch\->new;
\&
\&  # matches the first number found in a string
\&  # that contains \*(Aqfoo\*(Aq somewhere init
\&  my $rx = q{^.*foo&\eD*(\ed+)};
\&
\&  $parser\->regex($rx) or die $parser\->errmsg;
\&  print "VISUAL: ", $parser\->visual, "\en";
\&  print "REGEX:  ", $parser\->qr, "\en";
.Ve
.PP
Here's the output:
.PP
.Vb 2
\&  VISUAL: ^(?:.*foo&\eD*(\ed+))
\&  REGEX:  (?\-xism:^(?:(?=.*foo)\eD*(\ed+)))
.Ve
.SS "Extending the Extension"
.IX Subsection "Extending the Extension"
Here's a final example.  I'm going to rewrite \fIRegexp::AndBranch\fR to
handle both '&' and '!'.  '!' will indicate a negative look-ahead.
.PP
.Vb 2
\&  package Regexp::AndBranch;
\&  use base \*(AqRegexp::Parser\*(Aq;
\&
\&  sub init {
\&    my $self = shift;
\&    $self\->SUPER::init();
\&
\&    # X&Y = match Y if match X at the same place
\&    $self\->add_handler(\*(Aq&\*(Aq => sub {
\&      my ($S) = @_;
\&      push @{ $S\->{next} }, qw< atom >;
\&      return $S\->object(and => 1);
\&    });
\&
\&    # X!Y = match Y unless match X at the same place
\&    $self\->add_handler(\*(Aq!\*(Aq => sub {
\&      my ($S) = @_;
\&      push @{ $S\->{next} }, qw< atom >;
\&      return $S\->object(and => 0);
\&    });
\&  }
.Ve
.PP
We've added a handler, and added an argument to the constructor.  The
argument is a true or false value determining whether this is a positive
assertion.  Here's the new class for the object:
.PP
.Vb 2
\&  package Regexp::AndBranch::and;
\&  @ISA = qw( Regexp::Parser::branch );
\&
\&  sub new {
\&    my ($class, $rx, $pos) = @_;
\&    my $self = bless {
\&      rx => $rx,
\&      flags => $rx\->{flags}[\-1],
\&      data => [ [] ],
\&      family => \*(Aqbranch\*(Aq,
\&      branch => 1,
\&      neg => !$pos,
\&    }, $class;
\&    return $self;
\&  }
.Ve
.PP
We've added a \f(CW\*(C`neg\*(C'\fR attribute, and removed both \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`raw\*(C'\fR.  We
will replace them with methods:
.PP
.Vb 4
\&  sub raw {
\&    my $self = shift;
\&    $self\->{neg} ? \*(Aq!\*(Aq : \*(Aq&\*(Aq;
\&  }
\&
\&  sub type {
\&    my $self = shift;
\&    $self\->{neg} ? \*(Aqnot\*(Aq : \*(Aqand\*(Aq;
\&  }
.Ve
.PP
And finally, the small change to the \fBqr()\fR method:
.PP
.Vb 5
\&  sub qr {
\&    my ($self) = @_;
\&    my @kids = @{ $self\->{data} };
\&    my $consume = pop @kids;
\&    my $type = $self\->{neg} ? \*(Aqunlessm\*(Aq : \*(Aqifmatch\*(Aq;
\&
\&    for (@kids) {
\&      $_ = $self\->{rx}\->object($type => 1, @$_);
\&    }
\&
\&    return join "",
\&      map($_\->qr, @kids),
\&      map($_\->qr, @$consume);
\&  }
.Ve
.PP
Here's a sample run:
.PP
.Vb 2
\&  use Regexp::AndBranch;
\&  my $parser = Regexp::AndBranch\->new;
\&
\&  my @RX = (
\&    q{^(?:.*foo&\eD*(\ed+))},
\&    q{^(?:.*foo!\eD*(\ed+))},
\&  );
\&
\&  for (@RX) {
\&    $parser\->regex($_) or die $parser\->errmsg;
\&    print "VISUAL: ", $parser\->visual, "\en";
\&    print "REGEX:  ", $parser\->qr, "\en";
\&  }
.Ve
.PP
The output is:
.PP
.Vb 4
\&  VISUAL: ^(?:.*foo&\eD*(\ed+))
\&  REGEX:  (?\-xism:^(?:(?=.*foo)\eD*(\ed+)))
\&  VISUAL: ^(?:.*foo!\eD*(\ed+))
\&  REGEX:  (?\-xism:^(?:(?!.*foo)\eD*(\ed+)))
.Ve
.PP
Presto!
.SS "Escape Sequences"
.IX Subsection "Escape Sequences"
If you are creating a new escape sequence, like '\ey', your handler will
receive an additional argument which tells it if it's inside a character
class.
.PP
.Vb 9
\&  $parser\->add_handler(\*(Aq\ey\*(Aq => sub {
\&    my ($S, $cc) = @_;
\&    if ($cc) {
\&      # character class specific code
\&    }
\&    else {
\&      # elsewhere
\&    }
\&  });
.Ve
.SS "Character Classes"
.IX Subsection "Character Classes"
Character classes are not returned all at once, but piece by piece.
Because range checking (\f(CW\*(C`[a\-z]\*(C'\fR) requires knowledge of the characters
on the lower and upper side of the range, objects must be created during
the first pass.  To accomplish this, use \fBforce_object()\fR, which creates
an object regardless of what pass it's on.
.PP
.Vb 11
\&  $parser\->add_handler(\*(Aq\ey\*(Aq => sub {
\&    my ($S, $cc) = @_;
\&    if ($cc) {
\&      # so that $S\->object(...) creates an object:
\&      $S\->warn($S\->RPe_BADESC, "y", " in character class");
\&      return $S\->force_object(exact => "y");
\&    }
\&    else {
\&      # ...
\&    }
\&  });
.Ve
.PP
Also note the \f(CW\*(C`RPe_BADESC\*(C'\fR warning takes two arguments: the character
that was unexpectedly escaped, and a string.  If the warning is called
from a character class, pass \*(L" in character class\*(R"; otherwise, pass an
empty string.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
.SS "Creating Custom Messages"
.IX Subsection "Creating Custom Messages"
It is probably easiest to follow my module when creating warning and
error messages for your sub-class.
.PP
.Vb 4
\&  package Your::SubClass;
\&  # use constant NAME => VALUE, FMTSTRING
\&  use constant err_FOOBAR => 1, \*(AqYou broke the %s\*(Aq;
\&  use constant err_TOOBIG => 2, \*(AqRegex too large\*(Aq;
.Ve
.PP
Then you can access them via \f(CW\*(C`$parser\->err_FOOBAR\*(C'\fR, etc.
.SS "Throwing Warnings and Errors"
.IX Subsection "Throwing Warnings and Errors"
There are three methods you can use when a problem arises.  They use
\&\fBCarp::carp()\fR or \fBCarp::croak()\fR.  The argument list is used to fill in
the format string for \fBsprintf()\fR.
.ie n .IP "$parser\->warn($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.el .IP "\f(CW$parser\fR\->warn($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.IX Item "$parser->warn($parser->RPe_ERRMSG, ARGS...)"
Throws a warning \fIonly\fR during the first pass over the regex.
.ie n .IP "$parser\->awarn($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.el .IP "\f(CW$parser\fR\->awarn($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.IX Item "$parser->awarn($parser->RPe_ERRMSG, ARGS...)"
Unconditionally throws a warning.  Primarily useful when you need to
throw a warning that can only be figured out the second pass.
.ie n .IP "$parser\->error($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.el .IP "\f(CW$parser\fR\->error($parser\->RPe_ERRMSG, \s-1ARGS...\s0)" 4
.IX Item "$parser->error($parser->RPe_ERRMSG, ARGS...)"
Throws a fatal error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Parser, Regexp::Parser::Objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeff \f(CW\*(C`japhy\*(C'\fR Pinyan, \fIjaphy@perlmonk.org\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Jeff Pinyan \fIjaphy@perlmonk.org\fR. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
