.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Future::AsyncAwait::Awaitable 3"
.TH Future::AsyncAwait::Awaitable 3 "2020-10-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Future::AsyncAwait::Awaitable" \- the interface required by "Future::AsyncAwait"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module documents the method interface required by \f(CW\*(C`Future::AsyncAwait\*(C'\fR
to operate on future instances returned by expressions invoked by the \f(CW\*(C`await\*(C'\fR
keyword, and returned by functions declared by \f(CW\*(C`async sub\*(C'\fR. This information
is largely of relevance to implementors of other module integrations, event
systems, or similar. It is not necessary to make regular use of the syntax
provided by the module when working with existing event systems.
.PP
The methods required by this interface are all capitalised and prefixed with
\&\f(CW\*(C`AWAIT_...\*(C'\fR, ensuring they are unlikely to clash with existing methods on a
class which may have differing semantics.
.SS "Role::Tiny"
.IX Subsection "Role::Tiny"
If Role::Tiny is available, this module declares itself to be a role that
requires the following named methods. The role supplies no code to the applied
class, but can be useful for checking that you have in fact implemented all of
the required methods.
.SS "Conformance Test"
.IX Subsection "Conformance Test"
To assist implementors of alternative future-like classes, an \s-1API\s0 conformance
test suite is provided by Test::Future::AsyncAwait::Awaitable. You may find
this useful to check that your implementation is suitable.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
The following methods are expected to create new future instances. They make
use of the class set by the prevailing \f(CW\*(C`future_class\*(C'\fR import argument, if
set, or default to \f(CW\*(C`Future\*(C'\fR if not.
.SS "\s-1AWAIT_NEW_DONE\s0"
.IX Subsection "AWAIT_NEW_DONE"
Generate a new immediate future that is successful. The future will already be
ready and have the list of values set as its result.
.PP
.Vb 1
\&   $f = $CLASS\->AWAIT_NEW_DONE( @results )
\&
\&   # $f\->AWAIT_IS_READY will be true
\&   # $f\->AWAIT_GET will return @results
.Ve
.SS "\s-1AWAIT_NEW_FAIL\s0"
.IX Subsection "AWAIT_NEW_FAIL"
Generate a new immediate future that is failed. The future will already be
ready and invoking the \*(L"\s-1AWAIT_GET\*(R"\s0 method will throw the given exception.
.PP
.Vb 1
\&   $f = $CLASS\->AWAIT_NEW_FAIL( $message )
\&
\&   # $f\->AWAIT_IS_READY will be true
\&   # $f\->AWAIT_GET will throw $message
.Ve
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "\s-1AWAIT_CLONE\s0"
.IX Subsection "AWAIT_CLONE"
Generate a new pending future of the same type as an existing one, which is
not modified by doing so. It will only be invoked on instances that are
currently pending.
.PP
.Vb 1
\&   $new_f = $f\->AWAIT_CLONE
.Ve
.PP
If the instance has any fields that are required for successful operation
(such as application-wide context or event system components) these ought to
be copied. The method should not otherwise copy any per-instance state such
as pending callbacks or partial results.
.SS "\s-1AWAIT_DONE\s0"
.IX Subsection "AWAIT_DONE"
Sets the success result of an existing still-pending future. It will only be
invoked on future instances that are currently pending.
.PP
.Vb 1
\&   $f\->AWAIT_DONE( @results )
\&
\&   # $f\->AWAIT_IS_READY will now be true
\&   # $f\->AWAIT_GET will now return @results
.Ve
.SS "\s-1AWAIT_FAIL\s0"
.IX Subsection "AWAIT_FAIL"
Sets the failure result of an existing still-pending future. It will only be
invoked on future instances that are currently pending.
.PP
.Vb 1
\&   $f\->AWAIT_FAIL( $message )
\&
\&   # $f\->AWAIT_IS_READY will now be true
\&   # $f\->AWAIT_GET will now throw $message
.Ve
.SS "\s-1AWAIT_IS_READY\s0"
.IX Subsection "AWAIT_IS_READY"
Returns true if a future is ready (successful, failed or cancelled); false if
still pending.
.PP
.Vb 1
\&   $bool = $f\->AWAIT_IS_READY
.Ve
.SS "\s-1AWAIT_IS_CANCELLED\s0"
.IX Subsection "AWAIT_IS_CANCELLED"
Returns true is a future has already been cancelled; false if still pending,
successful or failed.
.PP
.Vb 1
\&   $bool = $f\->AWAIT_IS_CANCELLED
.Ve
.PP
An implementation that does not support cancellation can simply return a
constant false here:
.PP
.Vb 1
\&   sub AWAIT_IS_CANCELLED { 0 }
.Ve
.SS "\s-1AWAIT_GET\s0"
.IX Subsection "AWAIT_GET"
Yields the result of a successful future (or just the first value if called in
scalar context). Throws the failure message as an exception if called on a a
failed one. Will not be invoked on a pending or cancelled future.
.PP
.Vb 3
\&   @result = $f\->AWAIT_GET
\&   $result = $f\->AWAIT_GET
\&   $f\->AWAIT_GET
.Ve
.SS "\s-1AWAIT_ON_READY\s0"
.IX Subsection "AWAIT_ON_READY"
Attach a new \s-1CODE\s0 reference to be invoked when the future becomes ready (by
success or failure). The arguments and context that \f(CW$code\fR is invoked with
are unspecified.
.PP
.Vb 1
\&   $f\->AWAIT_ON_READY( $code )
.Ve
.SS "\s-1AWAIT_ON_CANCEL\s0"
.IX Subsection "AWAIT_ON_CANCEL"
Attach a future instance to be cancelled when another one is cancelled.
.PP
.Vb 1
\&   $f1\->AWAIT_ON_CANCEL( $f2 )
.Ve
.PP
When \f(CW$f1\fR is cancelled, then \f(CW$f2\fR is cancelled. There is no link from
\&\f(CW$f2\fR back to \f(CW$f1\fR \- whenever \f(CW$f2\fR changes state here, nothing special
happens to \f(CW$f1\fR.
.PP
An implementation that does not support cancellation can simply ignore this
method.
.PP
.Vb 1
\&   sub AWAIT_ON_CANCEL { }
.Ve
.PP
A newer version of this \s-1API\s0 specification will rename this to
\&\f(CW\*(C`AWAIT_CHAIN_CANCEL\*(C'\fR, so it is a good idea to alias the method under both
names for now.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
