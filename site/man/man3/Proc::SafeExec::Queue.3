.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Proc::SafeExec::Queue 3"
.TH Proc::SafeExec::Queue 3 "2013-06-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::SafeExec::Queue \- Uses Proc::SafeExec to manage a group of concurrent processes.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        use Proc::SafeExec::Queue;
\&        my $queue = Proc::SafeExec::Queue\->new({
\&                "soft_limit" => 4,  # Default is 4.
\&                "hard_limit" => 8,  # Default is soft_limit * 2.
\&        });
.Ve
.PP
To add a task to the queue:
.PP
.Vb 10
\&        my $id = $queue\->add({
\&                # Options describing when to execute.
\&                "exec_order" => 1,  # Default is 1.
\&                "callback_prefork" => \e&callback_prefork,  # Default is undef.
\&                "callback_postfork" => \e&callback_postfork,  # Default is undef.
\&                "callback_postwait" => \e&callback_postwait,  # Default is undef.
\&                "callback_error" => \e&callback_error,  # Default is undef.
\&                "exec" => {
\&                        # Options to new Proc::SafeExec.
\&                },
\&                "data" => {
\&                        # Space for the caller to store any ancillary information, for example, to be
\&                        # used in the callback functions.
\&                },
\&        });
.Ve
.PP
To cancel a task before it starts (okay during prefork):
.PP
.Vb 1
\&        $queue\->cancel($id);
.Ve
.PP
To wait on exited children and begin executing pending children:
.PP
.Vb 1
\&        my $did_something = $queue\->do_events();
.Ve
.PP
To get a list of children that haven't finished yet:
.PP
.Vb 1
\&        my @list = $queue\->remaining_children();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Proc::SafeExec::Queue provides a way of managing a group of concurrent
processes.
.PP
Here's a logical description of what happens. Processes are added to the queue
and execute when appropriate. The parent can enqueue them and forget about
them. Immediately before a child executes, before forking, the prerun function
executes. Immediately after a child is waited on, the postrun function
executes.
.PP
This decides when to execute a child based on exec_order, soft_limit, and
hard_limit. The exec_order option describes the ideal order the children should
be executed in, however, it's not strictly enforced, since children may be
added with a lower exec_order after one with a higher exec_order began
execution. When a new child is added to the queue, it always begins executing
immediately if there are fewer than soft_limit already executing. Otherwise,
it begins executing only if the number of children with an exec_order lower or
equal to the new child is lower than soft_limit and there are fewer than
hard_limit children executing. The number of children will never exceed
hard_limit. Whenever a child exits, this checks the queue to see if any more
should be started. If there is a tie when deciding which child to execute next,
the first one added to the queue wins.
.PP
Note that setting soft_limit to undef or greater than hard_limit is the same as
setting it to the same value as hard_limit, and both must be an integer greater
than zero. exec_order may be any numerical value, including negative and
floating point values (although it may be most intuitive to limit it to
integers greater than zero). Setting soft_limit or hard_limit to 0 means
infinity, but this can be dangerous because no computer can handle an infinite
number of processes.
.SH "USAGE"
.IX Header "USAGE"
The parent should call \f(CW$queue\fR\->\fBdo_events()\fR whenever it receives \s-1SIGCHLD,\s0 but
should never call it directly from the signal handler, because signal handlers
may be invoked at times when it is not safe to do anything but set a variable.
It is safe to call \f(CW$queue\fR\->\fBdo_events()\fR when there is nothing to do. Thus,
alternatively to trapping \s-1SIGCHLD,\s0 the parent may simply call
\&\f(CW$queue\fR\->\fBdo_events()\fR whenever it is convenient, such as at the beginning of an
event loop. If you choose to do this, consider the loop:
.PP
.Vb 1
\&        1 while $queue\->do_events();
.Ve
.PP
This is not the default because it starve the parent of time to do other work.
.PP
\&\f(CW$queue\fR\->\fBdo_events()\fR first waits on any children that exited and calls the
associated callback_postwait functions, then for each child scheduled for
execution, it calls the associated callback_prefork function, executes it, and
calls the associated callback_postfork function. If there is an error executing
a child, it calls callback_error; callback_postfork and callback_postwait are
never called. callback_prefork, callback_postfork, and callback_postwait may be
undef to indicate a null-op. If callback_error is set to undef and an error
occurs, a warning is issued via \fBwarn()\fR.
.PP
\&\f(CW$queue\fR\->\fBadd()\fR adds a child to the queue and, if appropriate, begins executing
it. It returns a unique \s-1ID\s0 representing the child.
.PP
The callback functions always receive the original options hash that was passed
to \f(CW$queue\fR\->\fBadd()\fR, with some additional elements. The callback functions can
inspect this hash to find out some things about the child, however this hash is
not to be meddled with, except as documented here. If you need to associate
your own information with the child, use the \*(L"data\*(R" subhash, which is entirely
reserved for the caller's use and may be modified at any time.
.PP
If the child began execution, the element \*(L"Proc::SafeExec\*(R" is set to the
Proc::SafeExec object. (This is always set in callback_postfork and
callback_postwait, never in callback_prefork, and sometimes in callback_error.)
The query methods of Proc::SafeExec may be called, specifically child_pid,
stdin, stdout, stderr, exit_status. The caller may \fBnot\fR call the wait method
because it affects the execution state. If an error occurred, the element
\&\*(L"error\*(R" is set to $@ for the duration of the callback_error function. The \*(L"id\*(R"
element is always set to the unique \s-1ID\s0 assigned to this child. The
callback_prefork function may modify the exec hash.
.PP
The method \f(CW$queue\fR\->\fBcancel()\fR removes a child from the queue, but only if it
hasn't started yet. This may be called during callback_prefork, but no later.
.PP
The method \f(CW$queue\fR\->\fBremaining_children()\fR returns the hashes of the children
remaining in the queue (including those that are running). (These are the same
hashes that are passed to the callback functions.) They're listed in the order
they would be started if none were running yet. The ones that are running might
not be the first ones in the list if the exec_order decreased in the sequence
that children were added.
.PP
When used as documented, this module never has an error to report directly to
the caller; all errors are reported through callback_error functions. If it
does die, there's a good chance the bug or misuse will leave things in an
inconsistent state that can't be recovered from automatically. This may be
worth improving.
.PP
\&\s-1XXX:\s0 What to do with running children when the queue is destroyed?
.SH "CAVEATS"
.IX Header "CAVEATS"
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.SH "VERSION AND HISTORY"
.IX Header "VERSION AND HISTORY"
See Proc::SafeExec.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See also Proc::SafeExec, the package containing this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Leif Pedersen, <bilbo@hobbiton.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 1
\& This may be distributed under the terms below (BSD\*(Aqish) or under the GPL.
\& 
\& Copyright (c) 2007
\& All Rights Reserved
\& Meridian Environmental Technology, Inc.
\& 4324 University Avenue, Grand Forks, ND 58203
\& http://meridian\-enviro.com
\& 
\& Redistribution and use in source and binary forms, with or without
\& modification, are permitted provided that the following conditions are
\& met:
\& 
\&  1. Redistributions of source code must retain the above copyright
\&     notice, this list of conditions and the following disclaimer.
\& 
\&  2. Redistributions in binary form must reproduce the above copyright
\&     notice, this list of conditions and the following disclaimer in the
\&     documentation and/or other materials provided with the
\&     distribution.
\& 
\& THIS SOFTWARE IS PROVIDED BY AUTHORS AND CONTRIBUTORS "AS IS" AND ANY
\& EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
\& IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
\& PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AUTHORS OR CONTRIBUTORS BE
\& LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
\& CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
\& SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
\& BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
\& WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
\& OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
\& ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
