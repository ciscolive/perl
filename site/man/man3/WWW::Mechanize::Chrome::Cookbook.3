.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::Mechanize::Chrome::Cookbook 3"
.TH WWW::Mechanize::Chrome::Cookbook 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::Mechanize::Chrome::Cookbook \- Getting things done with WWW::Mechanize::Chrome
.SH "Chrome versions"
.IX Header "Chrome versions"
You can find various current Chrome builds at
<https://chromium.woolyss.com/> .
.PP
The recommended approach to automation is to save a Chrome / Chromium version
and disable automatic updates so you can update at a defined point in time
instead and keep the change to your automation under control.
.SH "Web Application Testing with Chrome"
.IX Header "Web Application Testing with Chrome"
.SS "Rationale"
.IX Subsection "Rationale"
If you have an application with complex Javascript, you may want to do end to
end tests using WWW::Mechanize::Chrome. You can run your server application and
your test program in the same process if your server application can be run
under \s-1PSGI,\s0 as most web frameworks do.
.PP
Having all data within one process makes it very easy to fudge configuration
values or database entries at just the right time.
.SS "Initializing the web server in your test script"
.IX Subsection "Initializing the web server in your test script"
You will need to use a \s-1PSGI\s0 web server written in Perl that supports event
loops also supported by WWW::Mechanize::Chrome. Twiggy is one such server.
The setup for Twiggy is as follows:
.PP
.Vb 2
\&  use Twiggy::Server;
\&  use File::Temp \*(Aqtempdir\*(Aq;
\&
\&  my $port = 5099;
\&  my $server = Twiggy::Server\->new(
\&      host => \*(Aq127.0.0.1\*(Aq,
\&      port => $port,
\&  );
\&
\&  # Dancer specific parts
\&  $ENV{DANCER_APPHANDLER} = \*(AqDancer::Handler::PSGI\*(Aq;
\&  my $handler = Dancer::Handler\->get_handler();
\&  Dancer::_load_app(\*(AqApp::mykeep\*(Aq);
\&  my $app = $handler\->psgi_app();
\&
\&  # Rest of Twiggy setup
\&  $server\->register_service($app);
\&
\&  # Fudge the config as appropriate for our test
\&  Dancer::config()\->{mykeep}\->{notes_dir} = tempdir(
\&      CLEANUP => 1,
\&  );
\&
\&  my $mech = WWW::Mechanize::Chrome\->new(
\&  );
\&  my $res = $mech\->get("http://127.0.0.1:$port");
\&  ok $res\->is_success, "We can request the page";
.Ve
.SH "Debugging Headless Sessions"
.IX Header "Debugging Headless Sessions"
If you want to watch what a headless browser automation run is doing, you can
do so by sending a screencast from WWW::Mechanize::Chrome to a different browser
that supports websockets by using Mojolicious::Plugin::PNGCast from within
your automation session:
.PP
.Vb 4
\&    use Mojolicious::Lite;
\&    use Mojo::Server::Daemon;
\&    use WWW::Mechanize::Chrome;
\&    plugin \*(AqPNGCast\*(Aq;
\&
\&    my $daemon_url = \*(Aqhttp://localhost:3000\*(Aq;
\&
\&    my $ws_monitor = Mojo::Server::Daemon\->new(app => app());
\&    $ws_monitor\->listen([$daemon_url]);
\&    $ws_monitor\->start;
\&
\&    my $mech = WWW::Mechanize::Chrome\->new( headless => 1 );
\&    $mech\->setScreenFrameCallback( sub {
\&        app\->send_frame( $_[1]\->{data} )}
\&    );
\&
\&    print "Watch progress at $daemon_url\en";
\&    sleep 5;
\&
\&    $mech\->get(\*(Aqhttps://example.com\*(Aq);
\&    # ... more automation
.Ve
.PP
This will send the progress of your headless session to your browser so you can
see the differences between what you expect and what the browser displays.
.SH "Listing all requests made by a page"
.IX Header "Listing all requests made by a page"
Sometimes you want to block a single class of requests, or just list what
requests a page makes. This is supported since Chrome 80 or so.
.PP
.Vb 5
\&    $mech\->target\->send_message(\*(AqFetch.enable\*(Aq)\->get;
\&    my $request_listener = $mech\->add_listener(\*(AqFetch.requestPaused\*(Aq, sub {
\&        my( $info ) = @_;
\&        my $id = $info\->{params}\->{requestId};
\&        my $request = $info\->{params}\->{request};
\&
\&        if( $request\->{url} =~ /\e.html(\e?.*)?$/ ) {
\&            $mech\->target\->send_message(\*(AqFetch.continueRequest\*(Aq, requestId => $id, )\->retain;
\&            return;
\&        } else{
\&            diag "Ignored $request\->{url}";
\&            $mech\->target\->send_message(\*(AqFetch.failRequest\*(Aq, requestId => $id, errorReason => \*(AqAddressUnreachable\*(Aq );
\&        };
\&    });
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Detecting Chrome Headless <http://antoinevastel.github.io/bot%20detection/2018/01/17/detect-chrome-headless-v2.html>
.PP
Making Chrome Headless Undetectable <https://intoli.com/blog/making-chrome-headless-undetectable/>
.PP
Chrome Headless Detection <https://github.com/paulirish/headless-cat-n-mouse>
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/www\-mechanize\-chrome>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is <https://perlmonks.org/>.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-Chrome>
or via mail to www\-mechanize\-Chrome\-Bugs@rt.cpan.org <mailto:www-mechanize-Chrome-Bugs@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2010\-2020 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
