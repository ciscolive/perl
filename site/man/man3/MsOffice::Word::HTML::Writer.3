.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MsOffice::Word::HTML::Writer 3"
.TH MsOffice::Word::HTML::Writer 3 "2020-08-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MsOffice::Word::HTML::Writer \- Writing documents for MsWord in HTML format
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use MsOffice::Word::HTML::Writer;
\&  my $doc = MsOffice::Word::HTML::Writer\->new(
\&    title        => "My new doc",
\&    WordDocument => {View => \*(AqPrint\*(Aq},
\&  );
\&  
\&  $doc\->write("<p>hello, world</p>", 
\&              $doc\->page_break, 
\&              "<p>hello from another page</p>");
\&  
\&  $doc\->create_section(
\&    page => {size         => "21.0cm 29.7cm",
\&             margin       => "1.2cm 2.4cm 2.3cm 2.4cm",
\&             page_numbers => 50, # initial page number within this section
\&            },
\&    header => sprintf("Section 2, page %s of %s", 
\&                                  $doc\->field(\*(AqPAGE\*(Aq), 
\&                                  $doc\->field(\*(AqNUMPAGES\*(Aq)),
\&    footer => sprintf("printed at %s", 
\&                                  $doc\->field(\*(AqPRINTDATE\*(Aq)),
\&    new_page => 1, # or \*(Aqleft\*(Aq, or \*(Aqright\*(Aq
\&  );
\&  $doc\->write("this is the second section, look at header/footer");
\&  
\&  $doc\->attach("my_image.gif", $path_to_my_image);
\&  $doc\->write("<img src=\*(Aqfiles/my_image.gif\*(Aq>");
\&  
\&  my $filename = $doc\->save_as("/path/to/some/file");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Goal"
.IX Subsection "Goal"
The present module is one way to programatically generate documents
targeted for Microsoft Word (MsWord). It doesn't need
MsWord to be installed, and doesn't even require a Win32 machine
(which is why it is not in the \f(CW\*(C`Win32\*(C'\fR namespace).
.SS "MsWord and \s-1HTML\s0"
.IX Subsection "MsWord and HTML"
MsWord can read documents encoded in old native binary format, in Rich
Text Format (\s-1RTF\s0), in \s-1XML\s0 (either \s-1ODF\s0 or \s-1OOXML\s0), or \*(-- maybe this is
less known \*(-- in \s-1HTML,\s0 with some special markup for pagination and
other MsWord-specific features. Such \s-1HTML\s0 documents are often in
several parts, because attachments like images or headers/footers need
to be in separate files; however, since it is more convenient to carry
all data in a single file, MsWord also supports the \*(L"\s-1MHTML\*(R"\s0 format (or
\&\*(L"\s-1MHT\*(R"\s0 for short), i.e. an encapsulation of a whole \s-1HTML\s0 tree into a
single file encoded in \s-1MIME\s0 multipart format. This format can be
generated interactively from MsWord by calling the \*(L"SaveAs\*(R" menu and
choosing the \fI.mht\fR extension.
.PP
Documents saved with a \fI.mht\fR extension will not directly reopen in
MsWord : when clicking on such documents, Windows chooses Internet
Explorer as the default display program.  However, these documents can
be simply renamed with a \fI.doc\fR extension, and will then open
directly in MsWord.  By the way, the same can be done with \s-1XML\s0 or \s-1RTF\s0
documents.  That is to say, MsWord is able to recognize the internal
format of a file, without any dependency on the filename.  There is
one unfortunate restriction, however : when the extension is \fI.docx\fR,
MsWord does not accept any internal format different from \s-1OOXML.\s0 So one has
to either stick with the \fI.doc\fR extension, or choose a specific extension
like \fI.mswhtml\fR and then associate this extension to the MsWord program :
to do so, type the following command in a windows console
.PP
.Vb 1
\&  assoc .mswhtml=Word.Document.12 # for Office 2010, or .8 for Office 2003
.Ve
.SS "Features of the module"
.IX Subsection "Features of the module"
\&\f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR helps you to programatically generate
MsWord documents in \s-1MHT\s0 format. The advantage of this technique is
that one can rely on standard \s-1HTML\s0 mechanisms for layout control, such
as styles, tables, divs, etc. Of course this markup can be produced
using your favorite \s-1HTML\s0 templating module; the added value
of \f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR is to help building the 
\&\s-1MIME\s0 multipart file, and provide some abstractions for 
representing MsWord-specific features (headers, footers, fields, etc.).
.SS "Advantages of \s-1MHT\s0 format"
.IX Subsection "Advantages of MHT format"
The \s-1MHT\s0 format is probably the most convenient
way for programmatic document generation, because
.IP "\(bu" 4
unlike Excel, MsWord native binary format (used in versions up to 2003)
is unpublished and therefore cannot be generated without the MsWord executable.
.IP "\(bu" 4
remote control of the MsWord program through an \s-1OLE\s0 connection,
as in Win32::Word::Writer, requires a
local installation of Microsoft Office, and is not well
suited for server-side generation because the MsWord program might hang
or might open dialog boxes that require user input.
.IP "\(bu" 4
generation of documents in \s-1RTF\s0 is possible, but 
authoring the models requires deep knowledge of the \s-1RTF\s0 structure
\&\-\-\- see RTF::Writer.
.IP "\(bu" 4
authoring models in \s-1XML\s0 also requires
deep knowledge of the \s-1XML\s0 structure.
.Sp
Instead of working directly at the \s-1XML\s0 level, one could use the
OpenOffice::OODoc distribution on \s-1CPAN,\s0 which provides programmatic
access to the \*(L"\s-1ODF\*(R" XML\s0 format used by OpenOffice. MsWord is able to
read and produce such \s-1ODF\s0 files, but this is not fully satisfactory
because in that mode many MsWord features are disabled or restricted.
.Sp
The \s-1XML\s0 format used by MsWord is called \*(L"\s-1OOXML\*(R"\s0; to
my knowledge, there is no \s-1CPAN\s0 module providing an \s-1API\s0 to
this format.
.PP
By contrast, \f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR allows you to 
produce documents even with little knowledge of MsWord.
Besides, since the content is in \s-1HTML,\s0 it can be assembled
with any \s-1HTML\s0 tool, and therefore also requires little knowledge
of Perl.
.PP
One word of warning, however : opening \s-1MHT\s0 documents in MsWord is
a bit slower than native binary or \s-1RTF\s0 documents, because MsWord needs to
parse the \s-1HTML,\s0 compute the layout and convert it into its internal
representation.  Therefore \s-1MHT\s0 format is not recommended for very
large documents.
.SS "Usage"
.IX Subsection "Usage"
\&\f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR is used in production
at Geneva courts of law, for generating thousands of documents
per day, from hundreds of models, with an architecture of 
reusable document parts implemented by Template Toolkit mechanisms
(macros, blocks and views).
.SH "METHODS"
.IX Header "METHODS"
\&\fBGeneral convention\fR : method names that start
with a \fIverb\fR may change the internal state of the 
writer object (for example \*(L"write\*(R", \*(L"create_section\*(R");
method names that are \fInouns\fR return data without modifying
the internal state (for example \*(L"field\*(R", \*(L"content\*(R", page_break).
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $doc = MsOffice::Word::HTML::Writer\->new(%params);
.Ve
.PP
Creates a new writer object. Optional parameters are :
.IP "title" 4
.IX Item "title"
document title
.IP "head" 4
.IX Item "head"
any \s-1HTML\s0 declarations you may want to include in the
\&\f(CW\*(C`head\*(C'\fR part of the generated document (for example
inline \s-1CSS\s0 styles or links to attached stylesheets).
.IP "hf_head" 4
.IX Item "hf_head"
any \s-1HTML\s0 declarations you may want to include in the
\&\f(CW\*(C`head\*(C'\fR part of the \fIheaders and footers\fR \s-1HTML\s0 document
(MsWord requires headers and footers to be 
specified as \f(CW\*(C`div\*(C'\fRs in a separate \s-1HTML\s0 document).
.IP "WordDocument" 4
.IX Item "WordDocument"
a hashref of options to include as an \s-1XML\s0 island in the 
\&\s-1HTML\s0 \f(CW\*(C`head\*(C'\fR, corresponding to various options in the 
MsWord \*(L"Tools/Options\*(R" panel. These will be included
in a \s-1XML\s0 element named \f(CW\*(C`<w:WordDocument>\*(C'\fR, and
all children elements will be automatically prefixed
by \f(CW\*(C`w:\*(C'\fR. The hashref may contain nested hashrefs, such as
.Sp
.Vb 3
\&  WordDocument => { View => \*(AqPrint\*(Aq,
\&                    Compatibility => {DoNotExpandShiftReturn => "",
\&                                      BreakWrappedTables     => ""} }
.Ve
.Sp
Names and values of options
must be found from the Microsoft documentation, or from
reverse engineering of \s-1HTML\s0 files generated by MsWord.
.PP
Parameters may also be passed as a hashref instead of a hash.
.SS "write"
.IX Subsection "write"
.Vb 1
\&  $doc\->write("<p>hello, world</p>");
.Ve
.PP
Adds some \s-1HTML\s0 into the document body.
.SS "attach"
.IX Subsection "attach"
.Vb 3
\&  $doc\->attach($localname, $filename);
\&  $doc\->attach($localname, "<", \e$content);
\&  $doc\->attach($localname, "<&", $filehandle);
.Ve
.PP
Adds an attachment into the document; the attachment will be encoded
as a \s-1MIME\s0 part and will be accessible under \f(CW\*(C`files/$localname\*(C'\fR.
.PP
The remaining arguments to \f(CW\*(C`attach\*(C'\fR specify the source of the attachment;
they are directly passed to \*(L"open\*(R" in perlfunc and therefore have the same
\&\s-1API\s0 flexibility : you can specify a filename, a reference to a memory
variable, a reference to another filehandle, etc.
.SS "create_section"
.IX Subsection "create_section"
.Vb 10
\&  $doc\->create_section(
\&    page => {size   => "21.0cm 29.7cm",
\&             margin => "1.2cm 2.4cm 2.3cm 2.4cm"},
\&    header => sprintf("Section 2, page %s of %s", 
\&                                  $doc\->field(\*(AqPAGE\*(Aq), 
\&                                  $doc\->field(\*(AqNUMPAGES\*(Aq)),
\&    footer => sprintf("printed at %s", 
\&                                  $doc\->field(\*(AqPRINTDATE\*(Aq)),
\&    new_page => 1, # or \*(Aqleft\*(Aq, or \*(Aqright\*(Aq
\&  );
.Ve
.PP
Opens a new section within the document
(or, if this is called before any \*(L"write\*(R", 
setups pagination parameters for the first section).
Subsequent calls to the \*(L"write\*(R" method will add content to
that section, until the next \*(L"create_section\*(R" call.
.PP
Pagination parameters are all optional and may be given
either as a hash or as a hashref; accepted parameters are :
.IP "page" 4
.IX Item "page"
Hashref of \s-1CSS\s0 page styles, such as :
.RS 4
.IP "size" 4
.IX Item "size"
Paper size (for example \f(CW\*(C`21cm 29.7cm\*(C'\fR)
.IP "margin" 4
.IX Item "margin"
Margins (top right bottom left).
.IP "header_margin" 4
.IX Item "header_margin"
Margin for header
.IP "footer_margin" 4
.IX Item "footer_margin"
Margin for footer
.IP "page_numbers" 4
.IX Item "page_numbers"
Initial value for page numbers within this section
.IP "paper_source" 4
.IX Item "paper_source"
Parameters for paper source within this section
(values for these parameters must be reverse engineered from MsWord \s-1HTML\s0 
output)
.RE
.RS 4
.RE
.IP "header" 4
.IX Item "header"
Header content (in \s-1HTML\s0)
.IP "first_header" 4
.IX Item "first_header"
Header content for the first page of that section.
.IP "footer" 4
.IX Item "footer"
Footer content (in \s-1HTML\s0).
.IP "first_footer" 4
.IX Item "first_footer"
Footer content for the first page.
.IP "new_page" 4
.IX Item "new_page"
If true, a page break will be inserted before the new section.
If the argument is the word \f(CW\*(Aqleft\*(Aq\fR or \f(CW\*(Aqright\*(Aq\fR, one or two
page breaks will be inserted so that the next page is formatted
as a left (right) page.
.SS "save_as"
.IX Subsection "save_as"
.Vb 1
\&  my $filename = $doc\->save_as("/path/to/some/file");
.Ve
.PP
Generates the \s-1MIME\s0 document and saves it at the given location.
If no extension is present, file extension \fI.doc\fR will be added
by default to the filename; this is returned as the result from the method
call.
.SS "content"
.IX Subsection "content"
Returns the whole MIME-encoded document as a single string; this is
used internally by the \*(L"save_as\*(R" method.  Direct call is useful if
you don't want to save the document into a file, but want to do
something else like embedding it in a message or a \s-1ZIP\s0 file, or
returning it as an \s-1HTTP\s0 response.
.SS "page_break"
.IX Subsection "page_break"
.Vb 3
\&  my $html = $doc\->page_break;
\&  my $html = $doc\->page_break(\*(Aqleft\*(Aq);
\&  my $html = $doc\->page_break(\*(Aqright\*(Aq);
.Ve
.PP
Returns \s-1HTML\s0 markup for encoding a page break.
If an argument \f(CW\*(Aqleft\*(Aq\fR or \f(CW\*(Aqright\*(Aq\fR is given, one or two
page breaks will be inserted so that the next page is formatted
as a left (right) page.
.SS "tab"
.IX Subsection "tab"
.Vb 1
\&  my $html = $doc\->tab($n_tabs);
.Ve
.PP
Returns \s-1HTML\s0 markup for encoding one or several tabs. If \f(CW$n_tab\fR is
omitted, it defaults to 1.
.SS "field"
.IX Subsection "field"
.Vb 2
\&  my $html = $doc\->field($fieldname, $args, $content,
\&                         $prevent_html_entity_encoding);
.Ve
.PP
Returns \s-1HTML\s0 markup for a MsWord field.
.PP
Optional \f(CW$args\fR is a string with arguments or flags for
the field. See MsWord help documentation for the list of
field names and their associated arguments or flags.
.PP
Optional \f(CW$content\fR is the initial displayed content for the
field (because unfortunately MsWord does not immediately compute
the field content when opening the document; users will have
to explicitly request to update all fields, by selecting the whole
document and then hitting the F9 key).
.PP
Optional \f(CW$prevent_html_entity_encoding\fR is a boolean
that prevents the automatic translation of \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR and 
\&\f(CW\*(C`&\*(C'\fR characters into \s-1HTML\s0 entities \f(CW&lt\fR, \f(CW&gt\fR and
\&\f(CW\*(C`&amp;\*(C'\fR. This is useful if you want to insert some rich text.
.PP
Here are some examples :
.PP
.Vb 6
\&  my $header = sprintf "%s of %s", $doc\->field(\*(AqPAGE\*(Aq), 
\&                                   $doc\->field(\*(AqNUMPAGES\*(Aq);
\&  my $footer = sprintf "created at %s, printed at %s", 
\&                 doc\->field(CREATEDATE => \*(Aq\e\e@ "d MM yyyy"\*(Aq),
\&                 doc\->field(PRINTDATE  => \*(Aq\e\e@ "dddd d MMMM yyyy" \e\e* Upper\*(Aq);
\&  my $quoted = $doc\->field(\*(AqQUOTE\*(Aq, \*(Aq"hello, world"\*(Aq, \*(Aqhello, world\*(Aq);
.Ve
.SS "quote"
.IX Subsection "quote"
.Vb 1
\&  my $html = $doc\->quote($text, $prevent_html_entity_encoding);
.Ve
.PP
Shortcut to produce a \s-1QUOTE\s0 field (see last field example just above).
.PP
The optional \f(CW$prevent_html_entity_encoding\fR argument is explained in the
\&\*(L"field\*(R" method.
.SH "AUTHORING MHT DOCUMENTS"
.IX Header "AUTHORING MHT DOCUMENTS"
.SS "\s-1HTML\s0 for MsWord"
.IX Subsection "HTML for MsWord"
MsWord does not support the full \s-1HTML\s0 and \s-1CSS\s0 standard,
so authoring \s-1MHT\s0 documents requires some trial and error.
Basic divs, spans, paragraphs and tables,
are reasonably supported, together with their common \s-1CSS\s0
properties; but fancier features  like floats, absolute 
positioning, etc. may yield some surprises.
.PP
To specify widths and heights, you will get better results
by using \s-1CSS\s0 properties rather than attributes of the 
\&\s-1HTML\s0 table model.
.PP
In case of difficulties for implementing specific features, 
try to see what MsWord does with that feature when saving
a document in \s-1HTML\s0 format (plain \s-1HTM,\s0 not \s-1MHT\s0!). 
The generated \s-1HTML\s0 is quite verbose, but after eliminating
unnecessary tags one can sometimes figure out which are 
the key tags (they start with \f(CW\*(C`o:\*(C'\fR  or \f(CW\*(C`w:\*(C'\fR) or the
key attributes (they start with \f(CW\*(C`mso\-\*(C'\fR) which correspond
to the desired functionality.
.SS "Collaboration with the Template Toolkit"
.IX Subsection "Collaboration with the Template Toolkit"
The Template Toolkit (\s-1TT\s0 for short) 
is a very helpful tool for generating the \s-1HTML.\s0
Below are some hints about collaboration between
the two modules.
.PP
\fIClient code calls both \s-1TT\s0 and Word::HTML::Writer\fR
.IX Subsection "Client code calls both TT and Word::HTML::Writer"
.PP
The first mode is to use the Template Toolkit for
generating various document parts, and then assemble
them into \f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR.
.PP
.Vb 6
\&  use Template;
\&  my $tmpl_app = Template\->new(%options);
\&  $tmpl_app\->process("doctmpl/html_head.tt", \e%data, \emy $html_head);
\&  $tmpl_app\->process("doctmpl/body.tt",      \e%data, \emy $body);
\&  $tmpl_app\->process("doctmpl/header.tt",    \e%data, \emy $header);
\&  $tmpl_app\->process("doctmpl/footer.tt",    \e%data, \emy $footer);
\&  
\&  use MsOffice::Word::HTML::Writer;
\&  my $doc = MsOffice::Word::HTML::Writer\->new(
\&    title  => $data{title},
\&    head   => $html_head,
\&  );
\&  $doc\->create_section(
\&    header => $header,
\&    footer => $footer,
\&  );
\&  $doc\->write($body);
\&  $doc\->save_as("/path/to/some/file");
.Ve
.PP
This architecture is straightforward, but various document parts 
are split into several templates, which might be inconvenient
when maintaining a large body of document templates.
.PP
\fI\s-1HTML\s0 parts as blocks in a single template\fR
.IX Subsection "HTML parts as blocks in a single template"
.PP
Document parts might also be encoded as blocks within one
single template :
.PP
.Vb 3
\&  [% BLOCK html_head %]
\&  <style>...CSS...</style>
\&  [% END; # BLOCK html_head %]
\&  
\&  [% BLOCK body %]
\&    Hello, world
\&  [% END; # BLOCK body %]
\&  
\&  etc.
.Ve
.PP
Then the client code calls each block in turn to gather
the various parts :
.PP
.Vb 7
\&  use Template::Context;
\&  my $tmpl_ctxt = Template::Context\->new(%options);
\&  my $tmpl      = $tmpl_ctxt\->template("doctmpl/all_blocks.tt");
\&  my $html_head = $tmpl_ctxt\->process($tmpl\->blocks\->{html_head}, \e%data);
\&  my $body      = $tmpl_ctxt\->process($tmpl\->blocks\->{body},      \e%data);
\&  my $header    = $tmpl_ctxt\->process($tmpl\->blocks\->{header},    \e%data);
\&  my $footer    = $tmpl_ctxt\->process($tmpl\->blocks\->{footer},    \e%data);
\&  
\&  # assemble into MsOffice::Word::HTML::Writer, same as before
.Ve
.PP
\fITemplate toolkit calls MsOffice::Word::HTML::Writer\fR
.IX Subsection "Template toolkit calls MsOffice::Word::HTML::Writer"
.PP
Now let's look at a different architecture: the client code
calls the Template toolkit, which in turn calls
\&\f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR.
.PP
The most common way to call modules from \s-1TT\s0 is to use
a \fI\s-1TT\s0 plugin\fR; but since there is currently 
no \s-1TT\s0 plugin for \f(CW\*(C`MsOffice::Word::HTML::Writer\*(C'\fR,
we will just tell \s-1TT\s0 that templates can load regular
Perl modules, by turning on the \f(CW\*(C`LOAD_PERL\*(C'\fR option.
.PP
The client code looks like any other \s-1TT\s0 application; but the output of
the process method is a fully-fledged \s-1MHT\s0
document, instead of plain \s-1HTML.\s0
.PP
.Vb 3
\&  use Template;
\&  my $tmpl_app = Template\->new(LOAD_PERL => 1, %other_options);
\&  $tmpl_app\->process("doc_template.tt", \e%data, \emy $msword_doc);
.Ve
.PP
Within \f(CW\*(C`doc_template.tt\*(C'\fR, we have
.PP
.Vb 1
\&  [% # main entry point
\&  
\&     # gather various parts
\&     SET html_head = PROCESS html_head;
\&     SET header    = PROCESS header;
\&     SET footer    = PROCESS footer;
\&     SET body      = PROCESS body;
\&  
\&     # create Word::HTML::Writer object
\&     USE msword = MsOffice.Word.HTML.Writer(head=html_head);
\&  
\&     # setup section format
\&     CALL msword.create_section(
\&        page => {size          => "21.0cm 29.7cm",
\&                 margin        => "1cm 2.5cm 1cm 2.5cm",
\&                 header_margin => "1cm",
\&                 footer_margin => "0cm",},
\&        header => header,
\&        footer => footer
\&      );
\&  
\&      # write the body
\&     CALL msword.write(body);
\&  
\&     # return the MIME\-encoded MsWord document
\&     msword.content();  %]
\&  
\&  [% BLOCK html_head %]
\&  ...
.Ve
.PP
\fIInheritance through \s-1TT\s0 views\fR
.IX Subsection "Inheritance through TT views"
.PP
The above architecture can be refined one step further,
by using \s-1TT\s0 views to 
encapsulate documents. Views have an inheritance mechanism,
so it becomes possible to define families of document
templates, that inherit properties or methods from common
ancestors. Let us start with \fIgeneric_letter.tt2\fR, 
a generic letter template :
.PP
.Vb 2
\&  [% VIEW generic_letter
\&        title="Generic letter template";
\&  
\&       BLOCK main;
\&         USE msword = MsOffice.Word.HTML.Writer(
\&            title => view.title,
\&            head  => view.html_head(),
\&         );
\&         view.write_body();
\&         msword.content();
\&       END; # BLOCK main
\&    
\&       BLOCK write_body;
\&         CALL msword.create_section(
\&            page   => {size          => "21.0cm 29.7cm",
\&                       margin        => "1cm 2.5cm 1cm 2.5cm"},
\&            header => view.header(),
\&            footer => view.footer()
\&         );
\&         CALL msword.write(view.body());
\&       END; # BLOCK write_body
\&    
\&       BLOCK body;
\&         view.letter_head();
\&         view.letter_body();
\&       END; # BLOCK body
\&    
\&       BLOCK letter_body; %]
\&        Generic letter body; please override BLOCK letter_body in subviews
\&    [% END; # BLOCK letter_body;
\&  
\&       # ... other blocks for header, footer, letter_head, etc.
\&  
\&     END; # VIEW generic_letter
\&  
\&  [% # call main() method if this templated was loaded directly
\&     letter.main() UNLESS component.caller %]
.Ve
.PP
This is quite similar to an object-oriented class : assignments
within the view are like object attributes (i.e. the \f(CW\*(C`title\*(C'\fR
variable), and blocks within the view are like methods.
.PP
After the end of the view, we call the \f(CW\*(C`main\*(C'\fR method, but
only if that view was called directly from client code.
If the view is inherited, as displayed below, then the
call to \f(CW\*(C`main\*(C'\fR will be from the subview.
.PP
Now we can define a specific letter template that inherits
from the generic letter and overrides the \f(CW\*(C`letter_body\*(C'\fR block :
.PP
.Vb 1
\&  [% PROCESS generic_letter.tt2; # loads the parent view
\&  
\&     VIEW advertisement;
\&  
\&       BLOCK letter_body; %]
\&  
\&         <p>Dear [% receiver.name %],</p>
\&         <p>You have won a wonderful [% article %].
\&            Just call us at [% sender.phone %].</p>
\&         <p>Best regards,</p>
\&         [% view.signature(name => sender.name ) %]
\&  
\&  [%   END; # BLOCK letter_body
\&     END; # VIEW advertisement
\&  
\&     advertisement.main() UNLESS component.caller %]
.Ve
.SH "TO DO"
.IX Header "TO DO"
Many features could be added; for example:
.PP
.Vb 5
\&  \- link same header/footers across several sections
\&  \- multiple columns
\&  \- watermarks (I tried hard to reverse engineer MsWord behaviour,
\&    but it still doesn\*(Aqt work ... couldn\*(Aqt figure out all details
\&    of VML markup)
.Ve
.PP
Contributions welcome!
.SH "AUTHOR"
.IX Header "AUTHOR"
Laurent Dami, \f(CW\*(C`<laurent DOT dami AT etat DOT geneve DOT ch>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-win32\-word\-html\-writer at rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=MsOffice\-Word\-HTML\-Writer>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc MsOffice::Word::HTML::Writer
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/MsOffice\-Word\-HTML\-Writer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/MsOffice\-Word\-HTML\-Writer>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=MsOffice\-Word\-HTML\-Writer>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/MsOffice\-Word\-HTML\-Writer>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Win32::Word::Writer, RTF::Writer, Spreadsheet::WriteExcel,
OpenOffice::OODoc.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Laurent Dami, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
