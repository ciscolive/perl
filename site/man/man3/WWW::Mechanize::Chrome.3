.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::Mechanize::Chrome 3"
.TH WWW::Mechanize::Chrome 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::Mechanize::Chrome \- automate the Chrome browser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Log::Log4perl qw(:easy);
\&  use WWW::Mechanize::Chrome;
\&
\&  Log::Log4perl\->easy_init($ERROR);  # Set priority of root logger to ERROR
\&  my $mech = WWW::Mechanize::Chrome\->new();
\&  $mech\->get(\*(Aqhttps://google.com\*(Aq);
\&
\&  $mech\->eval_in_page(\*(Aqalert("Hello Chrome")\*(Aq);
\&  my $png = $mech\->content_as_png();
.Ve
.PP
A collection of other Examples is available
to help you get started.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Like WWW::Mechanize, this module automates web browsing with a Perl object.
Fetching and rendering of web pages is delegated to the Chrome (or Chromium)
browser by starting an instance of the browser and controlling it with Chrome
DevTools <https://developers.google.com/web/tools/chrome-devtools/>.
.SS "Advantages Over WWW::Mechanize"
.IX Subsection "Advantages Over WWW::Mechanize"
The Chrome browser provides advanced abilities useful for automating modern
web applications that are not (yet) possible with WWW::Mechanize alone:
.IP "\(bu" 4
Page content can be created or modified with JavaScript. You can also execute
custom JavaScript code on the page content.
.IP "\(bu" 4
Page content can be selected with \s-1CSS\s0 selectors.
.IP "\(bu" 4
Screenshots of the rendered page as an image or \s-1PDF\s0 file.
.SS "Disadvantages"
.IX Subsection "Disadvantages"
Installation of a Chrome compatible browser is required. There are some quirks
including sporadic, but harmless, error messages issued by the browser when
run with with DevTools.
.SS "A Brief Operational Overview"
.IX Subsection "A Brief Operational Overview"
\&\f(CW\*(C`WWW::Mechanize::Chrome\*(C'\fR (\s-1WMC\s0) leverages developer tools built into Chrome and
Chrome-like browsers to control a browser instance programatically. You can use
\&\s-1WMC\s0 to automate tedious tasks, test web applications, and perform web scraping
operations.
.PP
Typically, \s-1WMC\s0 is used to launch both a \fIhost\fR instance of the browser and
provide a \fIclient\fR instance of the browser. The host instance of the browser is
visible to you on your desktop (unless the browser is running in \*(L"headless\*(R"
mode, in which case it will not open in a window). The client instance is the
Perl program you write with the \s-1WMC\s0 module to issue commands to control the host
instance. As you navigate and \*(L"click\*(R" on various nodes in the client browser,
you watch the host browser respond to these actions as if by magic.
.PP
This magic happens as a result of commands that are issued from your client to
the host using Chrome's DevTools Protocol which implements the http protocol to
send \s-1JSON\s0 data structures. The host also responds to the client with \s-1JSON\s0 to
describe the web pages it has loaded. \s-1WMC\s0 conveniently hides the complexity of
the lower level communications between the client and host browsers and wraps
them in a Perl object to provide the easy-to-use methods documented here.
.SH "OPTIONS"
.IX Header "OPTIONS"
.ie n .SS """WWW::Mechanize::Chrome\->new( %options )"""
.el .SS "\f(CWWWW::Mechanize::Chrome\->new( %options )\fP"
.IX Subsection "WWW::Mechanize::Chrome->new( %options )"
.Vb 3
\&  my $mech = WWW::Mechanize::Chrome\->new(
\&      headless => 0,
\&  );
.Ve
.IP "\fBautodie\fR" 4
.IX Item "autodie"
.Vb 1
\&  autodie => 0   # make HTTP errors non\-fatal
.Ve
.Sp
By default, \f(CW\*(C`autodie\*(C'\fR is set to true. If an \s-1HTTP\s0 error is encountered, the
program dies along with its associated browser instances. This frees you from
having to write error checks after every request. Setting this value to false
makes \s-1HTTP\s0 errors non-fatal, allowing the program to continue running if
there is an error.
.IP "\fBheadless\fR" 4
.IX Item "headless"
Don't display a browser window. Default is to display a browser
window.
.IP "\fBhost\fR" 4
.IX Item "host"
Set the host the browser listens on:
.Sp
.Vb 2
\&  host => \*(Aq192.168.1.2\*(Aq
\&  host => \*(Aqlocalhost\*(Aq
.Ve
.Sp
Defaults to \f(CW127.0.0.1\fR. The browser will listen for commands on the
specified host. The host address should be inaccessible from the internet.
.IP "\fBport\fR" 4
.IX Item "port"
.Vb 1
\&  port => 9223   # set port the launched browser will use for remote operation
.Ve
.Sp
Defaults to \f(CW9222\fR. Commands to the browser will be issued through this port.
.IP "\fBtab\fR" 4
.IX Item "tab"
Specify the browser tab the Chrome browser will use:
.Sp
.Vb 2
\&  tab => \*(Aqcurrent\*(Aq
\&  tab => qr/PerlMonks/
.Ve
.Sp
By default, a web page is opened in a new browser tab. Setting \f(CW\*(C`tab\*(C'\fR to
\&\f(CW\*(C`current\*(C'\fR will use the current, active tab instead. Alternatively, to use an
existing inactive tab, you can pass a regular expression to match against the
existing tab's title. A false value implements the default behavior and a new
tab will be created.
.IP "\fBautoclose\fR" 4
.IX Item "autoclose"
.Vb 1
\&  autoclose => 0   # keep tab open after program end
.Ve
.Sp
By default, \f(CW\*(C`autoclose\*(C'\fR is set to true, closing the tab opened when running
your code. If \f(CW\*(C`autoclose\*(C'\fR is set to a false value, the tab will remain open
even after the program has finished.
.IP "\fBlaunch_exe\fR" 4
.IX Item "launch_exe"
Set the name and/or path to the browser's executable program:
.Sp
.Vb 3
\&  launch_exe => \*(Aqname\-of\-chrome\-executable\*(Aq   # for non\-standard executable names
\&  launch_exe => \*(Aq/path/to/executable\*(Aq         # for non\-standard paths
\&  launch_exe => \*(Aq/path/to/executable/chrome\*(Aq  # full path
.Ve
.Sp
By default, \f(CW\*(C`WWW::Mechanize::Chrome\*(C'\fR will search the appropriate paths for
Chrome's executable file based on the operating system. Use this option to set
the path to your executable if it is in a non-standard location or if the
executable has a non-standard name.
.Sp
The default paths searched are those found in \f(CW$ENV{PATH}\fR. For \s-1OS X,\s0 the user
and system \f(CW\*(C`Application\*(C'\fR directories are also searched. The default values for
the executable file's name are \f(CW\*(C`chrome\*(C'\fR on Windows, \f(CW\*(C`Google Chrome\*(C'\fR on \s-1OS X,\s0
and \f(CW\*(C`google\-chrome\*(C'\fR elsewhere.
.Sp
If you want to use Chromium, you must specify that explicitly with something
like:
.Sp
.Vb 1
\&  launch_exe => \*(Aqchromium\-browser\*(Aq, # if Chromium is named chromium\-browser on your OS
.Ve
.Sp
Results my vary for your operating system. Use the full path to the browser's
executable if you are having issues. You can also set the name of the executable
file with the \f(CW$ENV{CHROME_BIN}\fR environment variable.
.IP "\fBcleanup_signal\fR" 4
.IX Item "cleanup_signal"
.Vb 1
\&    cleanup_signal => \*(AqSIGKILL\*(Aq
.Ve
.Sp
The signal that is sent to Chrome to shut it down. On Linuxish OSes, this
will be \f(CW\*(C`TERM\*(C'\fR, on \s-1OSX\s0 and Windows it will be \f(CW\*(C`KILL\*(C'\fR.
.IP "\fBstart_url\fR" 4
.IX Item "start_url"
.Vb 1
\&  start_url => \*(Aqhttp://perlmonks.org\*(Aq  # Immediately navigate to a given URL
.Ve
.Sp
By default, the browser will open with a blank tab. Use the \f(CW\*(C`start_url\*(C'\fR option
to open the browser to the specified \s-1URL.\s0 More typically, the \f(CW\*(C`\->get\*(C'\fR
method is use to navigate to URLs.
.IP "\fBlaunch_arg\fR" 4
.IX Item "launch_arg"
Pass additional switches and parameters to the browser's executable:
.Sp
.Vb 1
\&  launch_arg => [ "\-\-some\-new\-parameter=foo", "\-\-another\-option" ]
.Ve
.Sp
Examples of other useful parameters include:
.Sp
.Vb 3
\&    \*(Aq\-\-start\-maximized\*(Aq,
\&    \*(Aq\-\-window\-size=1280x1696\*(Aq
\&    \*(Aq\-\-ignore\-certificate\-errors\*(Aq
\&
\&    \*(Aq\-\-disable\-web\-security\*(Aq,
\&    \*(Aq\-\-allow\-running\-insecure\-content\*(Aq,
\&
\&    \*(Aq\-\-load\-extension\*(Aq
\&    \*(Aq\-\-no\-sandbox\*(Aq
.Ve
.IP "\fBseparate_session\fR" 4
.IX Item "separate_session"
.Vb 1
\&  separate_session => 1   # create a new, empty session
.Ve
.Sp
This creates an empty, fresh Chrome session without any cookies. Setting this
will disregard any \fBdata_directory\fR setting.
.IP "\fBincognito\fR" 4
.IX Item "incognito"
.Vb 1
\&  incognito => 1   # open the browser in incognito mode
.Ve
.Sp
Defaults to false. Set to true to launch the browser in incognito mode.
.Sp
Most likely, you want to use \fBseparate_session\fR instead.
.IP "\fBdata_directory\fR" 4
.IX Item "data_directory"
.Vb 1
\&  data_directory => \*(Aq/path/to/data/directory\*(Aq  #  set the data directory
.Ve
.Sp
By default, an empty data directory is used. Use this setting to change the
base data directory for the browsing session.
.Sp
.Vb 5
\&  use File::Temp \*(Aqtempdir\*(Aq;
\&  # create a fresh Chrome every time
\&  my $mech = WWW::Mechanize::Chrome\->new(
\&      data_directory => tempdir(CLEANUP => 1 ),
\&  );
.Ve
.Sp
Using the \*(L"main\*(R" Chrome cookies:
.Sp
.Vb 3
\&  my $mech = WWW::Mechanize::Chrome\->new(
\&      data_directory => \*(Aq/home/corion/.config/chromium\*(Aq,
\&  );
.Ve
.IP "\fBprofile\fR" 4
.IX Item "profile"
.Vb 1
\&  profile => \*(Aq/path/to/profile/directory\*(Aq  #  set the profile directory
.Ve
.Sp
By default, your current user profile directory is used. Use this setting
to change the profile directory for the browsing session.
.Sp
You will need to set the \fBdata_directory\fR as well, so that Chrome finds the
profile within the data directory.
.IP "\fBwait_file\fR" 4
.IX Item "wait_file"
.Vb 1
\&  wait_file => "$tempdir/CrashpadMetrics\-active.pma"
.Ve
.Sp
When shutting down, wait until this file does not exist anymore or can be
deleted. This can help making sure that the Chrome process has really shut
down.
.IP "\fBstartup_timeout\fR" 4
.IX Item "startup_timeout"
.Vb 1
\&  startup_timeout => 5  # set the startup timeout value
.Ve
.Sp
Defaults to 20, the maximum number of seconds to wait for the browser to launch.
Higher or lower values can be set based on the speed of the machine. The
process attempts to connect to the browser once each second over the duration
of this setting.
.IP "\fBlisten_host\fR" 4
.IX Item "listen_host"
.Vb 1
\&  listen_host => \*(Aq192.1.168.7\*(Aq  # set an IP address for listening
.Ve
.Sp
Specifies an \s-1IP\s0 address the launched browser process should listen on. This
option is useful for controlling the browser from another machine on your
network.
.IP "\fBdriver\fR" 4
.IX Item "driver"
.Vb 1
\&  driver => $driver_object  # specify the driver object
.Ve
.Sp
Use a Chrome::DevToolsProtocol::Target object that has been manually constructed.
.IP "\fBreport_js_errors\fR" 4
.IX Item "report_js_errors"
.Vb 1
\&  report_js_errors => 1  # turn javascript error reporting on
.Ve
.Sp
Defaults to false. If true, tests for Javascript errors and warns after each
request are run. This is useful for testing with \f(CW\*(C`use warnings qw(fatal)\*(C'\fR.
.IP "\fBmute_audio\fR" 4
.IX Item "mute_audio"
.Vb 1
\&  mute_audio => 0  # turn sounds on
.Ve
.Sp
Defaults to true (sound off). A false value turns the sound on.
.IP "\fBbackground_networking\fR" 4
.IX Item "background_networking"
.Vb 1
\&  background_networking => 1  # turn background networking on
.Ve
.Sp
Defaults to false (off). A true value enables background networking.
.IP "\fBclient_side_phishing_detection\fR" 4
.IX Item "client_side_phishing_detection"
.Vb 1
\&  client_side_phishing_detection => 1  # turn client side phishing detection on
.Ve
.Sp
Defaults to false (off). A true value enables client side phishing detection.
.IP "\fBcomponent_update\fR" 4
.IX Item "component_update"
.Vb 1
\&  component_update => 1  # turn component updates on
.Ve
.Sp
Defaults to false (off). A true value enables component updates.
.IP "\fBdefault_apps\fR" 4
.IX Item "default_apps"
.Vb 1
\&  default_apps => 1  # turn default apps on
.Ve
.Sp
Defaults to false (off). A true value enables default apps.
.IP "\fBhang_monitor\fR" 4
.IX Item "hang_monitor"
.Vb 1
\&  hang_monitor => 1  # turn the hang monitor on
.Ve
.Sp
Defaults to false (off). A true value enables the hang monitor.
.IP "\fBhide_scrollbars\fR" 4
.IX Item "hide_scrollbars"
.Vb 1
\&  hide_scrollbars => 1  # hide the scrollbars
.Ve
.Sp
Defaults to false (off). A true value will hide the scrollbars.
.IP "\fBinfobars\fR" 4
.IX Item "infobars"
.Vb 1
\&  infobars => 1  # turn infobars on
.Ve
.Sp
Defaults to false (off). A true value will turn infobars on.
.IP "\fBpopup_blocking\fR" 4
.IX Item "popup_blocking"
.Vb 1
\&  popup_bloacking => 1  # block popups
.Ve
.Sp
Defaults to false (off). A true value will block popups.
.IP "\fBprompt_on_repost\fR" 4
.IX Item "prompt_on_repost"
.Vb 1
\&  prompt_on_repost => 1  # allow prompts when reposting
.Ve
.Sp
Defaults to false (off). A true value will allow prompts when reposting.
.IP "\fBsave_password_bubble\fR" 4
.IX Item "save_password_bubble"
.Vb 1
\&  save_password_bubble => 1  # allow the display of the save password bubble
.Ve
.Sp
Defaults to false (off). A true value allows the save password bubble to be
displayed.
.IP "\fBsync\fR" 4
.IX Item "sync"
.Vb 1
\&  sync => 1   # turn syncing on
.Ve
.Sp
Defaults to false (off). A true value turns syncing on.
.IP "\fBweb_resources\fR" 4
.IX Item "web_resources"
.Vb 1
\&  web_resources => 1   # turn web resources on
.Ve
.Sp
Defaults to false (off). A true value turns web resources on.
.PP
The \f(CW$ENV{WWW_MECHANIZE_CHROME_TRANSPORT}\fR variable can be set to a
different transport class to override the default transport
class. This is primarily used for testing
but can also help eliminate introducing bugs from the underlying websocket
implementation(s).
.PP
The \f(CW$ENV{WWW_MECHANIZE_CHROME_CONNECTION_STYLE}\fR variable can be set to
either \f(CW\*(C`websocket\*(C'\fR or \f(CW\*(C`pipe\*(C'\fR to specify the kind of transport that you
want to use.
.PP
The \f(CW\*(C`pipe\*(C'\fR transport is only available on unixish OSes and only with Chrome
v72 onwards.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """WWW::Mechanize::Chrome\->find_executable"""
.el .SS "\f(CWWWW::Mechanize::Chrome\->find_executable\fP"
.IX Subsection "WWW::Mechanize::Chrome->find_executable"
.Vb 1
\&    my $chrome = WWW::Mechanize::Chrome\->find_executable();
\&
\&    my $chrome = WWW::Mechanize::Chrome\->find_executable(
\&        \*(Aqchromium.exe\*(Aq,
\&        \*(Aq.\e\emy\-chrome\-66\e\e\*(Aq,
\&    );
\&
\&    my( $chrome, $diagnosis ) = WWW::Mechanize::Chrome\->find_executable(
\&        [\*(Aqchromium\-browser\*(Aq,\*(Aqgoogle\-chrome\*(Aq],
\&        \*(Aq./my\-chrome\-66/\*(Aq,
\&    );
\&    die $diagnosis if ! $chrome;
.Ve
.PP
Finds the first Chrome executable in the path (\f(CW$ENV{PATH}\fR). For Windows, it
also looks in \f(CW$ENV{ProgramFiles}\fR, \f(CW$ENV{ProgramFiles(x86)}\fR
and \f(CW$ENV{"ProgramFilesW6432"}\fR. For \s-1OSX\s0 it also looks in the user home
directory as given through \f(CW$ENV{HOME}\fR.
.PP
This is used to find the default Chrome executable if none was given through
the \f(CW\*(C`launch_exe\*(C'\fR option or if the executable is given and does not exist
and does not contain a directory separator.
.ie n .SS """$mech\->chrome_version"""
.el .SS "\f(CW$mech\->chrome_version\fP"
.IX Subsection "$mech->chrome_version"
.Vb 1
\&  print $mech\->chrome_version;
.Ve
.PP
Returns the version of the Chrome executable being used. This information
needs launching the browser and asking for the version via the network.
.ie n .SS """$mech\->chrome_version_info"""
.el .SS "\f(CW$mech\->chrome_version_info\fP"
.IX Subsection "$mech->chrome_version_info"
.Vb 1
\&  print $mech\->chrome_version_info\->{product};
.Ve
.PP
Returns the version information of the Chrome executable and various other
APIs of Chrome that the object is connected to.
.ie n .SS """$mech\->driver"""
.el .SS "\f(CW$mech\->driver\fP"
.IX Subsection "$mech->driver"
\&\fBdeprecated\fR \- use \f(CW\*(C`\->target\*(C'\fR instead
.PP
.Vb 1
\&    my $driver = $mech\->driver
.Ve
.PP
Access the Chrome::DevToolsProtocol instance connecting to Chrome.
.PP
Deprecated, don't use this anymore. Most likely you want to use \f(CW\*(C`\->target\*(C'\fR
to talk to the Chrome tab or \f(CW\*(C`\->transport\*(C'\fR to talk to the Chrome instance.
.ie n .SS """$mech\->target"""
.el .SS "\f(CW$mech\->target\fP"
.IX Subsection "$mech->target"
.Vb 1
\&    my $target = $mech\->target
.Ve
.PP
Access the Chrome::DevToolsProtocol::Target instance connecting to the
Chrome tab we use.
.ie n .SS """$mech\->transport"""
.el .SS "\f(CW$mech\->transport\fP"
.IX Subsection "$mech->transport"
.Vb 1
\&    my $transport = $mech\->transport
.Ve
.PP
Access the Chrome::DevToolsProtocol::Transport instance connecting to the
Chrome instance.
.ie n .SS """$mech\->tab"""
.el .SS "\f(CW$mech\->tab\fP"
.IX Subsection "$mech->tab"
.Vb 1
\&    my $tab = $mech\->tab
.Ve
.PP
Access the tab hash of the Chrome::DevToolsProtocol::Target instance.
This represents the tab we control.
.ie n .SS """$mech\->allow( %options )"""
.el .SS "\f(CW$mech\->allow( %options )\fP"
.IX Subsection "$mech->allow( %options )"
.Vb 1
\&  $mech\->allow( javascript => 1 );
.Ve
.PP
Allow or disallow execution of Javascript
.ie n .SS """$mech\->emulateNetworkConditions( %options )"""
.el .SS "\f(CW$mech\->emulateNetworkConditions( %options )\fP"
.IX Subsection "$mech->emulateNetworkConditions( %options )"
.Vb 8
\&  # Go offline
\&  $mech\->emulateNetworkConditions(
\&      offline => JSON::true,
\&      latency => 10, # ms ping
\&      downloadThroughput => 0, # bytes/s
\&      uploadThroughput => 0, # bytes/s
\&      connectionType => \*(Aqoffline\*(Aq, # cellular2g, cellular3g, cellular4g, bluetooth, ethernet, wifi, wimax, other.
\&  );
.Ve
.ie n .SS """$mech\->setRequestInterception( @patterns )"""
.el .SS "\f(CW$mech\->setRequestInterception( @patterns )\fP"
.IX Subsection "$mech->setRequestInterception( @patterns )"
.Vb 4
\&  $mech\->setRequestInterception(
\&      { urlPattern => \*(Aq*\*(Aq, resourceType => \*(AqDocument\*(Aq, interceptionStage => \*(AqRequest\*(Aq},
\&      { urlPattern => \*(Aq*\*(Aq, resourceType => \*(AqMedia\*(Aq, interceptionStage => \*(AqResponse\*(Aq},
\&  );
.Ve
.PP
Sets the list of request patterns and resource types for which the interception
callback will be invoked.
.ie n .SS """$mech\->add_listener"""
.el .SS "\f(CW$mech\->add_listener\fP"
.IX Subsection "$mech->add_listener"
.Vb 8
\&  my $url_loaded = $mech\->add_listener(\*(AqNetwork.responseReceived\*(Aq, sub {
\&      my( $info ) = @_;
\&      warn "Loaded URL "
\&           . $info\->{params}\->{response}\->{url}
\&           . ": "
\&           . $info\->{params}\->{response}\->{status};
\&      warn "Resource timing: " . Dumper $info\->{params}\->{response}\->{timing};
\&  });
.Ve
.PP
Returns a listener object. If that object is discarded, the listener callback
will be removed.
.PP
Calling this method in void context croaks.
.PP
To see the browser console live from your Perl script, use the following:
.PP
.Vb 5
\&  my $console = $mech\->add_listener(\*(AqRuntime.consoleAPICalled\*(Aq, sub {
\&    warn join ", ",
\&        map { $_\->{value} // $_\->{description} }
\&        @{ $_[0]\->{params}\->{args} };
\&  });
.Ve
.PP
If you want to explicitly remove the listener, either set it to \f(CW\*(C`undef\*(C'\fR:
.PP
.Vb 1
\&  undef $console;
.Ve
.PP
Alternatively, call
.PP
.Vb 1
\&  $console\->unregister;
.Ve
.PP
or call
.PP
.Vb 1
\&  $mech\->remove_listener( $console );
.Ve
.ie n .SS """$mech\->on_request_intercepted( $cb )"""
.el .SS "\f(CW$mech\->on_request_intercepted( $cb )\fP"
.IX Subsection "$mech->on_request_intercepted( $cb )"
.Vb 7
\&  $mech\->on_request_intercepted( sub {
\&      my( $mech, $info ) = @_;
\&      warn $info\->{request}\->{url};
\&      $mech\->continueInterceptedRequest_future(
\&          interceptionId => $info\->{interceptionId}
\&      )
\&  });
.Ve
.PP
A callback for intercepted requests that match the patterns set up
via \f(CW\*(C`setRequestInterception\*(C'\fR.
.PP
If you return a future from this callback, it will not be discarded but kept in
a safe place.
.ie n .SS """$mech\->searchInResponseBody( $id, %options )"""
.el .SS "\f(CW$mech\->searchInResponseBody( $id, %options )\fP"
.IX Subsection "$mech->searchInResponseBody( $id, %options )"
.Vb 10
\&  my $request_id = ...;
\&  my @matches = $mech\->searchInResponseBody(
\&      requestId     => $request_id,
\&      query         => \*(Aqrumpelstiltskin\*(Aq,
\&      caseSensitive => JSON::true,
\&      isRegex       => JSON::false,
\&  );
\&  for( @matches ) {
\&      print $_\->{lineNumber}, ":", $_\->{lineContent}, "\en";
\&  };
.Ve
.PP
Returns the matches (if any) for a string or regular expression within
a response.
.ie n .SS """$mech\->on_dialog( $cb )"""
.el .SS "\f(CW$mech\->on_dialog( $cb )\fP"
.IX Subsection "$mech->on_dialog( $cb )"
.Vb 5
\&  $mech\->on_dialog( sub {
\&      my( $mech, $dialog ) = @_;
\&      warn $dialog\->{message};
\&      $mech\->handle_dialog( 1 ); # click "OK" / "yes" instead of "cancel"
\&  });
.Ve
.PP
A callback for Javascript dialogs (\f(CW\*(C`alert()\*(C'\fR, \f(CW\*(C`prompt()\*(C'\fR, ... )
.ie n .SS """$mech\->handle_dialog( $accept, $prompt = undef )"""
.el .SS "\f(CW$mech\->handle_dialog( $accept, $prompt = undef )\fP"
.IX Subsection "$mech->handle_dialog( $accept, $prompt = undef )"
.Vb 5
\&  $mech\->on_dialog( sub {
\&      my( $mech, $dialog ) = @_;
\&      warn "[Javascript $dialog\->{type}]: $dialog\->{message}";
\&      $mech\->handle_dialog( 1 ); # click "OK" / "yes" instead of "cancel"
\&  });
.Ve
.PP
Closes the current Javascript dialog.
.ie n .SS """$mech\->js_console_entries()"""
.el .SS "\f(CW$mech\->js_console_entries()\fP"
.IX Subsection "$mech->js_console_entries()"
.Vb 2
\&  print $_\->{type}, " ", $_\->{message}, "\en"
\&      for $mech\->js_console_entries();
.Ve
.PP
An interface to the Javascript Error Console
.PP
Returns the list of entries in the \s-1JEC\s0
.ie n .SS """$mech\->js_errors()"""
.el .SS "\f(CW$mech\->js_errors()\fP"
.IX Subsection "$mech->js_errors()"
.Vb 2
\&  print "JS error: ", $_\->{message}, "\en"
\&      for $mech\->js_errors();
.Ve
.PP
Returns the list of errors in the \s-1JEC\s0
.ie n .SS """$mech\->clear_js_errors()"""
.el .SS "\f(CW$mech\->clear_js_errors()\fP"
.IX Subsection "$mech->clear_js_errors()"
.Vb 1
\&    $mech\->clear_js_errors();
.Ve
.PP
Clears all Javascript messages from the console
.ie n .SS """$mech\->eval_in_page( $str, %options )"""
.el .SS "\f(CW$mech\->eval_in_page( $str, %options )\fP"
.IX Subsection "$mech->eval_in_page( $str, %options )"
.ie n .SS """$mech\->eval( $str, %options )"""
.el .SS "\f(CW$mech\->eval( $str, %options )\fP"
.IX Subsection "$mech->eval( $str, %options )"
.Vb 1
\&  my ($value, $type) = $mech\->eval( \*(Aq2+2\*(Aq );
.Ve
.PP
Evaluates the given Javascript fragment in the
context of the web page.
Returns a pair of value and Javascript type.
.PP
This allows access to variables and functions declared
\&\*(L"globally\*(R" on the web page.
.IP "returnByValue" 4
.IX Item "returnByValue"
If you want to create an object in Chrome and only want to keep a handle to that
remote object, use \f(CW\*(C`JSON::false\*(C'\fR for the \f(CW\*(C`returnByValue\*(C'\fR option:
.Sp
.Vb 4
\&    my ($dummyObj,$type) = $mech\->eval(
\&        \*(Aqnew Object\*(Aq,
\&        returnByValue => JSON::false
\&    );
.Ve
.Sp
This is also helpful if the object in Chrome cannot be serialized as \s-1JSON.\s0
For example, \f(CW\*(C`window\*(C'\fR is such an object. The return value is a hash, whose
\&\f(CW\*(C`objectId\*(C'\fR is the most interesting part.
.PP
This method is special to WWW::Mechanize::Chrome.
.ie n .SS """$mech\->eval_in_chrome $code, @args"""
.el .SS "\f(CW$mech\->eval_in_chrome $code, @args\fP"
.IX Subsection "$mech->eval_in_chrome $code, @args"
.Vb 3
\&  $mech\->eval_in_chrome(<<\*(AqJS\*(Aq, "Foobar/1.0");
\&      this.settings.userAgent= arguments[0]
\&  JS
.Ve
.PP
Evaluates Javascript code in the context of Chrome.
.PP
This allows you to modify properties of Chrome.
.PP
This is currently not implemented.
.ie n .SS """$mech\->callFunctionOn( $function, @arguments )"""
.el .SS "\f(CW$mech\->callFunctionOn( $function, @arguments )\fP"
.IX Subsection "$mech->callFunctionOn( $function, @arguments )"
.Vb 5
\&  my ($value, $type) = $mech\->callFunctionOn(
\&      \*(Aqfunction(greeting) { window.alert(greeting)}\*(Aq,
\&      objectId => $someObjectId,
\&      arguments => [{ value => \*(AqHello World\*(Aq }]
\&  );
.Ve
.PP
Runs the given function with the specified arguments. This is the only way to
pass arguments to a function call without doing risky string interpolation.
The Javascript \f(CW\*(C`this\*(C'\fR object will be set to the object referenced from the
\&\f(CW\*(C`objectId\*(C'\fR.
.PP
The \f(CW\*(C`arguments\*(C'\fR option expects an arrayref of hashrefs. Each hash describes one
function argument.
.PP
The \f(CW\*(C`objectId\*(C'\fR parameter is optional. Leaving out the \f(CW\*(C`objectId\*(C'\fR parameter
will create a dummy object on which the function then is called.
.PP
This method is special to WWW::Mechanize::Chrome.
.ie n .SS """\->autoclose_tab"""
.el .SS "\f(CW\->autoclose_tab\fP"
.IX Subsection "->autoclose_tab"
Set the \f(CW\*(C`autoclose\*(C'\fR option
.ie n .SS """\->close"""
.el .SS "\f(CW\->close\fP"
.IX Subsection "->close"
.Vb 1
\&    $mech\->close()
.Ve
.PP
Tear down all connections and shut down Chrome.
.ie n .SS """$mech\->highlight_node( @nodes )"""
.el .SS "\f(CW$mech\->highlight_node( @nodes )\fP"
.IX Subsection "$mech->highlight_node( @nodes )"
.Vb 3
\&    my @links = $mech\->selector(\*(Aqa\*(Aq);
\&    $mech\->highlight_node(@links);
\&    print $mech\->content_as_png();
.Ve
.PP
Convenience method that marks all nodes in the arguments
with a red frame.
.PP
This is convenient if you need visual verification that you've
got the right nodes.
.SH "NAVIGATION METHODS"
.IX Header "NAVIGATION METHODS"
.ie n .SS """$mech\->get( $url, %options )"""
.el .SS "\f(CW$mech\->get( $url, %options )\fP"
.IX Subsection "$mech->get( $url, %options )"
.Vb 1
\&  my $response = $mech\->get( $url );
.Ve
.PP
Retrieves the \s-1URL\s0 \f(CW\*(C`URL\*(C'\fR.
.PP
It returns a HTTP::Response object for interface compatibility
with WWW::Mechanize.
.PP
Note that the returned HTTP::Response object gets the response body
filled in lazily, so you might have to wait a moment to get the response
body from the result. This is a premature optimization and later releases of
WWW::Mechanize::Chrome are planned to fetch the response body immediately when
accessing the response body.
.PP
Note that Chrome does not support download of files through the \s-1API.\s0
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\(bu" 4
\&\f(CW\*(C`intrapage\*(C'\fR \- Override the detection of whether to wait for a \s-1HTTP\s0 response
or not. Setting this will never wait for an \s-1HTTP\s0 response.
.ie n .SS """$mech\->_collectEvents"""
.el .SS "\f(CW$mech\->_collectEvents\fP"
.IX Subsection "$mech->_collectEvents"
.Vb 4
\&  my $events = $mech\->_collectEvents(
\&      sub { $_[0]\->{method} eq \*(AqPage.loadEventFired\*(Aq }
\&  );
\&  my( $e,$r) = Future\->wait_all( $events, $self\->target\->send_message(...));
.Ve
.PP
Internal method to create a Future that waits for an event that is sent by Chrome.
.PP
The subroutine is the predicate to check to see if the current event
is the event we have been waiting for.
.PP
The result is a Future that will return all captured events.
.ie n .SS """$mech\->get_local( $filename , %options )"""
.el .SS "\f(CW$mech\->get_local( $filename , %options )\fP"
.IX Subsection "$mech->get_local( $filename , %options )"
.Vb 1
\&  $mech\->get_local(\*(Aqtest.html\*(Aq);
.Ve
.PP
Shorthand method to construct the appropriate
\&\f(CW\*(C`file://\*(C'\fR \s-1URI\s0 and load it into Chrome. Relative
paths will be interpreted as relative to \f(CW$0\fR
or the \f(CW\*(C`basedir\*(C'\fR option.
.PP
This method accepts the same options as \f(CW\*(C`\->get()\*(C'\fR.
.PP
This method is special to WWW::Mechanize::Chrome but could
also exist in WWW::Mechanize through a plugin.
.PP
\&\fBWarning\fR: Chrome does not handle local files well. Especially
subframes do not get loaded properly.
.ie n .SS """$mech\->getRequestPostData"""
.el .SS "\f(CW$mech\->getRequestPostData\fP"
.IX Subsection "$mech->getRequestPostData"
.Vb 3
\&    if( $info\->{params}\->{response}\->{requestHeaders}\->{":method"} eq \*(AqPOST\*(Aq ) {
\&        $req\->{postBody} = $m\->getRequestPostData( $id );
\&    };
.Ve
.PP
Retrieves the data sent with a \s-1POST\s0 request
.ie n .SS """$mech\->post( $url, %options )"""
.el .SS "\f(CW$mech\->post( $url, %options )\fP"
.IX Subsection "$mech->post( $url, %options )"
\&\fBnot implemented\fR
.PP
.Vb 7
\&  $mech\->post( \*(Aqhttp://example.com\*(Aq,
\&      params => { param => "Hello World" },
\&      headers => {
\&        "Content\-Type" => \*(Aqapplication/x\-www\-form\-urlencoded\*(Aq,
\&      },
\&      charset => \*(Aqutf\-8\*(Aq,
\&  );
.Ve
.PP
Sends a \s-1POST\s0 request to \f(CW$url\fR.
.PP
A \f(CW\*(C`Content\-Length\*(C'\fR header will be automatically calculated if
it is not given.
.PP
The following options are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR \- a hash of \s-1HTTP\s0 headers to send. If not given,
the content type will be generated automatically.
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- the raw data to send, if you've encoded it already.
.ie n .SS """$mech\->reload( %options )"""
.el .SS "\f(CW$mech\->reload( %options )\fP"
.IX Subsection "$mech->reload( %options )"
.Vb 1
\&  $mech\->reload( ignoreCache => 1 )
.Ve
.PP
Acts like the reload button in a browser: repeats the current request.
The history (as per the \*(L"back\*(R" method) is not altered.
.PP
Returns the HTTP::Response object from the reload, or undef if there's no
current request.
.ie n .SS """$mech\->set_download_directory( $dir )"""
.el .SS "\f(CW$mech\->set_download_directory( $dir )\fP"
.IX Subsection "$mech->set_download_directory( $dir )"
.Vb 2
\&    my $downloads = tempdir();
\&    $mech\->set_download_directory( $downloads );
.Ve
.PP
Enables automatic file downloads and sets the directory where the files
will be downloaded to. Setting this to undef will disable downloads again.
.PP
The directory in \f(CW$dir\fR must be an absolute path, since Chrome does not know
about the current directory of your Perl script.
.ie n .SS """$mech\->cookie_jar"""
.el .SS "\f(CW$mech\->cookie_jar\fP"
.IX Subsection "$mech->cookie_jar"
.Vb 1
\&    my $cookies = $mech\->cookie_jar
.Ve
.PP
Returns all the Chrome cookies in a HTTP::Cookies::ChromeDevTools instance.
Setting a cookie in there will also set the cookie in Chrome.
.ie n .SS """$mech\->add_header( $name => $value, ... )"""
.el .SS "\f(CW$mech\->add_header( $name => $value, ... )\fP"
.IX Subsection "$mech->add_header( $name => $value, ... )"
.Vb 4
\&    $mech\->add_header(
\&        \*(AqX\-WWW\-Mechanize\-Chrome\*(Aq => "I\*(Aqm using it",
\&        Encoding => \*(Aqtext/klingon\*(Aq,
\&    );
.Ve
.PP
This method sets up custom headers that will be sent with \fBevery\fR \s-1HTTP\s0(S)
request that Chrome makes.
.PP
Note that currently, we only support one value per header.
.PP
Chrome since version 63+ does not allow setting and sending the \f(CW\*(C`Referer\*(C'\fR
header anymore. The bug report is
at <https://bugs.chromium.org/p/chromium/issues/detail?id=849972>.
.ie n .SS """$mech\->delete_header( $name , $name2... )"""
.el .SS "\f(CW$mech\->delete_header( $name , $name2... )\fP"
.IX Subsection "$mech->delete_header( $name , $name2... )"
.Vb 1
\&    $mech\->delete_header( \*(AqUser\-Agent\*(Aq );
.Ve
.PP
Removes \s-1HTTP\s0 headers from the agent's list of special headers. Note
that Chrome may still send a header with its default value.
.ie n .SS """$mech\->reset_headers"""
.el .SS "\f(CW$mech\->reset_headers\fP"
.IX Subsection "$mech->reset_headers"
.Vb 1
\&    $mech\->reset_headers();
.Ve
.PP
Removes all custom headers and makes Chrome send its defaults again.
.ie n .SS """$mech\->block_urls()"""
.el .SS "\f(CW$mech\->block_urls()\fP"
.IX Subsection "$mech->block_urls()"
.Vb 1
\&    $mech\->block_urls( \*(Aq//facebook.com/js/conversions/tracking.js\*(Aq );
.Ve
.PP
Sets the list of blocked URLs. These URLs will not be retrieved by Chrome
when loading a page. This is useful to eliminate tracking images or to test
resilience in face of bad network conditions.
.ie n .SS """$mech\->res()"" / ""$mech\->response(%options)"""
.el .SS "\f(CW$mech\->res()\fP / \f(CW$mech\->response(%options)\fP"
.IX Subsection "$mech->res() / $mech->response(%options)"
.Vb 1
\&    my $response = $mech\->response(headers => 0);
.Ve
.PP
Returns the current response as a HTTP::Response object.
.ie n .SS """$mech\->success()"""
.el .SS "\f(CW$mech\->success()\fP"
.IX Subsection "$mech->success()"
.Vb 3
\&    $mech\->get(\*(Aqhttps://google.com\*(Aq);
\&    print "Yay"
\&        if $mech\->success();
.Ve
.PP
Returns a boolean telling whether the last request was successful.
If there hasn't been an operation yet, returns false.
.PP
This is a convenience function that wraps \f(CW\*(C`$mech\->res\->is_success\*(C'\fR.
.ie n .SS """$mech\->status()"""
.el .SS "\f(CW$mech\->status()\fP"
.IX Subsection "$mech->status()"
.Vb 3
\&    $mech\->get(\*(Aqhttps://google.com\*(Aq);
\&    print $mech\->status();
\&    # 200
.Ve
.PP
Returns the \s-1HTTP\s0 status code of the response.
This is a 3\-digit number like 200 for \s-1OK, 404\s0 for not found, and so on.
.ie n .SS """$mech\->back()"""
.el .SS "\f(CW$mech\->back()\fP"
.IX Subsection "$mech->back()"
.Vb 1
\&    $mech\->back();
.Ve
.PP
Goes one page back in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->forward()"""
.el .SS "\f(CW$mech\->forward()\fP"
.IX Subsection "$mech->forward()"
.Vb 1
\&    $mech\->forward();
.Ve
.PP
Goes one page forward in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->stop()"""
.el .SS "\f(CW$mech\->stop()\fP"
.IX Subsection "$mech->stop()"
.Vb 1
\&    $mech\->stop();
.Ve
.PP
Stops all loading in Chrome, as if you pressed \f(CW\*(C`ESC\*(C'\fR.
.PP
This function is mostly of use in callbacks or in a timer callback from your
event loop.
.ie n .SS """$mech\->uri()"""
.el .SS "\f(CW$mech\->uri()\fP"
.IX Subsection "$mech->uri()"
.Vb 1
\&    print "We are at " . $mech\->uri;
.Ve
.PP
Returns the current document \s-1URI.\s0
.ie n .SS """$mech\->infinite_scroll( [$wait_time_in_seconds] )"""
.el .SS "\f(CW$mech\->infinite_scroll( [$wait_time_in_seconds] )\fP"
.IX Subsection "$mech->infinite_scroll( [$wait_time_in_seconds] )"
.Vb 1
\&    $new_content_found = $mech\->infinite_scroll(3);
.Ve
.PP
Loads content into pages that have \*(L"infinite scroll\*(R" capabilities by scrolling
to the bottom of the web page and waiting up to the number of seconds, as set by
the optional \f(CW$wait_time_in_seconds\fR argument, for the browser to load more
content. The default is to wait up to 20 seconds. For reasonbly fast sites,
the wait time can be set much lower.
.PP
The method returns a boolean \f(CW\*(C`true\*(C'\fR if new content is loaded, \f(CW\*(C`false\*(C'\fR
otherwise. You can scroll to the end (if there is one) of an infinitely
scrolling page like so:
.PP
.Vb 4
\&    while( $mech\->infinite_scroll ) {
\&        # Tests for exiting the loop earlier
\&        last if $count++ >= 10;
\&    }
.Ve
.SH "CONTENT METHODS"
.IX Header "CONTENT METHODS"
.ie n .SS """$mech\->document_future()"""
.el .SS "\f(CW$mech\->document_future()\fP"
.IX Subsection "$mech->document_future()"
.ie n .SS """$mech\->document()"""
.el .SS "\f(CW$mech\->document()\fP"
.IX Subsection "$mech->document()"
.Vb 1
\&    print $self\->document\->{nodeId};
.Ve
.PP
Returns the \f(CW\*(C`document\*(C'\fR node.
.PP
This is WWW::Mechanize::Chrome specific.
.ie n .SS """$mech\->content( %options )"""
.el .SS "\f(CW$mech\->content( %options )\fP"
.IX Subsection "$mech->content( %options )"
.Vb 4
\&  print $mech\->content;
\&  print $mech\->content( format => \*(Aqhtml\*(Aq ); # default
\&  print $mech\->content( format => \*(Aqtext\*(Aq ); # identical to \->text
\&  print $mech\->content( format => \*(Aqmhtml\*(Aq ); # identical to \->captureSnapshot
.Ve
.PP
This always returns the content as a Unicode string. It tries
to decode the raw content according to its input encoding.
This currently only works for \s-1HTML\s0 pages, not for images etc.
.PP
Recognized options:
.IP "\(bu" 4
\&\f(CW\*(C`format\*(C'\fR \- the stuff to return
.Sp
The allowed values are \f(CW\*(C`html\*(C'\fR and \f(CW\*(C`text\*(C'\fR. The default is \f(CW\*(C`html\*(C'\fR.
.ie n .SS """$mech\->text()"""
.el .SS "\f(CW$mech\->text()\fP"
.IX Subsection "$mech->text()"
.Vb 1
\&    print $mech\->text();
.Ve
.PP
Returns the text of the current \s-1HTML\s0 content.  If the content isn't
\&\s-1HTML,\s0 \f(CW$mech\fR will die.
.ie n .SS """$mech\->captureSnapshot_future()"""
.el .SS "\f(CW$mech\->captureSnapshot_future()\fP"
.IX Subsection "$mech->captureSnapshot_future()"
.ie n .SS """$mech\->captureSnapshot()"""
.el .SS "\f(CW$mech\->captureSnapshot()\fP"
.IX Subsection "$mech->captureSnapshot()"
.Vb 1
\&    print $mech\->captureSnapshot( format => \*(Aqmhtml\*(Aq )\->{data};
.Ve
.PP
Returns the current page as \s-1MHTML.\s0
.PP
This is WWW::Mechanize::Chrome specific.
.ie n .SS """$mech\->content_encoding()"""
.el .SS "\f(CW$mech\->content_encoding()\fP"
.IX Subsection "$mech->content_encoding()"
.Vb 1
\&    print "The content is encoded as ", $mech\->content_encoding;
.Ve
.PP
Returns the encoding that the content is in. This can be used
to convert the content from \s-1UTF\-8\s0 back to its native encoding.
.ie n .SS """$mech\->update_html( $html )"""
.el .SS "\f(CW$mech\->update_html( $html )\fP"
.IX Subsection "$mech->update_html( $html )"
.Vb 1
\&  $mech\->update_html($html);
.Ve
.PP
Writes \f(CW$html\fR into the current document. This is mostly
implemented as a convenience method for HTML::Display::MozRepl.
.PP
The value passed in as \f(CW$html\fR will be stringified.
.ie n .SS """$mech\->base()"""
.el .SS "\f(CW$mech\->base()\fP"
.IX Subsection "$mech->base()"
.Vb 1
\&  print $mech\->base;
.Ve
.PP
Returns the \s-1URL\s0 base for the current page.
.PP
The base is either specified through a \f(CW\*(C`base\*(C'\fR
tag or is the current \s-1URL.\s0
.PP
This method is specific to WWW::Mechanize::Chrome.
.ie n .SS """$mech\->content_type()"""
.el .SS "\f(CW$mech\->content_type()\fP"
.IX Subsection "$mech->content_type()"
.ie n .SS """$mech\->ct()"""
.el .SS "\f(CW$mech\->ct()\fP"
.IX Subsection "$mech->ct()"
.Vb 1
\&  print $mech\->content_type;
.Ve
.PP
Returns the content type of the currently loaded document
.ie n .SS """$mech\->is_html()"""
.el .SS "\f(CW$mech\->is_html()\fP"
.IX Subsection "$mech->is_html()"
.Vb 1
\&  print $mech\->is_html();
.Ve
.PP
Returns true/false on whether our content is \s-1HTML,\s0 according to the
\&\s-1HTTP\s0 headers.
.ie n .SS """$mech\->title()"""
.el .SS "\f(CW$mech\->title()\fP"
.IX Subsection "$mech->title()"
.Vb 1
\&  print "We are on page " . $mech\->title;
.Ve
.PP
Returns the current document title.
.SH "EXTRACTION METHODS"
.IX Header "EXTRACTION METHODS"
.ie n .SS """$mech\->links()"""
.el .SS "\f(CW$mech\->links()\fP"
.IX Subsection "$mech->links()"
.Vb 2
\&  print $_\->text . " \-> " . $_\->url . "\en"
\&      for $mech\->links;
.Ve
.PP
Returns all links in the document as WWW::Mechanize::Link objects.
.PP
Currently accepts no parameters. See \f(CW\*(C`\->xpath\*(C'\fR
or \f(CW\*(C`\->selector\*(C'\fR when you want more control.
.ie n .SS """$mech\->selector( $css_selector, %options )"""
.el .SS "\f(CW$mech\->selector( $css_selector, %options )\fP"
.IX Subsection "$mech->selector( $css_selector, %options )"
.Vb 1
\&  my @text = $mech\->selector(\*(Aqp.content\*(Aq);
.Ve
.PP
Returns all nodes matching the given \s-1CSS\s0 selector. If
\&\f(CW$css_selector\fR is an array reference, it returns
all nodes matched by any of the \s-1CSS\s0 selectors in the array.
.PP
This takes the same options that \f(CW\*(C`\->xpath\*(C'\fR does.
.PP
This method is implemented via WWW::Mechanize::Plugin::Selector.
.ie n .SS """$mech\->find_link_dom( %options )"""
.el .SS "\f(CW$mech\->find_link_dom( %options )\fP"
.IX Subsection "$mech->find_link_dom( %options )"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_link_dom( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method to find links, like WWW::Mechanize's
\&\f(CW\*(C`\->find_links\*(C'\fR method. This method returns \s-1DOM\s0 objects from
Chrome instead of WWW::Mechanize::Link objects.
.PP
Note that Chrome
might have reordered the links or frame links in the document
so the absolute numbers passed via \f(CW\*(C`n\*(C'\fR
might not be the same between
WWW::Mechanize and WWW::Mechanize::Chrome.
.PP
The supported options are:
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR and \f(CW\*(C`text_contains\*(C'\fR and \f(CW\*(C`text_regex\*(C'\fR
.Sp
Match the text of the link as a complete string, substring or regular expression.
.Sp
Matching as a complete string or substring is a bit faster, as it is
done in the XPath engine of Chrome.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR and \f(CW\*(C`id_contains\*(C'\fR and \f(CW\*(C`id_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`id\*(C'\fR attribute of the link completely or as part
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR and \f(CW\*(C`name_contains\*(C'\fR and \f(CW\*(C`name_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`name\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR and \f(CW\*(C`url_regex\*(C'\fR
.Sp
Matches the \s-1URL\s0 attribute of the link (\f(CW\*(C`href\*(C'\fR, \f(CW\*(C`src\*(C'\fR or \f(CW\*(C`content\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`class\*(C'\fR \- the \f(CW\*(C`class\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`n\*(C'\fR \- the (1\-based) index. Defaults to returning the first link.
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.Sp
The method \f(CW\*(C`croak\*(C'\fRs if no link is found. If the \f(CW\*(C`single\*(C'\fR option is true,
it also \f(CW\*(C`croak\*(C'\fRs when more than one link is found.
.ie n .SS """$mech\->find_link( %options )"""
.el .SS "\f(CW$mech\->find_link( %options )\fP"
.IX Subsection "$mech->find_link( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_link( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method quite similar to WWW::Mechanize's method.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns a WWW::Mechanize::Link object.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links( %options )"""
.el .SS "\f(CW$mech\->find_all_links( %options )\fP"
.IX Subsection "$mech->find_all_links( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_all_links( text_regex => qr/google/i );
.Ve
.PP
Finds all links in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links_dom %options"""
.el .SS "\f(CW$mech\->find_all_links_dom %options\fP"
.IX Subsection "$mech->find_all_links_dom %options"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_all_links_dom( text_regex => qr/google/i );
.Ve
.PP
Finds all matching linky \s-1DOM\s0 nodes in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->follow_link( $link )"""
.el .SS "\f(CW$mech\->follow_link( $link )\fP"
.IX Subsection "$mech->follow_link( $link )"
.ie n .SS """$mech\->follow_link( %options )"""
.el .SS "\f(CW$mech\->follow_link( %options )\fP"
.IX Subsection "$mech->follow_link( %options )"
.Vb 1
\&  $mech\->follow_link( xpath => \*(Aq//a[text() = "Click here!"]\*(Aq );
.Ve
.PP
Follows the given link. Takes the same parameters that \f(CW\*(C`find_link_dom\*(C'\fR
uses.
.PP
Note that \f(CW\*(C`\->follow_link\*(C'\fR will only try to follow link-like
things like \f(CW\*(C`A\*(C'\fR tags.
.ie n .SS """$mech\->xpath( $query, %options )"""
.el .SS "\f(CW$mech\->xpath( $query, %options )\fP"
.IX Subsection "$mech->xpath( $query, %options )"
.Vb 2
\&    my $link = $mech\->xpath(\*(Aq//a[id="clickme"]\*(Aq, one => 1);
\&    # croaks if there is no link or more than one link found
\&
\&    my @para = $mech\->xpath(\*(Aq//p\*(Aq);
\&    # Collects all paragraphs
\&
\&    my @para_text = $mech\->xpath(\*(Aq//p/text()\*(Aq, type => $mech\->xpathResult(\*(AqSTRING_TYPE\*(Aq));
\&    # Collects all paragraphs as text
.Ve
.PP
Runs an XPath query in Chrome against the current document.
.PP
If you need more information about the returned results,
use the \f(CW\*(C`\->xpathEx()\*(C'\fR function.
.PP
The options allow the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`document\*(C'\fR \- document in which the query is to be executed. Use this to
search a node within a specific subframe of \f(CW\*(C`$mech\->document\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`frames\*(C'\fR \- if true, search all documents in all frames and iframes.
This may or may not conflict with \f(CW\*(C`node\*(C'\fR. This will default to the
\&\f(CW\*(C`frames\*(C'\fR setting of the WWW::Mechanize::Chrome object.
.IP "\(bu" 4
\&\f(CW\*(C`node\*(C'\fR \- node relative to which the query is to be executed. Note
that you will have to use a relative XPath expression as well. Use
.Sp
.Vb 1
\&  .//foo
.Ve
.Sp
instead of
.Sp
.Vb 1
\&  //foo
.Ve
.Sp
Querying relative to a node only works for restricting to children of the node,
not for anything else. This is because we need to do the ancestor filtering
ourselves instead of having a Chrome \s-1API\s0 for it.
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`maybe\*(C'\fR \- If true, ensure that at most one element is found. Otherwise
croak or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`all\*(C'\fR \- If true, return all elements found. This is the default.
You can use this option if you want to use \f(CW\*(C`\->xpath\*(C'\fR in scalar context
to count the number of matched elements, as it will otherwise emit a warning
for each usage in scalar context without any of the above restricting options.
.IP "\(bu" 4
\&\f(CW\*(C`any\*(C'\fR \- no error is raised, no matter if an item is found or not.
.PP
Returns the matched results as WWW::Mechanize::Chrome::Node objects.
.PP
You can pass in a list of queries as an array reference for the first parameter.
The result will then be the list of all elements matching any of the queries.
.PP
This is a method that is not implemented in WWW::Mechanize.
.PP
In the long run, this should go into a general plugin for
WWW::Mechanize.
.ie n .SS """$mech\->by_id( $id, %options )"""
.el .SS "\f(CW$mech\->by_id( $id, %options )\fP"
.IX Subsection "$mech->by_id( $id, %options )"
.Vb 1
\&  my @text = $mech\->by_id(\*(Aq_foo:bar\*(Aq);
.Ve
.PP
Returns all nodes matching the given ids. If
\&\f(CW$id\fR is an array reference, it returns
all nodes matched by any of the ids in the array.
.PP
This method is equivalent to calling \f(CW\*(C`\->xpath\*(C'\fR :
.PP
.Vb 1
\&    $self\->xpath(qq{//*[\e@id="$_"]}, %options)
.Ve
.PP
It is convenient when your element ids get mistaken for
\&\s-1CSS\s0 selectors.
.ie n .SS """$mech\->click( $name [,$x ,$y] )"""
.el .SS "\f(CW$mech\->click( $name [,$x ,$y] )\fP"
.IX Subsection "$mech->click( $name [,$x ,$y] )"
.Vb 2
\&  # If the element is within a <form> element
\&  $mech\->click( \*(Aqgo\*(Aq );
\&
\&  # If the element is anywhere on the page
\&  $mech\->click({ xpath => \*(Aq//button[@name="go"]\*(Aq });
.Ve
.PP
Has the effect of clicking a button (or other element) on the current form. The
first argument is the \f(CW\*(C`name\*(C'\fR of the button to be clicked. The second and third
arguments (optional) allow you to specify the (x,y) coordinates of the click.
.PP
If there is only one button on the form, \f(CW\*(C`$mech\->click()\*(C'\fR with
no arguments simply clicks that one button.
.PP
If you pass in a hash reference instead of a name,
the following keys are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR \- Find the element to click by its contained text
.IP "\(bu" 4
\&\f(CW\*(C`selector\*(C'\fR \- Find the element to click by the \s-1CSS\s0 selector
.IP "\(bu" 4
\&\f(CW\*(C`xpath\*(C'\fR \- Find the element to click by the XPath query
.IP "\(bu" 4
\&\f(CW\*(C`dom\*(C'\fR \- Click on the passed \s-1DOM\s0 element
.Sp
You can use this to click on arbitrary page elements. There is no convenient
way to pass x/y co-ordinates when using the \f(CW\*(C`dom\*(C'\fR option.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- Click on the element with the given id
.Sp
This is useful if your document ids contain characters that
do look like \s-1CSS\s0 selectors. It is equivalent to
.Sp
.Vb 1
\&    xpath => qq{//*[\e@id="$id"]}
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`intrapage\*(C'\fR \- Override the detection of whether to wait for a \s-1HTTP\s0 response
or not. Setting this will never wait for an \s-1HTTP\s0 response.
.PP
Returns a HTTP::Response object.
.PP
As a deviation from the WWW::Mechanize \s-1API,\s0 you can also pass a
hash reference as the first parameter. In it, you can specify
the parameters to search much like for the \f(CW\*(C`find_link\*(C'\fR calls.
.ie n .SS """$mech\->click_button( ... )"""
.el .SS "\f(CW$mech\->click_button( ... )\fP"
.IX Subsection "$mech->click_button( ... )"
.Vb 2
\&  $mech\->click_button( name => \*(Aqgo\*(Aq );
\&  $mech\->click_button( input => $mybutton );
.Ve
.PP
Has the effect of clicking a button on the current form by specifying its
name, value, or index. Its arguments are a list of key/value pairs. Only
one of name, number, input or value must be specified in the keys.
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR \- name of the button
.IP "\(bu" 4
\&\f(CW\*(C`value\*(C'\fR \- value of the button
.IP "\(bu" 4
\&\f(CW\*(C`input\*(C'\fR \- \s-1DOM\s0 node
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- id of the button
.IP "\(bu" 4
\&\f(CW\*(C`number\*(C'\fR \- number of the button
.PP
If you find yourself wanting to specify a button through its
\&\f(CW\*(C`selector\*(C'\fR or \f(CW\*(C`xpath\*(C'\fR, consider using \f(CW\*(C`\->click\*(C'\fR instead.
.SH "FORM METHODS"
.IX Header "FORM METHODS"
.ie n .SS """$mech\->current_form()"""
.el .SS "\f(CW$mech\->current_form()\fP"
.IX Subsection "$mech->current_form()"
.Vb 1
\&  print $mech\->current_form\->{name};
.Ve
.PP
Returns the current form.
.PP
This method is incompatible with WWW::Mechanize.
It returns the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR object and not
a HTML::Form instance.
.PP
The current form will be reset by WWW::Mechanize::Chrome
on calls to \f(CW\*(C`\->get()\*(C'\fR and \f(CW\*(C`\->get_local()\*(C'\fR,
and on calls to \f(CW\*(C`\->submit()\*(C'\fR and \f(CW\*(C`\->submit_with_fields\*(C'\fR.
.ie n .SS """$mech\->dump_forms( [$fh] )"""
.el .SS "\f(CW$mech\->dump_forms( [$fh] )\fP"
.IX Subsection "$mech->dump_forms( [$fh] )"
.Vb 3
\&  open my $fh, \*(Aq>\*(Aq, \*(Aqform\-log.txt\*(Aq
\&      or die "Couldn\*(Aqt open logfile \*(Aqform\-log.txt\*(Aq: $!";
\&  $mech\->dump_forms( $fh );
.Ve
.PP
Prints a dump of the forms on the current page to
the filehandle \f(CW$fh\fR. If \f(CW$fh\fR is not specified or is undef, it dumps
to \f(CW\*(C`STDOUT\*(C'\fR.
.ie n .SS """$mech\->form_name( $name [, %options] )"""
.el .SS "\f(CW$mech\->form_name( $name [, %options] )\fP"
.IX Subsection "$mech->form_name( $name [, %options] )"
.Vb 1
\&  $mech\->form_name( \*(Aqsearch\*(Aq );
.Ve
.PP
Selects the current form by its name. The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_id( $id [, %options] )"""
.el .SS "\f(CW$mech\->form_id( $id [, %options] )\fP"
.IX Subsection "$mech->form_id( $id [, %options] )"
.Vb 1
\&  $mech\->form_id( \*(Aqlogin\*(Aq );
.Ve
.PP
Selects the current form by its \f(CW\*(C`id\*(C'\fR attribute.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.PP
This is equivalent to calling
.PP
.Vb 1
\&    $mech\->by_id($id,single => 1,%options)
.Ve
.ie n .SS """$mech\->form_number( $number [, %options] )"""
.el .SS "\f(CW$mech\->form_number( $number [, %options] )\fP"
.IX Subsection "$mech->form_number( $number [, %options] )"
.Vb 1
\&  $mech\->form_number( 2 );
.Ve
.PP
Selects the \fInumber\fRth form.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_with_fields( [$options], @fields )"""
.el .SS "\f(CW$mech\->form_with_fields( [$options], @fields )\fP"
.IX Subsection "$mech->form_with_fields( [$options], @fields )"
.Vb 3
\&  $mech\->form_with_fields(
\&      \*(Aquser\*(Aq, \*(Aqpassword\*(Aq
\&  );
.Ve
.PP
Find the form which has the listed fields.
.PP
If the first argument is a hash reference, it's taken
as options to \f(CW\*(C`\->xpath\*(C'\fR.
.PP
See also \*(L"$mech\->submit_form\*(R".
.ie n .SS """$mech\->forms( %options )"""
.el .SS "\f(CW$mech\->forms( %options )\fP"
.IX Subsection "$mech->forms( %options )"
.Vb 1
\&  my @forms = $mech\->forms();
.Ve
.PP
When called in a list context, returns a list
of the forms found in the last fetched page.
In a scalar context, returns a reference to
an array with those forms.
.PP
The options
are identical to those accepted by the \*(L"$mech\->selector\*(R" method.
.PP
The returned elements are the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR elements.
.ie n .SS """$mech\->field( $selector, $value, [, $index, \e@pre_events [,\e@post_events]] )"""
.el .SS "\f(CW$mech\->field( $selector, $value, [, $index, \e@pre_events [,\e@post_events]] )\fP"
.IX Subsection "$mech->field( $selector, $value, [, $index, @pre_events [,@post_events]] )"
.Vb 3
\&  $mech\->field( user => \*(Aqjoe\*(Aq );
\&  $mech\->field( not_empty => \*(Aq\*(Aq, 0, [], [] ); # bypass JS validation
\&  $mech\->field( date => \*(Aq2020\-04\-01\*(Aq, 2 );    # set second field named "date"
.Ve
.PP
Sets the field with the name given in \f(CW$selector\fR to the given value.
Returns the value.
.PP
The method understands very basic \s-1CSS\s0 selectors in the value for \f(CW$selector\fR,
like the HTML::Form \fBfind_input()\fR method.
.PP
A selector prefixed with '#' must match the id attribute of the input.
A selector prefixed with '.' matches the class attribute. A selector
prefixed with '^' or with no prefix matches the name attribute.
.PP
By passing the array reference \f(CW@pre_events\fR, you can indicate which
Javascript events you want to be triggered before setting the value.
\&\f(CW@post_events\fR contains the events you want to be triggered
after setting the value.
.PP
By default, the events set in the
constructor for \f(CW\*(C`pre_events\*(C'\fR and \f(CW\*(C`post_events\*(C'\fR
are triggered.
.ie n .SS """$mech\->sendkeys( %options )"""
.el .SS "\f(CW$mech\->sendkeys( %options )\fP"
.IX Subsection "$mech->sendkeys( %options )"
.Vb 1
\&    $mech\->sendkeys( string => "Hello World" );
.Ve
.PP
Sends a series of keystrokes. The keystrokes can be either a string or a
reference to an array containing the detailed data as hashes.
.IP "\fBstring\fR \- the string to send as keystrokes" 4
.IX Item "string - the string to send as keystrokes"
.PD 0
.IP "\fBkeys\fR \- reference of the array to send as keystrokes" 4
.IX Item "keys - reference of the array to send as keystrokes"
.IP "\fBdelay\fR \- delay in ms to sleep between keys" 4
.IX Item "delay - delay in ms to sleep between keys"
.PD
.ie n .SS """$mech\->upload( $selector, $value )"""
.el .SS "\f(CW$mech\->upload( $selector, $value )\fP"
.IX Subsection "$mech->upload( $selector, $value )"
.Vb 1
\&  $mech\->upload( user_picture => \*(AqC:/Users/Joe/face.png\*(Aq );
.Ve
.PP
Sets the file upload field with the name given in \f(CW$selector\fR to the given
file. The filename must be an absolute path and filename in the local
filesystem.
.PP
The method understands very basic \s-1CSS\s0 selectors in the value for \f(CW$selector\fR,
like the \f(CW\*(C`\->field\*(C'\fR method.
.ie n .SS """$mech\->value( $selector_or_element, [ $index | %options] )"""
.el .SS "\f(CW$mech\->value( $selector_or_element, [ $index | %options] )\fP"
.IX Subsection "$mech->value( $selector_or_element, [ $index | %options] )"
.Vb 1
\&    print $mech\->value( \*(Aquser\*(Aq );
.Ve
.PP
Returns the value of the field given by \f(CW$selector_or_name\fR or of the
\&\s-1DOM\s0 element passed in.
.PP
If you have multiple fields with the same name, you can use the index
to specify the index directly:
.PP
.Vb 1
\&    print $mech\->value( \*(Aqdate\*(Aq, 2 ); # get the second field named "date"
.Ve
.PP
The legacy form of
.PP
.Vb 1
\&    $mech\->value( name => value );
.Ve
.PP
is not supported anymore.
.PP
For fields that can have multiple values, like a \f(CW\*(C`select\*(C'\fR field,
the method is context sensitive and returns the first selected
value in scalar context and all values in list context.
.PP
Note that this method does not support file uploads. See the \f(CW\*(C`\->upload\*(C'\fR
method for that.
.ie n .SS """$mech\->get_set_value( %options )"""
.el .SS "\f(CW$mech\->get_set_value( %options )\fP"
.IX Subsection "$mech->get_set_value( %options )"
Allows fine-grained access to getting/setting a value
with a different \s-1API.\s0 Supported keys are:
.PP
.Vb 4
\&  name
\&  value
\&  pre
\&  post
.Ve
.PP
in addition to all keys that \f(CW\*(C`$mech\->xpath\*(C'\fR supports.
.ie n .SS """$mech\->select( $name, $value )"""
.el .SS "\f(CW$mech\->select( $name, $value )\fP"
.IX Subsection "$mech->select( $name, $value )"
.ie n .SS """$mech\->select( $name, \e@values )"""
.el .SS "\f(CW$mech\->select( $name, \e@values )\fP"
.IX Subsection "$mech->select( $name, @values )"
.Vb 1
\&    $mech\->select( \*(Aqitems\*(Aq, \*(Aqbanana\*(Aq );
.Ve
.PP
Given the name of a \f(CW\*(C`select\*(C'\fR field, set its value to the value
specified.  If the field is not \f(CW\*(C`<select multiple>\*(C'\fR and the
\&\f(CW$value\fR is an array, only the \fBfirst\fR value will be set.
Passing \f(CW$value\fR as a hash with
an \f(CW\*(C`n\*(C'\fR key selects an item by number (e.g.
\&\f(CW\*(C`{n => 3}\*(C'\fR or \f(CW\*(C`{n => [2,4]}\*(C'\fR).
The numbering starts at 1.  This applies to the current form.
.PP
If you have a field with \f(CW\*(C`<select multiple>\*(C'\fR and you pass a single
\&\f(CW$value\fR, then \f(CW$value\fR will be added to the list of fields selected,
without clearing the others.  However, if you pass an array reference,
then all previously selected values will be cleared.
.PP
Returns true on successfully setting the value. On failure, returns
false and calls \f(CW\*(C`$self>warn()\*(C'\fR with an error message.
.ie n .SS """$mech\->tick( $name, $value [, $set ] )"""
.el .SS "\f(CW$mech\->tick( $name, $value [, $set ] )\fP"
.IX Subsection "$mech->tick( $name, $value [, $set ] )"
.Vb 1
\&    $mech\->tick("confirmation_box", \*(Aqyes\*(Aq);
.Ve
.PP
\&\*(L"Ticks\*(R" the first checkbox that has both the name and value associated with it
on the current form. Dies if there is no named check box for that value.
Passing in a false value as the third optional argument will cause the
checkbox to be unticked.
.PP
(Un)ticking the checkbox is done by sending a click event to it if needed.
If \f(CW$value\fR is \f(CW\*(C`undef\*(C'\fR, the first checkbox matching \f(CW$name\fR will
be (un)ticked.
.PP
If \f(CW$name\fR is a reference to a hash, that hash will be used
as the options to \f(CW\*(C`\->find_link_dom\*(C'\fR to find the element.
.ie n .SS """$mech\->untick( $name, $value )"""
.el .SS "\f(CW$mech\->untick( $name, $value )\fP"
.IX Subsection "$mech->untick( $name, $value )"
.Vb 1
\&  $mech\->untick(\*(Aqspam_confirm\*(Aq,\*(Aqyes\*(Aq,undef)
.Ve
.PP
Causes the checkbox to be unticked. Shorthand for
.PP
.Vb 1
\&  $mech\->tick($name,$value,undef)
.Ve
.ie n .SS """$mech\->submit( $form )"""
.el .SS "\f(CW$mech\->submit( $form )\fP"
.IX Subsection "$mech->submit( $form )"
.Vb 1
\&  $mech\->submit;
.Ve
.PP
Submits the form. Note that this does \fBnot\fR fire the \f(CW\*(C`onClick\*(C'\fR
event and thus also does not fire eventual Javascript handlers.
Maybe you want to use \f(CW\*(C`$mech\->click\*(C'\fR instead.
.PP
The default is to submit the current form as returned
by \f(CW\*(C`$mech\->current_form\*(C'\fR.
.ie n .SS """$mech\->submit_form( %options )"""
.el .SS "\f(CW$mech\->submit_form( %options )\fP"
.IX Subsection "$mech->submit_form( %options )"
.Vb 6
\&  $mech\->submit_form(
\&      with_fields => {
\&          user => \*(Aqme\*(Aq,
\&          pass => \*(Aqsecret\*(Aq,
\&      }
\&  );
.Ve
.PP
This method lets you select a form from the previously fetched page,
fill in its fields, and submit it. It combines the form_number/form_name,
\&\f(CW\*(C`\->set_fields\*(C'\fR and \f(CW\*(C`\->click methods\*(C'\fR into one higher level call. Its
arguments are a list of key/value pairs, all of which are optional.
.IP "\(bu" 4
\&\f(CW\*(C`form => $mech\->current_form()\*(C'\fR
.Sp
Specifies the form to be filled and submitted. Defaults to the current form.
.IP "\(bu" 4
\&\f(CW\*(C`fields => \e%fields\*(C'\fR
.Sp
Specifies the fields to be filled in the current form
.IP "\(bu" 4
\&\f(CW\*(C`with_fields => \e%fields\*(C'\fR
.Sp
Probably all you need for the common case. It combines a smart form selector
and data setting in one operation. It selects the first form that contains
all fields mentioned in \e%fields. This is nice because you don't need to
know the name or number of the form to do this.
.Sp
(calls \*(L"$mech\->\fBform_with_fields()\fR\*(R" and \*(L"$mech\->\fBset_fields()\fR\*(R").
.Sp
If you choose this, the form_number, form_name, form_id and fields options
will be ignored.
.ie n .SS """$mech\->set_fields( $name => $value, ... )"""
.el .SS "\f(CW$mech\->set_fields( $name => $value, ... )\fP"
.IX Subsection "$mech->set_fields( $name => $value, ... )"
.Vb 4
\&  $mech\->set_fields(
\&      user => \*(Aqme\*(Aq,
\&      pass => \*(Aqsecret\*(Aq,
\&  );
.Ve
.PP
This method sets multiple fields of the current form. It takes a list of
field name and value pairs. If there is more than one field with the same
name, the first one found is set. If you want to select which of the
duplicate field to set, use a value which is an anonymous array which
has the field value and its number as the 2 elements.
.SH "CONTENT MONITORING METHODS"
.IX Header "CONTENT MONITORING METHODS"
.ie n .SS """$mech\->is_visible( $element )"""
.el .SS "\f(CW$mech\->is_visible( $element )\fP"
.IX Subsection "$mech->is_visible( $element )"
.ie n .SS """$mech\->is_visible(  %options )"""
.el .SS "\f(CW$mech\->is_visible(  %options )\fP"
.IX Subsection "$mech->is_visible( %options )"
.Vb 3
\&  if ($mech\->is_visible( selector => \*(Aq#login\*(Aq )) {
\&      print "You can log in now.";
\&  };
.Ve
.PP
Returns true if the element is visible, that is, it is
a member of the \s-1DOM\s0 and neither it nor its ancestors have
a \s-1CSS\s0 \f(CW\*(C`visibility\*(C'\fR attribute of \f(CW\*(C`hidden\*(C'\fR or
a \f(CW\*(C`display\*(C'\fR attribute of \f(CW\*(C`none\*(C'\fR.
.PP
You can either pass in a \s-1DOM\s0 element or a set of key/value
pairs to search the document for the element you want.
.IP "\(bu" 4
\&\f(CW\*(C`xpath\*(C'\fR \- the XPath query
.IP "\(bu" 4
\&\f(CW\*(C`selector\*(C'\fR \- the \s-1CSS\s0 selector
.IP "\(bu" 4
\&\f(CW\*(C`dom\*(C'\fR \- a \s-1DOM\s0 node
.PP
The remaining options are passed through to either the
/$mech\->xpath or /$mech\->selector method.
.ie n .SS """$mech\->wait_until_invisible( $element )"""
.el .SS "\f(CW$mech\->wait_until_invisible( $element )\fP"
.IX Subsection "$mech->wait_until_invisible( $element )"
.ie n .SS """$mech\->wait_until_invisible( %options )"""
.el .SS "\f(CW$mech\->wait_until_invisible( %options )\fP"
.IX Subsection "$mech->wait_until_invisible( %options )"
.Vb 1
\&  $mech\->wait_until_invisible( $please_wait );
.Ve
.PP
Waits until an element is not visible anymore.
.PP
Takes the same options as \*(L"\->is_visible\*(R" in \f(CW$mech\fR\->is_visible.
.PP
In addition, the following options are accepted:
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR \- the timeout after which the function will \f(CW\*(C`croak\*(C'\fR. To catch
the condition and handle it in your calling program, use an eval block.
A timeout of \f(CW0\fR means to never time out.
.IP "\(bu" 4
\&\f(CW\*(C`sleep\*(C'\fR \- the interval in seconds used to sleep. Subsecond
intervals are possible.
.PP
Note that when passing in a selector, that selector is requeried
on every poll instance. So the following query will work as expected:
.PP
.Vb 1
\&  xpath => \*(Aq//*[contains(text(),"stand by")]\*(Aq
.Ve
.PP
This also means that if your selector query relies on finding
a changing text, you need to pass the node explicitly instead of
passing the selector.
.ie n .SS """$mech\->wait_until_visible( %options )"""
.el .SS "\f(CW$mech\->wait_until_visible( %options )\fP"
.IX Subsection "$mech->wait_until_visible( %options )"
.Vb 1
\&  $mech\->wait_until_visible( selector => \*(Aqa.download\*(Aq );
.Ve
.PP
Waits until an query returns a visible element.
.PP
Takes the same options as \*(L"\->is_visible\*(R" in \f(CW$mech\fR\->is_visible.
.PP
In addition, the following options are accepted:
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR \- the timeout after which the function will \f(CW\*(C`croak\*(C'\fR. To catch
the condition and handle it in your calling program, use an eval block.
A timeout of \f(CW0\fR means to never time out.
.IP "\(bu" 4
\&\f(CW\*(C`sleep\*(C'\fR \- the interval in seconds used to sleep. Subsecond
intervals are possible.
.PP
Note that when passing in a selector, that selector is requeried
on every poll instance. So the following query will work as expected:
.PP
.Vb 1
\&  xpath => \*(Aq//*[contains(text(),"click here for download")]\*(Aq
.Ve
.SH "CONTENT RENDERING METHODS"
.IX Header "CONTENT RENDERING METHODS"
.ie n .SS """$mech\->content_as_png()"""
.el .SS "\f(CW$mech\->content_as_png()\fP"
.IX Subsection "$mech->content_as_png()"
.Vb 1
\&    my $png_data = $mech\->content_as_png();
\&
\&    # Create scaled\-down 480px wide preview
\&    my $png_data = $mech\->content_as_png(undef, { width => 480 });
.Ve
.PP
Returns the given tab or the current page rendered as \s-1PNG\s0 image.
.PP
All parameters are optional.
.PP
This method is specific to WWW::Mechanize::Chrome.
.ie n .SS """$mech\->saveResources_future"""
.el .SS "\f(CW$mech\->saveResources_future\fP"
.IX Subsection "$mech->saveResources_future"
.Vb 5
\&    my $file_map = $mech\->saveResources_future(
\&        target_file => \*(Aqthis_page.html\*(Aq,
\&        target_dir  => \*(Aqthis_page_files/\*(Aq,
\&        wanted      => sub { $_[0]\->{url} =~ m!^https?:!i },
\&    )\->get();
.Ve
.PP
Rough prototype of \*(L"Save Complete Page\*(R" feature
.ie n .SS """$mech\->viewport_size"""
.el .SS "\f(CW$mech\->viewport_size\fP"
.IX Subsection "$mech->viewport_size"
.Vb 2
\&  print Dumper $mech\->viewport_size;
\&  $mech\->viewport_size({ width => 1388, height => 792 });
.Ve
.PP
Returns (or sets) the new size of the viewport (the \*(L"window\*(R").
.PP
The recognized keys are:
.PP
.Vb 8
\&  width
\&  height
\&  deviceScaleFactor
\&  mobile
\&  screenWidth
\&  screenHeight
\&  positionX
\&  positionY
.Ve
.ie n .SS """$mech\->element_as_png( $element )"""
.el .SS "\f(CW$mech\->element_as_png( $element )\fP"
.IX Subsection "$mech->element_as_png( $element )"
.Vb 2
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my $i_want_this = $mech\->element_as_png($shiny);
.Ve
.PP
Returns \s-1PNG\s0 image data for a single element
.ie n .SS """$mech\->render_element( %options )"""
.el .SS "\f(CW$mech\->render_element( %options )\fP"
.IX Subsection "$mech->render_element( %options )"
.Vb 5
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my $i_want_this= $mech\->render_element(
\&        element => $shiny,
\&        format => \*(Aqpng\*(Aq,
\&    );
.Ve
.PP
Returns the data for a single element
or writes it to a file. It accepts
all options of \f(CW\*(C`\->render_content\*(C'\fR.
.PP
Note that while the image will have the node in the upper left
corner, the width and height of the resulting image will still
be the size of the browser window. Cut the image using
\&\f(CW\*(C`element_coordinates\*(C'\fR if you need exactly the element.
.ie n .SS """$mech\->element_coordinates( $element )"""
.el .SS "\f(CW$mech\->element_coordinates( $element )\fP"
.IX Subsection "$mech->element_coordinates( $element )"
.Vb 3
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my ($pos) = $mech\->element_coordinates($shiny);
\&    print $pos\->{left},\*(Aq,\*(Aq, $pos\->{top};
.Ve
.PP
Returns the page-coordinates of the \f(CW$element\fR
in pixels as a hash with four entries, \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR.
.PP
This function might get moved into another module more geared
towards rendering \s-1HTML.\s0
.ie n .SS """$mech\->render_content(%options)"""
.el .SS "\f(CW$mech\->render_content(%options)\fP"
.IX Subsection "$mech->render_content(%options)"
.Vb 1
\&    my $pdf_data = $mech\->render_content( format => \*(Aqpdf\*(Aq );
.Ve
.PP
Returns the current page rendered as \s-1PDF\s0 or \s-1PNG\s0
as a bytestring.
.PP
Note that the \s-1PDF\s0 format will only be successful with headless Chrome. At least
on Windows, when launching Chrome with a \s-1UI,\s0 printing to \s-1PDF\s0 will
be unavailable.
.PP
This method is specific to WWW::Mechanize::Chrome.
.ie n .SS """$mech\->content_as_pdf(%options)"""
.el .SS "\f(CW$mech\->content_as_pdf(%options)\fP"
.IX Subsection "$mech->content_as_pdf(%options)"
.Vb 1
\&    my $pdf_data = $mech\->content_as_pdf();
\&
\&    my $pdf_data = $mech\->content_as_pdf( format => \*(AqA4\*(Aq );
\&
\&    my $pdf_data = $mech\->content_as_pdf( paperWidth => 8, paperHeight => 11 );
.Ve
.PP
Returns the current page rendered in \s-1PDF\s0 format as a bytestring. The page format
can be specified through the \f(CW\*(C`format\*(C'\fR option.
.PP
Note that this method will only be successful with headless Chrome. At least on
Windows, when launching Chrome with a \s-1UI,\s0 printing to \s-1PDF\s0 will be unavailable.
See the \f(CW\*(C`html\-to\-pdf.pl\*(C'\fR script in the \f(CW\*(C`examples/\*(C'\fR directory of this distribution.
.PP
This method is specific to WWW::Mechanize::Chrome.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These are methods that are available but exist mostly as internal
helper methods. Use of these is discouraged.
.ie n .SS """$mech\->element_query( \e@elements, \e%attributes )"""
.el .SS "\f(CW$mech\->element_query( \e@elements, \e%attributes )\fP"
.IX Subsection "$mech->element_query( @elements, %attributes )"
.Vb 2
\&    my $query = $mech\->element_query([\*(Aqinput\*(Aq, \*(Aqselect\*(Aq, \*(Aqtextarea\*(Aq],
\&                               { name => \*(Aqfoo\*(Aq });
.Ve
.PP
Returns the XPath query that searches for all elements with \f(CW\*(C`tagName\*(C'\fRs
in \f(CW@elements\fR having the attributes \f(CW%attributes\fR. The \f(CW@elements\fR
will form an \f(CW\*(C`or\*(C'\fR condition, while the attributes will form an \f(CW\*(C`and\*(C'\fR
condition.
.SH "DEBUGGING METHODS"
.IX Header "DEBUGGING METHODS"
This module can collect the screencasts that Chrome can produce. The screencasts
are sent to your callback which either feeds them to \f(CW\*(C`ffmpeg\*(C'\fR to create a video
out of them or dumps them to disk as sequential images.
.PP
.Vb 3
\&  sub saveFrame {
\&      my( $mech, $framePNG ) = @_;
\&      print $framePNG\->{data};
\&
\&  }
\&
\&  $mech\->setScreenFrameCallback( \e&saveFrame );
\&  ... do stuff ...
\&  $mech\->setScreenFrameCallback( undef ); # stop recording
.Ve
.PP
If you want a premade screencast receiver for debugging headless Chrome
sessions, see Mojolicious::Plugin::PNGCast.
.ie n .SS """$mech\->sleep"""
.el .SS "\f(CW$mech\->sleep\fP"
.IX Subsection "$mech->sleep"
.Vb 1
\&  $mech\->sleep( 2 ); # wait for things to settle down
.Ve
.PP
Suspends the progress of the program while still handling messages from
Chrome.
.PP
The main use of this method is to give Chrome enough time to send all its
screencast frames and to catch up before shutting down the connection.
.SH "INCOMPATIBILITIES WITH WWW::Mechanize"
.IX Header "INCOMPATIBILITIES WITH WWW::Mechanize"
As this module is in a very early stage of development,
there are many incompatibilities. The main thing is
that only the most needed WWW::Mechanize methods
have been implemented by me so far.
.SS "Unsupported Methods"
.IX Subsection "Unsupported Methods"
At least the following methods are unsupported:
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_inputs\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_submits\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_image\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.SS "Functions that will likely never be implemented"
.IX Subsection "Functions that will likely never be implemented"
These functions are unlikely to be implemented because
they make little sense in the context of Chrome.
.IP "\(bu" 4
\&\f(CW\*(C`\->clone\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->credentials( $username, $password )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->get_basic_credentials( $realm, $uri, $isproxy )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->clear_credentials()\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->put\*(C'\fR
.Sp
I have no use for it
.IP "\(bu" 4
\&\f(CW\*(C`\->post\*(C'\fR
.Sp
This module does not yet support \s-1POST\s0 requests
.SH "INSTALLING"
.IX Header "INSTALLING"
See WWW::Mechanize::Chrome::Install
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
<https://developer.chrome.com/devtools/docs/debugging\-clients> \- the Chrome
DevTools homepage
.IP "\(bu" 4
<https://github.com/GoogleChrome/lighthouse> \- Google Lighthouse, the main
client of the Chrome \s-1API\s0
.IP "\(bu" 4
WWW::Mechanize \- the module whose \s-1API\s0 grandfathered this module
.IP "\(bu" 4
WWW::Mechanize::Chrome::Node \- objects representing \s-1HTML\s0 in Chrome
.IP "\(bu" 4
WWW::Mechanize::Firefox \- a similar module with a visible application
automating Firefox
.IP "\(bu" 4
WWW::Mechanize::PhantomJS \- a similar module without a visible application
automating PhantomJS
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/www\-mechanize\-chrome>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is <https://perlmonks.org/>.
.SH "TALKS"
.IX Header "TALKS"
I've given a German talk at \s-1GPW 2017,\s0 see <http://act.yapc.eu/gpw2017/talk/7027>
and <https://corion.net/talks> for the slides.
.PP
At The Perl Conference 2017 in Amsterdam, I also presented a talk, see
<http://act.perlconference.org/tpc\-2017\-amsterdam/talk/7022>.
The slides for the English presentation at TPCiA 2017 are at
<https://corion.net/talks/WWW\-Mechanize\-Chrome/www\-mechanize\-chrome.en.html>.
.PP
At the London Perl Workshop 2017 in London, I also presented a talk, see
Youtube <https://www.youtube.com/watch?v=V3WeO-iVkAc> . The slides for
that talk are
here <https://corion.net/talks/WWW-Mechanize-Chrome/www-mechanize-chrome.en.html>.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-Chrome>
or via mail to www\-mechanize\-Chrome\-Bugs@rt.cpan.org <mailto:www-mechanize-Chrome-Bugs@rt.cpan.org>.
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
Please see WWW::Mechanize::Chrome::Contributing.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
Please see WWW::Mechanize::Chrome::Troubleshooting.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Andreas König \f(CW\*(C`andk@cpan.org\*(C'\fR
Tobias Leich \f(CW\*(C`froggs@cpan.org\*(C'\fR
Steven Dondley \f(CW\*(C`s@dondley.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2010\-2020 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
