.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Future::AsyncAwait 3"
.TH Future::AsyncAwait 3 "2020-10-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Future::AsyncAwait" \- deferred subroutine syntax for futures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use v5.14;
\&   use Future::AsyncAwait;
\&
\&   async sub do_a_thing
\&   {
\&      my $first = await do_first_thing();
\&
\&      my $second = await do_second_thing();
\&
\&      return combine_things( $first, $second );
\&   }
\&
\&   do_a_thing()\->get;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides syntax for deferring and resuming subroutines while
waiting for Futures to complete. This syntax aims to make code that
performs asynchronous operations using futures look neater and more expressive
than simply using \f(CW\*(C`then\*(C'\fR chaining and other techniques on the futures
themselves. It is also a similar syntax used by a number of other languages;
notably C# 5, EcmaScript 6, Python 3, Dart. Rust is considering adding it.
.PP
The new syntax takes the form of two new keywords, \f(CW\*(C`async\*(C'\fR and \f(CW\*(C`await\*(C'\fR.
.ie n .SS """async"""
.el .SS "\f(CWasync\fP"
.IX Subsection "async"
The \f(CW\*(C`async\*(C'\fR keyword should appear just before the \f(CW\*(C`sub\*(C'\fR keyword that
declares a new function. When present, this marks that the function performs
its work in a \fIpotentially\fR asynchronous fashion. This has two effects: it
permits the body of the function to use the \f(CW\*(C`await\*(C'\fR expression, and it wraps
the return value of the function in a Future instance.
.PP
.Vb 4
\&   async sub myfunc
\&   {
\&      return 123;
\&   }
\&
\&   my $f = myfunc();
\&   my $result = $f\->get;
.Ve
.PP
This \f(CW\*(C`async\*(C'\fR\-declared function always returns a \f(CW\*(C`Future\*(C'\fR instance when
invoked. The returned future instance will eventually complete when the
function returns, either by the \f(CW\*(C`return\*(C'\fR keyword or by falling off the end;
the result of the future will be the return value from the function's code.
Alternatively, if the function body throws an exception, this will cause the
returned future to fail.
.PP
If the final expression in the body of the function returns a \f(CW\*(C`Future\*(C'\fR, don't
forget to \f(CW\*(C`await\*(C'\fR it rather than simply returning it as it is, or else this
return value will become double-wrapped \- almost certainly not what you
wanted.
.PP
.Vb 1
\&   async sub otherfunc { ... }
\&
\&   async sub myfunc
\&   {
\&      ...
\&      return await otherfunc();
\&   }
.Ve
.ie n .SS """await"""
.el .SS "\f(CWawait\fP"
.IX Subsection "await"
The \f(CW\*(C`await\*(C'\fR keyword forms an expression which takes a \f(CW\*(C`Future\*(C'\fR instance as
an operand and yields the eventual result of it. Superficially it can be
thought of similar to invoking the \f(CW\*(C`get\*(C'\fR method on the future.
.PP
.Vb 1
\&   my $result = await $f;
\&
\&   my $result = $f\->get;
.Ve
.PP
However, the key difference (and indeed the entire reason for being a new
syntax keyword) is the behaviour when the future is still pending and is not
yet complete. Whereas the simple \f(CW\*(C`get\*(C'\fR method would block until the future is
complete, the \f(CW\*(C`await\*(C'\fR keyword causes its entire containing function to become
suspended, making it return a new (pending) future instance. It waits in this
state until the future it was waiting on completes, at which point it wakes up
and resumes execution from the point of the \f(CW\*(C`await\*(C'\fR expression. When the
now-resumed function eventually finishes (either by returning a value or
throwing an exception), this value is set as the result of the future it had
returned earlier.
.PP
\&\f(CW\*(C`await\*(C'\fR provides scalar context to its controlling expression.
.PP
.Vb 3
\&   async sub func {
\&      # this function is invoked in scalar context
\&   }
\&
\&   await func();
.Ve
.PP
Because the \f(CW\*(C`await\*(C'\fR keyword may cause its containing function to suspend
early, returning a pending future instance, it is only allowed inside
\&\f(CW\*(C`async\*(C'\fR\-marked subs.
.PP
The converse is not true; just because a function is marked as \f(CW\*(C`async\*(C'\fR does
not require it to make use of the \f(CW\*(C`await\*(C'\fR expression. It is still useful to
turn the result of that function into a future, entirely without \f(CW\*(C`await\*(C'\fRing
on any itself.
.PP
Any function that doesn't actually await anything, and just returns immediate
futures can be neatened by this module too.
.PP
Instead of writing
.PP
.Vb 5
\&   sub imm
\&   {
\&      ...
\&      return Future\->done( @result );
\&   }
.Ve
.PP
you can now simply write
.PP
.Vb 5
\&   async sub imm
\&   {
\&      ...
\&      return @result;
\&   }
.Ve
.PP
with the added side-benefit that any exceptions thrown by the elided code will
be turned into an immediate-failed \f(CW\*(C`Future\*(C'\fR rather than making the call
itself propagate the exception, which is usually what you wanted when dealing
with futures.
.PP
This module is still under active development. While it now seems relatively
stable enough for most use-cases and has received a lot of \*(L"battle-testing\*(R" in
a wide variety of scenarios, there may still be the occasional case of memory
leak left in it, especially if still-pending futures are abandoned.
.ie n .SS """CANCEL"""
.el .SS "\f(CWCANCEL\fP"
.IX Subsection "CANCEL"
\&\fIExperimental. Since version 0.44.\fR
.PP
The \f(CW\*(C`CANCEL\*(C'\fR keyword declares a block of code which will be run in the event
that the future returned by the \f(CW\*(C`async sub\*(C'\fR is cancelled.
.PP
.Vb 3
\&   async sub f
\&   {
\&      CANCEL { warn "This task was cancelled"; }
\&
\&      await ...
\&   }
\&
\&   f()\->cancel;
.Ve
.PP
A \f(CW\*(C`CANCEL\*(C'\fR block is a self-contained syntax element, similar to perl
constructions like \f(CW\*(C`BEGIN\*(C'\fR, and does not need a terminating semicolon.
.PP
When a \f(CW\*(C`CANCEL\*(C'\fR block is encountered during execution of the \f(CW\*(C`async sub\*(C'\fR,
the code in its block is stored for the case that the returned future is
cancelled. Each will take effect as it is executed, possibly multiple times if
it appears inside a loop, or not at all if it appears conditionally in a
branch that was not executed.
.PP
.Vb 5
\&   async sub g
\&   {
\&      if(0) {
\&         CANCEL { warn "This does not happen"; }
\&      }
\&
\&      foreach my $x ( 1..3 ) {
\&         CANCEL { warn "This happens for x=$x"; }
\&      }
\&
\&      await ...
\&   }
\&
\&   g()\->cancel;
.Ve
.PP
\&\f(CW\*(C`CANCEL\*(C'\fR blocks are only invoked if a still-pending future is cancelled. They
are discarded without being executed if the function finishes; either
successfully or if it throws an exception.
.SH "Experimental Features"
.IX Header "Experimental Features"
Some of the features of this module are currently marked as experimental. They
will provoke warnings in the \f(CW\*(C`experimental\*(C'\fR category, unless silenced.
.PP
You can silence this with \f(CW\*(C`no warnings \*(Aqexperimental\*(Aq\*(C'\fR but then that will
silence every experimental warning, which may hide others unintentionally. For
a more fine-grained approach you can instead use the import line for this
module to only silence this module's warnings selectively:
.PP
.Vb 1
\&   use Future::AsyncAwait qw( :experimental(cancel) );
\&
\&   use Future::AsyncAwait qw( :experimental );  # all of the above
.Ve
.SH "SUPPORTED USES"
.IX Header "SUPPORTED USES"
Most cases involving awaiting on still-pending futures should work fine:
.PP
.Vb 3
\&   async sub foo
\&   {
\&      my ( $f ) = @_;
\&
\&      BEFORE();
\&      await $f;
\&      AFTER();
\&   }
\&
\&   async sub bar
\&   {
\&      my ( $f ) = @_;
\&
\&      return 1 + await( $f ) + 3;
\&   }
\&
\&   async sub splot
\&   {
\&      while( COND ) {
\&         await func();
\&      }
\&   }
\&
\&   async sub wibble
\&   {
\&      if( COND ) {
\&         await func();
\&      }
\&   }
\&
\&   async sub wobble
\&   {
\&      foreach my $var ( THINGs ) {
\&         await func();
\&      }
\&   }
\&
\&   async sub quux
\&   {
\&      my $x = do {
\&         await func();
\&      };
\&   }
\&
\&   async sub splat
\&   {
\&      eval {
\&         await func();
\&      };
\&   }
.Ve
.PP
Plain lexical variables are preserved across an \f(CW\*(C`await\*(C'\fR deferral:
.PP
.Vb 6
\&   async sub quux
\&   {
\&      my $message = "Hello, world\en";
\&      await func();
\&      print $message;
\&   }
.Ve
.PP
On perl versions 5.26 and later \f(CW\*(C`async sub\*(C'\fR syntax supports the \f(CW\*(C`signatures\*(C'\fR
feature if it is enabled:
.PP
.Vb 2
\&   use v5.26;
\&   use feature \*(Aqsignatures\*(Aq;
\&
\&   async sub quart($x, $y)
\&   {
\&      ...
\&   }
.Ve
.SS "Cancellation"
.IX Subsection "Cancellation"
Cancelled futures cause a suspended \f(CW\*(C`async sub\*(C'\fR to simply stop running.
.PP
.Vb 5
\&   async sub fizz
\&   {
\&      await func();
\&      say "This is never reached";
\&   }
\&
\&   my $f = fizz();
\&   $f\->cancel;
.Ve
.PP
Cancellation requests can propagate backwards into the future the
\&\f(CW\*(C`async sub\*(C'\fR is currently waiting on.
.PP
.Vb 5
\&   async sub floof
\&   {
\&      ...
\&      await $f1;
\&   }
\&
\&   my $f2 = floof();
\&
\&   $f2\->cancel;  # $f1 will be cancelled too
.Ve
.PP
This behaviour is still more experimental than the rest of the logic. The
following should be noted:
.IP "\(bu" 4
There is currently no way to perform the equivalent of \*(L"on_cancel\*(R" in Future
to add a cancellation callback to a future chain.
.IP "\(bu" 4
Cancellation propagation is only implemented on Perl version 5.24 and above.
An \f(CW\*(C`async sub\*(C'\fR in an earlier perl version will still stop executing if
cancelled, but will not propagate the request backwards into the future that
the \f(CW\*(C`async sub\*(C'\fR is currently waiting on. See \*(L"\s-1TODO\*(R"\s0.
.SH "SUBCLASSING Future"
.IX Header "SUBCLASSING Future"
By default when an \f(CW\*(C`async sub\*(C'\fR returns a result or fails immediately before
awaiting, it will return a new completed instance of the Future class. In
order to allow code that wishes to use a different class to represent futures
the module import method can be passed the name of a class to use instead.
.PP
.Vb 1
\&   use Future::AsyncAwait future_class => "Subclass::Of::Future";
\&
\&   async sub func { ... }
.Ve
.PP
This has the usual lexically-scoped effect, applying only to \f(CW\*(C`async sub\*(C'\fRs
defined within the block; others are unaffected.
.PP
.Vb 1
\&   use Future::AsyncAwait;
\&
\&   {
\&      use Future::AsyncAwait future_class => "Different::Future";
\&      async sub x { ... }
\&   }
\&
\&   async sub y { ... }  # returns a regular Future
.Ve
.PP
This will only affect immediate results. If the \f(CW\*(C`await\*(C'\fR keyword has to
suspend the function and create a new pending future, it will do this by using
the prototype constructor on the future it itself is waiting on, and the usual
subclass-respecting semantics of \*(L"new\*(R" in Future will remain in effect there. As
such it is not usually necessary to use this feature just for wrapping event
system modules or other similar situations.
.PP
Such an alternative subclass should implement the \s-1API\s0 documented by
Future::AsyncAwait::Awaitable.
.SH "WITH OTHER MODULES"
.IX Header "WITH OTHER MODULES"
.SS "Syntax::Keyword::Try"
.IX Subsection "Syntax::Keyword::Try"
As of Future::AsyncAwait version 0.10 and Syntax::Keyword::Try version
0.07, cross-module integration tests assert that basic \f(CW\*(C`try/catch\*(C'\fR blocks
inside an \f(CW\*(C`async sub\*(C'\fR work correctly, including those that attempt to
\&\f(CW\*(C`return\*(C'\fR from inside \f(CW\*(C`try\*(C'\fR.
.PP
.Vb 2
\&   use Future::AsyncAwait;
\&   use Syntax::Keyword::Try;
\&
\&   async sub attempt
\&   {
\&      try {
\&         await func();
\&         return "success";
\&      }
\&      catch {
\&         return "failed";
\&      }
\&   }
.Ve
.SS "Syntax::Keyword::Dynamically"
.IX Subsection "Syntax::Keyword::Dynamically"
As of Future::AsyncAwait version 0.32, cross-module integration tests
assert that the \f(CW\*(C`dynamically\*(C'\fR correctly works across an \f(CW\*(C`await\*(C'\fR boundary.
.PP
.Vb 2
\&   use Future::AsyncAwait;
\&   use Syntax::Keyword::Dynamically;
\&
\&   our $var;
\&
\&   async sub trial
\&   {
\&      dynamically $var = "value";
\&
\&      await func();
\&
\&      say "Var is still $var";
\&   }
.Ve
.SS "Object::Pad"
.IX Subsection "Object::Pad"
As of Future::AsyncAwait version 0.38 and Object::Pad version 0.15, both
modules now use XS::Parse::Sublike to parse blocks of code. Because of this
the two modules can operate together and allow class methods to be written as
async subs which await expressions:
.PP
.Vb 2
\&   use Future::AsyncAwait;
\&   use Object::Pad;
\&
\&   class Example
\&   {
\&      async method perform($block)
\&      {
\&         say "$self is performing code";
\&         await $block\->();
\&         say "code finished";
\&      }
\&   }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\*(L"Awaiting The Future\*(R" \- \s-1TPC\s0 in Amsterdam 2017
.Sp
<https://www.youtube.com/watch?v=Xf7rStpNaT0> (slides) <https://docs.google.com/presentation/d/13x5l8Rohv_RjWJ0OTvbsWMXKoNEWREZ4GfKHVykqUvc/edit#slide=id.p>
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Suspend and resume with some consideration for the savestack; i.e. the area
used to implement \f(CW\*(C`local\*(C'\fR and similar. While in general \f(CW\*(C`local\*(C'\fR support has
awkward questions about semantics, there are certain situations and cases
where internally-implied localisation of variables would still be useful and
can be supported without the semantic ambiguities of generic \f(CW\*(C`local\*(C'\fR.
.Sp
.Vb 1
\&   our $DEBUG = 0;
\&
\&   async sub quark
\&   {
\&      local $DEBUG = 1;
\&      await func();
\&   }
.Ve
.Sp
Since \f(CW\*(C`foreach\*(C'\fR loops on non-lexical iterator variables (usually the \f(CW$_\fR
global variable) effectively imply a \f(CW\*(C`local\*(C'\fR\-like behaviour, these are also
disallowed.
.Sp
.Vb 6
\&   async sub splurt
\&   {
\&      foreach ( LIST ) {
\&         await ...
\&      }
\&   }
.Ve
.Sp
Some notes on what makes the problem hard can be found at
.Sp
<https://rt.cpan.org/Ticket/Display.html?id=122793>
.IP "\(bu" 4
Currently this module requires perl version 5.16 or later. Additionally,
threaded builds of perl earlier than 5.22 are not supported.
.Sp
<https://rt.cpan.org/Ticket/Display.html?id=122252>
.Sp
<https://rt.cpan.org/Ticket/Display.html?id=124351>
.IP "\(bu" 4
Implement cancel back-propagation for Perl versions earlier than 5.24.
Currently this does not work due to some as-yet-unknown effects that
installing the back-propagation has, causing future instances to be reclaimed
too early.
.Sp
<https://rt.cpan.org/Ticket/Display.html?id=129202>
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
This is not a complete list of all known issues, but rather a summary of the
most notable ones that currently prevent the module from working correctly in
a variety of situations. For a complete list of known bugs, see the \s-1RT\s0 queue
at <https://rt.cpan.org/Dist/Display.html?Name=Future\-AsyncAwait>.
.IP "\(bu" 4
\&\f(CW\*(C`await\*(C'\fR inside \f(CW\*(C`map\*(C'\fR or \f(CW\*(C`grep\*(C'\fR blocks does not work. This is due to the
difficulty of detecting the map or grep context from internal perl state at
suspend time, sufficient to be able to restore it again when resuming.
.Sp
<https://rt.cpan.org/Ticket/Display.html?id=129748>
.Sp
As a workaround, consider converting a \f(CW\*(C`map\*(C'\fR expression to the equivalent
form using \f(CW\*(C`push\*(C'\fR onto an accumulator array with a \f(CW\*(C`foreach\*(C'\fR loop:
.Sp
.Vb 1
\&   my @results = map { await func($_) } ITEMS;
.Ve
.Sp
becomes
.Sp
.Vb 4
\&   my @results;
\&   foreach my $item ( ITEMS ) {
\&      push @results, await func($item);
\&   }
.Ve
.Sp
with a similar transformation for \f(CW\*(C`grep\*(C'\fR expressions.
.Sp
Alternatively, consider using the \f(CW\*(C`fmap*\*(C'\fR family of functions from
Future::Utils to provide a concurrent version of the same code, which can
keep multiple items running concurrently:
.Sp
.Vb 1
\&   use Future::Utils qw( fmap );
\&
\&   my @results = await fmap { func( shift ) }
\&      foreach    => [ ITEMS ],
\&      concurrent => 5;
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
With thanks to \f(CW\*(C`Zefram\*(C'\fR, \f(CW\*(C`ilmari\*(C'\fR and others from \f(CW\*(C`irc.perl.org/#p5p\*(C'\fR for
assisting with trickier bits of \s-1XS\s0 logic.
.PP
Thanks to \f(CW\*(C`genio\*(C'\fR for project management and actually reminding me to write
some code.
.PP
Thanks to The Perl Foundation for sponsoring me to continue working on the
implementation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
