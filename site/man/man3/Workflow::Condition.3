.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Condition 3"
.TH Workflow::Condition 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Condition \- Evaluate a condition depending on the workflow state and environment
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.07 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # First declare the condition in a \*(Aqworkflow_condition.xml\*(Aq...
\&
\& <conditions>
\&   <condition
\&      name="IsAdminUser"
\&      class="MyApp::Condition::IsAdminUser">
\&         <param name="admin_group_id" value="5" />
\&         <param name="admin_group_id" value="6" />
\&   </condition>
\& ...
\&
\& # Reference the condition in an action of the state/workflow definition...
\& <workflow>
\&   <state>
\&     ...
\&     <action name="SomeAdminAction">
\&       ...
\&       <condition name="IsAdminUser" />
\&     </action>
\&     <action name="AnotherAdminAction">
\&      ...
\&      <condition name="IsAdminUser" />
\&     </action>
\&     <action name="AUserAction">
\&      ...
\&      <condition name="!IsAdminUser" />
\&     </action>
\&   </state>
\&   ...
\& </workflow>
\&
\& # Then implement the condition
\&
\& package MyApp::Condition::IsAdminUser;
\&
\& use strict;
\& use base qw( Workflow::Condition );
\& use Workflow::Exception qw( condition_error configuration_error );
\&
\& _\|_PACKAGE_\|_\->mk_accessors( \*(Aqadmin_group_id\*(Aq );
\&
\& sub _init {
\&     my ( $self, $params ) = @_;
\&     unless ( $params\->{admin_group_id} ) {
\&         configuration_error
\&             "You must define one or more values for \*(Aqadmin_group_id\*(Aq in ",
\&             "declaration of condition ", $self\->name;
\&     }
\&     my @admin_ids = $self\->_normalize_array( $params\->{admin_group_id} );
\&     $self\->admin_group_id( { map { $_ => 1 } @admin_ids } );
\& }
\&
\& sub evaluate {
\&     my ( $self, $wf ) = @_;
\&     my $admin_ids = $self\->admin_group_id;
\&     my $current_user = $wf\->context\->param( \*(Aqcurrent_user\*(Aq );
\&     unless ( $current_user ) {
\&         condition_error "No user defined, cannot check groups";
\&     }
\&     foreach my $group ( @{ $current_user\->get_groups } ) {
\&         return if ( $admin_ids\->{ $group\->id } );
\&     }
\&     condition_error "Not member of any Admin groups";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Conditions are used by the workflow to see whether actions are
available in a particular context. So if user A asks the workflow for
the available actions she might get a different answer than user B
since they determine separate contexts.
.PP
\&\fB\s-1NOTE\s0\fR: The condition is enforced by Workflow::State. This means that
the condition name must be visible inside of the state definition. If
you specify the reference to the condition only inside of the full
action specification in a seperate file then nothing will happen. The
reference to the condition must be defined inside of the state/workflow
specification.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
While some conditions apply to all workflows, you may have a case where
a condition has different implementations for different workflow types.
For example, IsAdminUser may look in two different places for two
different workflow types, but you want to use the same condition name
for both.
.PP
You can accomplish this by adding a type in the condition configuration.
.PP
.Vb 9
\& <conditions>
\& <type>Ticket</type>
\&   <condition
\&      name="IsAdminUser"
\&      class="MyApp::Condition::IsAdminUser">
\&         <param name="admin_group_id" value="5" />
\&         <param name="admin_group_id" value="6" />
\&   </condition>
\& ...
.Ve
.PP
The type must match a loaded workflow type, or the condition won't work.
When the workflow looks for a condition, it will look for a typed condition
first. If it doesn't find one, it will look for non-typed conditions.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Strategy"
.IX Subsection "Strategy"
The idea behind conditions is that they can be stateless. So when the
Workflow::Factory object reads in the condition configuration it
creates the condition objects and initializes them with whatever
information is passed in.
.PP
Then when the condition is evaluated we just call \f(CW\*(C`evaluate()\*(C'\fR on the
condition. Hopefully the operation can be done very quickly since the
condition may be called many, many times during a workflow lifecycle
\&\*(-- they are typically used to show users what options they have given
the current state of the workflow for things like menu options. So
keep it short!
.SS "Methods"
.IX Subsection "Methods"
To create your own condition you should implement the following:
.PP
\fIinit( \e%params )\fR
.IX Subsection "init( %params )"
.PP
This is optional, but called when the condition is first
initialized. It may contain information you will want to initialize
your condition with in \f(CW\*(C`\e%params\*(C'\fR, which are all the declared
parameters in the condition declartion except for 'class' and 'name'.
.PP
You may also do any initialization here \*(-- you can fetch data from the
database and store it in the class or object, whatever you need.
.PP
If you do not have sufficient information in \f(CW\*(C`\e%params\*(C'\fR you should
throw an exception (preferably 'configuration_error' imported from
Workflow::Exception).
.PP
\fIevaluate( \f(CI$workflow\fI )\fR
.IX Subsection "evaluate( $workflow )"
.PP
Determine whether your condition fails by throwing an exception. You
can get the application context information necessary to process your
condition from the \f(CW$workflow\fR object.
.PP
\fI_init\fR
.IX Subsection "_init"
.PP
This is a \fIdummy\fR, please refer to \*(L"init\*(R"
.SS "Caching and inverting the result"
.IX Subsection "Caching and inverting the result"
If in one state, you ask for the same condition again, Workflow uses
the cached result, so that within one list of available actions, you
will get a consistent view. Note that if we would not use caching,
this might not necessary be the case, as something external might
change between the two \fBevaluate()\fR calls.
.PP
Caching is also used with an inverted condition, which you can specify
in the definition using \f(CW\*(C`<condition name="!some_condition"\*(C'\fR>.
This condition returns exactly the opposite of the original one, i.e.
if the original condition fails, this one does not and the other way
round. As caching is used, you can model \*(L"yes/no\*(R" decisions using this
feature \- if you have both \f(CW\*(C`<condition name="some_condition"\*(C'\fR> and
\&\f(CW\*(C`<condition name="!some_condition"\*(C'\fR> in your workflow state definition,
exactly one of them will succeed and one will fail \- which is particularly
useful if you use \*(L"autorun\*(R" a lot.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2007 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonas B. Nielsen (jonasbn) <jonasbn@cpan.org> is the current maintainer.
.PP
Chris Winters <chris@cwinters.com>, original author.
