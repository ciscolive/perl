.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::IP::Util 3"
.TH Net::IP::Util 3 "2013-05-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IP::Util \- Common useful routines like converting decimal address to binary and vice versa, determining address class,
                determining default mask, subnets and hosts and broadcast addresses for hosts in subnet.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  use Net::IP::Util;                       ## subroutines isClassAddrA\-E, bin2decIpAddr, dec2binIpAddr
\&  use Net::IP::Util qw/:class/;            ## subroutines isClassAddrA\-E, getAddrClass
\&  use Net::IP::Util qw/:convert/;          ## subroutines bin2decIpAddr, dec2binIpAddr 
\&  use Net::IP::Util qw/getAddrMaskDefault
\&                       getAddrClass
\&                       isValidMask
\&                       extendMaskByBits
\&                       calcSubnet
\&                       calcSubnetCIDR
\&                       calcSubnetExt
\&                       getNetworkAddr    ## Explicit inclusions
\&
\&  isClassAddrA(\*(Aq127.0.32.45\*(Aq);
\&  isClassAddrA(\*(Aq00001111.11110010.00100100.10000001\*(Aq);
\&
\&  dec2binIpAddr(\*(Aq128.0.0.56\*(Aq);
\&  bin2decIpAddr(\*(Aq10001000.10100001.00010101.00000001\*(Aq);
\&
\&  getAddrMaskDefault(\*(Aq124.45.0.0\*(Aq);
\&  getAddrMaskDefault(\*(Aq10000000.00000001.01010101.10000001\*(Aq);
\&
\&  getAddrClass(\*(Aq124.45.0.0\*(Aq);
\&  getAddrClass(\*(Aq00001111.11110010.00100100.10000001\*(Aq);
\&
\&  isValidMask(\*(Aq255.255.252.0\*(Aq);
\&  isValidMask(\*(Aq11111111.00000000.00000000.00000000\*(Aq);
\&
\&  extendMaskByBits(\*(Aq255.255.0.0\*(Aq,2);
\&  extendMaskByBits(\*(Aq11111111.00000000.00000000.00000000\*(Aq,2);
\&
\&  calcSubnet(\*(Aq128.8.9.0\*(Aq);
\&  calcSubnet(\*(Aq10001000.10100001.00010101.00000001\*(Aq);
\&
\&  calcSubnetCIDR(\*(Aq128.9.0.218/24\*(Aq);
\&  calcSubnetCIDR(\*(Aq128.9.0.218/28\*(Aq, \*(Aq255.255.255.0\*(Aq);
\&
\&  calcSubnetExt(\*(Aq128.0.0.1\*(Aq,4);
\&  calcSubnetExt(\*(Aq10001000.10100001.00010101.00000001\*(Aq,4);
\&                           
\&  getNetworkAddr(\*(Aq198.23.16.0\*(Aq,\*(Aq255.255.255.240\*(Aq,\*(Aq255.255.255.252\*(Aq);
\&  getNetworkAddr(\*(Aq198.23.16.0\*(Aq,\*(Aq255.255.255.240\*(Aq,\*(Aq255.255.255.252\*(Aq, 1);
\&  getNetworkAddr(\*(Aq10000000.00000001.01010101.10000001\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11110000\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11111100\*(Aq,);
\&  getNetworkAddr(\*(Aq10000000.00000001.01010101.10000001\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11110000\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11111100\*(Aq, 1);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.Vb 3
\&  This module tries provide the basic functionalities related to IPv4 addresses.
\&  Address class, subnet masks, subnet addresses, broadcast addresses can be deduced
\&  using the given methods. Ip addresses passed are also validated implicitly.
\&
\&  Provision has been given to specify IP addresses in either dotted decimal notation
\&  or dotted binary notation, methods have been provided for conversion to\-from these
\&  to notations which are internally used by other methods too.
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "isClassAddrA,isClassAddrB,isClassAddrC,isClassAddrD,isClassAddrE"
.IX Subsection "isClassAddrA,isClassAddrB,isClassAddrC,isClassAddrD,isClassAddrE"
.Vb 4
\&  isClassAddrA(<addr in decimal/binary>) : returns 1 if true
\&  eg.
\&  isClassAddrA(\*(Aq127.0.32.45\*(Aq);
\&  isClassAddrA(\*(Aq00001111.11110010.00100100.10000001\*(Aq);
.Ve
.SS "dec2binIpAddr"
.IX Subsection "dec2binIpAddr"
.Vb 3
\&  dec2binIpAddr(<ip addr in dotted decimal notation>) : returns ip in binary dotted notation
\&  eg.
\&  dec2binIpAddr(\*(Aq128.0.0.56\*(Aq);
.Ve
.SS "bin2decIpAddr"
.IX Subsection "bin2decIpAddr"
.Vb 3
\&  bin2decIpAddr(<ip addr in dotted binary notation>) : returns ip in decimal dotted notation
\&  eg.
\&  bin2decIpAddr(\*(Aq10001000.10100001.00010101.00000001\*(Aq);
.Ve
.SS "getAddrMaskDefault"
.IX Subsection "getAddrMaskDefault"
.Vb 4
\&  getAddrMaskDefault(<ip addr in decimal/binary notation>) : returns default subnet mask in dotted decimal notation
\&  eg.
\&  getAddrMaskDefault(\*(Aq124.45.0.0\*(Aq); >> 255.0.0.0
\&  getAddrMaskDefault(\*(Aq10000000.00000001.01010101.10000001\*(Aq); >> 255.0.0.0
.Ve
.SS "getAddrClass"
.IX Subsection "getAddrClass"
.Vb 4
\&  getAddrClass(<ip addr in decimal/binary notation>) : returns class (A/B/C/D/E) of ip address
\&  eg.  
\&  getAddrClass(\*(Aq124.45.0.0\*(Aq);
\&  getAddrClass(\*(Aq00001111.11110010.00100100.10000001\*(Aq);
.Ve
.SS "isValidMask"
.IX Subsection "isValidMask"
.Vb 4
\&  isValidMask(<ip addr in decimal/binary notation>) : returns 1 if valid mask
\&  eg.
\&  isValidMask(\*(Aq255.255.252.0\*(Aq);
\&  isValidMask(\*(Aq11111111.00000000.00000000.00000000\*(Aq);
.Ve
.SS "extendMaskByBits"
.IX Subsection "extendMaskByBits"
.Vb 5
\&  extendMaskByBits(<ip addr in decimal/binary notation>,<no.of bits to extend>)
\&    : returns mask after extending/turning on given no. of bits after the already on bits of the mask
\&  eg.
\&  extendMaskByBits(\*(Aq255.255.0.0\*(Aq,2); >> 255.255.192.0
\&  extendMaskByBits(\*(Aq11111111.00000000.00000000.00000000\*(Aq,2); >> 11111111.11000000.00000000.00000000
.Ve
.SS "calcSubnet"
.IX Subsection "calcSubnet"
.Vb 4
\&  calcSubnet(<ip addr in decimal/binary notation>) : returns (no. of subnets, no. of hosts)
\&  calcSubnet(\*(Aq128.90.80.12\*(Aq);
\&  calcSubnet(\*(Aq11000000.00000000.11000000.01011100\*(Aq);
\&  \- These always assumes Default Mask in calculation \- hence no of subnets returned is always 0
.Ve
.SS "calcSubnetCIDR"
.IX Subsection "calcSubnetCIDR"
.Vb 4
\&  calcSubnetCIDR(<ip addr in decimal/binary CIDR notation>, [<mask in decimal/binary notation>])
\&      : returns (no. of subnets, no. of hosts)
\&  calcSubnetCIDR(\*(Aq128.87.56.26/28\*(Aq);
\&  calcSubnetCIDR(\*(Aq128.87.56.26/28\*(Aq,\*(Aq255.255.252.0\*(Aq);
.Ve
.SS "calcSubnetExt"
.IX Subsection "calcSubnetExt"
.Vb 5
\&  calcSubnetExt(ip addr in decimal/binary notation>, no. of bits to extend in default mask OR no. of borrowed bits)
\&    : returns (no. of subnets, no. of hosts)
\&  eg.
\&  calcSubnetExt(\*(Aq128.0.0.1\*(Aq,4);
\&  calcSubnetExt(\*(Aq10001000.10100001.00010101.00000001\*(Aq,4);
\&
\&  Expln : no. of borrowed bits is added to the default subnet mask of ip addr to subnet mask
\&          and subnetting is done so :
\&          ***************************************************
\&          127.0.40.1           = ip addr
\&          255.0.0.0            = default subnet mask
\&          no. of borrowed bits = 4
\&                               => 255.240.0.0 = extended mask 
\&          ***************************************************
.Ve
.SS "getNetworkAddr"
.IX Subsection "getNetworkAddr"
.Vb 12
\&  getNetworkAddr(<ip addr in decimal/binary notation>,
\&                   <default mask in decimal/binary notation>,
\&                   <subnet mask in decimal/binary notation>,
\&                   <true flag \- if you want broadcast addresses instead of n/w addresses
\&                   ) : returns network/broadcast addresses of the subnets after subnetting as a list
\&  eg.
\&  getNetworkAddr(\*(Aq198.23.16.0\*(Aq,\*(Aq255.255.255.240\*(Aq,\*(Aq255.255.255.252\*(Aq); >> (\*(Aq198.23.16.0\*(Aq,\*(Aq198.23.16.4\*(Aq,\*(Aq198.23.16.8\*(Aq,\*(Aq198.23.16.12\*(Aq)
\&  getNetworkAddr(\*(Aq198.23.16.0\*(Aq,\*(Aq255.255.255.240\*(Aq,\*(Aq255.255.255.252\*(Aq,1); >> (\*(Aq198.23.16.3\*(Aq,\*(Aq198.23.16.7\*(Aq,\*(Aq198.23.16.11\*(Aq,\*(Aq198.23.16.15\*(Aq)
\&  getNetworkAddr(\*(Aq10000000.00000001.01010101.10000001\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11110000\*(Aq,
\&                   \*(Aq11111111.11111111.11111111.11111100\*(Aq,); >> Always returns n/w addresses in dotted decimal irrespective of binary/decimal
\&                                                               address parameter passed
.Ve
.SH "CAVEAT"
.IX Header "CAVEAT"
.Vb 3
\&  IPv4 only
\&  Validation of IP addresses are done, but because of conversions here and there it may not show the IP address properly in the error message
\&  as passed earlier by the user.
.Ve
.SH "Similar Modules"
.IX Header "Similar Modules"
.Vb 1
\&  Net::IP, Net::IpAddr etc.
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.Vb 1
\&  debashish@cpan.org
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2013 Debashish Parasar, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
