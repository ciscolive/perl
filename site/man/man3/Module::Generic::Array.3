.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic::Array 3"
.TH Module::Generic::Array 3 "2020-08-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic::Array \- An Array Manipulation Object Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    my $ar = Module::Generic::Array\->new( [qw( Joe John Mary )] );
\&    printf( "There are %d people\en", $ar\->length );
\&    # Adding one more
\&    $ar\->push( "Jack" );
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.1.1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The purpose of this class/package is to provide an object-oriented approach at array manipulation
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Provided with an optional array reference or an array object such as Module::Generic::Array, this will create a new object and return it.
.SS "as_string"
.IX Subsection "as_string"
Returns the array as string, which is essentially the same as \f(CW"@array"\fR
.PP
It takes an optional boolean value that, if true, will sort the array before.
.SS "as_hash"
.IX Subsection "as_hash"
Returns an hash reference with the keys being the array elements and the hash values their offset value.
.PP
It takes an optional hash of options:
.IP "\fIstart_from\fR" 4
.IX Item "start_from"
If true, the offset values will start from the number provided and not 0, as it is the case by default.
.PP
Example:
.PP
.Vb 8
\&    my $a = Module::Generic::Array\->new( [qw( Jack John Peter )] );
\&    my $h = $a\->as_hash({ start_from => 1 });
\&    # $h now is:
\&    {
\&        Jack => 1,
\&        John => 2,
\&        Peter => 3,
\&    }
.Ve
.SS "clone"
.IX Subsection "clone"
Creates a clone of the current array object and returns it.
.SS "delete"
.IX Subsection "delete"
Provided with an offset value and an optional length, and this will remove data from the array at the given offset and for the given length.
.PP
If no given length is provided, it removes all entries from the offset until the end.
.PP
It returns a list of elements removed in list context or a new array object of it in scalar context.
.PP
See also \*(L"splice\*(R"
.SS "each"
.IX Subsection "each"
Provided with a code reference such as a reference to a subroutine, and this will execute the code passing it the array offset and the current value as the 2 arguements. The current value is also accessible with \f(CW$_\fR
.PP
.Vb 6
\&    $a\->each(sub
\&    {
\&        print( "I got $_\en" );
\&        # could also write:
\&        # print( "I got $_[1] at offset $_[0]\en" );
\&    });
.Ve
.PP
To exit the loop, return \f(CW\*(C`undef()\*(C'\fR, for example:
.PP
.Vb 5
\&    $a\->each(sub
\&    {
\&        return if( $_ eq $not_this_one );
\&        print( "ok, this one\en" );
\&    });
.Ve
.SS "exists"
.IX Subsection "exists"
Provided with a value and this returns the number of match, as an Module::Generic::Number object, if it is found in the array, or false otherwise.
.SS "first"
.IX Subsection "first"
Returns the first element of the array, if any. If there are none, to ensure chaining will work, it will return a Module::Generic::Null object.
.SS "for"
.IX Subsection "for"
Provided with a subroutine reference and this will call the subroutine reference, passing it the offset number and the corresponding array value.
.PP
.Vb 5
\&    $ar\->for(sub
\&    {
\&        my( $i, $val ) = @_;
\&        # do something
\&    })
.Ve
.PP
\&\f(CW$_\fR is made available and contains the value of \f(CW$val\fR
.PP
It returns the object itself so this can be chained.
.PP
To exit the loop, return \f(CW\*(C`undef()\*(C'\fR, for example:
.PP
.Vb 5
\&    $a\->for(sub
\&    {
\&        return if( $_ eq $not_this_one );
\&        print( "ok, this one\en" );
\&    });
.Ve
.SS "foreach"
.IX Subsection "foreach"
Provided with a subroutine reference and this will call the subroutine reference, passing it the value for each entry in the array.
.PP
.Vb 5
\&    $ar\->foreach(sub
\&    {
\&        my $val = shift( @_ );
\&        # do something
\&    })
.Ve
.PP
It returns the object itself so this can be chained.
.PP
\&\f(CW$_\fR is made available and contains the value of \f(CW$val\fR
.PP
To exit the loop, return \f(CW\*(C`undef()\*(C'\fR, for example:
.PP
.Vb 5
\&    $a\->foreach(sub
\&    {
\&        return if( $_ eq $not_this_one );
\&        print( "ok, this one\en" );
\&    });
.Ve
.SS "get"
.IX Subsection "get"
Provided an integer representing an offset and this returns the corresponding value in the array. Offsets start from 0. A blank value will be treated as 0.
.PP
.Vb 5
\&    my $a = Module::Generic::Array\->new( [qw( abc def ghi )] );
\&    $a\->get( 1 ); # def
\&    $a\->get( \*(Aq\*(Aq ); # abc
\&    $a\->get( undef() ); # abc
\&    $a\->get( \-1 ); # ghi
.Ve
.PP
See also \*(L"index\*(R"
.SS "grep"
.IX Subsection "grep"
Provided with some data, and this will do a grep on the array.
.PP
If the data provided is a code reference or a reference to a subroutine, the code reference will be called for each array entry, and \f(CW$_\fR will also be available for each entry.
.PP
If the data is a regular expression, each array entry is tested against it.
.PP
It returns a list of matches found in ilst context and a new Module::Generic::Array in scalar context.
.SS "has"
.IX Subsection "has"
This is an alias for \*(L"exists\*(R"
.SS "index"
.IX Subsection "index"
Provided with an index of an element in the array and this returns its corresponding value.
.PP
It takes an integer and this ensures the value used is an integer by applying \*(L"int\*(R" in perlfunc
.PP
.Vb 2
\&    my $a = Module::Generic::Array\->new( [qw( John Jack Peter )] );
\&    $a\->index( 1 ); # returns Jack
.Ve
.PP
If there is nothing at the given offset, possibly because the array is smaller, then this would return undef.
.SS "iterator"
.IX Subsection "iterator"
This returns a new iterator to cycle through all the array items using iterator's method, such as \*(L"next\*(R" in Module::Generic::Iterator and \*(L"prev\*(R" in Module::Generic::Iterator. Each iterator element is an Module::Generic::Iterator::Element object
.PP
.Vb 8
\&    my $i = $a\->iterator;
\&    while( $i\->has_next )
\&    {
\&        my $elem = $i\->next;
\&        my $value = $elem\->value;
\&        # Get the next element relative to our element
\&        printf( "Next value is: %s at offset %d\en", $elem\->next, $elem\->next\->pos  );
\&    }
.Ve
.SS "join"
.IX Subsection "join"
Provided with a string, or expression just as documented in \*(L"join\*(R" in perlfunc and this will return a string as an <Module::Generic::Scalar object.
.SS "keys"
.IX Subsection "keys"
This works as documented in \*(L"keys\*(R" in perlfunc and returns a list of offset values for each entry in the array.
.SS "last"
.IX Subsection "last"
Returns the last element of the array. If there are none, instead it will return a Module::Generic::Null to ensure chaining will still work.
.SS "length"
.IX Subsection "length"
Returns the size of the array, starting from 1, as a Module::Generic::Number object.
.PP
This is different from \*(L"size\*(R" that returns value from 0 and \-1 if the array is empty.
.SS "list"
.IX Subsection "list"
Reeturns the array as a list
.PP
.Vb 3
\&    my $a = Module::Generic::Array\->new( [qw( Joe John Mary )] );
\&    print( "@$a" ); # Joe John Mary
\&    my @people = $a\->list; # @people now is ( "Joe", "John", "Mary" )
.Ve
.SS "map"
.IX Subsection "map"
Provided with a reference to a subroutine and this will call the subroutine for each element of the array and return a list in list context or a new Module::Generic::Array otherwise.
.PP
For each iteration of the array, \f(CW$_\fR is made available.
.PP
.Vb 1
\&    print( $a\->map(sub{ $_\->value })\->join( "\en" ), "\en" );
.Ve
.SS "pop"
.IX Subsection "pop"
Returns the last entry in the array.
.SS "pos"
.IX Subsection "pos"
Provided with some value (references are ok too), and this will return the position of it in the array, or undef if nothing was found.
.PP
.Vb 6
\&    my $a = Module::Generic::Array\->new( [qw( John Jack Peter )] );
\&    my $offset = $a\->pos( \*(AqJack\*(Aq ); # returns 1
\&    $a\->pos( \*(AqBob\*(Aq ); # Returns undef
\&    my $hash = { first_name => \*(AqJohn\*(Aq, last_name => \*(AqDoe\*(Aq };
\&    $a\->push( $hash );
\&    $a\->pos( $hash ); # Returns 3
.Ve
.PP
Note that it returns the position in the array of the first occurrence found. Maybe I should consider returning a list of all occurrences in list context?
.SS "push"
.IX Subsection "push"
Provided with some data and this adds it at the end of the array.
.SS "push_arrayref"
.IX Subsection "push_arrayref"
Provided with an array reference, and this add all its entry at the end of the array.
.PP
.Vb 4
\&    my $ar = Module::Generic::Array\->new( [qw( John Joe Mary )]);
\&    $ar\->push_arrayref( [qw( Jack Peter )] );
\&    print( $ar\->join( "," ), "\en" );
\&    # Now prints: John, Joe, Mary, Jack, Peter
.Ve
.SS "reset"
.IX Subsection "reset"
This empty the array, just like \*(L"undef\*(R"
.SS "reverse"
.IX Subsection "reverse"
Returns a the array in reverse order in list context or a new Module::Generic::Array object of it in scalar context.
.SS "scalar"
.IX Subsection "scalar"
Returns the size of the array. It basically calls \*(L"length\*(R"
.SS "set"
.IX Subsection "set"
Provided with an array, an array reference or an array-based object and this replaces all the data in the current object by the ones provided.
.PP
Note that if an array object is provided, it will copy the content of that object and not set the array object itself.
.PP
.Vb 3
\&    $a\->set( qw( John Jack Peter ) ); # Using an array of elements
\&    $a\->set( [qw( John Jack Peter )] ); # Using an array reference of elements
\&    $a\->set( $a2 ); # Using another array object, whatever its class may be
.Ve
.SS "shift"
.IX Subsection "shift"
Remove the first entry and returns it.
.SS "size"
.IX Subsection "size"
Returns the size of the array starting from 0, and \-1 if the array is empty, as a Module::Generic::Number object.
.PP
This is equivalent to the perl variable \f(CW$#\fR as documented in perldata. It returns the last index in the array.
.PP
This is different from \*(L"length\*(R" that returns value from 1 and 0 if the array is empty.
.SS "sort"
.IX Subsection "sort"
Sort the array and return the new array as a list in list context or a new Module::Generic::Array object in scalar context.
.SS "splice"
.IX Subsection "splice"
Takes the same arguments as the \*(L"splice\*(R" in perlfunc function, but its return value is different.
.PP
If \*(L"splice\*(R" is called to add new element, the array object is returned to allow chaining.
.PP
If no argument is provided, it just empties the array and return the array object is returned to allow chaining.
.PP
When offset and/or length are provided, it returns the list of elements found.
.SS "split"
.IX Subsection "split"
Just like the normal \*(L"split\*(R" in perlfunct function, it takes a string or expression and split the data provided into a list of elements.
.PP
It returns the list in list context, and returns a new Module::Generic::Array object in scalar context.
.SS "undef"
.IX Subsection "undef"
Just like \*(L"reset\*(R", this empty the array.
.SS "unshift"
.IX Subsection "unshift"
This add the given values at the beginning of the array.
.SS "values"
.IX Subsection "values"
Get a list of all the array values and return a list in list context or a ne Module::Generic::Array object in scalar context.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Generic::Scalar, Module::Generic::Number, Module::Generic::Boolean, Module::Generic::Hash, Module::Generic::Dynamic
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2000\-2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated
files under the same terms as Perl itself.
