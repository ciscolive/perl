.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises 3"
.TH Promises 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises \- An implementation of Promises in Perl
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use AnyEvent::HTTP;
\&  use JSON::XS qw[ decode_json ];
\&  use Promises qw[ collect deferred ];
\&
\&  sub fetch_it {
\&      my ($uri) = @_;
\&      my $d = deferred;
\&      http_get $uri => sub {
\&          my ($body, $headers) = @_;
\&          $headers\->{Status} == 200
\&              ? $d\->resolve( decode_json( $body ) )
\&              : $d\->reject( $body )
\&      };
\&      $d\->promise;
\&  }
\&
\&  my $cv = AnyEvent\->condvar;
\&
\&  collect(
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq),
\&  )\->then(
\&      sub {
\&          my ($product, $suggestions, $reviews) = @_;
\&          $cv\->send({
\&              product     => $product,
\&              suggestions => $suggestions,
\&              reviews     => $reviews,
\&          })
\&      },
\&      sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&  );
\&
\&  my $all_product_info = $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an implementation of the \*(L"Promise/A+\*(R" pattern for
asynchronous programming. Promises are meant to be a way to
better deal with the resulting callback spaghetti that can often
result in asynchronous programs.
.SH "FUTURE BACKWARDS COMPATIBILITY WARNING"
.IX Header "FUTURE BACKWARDS COMPATIBILITY WARNING"
The version of this module is being bumped up to 0.90 as the first
step towards 1.0 in which the goal is to have full Promises/A+ spec
compatibility. This is a departure to the previous goal of being
compatible with the Promises/A spec, this means that behavior may
change in subtle ways (we will attempt to document this completely
and clearly whenever possible).
.PP
It is \fB\s-1HIGHLY\s0\fR recommended that you test things very thoroughly
before upgrading to this version.
.SH "BACKWARDS COMPATIBILITY WARNING"
.IX Header "BACKWARDS COMPATIBILITY WARNING"
In version up to and including 0.08 there was a bug in how
rejected promises were handled. According to the spec, a
rejected callback can:
.IP "\(bu" 4
Rethrow the exception, in which case the next rejected handler
in the chain would be called, or
.IP "\(bu" 4
Handle the exception (by not \f(CW\*(C`die\*(C'\fRing), in which case the next
\&\fBresolved\fR handler in the chain would be called.
.PP
In previous versions of Promises, this last step was handled incorrectly:
a rejected handler had no way of handling the exception.  Once a promise
was rejected, only rejected handlers in the chain would be called.
.SS "Relation to the various Perl event loops"
.IX Subsection "Relation to the various Perl event loops"
This module is actually Event Loop agnostic, the \s-1SYNOPSIS\s0 above
uses AnyEvent::HTTP, but that is just an example, it can work
with any of the existing event loops out on \s-1CPAN.\s0 Over the next
few releases I will try to add in documentation illustrating each
of the different event loops and how best to use Promises with
them.
.SS "Relation to the Promise/A spec"
.IX Subsection "Relation to the Promise/A spec"
We are, with some differences, following the \s-1API\s0 spec called
\&\*(L"Promise/A\*(R" (and the clarification that is called \*(L"Promise/A+\*(R")
which was created by the Node.JS community. This is, for the most
part, the same \s-1API\s0 that is implemented in the latest jQuery and
in the \s-1YUI\s0 Deferred plug-in (though some purists argue that they
both go it wrong, google it if you care). We differ in some
respects to this spec, mostly because Perl idioms and best
practices are not the same as Javascript idioms and best
practices. However, the one important difference that should be
noted is that \*(L"Promise/A+\*(R" strongly suggests that the callbacks
given to \f(CW\*(C`then\*(C'\fR should be run asynchronously (meaning in the
next turn of the event loop). We do not do this by default,
because doing so would bind us to a given event loop
implementation, which we very much want to avoid. However we
now allow you to specify an event loop \*(L"backend\*(R" when using
Promises, and assuming a Deferred backend has been written
it will provide this feature accordingly.
.SS "Using a Deferred backend"
.IX Subsection "Using a Deferred backend"
As mentioned above, the default Promises::Deferred class calls the
success or error \f(CW\*(C`then()\*(C'\fR callback synchronously, because it isn't
tied to a particular event loop.  However, it is recommended that you
use the appropriate Deferred backend for whichever event loop you are
running.
.PP
Typically an application uses a single event loop, so all Promises
should use the same event-loop. Module implementers should just use the
Promises class directly:
.PP
.Vb 2
\&    package MyClass;
\&    use Promises qw(deferred collect);
.Ve
.PP
End users should specify which Deferred backend they wish to use. For
instance if you are using AnyEvent, you can do:
.PP
.Vb 2
\&    use Promises backend => [\*(AqAnyEvent\*(Aq];
\&    use MyClass;
.Ve
.PP
The Promises returned by MyClass will automatically use whichever
event loop AnyEvent is using.
.PP
See:
.IP "\(bu" 1
Promises::Deferred::AE
.IP "\(bu" 1
Promises::Deferred::AnyEvent
.IP "\(bu" 1
Promises::Deferred::EV
.IP "\(bu" 1
Promises::Deferred::Mojo
.IP "\(bu" 1
Promises::Deferred::IO::Async
.SS "Relation to Promises/Futures in Scala"
.IX Subsection "Relation to Promises/Futures in Scala"
Scala has a notion of Promises and an associated idea of Futures
as well. The differences and similarities between this module
and the Promises found in Scalar are highlighted in depth in a
cookbook entry below.
.SS "Cookbook"
.IX Subsection "Cookbook"
.IP "Promises::Cookbook::GentleIntro" 1
.IX Item "Promises::Cookbook::GentleIntro"
Read this first! This cookbook provides a step-by-step explanation
of how Promises work and how to use them.
.IP "Promises::Cookbook::SynopsisBreakdown" 1
.IX Item "Promises::Cookbook::SynopsisBreakdown"
This breaks down the example in the \s-1SYNOPSIS\s0 and walks through
much of the details of Promises and how they work.
.IP "Promises::Cookbook::TIMTOWTDI" 1
.IX Item "Promises::Cookbook::TIMTOWTDI"
Promise are just one of many ways to do async programming, this
entry takes the Promises \s-1SYNOPSIS\s0 again and illustrates some
counter examples with various modules.
.IP "Promises::Cookbook::ChainingAndPipelining" 1
.IX Item "Promises::Cookbook::ChainingAndPipelining"
One of the key benefits of Promises is that it retains much of
the flow of a synchronous program, this entry illustrates that
and compares it with a synchronous (or blocking) version.
.IP "Promises::Cookbook::Recursion" 1
.IX Item "Promises::Cookbook::Recursion"
This entry explains how to keep the stack under control when
using Promises recursively.
.IP "Promises::Cookbook::ScalaFuturesComparison" 1
.IX Item "Promises::Cookbook::ScalaFuturesComparison"
This entry takes some examples of Futures in the Scala language
and translates them into Promises. This entry also showcases
using Promises with Mojo::UserAgent.
.SH "EXPORTS"
.IX Header "EXPORTS"
.ie n .IP """deferred""" 4
.el .IP "\f(CWdeferred\fR" 4
.IX Item "deferred"
This just creates an instance of the Promises::Deferred class
it is purely for convenience.
.Sp
Can take a coderef, which will be dealt with as a \f(CW\*(C`then\*(C'\fR argument.
.Sp
.Vb 2
\&    my $promise = deferred sub {
\&        ... do stuff ...
\&
\&        return $something;
\&    };
\&
\&    # equivalent to
\&
\&    my $dummy = deferred;
\&
\&    my $promise = $dummy\->then(sub {
\&        ... do stuff ...
\&
\&        return $something;
\&    });
\&
\&    $dummy\->resolve;
.Ve
.ie n .IP """resolved( @values )""" 4
.el .IP "\f(CWresolved( @values )\fR" 4
.IX Item "resolved( @values )"
Creates an instance of Promises::Deferred resolved with
the provided \f(CW@values\fR. Purely a shortcut for
.Sp
.Vb 2
\&    my $promise = deferred;
\&    $promise\->resolve(@values);
.Ve
.ie n .IP """rejected( @values )""" 4
.el .IP "\f(CWrejected( @values )\fR" 4
.IX Item "rejected( @values )"
Creates an instance of Promises::Deferred rejected with
the provided \f(CW@values\fR. Purely a shortcut for
.Sp
.Vb 2
\&    my $promise = deferred;
\&    $promise\->reject(@values);
.Ve
.ie n .IP """collect( @promises )""" 4
.el .IP "\f(CWcollect( @promises )\fR" 4
.IX Item "collect( @promises )"
Accepts a list of Promises::Promise objects and then
returns a Promises::Promise object which will be called
once all the \f(CW@promises\fR have completed (either as an error
or as a success).
.Sp
The eventual result of the returned promise
object will be an array of all the results of each
of the \f(CW@promises\fR in the order in which they where passed
to \f(CW\*(C`collect\*(C'\fR originally, wrapped in arrayrefs, or the first error if
at least one of the promises fail.
.Sp
If \f(CW\*(C`collect\*(C'\fR is passed a value that is not a promise, it'll be wrapped
in an arrayref and passed through.
.Sp
.Vb 4
\&    my $p1 = deferred;
\&    my $p2 = deferred;
\&    $p1\->resolve(1);
\&    $p2\->resolve(2,3);
\&
\&    collect(
\&        $p1,
\&        \*(Aqnot a promise\*(Aq,
\&        $p2,
\&    )\->then(sub{
\&        print join \*(Aq : \*(Aq, map { join \*(Aq, \*(Aq, @$_ } @_; # => "1 : not a promise : 2, 3"
\&    })
.Ve
.ie n .IP """collect_hash( @promises )""" 4
.el .IP "\f(CWcollect_hash( @promises )\fR" 4
.IX Item "collect_hash( @promises )"
Like \f(CW\*(C`collect\*(C'\fR, but flatten its returned arrayref into a single
hash-friendly list.
.Sp
\&\f(CW\*(C`collect_hash\*(C'\fR can be useful to a structured hash instead
of a long list of promise values.
.Sp
For example,
.Sp
.Vb 1
\&  my $id = 12345;
\&
\&  collect(
\&      fetch_it("http://rest.api.example.com/\-/product/$id"),
\&      fetch_it("http://rest.api.example.com/\-/product/suggestions?for_sku=$id"),
\&      fetch_it("http://rest.api.example.com/\-/product/reviews?for_sku=$id"),
\&  )\->then(
\&      sub {
\&          my ($product, $suggestions, $reviews) = @_;
\&          $cv\->send({
\&              product     => $product,
\&              suggestions => $suggestions,
\&              reviews     => $reviews,
\&              id          => $id
\&          })
\&      },
\&      sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&  );
.Ve
.Sp
could be rewritten as
.Sp
.Vb 1
\&  my $id = 12345;
\&
\&  collect_hash(
\&      id          => $id,
\&      product     => fetch_it("http://rest.api.example.com/\-/product/$id"),
\&      suggestions => fetch_it("http://rest.api.example.com/\-/product/suggestions?for_sku=$id"),
\&      reviews     => fetch_it("http://rest.api.example.com/\-/product/reviews?for_sku=$id"),
\&  )\->then(
\&      sub {
\&          my %results = @_;
\&          $cv\->send(\e%results);
\&      },
\&      sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&  );
.Ve
.Sp
Note that all promise values of the key/value pairs passed to \f(CW\*(C`collect_hash\*(C'\fR
must return a scalar or nothing, as returning more than one value would
mess up the returned hash format. If a promise does return more than
one value, \f(CW\*(C`collect_hash\*(C'\fR will consider it as having failed.
.Sp
If you know that a
promise can return more than one value, you can do:
.Sp
.Vb 4
\&    my $collected = collect_hash(
\&        this => $promise_returning_scalar,
\&        that => $promise_returning_list\->then(sub{ [ @_ ] } ),
\&    );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Promises in General"
.IX Subsection "Promises in General"
.IP "You're Missing the Point of Promises <http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/>" 4
.IX Item "You're Missing the Point of Promises <http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/>"
.PD 0
.IP "Systems Programming at Twitter <http://monkey.org/~marius/talks/twittersystems/>" 4
.IX Item "Systems Programming at Twitter <http://monkey.org/~marius/talks/twittersystems/>"
.IP "\s-1SIP\-14\s0 \- Futures and Promises <http://docs.scala-lang.org/sips/pending/futures-promises.html>" 4
.IX Item "SIP-14 - Futures and Promises <http://docs.scala-lang.org/sips/pending/futures-promises.html>"
.IP "Promises/A+ spec <http://promises-aplus.github.io/promises-spec/>" 4
.IX Item "Promises/A+ spec <http://promises-aplus.github.io/promises-spec/>"
.IP "Promises/A spec <http://wiki.commonjs.org/wiki/Promises/A>" 4
.IX Item "Promises/A spec <http://wiki.commonjs.org/wiki/Promises/A>"
.PD
.SS "Perl Alternatives"
.IX Subsection "Perl Alternatives"
.IP "Future" 4
.IX Item "Future"
.PD 0
.IP "Mojo::Promise" 4
.IX Item "Mojo::Promise"
.PD
Part of the Mojolicious package.
.IP "Promise::ES6" 4
.IX Item "Promise::ES6"
.PD 0
.IP "Promise::Tiny" 4
.IX Item "Promise::Tiny"
.IP "AnyEvent::XSPromises" 4
.IX Item "AnyEvent::XSPromises"
.IP "Promise::XS" 4
.IX Item "Promise::XS"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
