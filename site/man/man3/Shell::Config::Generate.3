.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Shell::Config::Generate 3"
.TH Shell::Config::Generate 3 "2020-02-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Shell::Config::Generate \- Portably generate config for any shell
.SH "VERSION"
.IX Header "VERSION"
version 0.34
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
With this start up:
.PP
.Vb 2
\& use Shell::Guess;
\& use Shell::Config::Generate;
\& 
\& my $config = Shell::Config::Generate\->new;
\& $config\->comment( \*(Aqthis is my config file\*(Aq );
\& $config\->set( FOO => \*(Aqbar\*(Aq );
\& $config\->set_path(
\&   PERL5LIB => \*(Aq/foo/bar/lib/perl5\*(Aq,
\&               \*(Aq/foo/bar/lib/perl5/perl5/site\*(Aq,
\& );
\& $config\->append_path(
\&   PATH => \*(Aq/foo/bar/bin\*(Aq,
\&           \*(Aq/bar/foo/bin\*(Aq,
\& );
.Ve
.PP
This:
.PP
.Vb 1
\& $config\->generate_file(Shell::Guess\->bourne_shell, \*(Aqconfig.sh\*(Aq);
.Ve
.PP
will generate a config.sh file with this:
.PP
.Vb 12
\& # this is my config file
\& FOO=\*(Aqbar\*(Aq;
\& export FOO;
\& PERL5LIB=\*(Aq/foo/bar/lib/perl5:/foo/bar/lib/perl5/perl5/site\*(Aq;
\& export PERL5LIB;
\& if [ \-n "$PATH" ] ; then
\&   PATH=$PATH:\*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq;
\&   export PATH
\& else
\&   PATH=\*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq;
\&   export PATH;
\& fi;
.Ve
.PP
and this:
.PP
.Vb 1
\& $config\->generate_file(Shell::Guess\->c_shell, \*(Aqconfig.csh\*(Aq);
.Ve
.PP
will generate a config.csh with this:
.PP
.Vb 4
\& # this is my config file
\& setenv FOO \*(Aqbar\*(Aq;
\& setenv PERL5LIB \*(Aq/foo/bar/lib/perl5:/foo/bar/lib/perl5/perl5/site\*(Aq;
\& test "$?PATH" = 0 && setenv PATH \*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq || setenv PATH "$PATH":\*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq;
.Ve
.PP
and this:
.PP
.Vb 1
\& $config\->generate_file(Shell::Guess\->cmd_shell, \*(Aqconfig.cmd\*(Aq);
.Ve
.PP
will generate a \f(CW\*(C`config.cmd\*(C'\fR (Windows \f(CW\*(C`cmd.exe\*(C'\fR script) with this:
.PP
.Vb 4
\& rem this is my config file
\& set FOO=bar
\& set PERL5LIB=/foo/bar/lib/perl5;/foo/bar/lib/perl5/perl5/site
\& if defined PATH (set PATH=%PATH%;/foo/bar/bin;/bar/foo/bin) else (set PATH=/foo/bar/bin;/bar/foo/bin)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface for specifying shell configurations
for different shell environments without having to worry about the
arcane differences between shells such as csh, sh, cmd.exe and command.com.
.PP
It does not modify the current environment, but it can be used to
create shell configurations which do modify the environment.
.PP
This module uses Shell::Guess to represent the different types
of shells that are supported.  In this way you can statically specify
just one or more shells:
.PP
.Vb 9
\& #!/usr/bin/perl
\& use Shell::Guess;
\& use Shell::Config::Generate;
\& my $config = Shell::Config::Generate\->new;
\& # ... config config ...
\& $config\->generate_file(Shell::Guess\->bourne_shell,  \*(Aqfoo.sh\*(Aq );
\& $config\->generate_file(Shell::Guess\->c_shell,       \*(Aqfoo.csh\*(Aq);
\& $config\->generate_file(Shell::Guess\->cmd_shell,     \*(Aqfoo.cmd\*(Aq);
\& $config\->generate_file(Shell::Guess\->command_shell, \*(Aqfoo.bat\*(Aq);
.Ve
.PP
This will create foo.sh and foo.csh versions of the configurations,
which can be sourced like so:
.PP
.Vb 2
\& #!/bin/sh
\& . ./foo.sh
.Ve
.PP
or
.PP
.Vb 2
\& #!/bin/csh
\& source foo.csh
.Ve
.PP
It also creates \f(CW\*(C`.cmd\*(C'\fR and \f(CW\*(C`.bat\*(C'\fR files with the same configuration
which can be used in Windows.  The configuration can be imported back
into your shell by simply executing these files:
.PP
.Vb 1
\& C:\e> foo.cmd
.Ve
.PP
or
.PP
.Vb 1
\& C:\e> foo.bat
.Ve
.PP
Alternatively you can use the shell that called your Perl script using
Shell::Guess's \f(CW\*(C`running_shell\*(C'\fR method, and write the output to
standard out.
.PP
.Vb 6
\& #!/usr/bin/perl
\& use Shell::Guess;
\& use Shell::Config::Generate;
\& my $config = Shell::Config::Generate\->new;
\& # ... config config ...
\& print $config\->generate(Shell::Guess\->running_shell);
.Ve
.PP
If you use this pattern, you can eval the output of your script using
your shell's back ticks to import the configuration into the shell.
.PP
.Vb 2
\& #!/bin/sh
\& eval \`script.pl\`
.Ve
.PP
or
.PP
.Vb 2
\& #!/bin/csh
\& eval \`script.pl\`
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\& my $config = Shell::Config::Generate\->new;
.Ve
.PP
creates an instance of She::Config::Generate.
.SH "METHODS"
.IX Header "METHODS"
There are two types of instance methods for this class:
.IP "\(bu" 4
modifiers
.Sp
adjust the configuration in an internal portable format
.IP "\(bu" 4
generators
.Sp
generate shell configuration in a specific format given
the internal portable format stored inside the instance.
.PP
The idea is that you can create multiple modifications
to the environment without worrying about specific shells,
then when you are done you can create shell specific
versions of those modifications using the generators.
.PP
This may be useful for system administrators that must support
users that use different shells, with a single configuration
generation script written in Perl.
.SS "set"
.IX Subsection "set"
.Vb 1
\& $config\->set( $name => $value );
.Ve
.PP
Set an environment variable.
.SS "set_path"
.IX Subsection "set_path"
.Vb 1
\& $config\->set_path( $name => @values );
.Ve
.PP
Sets an environment variable which is stored in standard
\&'path' format (Like \s-1PATH\s0 or \s-1PERL5LIB\s0).  In \s-1UNIX\s0 land this
is a colon separated list stored as a string.  In Windows
this is a semicolon separated list stored as a string.
You can do the same thing using the \f(CW\*(C`set\*(C'\fR method, but if
you do so you have to determine the correct separator.
.PP
This will replace the existing path value if it already
exists.
.SS "append_path"
.IX Subsection "append_path"
.Vb 1
\& $config\->append_path( $name => @values );
.Ve
.PP
Appends to an environment variable which is stored in standard
\&'path' format.  This will create a new environment variable if
it doesn't already exist, or add to an existing value.
.SS "prepend_path"
.IX Subsection "prepend_path"
.Vb 1
\& $config\->prepend_path( $name => @values );
.Ve
.PP
Prepend to an environment variable which is stored in standard
\&'path' format.  This will create a new environment variable if
it doesn't already exist, or add to an existing value.
.SS "comment"
.IX Subsection "comment"
.Vb 1
\& $config\->comment( $comment );
.Ve
.PP
This will generate a comment in the appropriate format.
.PP
\&\fBnote\fR that including comments in your configuration may mean
it will not work with the \f(CW\*(C`eval\*(C'\fR backticks method for importing
configurations into your shell.
.SS "shebang"
.IX Subsection "shebang"
.Vb 2
\& $config\->shebang;
\& $config\->shebang($location);
.Ve
.PP
This will generate a shebang at the beginning of the configuration,
making it appropriate for use as a script.  For non \s-1UNIX\s0 shells this
will be ignored.  If specified, \f(CW$location\fR will be used as the
interpreter location.  If it is not specified, then the default
location for the shell will be used.
.PP
\&\fBnote\fR that the shebang in your configuration may mean
it will not work with the \f(CW\*(C`eval\*(C'\fR backticks method for importing
configurations into your shell.
.SS "echo_off"
.IX Subsection "echo_off"
.Vb 1
\& $config\->echo_off;
.Ve
.PP
For DOS/Windows configurations (\f(CW\*(C`command.com\*(C'\fR or \f(CW\*(C`cmd.exe\*(C'\fR), issue this as the
first line of the config:
.PP
.Vb 1
\& @echo off
.Ve
.SS "echo_on"
.IX Subsection "echo_on"
.Vb 1
\& $config\->echo_on;
.Ve
.PP
Turn off the echo off (that is do not put anything at the beginning of
the config) for DOS/Windows configurations (\f(CW\*(C`command.com\*(C'\fR or \f(CW\*(C`cmd.exe\*(C'\fR).
.SS "set_alias"
.IX Subsection "set_alias"
.Vb 1
\& $config\->set_alias( $alias => $command )
.Ve
.PP
Sets the given alias to the given command.
.PP
Caveat:
some older shells do not support aliases, such as
the original bourne shell.  This module will generate
aliases for those shells anyway, since /bin/sh may
actually be a more modern shell that \s-1DOES\s0 support
aliases, so do not use this method unless you can be
reasonable sure that the shell you are generating
supports aliases.  On Windows, for PowerShell, a simple
function is used instead of an alias so that arguments
may be specified.
.SS "set_path_sep"
.IX Subsection "set_path_sep"
.Vb 1
\& $config\->set_path_sep( $sep );
.Ve
.PP
Use \f(CW$sep\fR as the path separator instead of the shell
default path separator (generally \f(CW\*(C`:\*(C'\fR for Unix shells
and \f(CW\*(C`;\*(C'\fR for Windows shells).
.PP
Not all characters are supported, it is usually best
to stick with the shell default or to use \f(CW\*(C`:\*(C'\fR or \f(CW\*(C`;\*(C'\fR.
.SS "generate"
.IX Subsection "generate"
.Vb 2
\& my $command_text = $config\->generate;
\& my $command_text = $config\->generate( $shell );
.Ve
.PP
Generate shell configuration code for the given shell.
\&\f(CW$shell\fR is an instance of Shell::Guess.  If \f(CW$shell\fR
is not provided, then this method will use Shell::Guess
to guess the shell that called your perl script.
.PP
You can also pass in the shell name as a string for
\&\f(CW$shell\fR.  This should correspond to the appropriate
\&\fIname\fR_shell from Shell::Guess.  So for csh you
would pass in \f(CW"c"\fR and for tcsh you would pass in
\&\f(CW"tc"\fR, etc.
.SS "generate_file"
.IX Subsection "generate_file"
.Vb 1
\& $config\->generate_file( $shell, $filename );
.Ve
.PP
Generate shell configuration code for the given shell
and write it to the given file.  \f(CW$shell\fR is an instance
of Shell::Guess.  If there is an \s-1IO\s0 error it will throw
an exception.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "win32_space_be_gone"
.IX Subsection "win32_space_be_gone"
.Vb 1
\& my @new_path_list = win32_space_be_gone( @orig_path_list );
.Ve
.PP
On \f(CW\*(C`MSWin32\*(C'\fR and \f(CW\*(C`cygwin\*(C'\fR:
.PP
Given a list of directory paths (or filenames), this will
return an equivalent list of paths pointing to the same
file system objects without spaces.  To do this
\&\f(CW\*(C`Win32::GetShortPathName()\*(C'\fR is used on to find alternative
path names without spaces.
.PP
\&\s-1NOTE\s0 that this breaks when Windows is told not to create
short (\f(CW\*(C`8+3\*(C'\fR) filenames; see <http://www.perlmonks.org/?node_id=333930>
for a discussion of this behaviour.
.PP
In addition, on just \f(CW\*(C`Cygwin\*(C'\fR:
.PP
The input paths are first converted from \s-1POSIX\s0 to Windows paths
using \f(CW\*(C`Cygwin::posix_to_win_path\*(C'\fR, and then converted back to
\&\s-1POSIX\s0 paths using \f(CW\*(C`Cygwin::win_to_posix_path\*(C'\fR.
.PP
Elsewhere:
.PP
Returns the same list passed into it
.SS "cmd_escape_path"
.IX Subsection "cmd_escape_path"
.Vb 1
\& my @new_path_list = cmd_escape_path( @orig_path_list )
.Ve
.PP
Given a list of directory paths (or filenames), this will
return an equivalent list of paths escaped for cmd.exe and command.com.
.SS "powershell_escape_path"
.IX Subsection "powershell_escape_path"
.Vb 1
\& my @new_path_list = powershell_escape_path( @orig_path_list )
.Ve
.PP
Given a list of directory paths (or filenames), this will
return an equivalent list of paths escaped for PowerShell.
.SH "CAVEATS"
.IX Header "CAVEATS"
The test suite tests this module's output against the actual
shells that should understand them, if they can be found in
the path.  You can generate configurations for shells which
are not available (for example \f(CW\*(C`cmd.exe\*(C'\fR configurations from \s-1UNIX\s0 or
bourne configurations under windows), but the test suite only tests
them if they are found during the build of this module.
.PP
The implementation for \f(CW\*(C`csh\*(C'\fR depends on the external command \f(CW\*(C`test\*(C'\fR.
As far as I can tell \f(CW\*(C`test\*(C'\fR should be available on all modern
flavors of \s-1UNIX\s0 which are using \f(CW\*(C`csh\*(C'\fR.  If anyone can figure out
how to prepend or append to path type environment variable without
an external command in \f(CW\*(C`csh\*(C'\fR, then a patch would be appreciated.
.PP
The incantation for prepending and appending elements to a path
on csh probably deserve a comment here.  It looks like this:
.PP
.Vb 1
\& test "$?PATH" = 0 && setenv PATH \*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq || setenv PATH "$PATH":\*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq;
.Ve
.IP "\(bu" 4
one line
.Sp
The command is all on one line, and doesn't use if, which is
probably more clear and ideomatic.  This for example, might
make more sense:
.Sp
.Vb 5
\& if ( $?PATH == 0 ) then
\&   setenv PATH \*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq
\& else
\&   setenv PATH "$PATH":\*(Aq/foo/bar/bin:/bar/foo/bin\*(Aq
\& endif
.Ve
.Sp
However, this only works if the code interpreted using the csh
\&\f(CW\*(C`source\*(C'\fR command or is included in a csh script inline.  If you
try to invoke this code using csh \f(CW\*(C`eval\*(C'\fR then it will helpfully
convert it to one line and if does not work under csh in one line.
.PP
There are probably more clever or prettier ways to
append/prepend path environment variables as I am not a shell
programmer.  Patches welcome.
.PP
Only \s-1UNIX\s0 (bourne, bash, csh, ksh, fish and their derivatives) and
Windows (command.com, cmd.exe and PowerShell) are supported so far.
.PP
Fish shell support should be considered a tech preview.  The Fish
shell itself is somewhat in flux, and thus some tests are skipped
for the Fish shell since behavior is different for different versions.
In particular, new lines in environment variables may not work on
newer versions.
.PP
Patches welcome for your favorite shell / operating system.
.SH "AUTHOR"
.IX Header "AUTHOR"
Author: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
Brad Macpherson (\s-1BRAD,\s0 brad-mac)
.PP
mohawk
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Graham Ollis.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
