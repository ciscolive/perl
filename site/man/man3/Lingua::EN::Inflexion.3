.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Lingua::EN::Inflexion 3"
.TH Lingua::EN::Inflexion 3 "2020-07-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lingua::EN::Inflexion \- Inflect English nouns, verbs, adjectives, and articles
.SH "VERSION"
.IX Header "VERSION"
This document describes Lingua::EN::Inflexion version 0.002000
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Lingua::EN::Inflexion qw< noun inflect wordlist >;
\&
\&    # Request a search term, and treat it as a noun object...
\&    my $search_term   = prompt("Enter something to search for");
\&    my $search_target = noun($search_term);
\&
\&    # Search number\-insensitively (as a qr/PLURAL|SINGULAR/ regex)...
\&    my @matches = search($search_target\->as_regex);
\&
\&    # Inflect it to correct English...
\&    #    "0 indexes were found"
\&    #    "1 index was found"
\&    #    "99 indexes were found"
\&    my $search_result
\&        = inflect("<#i:$#matches> <N:indexes> <V:were> found");
\&
\&    # Inflect it to even better English...
\&    #    "no index was found"
\&    #    "one index was found"
\&    #    "99 indices were found"
\&    my $search_outcome
\&        = inflect("<#wnci:$#matches> <Nc:index> <V:was> found");
\&
\&    # Generate properly formatted lists of words and phrases...
\&    my $list = wordlist(@words);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Lingua::EN::Inflexion allows you to correctly inflect all
English nouns and verbs, as well as the small number of adjectives
and articles that still decline in modern English.
.PP
By default, the module follows the conventions of modern formal British
English (i.e. \s-1OED\s0 and Fowler's), but also attempts to support other
dialects as far as possible. The rules of inflexion it uses are almost
entirely table-driven (see \*(L"\s-1CONFIGURATION\*(R"\s0), so they can easily be
adapted for local requirements if necessary.
.PP
Where an English noun has both a modern and a classical/unassimilated
plural form (e.g. \*(L"maximums\*(R" and \*(L"maxima\*(R", \*(L"indexes\*(R" and \*(L"indices\*(R",
\&\*(L"librettos\*(R" and \*(L"libretti\*(R"), the module favours the modern inflexion,
unless the older form is specifically requested
(see \*(L"\fBclassical()\fR and \fBunassimilated()\fR\*(R").
.PP
In the few cases where a word has two or more singular inflexions (e.g.
plural \*(L"bases\*(R" to singular \*(L"base\*(R" or \*(L"basis\*(R") or is otherwise ambiguous
(e.g. plural \*(L"opera\*(R" to singular \*(L"opus\*(R" vs singular \*(L"opera\*(R" to plural
\&\*(L"operas\*(R"), the module provides a best guess about the more common usage.
These guesses can be changed by rearranging the source tables
(see \*(L"Rebuilding the module\*(R").
.SH "INTERFACE"
.IX Header "INTERFACE"
By default, the module exports five subroutines: \f(CW\*(C`noun()\*(C'\fR, \f(CW\*(C`verb()\*(C'\fR,
\&\f(CW\*(C`adj()\*(C'\fR, \f(CW\*(C`wordlist()\*(C'\fR, and \f(CW\*(C`inflect()\*(C'\fR.
.PP
The first three are constructors for objects representing nouns, verbs,
or adjectives respectively. These \fI\*(L"inflexion objects\*(R"\fR then provide a
selection of methods allowing each term to be appropriately inflected.
.PP
The \f(CW\*(C`wordlist()\*(C'\fR subroutine takes a list of words or phrases, and some
optional configuration arguments, and formats the list into a single
English phrase, with commas between the elements and a conjunction
before the last.
.PP
The \f(CW\*(C`inflect()\*(C'\fR subroutine is a general tool for constructing correctly
inflected sentences from uninflected components, using string
interpolation and a simple mark-up language.
.PP
As usual, you can also explicitly import a subset of these subroutines:
.PP
.Vb 1
\&    use Lingua::EN::Inflexion qw( noun verb );
.Ve
.PP
or you can import (some of) them under different names, by specifying
the name mappings in one or more hashes:
.PP
.Vb 7
\&    use Lingua::EN::Inflexion
\&        \*(Aqinflect\*(Aq,                     # imported as: inflect()
\&        {
\&          \*(Aqnoun\*(Aq => \*(Aqsubstantive\*(Aq,     # imported as: substantive()
\&          \*(Aqverb\*(Aq => \*(Aqdoing_word\*(Aq,      # imported as: doing_word()
\&        },
\&        { \*(Aqadj\*(Aq  => \*(Aqdescriptive\*(Aq }    # imported as: descriptive()
.Ve
.SS "Common methods shared by all inflexion objects"
.IX Subsection "Common methods shared by all inflexion objects"
The \f(CW\*(C`noun()\*(C'\fR, \f(CW\*(C`verb()\*(C'\fR, and \f(CW\*(C`adj()\*(C'\fR methods each return an
object representing an instance of that part of speech. In addition
to their type-specific interfaces, all those inflexion objects share the
following set of common methods, none of which takes an argument:
.ie n .IP """is_noun()""" 4
.el .IP "\f(CWis_noun()\fR" 4
.IX Item "is_noun()"
.PD 0
.ie n .IP """is_verb()""" 4
.el .IP "\f(CWis_verb()\fR" 4
.IX Item "is_verb()"
.ie n .IP """is_adj()""" 4
.el .IP "\f(CWis_adj()\fR" 4
.IX Item "is_adj()"
.PD
Returns true if the inflexion object represents the corresponding part
of speech. Shorter and quicker than calling:
.Sp
.Vb 3
\&    $term\->isa(\*(AqLingua::EN::Inflexion::Noun\*(Aq)
\&    $term\->isa(\*(AqLingua::EN::Inflexion::Verb\*(Aq)
\&    $term\->isa(\*(AqLingua::EN::Inflexion::Adjective\*(Aq)
.Ve
.ie n .IP """is_singular()""" 4
.el .IP "\f(CWis_singular()\fR" 4
.IX Item "is_singular()"
.PD 0
.ie n .IP """is_plural()""" 4
.el .IP "\f(CWis_plural()\fR" 4
.IX Item "is_plural()"
.PD
Returns true if the invocant represents a term of the
corresponding grammatical number.
.Sp
Note that the same inflexion object may return true for \fIboth\fR of these
calls, if the term it represents is uninflected. For example:
.Sp
.Vb 2
\&    noun(\*(Aqfish\*(Aq)\->is_singular     # true
\&    noun(\*(Aqfish\*(Aq)\->is_plural       # true
\&
\&    verb(\*(Aqcan\*(Aq)\->is_singular      # true
\&    verb(\*(Aqcan\*(Aq)\->is_plural        # true
\&
\&    adj(\*(Aqtypical\*(Aq)\->is_singular   # true
\&    adj(\*(Aqtypical\*(Aq)\->is_plural     # true
.Ve
.ie n .IP """singular( $optional_person )""" 4
.el .IP "\f(CWsingular( $optional_person )\fR" 4
.IX Item "singular( $optional_person )"
.PD 0
.ie n .IP """plural( $optional_person )""" 4
.el .IP "\f(CWplural( $optional_person )\fR" 4
.IX Item "plural( $optional_person )"
.PD
Returns a string representing the corresponding inflexion of the term
represented by the invocant. For example:
.Sp
.Vb 1
\&    say noun(\*(Aqfeet\*(Aq)\->singular;    # "foot"
\&
\&    say verb(\*(Aqis\*(Aq)\->plural;        # "are"
\&
\&    say adj("our")\->singular;      # "my"
.Ve
.Sp
If the optional argument is provided, it must be an integer between 1
and 3, which specifies the grammatical \*(L"person\*(R" (1st , 2nd, or 3rd)
that is wanted. Very few English nouns and adjectives are inflected
by person, so this option only affects personal and possessive pronouns,
possessive adjectives, and verbs:
.Sp
.Vb 4
\&    say noun(\*(Aqshe\*(Aq)\->singular;      # "she"
\&    say noun(\*(Aqshe\*(Aq)\->singular(1);   # "I"
\&    say noun(\*(Aqshe\*(Aq)\->singular(2);   # "you"
\&    say noun(\*(Aqshe\*(Aq)\->singular(3);   # "she"
\&
\&    say verb(\*(Aqam\*(Aq)\->singular;       # "am"
\&    say verb(\*(Aqam\*(Aq)\->singular(1);    # "am"
\&    say verb(\*(Aqam\*(Aq)\->singular(2);    # "are"
\&    say verb(\*(Aqam\*(Aq)\->singular(3);    # "is"
\&
\&    say adj("my")\->plural;       # "our"
\&    say adj("my")\->plural(1);    # "our"
\&    say adj("my")\->plural(2);    # "your"
\&    say adj("my")\->plural(3);    # "their"
.Ve
.Sp
Note that, without the argument, the method always
attempts to preserve the original person of the term:
.Sp
.Vb 3
\&    say verb(\*(Aqam\*(Aq)\->singular;       # "am"
\&    say verb(\*(Aqare\*(Aq)\->singular;      # "are"
\&    say verb(\*(Aqis\*(Aq)\->singular;       # "is"
.Ve
.Sp
Also note that, where a plural noun or adjective has multiple 3rd\-person
singular forms, the method always prefers the gender neutral form:
.Sp
.Vb 2
\&    say noun("they")\->singular;     # "it"  (not "she" or "he")
\&    say adj("our")\->singular(3);    # "its" (not "hers" or "his")
.Ve
.ie n .IP """classical()"" or ""unassimilated()""" 4
.el .IP "\f(CWclassical()\fR or \f(CWunassimilated()\fR" 4
.IX Item "classical() or unassimilated()"
This is a single method with two alternative names. It returns an
inflexion object representing the term, but which thereafter always
inflects in the classical/unassimilated maner. For example:
.Sp
.Vb 2
\&    say noun(\*(Aqbrother\*(Aq)\->plural;             # "brothers"
\&    say noun(\*(Aqbrother\*(Aq)\->classical\->plural;  # "brethren"
.Ve
.Sp
Note that most terms have only a single plural form, in which
case the resulting classical inflexion object will just
return the single plural form anyway. In fact, in such cases,
the module may choose to have \f(CW\*(C`classical()\*(C'\fR return the same
object as it was called on.
.ie n .IP """as_regex()""" 4
.el .IP "\f(CWas_regex()\fR" 4
.IX Item "as_regex()"
Returns a \f(CW\*(C`qr\*(C'\fR'd regex object which would match (case-insensitively)
any inflected form of the word. For example:
.Sp
.Vb 1
\&    $word =~ noun(\*(Aqcherub\*(Aq)\->as_regex   # qr/cherubs|cherubim|cherub/i
\&
\&    $word =~ verb(\*(Aqeat\*(Aq)\->as_regex      # qr/eats|eating|eaten|eat|ate/i
.Ve
.PP
\fIRegex and string coercions\fR
.IX Subsection "Regex and string coercions"
.PP
In Perl 5.12 or later, the \f(CW\*(C`as_regex()\*(C'\fR method is called
automatically if an inflexion object is used anywhere a regex is
expected. So the previous example could also have been written as:
.PP
.Vb 1
\&    $word =~ noun(\*(Aqcherub\*(Aq)             # qr/cherubs|cherubim|cherub/i
.Ve
.PP
If an inflexion object is used as a string, it is coerced back the
original string from which the object was built:
.PP
.Vb 2
\&    say noun("indices");                # prints: "indices"
\&    say verb("explains");               # prints: "explains"
.Ve
.PP
If you want a particular inflexion of the original word, ask for it
explicitly:
.PP
.Vb 2
\&    say noun("indices")\->singular;      # prints: "index"
\&    say verb("explains")\->plural;       # prints: "explain"
.Ve
.PP
\fISmartmatching inflexion objects\fR
.IX Subsection "Smartmatching inflexion objects"
.PP
If two inflexion objects are smartmatched, the operation
compares the two objects' singular, plural, and classical
plural inflexions, and returns true if any one pair of
inflexions matches (case-insensitively).
.PP
That is:
.PP
.Vb 1
\&    noun($word1) ~~ noun($word2)
.Ve
.PP
is just a shorthand for:
.PP
.Vb 3
\&       lc(noun($word1)\->singular)          eq lc(noun($word2)\->singular)
\&    || lc(noun($word1)\->plural)            eq lc(noun($word2)\->plural)
\&    || lc(noun($word1)\->classical\->plural) eq lc(noun($word2)\->classical\->plural)
.Ve
.PP
If an inflexion object is smartmatched against anything else, the
inflexion object is converted to a regex, which is then smartmatched
against the other argument.
.PP
That is:
.PP
.Vb 2
\&    $something_else ~~ noun($word1)
\&       noun($word1) ~~ $something_else
.Ve
.PP
are just slightly shorter (and less order-specific) ways of writing:
.PP
.Vb 1
\&    $something_else =~ noun($word1)\->as_regex;
.Ve
.PP
Note that the behaviour of smartmatched inflexion objects, together with
the regex and string coercions described earlier, collectively means
that there are significant differences between:
.PP
.Vb 2
\&    $word1 =~ noun($word2)         # $word1 matches any inflexion of $word2
\&    $word1 ~~ noun($word2)         # (ditto)
\&
\&    noun($word1) =~ $word2         # $word1 matches $word2 exactly
\&
\&    noun($word1) ~~ $word2         # any inflexion of $word1 matches $word2
\&
\&    noun($word1) ~~ noun($word2)   # $word1 and $word2 match in at least
\&                                   # one of their inflexions
.Ve
.PP
Choose the appropriate form of matching for the type and degree of
number-insensitivity you need.
.PP
\fIOther coercions on inflexion objects\fR
.IX Subsection "Other coercions on inflexion objects"
.PP
All other attempts to coerce an inflexion object to a value
(i.e. to a boolean or a number) fall back to the normal built-in
behaviour for Perl objects. That is: inflexion objects are always true,
and always numerify to their own memory address.
.PP
Any attempt to coerce an inflexion object to a reference produces
an exception.
.ie n .SS "The ""noun()"" constructor and associated methods"
.el .SS "The \f(CWnoun()\fP constructor and associated methods"
.IX Subsection "The noun() constructor and associated methods"
The \f(CW\*(C`noun()\*(C'\fR subroutine takes a single argument: a string containing
a noun or noun phrase. It returns an inflexion object representing
that noun:
.PP
.Vb 1
\&    my $noun_obj = noun($string);
.Ve
.PP
The subroutine is just a convenient wrapper around a constructor,
which you can call directly if you prefer:
.PP
.Vb 1
\&    my $noun_obj = Lingua::EN::Inflexion::Noun\->new($string);
.Ve
.PP
Noun objects provide six extra methods in addition to the common methods
described above...
.PP
\fI\f(CI\*(C`indef_article()\*(C'\fI\fR
.IX Subsection "indef_article()"
.PP
This method takes a no argument and returns either the string \f(CW\*(Aqa\*(Aq\fR or
the string \f(CW\*(Aqan\*(Aq\fR, depending on which form of indefinite article the
singular inflexion of that particular word requires.
.PP
Thus:
.PP
.Vb 4
\&    noun("uncle")\->indef_article();    # "an"
\&    noun("union")\->indef_article();    # "a"
\&    noun("house")\->indef_article();    # "a"
\&    noun("hours")\->indef_article();    # "an"
.Ve
.PP
\fI\f(CI\*(C`indefinite($count = 1)\*(C'\fI\fR
.IX Subsection "indefinite($count = 1)"
.PP
This method takes a single argument: an optional integer count
(which defaults to 1).
.PP
If the count value is 1, the method returns a string containing the
singular form of the noun with the appropriate indefinite article
(either \*(L"a\*(R" or \*(L"an\*(R") prepended.
.PP
If the count is not 1, the method returns a string containing the
plural form of the noun with the count value itself prepended.
.PP
Thus:
.PP
.Vb 6
\&                                    #   $N = 0      $N = 1      $N = 2
\&                                    #
\&    noun("uncle")\->indefinite($N);  # "0 uncles", "an uncle", "2 uncles"
\&    noun("union")\->indefinite($N);  # "0 unions",  "a union", "2 unions"
\&    noun("house")\->indefinite($N);  # "0 houses",  "a house", "2 houses"
\&    noun("hours")\->indefinite($N);  # "0 hours",  "an hour",  "2 hours"
.Ve
.PP
\fI\f(CI\*(C`cardinal()\*(C'\fI and \f(CI\*(C`cardinal($threshold)\*(C'\fI\fR
.IX Subsection "cardinal() and cardinal($threshold)"
.PP
Convert the word into the English word for a cardinal number, using the
Lingua::EN::Nums2Words module (which must be installed or an exception
is thrown). If the \f(CW$threshold\fR argument is supplied and the word
represents a number greater than or equal to that value, then word is
converted to digits instead.
.PP
For example:
.PP
.Vb 4
\&    noun( 1)\->cardinal;      # "one"
\&    noun(10)\->cardinal;      # "ten"
\&    noun(11)\->cardinal(20);  # "eleven"
\&    noun(21)\->cardinal(20);  # "21"
.Ve
.PP
The word is also converted if it is an English phrase representing
a valid number (via the Lingua::EN::Words2Nums module, which must
be installed or an exception is thrown):
.PP
.Vb 4
\&    noun("one")\->cardinal;                             # "one"
\&    noun("ten")\->cardinal;                             # "ten"
\&    noun("eleven")\->cardinal(20);                      # "eleven"
\&    noun("one hundred and twenty\-one")\->cardinal(20);  # "121"
.Ve
.PP
Words that are ordinal numbers are also correctly converted:
.PP
.Vb 2
\&    noun("first")\->cardinal;  # "one"
\&    noun("142nd")\->cardinal;  # "one hundred and forty\-two"
.Ve
.PP
Words that cannot be interpreted as numbers are treated as zero:
.PP
.Vb 2
\&    noun("eon")\->cardinal;    # "zero"
\&    noun("elven")\->cardinal;  # "zero"
.Ve
.PP
\fI\f(CI\*(C`ordinal()\*(C'\fI and \f(CI\*(C`ordinal($threshold)\*(C'\fI\fR
.IX Subsection "ordinal() and ordinal($threshold)"
.PP
Convert the word into the English word for an ordinal number, using the
Lingua::EN::Nums2Words module (which must be installed or an exception
is thrown). If the \f(CW$threshold\fR argument is supplied and the word
represents a number greater than or equal to that value, then word is
converted to digits instead.
.PP
For example:
.PP
.Vb 4
\&    noun( 1)\->ordinal;      # "first"
\&    noun(10)\->ordinal;      # "tenth"
\&    noun(11)\->ordinal(20);  # "eleventh"
\&    noun(21)\->ordinal(20);  # "21st"
.Ve
.PP
The word is also converted if it is an English phrase representing
a valid number (via the Lingua::EN::Words2Nums module, which must
be installed or an exception is thrown):
.PP
.Vb 4
\&    noun("one")\->ordinal;                             # "first"
\&    noun("ten")\->ordinal;                             # "tenth"
\&    noun("eleven")\->ordinal(20);                      # "eleventh"
\&    noun("one hundred and twenty\-one")\->ordinal(20);  # "121st"
.Ve
.PP
Words that are ordinal numbers are also correctly converted:
.PP
.Vb 4
\&    noun("first")\->ordinal;     # "first"
\&    noun("142nd")\->ordinal;     # "one hundred and forty\-second"
\&    noun("first")\->ordinal(0);  # "1st"
\&    noun("142nd")\->ordinal(0);  # "142nd"
.Ve
.PP
Words that cannot be interpreted as numbers are treated as zero:
.PP
.Vb 2
\&    noun("eon")\->ordinal;       # "zeroth"
\&    noun("elven")\->ordinal;     # "zeroth"
.Ve
.ie n .SS "The ""verb()"" constructor and associated methods"
.el .SS "The \f(CWverb()\fP constructor and associated methods"
.IX Subsection "The verb() constructor and associated methods"
The \f(CW\*(C`verb()\*(C'\fR subroutine takes a single argument: a string containing a
simple verb in the present tense (singular or plural). It returns an
inflexion object representing that verb.
.PP
.Vb 1
\&    my $verb_obj = verb($string);
.Ve
.PP
Like \f(CW\*(C`noun()\*(C'\fR, it's just a convenient shorthand for:
.PP
.Vb 1
\&    my $verb_obj = Lingua::EN::Inflexion::Verb\->new($string);
.Ve
.PP
Verb objects provide eight extra methods (in addition to the common
methods described earlier)...
.PP
\fI\f(CI\*(C`past()\*(C'\fI\fR
.IX Subsection "past()"
.PP
This method takes no arguments. It returns a string containing
the simple past tense (preterite) inflexion of the verb.
.PP
For example:
.PP
.Vb 3
\&    say verb("bat")\->past;   # "batted"
\&    say verb("sit")\->past;   # "sat"
\&    say verb("eat")\->past;   # "ate"
.Ve
.PP
\fI\f(CI\*(C`pres_part()\*(C'\fI\fR
.IX Subsection "pres_part()"
.PP
This method takes no arguments. It returns a string containing
the present participle of the verb.
.PP
For example:
.PP
.Vb 3
\&    say verb("bat")\->pres_part;   # "batting"
\&    say verb("sit")\->pres_part;   # "sitting"
\&    say verb("eat")\->pres_part;   # "eating"
.Ve
.PP
\fI\f(CI\*(C`past_part()\*(C'\fI\fR
.IX Subsection "past_part()"
.PP
This method takes no arguments. It returns a string containing
the past participle of the verb.
.PP
For example:
.PP
.Vb 3
\&    say verb("bat")\->past;   # "batted"
\&    say verb("sit")\->past;   # "sat"
\&    say verb("eat")\->past;   # "eaten"
.Ve
.PP
\fI\f(CI\*(C`is_present()\*(C'\fI\fR
.IX Subsection "is_present()"
.PP
\fI\f(CI\*(C`is_past()\*(C'\fI\fR
.IX Subsection "is_past()"
.PP
\fI\f(CI\*(C`is_pres_part()\*(C'\fI\fR
.IX Subsection "is_pres_part()"
.PP
\fI\f(CI\*(C`is_past_part()\*(C'\fI\fR
.IX Subsection "is_past_part()"
.PP
These methods return true when the original verb from which the
inflexion object was constructed is in the appropriate tense
(present or simple past) or is the appropriate participle.
.PP
For example
.PP
.Vb 4
\&    if (verb("sat")\->is_present)   {...}   # false
\&    if (verb("sat")\->is_past)      {...}   # true
\&    if (verb("sat")\->is_pres_part) {...}   # false
\&    if (verb("sat")\->is_past_part) {...}   # true
.Ve
.PP
\fI\f(CI\*(C`indefinite($count = 1)\*(C'\fI\fR
.IX Subsection "indefinite($count = 1)"
.PP
This method takes a single argument: an optional integer count
(which defaults to 1).
.PP
If the count value is 1, it returns the singular inflexion of the
verb. If the count is any other numeric value, it returns the
plural inflexion.
.ie n .SS "The ""adj()"" constructor and associated methods"
.el .SS "The \f(CWadj()\fP constructor and associated methods"
.IX Subsection "The adj() constructor and associated methods"
The \f(CW\*(C`adj()\*(C'\fR subroutine takes a single argument: a string containing
a simple adjective. It returns an inflexion object representing that
adjective:
.PP
.Vb 1
\&    my $adj_obj = adj($string);
.Ve
.PP
Like \f(CW\*(C`noun()\*(C'\fR and \f(CW\*(C`verb()\*(C'\fR, it's just an abbreviation for:
.PP
.Vb 1
\&    my $adj_obj = Lingua::EN::Inflexion::Adjective\->new($string);
.Ve
.PP
Adjective objects provide no methods except the common methods
described previously.
.ie n .SS "Sentence inflexions via the ""inflect()"" subroutine"
.el .SS "Sentence inflexions via the \f(CWinflect()\fP subroutine"
.IX Subsection "Sentence inflexions via the inflect() subroutine"
The \s-1OO\s0 nature of the Lingua::EN::Inflexion \s-1API\s0 makes it clean,
extensible, and robust. But does not make it easy to use in
the most common case:
.PP
.Vb 3
\&    # Do the search...
\&    my $target = noun($word);
\&    my @results = search_for($target\->as_regex);
\&
\&    # Do some grammar...
\&    my $target_s = @results==1 ? $target\->singular : $target\->plural;
\&    my $was_were = @results==1 ? \*(Aqwas\*(Aq             : \*(Aqwere\*(Aq;
\&
\&    # Report the results...
\&    say @results . " $target_s $was_were found";
.Ve
.PP
So Lingua::EN::Inflexion also provides a single subroutine that implements
a basic markup language to simplify the task:
.PP
.Vb 2
\&    # Do the search...
\&    my @results = search_for( noun($word)\->as_regex );
\&
\&    # Report the results...
\&    say inflect "<#i:$#results> <N:$word)> <V:was> found";
.Ve
.PP
The \f(CW\*(C`inflect()\*(C'\fR subroutine takes a single string argument and
replaces any nested markups (in angle brackets) with the appropriate
inflexions of their contents. It then returns the inflected string.
.PP
The markup notation always takes the form: \f(CW\*(C`<Xopts:content>\*(C'\fR
where \f(CW\*(C`X\*(C'\fR is a command (either \f(CW\*(C`N\*(C'\fR or \f(CW\*(C`V\*(C'\fR or \f(CW\*(C`A\*(C'\fR or \f(CW\*(C`#\*(C'\fR),
\&\f(CW\*(C`opts\*(C'\fR represents zero or more options for the command,
and \f(CW\*(C`content\*(C'\fR is the data on which to apply the command (normally
a word or phrase to be inflected).
.PP
The four commands currently supported are:
.PP
\fI\f(CI\*(C`<#: \f(CIinteger\f(CI >\*(C'\fI\fR
.IX Subsection "<#: integer >"
.PP
This markup sets the current count, which is used by which subsequent
markups in the string to chose whether to inflect their contents in the
singular (if the count is 1) or the plural (otherwise). The markup
itself is normally replaced with the integer specified or with
something equivalent, depending on the particular options used.
.PP
The options for this command are:
.ie n .IP """n""" 4
.el .IP "\f(CWn\fR" 4
.IX Item "n"
If the count equals zero, interpolate \*(L"no\*(R" into the string instead of the
actual count. For example:
.Sp
.Vb 3
\&    say inflect "<#n:$count> <N:results>";
\&              # "no results"   if $count == 0
\&              # "7 results"    if $count == 7
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`n\*(C'\fR for \*(L"no\*(R" or \*(L"nil's not numeric\*(R".
.ie n .IP """s""" 4
.el .IP "\f(CWs\fR" 4
.IX Item "s"
If the count equals zero, interpolate \*(L"no\*(R" into the string instead of
the actual count...and also inflect any subsequent nouns and verbs in
the singular. That is, the same word replacement as for the \f(CW\*(C`n\*(C'\fR option,
but treating zero as singular, not plural:
.Sp
.Vb 2
\&    say inflect "<#n:$count> <N:item> <V:were> found";
\&              # "no items were found"
\&
\&    say inflect "<#s:$count> <N:item> <V:were> found";
\&              # "no item was found"
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`s\*(C'\fR for \*(L"singular\*(R" or \*(L"sophisticated\*(R" or \*(L"snooty\*(R".
.ie n .IP """a""" 4
.el .IP "\f(CWa\fR" 4
.IX Item "a"
If the count equals one, interpolate \*(L"a\*(R" or \*(L"an\*(R" into the string instead
of the actual count. For example:
.Sp
.Vb 3
\&    say inflect "<#a:$count> <N:results>";
\&              # "a result"    if $count == 1
\&              # "3 results"   if $count == 3
\&
\&    say inflect "<#a:$count> <N:outcomes>";
\&              # "an outcome"  if $count == 1
\&              # "3 outcomes"  if $count == 3
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`a\*(C'\fR for \*(L"a\*(R" and \*(L"an\*(R", or \*(L"article\*(R".
.ie n .IP """w""" 4
.el .IP "\f(CWw\fR" 4
.IX Item "w"
If the count is small (between zero and ten), interpolate the
appropriate English word instead of the number:
.Sp
.Vb 4
\&    say inflect "<#w:$count> <N:results>";
\&              # "six results"  if $count == 6
\&              # "ten results"  if $count == 10
\&              # "11 results"   if $count == 11
.Ve
.Sp
Note that this option is overridden by the special case behaviours of
both the \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`a\*(C'\fR options, if either is also specified.
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`w\*(C'\fR for \*(L"wordy\*(R" or \*(L"written-out\*(R".
.ie n .IP """w""\fIN\fR" 4
.el .IP "\f(CWw\fR\fIN\fR" 4
.IX Item "wN"
The \f(CW\*(C`w\*(C'\fR option can also be followed by one or more digits, in which
case if the count is less than that number, the appropriate English word
is interpolated instead of the number:
.Sp
.Vb 4
\&    say inflect "<#w20:$count> <N:results>";
\&              # "six results"      if $count == 6
\&              # "nineteen results" if $count == 19
\&              # "20 results"       if $count == 20
.Ve
.Sp
In all other respects this variant behaves exactly like a regular \f(CW\*(C`w\*(C'\fR
option, as described in the previous item.
.ie n .IP """o""" 4
.el .IP "\f(CWo\fR" 4
.IX Item "o"
Display the count as an ordinal:
.Sp
.Vb 4
\&    say inflect "<#o:$count> <N:results>";
\&              # "1st result"   if $count == 6
\&              # "11th result"  if $count == 11
\&              # "22nd result"  if $count == 22
.Ve
.Sp
Note that, in keeping with English usage, under the \f(CW\*(C`o\*(C'\fR option, the
effective count is set to 1, rather than the actual number provided.
.Sp
When this option is combined with the \f(CW\*(C`w\*(C'\fR option, the ordinal is
converted to words:
.Sp
.Vb 4
\&    say inflect "<#ow:$count> <N:results>";
\&              # "first result"  if $count == 6
\&              # "tenth result"  if $count == 10
\&              # "11th result"   if $count == 11
.Ve
.Sp
Note that this option is overridden by the special case behaviours of
both the \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`a\*(C'\fR options, if either is also specified.
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`o\*(C'\fR for \*(L"ordinal\*(R" or \*(L"ordered\*(R".
.ie n .IP """f""" 4
.el .IP "\f(CWf\fR" 4
.IX Item "f"
Set the count, but instead of interpolating the number, interpolate
a phrase summarizing the general amount represented by that number.
.Sp
For example:
.Sp
.Vb 7
\&    say inflect "Found <#f:$count> <N:matches>";
\&              # "Found no matches"           if $count == 0
\&              # "Found one match"            if $count == 1
\&              # "Found a couple of matches"  if $count == 2
\&              # "Found a few matches"        if $count ~~ 3..5;
\&              # "Found several matches"      if $count ~~ 6..9;
\&              # "Found many matches"         if $count >= 10
.Ve
.Sp
If the \f(CW\*(C`#\*(C'\fR markup is at the end of the string (i.e. is not followed
by an alphabetic character), the phrases used are slightly different:
.Sp
.Vb 7
\&    say inflect "Searching for <Np:$target>.....found <#f:$count>.";
\&              # "Searching for \*(Aqitems\*(Aq.....found none."
\&              # "Searching for \*(Aqitems\*(Aq.....found one."
\&              # "Searching for \*(Aqitems\*(Aq.....found a couple."
\&              # "Searching for \*(Aqitems\*(Aq.....found a few."
\&              # "Searching for \*(Aqitems\*(Aq.....found several."
\&              # "Searching for \*(Aqitems\*(Aq.....found many."
.Ve
.Sp
The \f(CW\*(C`s\*(C'\fR and \f(CW\*(C`a\*(C'\fR options override the wording for counts of
zero or one:
.Sp
.Vb 3
\&    say inflect "Found <#fs:$count> <N:matches>";
\&              # "Found no match"             if $count == 0
\&              # "Found several matches"      if $count == 7
\&
\&    say inflect "Found <#fa:$count> <N:matches>";
\&              # "Found a match"              if $count == 1
\&              # "Found several matches"      if $count == 7
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`f\*(C'\fR for \*(L"fuzzy\*(R" or \*(L"friendly\*(R" or \*(L"few\*(R".
.ie n .IP """e""" 4
.el .IP "\f(CWe\fR" 4
.IX Item "e"
You can combine multiple count options to obtain more
sophisticated effects. A particularly elegant combination is:
.Sp
.Vb 5
\&    say inflect "<#asw:$count> <N:matches> <V:were> found";
\&              # "no match was found"      if $count == 0
\&              # "a match was found"       if $count == 1
\&              # "ten matches were found"  if $count == 10
\&              # "12 matches were found"   if $count == 12
.Ve
.Sp
This set of options is useful, but bordering on ponderous, so there is
an abbreviation for it:
.Sp
.Vb 1
\&    say inflect "<#e:$count> <N:matches> <V:were> found";
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`e\*(C'\fR for \*(L"eloquent\*(R" or \*(L"editorial expansion\*(R" or \*(L"erudite\*(R"
(or possibly: \*(L"elitist\*(R").
.ie n .IP """i""" 4
.el .IP "\f(CWi\fR" 4
.IX Item "i"
Increment the supplied integer \fIbefore\fR setting it as the current count
or interpolating it back into the string. This is useful if you have
an array of results and would like to interpolate its size as the
current count.
.Sp
For example, instead of:
.Sp
.Vb 2
\&    my $count = scalar(@results);
\&    say inflect "<#:$count> <N:matches> <V:were> retrieved";
.Ve
.Sp
or (even more hideously):
.Sp
.Vb 1
\&    say inflect "<#:${\e(@results)}> <N:matches> <V:were> retrieved";
.Ve
.Sp
you can just use:
.Sp
.Vb 1
\&    say inflect "<#i:$#results> <N:matches> <V:were> retrieved";
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`i\*(C'\fR for \*(L"increment\*(R" or \*(L"its intrinsic index is insufficient; increase it\*(R".
.ie n .IP """d""" 4
.el .IP "\f(CWd\fR" 4
.IX Item "d"
Set the current count definition, without displaying anything in place
of the markup.
.Sp
This is useful for constructions that either do not mention the count
explicitly:
.Sp
.Vb 3
\&    say inflect "<#d:$count> <N:Match> found";
\&              # "Match found"           if $count == 1
\&              # "Matches found"         if $count > 1
.Ve
.Sp
or in constructions where the count has to appear \fIafter\fR something
whose inflexion it controls:
.Sp
.Vb 3
\&    say inflect "There <#d:$count> <V:were> $count <N:matches>";
\&              # "There was 1 match"     if $count == 1
\&              # "There were 7 matches"  if $count > 1
.Ve
.Sp
The \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`n\*(C'\fR, and \f(CW\*(C`c\*(C'\fR options override \f(CW\*(C`d\*(C'\fR, so you can still be
specific when the count is less than two:
.Sp
.Vb 4
\&    say inflect "<#asd:$count> <N:matches> <V:were> found";
\&              # "no match was found"    if $count == 0
\&              # "a match was found"     if $count == 1
\&              # "matches were found"    if $count > 1
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`d\*(C'\fR for \*(L"don't display\*(R" or \*(L"disguised definition\*(R" or \*(L"delete\*(R".
.PP
\fI\f(CI\*(C`<N: \f(CIcontents\f(CI >\*(C'\fI\fR
.IX Subsection "<N: contents >"
.PP
This markup inflects its contents as a noun. That is, the markup is
replaced with \f(CW\*(C`noun(\*(Aqcontents\*(Aq)\->singular\*(C'\fR or
\&\f(CW\*(C`noun(\*(Aqcontents\*(Aq)\->plural\*(C'\fR depending on the value specified
by the most recent preceding \f(CW\*(C`<#:...>\*(C'\fR markup.
.PP
This command takes three options:
.ie n .IP """c""" 4
.el .IP "\f(CWc\fR" 4
.IX Item "c"
Cause the noun inflexion to use \f(CW\*(C`noun(\*(Aqcontents\*(Aq)\->classical\*(C'\fR:
.Sp
.Vb 5
\&    say inflect "<#:$count> <N:$target> found";
\&              # "7 maximums found"
\&              # "7 formulas found"
\&              # "7 corpuses found"
\&              # "7 brothers found"
\&
\&    say inflect "<#:$count> <Nc:$target> found";
\&              # "7 maxima found"
\&              # "7 formulae found"
\&              # "7 corpora found"
\&              # "7 brethren found"
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`c\*(C'\fR for \*(L"classical\*(R" or \*(L"cultured\*(R" or \*(L"conformatio Caesaris cascus\*(R".
.ie n .IP """p""" 4
.el .IP "\f(CWp\fR" 4
.IX Item "p"
Causes the noun to inflect to the plural, regardless of the currently
active count (i.e. regardless of the actual value specified in any
preceding \f(CW\*(C`<#:...>\*(C'\fR.
.Sp
This is sometimes useful for constructions such as:
.Sp
.Vb 4
\&    say inflect "Searching for <Np:$target>.....found $count";
\&              # "Searching for walruses...found 1"
\&              # "Searching for appendixes...found 4"
\&              # "Searching for denarii...found 12742"
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`p\*(C'\fR for \*(L"plural\*(R" or \*(L"plentiful\*(R" or \*(L"plethora\*(R".
.ie n .IP """s""" 4
.el .IP "\f(CWs\fR" 4
.IX Item "s"
Causes the noun to inflect to the singular, regardless of the currently
active count (i.e. regardless of the value in any preceding \f(CW\*(C`<#:...>\*(C'\fR.
.Sp
This is sometimes useful for constructions such as:
.Sp
.Vb 4
\&    say inflect "Searching for <#a:> <Ns:$target>.....found $count";
\&              # "Searching for a walrus...found 1"
\&              # "Searching for an appendix...found 4"
\&              # "Searching for a denarius...found 12742"
.Ve
.Sp
\&\fIMnemonic:\fR \f(CW\*(C`s\*(C'\fR for \*(L"singular\*(R" or \*(L"solitary\*(R" or \*(L"solo\*(R".
.PP
\fI\f(CI\*(C`<V: \f(CIcontents\f(CI >\*(C'\fI\fR
.IX Subsection "<V: contents >"
.PP
This markup inflects its contents as a verb. That is, the markup is
replaced with \f(CW\*(C`verb(\*(Aqcontents\*(Aq)\->singular\*(C'\fR or
\&\f(CW\*(C`verb(\*(Aqcontents\*(Aq)\->plural\*(C'\fR depending on the value specified
by the most recent preceding \f(CW\*(C`<#:...>\*(C'\fR markup.
.PP
This command has no options.
.PP
\fI\f(CI\*(C`<A: \f(CIcontents\f(CI >\*(C'\fI\fR
.IX Subsection "<A: contents >"
.PP
This markup inflects its contents as an adjective. That is, the markup
is replaced with \f(CW\*(C`adj(\*(Aqcontents\*(Aq)\->singular\*(C'\fR or
\&\f(CW\*(C`adj(\*(Aqcontents\*(Aq)\->plural\*(C'\fR depending on the value specified by the
most recent preceding \f(CW\*(C`<#:...>\*(C'\fR markup.
.PP
This command has no options.
.PP
\fILong-form markup notation\fR
.IX Subsection "Long-form markup notation"
.PP
Every command in the \f(CW\*(C`inflect()\*(C'\fR markup language is a single
uppercase letter. Every option is a single lowercase letter.
That's useful because it keeps markup relatively concise:
.PP
.Vb 1
\&    say inflect "<#anw:$count> <Nc:$target> <V:were> found";
.Ve
.PP
but it's also a problem because it makes the meaning of each
markup hard to remember six months later. So \f(CW\*(C`inflect()\*(C'\fR
also allows you to specify options with complete words, like so:
.PP
.Vb 1
\&    say inflect "<#AnNoWords:$count> <NounClassical:$target> <Verb:were> found";
.Ve
.PP
That is: \f(CW\*(C`inflect()\*(C'\fR allows the words \f(CW\*(C`Noun\*(C'\fR, \f(CW\*(C`Verb\*(C'\fR, and \f(CW\*(C`Adj\*(C'\fR as
synonyms for the commands \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`V\*(C'\fR, and \f(CW\*(C`A\*(C'\fR respectively.
.PP
And if \f(CW\*(C`inflect()\*(C'\fR encounters a markup where the options section contains
any uppercase letters, it ignores any lowercase letters within the options,
and then converts the uppercase letters to lowercase and uses those as its
options. Thus:
.PP
.Vb 1
\&    say inflect "<#AnNoWords:$count> <NounClassical:$target> <Verb:were> found";
.Ve
.PP
first maps the full command names back to the one-letter versions:
.PP
.Vb 1
\&    say inflect "<#AnNoWords:$count> <N   Classical:$target> <V   :were> found";
.Ve
.PP
then removes the lowercase letters from the options:
.PP
.Vb 1
\&    say inflect "<#A N W    :$count> <N   C        :$target> <V   :were> found";
.Ve
.PP
and finally converts what's left to lowercase:
.PP
.Vb 1
\&    say inflect "<#a n w    :$count> <N   c        :$target> <V   :were> found";
.Ve
.SS "Converting lists of words to phrases"
.IX Subsection "Converting lists of words to phrases"
When creating a list of words, commas are used between adjacent items,
except if the items contain commas, in which case semicolons are used.
But if there are less than three items, the commas/semicolons are omitted
entirely. The final item also has a conjunction (usually \*(L"and\*(R" or \*(L"or\*(R")
before it. And although it's often misleading , some people prefer to
omit the comma before that final conjunction, even when there are more
than two items.
.PP
That's complicated enough to warrant its own subroutine: \f(CW\*(C`wordlist()\*(C'\fR.
This subroutine expects a list of words, possibly with one or more hash
references containing options. It returns a string that joins the list
together in the normal English usage. For example:
.PP
.Vb 2
\&    print "You chose ", wordlist(@selected_items), "\en";
\&    # You chose barley soup, roast beef, and Yorkshire pudding
\&
\&    print "You chose ", wordlist(@selected_items, {final_sep=>""}), "\en";
\&    # You chose barley soup, roast beef and Yorkshire pudding
\&
\&    print "Please choose ", wordlist(@side_orders, {conj=>"or"}), "\en";
\&    # Please choose salad, vegetables, or ice\-cream
.Ve
.PP
The available options are:
.PP
.Vb 1
\&    Option named    Specifies                Default value
\&
\&    conj            Final conjunction        "and"
\&    sep             Inter\-item separator     "," or ";"
\&    final_sep       Final separator          value of \*(Aqsep\*(Aq option
.Ve
.SH "CONVERTING FROM LINGUA::EN::INFLECT"
.IX Header "CONVERTING FROM LINGUA::EN::INFLECT"
This module is the successor to the original Lingua::EN::Inflect module.
The following tables summarize how to convert code from the old interface
to the new.
.PP
.Vb 10
\&    Lingua::EN::Inflect subroutines         Lingua::EN::Inflexion code
\&    ====================================================================
\&    PL($word)                               # No equivalent
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PL_N($word)                             noun($word)\->plural
\&    PL_V($word)                             verb($word)\->plural
\&    PL_ADJ($word)                           adj($word)\->plural
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    NO($word)                               # No equivalent
\&    NUM($word)                              # No equivalent
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    A($word)                                noun($word)\->indefinite
\&    AN($word)                               noun($word)\->indefinite
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PL_eq($word1, $word2)                   # No equivalent
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PL_N_eq($word1, $word2)                 noun($word1) ~~ noun($word2)
\&    PL_V_eq($word1, $word2)                 verb($word1) ~~ verb($word2)
\&    PL_ADJ_eq($word1, $word2)               adj($word1) ~~ adj($word2)
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PART_PRES($word)                        verb( $word )\->pres_part
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    ORD($word)                              noun( $word )\->ordinal
\&    NUMWORDS($word)                         noun( $word )\->cardinal
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    WORDLIST(@words, \e%opts)                wordlist( @words, \e%opts)
\&
\&
\&    Lingua::EN::Inflect::inflect()          Lingua::EN::Inflexion::inflect()
\&    ========================================================================
\&    "PL($word)"                             # No equivalent
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    "PL_N($word)"                           "<N:$word>"
\&    "PL_V($word)"                           "<V:$word>"
\&    "PL_ADJ($word)"                         "<A:$word>"
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    "NUM($num)"                             "<#:$num>"
\&    "NO($word)"                             "<#n:$num>"
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    "A($word)"                              "<#a:$num> N<$word>"
\&    "AN($word)"                             "<#a:$num> N<$word>"
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    "PART_PRES($word)"                      # No equivalent
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    "ORD($word)"                            "<No:$word>"
\&    "NUMWORDS($word)"                       "<Nw:$word>"
.Ve
.SH "LINGUISTIC ABYSSES"
.IX Header "LINGUISTIC ABYSSES"
No further correspondence will be entered into on the topics of...
.ie n .SS """octopi"""
.el .SS "``octopi''"
.IX Subsection "octopi"
Yes, many people use it.
No, it isn't correct English...nor correct Latin...nor correct Greek.
Yes, there actually \fIis\fR a classical Latin precedent for the inflexion.
No, that precedent isn't relevant to English, because \*(L"octopus\*(R" didn't come from classical Latin, or even \fIvia\fR classical Latin.
Yes, this module recognizes the word and will correctly inflect it back to \*(L"octopus\*(R" in the singular.
No, the module will never inflect \*(L"octopus\*(R" to \*(L"octopi\*(R".
.ie n .SS """octopodes"""
.el .SS "``octopodes''"
.IX Subsection "octopodes"
Yes, very few people use it (and almost only ever when raging against \*(L"octopi\*(R").
No, it isn't correct English...nor was it ever used in classical Latin.
Yes, there certainly \fIis\fR a ancient Greek precedent for the inflexion.
No, that precedent isn't relevant to English, because \*(L"octopus\*(R" didn't come from ancient Greek either.
Yes, this module recognizes the word and will correctly inflect it back to \*(L"octopus\*(R" in the singular.
No, the module will never inflect \*(L"octopus\*(R" to \*(L"octopodes\*(R".
.ie n .SS """octopuses"""
.el .SS "``octopuses''"
.IX Subsection "octopuses"
For a thorough, erudite, and eminently satisfying explanation of why
it's only ever been \*(L"octopuses\*(R", I can sincerely recommend:
<http://web.archive.org/web/20170112234148/http://www.heracliteanriver.com/?p=240>
.ie n .SS """viri"" and ""virii"""
.el .SS "``viri'' and ``virii''"
.IX Subsection "viri and virii"
The noun \*(L"virus\*(R" had no plural in its original Latin (probably because
it was a mass noun). So the only plural in English is the natural one:
\&\*(L"viruses\*(R".
.PP
Nevertheless, this module will do the right thing when asked to inflect
\&\*(L"viri\*(R" and \*(L"virii\*(R" back to the singular (unless you happen to think that
the right thing would be to beat them to death with a stick).
.ie n .SS "Singular ""they"", ""them"", ""their"", and ""theirs"""
.el .SS "Singular ``they'', ``them'', ``their'', and ``theirs''"
.IX Subsection "Singular they, them, their, and theirs"
\&...were good enough for Auden, Austen, Byron, Carroll, Caxton, Chaucer,
Defoe, Dickens, Eliot, Fitzgerald, Gaskell, Kipling, Orwell, Ruskin,
Scott, Shakespeare, Shaw, Shelley, Sheridan, Spenser, Stevenson, Swift,
Thackeray, Trollope, Wells, Wharton, and Wilde...so they're good enough
for this module.
.PP
In fact, it wasn't until the 19th Century that maniacal neo-Latinizing
prescriptive grammarians started pillorying the use of gender-neutral
singular \*(L"they\*(R" \fIetc.\fR in English.
.PP
Meanwhile, real people have kept right on using it for the past two
hundred years, just as they did for the preceding five hundred.
And the \s-1OED\s0 now actually prefers \*(L"they\*(R" to \*(L"he\*(R" for gender-nonspecific
usages.
.PP
So if someone wants to complain about this module supporting\*(--and
even favouring\*(--the usage, \fIthey\fR are most welcome to write \fItheir\fR
own module as best suits \fIthem\fR.
.ie n .SS "Singular ""themself"""
.el .SS "Singular ``themself''"
.IX Subsection "Singular themself"
Despite the fact that \*(L"themself\*(R" has been in use for nearly 500 years,
and actually predates \*(L"themselves\*(R", the word is not considered
acceptable in modern English, and certainly not as a singular form.
.PP
Eventually it may garner the same general acceptance as singular \*(L"they\*(R",
\&\*(L"them\*(R", and \*(L"their\*(R"...but not yet. Although one may encounter such
gender-nonspecific constructions as:
.PP
    "Anyone might find \fBthemself\fR contemplating their own mortality."
.PP
the correct formulation is still:
.PP
    "Anyone might find \fBthemselves\fR contemplating their own mortality."
.PP
The module does recognize \*(L"themself\*(R" as a reflexive pronoun, but
converts it to the currently accepted form (\*(L"themselves\*(R") for both
singular and plural inflexions.
.ie n .SS """inflexion"""
.el .SS "``inflexion''"
.IX Subsection "inflexion"
It's exactly the same thing as \*(L"inflection\*(R".
I simply find the classical spelling more elegant.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Missing arg to %s""" 4
.el .IP "\f(CWMissing arg to %s\fR" 4
.IX Item "Missing arg to %s"
You passed an \f(CW\*(C`undef\*(C'\fR as the single argument to \f(CW\*(C`noun()\*(C'\fR, \f(CW\*(C`verb()\*(C'\fR,
or \f(CW\*(C`adj()\*(C'\fR. They require a string instead.
.ie n .IP """Can\*(Aqt coerce %s object to %s reference""" 4
.el .IP "\f(CWCan\*(Aqt coerce %s object to %s reference\fR" 4
.IX Item "Cant coerce %s object to %s reference"
Inflexion objects can convert themselves to strings, or numbers, or booleans,
or regexes, but not to references.
.Sp
You didn't accidentally write something like:
.Sp
.Vb 1
\&    $inflexion_obj\->{plural}   # Should be: $inflexion_obj\->plural
.Ve
.Sp
\&...did you?
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Lingua::EN::Inflexion has no run-time configuration files or environment
variables.
.PP
However, the module itself is largely created from two tables of
inflexions (for nouns and verbs respectively).
.SS "The \fInouns.lei\fP file"
.IX Subsection "The nouns.lei file"
All the noun inflexions that Lingua::EN::Inflexion provides are
generated from a single file: \fInouns.lei\fR.
.PP
\fIFile format\fR
.IX Subsection "File format"
.PP
The format of each entry in this file is as follows:
.PP
.Vb 1
\&    SINGULAR NOUN   =>   MODERN PLURAL FORM  |  CLASSICAL FORM
.Ve
.PP
Either the modern plural or the classical plural\*(--but not
both\*(--may be omitted. If the classical plural is omitted,
the \f(CW\*(C`|\*(C'\fR is not required (but is still allowed).
.PP
Normal Perl comments (introduced by a \f(CW\*(C`#\*(C'\fR) may also be included,
and will be ignored.
.PP
Each singular or plural form can consist of any number of words.
.PP
For example:
.PP
.Vb 5
\&    man             =>   men
\&    minimum         =>   minimums        | minima
\&    mitochondrian   =>                   | mitochondria
\&    malum in se     =>                   | mala in se
\&    mother\-in\-law   =>   mothers\-in\-law  |
.Ve
.PP
\fIInflexions of hyphenated terms\fR
.IX Subsection "Inflexions of hyphenated terms"
.PP
Terms that contain hyphens are automatically expanded to include the
non-hyphenated version of the term as well. So the final example above
also implies:
.PP
.Vb 1
\&    mother in law   =>   mothers in law  |
.Ve
.PP
However, the reverse is not true, so the second last example above
does \fInot\fR imply:
.PP
.Vb 1
\&    malum\-in\-se     =>                   | mala\-in\-se
.Ve
.PP
\fINon-suffix-based inflexions\fR
.IX Subsection "Non-suffix-based inflexions"
.PP
Terms like \*(L"mother-in-law\*(R" and \*(L"malum in se\*(R" are unusual in English, because
the component that is inflected is not the final word (as it is in terms
like \*(L"major general\*(R" and \*(L"mill pond\*(R").
.PP
\&\*(L"Mother-in-law\*(R" is a particular problem because there are an endless set
of other related terms: \*(L"father-in-law\*(R", \*(L"sister-in-law\*(R", \*(L"uncle-in-law\*(R",
\&\*(L"niece-in-law\*(R", \*(L"cousin-in-law\*(R", etc.
.PP
There are other similar patterns of non-terminal inflexion, such as
\&\*(L"passer\-by\*(R"/\*(L"hanger\-on\*(R"/\*(L"fender\-off\*(R" (which become:
\&\*(L"passers\-by\*(R"/\*(L"hangers\-on\*(R"/\*(L"fenders\-off\*(R" in the plural), or
\&\*(L"son of a gun\*(R"/\*(L"son of a bitch\*(R"/\*(L"son of a motherless goat\*(R"
(which become: \*(L"sons of guns\*(R"/\*(L"sons of bitches\*(R"/\*(L"sons of motherless goats\*(R").
.PP
To simplify specifying these kinds of inflexions, you can use three special
placeholders within any rule in the \fInouns.lei\fR file:
.PP
.Vb 1
\&   (SING)     # Any other singular word defined in the file
\&
\&   (PL)       # Any other plural word defined in the file
\&
\&   (PREP)     # Any preposition
.Ve
.PP
For example, to cover the various cases mentioned above (and many
others as well):
.PP
.Vb 2
\&        son\-of\-a\-(SING)  =>  sons\-of\-(PL)   # son\-of\-a\-gun   \-\-> sons\-of\-guns
\&                                            # son of a camel \-\-> sons of camels
\&
\&        (SING)\-(PREP)\-*  =>  (PL)\-(PREP)\-*  # mother\-in\-law  \-\-> mothers\-in\-law
\&                                            # man of peace   \-\-> men of peace
\&
\&        (SING)\-(PREP)    =>  (PL)\-(PREP)    # passer\-by      \-\-> passers\-by
\&                                            # hanger\-on      \-\-> hangers\-on
.Ve
.PP
\fISuffix-based inflexions\fR
.IX Subsection "Suffix-based inflexions"
.PP
You can specify the inflexion of a general suffix in either of
two ways:
.PP
.Vb 2
\&    *mouse  =>  *mice
\&    \-men    =>  \-mens  | \-mina
.Ve
.PP
A leading asterisk indicates that the suffix is itself a complete word,
so the \f(CW*mouse\fR specification is shorthand for:
.PP
.Vb 6
\&    mouse         =>  mice
\&    dormouse      =>  dormice
\&    flittermouse  =>  flittermice
\&    shrewmouse    =>  shrewmice
\&    titmouse      =>  titmice
\&    # etc.
.Ve
.PP
A leading hyphen indicates that the suffix is \fInot\fR itself a complete word,
so the \f(CW\*(C`\-men\*(C'\fR specification is shorthand for:
.PP
.Vb 5
\&    foramen       =>  foramens  |  foramina
\&    lumen         =>  lumens    |  lumina
\&    numen         =>  numens    |  numina
\&    stamen        =>  stamens   |  stamina
\&    # etc.
.Ve
.PP
but not for:
.PP
.Vb 1
\&    men           =>  mens      |  mina
.Ve
.PP
\fIConflicting inflexions\fR
.IX Subsection "Conflicting inflexions"
.PP
English noun inflexions are (unfortunately) not always one-to-one.
.PP
If two or more inflexions specify the same plural form, the module
always defaults to the first one to appear in the file. Hence, given:
.PP
.Vb 2
\&    base   =>  bases
\&    basis  =>  bases
.Ve
.PP
the following behaviour has been specified:
.PP
.Vb 1
\&                    \->singular    \->plural
\&
\&    noun(\*(Aqbases\*(Aq)     "base"       "bases"
.Ve
.PP
That is, it will always use the first specification for any
plural-to-singular inflexion of \*(L"bases\*(R", and so never produce \*(L"basis\*(R".
.PP
Likewise, if two or more inflexions specify the same singular form,
the first of them will be used as the module's default. For example, given:
.PP
.Vb 3
\&    octopus  =>  octopuses  |
\&    octopus  =>             |  octopi
\&    octopus  =>             |  octopodes
.Ve
.PP
then the following behaviour has been specified:
.PP
.Vb 1
\&                                 \->singular    \->plural
\&
\&    noun(\*(Aqoctopus\*(Aq)               "octopus"    "octopuses"
\&    noun(\*(Aqoctopus\*(Aq)\->classical    "octopus"    "octopuses"
.Ve
.PP
That is, the module will always use the first specification for any
singular-to-plural inflexion of \*(L"octopus\*(R" (see the preceding
discussion for an explanation of why this is the only
appropriate behaviour for this particular word.)
.PP
\fINon-indicative inflexions\fR
.IX Subsection "Non-indicative inflexions"
.PP
A small number of suffix inflexions can present problems for the
\&\f(CW\*(C`is_singular()\*(C'\fR and \f(CW\*(C`is_plural()\*(C'\fR methods of inflexion objects.
.PP
For example, the most general rule for inflecting nouns in English is:
.PP
.Vb 1
\&        \-    =>  \-s        # Form the plural by adding "\-s"
.Ve
.PP
But \f(CW\*(C`is_plural()\*(C'\fR uses the specified plural form to determine the
number of a word, by matching it against a pattern built from the
inflexion specification. So, given the previous rule, it will cause
\&\f(CW\*(C`is_plural()\*(C'\fR to identify as plural any word that matches \f(CW\*(C`/.+s/\*(C'\fR.
.PP
And that's a problem. Words like \*(L"rainbows\*(R" and \*(L"kittens\*(R" and \*(L"kisses\*(R"
are indeed plural. But words like \*(L"basis\*(R" and \*(L"atlas\*(R" and \*(L"yes\*(R" aren't.
.PP
So it's possible to specify an inflexion rule that can be used to
inflect words, but which is \fInot\fR used to identify the words'
intrinsic number. To do that, use the special marker:
\&\f(CW\*(C`<nonindicative>\*(C'\fR.
.PP
For example:
.PP
.Vb 1
\&    <nonindicative>  \-  =>  \-s
.Ve
.PP
This marker should not often be required, except for very general
inflexions. In fact, the standard \fInoun.lei\fR that ships with the
module uses it only three times within 2500 inflexions
.SS "The \fIverbs.lei\fP file"
.IX Subsection "The verbs.lei file"
The vast majority of the verb inflexions provided by Lingua::EN::Inflexion
are also autogenerated, from the file \fIverbs.lei\fR
.PP
\fIFile format\fR
.IX Subsection "File format"
.PP
Each entry in this file consists of five words on a single line,
summarizing the inflexion of one verb. The order must be:
.PP
.Vb 2
\&    PRESENT       PRESENT     SIMPLE      PRESENT         PAST
\&    SINGULAR      PLURAL       PAST      PARTICIPLE    PARTICIPLE
.Ve
.PP
For example:
.PP
.Vb 4
\&    bides         bide        bided       biding         bided
\&    bills         bill        billed      billing        billed
\&    binds         bind        bound       binding        bound
\&    bites         bite        bit         biting         bitten
.Ve
.PP
\fISuffix-based inflexions\fR
.IX Subsection "Suffix-based inflexions"
.PP
General suffix inflexions can be specified the same way as for
nouns: using either an asterisk (for complete words) or a hyphen
(for incomplete suffixes).
.PP
You can also use character classes to consolidate two or more similar
inflective patterns.
.PP
For example:
.PP
.Vb 3
\&    # Handle "underbids" and "disbelieves" as well...
\&    *bids          *bid          *bade          *bidding        *bidden
\&    *believes      *believe      *believed      *believing      *believed
\&
\&    # Handle "hisses" and "kisses"...
\&    \-sses          \-ss           \-ssed          \-ssing          \-ssed
\&
\&    # Handle "accrues" and "fetes", but not "sees"...
\&    \-[^e]es        \-[^e]e            \-[^e]ed           \-[^e]ing          \-[^e]ed
.Ve
.PP
\fIDefective verbs\fR
.IX Subsection "Defective verbs"
.PP
Entries for defective verbs still require all five columns to be
supplied. Use a single underscore to mark a column without supplying
an inflexion for that column. For example:
.PP
.Vb 3
\&    may           may           _           _          _
\&    might         might         _           _          _
\&    must          must          _           _          _
\&
\&    \-n\*(Aqt          \-n\*(Aqt          \-n\*(Aqt        _          _
\&
\&    \-[^s]s        \-[^s]         _           _          _
.Ve
.SS "Rebuilding the module"
.IX Subsection "Rebuilding the module"
The \fInoun.lei\fR file is used to autogenerate the following components of
the module:
.PP
.Vb 1
\&    lib/Lingua/EN/Inflexion/Noun.pm
\&
\&    t/noun_is_singular.t
\&    t/noun_is_plural.t
\&    t/noun_plural.t
\&    t/noun_classical_plural.t
\&    t/noun_singular.t
.Ve
.PP
If you change \fInouns.lei\fR, you can rebuild these files by running the
application \fIbin/generate_nouns\fR from your command-line. Remember to
then reinstall the Noun.pm module for your changes to take effect.
.PP
The \fIverb.lei\fR file is used to autogenerate the following components of
the module:
.PP
.Vb 1
\&    lib/Lingua/EN/Inflexion/Verb.pm
\&
\&    t/verb_is_singular.t
\&    t/verb_is_plural.t
\&    t/verb_plural.t
\&    t/verb_singular.t
\&    t/verb_past.t
\&    t/verb_pres_part.t
\&    t/verb_past_part.t
.Ve
.PP
If you change \fIverbs.lei\fR, you can rebuild these files by running the
application \fIbin/generate_verbs\fR and then reinstalling the Verb.pm module.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
The implementation of this module depends on several other modules that
are distributed with it (none of which has its own \s-1API,\s0 none of which
contains any user-servicable parts, and most of which are entirely
computer-generated).
.IP "Lingua::EN::Inflexion::Term" 4
.IX Item "Lingua::EN::Inflexion::Term"
Internals of the various methods for the three types of inflexion
objects.
.IP "Lingua::EN::Inflexion::Nouns" 4
.IX Item "Lingua::EN::Inflexion::Nouns"
Internal hash tables and regex-based suffix patterns for nouns.
Autogenerated from the file \fInouns.lei\fR.
.IP "Lingua::EN::Inflexion::Verbs" 4
.IX Item "Lingua::EN::Inflexion::Verbs"
Internal hash tables and regex-based suffix patterns for verbs.
Autogenerated from the file \fIverbs.lei\fR.
.IP "Lingua::EN::Inflexion::Indefinite" 4
.IX Item "Lingua::EN::Inflexion::Indefinite"
Internal hash tables and regex logic for working out
whether a noun takes \*(L"a\*(R" or \*(L"an\*(R".
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Not only is real English more complicated than we imagine,
it is probably more complicated than we \fIcan\fR imagine.
It is certainly more complicated than we can reasonably code.
.PP
Hence it is very likely that this module will get \fIsomething\fR
wrong...though no bugs are currently outstanding.
.PP
Please report any bugs or make feature requests to
\&\f(CW\*(C`bug\-lingua\-en\-inflexion@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2014\-2016, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1272:" 4
.IX Item "Around line 1272:"
Deleting unknown formatting code V<>
.IP "Around line 1276:" 4
.IX Item "Around line 1276:"
Deleting unknown formatting code V<>
