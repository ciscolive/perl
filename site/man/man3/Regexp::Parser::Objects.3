.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Regexp::Parser::Objects 3"
.TH Regexp::Parser::Objects 3 "2020-01-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Parser::Objects \- objects for Perl 5 regexes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains the object definitions for \fIRegexp::Parser\fR.
.SS "Inheritance"
.IX Subsection "Inheritance"
All \fIRegexp::Parser::*\fR objects inherit from
\&\fIRegexp::Parser::_\|_object_\|_\fR, the global object base class.  All
user-defined \fIMyRx::*\fR objects inherit from \fIMyRx::_\|_object_\|_\fR first,
then from the \fIRegexp::Parser::*\fR object of the same name, and finally
from \fIRegexp::Parser::_\|_object_\|_\fR.  Don't worry \*(-- if you don't define
a base class for your module's objects, or the object you create isn't
a modification of a standard object, no warnings will be issued.
.SS "The \fI_\|_object_\|_\fP Base Class"
.IX Subsection "The __object__ Base Class"
All nodes inherit from \fIRegexp::Parser::_\|_object_\|_\fR the following
methods:
.ie n .IP "my $d = $obj\->\fBdata()\fR" 4
.el .IP "my \f(CW$d\fR = \f(CW$obj\fR\->\fBdata()\fR" 4
.IX Item "my $d = $obj->data()"
The object's data.  This might be an array reference (for a 'branch'
node), another object (for a 'quant' node), or it might not exist at all
(for an 'anchor' node).
.ie n .IP "my $e = $obj\->\fBender()\fR" 4
.el .IP "my \f(CW$e\fR = \f(CW$obj\fR\->\fBender()\fR" 4
.IX Item "my $e = $obj->ender()"
The arguments to \fBobject()\fR to create the ending node for this object.
This is used by the \fBwalk()\fR method.  Typically, a capturing group's ender
is a \f(CW\*(C`close\*(C'\fR node, any other assertion's ender is a \f(CW\*(C`tail\*(C'\fR node, and a
character class's ender is an \f(CW\*(C`anyof_close\*(C'\fR node.
.ie n .IP "my $c = $obj\->\fBfamily()\fR" 4
.el .IP "my \f(CW$c\fR = \f(CW$obj\fR\->\fBfamily()\fR" 4
.IX Item "my $c = $obj->family()"
The general family of this object.  These are any of: alnum, anchor,
anyof, anyof_char, anyof_class, anyof_range, assertion, branch, close,
clump, digit, exact, flags, group, groupp, minmod, prop, open, quant, ref,
reg_any.
.ie n .IP "my $f = $obj\->\fBflags()\fR" 4
.el .IP "my \f(CW$f\fR = \f(CW$obj\fR\->\fBflags()\fR" 4
.IX Item "my $f = $obj->flags()"
The flag value for this object.  This value is a number created by \s-1OR\s0'ing
together the flags that are enabled at the time.
.ie n .IP "$obj\->\fBinsert()\fR" 4
.el .IP "\f(CW$obj\fR\->\fBinsert()\fR" 4
.IX Item "$obj->insert()"
Inserts this object into the tree.  It returns a value that says whether
or not it ended up being merged with the previous object in the tree.
.ie n .IP "my $m = $obj\->\fBmerge()\fR" 4
.el .IP "my \f(CW$m\fR = \f(CW$obj\fR\->\fBmerge()\fR" 4
.IX Item "my $m = $obj->merge()"
Merges this node with the previous one, if they are of the same type. If
it is called \fIafter\fR \f(CW$obj\fR has been added to the tree, \f(CW$obj\fR will be
removed from the tree.  Most node types don't merge.  Returns true if
the node was merged with the previous one.
.ie n .IP "my $o = $obj\->\fBomit()\fR" 4
.el .IP "my \f(CW$o\fR = \f(CW$obj\fR\->\fBomit()\fR" 4
.IX Item "my $o = $obj->omit()"
.PD 0
.ie n .IP "my $o = $obj\->omit(\s-1VALUE\s0)" 4
.el .IP "my \f(CW$o\fR = \f(CW$obj\fR\->omit(\s-1VALUE\s0)" 4
.IX Item "my $o = $obj->omit(VALUE)"
.PD
Whether this node is omitted from the parse tree.  Certain objects
do not need to appear in the tree, but are needed when inspecting
the parsing, or walking the tree.
.Sp
You can also set this attribute by passing a value.
.ie n .IP "my $q = $obj\->\fBqr()\fR" 4
.el .IP "my \f(CW$q\fR = \f(CW$obj\fR\->\fBqr()\fR" 4
.IX Item "my $q = $obj->qr()"
The regex representation of this object.  It includes the regex
representation of any children of the object.
.ie n .IP "my $r = $obj\->\fBraw()\fR" 4
.el .IP "my \f(CW$r\fR = \f(CW$obj\fR\->\fBraw()\fR" 4
.IX Item "my $r = $obj->raw()"
The raw representation of this object.  It does not look at the
children of the object, just itself.  This is used primarily when
inspecting the parsing of the regex.
.ie n .IP "my $t = $obj\->\fBtype()\fR" 4
.el .IP "my \f(CW$t\fR = \f(CW$obj\fR\->\fBtype()\fR" 4
.IX Item "my $t = $obj->type()"
The specific type of this object.  See the object's documentation for
possible values for its type.
.ie n .IP "my $v = $obj\->\fBvisual()\fR" 4
.el .IP "my \f(CW$v\fR = \f(CW$obj\fR\->\fBvisual()\fR" 4
.IX Item "my $v = $obj->visual()"
The visual representation of this object.  It includes the visual
representation of any children of the object.
.ie n .IP "$obj\->\fBwalk()\fR" 4
.el .IP "\f(CW$obj\fR\->\fBwalk()\fR" 4
.IX Item "$obj->walk()"
\&\*(L"Walks\*(R" the object.  This is used to dive into the node's children
when using a walker (see \*(L"Walking the Tree\*(R" in Regexp::Parser).
.PP
Objects may override these methods (as objects often do).
.PP
\fIUsing \fI\s-1NEXT::\s0\fI instead of \fI\s-1SUPER::\s0\fI\fR
.IX Subsection "Using NEXT:: instead of SUPER::"
.PP
You can't use \f(CW\*(C`$obj\->SUPER::method()\*(C'\fR inside the \fI_\|_object_\|_\fR class,
because \fI_\|_object_\|_\fR doesn't inherit from anywhere.  You want to go along
the \fIobject\fR's inheritance tree.  Use Damian Conway's \fI\s-1NEXT\s0\fR module
instead.  This module is standard with Perl 5.8.
.SS "Object Attributes"
.IX Subsection "Object Attributes"
All objects share the following attributes (accessible via
\&\f(CW\*(C`$obj\->{...}\*(C'\fR):
.IP "rx" 4
.IX Item "rx"
The parser object with which it was created.
.IP "flags" 4
.IX Item "flags"
The flags for the object.
.PP
The following attributes may also be set:
.IP "branch" 4
.IX Item "branch"
Whether this object has branches (like \f(CW\*(C`|\*(C'\fR).
.IP "family" 4
.IX Item "family"
The general family of this object.
.IP "data" 4
.IX Item "data"
The data or children of this object.
.IP "dir" 4
.IX Item "dir"
The direction of this object (for look\-ahead/behind assertions).  If
less than 0, it is behind; otherwise, it is ahead.
.IP "down" 4
.IX Item "down"
Whether this object creates a deeper scope (like an \s-1OPEN\s0).
.IP "ifthen" 4
.IX Item "ifthen"
Whether this object has a true/false branch (like the \f(CW\*(C`(?(...)T|F)\*(C'\fR
assertion).
.IP "max" 4
.IX Item "max"
The maximum repetition count of this object (for quantifiers).
.IP "min" 4
.IX Item "min"
The minimum repetition count of this object (for quantifiers).
.IP "neg" 4
.IX Item "neg"
Whether this object is negated (like a look-ahead or a character class).
.IP "nparen" 4
.IX Item "nparen"
The capture group related to this object (like for \s-1OPEN\s0 and back
references).
.IP "off" 4
.IX Item "off"
The flags specifically turned off for this object (for flag assertions
and \f(CW\*(C`(?:...)\*(C'\fR).
.IP "omit" 4
.IX Item "omit"
Whether this object is omitted from the actual tree (like a \s-1CLOSE\s0).
.IP "on" 4
.IX Item "on"
The flags specifically turned on for this object (for flag assertions
and \f(CW\*(C`(?:...)\*(C'\fR).
.IP "raw" 4
.IX Item "raw"
The raw representation of this object.
.IP "type" 4
.IX Item "type"
The specific type of this object.
.IP "up" 4
.IX Item "up"
Whether this object goes into a shallower scope (like a \s-1CLOSE\s0).
.IP "vis" 4
.IX Item "vis"
The visual representation of this object.
.IP "zerolen" 4
.IX Item "zerolen"
Whether this object does is zero-width (like an anchor).
.PP
If there is a method with the name of one of these attributes, it is
\&\fIimperative\fR you use the method to access the attribute when \fIoutside\fR
the class, and it's a good idea to do so \fIinside\fR the class as well.
.SH "OBJECTS"
.IX Header "OBJECTS"
All objects are prefixed with \fIRegexp::Parser::\fR, but that is omitted
here for brevity.  The headings are object \fIclasses\fR.  The field
\&\*(L"family\*(R" represents the general category into which that object falls.
.PP
This is very sparse.  Future versions will have more complete
documentation.  For now, read the source (!).
.SS "bol"
.IX Subsection "bol"
Family: anchor
.PP
Types: bol (\f(CW\*(C`^\*(C'\fR), sbol (\f(CW\*(C`^\*(C'\fR with \f(CW\*(C`/s\*(C'\fR on, \f(CW\*(C`\eA\*(C'\fR), mbol (\f(CW\*(C`^\*(C'\fR with
\&\f(CW\*(C`/m\*(C'\fR on)
.SS "bound"
.IX Subsection "bound"
Family: anchor
.PP
Types: bound (\f(CW\*(C`\eb\*(C'\fR), nbound (\f(CW\*(C`\eB\*(C'\fR)
.PP
Neg: 1 if negated
.SS "gpos"
.IX Subsection "gpos"
Family: anchor
.PP
Types: gpos (\f(CW\*(C`\eG\*(C'\fR)
.SS "eol"
.IX Subsection "eol"
Family: anchor
.PP
Types: eol (\f(CW\*(C`$\*(C'\fR), seol (\f(CW\*(C`$\*(C'\fR with \f(CW\*(C`/s\*(C'\fR on, \f(CW\*(C`\eZ\*(C'\fR), meol (\f(CW\*(C`$\*(C'\fR with
\&\f(CW\*(C`/m\*(C'\fR on), eos (\f(CW\*(C`\ez\*(C'\fR)
.SS "reg_any"
.IX Subsection "reg_any"
Family: reg_any
.PP
Types: reg_any (\f(CW\*(C`.\*(C'\fR), sany (\f(CW\*(C`.\*(C'\fR with \f(CW\*(C`/s\*(C'\fR on), cany (\f(CW\*(C`\eC\*(C'\fR)
.SS "alnum"
.IX Subsection "alnum"
Family: alnum
.PP
Types: alnum (\f(CW\*(C`\ew\*(C'\fR), nalnum (\f(CW\*(C`\eW\*(C'\fR)
.PP
Neg: 1 if negated
.SS "space"
.IX Subsection "space"
Family: space
.PP
Types: space (\f(CW\*(C`\es\*(C'\fR), nspace (\f(CW\*(C`\eS\*(C'\fR)
.PP
Neg: 1 if negated
.SS "digit"
.IX Subsection "digit"
Family: digit
.PP
Types: digit (\f(CW\*(C`\ed\*(C'\fR), ndigit (\f(CW\*(C`\eD\*(C'\fR)
.PP
Neg: 1 if negated
.SS "anyof"
.IX Subsection "anyof"
Family: anyof
.PP
Types: anyof (\f(CW\*(C`[\*(C'\fR)
.PP
Data: array reference of \fIanyof_char\fR, \fIanyof_range\fR, \fIanyof_class\fR
.PP
Neg: 1 if negated
.PP
Ender: \fIanyof_close\fR
.SS "anyof_char"
.IX Subsection "anyof_char"
Family: anyof_char
.PP
Types: anyof_char (\f(CW\*(C`X\*(C'\fR)
.PP
Data: actual character
.SS "anyof_range"
.IX Subsection "anyof_range"
Family: anyof_range
.PP
Types: anyof_range (\f(CW\*(C`X\-Y\*(C'\fR)
.PP
Data: array reference of lower and upper bounds, both \fIanyof_char\fR
.SS "anyof_class"
.IX Subsection "anyof_class"
Family: anyof_class
.PP
Types: via \f(CW\*(C`[:NAME:]\*(C'\fR, \f(CW\*(C`[:^NAME:]\*(C'\fR, \f(CW\*(C`\ep{NAME}\*(C'\fR, \f(CW\*(C`\eP{NAME}\*(C'\fR: alnum
(\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR), alpha, ascii, cntrl, digit (\f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR), graph, lower,
print, punct, space (\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR), upper, word, xdigit; others are
possible (Unicode properties and user-defined \s-1POSIX\s0 classes)
.PP
Data: '\s-1POSIX\s0' if \f(CW\*(C`[:NAME:]\*(C'\fR, \f(CW\*(C`[^:NAME:]\*(C'\fR (or other \s-1POSIX\s0 notations, like
\&\f(CW\*(C`[=NAME=]\*(C'\fR and \f(CW\*(C`[.NAME.]\*(C'\fR); otherwise, reference to \fIalnum\fR, \fIdigit\fR,
\&\fIspace\fR, or \fIprop\fR object
.PP
Neg: 1 if negated
.SS "anyof_close"
.IX Subsection "anyof_close"
Family: close
.PP
Types: anyof_close (\f(CW\*(C`]\*(C'\fR when in \f(CW\*(C`[...\*(C'\fR)
.PP
Omitted
.SS "prop"
.IX Subsection "prop"
Family: prop
.PP
Types: name of property (\f(CW\*(C`\ep{NAME}\*(C'\fR, \f(CW\*(C`\eP{NAME}\*(C'\fR); any Unicode property
defined by Perl or elsewhere
.PP
Neg: 1 if negated
.SS "clump"
.IX Subsection "clump"
Family: clump
.PP
Types: clump (\f(CW\*(C`\eX\*(C'\fR)
.SS "branch"
.IX Subsection "branch"
Family: branch
.PP
Types: branch (\f(CW\*(C`|\*(C'\fR)
.PP
Data: array reference of array references, each representing one
alternation, holding any number of objects
.PP
Branched
.SS "exact"
.IX Subsection "exact"
Family: exact
.PP
Types: exact (\f(CW\*(C`abc\*(C'\fR), exactf (\f(CW\*(C`abc\*(C'\fR with \f(CW\*(C`/i\*(C'\fR on)
.PP
Data: array reference of actual characters
.SS "quant"
.IX Subsection "quant"
Family: quant
.PP
Types: star (\f(CW\*(C`*\*(C'\fR), plus (\f(CW\*(C`+\*(C'\fR), curly (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`{n}\*(C'\fR, \f(CW\*(C`{n,}\*(C'\fR, \f(CW\*(C`{n,m}\*(C'\fR)
.PP
Data: one object
.SS "group"
.IX Subsection "group"
Family: group
.PP
Types: group (\f(CW\*(C`(?:\*(C'\fR, \f(CW\*(C`(?i\-s:\*(C'\fR)
.PP
Data: array reference of any number of objects
.PP
Ender: \fItail\fR
.SS "open"
.IX Subsection "open"
Family: open
.PP
Types: open1, open2 ... openN (\f(CW\*(C`(\*(C'\fR)
.PP
Data: array reference of any number of objects
.PP
Ender: \fIclose\fR
.SS "close"
.IX Subsection "close"
Family: close
.PP
Types: close1, close2 ... closeN (\f(CW\*(C`)\*(C'\fR when in \f(CW\*(C`(...\*(C'\fR)
.PP
Omitted
.SS "tail"
.IX Subsection "tail"
Family: close
.PP
Types: tail (\f(CW\*(C`)\*(C'\fR when not in \f(CW\*(C`(...\*(C'\fR)
.PP
Omitted
.SS "ref"
.IX Subsection "ref"
Family: ref
.PP
Types: ref1, ref2 .. refN (\f(CW\*(C`\e1\*(C'\fR, \f(CW\*(C`\e2\*(C'\fR, etc.); reff1, reff2 .. reffN
(\f(CW\*(C`\e1\*(C'\fR, \f(CW\*(C`\e2\*(C'\fR, etc. with \f(CW\*(C`/i\*(C'\fR on)
.SS "ifmatch"
.IX Subsection "ifmatch"
Family: assertion
.PP
Types: ifmatch (\f(CW\*(C`(?=)\*(C'\fR, \f(CW\*(C`(?<=\*(C'\fR)
.PP
Data: array reference of any number of objects
.PP
Dir: \-1 if look-behind, 1 if look-ahead
.PP
Ender: tail
.SS "unlessm"
.IX Subsection "unlessm"
Family: assertion
.PP
Types: unlessm (\f(CW\*(C`(?!\*(C'\fR, \f(CW\*(C`(?<!\*(C'\fR)
.PP
Data: array reference of any number of objects
.PP
Dir: \-1 if look-behind, 1 if look-ahead
.PP
Ender: tail
.SS "suspend"
.IX Subsection "suspend"
Family: assertion
.PP
Types: suspend (\f(CW\*(C`(?>\*(C'\fR)
.PP
Data: array reference of any number of objects
.PP
Ender: tail
.SS "ifthen"
.IX Subsection "ifthen"
Family: assertion
.PP
Types: ifthen (\f(CW\*(C`(?(\*(C'\fR)
.PP
Data: array reference of two objects; first: \fIifmatch\fR, \fIunlessm\fR,
\&\fIeval\fR, \fIgroupp\fR; second: \fIbranch\fR
.PP
Ender: tail
.SS "groupp"
.IX Subsection "groupp"
Family: groupp
.PP
Types: groupp1, groupp2 .. grouppN (\f(CW1\fR, \f(CW2\fR, etc. when in \f(CW\*(C`(?(\*(C'\fR)
.SS "eval"
.IX Subsection "eval"
Family: assertion
.PP
Types: eval (\f(CW\*(C`(?{\*(C'\fR)
.PP
Data: string with contents of assertion
.SS "logical"
.IX Subsection "logical"
Family: assertion
.PP
Types: logical (\f(CW\*(C`(??{\*(C'\fR)
.PP
Data: string with contents of assertion
.SS "flags"
.IX Subsection "flags"
Family: flags
.PP
Types: flags (\f(CW\*(C`(?i\-s)\*(C'\fR)
.SS "minmod"
.IX Subsection "minmod"
Family: minmod
.PP
Types: minmod (\f(CW\*(C`?\*(C'\fR after \fIquant\fR)
.PP
Data: an object in the \fIquant\fR family
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Parser, Regexp::Parser::Handlers.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeff \f(CW\*(C`japhy\*(C'\fR Pinyan, \fIjaphy@perlmonk.org\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Jeff Pinyan \fIjaphy@perlmonk.org\fR. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
