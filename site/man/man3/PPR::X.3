.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PPR::X 3"
.TH PPR::X 3 "2020-06-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPR::X \- Pattern\-based Perl Recognizer
.SH "VERSION"
.IX Header "VERSION"
This document describes \s-1PPR::X\s0 version 0.000027
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use PPR::X;
\&
\&    # Define a regex that will match an entire Perl document...
\&    my $perl_document = qr{
\&
\&        # What to match            # Install the (?&PerlDocument) rule
\&        (?&PerlEntireDocument)     $PPR::X::GRAMMAR
\&
\&    }x;
\&
\&
\&    # Define a regex that will match a single Perl block...
\&    my $perl_block = qr{
\&
\&        # What to match...         # Install the (?&PerlBlock) rule...
\&        (?&PerlBlock)              $PPR::X::GRAMMAR
\&    }x;
\&
\&
\&    # Define a regex that will match a simple Perl extension...
\&    my $perl_coroutine = qr{
\&
\&        # What to match...
\&        coro                                           (?&PerlOWS)
\&        (?<coro_name>  (?&PerlQualifiedIdentifier)  )  (?&PerlOWS)
\&        (?<coro_code>  (?&PerlBlock)                )
\&
\&        # Install the necessary subrules...
\&        $PPR::X::GRAMMAR
\&    }x;
\&
\&
\&    # Define a regex that will match an integrated Perl extension...
\&    my $perl_with_classes = qr{
\&
\&        # What to match...
\&        \eA
\&            (?&PerlOWS)       # Optional whitespace (including comments)
\&            (?&PerlDocument)  # A full Perl document
\&            (?&PerlOWS)       # More optional whitespace
\&        \eZ
\&
\&        # Add a \*(Aqclass\*(Aq keyword into the syntax that PPR::X understands...
\&        (?(DEFINE)
\&            (?<PerlKeyword>
\&
\&                    class                              (?&PerlOWS)
\&                    (?&PerlQualifiedIdentifier)        (?&PerlOWS)
\&                (?: is (?&PerlNWS) (?&PerlIdentifier)  (?&PerlOWS) )*+
\&                    (?&PerlBlock)
\&            )
\&
\&            (?<kw_balanced_parens>
\&                \e( (?: [^()]++ | (?&kw_balanced_parens) )*+ \e)
\&            )
\&        )
\&
\&        # Install the necessary standard subrules...
\&        $PPR::X::GRAMMAR
\&    }x;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1PPR::X\s0 module provides a single regular expression that defines a set
of independent subpatterns suitable for matching entire Perl documents,
as well as a wide range of individual syntactic components of Perl
(i.e. statements, expressions, control blocks, variables, etc.)
.PP
The regex does not \*(L"parse\*(R" Perl (that is, it does not build a syntax
tree, like the \s-1PPI\s0 module does). Instead it simply \*(L"recognizes\*(R" standard
Perl constructs, or new syntaxes composed from Perl constructs.
.PP
Its features and capabilities therefore complement those of the \s-1PPI\s0
module, rather than replacing them. See \*(L"Comparison with \s-1PPI\*(R"\s0.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Importing and using the Perl grammar regex"
.IX Subsection "Importing and using the Perl grammar regex"
The \s-1PPR::X\s0 module exports no subroutines or variables,
and provides no methods. Instead, it defines a single
package variable, \f(CW$PPR::X::GRAMMAR\fR, which can be
interpolated into regexes to add rules that permit
Perl constructs to be parsed:
.PP
.Vb 1
\&    $source_code =~ m{ (?&PerlEntireDocument)  $PPR::X::GRAMMAR }x;
.Ve
.PP
Note that all the examples shown so far have interpolated this \*(L"grammar
variable\*(R" at the end of the regular expression. This placement is
desirable, but not necessary. Both of the following work identically:
.PP
.Vb 1
\&    $source_code =~ m{ (?&PerlEntireDocument)   $PPR::X::GRAMMAR }x;
\&
\&    $source_code =~ m{ $PPR::X::GRAMMAR   (?&PerlEntireDocument) }x;
.Ve
.PP
However, if the grammar is to be extended,
then the extensions must be specified \fB\f(BIbefore\fB\fR the base grammar
(i.e. before the interpolation of \f(CW$PPR::X::GRAMMAR\fR). Placing the grammar
variable at the end of a regex ensures that will be the case, and has
the added advantage of \*(L"front-loading\*(R" the regex with the most important
information: what is actually going to be matched.
.PP
Note too that, because the \s-1PPR::X\s0 grammar internally uses capture groups,
placing \f(CW$PPR::X::GRAMMAR\fR anywhere other than the very end of your regex
may change the numbering of any explicit capture groups in your regex.
For complete safety, regexes that use the \s-1PPR::X\s0 grammar should probably
use named captures, instead of numbered captures.
.SS "Error reporting"
.IX Subsection "Error reporting"
Regex-based parsing is all-or-nothing: either your regex matches
(and returns any captures you requested), or it fails to match
(and returns nothing).
.PP
This can make it difficult to detect \fIwhy\fR a PPR::X\-based match failed;
to work out what the \*(L"bad source code\*(R" was that prevented your regex
from matching.
.PP
So the module provides a special variable that attempts to detect the
source code that prevented any call to the \f(CW\*(C`(?&PerlStatement)\*(C'\fR subpattern
from matching. That variable is: \f(CW$PPR::X::ERROR\fR
.PP
\&\f(CW$PPR::X::ERROR\fR is only set if it is undefined at the point where an
error is detected, and will only be set to the first such error that
is encountered during parsing.
.PP
Note that errors are only detected when matching context-sensitive components
(for example in the middle of a \f(CW\*(C`(?&PerlStatement), as part of a
\&\f(CW\*(C`(?&PerlContextualRegex)\*(C'\f(CW, or at the end of a \f(CW\*(C`(?&PerlEntireDocument\*(C'\f(CW)\*(C'\fR.
Errors, especially errors at the end of otherwise valid code, will often
not be detected in context-free components (for example, at the end of a
\&\f(CW\*(C`(?&PerlStatementSequence), as part of a \f(CW\*(C`(?&PerlRegex)\*(C'\f(CW, or at the
end of a \f(CW\*(C`(?&PerlDocument\*(C'\f(CW)\*(C'\fR.
.PP
A common mistake in this area is to attempt to match an entire Perl document
using:
.PP
.Vb 1
\&    m{ \eA (?&PerlDocument) \eZ   $PPR::X::GRAMMAR }x
.Ve
.PP
instead of:
.PP
.Vb 1
\&    m{ (?&PerlEntireDocument)   $PPR::X::GRAMMAR }x
.Ve
.PP
Only the second approach will be able to successfully detect an unclosed
curly bracket at the end of the document.
.PP
\fI\f(CI\*(C`PPR_X::ERROR\*(C'\fI interface\fR
.IX Subsection "PPR_X::ERROR interface"
.PP
If it is set, \f(CW$PPR::X::ERROR\fR will contain an object of type \s-1PPR::X::ERROR,\s0
with the following methods:
.ie n .IP """$PPR::X::ERROR\->origin($line, $file)""" 4
.el .IP "\f(CW$PPR::X::ERROR\->origin($line, $file)\fR" 4
.IX Item "$PPR::X::ERROR->origin($line, $file)"
Returns a clone of the \s-1PPR::X::ERROR\s0 object that now believes that the
source code parsing failure it is reporting occurred in a code fragment
starting at the specified line and file. If the second argument is
omitted, the file name is not reported in any diagnostic.
.ie n .IP """$PPR::X::ERROR\->source()""" 4
.el .IP "\f(CW$PPR::X::ERROR\->source()\fR" 4
.IX Item "$PPR::X::ERROR->source()"
Returns a string containing the specific source code that could not be
parsed as a Perl statement.
.ie n .IP """$PPR::X::ERROR\->prefix()""" 4
.el .IP "\f(CW$PPR::X::ERROR\->prefix()\fR" 4
.IX Item "$PPR::X::ERROR->prefix()"
Returns a string containing all the source code preceding the
code that could not be parsed. That is: the valid code that is
the preceding context of the unparsable code.
.ie n .IP """$PPR::X::ERROR\->line( $opt_offset )""" 4
.el .IP "\f(CW$PPR::X::ERROR\->line( $opt_offset )\fR" 4
.IX Item "$PPR::X::ERROR->line( $opt_offset )"
Returns an integer which is the line number at which the unparsable
code was encountered. If the optional \*(L"offset\*(R" argument is provided,
it will be added to the line number returned. Note that the offset
is ignored if the \s-1PPR::X::ERROR\s0 object originates from a prior call to
\&\f(CW\*(C`$PPR::X::ERROR\->origin\*(C'\fR (because in that case you will have already
specified the correct offset).
.ie n .IP """$PPR::X::ERROR\->diagnostic()""" 4
.el .IP "\f(CW$PPR::X::ERROR\->diagnostic()\fR" 4
.IX Item "$PPR::X::ERROR->diagnostic()"
Returns a string containing the diagnostic that would be returned
by \f(CW\*(C`perl \-c\*(C'\fR if the source code were compiled.
.Sp
\&\fB\f(BIWarning:\fB\fR The diagnostic is obtained by partially eval'ing
the source code. This means that run-time code will not be executed,
but \f(CW\*(C`BEGIN\*(C'\fR and \f(CW\*(C`CHECK\*(C'\fR blocks will run. Do \fB\f(BInot\fB\fR call this method
if the source code that created this error might also have non-trivial
compile-time side-effects.
.PP
A typical use might therefore be:
.PP
.Vb 2
\&    # Make sure it\*(Aqs undefined, and will only be locally modified...
\&    local $PPR::X::ERROR;
\&
\&    # Process the matched block...
\&    if ($source_code =~ m{ (?<Block> (?&PerlBlock) )  $PPR::X::GRAMMAR }x) {
\&        process( $+{Block} );
\&    }
\&
\&    # Or report the offending code that stopped it being a valid block...
\&    else {
\&        die "Invalid Perl block: " . $PPR::X::ERROR\->source . "\en",
\&            $PPR::X::ERROR\->origin($linenum, $filename)\->diagnostic . "\en";
\&    }
.Ve
.ie n .SS "Decommenting code with ""PPR_X::decomment()"""
.el .SS "Decommenting code with \f(CWPPR_X::decomment()\fP"
.IX Subsection "Decommenting code with PPR_X::decomment()"
The module provides (but does not export) a \f(CW\*(C`decomment()\*(C'\fR
subroutine that can remove any comments and/or \s-1POD\s0 from source code.
.PP
It takes a single argument: a string containing the course code.
It returns a single value: a string containing the decommented source code.
.PP
For example:
.PP
.Vb 1
\&    $decommented_code = PPR::X::decomment( $commented_code );
.Ve
.PP
The subroutine will fail if the argument wasn't valid Perl code,
in which case it returns \f(CW\*(C`undef\*(C'\fR and sets \f(CW$PPR::X::ERROR\fR to indicate
where the invalid source code was encountered.
.PP
Note that, due to separate bugs in the regex engine in Perl 5.14 and
5.20, the \f(CW\*(C`decomment()\*(C'\fR subroutine is not available when running under
these releases.
.SS "Examples"
.IX Subsection "Examples"
\&\fINote:\fR In each of the following examples, the subroutine \f(CW\*(C`slurp()\*(C'\fR is
used to acquire the source code from a file whose name is passed as its
argument. The \f(CW\*(C`slurp()\*(C'\fR subroutine is just:
.PP
.Vb 1
\&    sub slurp { local (*ARGV, $/); @ARGV = shift; readline; }
.Ve
.PP
or, for the less twisty-minded:
.PP
.Vb 6
\&    sub slurp {
\&        my ($filename) = @_;
\&        open my $filehandle, \*(Aq<\*(Aq, $filename or die $!;
\&        local $/;
\&        return readline($filehandle);
\&    }
.Ve
.PP
\fIValidating source code\fR
.IX Subsection "Validating source code"
.PP
.Vb 7
\&  # "Valid" if source code matches a Perl document under the Perl grammar
\&  printf(
\&      "$filename %s a valid Perl file\en",
\&      slurp($filename) =~ m{ (?&PerlEntireDocument)  $PPR::X::GRAMMAR }x
\&          ? "is"
\&          : "is not"
\&  );
.Ve
.PP
\fICounting statements\fR
.IX Subsection "Counting statements"
.PP
.Vb 11
\&  printf(                                        # Output
\&      "$filename contains %d statements\en",      # a report of
\&      scalar                                     # the count of
\&          grep {defined}                         # defined matches
\&              slurp($filename)                   # from the source code,
\&                  =~ m{
\&                        \eG (?&PerlOWS)           # skipping whitespace
\&                           ((?&PerlStatement))   # and keeping statements,
\&                        $PPR::X::GRAMMAR            # using the Perl grammar
\&                      }gcx;                      # incrementally
\&  );
.Ve
.PP
\fIStripping comments and \s-1POD\s0 from source code\fR
.IX Subsection "Stripping comments and POD from source code"
.PP
.Vb 3
\&  my $source = slurp($filename);                    # Get the source
\&  $source =~ s{ (?&PerlNWS)  $PPR::X::GRAMMAR }{ }gx;  # Compact whitespace
\&  print $source;                                    # Print the result
.Ve
.PP
\fIStripping comments and \s-1POD\s0 from source code (in Perl v5.14 or later)\fR
.IX Subsection "Stripping comments and POD from source code (in Perl v5.14 or later)"
.PP
.Vb 2
\&  # Print  the source code,  having compacted whitespace...
\&    print  slurp($filename)  =~ s{ (?&PerlNWS)  $PPR::X::GRAMMAR }{ }gxr;
.Ve
.PP
\fIStripping everything \f(CI\*(C`except\*(C'\fI comments and \s-1POD\s0 from source code\fR
.IX Subsection "Stripping everything except comments and POD from source code"
.PP
.Vb 7
\&  say                                         # Output
\&      grep {defined}                          # defined matches
\&          slurp($filename)                    # from the source code,
\&              =~ m{ \eG ((?&PerlOWS))          # keeping whitespace,
\&                       (?&PerlStatement)?     # skipping statements,
\&                    $PPR::X::GRAMMAR             # using the Perl grammar
\&                  }gcx;                       # incrementally
.Ve
.SS "Available rules"
.IX Subsection "Available rules"
Interpolating \f(CW$PPR::X::GRAMMAR\fR in a regex makes all of the following
rules available within that regex.
.PP
Note that other rules not listed here may also be added, but these are
all considered strictly internal to the \s-1PPR::X\s0 module and are not
guaranteed to continue to exist in future releases. All such
\&\*(L"internal-use-only\*(R" rules have names that start with \f(CW\*(C`PPR_X_\*(C'\fR...
.PP
\fI\f(CI\*(C`(?&PerlDocument)\*(C'\fI\fR
.IX Subsection "(?&PerlDocument)"
.PP
Matches a valid Perl document, including leading or trailing
whitespace, comments, and any final \f(CW\*(C`_\|_DATA_\|_\*(C'\fR or \f(CW\*(C`_\|_END_\|_\*(C'\fR section.
.PP
This rule is context-free, so it can be embedded in a larger regex.
For example, to match an embedded chunk of Perl code, delimited by
\&\f(CW\*(C`<<<\*(C'\fR...\f(CW\*(C`>>>\*(C'\fR:
.PP
.Vb 1
\&    $src = m{ <<< (?&PerlDocument) >>>   $PPR::X::GRAMMAR }x;
.Ve
.PP
\fI\f(CI\*(C`(?&PerlEntireDocument)\*(C'\fI\fR
.IX Subsection "(?&PerlEntireDocument)"
.PP
Matches an entire valid Perl document, including leading or trailing
whitespace, comments, and any final \f(CW\*(C`_\|_DATA_\|_\*(C'\fR or \f(CW\*(C`_\|_END_\|_\*(C'\fR section.
.PP
This rule is \fInot\fR context-free. It has an internal \f(CW\*(C`\eA\*(C'\fR at the beginning
and \f(CW\*(C`\eZ\*(C'\fR at the end, so a regex containing \f(CW\*(C`(?&PerlEntireDocument)\*(C'\fR
will only match if:
.IP "(a)" 4
.IX Item "(a)"
the \f(CW\*(C`(?&PerlEntireDocument)\*(C'\fR is the sole top-level element of the regex
(or, at least the sole element of a single top-level \f(CW\*(C`|\*(C'\fR\-branch of the regex),
.IP "\fB\f(BIand\fB\fR" 4
.IX Item "and"
.PD 0
.IP "(b)" 4
.IX Item "(b)"
.PD
the entire string being matched contains only a single valid Perl document.
.PP
In general, if you want to check that a string consists entirely of
a single valid sequence of Perl code, use:
.PP
.Vb 1
\&    $str =~ m{ (?&PerlEntireDocument)  $PPR::X::GRAMMAR }
.Ve
.PP
If you want to check that a string \fIcontains\fR at least one valid sequence
of Perl code at some point, possibly embedded in other text, use:
.PP
.Vb 1
\&    $str =~ m{ (?&PerlDocument)  $PPR::X::GRAMMAR }
.Ve
.PP
\fI\f(CI\*(C`(?&PerlStatementSequence)\*(C'\fI\fR
.IX Subsection "(?&PerlStatementSequence)"
.PP
Matches zero-or-more valid Perl statements, separated by optional
\&\s-1POD\s0 sequences.
.PP
\fI\f(CI\*(C`(?&PerlStatement)\*(C'\fI\fR
.IX Subsection "(?&PerlStatement)"
.PP
Matches a single valid Perl statement, including: control structures;
\&\f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, \f(CW\*(C`END\*(C'\fR, \f(CW\*(C`DESTROY\*(C'\fR, or
\&\f(CW\*(C`AUTOLOAD\*(C'\fR blocks; variable declarations, \f(CW\*(C`use\*(C'\fR statements, etc.
.PP
\fI\f(CI\*(C`(?&PerlExpression)\*(C'\fI\fR
.IX Subsection "(?&PerlExpression)"
.PP
Matches a single valid Perl expression involving operators of any
precedence, but not any kind of block (i.e. not control structures,
\&\f(CW\*(C`BEGIN\*(C'\fR blocks, etc.) nor any trailing statement modifier (e.g.
not a postfix \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR, or \f(CW\*(C`for\*(C'\fR).
.PP
\fI\f(CI\*(C`(?&PerlLowPrecedenceNotExpression)\*(C'\fI\fR
.IX Subsection "(?&PerlLowPrecedenceNotExpression)"
.PP
Matches an expression at the precedence of the \f(CW\*(C`not\*(C'\fR operator.
That is, a single valid Perl expression that involves operators above
the precedence of \f(CW\*(C`and\*(C'\fR.
.PP
\fI\f(CI\*(C`(?&PerlAssignment)\*(C'\fI\fR
.IX Subsection "(?&PerlAssignment)"
.PP
Matches an assignment expression.
That is, a single valid Perl expression involving operators above the
precedence of comma (\f(CW\*(C`,\*(C'\fR or \f(CW\*(C`=>\*(C'\fR).
.PP
\fI\f(CI\*(C`(?&PerlConditionalExpression)\*(C'\fI or \f(CI\*(C`(?&PerlScalarExpression)\*(C'\fI\fR
.IX Subsection "(?&PerlConditionalExpression) or (?&PerlScalarExpression)"
.PP
Matches a conditional expression that uses the \f(CW\*(C`?\*(C'\fR...\f(CW\*(C`:\*(C'\fR ternary operator.
That is, a single valid Perl expression involving operators above the
precedence of assignment.
.PP
The alterative name comes from the fact that anything matching this rule
is what most people think of as a single element of a comma-separated list.
.PP
\fI\f(CI\*(C`(?&PerlBinaryExpression)\*(C'\fI\fR
.IX Subsection "(?&PerlBinaryExpression)"
.PP
Matches an expression that uses any high-precedence binary operators.
That is, a single valid Perl expression involving operators above the
precedence of the ternary operator.
.PP
\fI\f(CI\*(C`(?&PerlPrefixPostfixTerm)\*(C'\fI\fR
.IX Subsection "(?&PerlPrefixPostfixTerm)"
.PP
Matches a term with optional prefix and/or postfix unary operators
and/or a trailing sequence of \f(CW\*(C`\->\*(C'\fR dereferences.
That is, a single valid Perl expression involving operators above the
precedence of exponentiation (\f(CW\*(C`**\*(C'\fR).
.PP
\fI\f(CI\*(C`(?&PerlTerm)\*(C'\fI\fR
.IX Subsection "(?&PerlTerm)"
.PP
Matches a simple high-precedence term within a Perl expression.
That is: a subroutine or builtin function call; a variable declaration;
a variable or typeglob lookup; an anonymous array, hash, or subroutine
constructor; a quotelike or numeric literal; a regex match; a
substitution; a transliteration; a \f(CW\*(C`do\*(C'\fR or \f(CW\*(C`eval\*(C'\fR block; or any other
expression in surrounding parentheses.
.PP
\fI\f(CI\*(C`(?&PerlTermPostfixDereference)\*(C'\fI\fR
.IX Subsection "(?&PerlTermPostfixDereference)"
.PP
Matches a sequence of array\- or hash-lookup brackets, or subroutine call
parentheses, or a postfix dereferencer (e.g. \f(CW\*(C`\->$*\*(C'\fR), with
explicit or implicit intervening \f(CW\*(C`\->\*(C'\fR, such as might appear after a term.
.PP
\fI\f(CI\*(C`(?&PerlLvalue)\*(C'\fI\fR
.IX Subsection "(?&PerlLvalue)"
.PP
Matches any variable or parenthesized list of variables that could
be assigned to.
.PP
\fI\f(CI\*(C`(?&PerlPackageDeclaration)\*(C'\fI\fR
.IX Subsection "(?&PerlPackageDeclaration)"
.PP
Matches the declaration of any package
(with or without a defining block).
.PP
\fI\f(CI\*(C`(?&PerlSubroutineDeclaration)\*(C'\fI\fR
.IX Subsection "(?&PerlSubroutineDeclaration)"
.PP
Matches the declaration of any named subroutine
(with or without a defining block).
.PP
\fI\f(CI\*(C`(?&PerlUseStatement)\*(C'\fI\fR
.IX Subsection "(?&PerlUseStatement)"
.PP
Matches a \f(CW\*(C`use <module name> ...;\*(C'\fR or \f(CW\*(C`use <version number>;\*(C'\fR statement.
.PP
\fI\f(CI\*(C`(?&PerlReturnStatement)\*(C'\fI\fR
.IX Subsection "(?&PerlReturnStatement)"
.PP
Matches a \f(CW\*(C`return <expression>;\*(C'\fR or \f(CW\*(C`return;\*(C'\fR statement.
.PP
\fI\f(CI\*(C`(?&PerlReturnExpression)\*(C'\fI\fR
.IX Subsection "(?&PerlReturnExpression)"
.PP
Matches a \f(CW\*(C`return <expression>\*(C'\fR
as an expression without trailing end-of-statement markers.
.PP
\fI\f(CI\*(C`(?&PerlControlBlock)\*(C'\fI\fR
.IX Subsection "(?&PerlControlBlock)"
.PP
Matches an \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`unless\*(C'\fR, \f(CW\*(C`while\*(C'\fR, \f(CW\*(C`until\*(C'\fR, \f(CW\*(C`for\*(C'\fR, or \f(CW\*(C`foreach\*(C'\fR
statement, including its block.
.PP
\fI\f(CI\*(C`(?&PerlDoBlock)\*(C'\fI\fR
.IX Subsection "(?&PerlDoBlock)"
.PP
Matches a \f(CW\*(C`do\*(C'\fR\-block expression.
.PP
\fI\f(CI\*(C`(?&PerlEvalBlock)\*(C'\fI\fR
.IX Subsection "(?&PerlEvalBlock)"
.PP
Matches a \f(CW\*(C`eval\*(C'\fR\-block expression.
.PP
\fI\f(CI\*(C`(?&PerlStatementModifier)\*(C'\fI\fR
.IX Subsection "(?&PerlStatementModifier)"
.PP
Matches an \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`unless\*(C'\fR, \f(CW\*(C`while\*(C'\fR, \f(CW\*(C`until\*(C'\fR, \f(CW\*(C`for\*(C'\fR, or \f(CW\*(C`foreach\*(C'\fR
modifier that could appear after a statement. Only matches the modifier, not
the preceding statement.
.PP
\fI\f(CI\*(C`(?&PerlFormat)\*(C'\fI\fR
.IX Subsection "(?&PerlFormat)"
.PP
Matches a \f(CW\*(C`format\*(C'\fR declaration, including its terminating \*(L"dot\*(R".
.PP
\fI\f(CI\*(C`(?&PerlBlock)\*(C'\fI\fR
.IX Subsection "(?&PerlBlock)"
.PP
Matches a \f(CW\*(C`{\*(C'\fR...\f(CW\*(C`}\*(C'\fR\-delimited block containing zero-or-more statements.
.PP
\fI\f(CI\*(C`(?&PerlCall)\*(C'\fI\fR
.IX Subsection "(?&PerlCall)"
.PP
Matches a class to a subroutine or built-in function.
Accepts all valid call syntaxes,
either via a literal names or a reference,
with or without a leading \f(CW\*(C`&\*(C'\fR,
with or without arguments,
with or without parentheses on any argument list.
.PP
\fI\f(CI\*(C`(?&PerlAttributes)\*(C'\fI\fR
.IX Subsection "(?&PerlAttributes)"
.PP
Matches a list of colon-preceded attributes, such as might be specified
on the declaration of a subroutine or a variable.
.PP
\fI\f(CI\*(C`(?&PerlCommaList)\*(C'\fI\fR
.IX Subsection "(?&PerlCommaList)"
.PP
Matches a list of zero-or-more comma-separated subexpressions.
That is, a single valid Perl expression that involves operators above the
precedence of \f(CW\*(C`not\*(C'\fR.
.PP
\fI\f(CI\*(C`(?&PerlParenthesesList)\*(C'\fI\fR
.IX Subsection "(?&PerlParenthesesList)"
.PP
Matches a list of zero-or-more comma-separated subexpressions inside
a set of parentheses.
.PP
\fI\f(CI\*(C`(?&PerlList)\*(C'\fI\fR
.IX Subsection "(?&PerlList)"
.PP
Matches either a parenthesized or unparenthesized list of
comma-separated subexpressions. That is, matches anything that either of
the two preceding rules would match.
.PP
\fI\f(CI\*(C`(?&PerlAnonymousArray)\*(C'\fI\fR
.IX Subsection "(?&PerlAnonymousArray)"
.PP
Matches an anonymous array constructor.
That is: a list of zero-or-more subexpressions inside square brackets.
.PP
\fI\f(CI\*(C`(?&PerlAnonymousHash)\*(C'\fI\fR
.IX Subsection "(?&PerlAnonymousHash)"
.PP
Matches an anonymous hash constructor.
That is: a list of zero-or-more subexpressions inside curly brackets.
.PP
\fI\f(CI\*(C`(?&PerlArrayIndexer)\*(C'\fI\fR
.IX Subsection "(?&PerlArrayIndexer)"
.PP
Matches a valid indexer that could be applied to look up elements of a array.
That is: a list of or one-or-more subexpressions inside square brackets.
.PP
\fI\f(CI\*(C`(?&PerlHashIndexer)\*(C'\fI\fR
.IX Subsection "(?&PerlHashIndexer)"
.PP
Matches a valid indexer that could be applied to look up entries of a hash.
That is: a list of or one-or-more subexpressions inside curly brackets,
or a simple bareword indentifier inside curley brackets.
.PP
\fI\f(CI\*(C`(?&PerlDiamondOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlDiamondOperator)"
.PP
Matches anything in angle brackets.
That is: any \*(L"diamond\*(R" readline (e.g. \f(CW\*(C`<$filehandle>\*(C'\fR
or file-grep operation (e.g. \f(CW\*(C`<*.pl>\*(C'\fR).
.PP
\fI\f(CI\*(C`(?&PerlComma)\*(C'\fI\fR
.IX Subsection "(?&PerlComma)"
.PP
Matches a short (\f(CW\*(C`,\*(C'\fR) or long (\f(CW\*(C`=>\*(C'\fR) comma.
.PP
\fI\f(CI\*(C`(?&PerlPrefixUnaryOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlPrefixUnaryOperator)"
.PP
Matches any high-precedence prefix unary operator.
.PP
\fI\f(CI\*(C`(?&PerlPostfixUnaryOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlPostfixUnaryOperator)"
.PP
Matches any high-precedence postfix unary operator.
.PP
\fI\f(CI\*(C`(?&PerlInfixBinaryOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlInfixBinaryOperator)"
.PP
Matches any infix binary operator
whose precedence is between \f(CW\*(C`..\*(C'\fR and \f(CW\*(C`**\*(C'\fR.
.PP
\fI\f(CI\*(C`(?&PerlAssignmentOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlAssignmentOperator)"
.PP
Matches any assignment operator,
including all \fIop\fR\f(CW\*(C`=\*(C'\fR variants.
.PP
\fI\f(CI\*(C`(?&PerlLowPrecedenceInfixOperator)\*(C'\fI\fR
.IX Subsection "(?&PerlLowPrecedenceInfixOperator)"
.PP
Matches \f(CW\*(C`and\*(C'\fR, <or>, or \f(CW\*(C`xor\*(C'\fR.
.PP
\fI\f(CI\*(C`(?&PerlAnonymousSubroutine)\*(C'\fI\fR
.IX Subsection "(?&PerlAnonymousSubroutine)"
.PP
Matches an anonymous subroutine.
.PP
\fI\f(CI\*(C`(?&PerlVariable)\*(C'\fI\fR
.IX Subsection "(?&PerlVariable)"
.PP
Matches any type of access on any scalar, array, or hash
variable.
.PP
\fI\f(CI\*(C`(?&PerlVariableScalar)\*(C'\fI\fR
.IX Subsection "(?&PerlVariableScalar)"
.PP
Matches any scalar variable,
including fully qualified package variables,
punctuation variables, scalar dereferences,
and the \f(CW$#array\fR syntax.
.PP
\fI\f(CI\*(C`(?&PerlVariableArray)\*(C'\fI\fR
.IX Subsection "(?&PerlVariableArray)"
.PP
Matches any array variable,
including fully qualified package variables,
punctuation variables, and array dereferences.
.PP
\fI\f(CI\*(C`(?&PerlVariableHash)\*(C'\fI\fR
.IX Subsection "(?&PerlVariableHash)"
.PP
Matches any hash variable,
including fully qualified package variables,
punctuation variables, and hash dereferences.
.PP
\fI\f(CI\*(C`(?&PerlTypeglob)\*(C'\fI\fR
.IX Subsection "(?&PerlTypeglob)"
.PP
Matches a typeglob.
.PP
\fI\f(CI\*(C`(?&PerlScalarAccess)\*(C'\fI\fR
.IX Subsection "(?&PerlScalarAccess)"
.PP
Matches any kind of variable access
beginning with a \f(CW\*(C`$\*(C'\fR,
including fully qualified package variables,
punctuation variables, scalar dereferences,
the \f(CW$#array\fR syntax, and single-value
array or hash look-ups.
.PP
\fI\f(CI\*(C`(?&PerlScalarAccessNoSpace)\*(C'\fI\fR
.IX Subsection "(?&PerlScalarAccessNoSpace)"
.PP
Matches any kind of variable access beginning with a \f(CW\*(C`$\*(C'\fR, including
fully qualified package variables, punctuation variables, scalar
dereferences, the \f(CW$#array\fR syntax, and single-value array or hash
look-ups.
But does not allow spaces between the components of the
variable access (i.e. imposes the same constraint as within an
interpolating quotelike).
.PP
\fI\f(CI\*(C`(?&PerlScalarAccessNoSpaceNoArrow)\*(C'\fI\fR
.IX Subsection "(?&PerlScalarAccessNoSpaceNoArrow)"
.PP
Matches any kind of variable access beginning with a \f(CW\*(C`$\*(C'\fR, including
fully qualified package variables, punctuation variables, scalar
dereferences, the \f(CW$#array\fR syntax, and single-value array or hash
look-ups.
But does not allow spaces or arrows between the components of the
variable access (i.e. imposes the same constraint as within a
\&\f(CW\*(C`<...>\*(C'\fR\-delimited interpolating quotelike).
.PP
\fI\f(CI\*(C`(?&PerlArrayAccess)\*(C'\fI\fR
.IX Subsection "(?&PerlArrayAccess)"
.PP
Matches any kind of variable access
beginning with a \f(CW\*(C`@\*(C'\fR,
including arrays, array dereferences,
and list slices of arrays or hashes.
.PP
\fI\f(CI\*(C`(?&PerlArrayAccessNoSpace)\*(C'\fI\fR
.IX Subsection "(?&PerlArrayAccessNoSpace)"
.PP
Matches any kind of variable access
beginning with a \f(CW\*(C`@\*(C'\fR,
including arrays, array dereferences,
and list slices of arrays or hashes.
But does not allow spaces between the components of the
variable access (i.e. imposes the same constraint as within an
interpolating quotelike).
.PP
\fI\f(CI\*(C`(?&PerlArrayAccessNoSpaceNoArrow)\*(C'\fI\fR
.IX Subsection "(?&PerlArrayAccessNoSpaceNoArrow)"
.PP
Matches any kind of variable access
beginning with a \f(CW\*(C`@\*(C'\fR,
including arrays, array dereferences,
and list slices of arrays or hashes.
But does not allow spaces or arrows between the components of the
variable access (i.e. imposes the same constraint as within a
\&\f(CW\*(C`<...>\*(C'\fR\-delimited interpolating quotelike).
.PP
\fI\f(CI\*(C`(?&PerlHashAccess)\*(C'\fI\fR
.IX Subsection "(?&PerlHashAccess)"
.PP
Matches any kind of variable access
beginning with a \f(CW\*(C`%\*(C'\fR,
including hashes, hash dereferences,
and kv-slices of hashes or arrays.
.PP
\fI\f(CI\*(C`(?&PerlLabel)\*(C'\fI\fR
.IX Subsection "(?&PerlLabel)"
.PP
Matches a colon-terminated label.
.PP
\fI\f(CI\*(C`(?&PerlLiteral)\*(C'\fI\fR
.IX Subsection "(?&PerlLiteral)"
.PP
Matches a literal value.
That is: a number, a \f(CW\*(C`qr\*(C'\fR or \f(CW\*(C`qw\*(C'\fR
quotelike, a string, or a bareword.
.PP
\fI\f(CI\*(C`(?&PerlString)\*(C'\fI\fR
.IX Subsection "(?&PerlString)"
.PP
Matches a string literal.
That is: a single\- or double-quoted string,
a \f(CW\*(C`q\*(C'\fR or \f(CW\*(C`qq\*(C'\fR string, a heredoc, or a
version string.
.PP
\fI\f(CI\*(C`(?&PerlQuotelike)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelike)"
.PP
Matches any form of quotelike operator.
That is: a single\- or double-quoted string,
a \f(CW\*(C`q\*(C'\fR or \f(CW\*(C`qq\*(C'\fR string, a heredoc, a
version string, a \f(CW\*(C`qr\*(C'\fR, a \f(CW\*(C`qw\*(C'\fR, a \f(CW\*(C`qx\*(C'\fR,
a \f(CW\*(C`/.../\*(C'\fR or \f(CW\*(C`m/.../\*(C'\fR regex,
a substitution, or a transliteration.
.PP
\fI\f(CI\*(C`(?&PerlHeredoc)\*(C'\fI\fR
.IX Subsection "(?&PerlHeredoc)"
.PP
Matches a heredoc specifier.
That is: just the initial \f(CW\*(C`<<TERMINATOR>\*(C'\fR component,
\&\fInot\fR the actual contents of the heredoc on the
subsequent lines.
.PP
This rule only matches a heredoc specifier if that specifier
is correctly followed on the next line by any heredoc contents
and then the correct terminator.
.PP
However, if the heredoc specifier \fIis\fR correctly matched, subsequent
calls to either of the whitespace-matching rules (\f(CW\*(C`(?&PerlOWS)\*(C'\fR or
\&\f(CW\*(C`(?&PerlNWS)\*(C'\fR) will also consume the trailing heredoc contents and
the terminator.
.PP
So, for example, to correctly match a heredoc plus its contents
you could use something like:
.PP
.Vb 1
\&    m/ (?&PerlHeredoc) (?&PerlOWS)  $PPR::X::GRAMMAR /x
.Ve
.PP
or, if there may be trailing items on the same line as the heredoc
specifier:
.PP
.Vb 3
\&    m/ (?&PerlHeredoc)
\&       (?<trailing_items> [^\en]* )
\&       (?&PerlOWS)
\&
\&       $PPR::X::GRAMMAR
\&    /x
.Ve
.PP
Note that the saeme limitations apply to other constructs that
match heredocs, such a \f(CW\*(C`(?&PerlQuotelike)\*(C'\fR or \f(CW\*(C`(?&PerlString)\*(C'\fR.
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeQ)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeQ)"
.PP
Matches a single-quoted string,
either a \f(CW\*(Aq...\*(Aq\fR
or a \f(CW\*(C`q/.../\*(C'\fR (with any valid delimiters).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeQQ)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeQQ)"
.PP
Matches a double-quoted string,
either a \f(CW"..."\fR
or a \f(CW\*(C`qq/.../\*(C'\fR (with any valid delimiters).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeQW)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeQW)"
.PP
Matches a \*(L"quotewords\*(R" list.
That is a \f(CW\*(C`qw/ list of words /\*(C'\fR
(with any valid delimiters).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeQX)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeQX)"
.PP
Matches a \f(CW\*(C`qx\*(C'\fR system call,
either a \f(CW\*(C`\`...\`\*(C'\fR
or a \f(CW\*(C`qx/.../\*(C'\fR (with any valid delimiters)
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeS)\*(C'\fI or \f(CI\*(C`(?&PerlSubstitution)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeS) or (?&PerlSubstitution)"
.PP
Matches a substitution operation.
That is: \f(CW\*(C`s/.../.../\*(C'\fR
(with any valid delimiters and any valid trailing modifiers).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeTR)\*(C'\fI or \f(CI\*(C`(?&PerlTransliteration)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeTR) or (?&PerlTransliteration)"
.PP
Matches a transliteration operation.
That is: \f(CW\*(C`tr/.../.../\*(C'\fR or \f(CW\*(C`y/.../.../\*(C'\fR
(with any valid delimiters and any valid trailing modifiers).
.PP
\fI\f(CI\*(C`(?&PerlContextualQuotelikeM)\*(C'\fI or \f(CI\*(C`(?&PerContextuallMatch)\*(C'\fI\fR
.IX Subsection "(?&PerlContextualQuotelikeM) or (?&PerContextuallMatch)"
.PP
Matches a regex-match operation in any context where it would
be allowed in valid Perl.
That is: \f(CW\*(C`/.../\*(C'\fR or \f(CW\*(C`m/.../\*(C'\fR
(with any valid delimiters and any valid trailing modifiers).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeM)\*(C'\fI or \f(CI\*(C`(?&PerlMatch)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeM) or (?&PerlMatch)"
.PP
Matches a regex-match operation.
That is: \f(CW\*(C`/.../\*(C'\fR or \f(CW\*(C`m/.../\*(C'\fR
(with any valid delimiters and any valid trailing modifiers)
in any context (i.e. even in places where it would not normally
be allowed within a valid piece of Perl code).
.PP
\fI\f(CI\*(C`(?&PerlQuotelikeQR)\*(C'\fI\fR
.IX Subsection "(?&PerlQuotelikeQR)"
.PP
Matches a \f(CW\*(C`qr\*(C'\fR regex constructor
(with any valid delimiters and any valid trailing modifiers).
.PP
\fI\f(CI\*(C`(?&PerlContextualRegex)\*(C'\fI\fR
.IX Subsection "(?&PerlContextualRegex)"
.PP
Matches a \f(CW\*(C`qr\*(C'\fR regex constructor or a \f(CW\*(C`/.../\*(C'\fR or \f(CW\*(C`m/.../\*(C'\fR regex-match
operation (with any valid delimiters and any valid trailing modifiers)
anywhere where either would be allowed in valid Perl.
.PP
In other words: anything capable of matching within valid Perl code.
.PP
\fI\f(CI\*(C`(?&PerlRegex)\*(C'\fI\fR
.IX Subsection "(?&PerlRegex)"
.PP
Matches a \f(CW\*(C`qr\*(C'\fR regex constructor or a \f(CW\*(C`/.../\*(C'\fR or \f(CW\*(C`m/.../\*(C'\fR regex-match
operation in any context (i.e. even in places where it would not normally
be allowed within a valid piece of Perl code).
.PP
In other words: anything capable of matching.
.PP
\fI\f(CI\*(C`(?&PerlBuiltinFunction)\*(C'\fI\fR
.IX Subsection "(?&PerlBuiltinFunction)"
.PP
Matches the \fIname\fR of any builtin function.
.PP
To match an actual call to a built-in function, use:
.PP
.Vb 4
\&    m/
\&        (?= (?&PerlBuiltinFunction) )
\&        (?&PerlCall)
\&    /x
.Ve
.PP
\fI\f(CI\*(C`(?&PerlNullaryBuiltinFunction)\*(C'\fI\fR
.IX Subsection "(?&PerlNullaryBuiltinFunction)"
.PP
Matches the name of any builtin function that never
takes arguments.
.PP
To match an actual call to a built-in function that
never takes arguments, use:
.PP
.Vb 4
\&    m/
\&        (?= (?&PerlNullaryBuiltinFunction) )
\&        (?&PerlCall)
\&    /x
.Ve
.PP
\fI\f(CI\*(C`(?&PerlVersionNumber)\*(C'\fI\fR
.IX Subsection "(?&PerlVersionNumber)"
.PP
Matches any number or version-string that can be
used as a version number within a \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`no\*(C'\fR,
or \f(CW\*(C`package\*(C'\fR statement.
.PP
\fI\f(CI\*(C`(?&PerlVString)\*(C'\fI\fR
.IX Subsection "(?&PerlVString)"
.PP
Matches a version-string (a.k.a v\-string).
.PP
\fI\f(CI\*(C`(?&PerlNumber)\*(C'\fI\fR
.IX Subsection "(?&PerlNumber)"
.PP
Matches a valid number,
including binary, octal, decimal and hexadecimal integers,
and floating-point numbers with or without an exponent.
.PP
\fI\f(CI\*(C`(?&PerlIdentifier)\*(C'\fI\fR
.IX Subsection "(?&PerlIdentifier)"
.PP
Matches a simple, unqualified identifier.
.PP
\fI\f(CI\*(C`(?&PerlQualifiedIdentifier)\*(C'\fI\fR
.IX Subsection "(?&PerlQualifiedIdentifier)"
.PP
Matches a qualified or unqualified identifier,
which may use either \f(CW\*(C`::\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR as internal
separators, but only \f(CW\*(C`::\*(C'\fR as initial or terminal
separators.
.PP
\fI\f(CI\*(C`(?&PerlOldQualifiedIdentifier)\*(C'\fI\fR
.IX Subsection "(?&PerlOldQualifiedIdentifier)"
.PP
Matches a qualified or unqualified identifier,
which may use either \f(CW\*(C`::\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR as both
internal and external separators.
.PP
\fI\f(CI\*(C`(?&PerlBareword)\*(C'\fI\fR
.IX Subsection "(?&PerlBareword)"
.PP
Matches a valid bareword.
.PP
Note that this is not the same as an simple identifier,
nor the same as a qualified identifier.
.PP
\fI\f(CI\*(C`(?&PerlPod)\*(C'\fI\fR
.IX Subsection "(?&PerlPod)"
.PP
Matches a single \s-1POD\s0 section containing any contiguous set of \s-1POD\s0
directives, up to the first \f(CW\*(C`=cut\*(C'\fR or end-of-file.
.PP
\fI\f(CI\*(C`(?&PerlPodSequence)\*(C'\fI\fR
.IX Subsection "(?&PerlPodSequence)"
.PP
Matches any sequence of \s-1POD\s0 sections,
separated and /or surrounded by optional whitespace.
.PP
\fI\f(CI\*(C`(?&PerlNWS)\*(C'\fI\fR
.IX Subsection "(?&PerlNWS)"
.PP
Match one-or-more characters of necessary whitespace,
including spaces, tabs, newlines, comments, and \s-1POD.\s0
.PP
\fI\f(CI\*(C`(?&PerlOWS)\*(C'\fI\fR
.IX Subsection "(?&PerlOWS)"
.PP
Match zero-or-more characters of optional whitespace,
including spaces, tabs, newlines, comments, and \s-1POD.\s0
.PP
\fI\f(CI\*(C`(?&PerlOWSOrEND)\*(C'\fI\fR
.IX Subsection "(?&PerlOWSOrEND)"
.PP
Match zero-or-more characters of optional whitespace,
including spaces, tabs, newlines, comments, \s-1POD,\s0
and any trailing \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR section.
.PP
\fI\f(CI\*(C`(?&PerlEndOfLine)\*(C'\fI\fR
.IX Subsection "(?&PerlEndOfLine)"
.PP
Matches a single newline (\f(CW\*(C`\en\*(C'\fR) character.
.PP
This is provided mainly to allow newlines to
be \*(L"hooked\*(R" by redefining \f(CW\*(C`(?<PerlEndOfLine>)\*(C'\fR
(for example, to count lines during a parse).
.PP
\fI\f(CI\*(C`(?&PerlKeyword)\*(C'\fI\fR
.IX Subsection "(?&PerlKeyword)"
.PP
Match a pluggable keyword.
.PP
Note that there are no pluggable keywords
in the default \s-1PPR::X\s0 regex;
they must be added by the end-user.
See the following section for details.
.SS "Extending the Perl syntax with keywords"
.IX Subsection "Extending the Perl syntax with keywords"
In Perl 5.12 and later, it's possible to add new types
of statements to the language using a mechanism called
\&\*(L"pluggable keywords\*(R".
.PP
This mechanism (best accessed via \s-1CPAN\s0 modules such as
\&\f(CW\*(C`Keyword::Simple\*(C'\fR or \f(CW\*(C`Keyword::Declare\*(C'\fR) acts like a limited macro
facility. It detects when a statement begins with a particular,
pre-specified keyword, passes the trailing text to an associated keyword
handler, and replaces the trailing source code with whatever the keyword
handler produces.
.PP
For example, the Dios module uses this mechanism to add keywords such
as \f(CW\*(C`class\*(C'\fR, \f(CW\*(C`method\*(C'\fR, and \f(CW\*(C`has\*(C'\fR to Perl 5, providing a declarative
\&\s-1OO\s0 syntax. And the Object::Result module uses pluggable keywords to
add a \f(CW\*(C`result\*(C'\fR statement that simplifies returning an ad hoc object from a
subroutine.
.PP
Unfortunately, because such modules effectively extend the standard Perl
syntax, by default \s-1PPR::X\s0 has no way of successfully parsing them.
.PP
However, when setting up a regex using \f(CW$PPR::X::GRAMMAR\fR it is possible to
extend that grammar to deal with new keywords...by defining a rule named
\&\f(CW\*(C`(?<PerlKeyword>...)\*(C'\fR.
.PP
This rule is always tested as the first option within the standard
\&\f(CW\*(C`(?&PerlStatement)\*(C'\fR rule, so any syntax declared within effectively
becomes a new kind of statement. Note that each alternative within
the rule must begin with a valid \*(L"keyword\*(R" (that is: a simple
identifier of some kind).
.PP
For example, to support the three keywords from Dios:
.PP
.Vb 1
\&    $Dios::GRAMMAR = qr{
\&
\&        # Add a keyword rule to support Dios...
\&        (?(DEFINE)
\&            (?<PerlKeyword>
\&
\&                    class                              (?&PerlOWS)
\&                    (?&PerlQualifiedIdentifier)        (?&PerlOWS)
\&                (?: is (?&PerlNWS) (?&PerlIdentifier)  (?&PerlOWS) )*+
\&                    (?&PerlBlock)
\&            |
\&                    method                             (?&PerlOWS)
\&                    (?&PerlIdentifier)                 (?&PerlOWS)
\&                (?: (?&kw_balanced_parens)             (?&PerlOWS) )?+
\&                (?: (?&PerlAttributes)                 (?&PerlOWS) )?+
\&                    (?&PerlBlock)
\&            |
\&                    has                                (?&PerlOWS)
\&                (?: (?&PerlQualifiedIdentifier)        (?&PerlOWS) )?+
\&                    [\e@\e$%][.!]?(?&PerlIdentifier)     (?&PerlOWS)
\&                (?: (?&PerlAttributes)                 (?&PerlOWS) )?+
\&                (?: (?: // )?+ =                       (?&PerlOWS)
\&                    (?&PerlExpression)                 (?&PerlOWS) )?+
\&                (?> ; | (?= \e} ) | \ez )
\&            )
\&
\&            (?<kw_balanced_parens>
\&                \e( (?: [^()]++ | (?&kw_balanced_parens) )*+ \e)
\&            )
\&        )
\&
\&        # Add all the standard PPR::X rules...
\&        $PPR::X::GRAMMAR
\&    }x;
\&
\&    # Then parse with it...
\&
\&    $source_code =~ m{ \eA (?&PerlDocument) \eZ  $Dios::GRAMMAR }x;
.Ve
.PP
Or, to support the \f(CW\*(C`result\*(C'\fR statement from \f(CW\*(C`Object::Result\*(C'\fR:
.PP
.Vb 1
\&    my $ORK_GRAMMAR = qr{
\&
\&        # Add a keyword rule to support Object::Result...
\&        (?(DEFINE)
\&            (?<PerlKeyword>
\&                result                        (?&PerlOWS)
\&                \e{                            (?&PerlOWS)
\&                (?: (?> (?&PerlIdentifier)
\&                    |   < [[:upper:]]++ >
\&                    )                         (?&PerlOWS)
\&                    (?&PerlParenthesesList)?+      (?&PerlOWS)
\&                    (?&PerlBlock)             (?&PerlOWS)
\&                )*+
\&                \e}
\&            )
\&        )
\&
\&        # Add all the standard PPR::X rules...
\&        $PPR::X::GRAMMAR
\&    }x;
\&
\&    # Then parse with it...
\&
\&    $source_code =~ m{ \eA (?&PerlDocument) \eZ  $ORK_GRAMMAR }x;
.Ve
.PP
Note that, although pluggable keywords are only available from Perl
5.12 onwards, \s-1PPR::X\s0 will still accept \f(CW\*(C`(&?PerlKeyword)\*(C'\fR extensions under
Perl 5.10.
.SS "Extending the Perl syntax in other ways"
.IX Subsection "Extending the Perl syntax in other ways"
Other modules (such as \f(CW\*(C`Devel::Declare\*(C'\fR and \f(CW\*(C`Filter::Simple\*(C'\fR)
make it possible to extend Perl syntax in even more flexible ways.
The \s-1PPR::X\s0 module provides support for syntactic extensions more
general than pluggable keywords.
.PP
\&\s-1PPR::X\s0 allows \fIany\fR of its public rules to be redefined in a
particular regex. For example, to create a regex that matches
standard Perl syntax, but which allows the keyword \f(CW\*(C`fun\*(C'\fR as
a synonym for \f(CW\*(C`sub\*(C'\fR:
.PP
.Vb 1
\&    my $FUN_GRAMMAR = qr{
\&
\&        # Extend the subroutine\-matching rules...
\&        (?(DEFINE)
\&            (?<PerlStatement>
\&                # Try the standard syntax...
\&                (?&PerlStdStatement)
\&            |
\&                # Try the new syntax...
\&                fun                               (?&PerlOWS)
\&                (?&PerlOldQualifiedIdentifier)    (?&PerlOWS)
\&                (?: \e( [^)]*+ \e) )?+              (?&PerlOWS)
\&                (?: (?&PerlAttributes)            (?&PerlOWS) )?+
\&                (?> ; | (?&PerlBlock) )
\&            )
\&
\&            (?<PerlAnonymousSubroutine>
\&                # Try the standard syntax
\&                (?&PerlStdAnonymousSubroutine)
\&            |
\&                # Try the new syntax
\&                fun                               (?&PerlOWS)
\&                (?: \e( [^)]*+ \e) )?+              (?&PerlOWS)
\&                (?: (?&PerlAttributes)            (?&PerlOWS) )?+
\&                (?> ; | (?&PerlBlock) )
\&            )
\&        )
\&
\&        $PPR::X::GRAMMAR
\&    }x;
.Ve
.PP
Note first that any redefinitions of the various rules have to be
specified before the interpolation of the standard rules (so that the
new rules take syntactic precedence over the originals).
.PP
The structure of each redefinition is essentially identical.
First try the original rule, which is still accessible as \f(CW\*(C`(?&PerlStd...)\*(C'\fR
(instead of \f(CW\*(C`(?&Perl...)\*(C'\fR). Otherwise, try the new alternative, which
may be constructed out of other rules.
    original rule.
.PP
There is no absolute requirement to try the original rule as part of the
new rule, but if you don't then you are \fIreplacing\fR the rule, rather
than extending it. For example, to replace the low-precedence boolean
operators (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, and \f(CW\*(C`not\*(C'\fR) with their Latin equivalents:
.PP
.Vb 1
\&    my $GRAMMATICA = qr{
\&
\&        # Verbum sapienti satis est...
\&        (?(DEFINE)
\&
\&            # Iunctiones...
\&            (?<PerlLowPrecedenceInfixOperator>
\&                atque | vel | aut
\&            )
\&
\&            # Contradicetur...
\&            (?<PerlLowPrecedenceNotExpression>
\&                (?: non  (?&PerlOWS) )*+  (?&PerlCommaList)
\&            )
\&        )
\&
\&        $PPR::X::GRAMMAR
\&    }x;
.Ve
.PP
Or to maintain a line count within the parse:
.PP
.Vb 1
\&    my $COUNTED_GRAMMAR = qr{
\&
\&        (?(DEFINE)
\&
\&            (?<PerlEndOfLine>
\&                # Try the standard syntax
\&                (?&PerlStdEndOfLine)
\&
\&                # Then count the line (must localize, to handle backtracking)...
\&                (?{ local $linenum = $linenum + 1; })
\&            )
\&        )
\&
\&        $PPR::X::GRAMMAR
\&    }x;
.Ve
.SS "Comparison with \s-1PPI\s0"
.IX Subsection "Comparison with PPI"
The \s-1PPI\s0 and \s-1PPR::X\s0 modules can both identify valid Perl code,
but they do so in very different ways, and are optimal for
different purposes.
.PP
\&\s-1PPI\s0 scans an entire Perl document and builds a hierarchical
representation of the various components. It is therefore suitable for
recognition, validation, partial extraction, and in-place transformation
of Perl code.
.PP
\&\s-1PPR::X\s0 matches only as much of a Perl document as specified by the regex
you create, and does not build any hierarchical representation of the
various components it matches. It is therefore suitable for recognition
and validation of Perl code. However, unless great care is taken, \s-1PPR::X\s0 is
not as reliable as \s-1PPI\s0 for extractions or transformations of components
smaller than a single statement.
.PP
On the other hand, \s-1PPI\s0 always has to parse its entire input, and
build a complete non-trivial nested data structure for it, before it
can be used to recognize or validate any component. So it is almost
always significantly slower and more complicated than \s-1PPR::X\s0 for those
kinds of tasks.
.PP
For example, to determine whether an input string begins with a valid
Perl block, \s-1PPI\s0 requires something like:
.PP
.Vb 8
\&    if (my $document = PPI::Document\->new(\e$input_string) ) {
\&        my $block = $document\->schild(0)\->schild(0);
\&        if ($block\->isa(\*(AqPPI::Structure::Block\*(Aq)) {
\&            $block\->remove;
\&            process_block($block);
\&            process_extra($document);
\&        }
\&    }
.Ve
.PP
whereas \s-1PPR::X\s0 needs just:
.PP
.Vb 4
\&    if ($input_string =~ m{ \eA (?&PerlOWS) ((?&PerlBlock)) (.*) }xs) {
\&        process_block($1);
\&        process_extra($2);
\&    }
.Ve
.PP
Moreover, the \s-1PPR::X\s0 version will be at least twice as fast at recognizing that
leading block (and usually four to seven times faster)...mainly because it
doesn't have to parse the trailing code at all, nor build any representation
of its hierarchical structure.
.PP
As a simple rule of thumb, when you only need to quickly detect, identify,
or confirm valid Perl (or just a single valid Perl component), use \s-1PPR::X.\s0
When you need to examine, traverse, or manipulate the internal structure
or component relationships within an entire Perl document, use \s-1PPI.\s0
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Warning: This program is running under Perl 5.20...""" 4
.el .IP "\f(CWWarning: This program is running under Perl 5.20...\fR" 4
.IX Item "Warning: This program is running under Perl 5.20..."
Due to an unsolved issue with that particular release of Perl, the
single regex in the \s-1PPR::X\s0 module takes a ridiculously long time
to compile under Perl 5.20 (i.e. minutes, not milliseconds).
.Sp
The code will work correctly when it eventually does compile,
but the start-up delay is so extreme that the module issues
this warning, to reassure users the something is actually
happening, and explain why it's happening so slowly.
.Sp
The only remedy at present is to use an older or newer version
of Perl.
.Sp
For all the gory details, see:
<https://rt.perl.org/Public/Bug/Display.html?id=122283>
<https://rt.perl.org/Public/Bug/Display.html?id=122890>
.ie n .IP """PPR::X::decomment() does not work under Perl 5.14""" 4
.el .IP "\f(CWPPR::X::decomment() does not work under Perl 5.14\fR" 4
.IX Item "PPR::X::decomment() does not work under Perl 5.14"
There is a separate bug in the Perl 5.14 regex engine that prevents
the \f(CW\*(C`decomment()\*(C'\fR subroutine from correctly detecting the location
of comments.
.Sp
The subroutine throws an exception if you attempt to call it
when running under Perl 5.14 specifically.
.PP
The module has no other diagnostics, apart from those Perl
provides for all regular expressions.
.PP
The commonest error is to forget to add \f(CW$PPR::X::GRAMMAR\fR
to a regex, in which case you will get a standard Perl
error message such as:
.PP
.Vb 2
\&    Reference to nonexistent named group in regex;
\&    marked by <\-\- HERE in m/
\&
\&        (?&PerlDocument <\-\- HERE )
\&
\&    / at example.pl line 42.
.Ve
.PP
Adding \f(CW$PPR::X::GRAMMAR\fR at the end of the regex solves the problem.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
\&\s-1PPR::X\s0 requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Requires Perl 5.10 or later.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
This module works under all versions of Perl from 5.10 onwards.
.PP
However, the lastest release of Perl 5.20 seems to have significant
difficulties compiling large regular expressions, and typically requires
over a minute to build any regex that incorporates the \f(CW$PPR::X::GRAMMAR\fR rule
definitions.
.PP
The problem does not occur in Perl 5.10 to 5.18, nor in Perl 5.22 or later,
though the parser is still measurably slower in all Perl versions
greater than 5.20 (presumably because \fImost\fR regexes are measurably
slower in more modern versions of Perl; such is the price of full
re-entrancy and safe lexical scoping).
.PP
The \f(CW\*(C`decomment()\*(C'\fR subroutine trips a separate regex engine bug in Perl
5.14 only and will not run under that version.
.PP
There are also constructs in Perl 5 which cannot be parsed without
actually executing some code...which the regex does not attempt to
do, for obvious reasons.
.SH "BUGS"
.IX Header "BUGS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-ppr@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2017, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
