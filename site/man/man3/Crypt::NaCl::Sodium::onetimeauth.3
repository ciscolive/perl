.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::onetimeauth 3"
.TH Crypt::NaCl::Sodium::onetimeauth 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::onetimeauth \- One\-time authentication (Poly1305)
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_onetimeauth = Crypt::NaCl::Sodium\->onetimeauth();
\&
\&    my ($msg, $key, $mac);
\&
\&    $msg = "First message";
\&
\&    # generate one\-time secret key
\&    $key = $crypto_onetimeauth\->keygen();
\&
\&    # calculate authenticator
\&    $mac = $crypto_onetimeauth\->mac( $msg, $key );
\&
\&    # verify message
\&    if ( $crypto_onetimeauth\->verify($mac, $msg, $key) ) {
\&        # verified OK
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`crypto_onetimeauth\*(C'\fR's \*(L"mac\*(R", viewed as a function of the message for a
uniform random key, is designed to meet the standard notion of unforgeability
after a single message. After the sender authenticates one message, an attacker
cannot find authenticators for any other messages.
.PP
The sender must not use this function to authenticate more than one message
under the same key. Authenticators for two messages under the same key should be
expected to reveal enough information to allow forgeries of authenticators on
other messages.
.PP
When multiple messages need to be authenticated use
Crypt::NaCl::Sodium::auth.
.SH "METHODS"
.IX Header "METHODS"
.SS "keygen"
.IX Subsection "keygen"
.Vb 1
\&    my $key = $crypto_onetimeauth\->keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_onetimeauth\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.SS "mac"
.IX Subsection "mac"
.Vb 1
\&    my $mac = $crypto_onetimeauth\->mac( $msg, $key );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using given \f(CW$key\fR.
.PP
The length of the \f(CW$mac\fR equals \*(L"\s-1BYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR Never use this method to authenticate more than one message
under the same key.
.PP
Returns Data::BytesLocker object.
.SS "verify"
.IX Subsection "verify"
.Vb 3
\&    unless ( $crypto_onetimeauth\->verify( $mac, $msg, $key ) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
Verifies the integrity and authenticity of the \f(CW$msg\fR using given \f(CW$mac\fR and \f(CW$key\fR.
.PP
Method returns true if message has been verified, false otherwise.
.SH "Multi-part API"
.IX Header "Multi-part API"
Multi-part computation is also supported.
.PP
.Vb 1
\&    my $ctx = $crypto_onetimeauth\->init( $key );
\&
\&    $ctx\->update( $msgX );
\&    $ctx\->update( $msgY )\->update( $msgZ, ... );
\&
\&    my $mac = $ctx\->final();
\&
\&    my $msgXYZ = join(\*(Aq\*(Aq, $msgX, $msgY, $msgZ, ...);
\&    unless ( $crypto_onetimeauth\->verify( $mac, $msgXYZ, $key) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.SS "init"
.IX Subsection "init"
.Vb 1
\&    my $ctx = $crypto_onetimeauth\->init( $key );
.Ve
.PP
Creates a context for multi-part computation using given \f(CW$key\fR generated using
\&\*(L"keygen\*(R".
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::onetimeauth::stream\*(C'\fR object which encapsulates
the computation state of the algorithm.
.SS "clone"
.IX Subsection "clone"
.Vb 4
\&    while ( <> ) {
\&        $ctx\->update( $_ );
\&        print "Line: $.: ", $ctx\->clone\->final\->to_hex, "\en";
\&    }
.Ve
.PP
Returns a copy of \f(CW$ctx\fR object, that contains the current computation
state.
.SS "update"
.IX Subsection "update"
.Vb 1
\&    $ctx\->update( $msg, ... );
.Ve
.PP
Appends its arguments to the message for which the \s-1MAC\s0 is being calculated.
.PP
Returns the \f(CW$ctx\fR object itself.
.SS "final"
.IX Subsection "final"
.Vb 1
\&    my $mac = $ctx\->final();
.Ve
.PP
Computes the final \s-1MAC\s0 of the input data.
.PP
Returns Data::BytesLocker object.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1KEYBYTES\s0"
.IX Subsection "KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_onetimeauth\->KEYBYTES;
.Ve
.PP
Returns the length of key.
.SS "\s-1BYTES\s0"
.IX Subsection "BYTES"
.Vb 1
\&    my $mac_length = $crypto_onetimeauth\->BYTES;
.Ve
.PP
Returns the length of \s-1MAC.\s0
.SH "SECURITY MODEL"
.IX Header "SECURITY MODEL"
\&\f(CW\*(C`crypto_onetimeauth\*(C'\fR uses \fIPoly1305\fR authenticator, which is \fIproven\fR to meet
the standard notion of unforgeability after a single message.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
Cryptography in NaCl <http://cr.yp.to/highspeed/naclcrypto-20090310.pdf>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
