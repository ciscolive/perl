.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Checker 3"
.TH Data::Checker 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Checker \- a framework for checking data validity
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Data::Checker;
\&
\&   $obj = new Data::Checker;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A commonly performed task is to have a set of data that you want to
validate.  Given a set of elements, you want to test each to make sure
that it is valid, and then break the set into two groups: the group
that is valid, and the group that is not.  With the group that is not
valid, you usually want an error message associated with that element
so you can see why it is not valid.
.PP
Although this is an extremely common task, there isn't a convenient
framework for expressing these tests in, which means that every time
you want to do this kind of testing, you not only have to write the
functions for doing the tests, you also have to write the entire
framework as well.
.PP
This module was written to provide the framework around the tests.  A
number of common test functions are provided, or you can write your
own, and the framework will take care of the rest.
.PP
The framework includes the following commonly desired functionality:
.IP "Automatic handling of the testing" 4
.IX Item "Automatic handling of the testing"
A list of elements is passed in to the framework, and it will
automatically apply the tests and split the elements into sets of
passing and failing elements.
.IP "Running tests in parallel" 4
.IX Item "Running tests in parallel"
Many times, testing a piece of data may take a significant amount of
time, and running them in parallel can greatly speed up the process.
.Sp
This framework allows you to run any number of the tests in parallel,
or you can run them serially one at a time.
.IP "Support for warnings and information messages" 4
.IX Item "Support for warnings and information messages"
Sometimes you want some tests to produce warnings or just
informational messages for an element, but to still consider them as
having passed the test.
.Sp
The level for each test can be specified so that a failure produces an
informational notice, a warning, or an error.  Only an error means
that the element fails the test.
.SH "BASE METHODS"
.IX Header "BASE METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&   $obj = new Data::Checker;
.Ve
.Sp
This creates a new data check framework.
.IP "\fBversion\fR" 4
.IX Item "version"
.Vb 1
\&   $vers = $obj\->version;
.Ve
.Sp
This returns the version of this module.
.IP "\fBparallel\fR" 4
.IX Item "parallel"
.Vb 1
\&   $obj\->parallel($n);
.Ve
.Sp
In many cases, tests can be run in parallel to speed things up.  By
default, all tests will be run serially (one at a time) but that
behavior can be changed using this method.  \f(CW$n\fR must be a positive
integer (or zero):
.Sp
.Vb 1
\&   $n=1  All tests are run serially. This is the default.
\&
\&   $n>1  $n tests will run at a time.  If there are more
\&         elements than this, one will have to finish before
\&         another will start.
\&
\&   $n=0  All of the elements will be tested at the same time.
.Ve
.IP "\fBcheck\fR" 4
.IX Item "check"
.Vb 1
\&   ($pass,$fail,$warn,$info) = $obj\->check($data,$check,$check_opts);
.Ve
.Sp
This is the function which actually performs the checks.  It takes a
set of elements (\f(CW$data\fR) and verifies them using the checks specified
by \f(CW$check\fR and \f(CW$check_opts\fR.  It returns a list of elements that pass
the check and a list that fail the check.  In addition, informational
notes and warnings about the elements may also be returned.
.Sp
The data is passed in as a single data structure (\f(CW$data\fR) as described
below in the \*(L"\s-1SPECIFYING DATA\*(R"\s0 section.
.Sp
\&\f(CW$check\fR specifies what function to use to perform a check.  It will
be used to test an individual element to determine whether it passes
or fails a check.  This is described below in the \*(L"\s-1CHECK FUNCTION\*(R"\s0 section.
.Sp
\&\f(CW$check_opts\fR is a hashref that contains options specifying exactly how
the check is to be performed, and it will be passed to the check
function.  This is described more fully below in the \*(L"\s-1CHECK OPTIONS\*(R"\s0
section.
.SH "SPECIFYING DATA"
.IX Header "SPECIFYING DATA"
Data is passed in to the \fBcheck\fR method in one of two forms.
.PP
The simplest form is a listref.  For example:
.PP
.Vb 1
\&   $data = [ \*(Aqcow\*(Aq, \*(Aqhorse\*(Aq, \*(Aqzebra\*(Aq, \*(Aqoak\*(Aq ]
.Ve
.PP
Many tests do not require any more than this.  For these, elements
that pass are returned also as a listref.  Order is \s-1NOT\s0 preserved
in the output (\f(CW$pass\fR and \f(CW$fail\fR).
.PP
Some tests however rely on a description of each element, and
for these, the data is passed in as a hashref where each key is
one data element and the value is a description of the elements
(which will typically be a hashref, but might be a scalar, a listref,
or some other type of description, and will be documented with the
function doing the check).
.PP
For example:
.PP
.Vb 7
\&   $data = { \*(Aqapple\*(Aq  => { \*(Aqtype\*(Aq  => \*(Aqfruit\*(Aq,
\&                           \*(Aqcolor\*(Aq => \*(Aqred\*(Aq },
\&             \*(Aqpear\*(Aq   => { \*(Aqtype\*(Aq  => \*(Aqfruit\*(Aq,
\&                           \*(Aqcolor\*(Aq => \*(Aqyellow\*(Aq },
\&             \*(Aqbean\*(Aq   => { \*(Aqtype\*(Aq  => \*(Aqvegetable\*(Aq,
\&                           \*(Aqcolor\*(Aq => \*(Aqgreen\*(Aq }
\&           }
.Ve
.PP
As mentioned, the exact form of the description will be documented with
the function that is used to do the checks.
.PP
When data is passed in as a hashref, the list of elements that pass
is also a hashref with the description fully preserved.
.SH "CHECK FUNCTION"
.IX Header "CHECK FUNCTION"
All checks are performed by a function which takes a single element and
tests it to see if it passes.  It may perform only a single check on
an element, or multiple checks.
.PP
All check functions take the same set of arguments, and all return the
same set of values.
.PP
The \f(CW$check\fR argument in the \fBcheck\fR method provides a pointer to where
the check function can be found.
.PP
\&\f(CW$check\fR can be a coderef, in which case you are passing the check
function in directly.  Alternately, \f(CW$check\fR can be a string naming the
check function, or the namespace where it is found.
.PP
If \f(CW$check\fR is a string, the Data::Checker framework will look for a check
function based on that string.  As an example, if \f(CW$check\fR is \fBFoo::Bar\fR,
the following locations will be examined to see if they are a function:
.PP
.Vb 6
\&   Foo::Bar
\&   Foo::Bar::check
\&   CALLER::Foo::Bar
\&   CALLER::Foo::Bar::check
\&   Data::Checker::Foo::Bar
\&   Data::Checker::Foo::Bar::check
.Ve
.PP
where \fB\s-1CALLER\s0\fR is the package of the calling routine.  The first one
which refers to a function will be used.  The appropriate module will
be loaded as necessary.
.PP
A check function is always called as follows:
.PP
.Vb 2
\&   ($element,$err,$warn,$info) =
\&     FUNCTION($obj,$element,$description,$check_opts);
.Ve
.PP
The arguments to the check function are:
.ie n .IP "$obj" 4
.el .IP "\f(CW$obj\fR" 4
.IX Item "$obj"
\&\f(CW$obj\fR is the Data::Checker object that was created, and is passed in to
provide the check function some useful methods provided by the
framework.  These functions are described below in the
\&\*(L"\s-1CHECK FUNCTION METHODS\*(R"\s0
.ie n .IP "$element, $description" 4
.el .IP "\f(CW$element\fR, \f(CW$description\fR" 4
.IX Item "$element, $description"
\&\f(CW$element\fR is the element being tested, and \f(CW$description\fR is the description
of that element.
.Sp
If the list of elements was specified as a listref, \f(CW$element\fR will be one
value from that listref and \f(CW$description\fR will be undef.
.Sp
If the list of elements was specified as a hashref, \f(CW$element\fR will be one
of the keys from that hashref and \f(CW$description\fR will be the value of that
key.
.ie n .IP "$check_opts" 4
.el .IP "\f(CW$check_opts\fR" 4
.IX Item "$check_opts"
\&\f(CW$check_opts\fR is the hashref that was passed in to the \fBcheck\fR method
and is described in the \*(L"\s-1CHECK OPTIONS\*(R"\s0 section.
.PP
The check function always returns the following values:
.ie n .IP "$element" 4
.el .IP "\f(CW$element\fR" 4
.IX Item "$element"
This is the element that was passed in as an argument.  It must be
returned so that when parallel testing is done, the parent can easily
determine which element was being checked by a finished thread.
.ie n .IP "$err" 4
.el .IP "\f(CW$err\fR" 4
.IX Item "$err"
This is a listref of error messages.  If this is undefined or empty,
then the element passed the test.
.ie n .IP "$info, $warn" 4
.el .IP "\f(CW$info\fR, \f(CW$warn\fR" 4
.IX Item "$info, $warn"
These are listrefs of informational messages and warnings about this element.
These are optional.
.SH "CHECK OPTIONS"
.IX Header "CHECK OPTIONS"
Options may be passed in to the check function as a hashref.  The form
of the hashref (what keys/values are allowed) is documented with the
check function, but the general form is:
.PP
.Vb 2
\&   $check_opts = { GLOBAL_OPT_1 => GLOBAL_VAL_1,
\&                   GLOBAL_OPT_2 => GLOBAL_VAL_2, ...
\&
\&                   CHECK_A      => { OPT_A1 => VAL_A1,
\&                                     OPT_A2 => VAL_A2, ... }
\&                   CHECK_B      => { OPT_A1 => VAL_A1,
\&                                     OPT_A2 => VAL_A2, ... }
\&                   ... }
.Ve
.PP
There are two types of keys in \f(CW$check_opts\fR: ones which sets global
options (which apply to all possible checks that could be done), and
ones which define exactly what types of checks are performed and
options that apply only to that check.
.PP
All check specific options will override a global option.
.PP
The following options are standard:
.IP "level => err, warn, info" 4
.IX Item "level => err, warn, info"
The \fBlevel\fR option (which defaults to 'err') can be set to 'warn' or
\&'info'.  If it is, then any element which fails this check will produce
the appropriate type of message.  It will only result in a failure if
it is set to 'err'.
.IP "negate => 1" 4
.IX Item "negate => 1"
The \fBnegate\fR option can be set to negate the test (i.e. what would have
been deemed a success it actually a failure and vice versa.
.IP "message => [ \s-1STRING, STRING, ...\s0 ]" 4
.IX Item "message => [ STRING, STRING, ... ]"
The message to return if a check fails.  The string _\|_ELEMENT_\|_ will be
replaced by the element being checked.
.PP
For example, doing \s-1DNS\s0 checks, you might want to specify exactly
what server to use, and you might want to check that a host is
defined in \s-1DNS\s0 (and produce an error if it is not), and warn if it
does not have a unique \s-1IP.\s0  This might be done by passing in:
.PP
.Vb 3
\&   $check_opts = { \*(Aqnameservers\*(Aq  => \*(Aqmy.dns.server\*(Aq,
\&                   \*(Aqdns\*(Aq          => undef,
\&                   \*(Aqunique\*(Aq       => { \*(Aqlevel\*(Aq => \*(Aqwarn\*(Aq } }
.Ve
.SH "CHECK FUNCTION METHODS"
.IX Header "CHECK FUNCTION METHODS"
In addition to the base methods listed above, the Data::Checker object also
includes the following methods which are intended to be called inside a
check function.
.IP "check_performed" 4
.IX Item "check_performed"
.Vb 1
\&   $flag = $obj\->check_performed($check_opts,$label);
.Ve
.Sp
This checks \f(CW$check_opts\fR for the existance of a key named \f(CW$label\fR indicating
that that check should be performed.
.IP "check_level" 4
.IX Item "check_level"
.Vb 1
\&   $level = $obj\->check_level($check_opts [,$label]);
.Ve
.Sp
Check to see what level ('err', 'info', or 'warn') the check is.  If a check
is 'err' level, then if it fails, it produces an error.  If it is 'warn'
level, it produces a warning, but the check is marked as a passing.  If it is
\&'info', then if the check fails, it produces an informational message, but the
check is marked as passing.
.IP "check_option" 4
.IX Item "check_option"
.Vb 1
\&   $val = $obj\->check_option($check_opts,$opt [,$default [,$label]]);
.Ve
.Sp
This returns the value of the given option (\f(CW$opt\fR) for this check (\f(CW$label\fR).
.Sp
If the option is not found, \f(CW$default\fR is returned (if it is given).
.IP "check_message" 4
.IX Item "check_message"
.Vb 2
\&   $obj\->check_message($check_opts,$label,$element,$default_message,
\&                       $level,$err,$warn,$info);
.Ve
.Sp
This produces a message indicating that the check failed and stores it
in the appropriate listref.
.Sp
If the 'message' option is available, that message is used.  Otherwise,
\&\f(CW$default_message\fR will be used.
.Sp
The message can be a string or a listref (a multi-line message).  The
string _\|_ELEMENT_\|_ will be replaced by the element being tested.
.IP "check_value" 4
.IX Item "check_value"
.Vb 3
\&   $obj\->check_value($check_opts,$label,$element,$value,
\&                     $std_fail,$negate_fail,
\&                     $err,$warn,$info);
.Ve
.Sp
This will test to see if a check passed or failed.  It takes a value (\f(CW$value\fR)
and if it evaluates to true, then by default the check passes (unless the
\&'negate' option is present in which case it fails).
.Sp
The \f(CW$std_fail\fR is a message (either a string or a listref of strings) that
will be given when the check fails and the 'negate' option is not set.
\&\f(CW$negate_fail\fR is a similar message that will be given when the check fails
but the 'negate' option is set.
.Sp
\&\f(CW$err\fR, \f(CW$warn\fR, and \f(CW$info\fR are listrefs containing the messages.
.Sp
If \f(CW$err\fR is non-empty, an error has occurred.
.Sp
If the \f(CW$negate_fail\fR empty is empty, the 'negate' option will be
ignored.  This is typically used to test an element to see if it is
the right type of data for this check.  If it isn't, other types of
checks are typically not able to run.
.Sp
If \f(CW$label\fR is empty, the test is always performed.
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Data::Checker::DNS" 4
.IX Item "Data::Checker::DNS"
Predefined \s-1DNS\s0 checks.
.IP "Data::Checker::Ping" 4
.IX Item "Data::Checker::Ping"
Predefined checks to see if a host reponds to pings.
.IP "Data::Checker::IP" 4
.IX Item "Data::Checker::IP"
Predefined checks to see if an element is a valid \s-1IP.\s0
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
