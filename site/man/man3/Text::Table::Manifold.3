.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Text::Table::Manifold 3"
.TH Text::Table::Manifold 3 "2020-10-22" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Text::Table::Manifold" \- Render tables in manifold formats
.SH "Synopsis"
.IX Header "Synopsis"
This is scripts/synopsis.pl:
.PP
.Vb 1
\&        #!/usr/bin/env perl
\&
\&        use strict;
\&        use utf8;
\&        use warnings;
\&        use warnings qw(FATAL utf8); # Fatalize encoding glitches.
\&        use open     qw(:std :utf8); # Undeclared streams in UTF\-8.
\&
\&        use Text::Table::Manifold \*(Aq:constants\*(Aq;
\&
\&        # \-\-\-\-\-\-\-\-\-\-\-
\&
\&        # Set parameters with new().
\&
\&        my($table) = Text::Table::Manifold \-> new
\&        (
\&                alignment =>
\&                [
\&                        align_left,
\&                        align_center,
\&                        align_right,
\&                        align_center,
\&                ]
\&        );
\&
\&        $table \-> headers([\*(AqHomepage\*(Aq, \*(AqCountry\*(Aq, \*(AqName\*(Aq, \*(AqMetadata\*(Aq]);
\&        $table \-> data(
\&        [
\&                [\*(Aqhttp://savage.net.au/\*(Aq,   \*(AqAustralia\*(Aq, \*(AqRon Savage\*(Aq,    undef],
\&                [\*(Aqhttps://duckduckgo.com/\*(Aq, \*(AqEarth\*(Aq,     \*(AqMr. S. Engine\*(Aq, \*(Aq\*(Aq],
\&        ]);
\&
\&        # Note: Save the data, since render() may update it.
\&
\&        my(@data) = @{$table \-> data};
\&
\&        # Set parameters with methods.
\&
\&        $table \-> empty(empty_as_text);
\&        $table \-> format(format_internal_boxed);
\&        $table \-> undef(undef_as_text);
\&
\&        # Set parameters with render().
\&
\&        print "Format: format_internal_boxed: \en";
\&        print join("\en", @{$table \-> render(padding => 1)}), "\en";
\&        print "\en";
\&
\&        $table \-> headers([\*(AqOne\*(Aq, \*(AqTwo\*(Aq, \*(AqThree\*(Aq]);
\&        $table \-> data(
\&        [
\&                [\*(AqReichwaldstraße\*(Aq, \*(AqBöhme\*(Aq, \*(Aqʎ ʏ ʐ ʑ ʒ ʓ ʙ ʚ\*(Aq],
\&                [\*(AqΔΔΔΔΔΔΔΔΔΔ\*(Aq, \*(AqΠηληϊάδεω Ἀχιλῆος\*(Aq, \*(AqA snowman: ☃\*(Aq],
\&                [\*(AqTwo ticks: ✔✔\*(Aq, undef, \*(Aq<table><tr><td>TBA</td></tr></table>\*(Aq],
\&        ]);
\&
\&        # Save the data, since render() may update it.
\&
\&        @data = @{$table \-> data};
\&
\&        $table \-> empty(empty_as_minus);
\&        $table \-> format(format_internal_boxed);
\&        $table \-> undef(undef_as_text);
\&        $table \-> padding(2);
\&
\&        print "Format: format_internal_boxed: \en";
\&        print join("\en", @{$table \-> render}), "\en";
\&        print "\en";
\&
\&        # Restore the saved data.
\&
\&        $table \-> data([@data]);
\&
\&        # Etc.
.Ve
.PP
This is data/synopsis.log, the output of synopsis.pl:
.PP
.Vb 7
\&        Format: format_internal_boxed:
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        | Homepage                |  Country  |          Name | Metadata |
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        | http://savage.net.au/   | Australia |    Ron Savage |  undef   |
\&        | https://duckduckgo.com/ |   Earth   | Mr. S. Engine |  empty   |
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&
\&        Format: format_internal_boxed:
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  One              |         Two         |                                 Three  |
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  Reichwaldstraße  |        Böhme        |                       ʎ ʏ ʐ ʑ ʒ ʓ ʙ ʚ  |
\&        |  ΔΔΔΔΔΔΔΔΔΔ       |  Πηληϊάδεω Ἀχιλῆος  |                          A snowman: ☃  |
\&        |  Two ticks: ✔✔    |        undef        |  <table><tr><td>TBA</td></tr></table>  |
\&        +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
The latter table renders perfectly in \s-1FF,\s0 but not so in Chrome (today, 2015\-01\-31).
.SH "Description"
.IX Header "Description"
Outputs tables in any one of several supported types.
.PP
Features:
.IP "o Generic interface to all supported table formats" 4
.IX Item "o Generic interface to all supported table formats"
.PD 0
.IP "o Separately specify header/data/footer rows" 4
.IX Item "o Separately specify header/data/footer rows"
.IP "o Separately include/exclude header/data/footer rows" 4
.IX Item "o Separately include/exclude header/data/footer rows"
.IP "o Align cell values" 4
.IX Item "o Align cell values"
.PD
Each column has its own alignment option, left, center or right.
.Sp
For internally generated \s-1HTML,\s0 this is done with a \s-1CSS\s0 \f(CW\*(C`div\*(C'\fR within each \f(CW\*(C`td\*(C'\fR, not with the obsolete
\&\f(CW\*(C`td align\*(C'\fR attribute.
.Sp
But decimal places are not alignable, yet, as discussed in the \*(L"\s-1TODO\*(R"\s0.
.IP "o Escape \s-1HTML\s0 entities or URIs" 4
.IX Item "o Escape HTML entities or URIs"
But not both at the same time!
.IP "o Extend short header/data/footer rows with empty strings or undef" 4
.IX Item "o Extend short header/data/footer rows with empty strings or undef"
Auto-extension results in all rows being the same length.
.Sp
This takes place before the transformation, if any, mentioned next.
.IP "o Tranform cell values which are empty strings and undef" 4
.IX Item "o Tranform cell values which are empty strings and undef"
.PD 0
.IP "o Pad cell values" 4
.IX Item "o Pad cell values"
.IP "o Handle \s-1UFT8\s0" 4
.IX Item "o Handle UFT8"
.IP "o Return the table as an arrayref of lines or as a string" 4
.IX Item "o Return the table as an arrayref of lines or as a string"
.PD
The arrayref is returned by \*(L"render([%hash])\*(R", and the string by \*(L"render_as_string([%hash])\*(R".
.Sp
When returning a string by calling \f(CW\*(C`render_as_string()\*(C'\fR (which calls \f(CW\*(C`render()\*(C'\fR), you can specify
how the lines in the arrayref are joined.
.Sp
In the same way the \f(CW\*(C`format\*(C'\fR parameter discussed just below controls the output, the \f(CW\*(C`join\*(C'\fR
parameter controls the join.
.PP
The format of the output is controlled by the \f(CW\*(C`format\*(C'\fR parameter to \f(CW\*(C`new()\*(C'\fR, or by the parameter
to the \*(L"format([$format])\*(R" method, or by the value of the \f(CW\*(C`format\*(C'\fR key in the hash passed to
\&\*(L"render([%hash])\*(R" and \*(L"render_as_string(%hash])\*(R", and must be one of these imported constants:
.IP "o format_internal_boxed" 4
.IX Item "o format_internal_boxed"
All headers, footers and table data are surrounded by \s-1ASCII\s0 characters.
.Sp
The rendering is done internally.
.Sp
See scripts/internal.boxed.pl and output file data/internal.boxed.log.
.IP "o format_internal_github" 4
.IX Item "o format_internal_github"
Render as github-flavoured markdown.
.Sp
The rendering is done internally.
.Sp
See scripts/internal.github.pl and output file data/internal.github.log.
.IP "o format_internal_html" 4
.IX Item "o format_internal_html"
Render as a \s-1HTML\s0 table. You can use the \*(L"pass_thru([$hashref])\*(R" method to set options for the \s-1HTML\s0
table.
.Sp
The rendering is done internally.
.Sp
See scripts/internal.html.pl and output file data/internal.html.log.
.IP "o format_html_table" 4
.IX Item "o format_html_table"
Passes the data to HTML::Table. You can use the \*(L"pass_thru([$hashref])\*(R" method to set options
for the \f(CW\*(C`HTML::Table\*(C'\fR object constructor.
.Sp
Warning: You must use \f(CW\*(C`Text::Table::Manifold\*(C'\fR's \f(CW\*(C`data()\*(C'\fR method, or the \f(CW\*(C`data\*(C'\fR parameter to
\&\f(CW\*(C`new()\*(C'\fR, and not the \f(CW\*(C`\-data\*(C'\fR option to \f(CW\*(C`HTML::Table\*(C'\fR. This is because the module processes the
data before calling the \f(CW\*(C`HTML::Table\*(C'\fR constructor.
.IP "o format_text_csv" 4
.IX Item "o format_text_csv"
Passes the data to Text::CSV. You can use the \*(L"pass_thru([$hashref])\*(R" method to set options for
the \f(CW\*(C`Text::CSV\*(C'\fR object constructor.
.Sp
See scripts/text.csv.pl and output file data/text.csv.log.
.IP "o format_text_unicodebox_table" 4
.IX Item "o format_text_unicodebox_table"
Passes the data to Text::UnicodeBox::Table. You can use the \*(L"pass_thru([$hashref])\*(R" method to
set options for the \f(CW\*(C`Text::UnicodeBox::Table\*(C'\fR object constructor.
.Sp
See scripts/text.unicodebox.table.pl and output file data/text.unicodebox.table.log.
.PP
See also scripts/synopsis.pl, and the output data/synopsis.log.
.SH "Distributions"
.IX Header "Distributions"
This module is available as a Unix-style distro (*.tgz).
.PP
See <http://savage.net.au/Perl\-modules/html/installing\-a\-module.html>
for help on unpacking and installing distros.
.SH "Installation"
.IX Header "Installation"
Install Text::Table::Manifold as you would any \f(CW\*(C`Perl\*(C'\fR module:
.PP
Run:
.PP
.Vb 1
\&        cpanm Text::Table::Manifold
.Ve
.PP
or run:
.PP
.Vb 1
\&        sudo cpan Text::Table::Manifold
.Ve
.PP
or unpack the distro, and then either:
.PP
.Vb 4
\&        perl Build.PL
\&        ./Build
\&        ./Build test
\&        sudo ./Build install
.Ve
.PP
or:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make (or dmake or nmake)
\&        make test
\&        make install
.Ve
.SH "Constructor and Initialization"
.IX Header "Constructor and Initialization"
\&\f(CW\*(C`new()\*(C'\fR is called as \f(CW\*(C`my($parser) = Text::Table::Manifold \-> new(k1 => v1, k2 => v2, ...)\*(C'\fR.
.PP
It returns a new object of type \f(CW\*(C`Text::Table::Manifold\*(C'\fR.
.PP
Details of all parameters are explained in the \*(L"\s-1FAQ\*(R"\s0.
.PP
Key-value pairs accepted in the parameter list (see corresponding methods for details
[e.g. \*(L"data([$arrayref])\*(R"]):
.ie n .IP "o alignment => $arrayref of imported constants" 4
.el .IP "o alignment => \f(CW$arrayref\fR of imported constants" 4
.IX Item "o alignment => $arrayref of imported constants"
This specifies alignment per column. There should be one array element per column of data. The
\&\f(CW$arrayref\fR will be auto-extended if necessary, using the constant \f(CW\*(C`align_center\*(C'\fR.
.Sp
Alignment applies equally to every cell in the column.
.Sp
A value for this parameter is optional.
.Sp
Default: align_center for every column.
.ie n .IP "o data => $arrayref_of_arrayrefs" 4
.el .IP "o data => \f(CW$arrayref_of_arrayrefs\fR" 4
.IX Item "o data => $arrayref_of_arrayrefs"
This specifies the table of cell values.
.Sp
An arrayref of arrayrefs, each inner arrayref is a row of data.
.Sp
The # of elements in each alignment/header/data/footer row does not have to be the same. See the
\&\f(CW\*(C`extend*\*(C'\fR parameters for more. Auto-extension results in all rows being the same length.
.Sp
A value for this parameter is optional.
.Sp
Default: [].
.IP "o empty => An imported constant" 4
.IX Item "o empty => An imported constant"
This specifies how to transform cell values which are the empty string. See also the \f(CW\*(C`undef\*(C'\fR
parameter.
.Sp
The \f(CW\*(C`empty\*(C'\fR parameter is activated after the \f(CW\*(C`extend*\*(C'\fR parameters has been applied.
.Sp
A value for this parameter is optional.
.Sp
Default: empty_as_empty. I.e. do not transform.
.IP "o escape => An imported constant" 4
.IX Item "o escape => An imported constant"
This specifies escaping of either \s-1HTML\s0 entities or URIs.
.Sp
A value for this parameter is optional.
.Sp
Default: escape_nothing. I.e. do not transform.
.IP "o extend_data => An imported constant" 4
.IX Item "o extend_data => An imported constant"
The 2 constants available allow you to specify how short data rows are extended. Then, after
extension, the transformations specified by the parameters \f(CW\*(C`empty\*(C'\fR and \f(CW\*(C`undef\*(C'\fR are applied.
.Sp
A value for this parameter is optional.
.Sp
Default: extend_with_empty. I.e. extend short data rows with the empty string.
.IP "o extend_footers => An imported constant" 4
.IX Item "o extend_footers => An imported constant"
The 2 constants available allow you to specify how short footer rows are extended. Then, after
extension, the transformations specified by the parameters \f(CW\*(C`empty\*(C'\fR and \f(CW\*(C`undef\*(C'\fR are applied.
.Sp
A value for this parameter is optional.
.Sp
Default: extend_with_empty. I.e. extend short footer rows with the empty string.
.IP "o extend_headers => An imported constant" 4
.IX Item "o extend_headers => An imported constant"
The 2 constants available allow you to specify how short header rows are extended. Then, after
extension, the transformations specified by the parameters \f(CW\*(C`empty\*(C'\fR and \f(CW\*(C`undef\*(C'\fR are applied.
.Sp
A value for this parameter is optional.
.Sp
Default: extend_with_empty. I.e. extend short header rows with the empty string.
.ie n .IP "o footers => $arrayref" 4
.el .IP "o footers => \f(CW$arrayref\fR" 4
.IX Item "o footers => $arrayref"
These are the column footers. See also the \f(CW\*(C`headers\*(C'\fR option.
.Sp
The # of elements in each header/data/footer row does not have to be the same. See the \f(CW\*(C`extend*\*(C'\fR
parameters for more.
.Sp
A value for this parameter is optional.
.Sp
Default: [].
.IP "o format => An imported constant" 4
.IX Item "o format => An imported constant"
This specifies which format to output from the rendering methods.
.Sp
A value for this parameter is optional.
.Sp
Default: format_internal_boxed.
.ie n .IP "o headers => $arrayref" 4
.el .IP "o headers => \f(CW$arrayref\fR" 4
.IX Item "o headers => $arrayref"
These are the column headers. See also the \f(CW\*(C`footers\*(C'\fR option.
.Sp
The # of elements in each header/data/footer row does not have to be the same. See the \f(CW\*(C`extend*\*(C'\fR
parameters for more.
.Sp
A value for this parameter is optional.
.Sp
Default: [].
.IP "o include => An imported constant" 4
.IX Item "o include => An imported constant"
Controls whether header/data/footer rows are included in the output.
.Sp
The are three constants available, and any of them can be combined with '|', the logical \s-1OR\s0
operator.
.Sp
A value for this parameter is optional.
.Sp
Default: include_headers | include_data.
.ie n .IP "o join => $string" 4
.el .IP "o join => \f(CW$string\fR" 4
.IX Item "o join => $string"
\&\*(L"render_as_string([%hash])\*(R" uses \f(CW$hash\fR{join}, or \f(CW$self\fR \-> join, in Perl's
\&\f(CW\*(C`join($join, @$araref)\*(C'\fR to join the elements of the arrayref returned by internally calling
\&\*(L"render([%hash])\*(R".
.Sp
\&\f(CW\*(C`render()\*(C'\fR ignores the \f(CW\*(C`join\*(C'\fR key in the hash.
.Sp
A value for this parameter is optional.
.Sp
Default: ''.
.ie n .IP "o padding => $integer" 4
.el .IP "o padding => \f(CW$integer\fR" 4
.IX Item "o padding => $integer"
This integer is the # of spaces added to each side of the cell value, after the \f(CW\*(C`alignment\*(C'\fR
parameter has been applied.
.Sp
A value for this parameter is optional.
.Sp
Default: 0.
.ie n .IP "o pass_thru => $hashref" 4
.el .IP "o pass_thru => \f(CW$hashref\fR" 4
.IX Item "o pass_thru => $hashref"
A hashref of values to pass thru to another object.
.Sp
The keys in this \f(CW$hashref\fR control what parameters are passed to rendering routines.
.Sp
A value for this parameter is optional.
.Sp
Default: {}.
.IP "o undef => An imported constant" 4
.IX Item "o undef => An imported constant"
This specifies how to transform cell values which are undef. See also the \f(CW\*(C`empty\*(C'\fR parameter.
.Sp
The \f(CW\*(C`undef\*(C'\fR parameter is activated after the \f(CW\*(C`extend*\*(C'\fR parameters have been applied.
.Sp
A value for this parameter is optional.
.Sp
Default: undef_as_undef. I.e. do not transform.
.SH "Methods"
.IX Header "Methods"
See the \*(L"\s-1FAQ\*(R"\s0 for details of all importable constants mentioned here.
.PP
And remember, all methods listed here which are parameters to \*(L"new([%hash])\*(R", are also parameters
to both \*(L"render([%hash])\*(R" and \*(L"render_as_string([%hash])\*(R".
.SS "alignment([$arrayref])"
.IX Subsection "alignment([$arrayref])"
Here, the [] indicate an optional parameter.
.PP
Returns the alignment as an arrayref of constants, one per column.
.PP
There should be one element in \f(CW$arrayref\fR for each column of data. If the \f(CW$arrayref\fR is too short,
\&\f(CW\*(C`align_center\*(C'\fR is the default for the missing alignments.
.PP
Obviously, \f(CW$arrayref\fR might force spaces to be added to one or both sides of a cell value.
.PP
Alignment applies equally to every cell in the column.
.PP
This happens before any spaces specified by \*(L"padding([$integer])\*(R" are added.
.PP
See the \*(L"FAQ#What are the constants for alignment?\*(R" for legal values for the alignments (per
column).
.PP
\&\f(CW\*(C`alignment\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "data([$arrayref])"
.IX Subsection "data([$arrayref])"
Here, the [] indicate an optional parameter.
.PP
Returns the data as an arrayref. Each element in this arrayref is an arrayref of one row of data.
.PP
The structure of \f(CW$arrayref\fR, if provided, must match the description in the previous line.
.PP
Rows do not need to have the same number of elements.
.PP
Use Perl's \f(CW\*(C`undef\*(C'\fR or '' (the empty string) for missing values.
.PP
See \*(L"empty([$empty])\*(R" and \*(L"undef([$undef])\*(R" for how '' and \f(CW\*(C`undef\*(C'\fR are handled.
.PP
See \*(L"extend_data([$extend])\*(R" for how to extend short data rows, or let the code extend auto-extend
them.
.PP
\&\f(CW\*(C`data\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "empty([$empty])"
.IX Subsection "empty([$empty])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how empty cell values ('') are being dealt with.
.PP
\&\f(CW$empty\fR controls how empty strings in cells are rendered.
.PP
See the \*(L"FAQ#What are the constants for handling cell values which are empty strings?\*(R"
for legal values for \f(CW$empty\fR.
.PP
See also \*(L"undef([$undef])\*(R".
.PP
\&\f(CW\*(C`empty\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "escape([$escape])"
.IX Subsection "escape([$escape])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how \s-1HTML\s0 entities and URIs are being dealt with.
.PP
\&\f(CW$escape\fR controls how either \s-1HTML\s0 entities or URIs are rendered.
.PP
See the \*(L"FAQ#What are the constants for escaping \s-1HTML\s0 entities and URIs?\*(R"
for legal values for \f(CW$escape\fR.
.PP
\&\f(CW\*(C`escape\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "extend_data([$extend])"
.IX Subsection "extend_data([$extend])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how short data rows are extended.
.PP
If the # of elements in a data row is shorter than the longest row, \f(CW$extend\fR
specifies how to extend those short rows.
.PP
See the \*(L"FAQ#What are the constants for extending short rows?\*(R" for legal values for \f(CW$extend\fR.
.PP
\&\f(CW\*(C`extend_data\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "extend_footers([$extend])"
.IX Subsection "extend_footers([$extend])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how short footer rows are extended.
.PP
If the # of elements in a footer row is shorter than the longest row, \f(CW$extend\fR
specifies how to extend those short rows.
.PP
See the \*(L"FAQ#What are the constants for extending short rows?\*(R" for legal values for \f(CW$extend\fR.
.PP
\&\f(CW\*(C`extend_footers\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "extend_headers([$extend])"
.IX Subsection "extend_headers([$extend])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how short header rows are extended.
.PP
If the # of elements in a header row is shorter than the longest row, \f(CW$extend\fR
specifies how to extend those short rows.
.PP
See the \*(L"FAQ#What are the constants for extending short rows?\*(R" for legal values for \f(CW$extend\fR.
.PP
\&\f(CW\*(C`extend_headers\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "footers([$arrayref])"
.IX Subsection "footers([$arrayref])"
Here, the [] indicate an optional parameter.
.PP
Returns the footers as an arrayref of strings.
.PP
\&\f(CW$arrayref\fR, if provided, must be an arrayref of strings.
.PP
See \*(L"extend_footers([$extend])\*(R" for how to extend a short footer row, or let the code auto-extend
it.
.PP
\&\f(CW\*(C`footers\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "format([$format])"
.IX Subsection "format([$format])"
Here, the [] indicate an optional parameter.
.PP
Returns the format as a constant (actually an integer).
.PP
See the \*(L"FAQ#What are the constants for formatting?\*(R" for legal values for \f(CW$format\fR.
.PP
\&\f(CW\*(C`format\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "\fBformat_as_internal_boxed()\fP"
.IX Subsection "format_as_internal_boxed()"
Called by \*(L"render([%hash])\*(R".
.SS "\fBformat_as_internal_github()\fP"
.IX Subsection "format_as_internal_github()"
Called by \*(L"render([%hash])\*(R".
.SS "\fBformat_as_internal_html()\fP"
.IX Subsection "format_as_internal_html()"
Called by \*(L"render([%hash])\*(R".
.SS "\fBformat_as_html_table()\fP"
.IX Subsection "format_as_html_table()"
Called by \*(L"render([%hash])\*(R".
.SS "\fBformat_as_text_csv()\fP."
.IX Subsection "format_as_text_csv()."
Called by \*(L"render([%hash])\*(R".
.SS "\fBformat_as_text_unicodebox_table()\fP"
.IX Subsection "format_as_text_unicodebox_table()"
Called by \*(L"render([%hash])\*(R".
.SS "headers([$arrayref])"
.IX Subsection "headers([$arrayref])"
Here, the [] indicate an optional parameter.
.PP
Returns the headers as an arrayref of strings.
.PP
\&\f(CW$arrayref\fR, if provided, must be an arrayref of strings.
.PP
See \*(L"extend_headers([$extend])\*(R" for how to extend a short header row, or let the code auto-extend
it.
.PP
\&\f(CW\*(C`headers\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "include([$include])"
.IX Subsection "include([$include])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying if header/data/footer rows are included in the output.
.PP
See the \*(L"FAQ#What are the constants for including/excluding rows in the output?\*(R" for legal values
for \f(CW$include\fR.
.PP
\&\f(CW\*(C`include\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "join([$join])"
.IX Subsection "join([$join])"
Here, the [] indicate an optional parameter.
.PP
Returns the string used to join lines in the table when you call \*(L"render_as_string([%hash])\*(R".
.PP
\&\f(CW$join\fR is the parameter passed to the Perl function \f(CW\*(C`join()\*(C'\fR by \f(CW\*(C`render_as_string()\*(C'\fR.
.PP
Further, you can use the key \f(CW\*(C`join\*(C'\fR in \f(CW%hash\fR to pass a value directly to
\&\*(L"render_as_string([%hash])\*(R".
.SS "new([%hash])"
.IX Subsection "new([%hash])"
The constructor. See \*(L"Constructor and Initialization\*(R" for details of the parameter list.
.PP
Note: \*(L"render([%hash])\*(R" and \*(L"render_as_string([%hash])\*(R"support the same options as \f(CW\*(C`new()\*(C'\fR.
.SS "padding([$integer])"
.IX Subsection "padding([$integer])"
Here, the [] indicate an optional parameter.
.PP
Returns the padding as an integer.
.PP
Padding is the # of spaces to add to both sides of the cell value after it has been aligned.
.PP
\&\f(CW\*(C`padding\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "pass_thru([$hashref])"
.IX Subsection "pass_thru([$hashref])"
Here, the [] indicate an optional parameter.
.PP
Returns the hashref previously provided.
.PP
See \*(L"FAQ#What is the format of the \f(CW$hashref\fR used in the call to \fBpass_thru()\fR?\*(R" for details.
.PP
See scripts/html.table.pl, scripts/internal.table.pl and scripts/text.csv.pl for sample code where
it is used in various ways.
.PP
\&\f(CW\*(C`pass_thru\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "render([%hash])"
.IX Subsection "render([%hash])"
Here, the [] indicate an optional parameter.
.PP
Returns an arrayref, where each element is 1 line of the output table. These lines do not have \*(L"\en\*(R"
or any other line terminator added by this module.
.PP
It's up to you how to handle the output. The simplest thing is to just do:
.PP
.Vb 1
\&        print join("\en", @{$table \-> render}), "\en";
.Ve
.PP
Note: \f(CW\*(C`render()\*(C'\fR supports the same options as \*(L"new([%hash])\*(R".
.PP
\&\f(CW\*(C`render()\*(C'\fR ignores the \f(CW\*(C`join\*(C'\fR key in the hash.
.PP
See also \*(L"render_as_string([%hash])\*(R".
.SS "render_as_string([%hash])"
.IX Subsection "render_as_string([%hash])"
Here, the [] indicate an optional parameter.
.PP
Returns the rendered data as a string.
.PP
\&\f(CW\*(C`render_as_string\*(C'\fR uses the value of \f(CW$hash\fR{join}, or the result of calling \f(CW$self\fR \-> join, in Perl's
\&\f(CW\*(C`join($join, @$araref)\*(C'\fR to join the elements of the arrayref returned by internally calling
\&\*(L"render([%hash])\*(R".
.PP
Note: \f(CW\*(C`render_as_string()\*(C'\fR supports the same options as \*(L"new([%hash])\*(R", and passes them all to
\&\*(L"render([%hash])\*(R".
.PP
See also \*(L"render([%hash])\*(R".
.SS "undef([$undef])"
.IX Subsection "undef([$undef])"
Here, the [] indicate an optional parameter.
.PP
Returns the option specifying how undef cell values are being dealt with.
.PP
\&\f(CW$undef\fR controls how undefs in cells are rendered.
.PP
See the \*(L"FAQ#What are the constants for handling cell values which are undef?\*(R"
for legal values for \f(CW$undef\fR.
.PP
See also \*(L"empty([$empty])\*(R".
.PP
\&\f(CW\*(C`undef\*(C'\fR is a parameter to \*(L"new([%hash])\*(R". See \*(L"Constructor and Initialization\*(R".
.SS "\fBwidths()\fP"
.IX Subsection "widths()"
Returns an arrayref of the width of each column, after the data is cleaned and rectified, but before
it has been aligned or padded.
.SH "FAQ"
.IX Header "FAQ"
Note: See \*(L"\s-1TODO\*(R"\s0 for what has not been implemented yet.
.SS "How are imported constants used?"
.IX Subsection "How are imported constants used?"
Firstly, you must import them with:
.PP
.Vb 1
\&        use Text::Table::Manifold \*(Aq:constants\*(Aq;
.Ve
.PP
Then you can use them in the constructor:
.PP
.Vb 1
\&        my($table) = Text::Table::Manifold \-> new(empty => empty_as_text);
.Ve
.PP
And/or you can use them in method calls:
.PP
.Vb 1
\&        $table \-> format(format_internal_boxed);
.Ve
.PP
See scripts/synopsis.pl for various use cases.
.PP
Note how sample code uses the names of the constants. The integer values listed below are just \s-1FYI.\s0
.SS "What are the constants for alignment?"
.IX Subsection "What are the constants for alignment?"
The parameters, one per column, to \*(L"alignment([$arrayref])\*(R" must be one of the following:
.IP "o align_left  => 0" 4
.IX Item "o align_left => 0"
.PD 0
.IP "o align_center => 1" 4
.IX Item "o align_center => 1"
.PD
So-spelt. Not 'centre'.
.IP "o align_right => 2" 4
.IX Item "o align_right => 2"
.PP
Alignment applies equally to every cell in a column.
.SS "What are the constants for handling cell values which are empty strings?"
.IX Subsection "What are the constants for handling cell values which are empty strings?"
The parameter to \*(L"empty([$empty])\*(R" must be one of the following:
.IP "o empty_as_empty => 0" 4
.IX Item "o empty_as_empty => 0"
Do nothing. This is the default.
.IP "o empty_as_minus => 1" 4
.IX Item "o empty_as_minus => 1"
Convert empty cell values to '\-'.
.IP "o empty_as_text  => 2" 4
.IX Item "o empty_as_text => 2"
Convert empty cell values to the text string 'empty'.
.IP "o empty_as_undef => 3" 4
.IX Item "o empty_as_undef => 3"
Convert empty cell values to undef.
.PP
See also \*(L"undef([$undef])\*(R".
.PP
Warning: This updates the original data!
.SS "What are the constants for escaping \s-1HTML\s0 entities and URIs?"
.IX Subsection "What are the constants for escaping HTML entities and URIs?"
The parameter to \*(L"escape([$escape])\*(R" must be one of the following:
.IP "o escape_nothing => 0" 4
.IX Item "o escape_nothing => 0"
This is the default.
.IP "o escape_html    => 1" 4
.IX Item "o escape_html => 1"
Use HTML::Entities::Interpolate to escape \s-1HTML\s0 entities. \f(CW\*(C`HTML::Entities::Interpolate\*(C'\fR cannot
be loaded at runtime, and so is always needed.
.IP "o escape_uri     => 2" 4
.IX Item "o escape_uri => 2"
Use URI::Escape's \fBuri_escape()\fR method to escape URIs. \f(CW\*(C`URI::Escape\*(C'\fR is loaded at runtime
if needed.
.PP
Warning: This updates the original data!
.SS "What are the constants for extending short rows?"
.IX Subsection "What are the constants for extending short rows?"
The parameters to \*(L"extend_data([$extend])\*(R", \*(L"extend_footers([$extend])\*(R" and
\&\*(L"extend_headers([$extend])\*(R", must be one of the following:
.IP "o extend_with_empty => 0" 4
.IX Item "o extend_with_empty => 0"
Short header/data/footer rows are extended with the empty string.
.Sp
Later, the values discussed under
\&\*(L"FAQ#What are the constants for handling cell values which are empty strings?\*(R" will be applied.
.IP "o extend_with_undef => 1" 4
.IX Item "o extend_with_undef => 1"
Short header/data/footer rows are extended with undef.
.Sp
Later, the values discussed under
\&\*(L"FAQ#What are the constants for handling cell values which are undef?\*(R" will be applied.
.PP
See also \*(L"empty([$empty])\*(R" and \*(L"undef([$undef])\*(R".
.PP
Warning: This updates the original data!
.SS "What are the constants for formatting?"
.IX Subsection "What are the constants for formatting?"
The parameter to \*(L"format([$format])\*(R" must be one of the following:
.IP "o format_internal_boxed        => 0" 4
.IX Item "o format_internal_boxed => 0"
Render internally.
.IP "o format_text_csv              => 1" 4
.IX Item "o format_text_csv => 1"
Text::CSV is loaded at runtime if this option is used.
.IP "o format_internal_github       => 2" 4
.IX Item "o format_internal_github => 2"
Render internally.
.IP "o format_internal_html         => 3" 4
.IX Item "o format_internal_html => 3"
Render internally.
.IP "o format_html_table            => 4" 4
.IX Item "o format_html_table => 4"
HTML::Table is loaded at runtime if this option is used.
.IP "o format_text_unicodebox_table => 5" 4
.IX Item "o format_text_unicodebox_table => 5"
Text::UnicodeBox::Table is loaded at runtime if this option is used.
.SS "What are the constants for including/excluding rows in the output?"
.IX Subsection "What are the constants for including/excluding rows in the output?"
The parameter to \*(L"include([$include])\*(R" must be one or more of the following:
.IP "o include_data    => 1" 4
.IX Item "o include_data => 1"
Data rows are included in the output.
.IP "o include_footers => 2" 4
.IX Item "o include_footers => 2"
Footer rows are included in the output.
.IP "o include_headers => 4" 4
.IX Item "o include_headers => 4"
Header rows are included in the output.
.ie n .SS "What is the format of the $hashref used in the call to \fBpass_thru()\fP?"
.el .SS "What is the format of the \f(CW$hashref\fP used in the call to \fBpass_thru()\fP?"
.IX Subsection "What is the format of the $hashref used in the call to pass_thru()?"
It takes these (key => value) pairs:
.ie n .IP "o new => $hashref" 4
.el .IP "o new => \f(CW$hashref\fR" 4
.IX Item "o new => $hashref"
.RS 4
.PD 0
.IP "o For internal rendering of \s-1HTML\s0" 4
.IX Item "o For internal rendering of HTML"
.PD
$$hashref{table} is used to specify parameters for the \f(CW\*(C`table\*(C'\fR tag.
.Sp
Currently, \f(CW\*(C`table\*(C'\fR is the only tag supported by this mechanism.
.IP "o When using HTML::Table, for external rendering of \s-1HTML\s0" 4
.IX Item "o When using HTML::Table, for external rendering of HTML"
\&\f(CW$hashref\fR is passed to the HTML::Table constructor.
.IP "o When using Text::CSV, for external rendering of \s-1CSV\s0" 4
.IX Item "o When using Text::CSV, for external rendering of CSV"
\&\f(CW$hashref\fR is passed to the Text::CSV constructor.
.IP "o When using Text::UnicodeBox::Table, for external rendering of boxes" 4
.IX Item "o When using Text::UnicodeBox::Table, for external rendering of boxes"
\&\f(CW$hashref\fR is passed to the Text::UnicodeBox::Table constructor.
.RE
.RS 4
.RE
.PP
See html.table.pl, internal.html.pl and text.csv.pl, all in the scripts/ directory.
.SS "What are the constants for handling cell values which are undef?"
.IX Subsection "What are the constants for handling cell values which are undef?"
The parameter to \*(L"undef([$undef])\*(R" must be one of the following:
.IP "o undef_as_empty => 0" 4
.IX Item "o undef_as_empty => 0"
Convert undef cell values to the empty string ('').
.IP "o undef_as_minus => 1" 4
.IX Item "o undef_as_minus => 1"
Convert undef cell values to '\-'.
.IP "o undef_as_text  => 2" 4
.IX Item "o undef_as_text => 2"
Convert undef cell values to the text string 'undef'.
.IP "o undef_as_undef => 3" 4
.IX Item "o undef_as_undef => 3"
Do nothing.
.Sp
This is the default.
.PP
See also \*(L"empty([$undef])\*(R".
.PP
Warning: This updates the original data!
.SS "Will you extend the program to support other external renderers?"
.IX Subsection "Will you extend the program to support other external renderers?"
Possibly, but only if the extension matches the spirit of this module, which is roughly: Keep it
simple, and provide just enough options but not too many options. \s-1IOW,\s0 there is no point in passing
a huge number of options to an external class when you can use that class directly anyway.
.PP
I've looked a number of times at PDF::Table, for example, but it is just a little bit too
complex. Similarly, Text::ANSITable has too many methods.
.PP
See also \*(L"\s-1TODO\*(R"\s0.
.SS "How do I run author tests?"
.IX Subsection "How do I run author tests?"
This runs both standard and author tests:
.PP
.Vb 1
\&        shell> perl Build.PL; ./Build; ./Build authortest
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "o Fancy alignment of real numbers" 4
.IX Item "o Fancy alignment of real numbers"
It makes sense to right-justify integers, but in the rest of the table you probably want to
left-justify strings.
.Sp
Then, vertically aligning decimal points (whatever they are in your locale) is another complexity.
.Sp
See Text::ASCIITable and Text::Table.
.IP "o Embedded newlines" 4
.IX Item "o Embedded newlines"
Cell values could be split at each \*(L"\en\*(R" character, to find the widest line within the cell. That
would be then used as the cell's width.
.Sp
For Unicode, this is complex. See <http://www.unicode.org/versions/Unicode7.0.0/ch04.pdf>, and
especially p 192, for 'Line break' controls. Also, the Unicode line breaking algorithm is documented
in <http://www.unicode.org/reports/tr14/>.
.Sp
Perl modules and other links relevant to this topic are listed under \*(L"See Also#Line Breaking\*(R".
.IP "o Nested tables" 4
.IX Item "o Nested tables"
This really requires the implementation of embedded newline analysis, as per the previous point.
.IP "o Pass-thru class support" 4
.IX Item "o Pass-thru class support"
The problem is the mixture of options required to drive classes.
.IP "o Sorting the rows, or individual columns" 4
.IX Item "o Sorting the rows, or individual columns"
See Data::Table and HTML::Table.
.IP "o Color support" 4
.IX Item "o Color support"
See Text::ANSITable.
.IP "o Subtotal support" 4
.IX Item "o Subtotal support"
Maybe one day. I did see a subtotal feature in a module while researching this, but I can't find it
any more.
.Sp
See Data::Table. It has grouping features.
.SH "See Also"
.IX Header "See Also"
.SS "Table Rendering"
.IX Subsection "Table Rendering"
Any::Renderer
.PP
Data::Formatter::Text
.PP
Data::Tab
.PP
Data::Table
.PP
Data::Tabulate
.PP
Gapp::TableMap
.PP
HTML::Table
.PP
HTML::Tabulate
.PP
LaTeX::Table
.PP
PDF::Table
.PP
PDF::TableX
.PP
PDF::Report::Table
.PP
Table::Simple
.PP
Term::TablePrint
.PP
Text::ANSITable
.PP
Text::ASCIITable
.PP
Text::CSV
.PP
Text::FormatTable
.PP
Text::MarkdownTable
.PP
Text::SimpleTable
.PP
Text::Table
.PP
Text::Table::Tiny
.PP
Text::TabularDisplay
.PP
Text::Tabulate
.PP
Text::UnicodeBox
.PP
Text::UnicodeBox::Table
.PP
Text::UnicodeTable::Simple
.PP
Tie::Array::CSV
.SS "Line Breaking"
.IX Subsection "Line Breaking"
Text::Format
.PP
Text::LineFold
.PP
Text::NWrap
.PP
Text::Wrap
.PP
Text::WrapI18N
.PP
Unicode::LineBreak.
.PP
\&\s-1UNICODE LINE BREAKING ALGORITHM\s0 <http://unicode.org/reports/tr14/>
.SH "Machine-Readable Change Log"
.IX Header "Machine-Readable Change Log"
The file Changes was converted into Changelog.ini by Module::Metadata::Changes.
.SH "Version Numbers"
.IX Header "Version Numbers"
Version numbers < 1.00 represent development versions. From 1.00 up, they are production versions.
.SH "Repository"
.IX Header "Repository"
<https://github.com/ronsavage/Text\-Table\-Manifold>
.SH "Support"
.IX Header "Support"
Email the author, or log a bug on \s-1RT:\s0
.PP
<https://rt.cpan.org/Public/Dist/Display.html?Name=Text::Table::Manifold>.
.SH "Author"
.IX Header "Author"
Text::Table::Manifold was written by Ron Savage \fI<ron@savage.net.au>\fR in 2015.
.PP
Marpa's homepage: <http://savage.net.au/Marpa.html>.
.PP
My homepage: <http://savage.net.au/>.
.SH "Copyright"
.IX Header "Copyright"
Australian copyright (c) 2014, Ron Savage.
.PP
.Vb 4
\&        All Programs of mine are \*(AqOSI Certified Open Source Software\*(Aq;
\&        you can redistribute them and/or modify them under the terms of
\&        The Perl Artistic License, a copy of which is available at:
\&        https://perldoc.perl.org/perlartistic.html.
.Ve
