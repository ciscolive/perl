.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Metrics::Any::Collector 3"
.TH Metrics::Any::Collector 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Metrics::Any::Collector" \- module\-side of the monitoring metrics reporting API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   use Metrics::Any \*(Aq$metrics\*(Aq,
\&      strict => 0,
\&      name_prefix => [ \*(Aqmy_module_name\*(Aq ];
\&
\&   sub do_thing {
\&      $metrics\->inc_counter( \*(Aqthings_done\*(Aq );
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of this class provide an \s-1API\s0 for individual modules to declare
metadata about metrics they will report, and to report individual values or
observations on those metrics. An instance should be obtained for a reporting
module by the \f(CW\*(C`use Metrics::Any\*(C'\fR statement.
.PP
The collector acts primarily as a proxy for the application's configured
Metrics::Any::Adapter instance. The proxy will lazily create an adapter
when required to first actually report a metric value, but until then any
metadata stored by any of the \f(CW\*(C`make_*\*(C'\fR methods will not create one. This lazy
deferral allows a certain amount of flexibility with module load order and
application startup. By carefully writing module code to not report any values
of metrics until the main activity has actually begin, it should be possible
to allow programs to configure the metric reporting in a flexible manner
during program startup.
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
.SS "name_prefix"
.IX Subsection "name_prefix"
\&\fISince version 0.05.\fR
.PP
Optional prefix to prepend to any name provided to the \f(CW\*(C`make_*\*(C'\fR functions.
.PP
If set, this value and the registered names must be given as array references,
not simple strings.
.PP
.Vb 1
\&   use Metrics::Any \*(Aq$metrics\*(Aq, name_prefix => [qw( my_program_name )];
\&
\&   $metrics\->make_counter( events =>
\&      name => [ "events" ],
\&   );
\&
\&   # Will create a counter named ["my_program_name", "events"] formed by the
\&   # adapter.
.Ve
.SS "strict"
.IX Subsection "strict"
\&\fISince version 0.05.\fR
.PP
Optional boolean which controls whether metrics must be registered by a
\&\f(CW\*(C`make_\*(C'\fR method before they can be used (when true), or whether to attempt
lazily registering them when first encountered by a reporting method (when
false).
.PP
When strict mode is off and a reporting method (e.g. \f(CW\*(C`inc_counter\*(C'\fR) is
invoked on an unrecognised handle, it will be lazily registered. If the metric
is reported with values, an attempt is made to determine what the list of
label names is; which will depend on the form the label values are given in.
Labels passed by array reference, or by hash reference for a single label will
work fine. If a hash reference is passed with multiple keys, a warning is
printed that the order may not be reliable. Finally, for (discouraged) flat
lists of values directly it is not possible to recover label name information
so an exception is thrown.
.PP
For this reason, when operating with strict mode off, it is recommended always
to use the array reference form of supplying labels, to ensure they are
registered correctly.
.PP
In the current version this parameter defaults true, and thus all metrics must
be registered in advance. This may be changed in a future version for
convenience in smaller modules, so paranoid authors should set it explicitly:
.PP
.Vb 1
\&   use Metrics::Any::Adapter \*(Aq$metrics\*(Aq, strict => 1;
.Ve
.PP
If strict mode is switched off, it is recommended to set a name prefix to
ensure that lazily-registered metrics will at least have a useful name.
.SH "BOOLEAN OVERRIDE"
.IX Header "BOOLEAN OVERRIDE"
Instances of this class override boolean truth testing. They are usually true,
except in the case that an adapter has already been created and it is the Null
type. This allows modules to efficiently test whether to report metrics at all
by using code such as
.PP
.Vb 3
\&   if( $metrics ) {
\&      $metrics\->inc_counter( name => some_expensive_function() );
\&   }
.Ve
.PP
While the Null adapter will simply ignore any of the methods invoked on it,
without this conditional test the caller would otherwise still have to
calculate the value that won't be used. This structure allows the calculation
to be avoided if metrics are not in use.
.SH "METHODS"
.IX Header "METHODS"
.Vb 1
\&   $package = $metrics\->package
.Ve
.PP
Returns the package name that created the collector; the package in which the
.PP
.Vb 1
\&   use Metrics::Any \*(Aq$metrics\*(Aq;
.Ve
.PP
statement was invoked.
.SH "METRIC TYPES"
.IX Header "METRIC TYPES"
Each type of metric is created by one of the \f(CW\*(C`make_*\*(C'\fR methods. They all take
the following common arguments:
.IP "name => ARRAY[ \s-1STRING\s0 ] | \s-1STRING\s0" 4
.IX Item "name => ARRAY[ STRING ] | STRING"
Optional. An array of string parts, or a plain string name to use for
reporting this metric to its upstream service.
.Sp
Modules should preferrably use an array of string parts to specify their
metric names, as different adapter types may have different ways to represent
this hierarchially. Base-level parts of the name should come first, followed
by more specific parts. It is common for related metrics to be grouped by name
having identical prefixes but differing only in the final part.
.Sp
The name is optional; if unspecified then the handle will be used to form the
name, combined with a \f(CW\*(C`name_prefix\*(C'\fR argument if one was set for the package.
.IP "description => \s-1STRING\s0" 4
.IX Item "description => STRING"
Optional human-readable description. May be used for debugging or other
purposes.
.IP "labels => ARRAY[ \s-1STRING\s0 ]" 4
.IX Item "labels => ARRAY[ STRING ]"
Optional reference to an array of string names to use as label names.
.Sp
A labelled metric will expect to receive additional information in its
reporting method to give values for these labels. This information should be
in either an even-length array reference of name/value pairs, or a hash
reference. E.g.
.Sp
.Vb 2
\&   $metrics\->inc_counter( handle => [ labelname => $labelvalue ] );
\&   $metrics\->inc_counter( handle => { labelname => $labelvalue } );
.Ve
.Sp
A legacy form where a plain list of values is passed, each corresponding to a
named label in the same order, is currently accepted but discouraged in favour
of the above forms.
.Sp
.Vb 1
\&   $metrics\->inc_counter( handle => $labelvalue );
.Ve
.Sp
Note that not all metric reporting adapters may be able to represent all of
the labels. Each should document what its behaviour will be.
.SS "Counter"
.IX Subsection "Counter"
The \*(L"make_counter\*(R" method creates a new metric which counts occurances of
some event within the application. Its value begins at zero, and can be
incremented by \*(L"inc_counter\*(R" whenever the event occurs.
.PP
Some counters may simple count occurances of events, while others may count
in other units, for example counts of bytes. Adapters may make use of the
\&\f(CW\*(C`units\*(C'\fR parameter of the distribution to perform some kind of
adapter-specific behaviour. The following units are suggested:
.PP
\fIbytes\fR
.IX Subsection "bytes"
.PP
Observations give sizes in bytes (perhaps memory buffer or network message
sizes), and should be integers.
.SS "make_counter"
.IX Subsection "make_counter"
.Vb 1
\&   $collector\->make_counter( $handle, %args )
.Ve
.PP
Requests the creation of a new counter metric. The \f(CW$handle\fR name should be
unique within the collector instance, though does not need to be unique across
the entire program, as it will be namespaced by the collector instance.
.PP
The following extra arguments may be passed:
.IP "units => \s-1STRING\s0" 4
.IX Item "units => STRING"
A hint to the adapter about what kind of measurements are being observed, so
it might take specific behaviour.
.SS "inc_counter"
.IX Subsection "inc_counter"
.Vb 1
\&   $collector\->inc_counter( $handle, $labels )
.Ve
.PP
Reports that the counter metric value be incremented by one. The \f(CW$handle\fR
name must match one earlier created by \*(L"make_counter\*(R".
.SS "inc_counter_by"
.IX Subsection "inc_counter_by"
.Vb 1
\&   $collector\->inc_counter_by( $handle, $amount, $labels )
.Ve
.PP
Reports that a counter metric value be incremented by some specified value.
.SS "Distribution"
.IX Subsection "Distribution"
The \*(L"make_distribution\*(R" method creates a new metric which counts individual
observations of some numerical quantity (which may or may not be integral).
New observations can be added by the \*(L"report_distribution\*(R" method.
.PP
Some adapter types may only store an aggregated total; others may store some
sort of statistical breakdown, either total + count, or a bucketed histogram.
The specific adapter documentation should explain how it handles
distributions.
.PP
Adapters may make use of the \f(CW\*(C`units\*(C'\fR parameter of the distribution to perform
some kind of adapter-specific behaviour. The following units are suggested:
.PP
\fIbytes\fR
.IX Subsection "bytes"
.PP
Observations give sizes in bytes (perhaps memory buffer or network message
sizes), and should be integers.
.PP
\fIseconds\fR
.IX Subsection "seconds"
.PP
Observations give durations in seconds.
.SS "make_distribution"
.IX Subsection "make_distribution"
.Vb 1
\&   $collector\->make_distribution( $handle, %args )
.Ve
.PP
Requests the creation of a new distribution metric.
.PP
The following extra arguments may be passed:
.IP "units => \s-1STRING\s0" 4
.IX Item "units => STRING"
A hint to the adapter about what kind of measurements are being observed, so
it might take specific behaviour. If unspecified, a default of \f(CW\*(C`bytes\*(C'\fR will
apply.
.SS "report_distribution"
.IX Subsection "report_distribution"
.Vb 1
\&   $collector\->report_distribution( $handle, $amount, $labels )
.Ve
.PP
\&\fISince version 0.05.\fR
.PP
Reports a new observation for the distribution metric. The \f(CW$handle\fR name
must match one earlier created by \*(L"make_distribution\*(R". The \f(CW$amount\fR may
be interpreted by the adapter depending on the defined \f(CW\*(C`units\*(C'\fR type for the
distribution.
.PP
This method used to be called \f(CW\*(C`inc_distribution_by\*(C'\fR and is currently still
available as an alias.
.SS "Gauge"
.IX Subsection "Gauge"
The \*(L"make_gauge\*(R" method creates a new metric which reports on the
instantaneous value of some measurable quantity. Unlike the other metric types
this does not have to only increment forwards when certain events occur, but
can measure a quantity that may both increase and decrease over time; such as
the number some kind of object in memory, or the size of some data structure.
.PP
As an alternative to incrementing or decrementing the value when particular
events occur, the absolute value of the gauge can also be set directly.
.SS "make_gauge"
.IX Subsection "make_gauge"
.Vb 1
\&   $collector\->make_gauge( $handle, %args )
.Ve
.PP
Requests the creation of a new gauge metric.
.SS "inc_gauge"
.IX Subsection "inc_gauge"
.Vb 1
\&   $collector\->inc_gauge( $handle, $labels )
.Ve
.SS "dec_gauge"
.IX Subsection "dec_gauge"
.Vb 1
\&   $collector\->dec_gauge( $handle, $labels )
.Ve
.SS "inc_gauge_by"
.IX Subsection "inc_gauge_by"
.Vb 1
\&   $collector\->inc_gauge_by( $handle, $amount, $labels )
.Ve
.SS "dec_gauge_by"
.IX Subsection "dec_gauge_by"
.Vb 1
\&   $collector\->dec_gauge_by( $handle, $amount, $labels )
.Ve
.PP
Reports that the observed value of the gauge has increased or decreased by the
given amount (or 1).
.SS "set_gauge_to"
.IX Subsection "set_gauge_to"
.Vb 1
\&   $collector\->set_gauge_to( $handle, $amount, $labels )
.Ve
.PP
Reports that the observed value of the gauge is now the given amount.
.PP
The \f(CW$handle\fR name must match one earlier created by \*(L"make_gauge\*(R".
.SS "Timer"
.IX Subsection "Timer"
The \*(L"make_timer\*(R" method creates a new metric which measures durations of
time consumed by the application. New observations of durations can be added
by the \*(L"report_timer\*(R" method.
.PP
Timer metrics may be handled by the adapter similarly to distribution metrics.
Moreover, adapters may choose to implement timers as distributions with units
of \f(CW\*(C`seconds\*(C'\fR.
.SS "make_timer"
.IX Subsection "make_timer"
.Vb 1
\&   $collector\->make_timer( $handle, %args )
.Ve
.PP
Requests the creation of a new timer metric.
.SS "report_timer"
.IX Subsection "report_timer"
.Vb 1
\&   $collector\->report_timer( $handle, $duration, $labels )
.Ve
.PP
\&\fISince version 0.05.\fR
.PP
Reports a new duration for the timer metric. The \f(CW$handle\fR name must match
one earlier created by \*(L"make_timer\*(R". The \f(CW$duration\fR gives a time measured
in seconds, and may be fractional.
.PP
This method used to called \f(CW\*(C`inc_timer_by\*(C'\fR and is currently still available as
an alias.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
