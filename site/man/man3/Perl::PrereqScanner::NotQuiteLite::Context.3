.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Perl::PrereqScanner::NotQuiteLite::Context 3"
.TH Perl::PrereqScanner::NotQuiteLite::Context 3 "2019-08-21" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::PrereqScanner::NotQuiteLite::Context
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is typically used to keep callbacks, an eval state, and
found prerequisites for a processing file.
.SH "METHODS"
.IX Header "METHODS"
.SS "add"
.IX Subsection "add"
.Vb 2
\&  $c\->add($module);
\&  $c\->add($module => $minimum_version);
.Ve
.PP
adds a module with/without a minimum version as a requirement
or a suggestion, depending on the eval state. You can add a module
with different versions as many times as you wish. The actual
minimum version for the module is calculated inside
(by CPAN::Meta::Requirements).
.SS "register_keyword_parser, remove_keyword_parser, register_method_parser, register_sub_parser"
.IX Subsection "register_keyword_parser, remove_keyword_parser, register_method_parser, register_sub_parser"
.Vb 5
\&  $c\->register_keyword_parser(
\&    \*(Aqfunc_name\*(Aq,
\&    [$parser_class, \*(Aqparser_for_the_func\*(Aq, $used_module],
\&  );
\&  $c\->remove_keyword_parser(\*(Aqfunc_name\*(Aq);
\&
\&  $c\->register_method_parser(
\&    \*(Aqmethod_name\*(Aq,
\&    [$parser_class, \*(Aqparser_for_the_method\*(Aq, $used_module],
\&  );
.Ve
.PP
If you find a module that can export a loader function is actually
\&\f(CW\*(C`use\*(C'\fRd (such as Moose that can export an \f(CW\*(C`extends\*(C'\fR function
that will load a module internally), you might also register the
loader function as a custom keyword dynamically so that the scanner
can also run a callback for the function to parse its argument
tokens.
.PP
You can also remove the keyword when you find the module is \f(CW\*(C`no\*(C'\fRed
(and when the module supports \f(CW\*(C`unimport\*(C'\fR).
.PP
You can also register a method callback on the fly (but you can't
remove it).
.PP
If you always want to check some functions/methods when you load a
plugin, just register them using a \f(CW\*(C`register\*(C'\fR method in the plugin.
.SS "requires"
.IX Subsection "requires"
returns a CPAN::Meta::Requirements object for requirements.
.SS "suggests"
.IX Subsection "suggests"
returns a CPAN::Meta::Requirements object for suggestions
(requirements in \f(CW\*(C`eval\*(C'\fRs), or undef when it is not expected to
parse tokens in \f(CW\*(C`eval\*(C'\fR.
.SH "METHODS MOSTLY FOR INTERNAL USE"
.IX Header "METHODS MOSTLY FOR INTERNAL USE"
.SS "new"
.IX Subsection "new"
creates an instance. You usually don't need to call this because
it's automatically created in the scanner.
.SS "has_callbacks, has_callback_for, run_callback_for"
.IX Subsection "has_callbacks, has_callback_for, run_callback_for"
.Vb 3
\&  next unless $c\->has_callbacks(\*(Aquse\*(Aq);
\&  next unless $c\->has_callbacks_for(\*(Aquse\*(Aq, \*(Aqbase\*(Aq);
\&  $c\->run_callbacks_for(\*(Aquse\*(Aq, \*(Aqbase\*(Aq, $tokens);
.Ve
.PP
\&\f(CW\*(C`has_callbacks\*(C'\fR returns true if a callback for \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`no\*(C'\fR,
\&\f(CW\*(C`keyword\*(C'\fR, or \f(CW\*(C`method\*(C'\fR is registered. \f(CW\*(C`has_callbacks_for\*(C'\fR
returns true if a callback for the module/keyword/method is
registered. \f(CW\*(C`run_callbacks_for\*(C'\fR is to run the callback.
.SS "has_added"
.IX Subsection "has_added"
returns true if a module has already been added as a requirement
or a suggestion. Only useful for the ::UniversalVersion plugin.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kenichi Ishigaki, <ishigaki@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Kenichi Ishigaki.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
