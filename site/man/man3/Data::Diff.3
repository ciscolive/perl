.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Diff 3"
.TH Diff 3 "2004-10-25" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Diff \- data structure comparison module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Data::Diff qw(diff);
\&
\&        # simple procedural interface to raw difference output
\&        $out = diff( $a, $b );
\&
\&        # OO usage
\&        $diff = Data::Diff\->new( $a, $b );
\&
\&        $new = $diff\->apply();
\&        $changes = $diff\->diff_a();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::Diff computes the differences between two abirtray complex data structures.
.SH "METHODS"
.IX Header "METHODS"
.SS "Creation"
.IX Subsection "Creation"
.ie n .IP "new Data::Diff( $a, $b, $options )" 4
.el .IP "new Data::Diff( \f(CW$a\fR, \f(CW$b\fR, \f(CW$options\fR )" 4
.IX Item "new Data::Diff( $a, $b, $options )"
Creates and retruns a new Data::Diff object with the differences between \f(CW$a\fR and \f(CW$b\fR.
.SS "Access"
.IX Subsection "Access"
.ie n .IP "apply( $options )" 4
.el .IP "apply( \f(CW$options\fR )" 4
.IX Item "apply( $options )"
Returns the result of applying one side over the other.
.IP "\fBraw()\fR" 4
.IX Item "raw()"
Returns the internal data structure that describes the differences at all levels within.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP "Diff( $a, $b, $options )" 4
.el .IP "Diff( \f(CW$a\fR, \f(CW$b\fR, \f(CW$options\fR )" 4
.IX Item "Diff( $a, $b, $options )"
Compares the two arguments \f(CW$a\fR and \f(CW$b\fR and returns the raw comparison between the two.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
Nothing by default but you can choose to export the non-OO function \fBDiff()\fR.
.SH "NOTES"
.IX Header "NOTES"
.SS "Difference Description Structure"
.IX Subsection "Difference Description Structure"
The data structure returned by both the method raw and the function Diff.  follow
this same convention of metadata.  The value returned is always a hash reference
and the hash will have one or more of the following hash keys: \f(CW\*(C`type\*(C'\fR, \f(CW\*(C`same\*(C'\fR,
\&\f(CW\*(C`diff\*(C'\fR, \f(CW\*(C`diff_a\*(C'\fR, \f(CW\*(C`diff_b\*(C'\fR, \f(CW\*(C`uniq_a\*(C'\fR and \f(CW\*(C`uniq_b\*(C'\fR.
.PP
The \f(CW\*(C`type\*(C'\fR key is just a scalar string that is the data type of the sub elements
in metadata.
The data type of the values, for the other keys, depend on the input values that
were passed in via the \f(CW$a\fR and \f(CW$b\fR references.  for example if \f(CW$a\fR and \f(CW$b\fR were both
array references then all of the keys in the metadata structure will be array
references.  Recusively the elements in the array references for the \f(CW\*(C`diff\*(C'\fR key
and the \f(CW\*(C`same\*(C'\fR key will also be of the same metadata structure.  The values of
the elements in the \f(CW\*(C`diff_a\*(C'\fR, \f(CW\*(C`diff_b\*(C'\fR, \f(CW\*(C`uniq_a\*(C'\fR and \f(CW\*(C`uniq_b\*(C'\fR will not have
any metadata associated with them since they represent the orignal values from
the input.
.PP
If you thought your structure of array and hash references was a mess just wait
till this modules get ahold of it.
.SH "BUGS"
.IX Header "BUGS"
The Data::Diff does not have any way to detect a cycle in the references and will
crash if there is a loop.
.PP
The module does its best to handle things like \s-1HANDLES\s0 and \s-1CODE\s0 and \s-1LVALUES\s0 but
it might not do the best job because visiblity into those data types is poor.
.SH "AUTHOR"
.IX Header "AUTHOR"
George Campbell, <gilko@gilko.com>
.PP
Copyright (c) 1996\-98 George Campbell. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl.
