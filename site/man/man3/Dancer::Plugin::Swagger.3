.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer::Plugin::Swagger 3"
.TH Dancer::Plugin::Swagger 3 "2016-04-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::Plugin::Swagger \- create Swagger documentation of the app REST interface
.SH "VERSION"
.IX Header "VERSION"
version 0.2.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MyApp;
\&
\&    use Dancer;
\&    use Dancer::Plugin::Swagger;
\&
\&    our $VERSION = "0.1";
\&
\&    get \*(Aq/choreograph/:name\*(Aq => sub { ... };
\&
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This plugin provides tools to create and access a Swagger <http://swagger.io/> specification file for a
Dancer \s-1REST\s0 web service.
.PP
Overview of \f(CW\*(C`Dancer::Plugin::Swagger\*(C'\fR's features:
.IP "Can create a \fI/swagger.json\fR \s-1REST\s0 specification file." 4
.IX Item "Can create a /swagger.json REST specification file."
.PD 0
.IP "Can auto-discover routes and add them to the swagger file." 4
.IX Item "Can auto-discover routes and add them to the swagger file."
.IP "Can provide a Swagger \s-1UI\s0 version of the swagger documentation." 4
.IX Item "Can provide a Swagger UI version of the swagger documentation."
.PD
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.Vb 9
\&    plugins:
\&        Swagger:
\&           main_api_module: MyApp
\&           show_ui: 1
\&           ui_url: /doc
\&           ui_dir: /path/to/files
\&           auto_discover_skip:
\&            \- /swagger.json
\&            \- qr#^/doc/#
.Ve
.SS "main_api_module"
.IX Subsection "main_api_module"
If not provided explicitly, the Swagger document's title and version will be set
to the abstract and version of this module.
.PP
Defaults to the first
module to import Dancer::Plugin::Swagger.
.SS "show_ui"
.IX Subsection "show_ui"
If \f(CW\*(C`true\*(C'\fR, a route will be created for the Swagger \s-1UI\s0 (see <http://swagger.io/swagger\-ui/>).
.PP
Defaults to \f(CW\*(C`true\*(C'\fR.
.SS "ui_url"
.IX Subsection "ui_url"
Path of the swagger ui route. Will also be the prefix for all the \s-1CSS/JS\s0 dependencies of the page.
.PP
Defaults to \f(CW\*(C`/doc\*(C'\fR.
.SS "ui_dir"
.IX Subsection "ui_dir"
Filesystem path to the directory holding the assets for the Swagger \s-1UI\s0 page.
.PP
Defaults to a copy of the Swagger \s-1UI\s0 code bundled with the Dancer::Plugin::Swagger distribution.
.SS "auto_discover_skip"
.IX Subsection "auto_discover_skip"
List of urls that should not be added to the Swagger document by \f(CW\*(C`swagger_auto_discover\*(C'\fR.
If an url begins with \f(CW\*(C`qr\*(C'\fR, it will be compiled as a regular expression.
.PP
Defauls to \f(CW\*(C`/swagger.json\*(C'\fR and, if \f(CW\*(C`show_ui\*(C'\fR is \f(CW\*(C`true\*(C'\fR, all the urls under \f(CW\*(C`ui_url\*(C'\fR.
.SS "validate_response"
.IX Subsection "validate_response"
If set to \f(CW\*(C`true\*(C'\fR, calls to \f(CW\*(C`swagger_response\*(C'\fR will verify if a schema is defined 
for the response, and if so validate against it. JSON::Schema::AsType is used for the
validation (and this required if this option is used).
.PP
Defaults to \f(CW\*(C`false\*(C'\fR.
.SS "strict_validation"
.IX Subsection "strict_validation"
If set to \f(CW\*(C`true\*(C'\fR, dies if a call to \f(CW\*(C`swagger_response\*(C'\fR doesn't find a schema for its response.
.PP
Defaults to \f(CW\*(C`false\*(C'\fR.
.SH "PLUGIN KEYWORDS"
.IX Header "PLUGIN KEYWORDS"
.ie n .SS "swagger_path $description, \e%args, $route"
.el .SS "swagger_path \f(CW$description\fP, \e%args, \f(CW$route\fP"
.IX Subsection "swagger_path $description, %args, $route"
.Vb 6
\&    swagger_path {
\&        description => \*(AqReturns info about a judge\*(Aq,
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => sub {
\&        ...;
\&    };
.Ve
.PP
Registers a route as a swagger path item in the swagger document.
.PP
\&\f(CW%args\fR is optional.
.PP
The \f(CW$description\fR is optional as well, and can also be defined as part of the 
\&\f(CW%args\fR.
.PP
.Vb 5
\&    # equivalent to the main example
\&    swagger_path \*(AqReturns info about a judge\*(Aq,
\&    get \*(Aq/judge/:judge_name\*(Aq => sub {
\&        ...;
\&    };
.Ve
.PP
If the \f(CW$description\fR spans many lines, it will be left-trimmed.
.PP
.Vb 2
\&    swagger_path q{ 
\&        Returns info about a judge.
\&
\&        Some more documentation can go here.
\&
\&            And this will be seen as a performatted block
\&            by swagger.
\&    }, 
\&    get \*(Aq/judge/:judge_name\*(Aq => sub {
\&        ...;
\&    };
.Ve
.PP
\fISupported arguments\fR
.IX Subsection "Supported arguments"
.IP "method" 4
.IX Item "method"
The \s-1HTTP\s0 method (\s-1GET, POST,\s0 etc) for the path item.
.Sp
Defaults to the route's method.
.IP "path" 4
.IX Item "path"
The url for the path item.
.Sp
Defaults to the route's path.
.IP "description" 4
.IX Item "description"
The path item's description.
.IP "tags" 4
.IX Item "tags"
Optional arrayref of tags assigned to the path.
.IP "parameters" 4
.IX Item "parameters"
List of parameters for the path item. Must be an arrayref or a hashref.
.Sp
Route parameters are automatically populated. E.g.,
.Sp
.Vb 2
\&    swagger_path
\&    get \*(Aq/judge/:judge_name\*(Aq => { ... };
.Ve
.Sp
is equivalent to
.Sp
.Vb 6
\&    swagger_path {
\&        parameters => [
\&            { name => \*(Aqjudge_name\*(Aq, in => \*(Aqpath\*(Aq, required => 1, type => \*(Aqstring\*(Aq },
\&        ] 
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => { ... };
.Ve
.Sp
If the parameters are passed as a hashref, the keys are the names of the parameters, and they will
appear in the swagger document following their alphabetical order.
.Sp
If the parameters are passed as an arrayref, they will appear in the document in the order
in which they are passed. Additionally, each parameter can be given as a hashref, or can be a 
\&\f(CW\*(C`name => arguments\*(C'\fR pair.
.Sp
In both format, for the key/value pairs, a string value is considered to be the 
\&\f(CW\*(C`description\*(C'\fR of the parameter.
.Sp
Finally, if not specified explicitly, the \f(CW\*(C`in\*(C'\fR argument of a parameter defaults to \f(CW\*(C`query\*(C'\fR,
and its type to \f(CW\*(C`string\*(C'\fR.
.Sp
.Vb 4
\&    parameters => [
\&        { name => \*(Aqbar\*(Aq, in => \*(Aqpath\*(Aq, required => 1, type => \*(Aqstring\*(Aq },
\&        { name => \*(Aqfoo\*(Aq, in => \*(Aqquery\*(Aq, type => \*(Aqstring\*(Aq, description => \*(Aqyadah\*(Aq },
\&    ],
\&
\&    # equivalent arrayref with mixed pairs/non\-pairs
\&
\&    parameters => [
\&        { name => \*(Aqbar\*(Aq, in => \*(Aqpath\*(Aq, required => 1, type => \*(Aqstring\*(Aq },
\&        foo => { in => \*(Aqquery\*(Aq, type => \*(Aqstring\*(Aq, description => \*(Aqyadah\*(Aq },
\&    ],
\&
\&    # equivalent hashref format 
\&    
\&    parameters => {
\&        bar => { in => \*(Aqpath\*(Aq, required => 1, type => \*(Aqstring\*(Aq },
\&        foo => { in => \*(Aqquery\*(Aq, type => \*(Aqstring\*(Aq, description => \*(Aqyadah\*(Aq },
\&    },
\&
\&    # equivalent, using defaults
\&    parameters => {
\&        bar => { in => \*(Aqpath\*(Aq, required => 1 },
\&        foo => \*(Aqyadah\*(Aq,
\&    },
.Ve
.IP "responses" 4
.IX Item "responses"
Possible responses from the path. Must be a hashref.
.Sp
.Vb 6
\&    swagger_path {
\&        responses => {
\&            default => { description => \*(AqThe judge information\*(Aq }
\&        },
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => { ... };
.Ve
.Sp
If the key \f(CW\*(C`example\*(C'\fR is given (instead of \f(CW\*(C`examples\*(C'\fR as defined by the Swagger specs), 
and the serializer used by the application is Dancer::Serializer::JSON or Dancer::Serializer::YAML,
the example will be expanded to have the right content-type key.
.Sp
.Vb 6
\&    swagger_path {
\&        responses => {
\&            default => { example => { fullname => \*(AqMary Ann Murphy\*(Aq } }
\&        },
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => { ... };
\&
\&    # equivalent to
\&
\&    swagger_path {
\&        responses => {
\&            default => { examples => { \*(Aqapplication/json\*(Aq => { fullname => \*(AqMary Ann Murphy\*(Aq } } }
\&        },
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => { ... };
.Ve
.Sp
The special key \f(CW\*(C`template\*(C'\fR will not appear in the Swagger doc, but will be
used by the \f(CW\*(C`swagger_template\*(C'\fR plugin keyword.
.ie n .SS "swagger_template $code, $args"
.el .SS "swagger_template \f(CW$code\fP, \f(CW$args\fP"
.IX Subsection "swagger_template $code, $args"
.Vb 10
\&    swagger_path {
\&        responses => {
\&            404 => { template => sub { +{ error => "judge \*(Aq$_[0]\*(Aq not found" } }  
\&        },
\&    },
\&    get \*(Aq/judge/:judge_name\*(Aq => {  
\&        my $name = param(\*(Aqjudge_name\*(Aq);
\&        return swagger_template 404, $name unless in_db($name);
\&        ...;
\&    };
.Ve
.PP
Calls the template for the \f(CW$code\fR response, passing it \f(CW$args\fR. If \f(CW$code\fR is numerical, also set
the response's status to that value.
.SS "swagger_auto_discover skip => \e@list"
.IX Subsection "swagger_auto_discover skip => @list"
Populates the Swagger document with information of all
the routes of the application.
.PP
Accepts an optional \f(CW\*(C`skip\*(C'\fR parameter that takes an arrayref of
routes that shouldn't be added to the Swagger document. The routes
can be specified as-is, or via regular expressions. If no skip list is given, defaults to 
the c<auto_discover_skip> configuration value.
.PP
.Vb 1
\&    swagger_auto_discover skip => [ \*(Aq/swagger.json\*(Aq, qr#^/doc/# ];
.Ve
.PP
The information of a route won't be altered if it's 
already present in the document.
.PP
If a route has path parameters, they will be automatically
added as such in the \f(CW\*(C`parameters\*(C'\fR section.
.PP
Routes defined as regexes are skipped, as there is no clean way
to automatically make them look nice.
.PP
.Vb 2
\&        # will be picked up
\&    get \*(Aq/user\*(Aq => ...;
\&
\&        # ditto, as \*(Aq/user/{user_id}\*(Aq
\&    get \*(Aq/user/:user_id => ...;
\&
\&        # won\*(Aqt be picked up
\&    get qr#/user/(\ed+)# => ...;
.Ve
.PP
Note that routes defined after \f(CW\*(C`swagger_auto_discover\*(C'\fR has been called won't 
be added to the Swagger document. Typically, you'll want \f(CW\*(C`swagger_auto_discover\*(C'\fR
to be called at the very end of your module. Alternatively, \f(CW\*(C`swagger_auto_discover\*(C'\fR
can be called more than once safely \*(-- which can be useful if an application creates
routes dynamically.
.ie n .SS "swagger_definition $name => $definition, ..."
.el .SS "swagger_definition \f(CW$name\fP => \f(CW$definition\fP, ..."
.IX Subsection "swagger_definition $name => $definition, ..."
Adds a schema (or more) to the definition section of the Swagger document.
.PP
.Vb 8
\&    swagger_definition \*(AqJudge\*(Aq => {
\&        type => \*(Aqobject\*(Aq,
\&        required => [ \*(Aqfullname\*(Aq ],
\&        properties => {
\&            fullname => { type => \*(Aqstring\*(Aq },
\&            seasons => { type => \*(Aqarray\*(Aq, items => { type => \*(Aqinteger\*(Aq } },
\&        }
\&    };
.Ve
.PP
The function returns the reference to the definition that can be then used where
schemas are used.
.PP
.Vb 2
\&    my $Judge = swagger_definition \*(AqJudge\*(Aq => { ... };
\&    # $Judge is now the hashref \*(Aq{ \*(Aq$ref\*(Aq => \*(Aq#/definitions/Judge\*(Aq }\*(Aq
\&    
\&    # later on...
\&    swagger_path {
\&        responses => {
\&            default => { schema => $Judge },
\&        },
\&    },
\&    get \*(Aq/judge/:name\*(Aq => sub { ... };
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the \fIexamples/\fR directory of the distribution for a working example.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://swagger.io/|Swagger>" 4
.IX Item "<http://swagger.io/|Swagger>"
.SH "AUTHOR"
.IX Header "AUTHOR"
Yanick Champoux <yanick@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Yanick Champoux.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
