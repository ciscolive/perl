.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPIx::QuoteLike::Token 3"
.TH PPIx::QuoteLike::Token 3 "2020-10-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPIx::QuoteLike::Token \- Represent any token.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is an abstract class, and should not be instantiated by the user.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Perl module represents the base of the token hierarchy.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
\&\f(CW\*(C`PPIx::QuoteLike::Token\*(C'\fR is not descended from any other class.
.PP
\&\f(CW\*(C`PPIx::QuoteLike::Token\*(C'\fR is the parent of
PPIx::QuoteLike::Token::Control,
PPIx::QuoteLike::Token::Interpolation,
PPIx::QuoteLike::Token::String,
PPIx::QuoteLike::Token::Structure,
PPIx::QuoteLike::Token::Unknown and
PPIx::QuoteLike::Token::Whitespace.
.SH "METHODS"
.IX Header "METHODS"
This class supports the following public methods:
.SS "column_number"
.IX Subsection "column_number"
This method returns the column number of the first character in the
element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "content"
.IX Subsection "content"
.Vb 1
\& say $token\->content();
.Ve
.PP
This method returns the text that makes up the token.
.SS "error"
.IX Subsection "error"
.Vb 1
\& say $token\->error();
.Ve
.PP
This method returns the error text. This will be \f(CW\*(C`undef\*(C'\fR unless the
token actually represents an error.
.SS "line_number"
.IX Subsection "line_number"
This method returns the line number of the first character in the
element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "location"
.IX Subsection "location"
This method returns a reference to an array describing the position of
the element in the string, or \f(CW\*(C`undef\*(C'\fR if the location is unavailable.
.PP
The array is compatible with the corresponding
PPI::Element method.
.SS "logical_filename"
.IX Subsection "logical_filename"
This method returns the logical file name (taking \f(CW\*(C`#line\*(C'\fR directives
into account) of the file containing first character in the element, or
\&\f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "logical_line_number"
.IX Subsection "logical_line_number"
This method returns the logical line number (taking \f(CW\*(C`#line\*(C'\fR directives
into account) of the first character in the element, or \f(CW\*(C`undef\*(C'\fR if that
can not be determined.
.SS "parent"
.IX Subsection "parent"
.Vb 1
\& my $parent = $token\->parent();
.Ve
.PP
This method returns the token's parent, which will be the
PPIx::QuoteLike object that contains it.
.SS "next_sibling"
.IX Subsection "next_sibling"
.Vb 1
\& my $next = $token\->next_sibling();
.Ve
.PP
This method returns the token after the invocant, or nothing if there is
none.
.SS "perl_version_introduced"
.IX Subsection "perl_version_introduced"
This method returns the version of Perl in which the element was
introduced. This will be at least 5.000. Before 5.006 I am relying on
the \fIperldelta\fR, \fIperlre\fR, and \fIperlop\fR documentation, since I have
been unable to build earlier Perls. Since I have found no documentation
before 5.003, I assume that anything found in 5.003 is also in 5.000.
.PP
Since this all depends on my ability to read and understand masses of
documentation, the results of this method should be viewed with caution,
if not downright skepticism.
.PP
There are also cases which are ambiguous in various ways. For those see
\&\*(L"\s-1RESTRICTIONS\*(R"\s0 in PPIx::Regexp, and especially
\&\*(L"Changes in Syntax\*(R" in PPIx::Regexp.
.SS "perl_version_removed"
.IX Subsection "perl_version_removed"
This method returns the version of Perl in which the element was
removed. If the element is still valid the return is \f(CW\*(C`undef\*(C'\fR.
.PP
All the \fIcaveats\fR to
\&\fBperl_version_introduced()\fR apply here also,
though perhaps less severely since although many features have been
introduced since 5.0, few have been removed.
.SS "previous_sibling"
.IX Subsection "previous_sibling"
.Vb 1
\& my $prev = $token\->previous_sibling();
.Ve
.PP
This method returns the token before the invocant, or nothing if there
is none.
.SS "significant"
.IX Subsection "significant"
.Vb 2
\& $token\->significant()
\&     and say \*(Aqsignificant\*(Aq;
.Ve
.PP
This Boolean method returns a true value if the token is significant,
and a false one otherwise.
.SS "snext_sibling"
.IX Subsection "snext_sibling"
.Vb 1
\& my $next = $token\->snext_sibling();
.Ve
.PP
This method returns the significant token after the invocant, or nothing
if there is none.
.SS "sprevious_sibling"
.IX Subsection "sprevious_sibling"
.Vb 1
\& my $prev = $token\->sprevious_sibling();
.Ve
.PP
This method returns the significant token before the invocant, or
nothing if there is none.
.SS "statement"
.IX Subsection "statement"
This method returns the PPI::Statement that
contains this token, or nothing if the statement can not be
determined.
.PP
In general this method will return something only under the following
conditions:
.IP "\(bu" 4
The token is contained in a PPIx::QuoteLike object;
.IP "\(bu" 4
That object was initialized from a PPI::Element;
.IP "\(bu" 4
The PPI::Element is contained in a statement.
.SS "top"
.IX Subsection "top"
This method returns the top of the hierarchy.
.SS "variables"
.IX Subsection "variables"
.Vb 1
\& say "Interpolates $_" for $elem\->variables();
.Ve
.PP
\&\fB\s-1NOTE\s0\fR that this method is discouraged, and may well be deprecated and
removed. My problem with it is that it returns variable names rather
than PPI::Element objects, leaving you no idea how the
variables are used. It was originally written for the benefit of
Perl::Critic::Policy::Variables::ProhibitUnusedVarsStricter,
but has proven inadequate to that policy's needs.
.PP
This convenience method returns all interpolated variables. Each is
returned only once, and they are returned in no particular order.
.PP
\&\fB\s-1NOTE\s0\fR that because this class does not represent an interpolation,
this method returns nothing.
.SS "visual_column_number"
.IX Subsection "visual_column_number"
This method returns the visual column number (taking tabs into account)
of the first character in the element, or \f(CW\*(C`undef\*(C'\fR if that can not be
determined.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
PPIx::QuoteLike.
.SH "SUPPORT"
.IX Header "SUPPORT"
Support is by the author. Please file bug reports at
<https://rt.cpan.org>, or in electronic mail to the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas R. Wyant, \s-1III\s0 \fIwyant at cpan dot org\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2016\-2020 by Thomas R. Wyant, \s-1III\s0
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.10.0. For more details, see the full text
of the licenses in the directory \s-1LICENSES.\s0
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
