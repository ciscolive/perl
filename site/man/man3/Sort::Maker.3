.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sort::Maker 3"
.TH Sort::Maker 3 "2006-12-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sort::Maker \- A simple way to make efficient sort subs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Sort::Maker ;
\&
\&        my $sorter = make_sorter( ... ) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has two main goals: to make it easy to create correct sort
functions, and to make it simple to select the optimum sorting
algorithm for the number of items to be sorted. Sort::Maker generates
complete sort subroutines in one of four styles, plain, orcish
manouver, Schwartzian Transform and the Guttman-Rosler Transform. You
can also get the source for a sort sub you create via the
sorter_source call.
.ie n .SH """make_sorter"""
.el .SH "\f(CWmake_sorter\fP"
.IX Header "make_sorter"
The sub \f(CW\*(C`make_sorter\*(C'\fR is exported by Sort::Maker. It makes a sort sub
and returns a reference to it. You describe how you want it to sort
its input by passing general options and key descriptions to
\&\f(CW\*(C`make_sorter\*(C'\fR.
.ie n .SS "Arguments to ""make_sorter"""
.el .SS "Arguments to \f(CWmake_sorter\fP"
.IX Subsection "Arguments to make_sorter"
There are two types of arguments, boolean and value. Boolean arguments
can be set just with the option name and can optionally be followed by
\&'1'. You can easily set multiple boolean general arguments with
\&\fBqw()\fR. Value arguments must have a following value.  Arguments can
appear in any order but the key descriptions (see below) must appear
in their sort order. The code examples below show various ways to set
the various arguments.
.PP
Arguments fall into four categories: selecting the style of the sort,
key descriptions, setting defaults for key description attributes, and
setting general flags and values. The following sections will describe
the categories and their associated arguments.
.SS "Sort Style"
.IX Subsection "Sort Style"
The style of the sort to be made is selected by setting one of the
following Boolean arguments. Only one may be set otherwise an error
is reported (see below for error handling). Also see below for
detailed descriptions of the supported sort styles.
.PP
.Vb 4
\&        plain
\&        orcish
\&        ST
\&        GRT
\&
\&        # Make a plain sorter
\&        my $plain_sorter = make_sorter( qw( plain ) ... ) ;
\&
\&        # Make an orcish manouevre sorter
\&        my $orcish_sorter = make_sorter( orcish => 1 ... ) ;
\&
\&        # Make a Schwartzian Transform sorter
\&        my $st_sorter = make_sorter( \*(AqST\*(Aq, 1, ... ) ;
\&
\&        # Make a GRT sort
\&        my $GRT = make_sorter( \*(AqGRT\*(Aq, ... ) ;
.Ve
.SS "Key Attribute Defaults"
.IX Subsection "Key Attribute Defaults"
The following arguments set defaults for the all of the keys'
attributes.  These default values can be overridden in any individual
key.  Only one of the attributes in each of the groups below can be
set as defaults or for any given key. If more than one attribute in
each group is set, then \f(CW\*(C`make_sorter\*(C'\fR will return an error.  The
attribute that is the default for each group is marked.  See below for
details on key attributes.
.PP
.Vb 2
\&        ascending       (default)
\&        descending
\&
\&        case            (default)
\&        no_case
\&
\&        signed
\&        unsigned
\&        signed_float    (default)
\&        unsigned_float
\&
\&        fixed
\&        varying
.Ve
.SS "General Options"
.IX Subsection "General Options"
These arguments set general options that apply to how the generated
sorter interacts with the outside world.
.PP
\fI\f(CI\*(C`name\*(C'\fI\fR
.IX Subsection "name"
.PP
This is a value option which exports the generated sort sub to that
name. The call to \f(CW\*(C`make_sorter\*(C'\fR must be run to install the named
named function before it is called. You should still check the result
of \f(CW\*(C`make_sorter\*(C'\fR to see if an error occurred (it returns undef).
.PP
.Vb 2
\&        my $sorter = make_sorter( name => \*(Aqsort_func\*(Aq, ... ) ;
\&        die "make_sorter: $@" unless $sorter ;
\&
\&        ...
\&
\&        @sorted = sort_func @unsorted ;
.Ve
.PP
\fI\f(CI\*(C`ref_in/ref_out\*(C'\fI\fR
.IX Subsection "ref_in/ref_out"
.PP
This boolean arguments specifies that the input to and output from the
sort sub will be array references. \f(CW\*(C`ref_in\*(C'\fR makes the sorter only
take as input a single array reference (which contains the unsorted
records). \f(CW\*(C`ref_out\*(C'\fR makes the sorter only return a single array
reference (which contains the sorted records). You can set both of
these options in a sorter.
.PP
Note: This does not affect key extraction code which still gets each
record in \f(CW$_\fR. It only modifies the I/O of the generated sorter.
.PP
.Vb 3
\&        # input records are in an array reference
\&        my $sorter = make_sorter( qw( ref_in ), ... ) ;
\&        @sorted_array = $sorter\->( \e@unsorted_input ) ;
\&
\&        # sorted output records are in an array reference
\&        my $sorter = make_sorter( ref_out => 1, ... ) ;
\&        $sorted_array_ref = $sorter\->( @unsorted_input ) ;
\&
\&        # input and output records are in array references
\&        my $sorter = make_sorter( qw( ref_in ref_out ), ... ) ;
\&        $sorted_array_ref = $sorter\->( \e@unsorted_input ) ;
.Ve
.PP
\fI\f(CI\*(C`string_data\*(C'\fI\fR
.IX Subsection "string_data"
.PP
This boolean argument specifies that the input records will be plain
text strings with no null (0x0) bytes in them.  It is only valid for
use with the \s-1GRT\s0 and it is ignored for the other sort styles. It tells
the \s-1GRT\s0 that it can put the record directly into the string cache and
it will be separated from the packed keys with a null byte (hence that
restriction). This is an optimization that can run slightly faster
than the normal index sorting done with the \s-1GRT.\s0 Run this to see the
benchmark results.
.PP
.Vb 1
\&        perl t/string_data.t \-bench
.Ve
.PP
\fI\f(CI\*(C`init_code\*(C'\fI\fR
.IX Subsection "init_code"
.PP
This value argument is code that will be put into the beginning of the
generated sorter subroutine. It is meant to be used to declare lexical
variables that the extraction code can use. Normally different
extraction code have no way to share common code. By declaring
lexicals with the \f(CW\*(C`init_code\*(C'\fR option, some key extraction code
can save data there for use by another key. This is useful if you have
two (or more) keys that share a complex piece of code such as
accessing a deep value in a record tree.
.PP
For example, suppose the input record is an array of arrays of hashes
of strings and the string has 2 keys that need to be grabbed by a
regex. The string is a string key, a ':' and a number key. So the
common part of the key extraction is:
.PP
.Vb 1
\&        $_\->[0][0]{a}
.Ve
.PP
And the make_sorter call is:
.PP
.Vb 7
\&        my $sorter = make_sorter( 
\&                \*(AqST\*(Aq,
\&                init_code => \*(Aqmy( $str, $num ) ;\*(Aq,
\&                string => \*(Aqdo{( $str, $num ) =
\&                        $_\->[0][0]{a} =~ /^(\ew+):(\ed+)$/; $str}\*(Aq,
\&                number => \*(Aq$num\*(Aq
\&        ) ;
.Ve
.PP
In the above code both keys are extracted in the first key extraction
code and the number key is saved in \f(CW$num\fR. The second key extraction
code just uses that saved value.
.PP
Note that \f(CW\*(C`init_code\*(C'\fR is only useful in the \s-1ST\s0 and \s-1GRT\s0 sort styles as
they process all the keys of a record at one time and can use
variables declared in \f(CW\*(C`init_code\*(C'\fR to transfer data to later keys. The
plain and orcish sorts may not process a later key at the same time as
an earlier key (that only happens when the earlier key is compared to
an equal key). Also for \f(CW\*(C`init_code\*(C'\fR to be a win, the data set must be
large enough and the work to extract the keys must be hard enough for
the savings to be noticed. The test init_code.t shows some examples
and you can see the speedup when you run:
.PP
.Vb 1
\&        perl t/init_code.t \-bench
.Ve
.SS "Key Description Arguments"
.IX Subsection "Key Description Arguments"
Sorting data requires that records be compared in some way so they can
be put into a proper sequence. The parts of the records that actually
get compared are called its keys. In the simplest case the entire
record is the key, as when you sort a list of numbers or file
names. But in many cases the keys are embedded in the full record and
they need to be extracted before they can be used in comparisons.
Sort::Maker uses key descriptions that extract the key from the
record, and optional other attributes that will help optimize the
sorting operation. This section will explain how to pass key
description arguments to the make_sorter subroutine and what the
various attributes mean and how to best use them.
.PP
The generated sorter will sort the records according to the order of
the key arguments. The first key is used to compare a pair of records
and if they are deemed equal, then the next key is examined. This happens
until the records are given an ordering or you run out of keys and the
records are deemed equal in sort order.  Key descriptions can be mixed
with the other arguments which can appear in any order and anywhere in
the argument list, but the keys themselves must be in the desired
order.
.PP
A key argument is either 'string' or 'number' followed by optional
attributes. The key type sets the way that the key is compared
(e.g. using 'cmp' or '<=>').  All key attributes can be set from the
default values in the global arguments or set in each individual key
description.
.PP
There are 4 ways to provide attributes to a key:
.PP
\fINo attributes\fR
.IX Subsection "No attributes"
.PP
A key argument which is either at the end of the argument list or is
followed by a valid keyword token has no explict attributes. This key
will use the default attributes.  In both of these examples, a default
attribute was set and used by the key description which is just a
single key argument.
.PP
.Vb 2
\&        # sort the record as a single number in descending order
\&        my $sorter = make_sorter( qw( plain number descending ) ) ;
\&
\&        # sort the record as a case sensitive string
\&        my $sorter = make_sorter( qw( plain case string ) ) ;
\&
\&        # sort the record as a single number in ascending order
\&        my $sorter = make_sorter( qw( ST number ) ) ;
.Ve
.PP
\fIOnly Code as a Value\fR
.IX Subsection "Only Code as a Value"
.PP
A key argument which is followed by a scalar value which is not a
valid keyword token, will use that scalar value as its key extraction
code. See below for more on key extraction code.
.PP
.Vb 2
\&        # sort by the first (optionally signed) number matched
\&        my $sorter = make_sorter( qw( plain number /([+\-]?\ed+)/ ) ) ;
\&
\&        # string sort by the 3rd field in the input records (array refs)
\&        my $sorter = make_sorter( \*(AqST\*(Aq, string => \*(Aq$_\->[2]\*(Aq ) ;
.Ve
.PP
\fIAn Array Reference\fR
.IX Subsection "An Array Reference"
.PP
A key argument which is followed by an array reference will parse that
array for its description attributes. As with the general boolean
arguments, any boolean attribute can be optionally followed by a
\&'1'. Value attributes must be followed by their value.
.PP
.Vb 2
\&        # another way to specify the same sort as above
\&        # sort by the first (optionally signed) number matched
\&
\&        my $sorter = make_sorter(
\&                qw( plain ),
\&                number => [
\&                        code => \*(Aq/(\ed+)/\*(Aq,
\&                        \*(Aqdescending\*(Aq,
\&                ],
\&        ) ;
\&
\&        # same sort but for the GRT which uses the \*(Aqunsigned\*(Aq
\&        # attribute to optimize the sort.
\&
\&        my $sorter = make_sorter(
\&                qw( GRT ),
\&                number => [
\&                        qw( descending unsigned ),
\&                        code => \*(Aq/(\ed+)/\*(Aq,
\&                ],
\&        ) ;
.Ve
.PP
\fIA Hash Reference\fR
.IX Subsection "A Hash Reference"
.PP
A key argument which is followed a hash reference will use that hash
as its description attributes. Any boolean attribute in the hash must
have a value of '1'.  Value attributes must be followed by their
value.
.PP
.Vb 2
\&        # another way to specify the same sort as above
\&        # sort by the first (optionally signed) number matched
\&
\&        my $sorter = make_sorter(
\&                qw( plain ),
\&                number => {
\&                        code => \*(Aq/(\ed+)/\*(Aq,
\&                        descending => 1,
\&                },
\&        ) ;
\&
\&        # a multi\-key sort. the first key is a descending unsigned
\&        # integer and the second is a string padded to 10 characters
\&
\&        my $sorter = make_sorter(
\&                qw( GRT ),
\&                number => {
\&                        code => \*(Aq/(\ed+)/\*(Aq,
\&                        descending => 1,
\&                        unsigned => 1,
\&                },
\&                string => {
\&                        code => \*(Aq/FOO<(\ew+)>/\*(Aq,
\&                        fixed => 10,
\&                },
\&        ) ;
.Ve
.SS "Key Description Attributes"
.IX Subsection "Key Description Attributes"
What follows are the attributes for key descriptions. Most use 
the default values passed in the arguments to \f(CW\*(C`make_sorter\*(C'\fR.
.PP
\fI\f(CI\*(C`code\*(C'\fI\fR
.IX Subsection "code"
.PP
This value attribute is the code that will be used to extract a key
from the input record. It can be a string of Perl code, a qr// regular
expression (Regexp reference) or an anonymous sub (\s-1CODE\s0 reference)
that operates on \f(CW$_\fR and extracts a value.  The code will be wrapped in
a do{} block and called in a list context so that regular expressions
can just use () to grab a key value. The code defaults to \f(CW$_\fR which
means the entire record is used for this key. You can't set the
default for code (unlike all the other key attributes). See the
section on Extraction Code for more.
.PP
.Vb 1
\&        # make an ST sort of the first number grabbed in descending order
\&
\&        my $sorter = make_sorter(
\&                qw( ST ),
\&                number => {
\&                        code    => \*(Aq/(\ed+)/\*(Aq,
\&                        descending => 1,
\&                },
\&        ) ;
.Ve
.PP
\fI\f(CI\*(C`ascending/descending\*(C'\fI\fR
.IX Subsection "ascending/descending"
.PP
These two Boolean attributes control the sorting order for this
key. If a key is marked as \f(CW\*(C`ascending\*(C'\fR (which is the initial default
for all keys), then lower keys will sort before higher
keys. \f(CW\*(C`descending\*(C'\fR sorts have the higher keys sort before the lower
keys. It is illegal to have both set in the defaults or in any key.
.PP
.Vb 2
\&        # sort by descending order of the first grabbed number
\&        # and then sort in ascending order the first grabbed <word>
\&
\&        my $sorter = make_sorter(
\&                qw( ST descending ),
\&                number => {
\&                        code    => \*(Aq/(\ed+)/\*(Aq,
\&                },
\&                string => {
\&                        code    => \*(Aq/<(\ew+)>/\*(Aq,
\&                        ascending => 1,
\&                },
\&        ) ;
\&
\&        # this will return undef and store an error in $@. 
\&        # you can\*(Aqt have both \*(Aqascending\*(Aq and \*(Aqdescending\*(Aq as defaults
\&
\&        my $sorter = make_sorter(
\&                qw( ST ascending descending ),
\&                number => {
\&                        code    => \*(Aq/(\ed+)/\*(Aq,
\&                        descending => 1,
\&                },
\&        ) ;
\&
\&        # this will return undef and store an error in $@. 
\&        # you can\*(Aqt have both \*(Aqascending\*(Aq and \*(Aqdescending\*(Aq in a key
\&
\&        my $sorter = make_sorter(
\&                qw( ST )
\&                number => {
\&                        code    => \*(Aq/(\ed+)/\*(Aq,
\&                        descending => 1,
\&                        ascending => 1,
\&                },
\&        ) ;
.Ve
.PP
\fI\f(CI\*(C`case/no_case\*(C'\fI\fR
.IX Subsection "case/no_case"
.PP
These two Boolean attributes control how 'string' keys handle case
sensitivity. If a key is marked as \f(CW\*(C`case\*(C'\fR (which is the initial
default for all keys), then keys will treat upper and lower case
letters as different.  If the key is marked as \f(CW\*(C`no_case\*(C'\fR then they
are treated as equal.  It is illegal to have both set in the defaults
or in any key. Internally this uses the \fBuc()\fR function so you can use
locale settings to affect string sorts.
.PP
.Vb 2
\&        # sort by the first grabbed word with no case
\&        # and then sort the grabbed <word> with case
\&
\&        my $sorter = make_sorter(
\&                qw( ST no_case ),
\&                string => {
\&                        code    => \*(Aq/(\ew+)/\*(Aq,
\&                },
\&                string => {
\&                        code    => \*(Aq/<(\ew+)>/\*(Aq,
\&                        case => 1,
\&                },
\&        ) ;
\&
\&        # this will return undef and store an error in $@. 
\&        # you can\*(Aqt have both \*(Aqcase\*(Aq and \*(Aqno_case\*(Aq as defaults
\&
\&        my $sorter = make_sorter(
\&                qw( ST no_case case ),
\&                string => {
\&                        code    => \*(Aq/(\ew+)/\*(Aq,
\&                },
\&        ) ;
\&
\&        # this will return undef and store an error in $@. 
\&        # you can\*(Aqt have both \*(Aqcase\*(Aq and \*(Aqno_case\*(Aq in a key
\&
\&        my $sorter = make_sorter(
\&                qw( ST )
\&                string => {
\&                        code    => \*(Aq/(\ew+)/\*(Aq,
\&                        no_case => 1,
\&                        case    => 1,
\&                },
\&        ) ;
.Ve
.PP
\fI\f(CI\*(C`closure\*(C'\fI\fR
.IX Subsection "closure"
.PP
This Boolean attribute causes this key to use call its \s-1CODE\s0 reference
to extract its value. This is useful if you need to access a lexical
variable during the key extraction. A typical use would be if you have
a sorting order stored in a lexical and need to access that from the
extraction code. If you didn't set the \f(CW\*(C`closure\*(C'\fR attribute for this
key, the generated source (see Key Extraction) would not be able to
see that lexical which will trigger a Perl compiling error in
make_sorter.
.PP
.Vb 6
\&        my @months = qw( 
\&                January February March April May June 
\&                July August September October November December ) ;
\&        my @month_jumble = qw(
\&                February June October March January April
\&                July November August December May September ) ;
\&
\&        my %month_to_num ;
\&        @month_to_num{ @months } = 1 .. @months ;
.Ve
.PP
# this will fail to generate a sorter if 'closure' is removed
# as \f(CW%month_to_num\fR will not be in scope to the eval inside sort_maker.
.PP
.Vb 4
\&        my $sorter = make_sorter(
\&                \*(Aqclosure\*(Aq,
\&                number => sub { $month_to_num{$_} },
\&        ) ;
\&
\&        my @sorted = $sorter\->( @month_jumble ) ;
.Ve
.PP
\fI\f(CI\*(C`signed/unsigned/signed_float/unsigned_float\*(C'\fI (\s-1GRT\s0 only)\fR
.IX Subsection "signed/unsigned/signed_float/unsigned_float (GRT only)"
.PP
These Boolean attributes are only used by the \s-1GRT\s0 sort style. They are
meant to describe the type of a number key so that the \s-1GRT\s0 can best
process and cache the key's value. It is illegal to have more than one
of them set in the defaults or in any key. See the section on \s-1GRT\s0
sorting for more.
.PP
The \f(CW\*(C`signed\*(C'\fR and \f(CW\*(C`unsigned\*(C'\fR attributes mark this number key as an
integer. The \s-1GRT\s0 does the least amount of work processing an unsigned
integer and only slightly more work for a signed integer. It is worth
using these attributes if a sort key is restricted to integers.
.PP
The \f(CW\*(C`signed_float\*(C'\fR (which is the normal default for all keys) and
\&\f(CW\*(C`unsigned_float\*(C'\fR attributes mark this number key as a float. The \s-1GRT\s0
does the less work processing an unsigned float then a signed float.
It is worth using the \f(CW\*(C`unsigned_float\*(C'\fR attribute if a sort key is
restricted to non-negative values. The \f(CW\*(C`signed_float\*(C'\fR attribute is
supported to allow overriding defaults and to make it easier to
auto-generate sorts.
.PP
\fI\f(CI\*(C`fixed/varying\*(C'\fI (\s-1GRT\s0 only)\fR
.IX Subsection "fixed/varying (GRT only)"
.PP
These attributes are only used by the \s-1GRT\s0 sort style. They are used
to describe the type of a string key so that the \s-1GRT\s0 can properly
process and cache the key's value. It is illegal to have more than one
of them set in the defaults or in any key. See the section on \s-1GRT\s0
sorting for more.
.PP
\&\f(CW\*(C`fixed\*(C'\fR is a value attribute that marks this string key as always
being this length. The extracted value will either be padded with null
(0x0) bytes or truncated to the specified length (the value of
\&\f(CW\*(C`fixed\*(C'\fR). The data in this key may have embedded null bytes (0x0) and
may be sorted in descending order.
.PP
\&\f(CW\*(C`varying\*(C'\fR is a Boolean attribute marks this string key as being of
varying lengths. The \s-1GRT\s0 sorter will do a scan of all of this key's
values to find the maximum string length and then it pads all the
extracted values to that length. The data in this key may have
embedded null bytes (0x0) and may be sorted in descending order.
.SS "Key Extraction Code"
.IX Subsection "Key Extraction Code"
Each input record must have its sort keys extracted from the data.
This is the purpose of the 'code' attribute in key descriptions.  The
code has to operate on a record which is in \f(CW$_\fR and it must return
the key value. The code is executed in a list context so you can use
grabs in m// to return the key. Note that only the first grab will be
used but you shouldn't have more than one anyway. See the examples
below.
.PP
Code can be either a string, a qr// object (Regexp reference) or an
anonymous sub (\s-1CODE\s0 reference).
.PP
If qr// is used, the actual generated code will be m($qr) which works
because qr// will interpolate to its string representation. The
advantage of qr// over a string is that the qr// will be syntax
checked at compile time while the string only later when the generated
sorter is compiled by an eval.
.PP
If a \s-1CODE\s0 reference is found, it is used to extract the key in the
generated sorter. As with qr//, the advantage is that the extraction
code is syntax checked at compile time and not runtime. Also the
deparsed code is wrapped in a \f(CW\*(C`do{}\*(C'\fR block so you may use complex
code to extract the key. In the default case a \s-1CODE\s0 reference will be
deparsed by the B::Deparse module into Perl source. If the key has the
\&\f(CW\*(C`closure\*(C'\fR attribute set, the code will be called to extract the key.
.PP
The following will generate sorters with exact same behavior:
.PP
.Vb 4
\&        $sorter = make_sorter( \*(AqST\*(Aq, string => \*(Aq/(\ew+)/\*(Aq ) ;
\&        $sorter = make_sorter( \*(AqST\*(Aq, string => qr/(\ew+)/ ) ;
\&        $sorter = make_sorter( \*(AqST\*(Aq, string => sub { /(\ew+)/ } ) ;
\&        $sorter = make_sorter( \*(AqST\*(Aq, \*(Aqclosure\*(Aq, string => sub { /(\ew+)/ } ) ;
.Ve
.PP
Extraction code for a key can be set in one of three ways.
.PP
\fINo explicit code\fR
.IX Subsection "No explicit code"
.PP
If you don't pass any extraction code to a key, it will default to \f(CW$_\fR
which is the entire record. This is useful in certain cases such as in
simple sorts where you are sorting the entire record.
.PP
.Vb 2
\&        # sort numerically and in reverse order
\&        my $sorter = make_sorter( qw( plain number descending ) ;
\&
\&        # sort with case folding
\&        my $sorter = make_sorter( qw( plain no_case string ) ;
\&
\&        # sort by file time stamp and then by name
\&        my $sorter = make_sorter( \*(AqST\*(Aq, number => \*(Aq\-M\*(Aq, \*(Aqstring\*(Aq ) ;
.Ve
.PP
\fICode is the only key attribute\fR
.IX Subsection "Code is the only key attribute"
.PP
In many cases you don't need to specify any specific key attributes (the
normal or globally set defaults are fine) but you need extraction
code. If the argument that follows a key type ( 'string' or 'number' )
is not a valid keyword, it will be assumed to be the extraction code
for that key.
.PP
.Vb 2
\&        # grab the first number string as the key
\&        my $sorter = make_sorter( qw( plain number /(\ed+)/ ) ) ;
\&
\&        # no_case string sort on the 3rd\-5th chars of the 2nd array element
\&        my $sorter = make_sorter(
\&                plain   => 1,
\&                no_case => 1,
\&                string  => \*(Aqsubstr( $_\->[1], 2, 3)\*(Aq
\&        ) ;
.Ve
.PP
\fIKey needs specific attributes\fR
.IX Subsection "Key needs specific attributes"
.PP
When the key needs to have its own specific attributes other than its
code, you need to pass them in an \s-1ARRAY\s0 or \s-1HASH\s0 reference. This is
mostly needed when there are multiple keys and the defaults are not
correct for all the keys.
.PP
.Vb 2
\&        # string sort by the first 3 elements of the array record with
\&        # different case requirements
\&        
\&        my $sorter = make_sorter(
\&                ST      => 1,
\&                string  => {
\&                        code    => \*(Aq$_\->[0]\*(Aq,
\&                        no_case => 1,
\&                },
\&                string  => \*(Aq$_\->[1]\*(Aq,
\&                string  => {
\&                        code    => \*(Aq$_\->[2]\*(Aq,
\&                        no_case => 1,
\&                },
\&        ) ;
\&
\&        # GRT sort with multiple unsigned integers and padded strings
\&        # note that some keys use a hash ref and some an array ref
\&        # the record is marked with key\ed: sections
\&        my $sorter = make_sorter(
\&                GRT     => 1,
\&                descending => 1,
\&                number  => {
\&                        code    => \*(Aqkey1:(\ed+)\*(Aq,
\&                        unsigned => 1,
\&                },
\&                number  => [
\&                        code    => \*(Aqkey2:([+\-]?\ed+)\*(Aq,
\&                        qw( signed ascending ),
\&                ],
\&                string  => [
\&                        code    => \*(Aqkey3:(\ew{10})\*(Aq,
\&                        fixed => 1,
\&                        ascending => 1,
\&                ],
\&                # pad the extracted keys to 8 chars
\&                string  => {
\&                        code    => \*(Aqkey4:([A\-Z]+)\*(Aq,
\&                        pad => 8,
\&                },
\&        ) ;
.Ve
.SH "Key Caching"
.IX Header "Key Caching"
A good question to ask is \*(L"What speed advantages do you get from this
module when all the sorts generated use Perl's internal sort function?\*(R"
The sort function has a O( N * log N ) growth function which means that
the amount of work done increases by that formula as N (the number of
input records) increases. In a plain sort this means the the key
extraction code is executed N * log N times when you only have N
records. That can be a very large waste of cpu time. So the other three
sort styles speed up the overall sort by only executing the extraction
code N times by caching the extracted keys. How they cache the keys is
their primary difference. To compare or study the actual code generated
for the different sort styles, you can run make_sorter and just change
the style. Then call sorter_source (not exported by default) and pass it
the sort code reference returned by make_sorter. It will return the
generated sort source.
.ie n .SS """plain"""
.el .SS "\f(CWplain\fP"
.IX Subsection "plain"
Plain sorting doesn't do any key caching. It is fine for short input
lists (see the Benchmark section) and also as a way to see how much \s-1CPU\s0
is saved when using one of the other styles.
.ie n .SS """orcish"""
.el .SS "\f(CWorcish\fP"
.IX Subsection "orcish"
The Orcish maneuvre (created by Joseph Hall) caches the extracted keys
in a hash. It does this with code like this:
.PP
.Vb 1
\&        $cache{$a} ||= CODE($a) ;
.Ve
.PP
\&\s-1CODE\s0 is the extract code and it operates on a record in \f(CW$a\fR. If we have
never seen this record before then the cache entry will be undef and the
||= operator will assign the extracted key to that hash slot. The next
time this record is seen in a comparison, the saved extracted key will
be found in the hash and used. The name orcish comes from OR-cache.
.ie n .SS """ST"""
.el .SS "\f(CWST\fP"
.IX Subsection "ST"
The \s-1ST\s0 (Schwartzian Transform and popularized by Randal Schwartz) uses
an anonymous array to store the record and its extracted keys. It
first executes a map that creates an anonymous array:
.PP
.Vb 1
\&        map [ $_, CODE1( $_ ), CODE2( $_ ) ], @input
.Ve
.PP
The \s-1CODE\s0's extract the set of keys from the record but only once per
record so it is O(N). Now the sort function can just do the comparisons
and it returns a list of sorted anonymous arrays.
.PP
.Vb 5
\&        sort {
\&                $a\->[1] cmp $b\->[1]
\&                        ||
\&                $a\->[2] cmp $b\->[2]
\&        }
.Ve
.PP
Finally, we need to get back the original records which are in the first
slot of the anonymous array:
.PP
.Vb 1
\&        map $_\->[0]
.Ve
.PP
This is why the \s-1ST\s0 is known as a map/sort/map technique.
.ie n .SS """GRT"""
.el .SS "\f(CWGRT\fP"
.IX Subsection "GRT"
The Guttman-Rosler Transform (popularized by Uri Guttman and Larry
Rosler) uses a string to cache the extracted keys as well as either
the record or its index. It is also a map/sort/map technique but
because its cache is a string, it can be sorted without any Perl level
callback (the {} block passed to sort). This is a signifigant win
since that callback is running O( N log N). But this speedup comes at
a cost of complexity. You can't just join the keys into a string and
properly sort them. Each key may need to be processed so that it will
correctly sort in order and it doesn't interfere with other keys. That
is why the \s-1GRT\s0 has several key attributes to enable it to properly and
efficiently pack the sort keys into a single string. The following
lists the \s-1GRT\s0 key attributes, when you need them and what key
processing is done for each.  Note that you can always enable the \s-1GRT\s0
specific attributes as they are just ignored by the other sort styles.
.PP
The \s-1GRT\s0 gains its speed by using a single byte string to cache all of
the extracted keys from a given input record. Packing keys into a
string such that it will lexically sort the correct way requires some
deep mojo and data munging. But that is why this module was written \-
to hide all that from the coder. Below are descriptions of how the
various key types are packed and how to best use the \s-1GRT\s0 specific key
attributes.  Note: you can only use one of the \s-1GRT\s0 number or string
attributes for any key. Setting more than one in either the defaults
or in any given key is an error (a key's attribute can override a
default choice).
.PP
\fI\f(CI\*(C`unsigned\*(C'\fI\fR
.IX Subsection "unsigned"
.PP
The 'unsigned' Boolean attribute tells the \s-1GRT\s0 that this number key is a
non-negative integer. This allows the \s-1GRT\s0 to just pack it into 4 bytes
using the N format (network order \- big endian). An integer packed this
way will have its most significant bytes compared before its least
signifigant bytes. This involves the least amount of key munging and so
it is the most efficient way to sort numbers in the \s-1GRT.\s0
.PP
If you want this key to sort in descending order, then the key value is
negated and normalized (see the 'signed' attribute) so there is no
advantage to using 'unsigned'.
.PP
\fI\f(CI\*(C`signed\*(C'\fI\fR
.IX Subsection "signed"
.PP
The 'signed' Boolean attribute tells the \s-1GRT\s0 that this number key is
an integer. This allows the \s-1GRT\s0 to just pack it into 4 bytes using the
N format (network order \- big endian).  The key value must first be
normalized which will convert it to an unsigned integer but with the
same ordering as a signed integer. This is simply done by inverting
the sign (highest order) bit of the integer. As mentioned above, when
sorting this key in descending order, the \s-1GRT\s0 just negates the key
value.
.PP
\&\s-1NOTE:\s0 In the \s-1GRT\s0 the signed and unsigned integer attributes only work
on perl built with 32 bit integers. This is due to using the N format
of pack which is specified to be 32 bits. A future version may support
64 bit integers (anyone want to help?).
.PP
\fI\f(CI\*(C`unsigned_float\*(C'\fI\fR
.IX Subsection "unsigned_float"
.PP
The 'unsigned_float' Boolean attribute tells the \s-1GRT\s0 that this number
key is a non-negative floating point number. This allows the \s-1GRT\s0 to
pack it into 8 bytes using the 'd' format. A float packed this way
will have its most significant bytes compared before its least
signifigant bytes.
.PP
\fI\f(CI\*(C`signed_float\*(C'\fI\fR
.IX Subsection "signed_float"
.PP
The \f(CW\*(C`signed_float\*(C'\fR Boolean attribute (which is the default for all
number keys when using the \s-1GRT\s0) tells the \s-1GRT\s0 that this number key is
a floating point number. This allows the \s-1GRT\s0 to pack it into 8 bytes
using the 'd' format. A float packed this way will have its most
significant bytes compared before its least signifigant bytes. When
processed this key will be normalized to an unsigned float similar to
to the \f(CW\*(C`signed\*(C'\fR to \f(CW\*(C`unsigned\*(C'\fR conversion mentioned above.
.PP
\&\s-1NOTE:\s0 The \s-1GRT\s0 only works with floats that are in the \s-1IEEE\s0 format for
doubles. This includes most modern architectures including x86, sparc,
powerpc, mips, etc. If the cpu doesn't have \s-1IEEE\s0 floats you can either
use the integer attributes or select another sort style (all the
others have no restriction on float formats).
.PP
\fIsimple string.\fR
.IX Subsection "simple string."
.PP
If a string key is being sorted in ascending order with the \s-1GRT\s0 and it
doesn't have one of the \s-1GRT\s0 string attributes, it will be packed
without any munging and a null (0x0) byte will be appended to it. This
byte enables a shorter string to sort before longer ones that start
with the shorter string.
.PP
\&\s-1NOTE:\s0 You cannot sort strings in descending order in the \s-1GRT\s0 unless
the key has either the 'fixed' or 'varying' attributes set. Also, if a
string is being sorted in ascending order but has any null (0x0) bytes
in it, the key must have one of those attributes set.
.PP
\fI\f(CI\*(C`fixed\*(C'\fI\fR
.IX Subsection "fixed"
.PP
This value attribute tells the \s-1GRT\s0 to pack this key value as a fixed
length string. The extracted value will either be padded with null
(0x0) bytes or truncated to the specified length (the value of the
\&\f(CW\*(C`fixed\*(C'\fR attribute). This means it can be packed into the cache string
with no padding and no trailing null byte is needed. The key can
contain any data including null (0x0) bytes. Data munging
happens only if the key's sort order is descending. Then the key value is
xor'ed with a same length string of 0xff bytes. This toggles each bit
which allows for a lexical comparison but in the reverse order. This
same bit inversion is used for descending varying strings.
.PP
\fI\f(CI\*(C`varying\*(C'\fI\fR
.IX Subsection "varying"
.PP
This Boolean attribute tells the \s-1GRT\s0 that this key value is a varying length
string and has no predetermined padding length. A prescan is done to
determine the maximum string length for this key and that is used as the
padding length. The rest is the same as with the 'fixed' attribute.
.ie n .SS """sorter_source"""
.el .SS "\f(CWsorter_source\fP"
.IX Subsection "sorter_source"
This sub (which can be exported) returns the source of a generated
sort sub or the source of the last one that had an error. To get the
source of an existing sort sub, pass it a reference to that sub (i.e.
the reference returned from make_sorter). To get the source for a
failed call to make_sorter, don't pass in any arguments.
.PP
.Vb 2
\&        my $sorter = make_sorter( ... ) ;
\&        print sorter_source( $sorter ) ;
\&
\&        make_sorter( name => \*(Aqmy_sorter\*(Aq, ... ) ;
\&        print sorter_source( \e&my_sorter ) ;
\&
\&        my $sorter = make_sorter( ... ) 
\&                or die "make_sorter error: $@\en", sorter_source();
.Ve
.PP
If all you want is the generated source you can just do:
.PP
.Vb 1
\&        print sorter_source make_sorter( ... ) ;
.Ve
.SS "Error Handling"
.IX Subsection "Error Handling"
When \f(CW\*(C`make_sorter\*(C'\fR detects an error (either bad arguments or when the
generated sorter won't compile), it returns undef and set $@ to an
error message. The error message will include the generated source and
compiler and warning errors if the sorter didn't compile correctly.
The test t/errors.t covers all the possible error messages.  You can
also retrieve the generated source after a compiling error by calling
\&\f(CW\*(C`sorter_source\*(C'\fR.
.SH "TESTS"
.IX Header "TESTS"
\&\f(CW\*(C`Sort::Maker\*(C'\fR uses a table of test configurations that can both run
tests and benchmarks. Each test script is mostly a table that
generates multiple versions of the sorters, generate sample data and
compares the sorter results with a sort that is known to be good. If
you run the scripts directly and with a \-bench argument, then they
generate the same sorter subs and benchmark them. This design ensures
that benchmarks are running on correctly generated code and it makes
it very easy to add more test and benchmark variations. The code that
does all the work is in t/common.pl. Here is a typical test table
entry:
.PP
.Vb 10
\&        {
\&                skip    => 0,
\&                source  => 0,
\&                name    => \*(Aqinit_code\*(Aq,
\&                gen     => sub { rand_choice( @string_keys ) . \*(Aq:\*(Aq .
\&                                 rand_choice( @number_keys ) },
\&                gold    => sub {
\&                         ($a =~ /^(\ew+)/)[0] cmp ($b =~ /^(\ew+)/)[0]
\&                                        ||
\&                         ($a =~ /(\ed+$)/)[0] <=> ($b =~ /(\ed+$)/)[0] 
\&                },
\&                args    => [
\&                        init_code => \*(Aqmy( $str, $num ) ;\*(Aq,
\&                        string => \*(Aqdo{( $str, $num ) = /^(\ew+):(\ed+)$/; $str}\*(Aq,
\&                        number => \*(Aq$num\*(Aq,
\&                ],
\&        },
.Ve
.PP
\&\f(CW\*(C`skip\*(C'\fR is a boolean that causes this test/benchmark to be skipped.
Setting \f(CW\*(C`source\*(C'\fR causes the sorter's source to be printed out.
\&\f(CW\*(C`gen\*(C'\fR is a sub that generates a single input record. There are
support subs in t/common.pl that will generate random data. Some tests
have a \f(CW\*(C`data\*(C'\fR field which is fixed data for a test (instead of the
generated data). The <gold> field is a comparision subroutine usable
by the sort function. It is used to sort the test data into a golden
result which is used to compare against all the generated sorters.
\&\f(CW\*(C`args\*(C'\fR is an anonymous array of arguments for a sorter or a hash ref
with multiple named/args pairs. See t/io.t for an example of that.
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
.SH "EXPORT"
.IX Header "EXPORT"
This module always exports the \f(CW\*(C`make_sorter\*(C'\fR sub.  It can also
optionally export \f(CW\*(C`sorter_source\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Sort::Maker \s-1GRT\s0 currently works only with 32 bit integers due to pack
N format being exactly 32 bits. If someone with a 64 bit Perl wants to
work on using the Q format or the ! suffix and dealing with endian
issues, I will be glad to help and support it. It would be best if
there was a network (big endian) pack format for quads/longlongs but
that can be done similarly to how floats are packed now.
.SH "AUTHOR"
.IX Header "AUTHOR"
Uri Guttman, <uri@stemsystems.com>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
I would like to thank the inimitable Damian Conway for his help in the
\&\s-1API\s0 design, the \s-1POD,\s0 and for being a good Perl friend.
.PP
And thanks to Boston.pm for the idea of allowing qr// for key
extraction code.
