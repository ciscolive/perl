.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Spreadsheet::WriteExcel::Styler 3"
.TH Spreadsheet::WriteExcel::Styler 3 "2020-08-19" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::WriteExcel::Styler \- Styles for formatting generated Excel files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Spreadsheet::WriteExcel; # or use Excel::Writer::XLSX
\&  use Spreadsheet::WriteExcel::Styler;
\&
\&  # Create an Excel workbook and worksheet
\&  my $workbook = Spreadsheet::WriteExcel\->new(\*(Aqoutput.xls\*(Aq);
\&               # or Excel::Writer::XLSX\->new(\*(Aqoutput.xls\*(Aq);
\&  $worksheet = $workbook\->add_worksheet();
\&
\&  # Create a styler with some styles 
\&  my $styler = Spreadsheet::WriteExcel::Styler\->new($workbook);
\&  $styler\->add_styles(
\&    title        => {align       => "center",
\&                     border      => 1,
\&                     bold        => 1,
\&                     color       => \*(Aqwhite\*(Aq,
\&                     bg_color    => \*(Aqblue\*(Aq},
\&    right_border => {right       => 6,         # double line
\&                     right_color => \*(Aqblue\*(Aq},
\&    highlighted  => {bg_color    => \*(Aqsilver\*(Aq},
\&    rotated      => {rotation    => 90},
\&  );
\&
\&  # Write data into a cell, with a list of cumulated styles
\&  $worksheet\->write($row, $col, $data, 
\&                    $styler\->(qw/highlighted right_border/));
\&
\&  # same thing, but styles are expressed as toggles in a hashref
\&  $worksheet\->write($row, $col, $data,
\&                    $styler\->({ highlighted  => 1,
\&                                rotated      => 0,
\&                                right_border => should_border($row, $col) }));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a small utility to help formatting cells while
creating Excel workbooks through Spreadsheet::WriteExcel
or Excel::Writer::XLSX.
.PP
When working interactively within the Excel application, users often
change one format feature at a time (highlight a row, add a border to
a column, etc.); these changes do not affect other format features
(for example if you change the background color, it does not affect
fonts, borders, or cell alignment).  By contrast, when generating a
workbook programmatically through Spreadsheet::WriteExcel or
Excel::Writer::XLSX, formats express complete sets of features, and
they cannot be combined together. This means that the programmer has
to prepare in advance all formats for all possible combinations of
format features, and has to invent a way of cataloguing those
combinations.
.PP
Styler objects from the current module come to the rescue: they hold a
catalogue of \fIstyles\fR, where each style is a collection of format
features.  Then, for any combination of styles, the styler generates a
Spreadsheet::WriteExcel::Format or Excel::Writer::XLSX::Format
on the fly, or, if a similar combination was already encountered,
retrieves the format from its internal cache.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
.Vb 1
\&  my $styler = Spreadsheet::WriteExcel::Styler\->new($workbook);
.Ve
.PP
Creates a styler object, associated to a given workbook.
.ie n .SS """add_styles"""
.el .SS "\f(CWadd_styles\fP"
.IX Subsection "add_styles"
.Vb 5
\&  $styler\->add_styles(
\&    $style_name_1 => \e%format_properties_1,
\&    $style_name_2 => \e%format_properties_2,
\&    ...
\&   );
.Ve
.PP
Defines a number of styles within the styler. Each style has a name
and a hashref containing format properties (like for 
\&\f(CW\*(C`Spreadsheet::WriteExcel\*(C'\fR's
add_format method).
.ie n .SS """format"" or function dereferencing operator"
.el .SS "\f(CWformat\fP or function dereferencing operator"
.IX Subsection "format or function dereferencing operator"
.Vb 5
\&  # explicit calls to the \*(Aqformat()\*(Aq method
\&  my $format = $styler\->format($style_name_1, $style_name_2, ...);
\&  my $format = $styler\->format({$style_name_1 => $toggle_1,
\&                                $style_name_2 => $toggle_2,
\&                                ...});
\&
\&  # same as above, but in shorthand notation
\&  my $format = $styler\->($style_name_1, $style_name_2, ...);
\&  my $format = $styler\->({$style_name_1 => $toggle_1,
\&                          $style_name_2 => $toggle_2,
\&                          ...});
.Ve
.PP
The \f(CW\*(C`format\*(C'\fR method can be invoked either as a regular method call,
or, in shorthand notation, as a simple coderef call (arrow operator and
parentheses). It returns a \f(CW\*(C`Format\*(C'\fR object,
either retrieved from cache, or created on the fly, that can then be
passed as argument to any of the worksheet's write methods.
.PP
Arguments to \f(CW\*(C`format()\*(C'\fR can be either :
.IP "\(bu" 4
a list of style names
.IP "\(bu" 4
a single arrayref containing a list of style names
.IP "\(bu" 4
a single hashref where keys are style names and values
are boolean toggles that specify whether that style should
be applied or not
.PP
The array form is useful when one knows statically the list
of styles to apply. The hashref form is useful when decisions
about styles depend on the context, as for example in :
.PP
.Vb 5
\&  my $format = $styler\->({
\&    highlighted  => ($row % 2),
\&    right_border => $is_end_of_group{$col},
\&    emphasized   => is_very_important($data),
\&   });
.Ve
.ie n .SS """workbook"""
.el .SS "\f(CWworkbook\fP"
.IX Subsection "workbook"
Returns the workbook to which this styler is bound.
.ie n .SS """styles"""
.el .SS "\f(CWstyles\fP"
.IX Subsection "styles"
Returns the list of style names defined in this styler.
.ie n .SS """style"""
.el .SS "\f(CWstyle\fP"
.IX Subsection "style"
.Vb 1
\&  my $props_hashref = $styler\->style($style_name);
.Ve
.PP
Returns the hashref of format properties that were defined
for the given \f(CW$style_name\fR through a previous call to the
\&\*(L"add_styles\*(R" method.
.SH "AUTHOR"
.IX Header "AUTHOR"
Laurent Dami, \f(CW\*(C`<laurent.dami AT etat ge ch>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-spreadsheet\-writeexcel\-styler at rt.cpan.org\*(C'\fR, or through the
web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Spreadsheet\-WriteExcel\-Styler>.
I will be notified, and then you'll automatically be notified of
progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Spreadsheet::WriteExcel::Styler
.Ve
.PP
You can also look for information at:
.IP "\s-1RT: CPAN\s0's request tracker" 4
.IX Item "RT: CPAN's request tracker"
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Spreadsheet\-WriteExcel\-Styler>
.IP "AnnoCPAN: Annotated \s-1CPAN\s0 documentation" 4
.IX Item "AnnoCPAN: Annotated CPAN documentation"
<http://annocpan.org/dist/Spreadsheet\-WriteExcel\-Styler>
.IP "\s-1CPAN\s0 Ratings" 4
.IX Item "CPAN Ratings"
<http://cpanratings.perl.org/d/Spreadsheet\-WriteExcel\-Styler>
.IP "\s-1METACPAN\s0" 4
.IX Item "METACPAN"
<https://metacpan.org/dist/Spreadsheet\-WriteExcel\-Styler/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to John McNamara and to all other contributors for
the wonderful Spreadsheet::WriteExcel 
and Excel::Writer::XLSX modules.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2010, 2012 Laurent Dami.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See <http://dev.perl.org/licenses/> for more information.
