.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Trie 3"
.TH Trie 3 "2011-12-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree::Trie \- A data structure optimized for prefix lookup.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Tree::Trie;
\& use strict;
\&
\& my($trie) = new Tree::Trie;
\& $trie\->add(qw[aeode calliope clio erato euterpe melete melpomene mneme 
\&   polymnia terpsichore thalia urania]);
\& my(@all) = $trie\->lookup("");
\& my(@ms)  = $trie\->lookup("m");
\& $" = "\-\-";
\& print "All muses: @all\enMuses beginning with \*(Aqm\*(Aq: @ms\en";
\& my(@deleted) = $trie\->remove(qw[calliope thalia doc]);
\& print "Deleted muses: @deleted\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a trie data structure.  The term \*(L"trie\*(R" comes from the
word re\fBtrie\fRval, but is generally pronounced like \*(L"try\*(R".  A trie is a tree
structure (or directed acyclic graph), the nodes of which represent letters 
in a word.  For example, the final lookup for the word 'bob' would look 
something like \f(CW\*(C`$ref\->{\*(Aqb\*(Aq}{\*(Aqo\*(Aq}{\*(Aqb\*(Aq}{\*(Aq00\*(Aq}\*(C'\fR (the 00 being an
end marker).  Only nodes which would represent words in the trie exist, making
the structure slightly smaller than a hash of the same data set.
.PP
The advantages of the trie over other data storage methods is that lookup
times are O(1) \s-1WRT\s0 the size of the index.  For sparse data sets, it is probably
not as efficient as performing a binary search on a sorted list, and for small
files, it has a lot of overhead.  The main advantage (at least from my 
perspective) is that it provides a relatively cheap method for finding a list
of words in a large, dense data set which \fBbegin\fR with a certain string.
.PP
The term \*(L"word\*(R" in this documentation can refer to one of two things: either a
reference to an array of strings, or a scalar which is not a reference.  In
the case of the former, each element of the array is treated as a \*(L"letter\*(R"
of the \*(L"word\*(R".  In the case of the latter, the scalar is evaluated in string
context and it is split into its component letters.  Return values of methods
match the values of what is passed in \*(-- that is, if you call \fBlookup()\fR with
an array reference, the return value will be an array reference (if
appropriate).
.PP
\&\s-1NOTE:\s0 The return semantics of the lookup_data method have \s-1CHANGED\s0 from version
1.0 to version 1.1.  If you use this method, be sure to see the perldoc on
that method for details.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew()\fR" 4
.IX Item "new()"
.PD 0
.IP "new({\fIoption0\fR => \fIvalue0\fR, \fIoption1\fR => \fIvalue1\fR, ...})" 4
.IX Item "new({option0 => value0, option1 => value1, ...})"
.PD
This is the constructor method for the class.  You may optionally pass it
a hash reference with a set of \fIoption\fR => \fIvalue\fR pairs.  The options
which can be set at object creation-time are \*(L"deepsearch\*(R", \*(L"end_marker\*(R" and
\&\*(L"freeze_end_marker\*(R".  See the documentation on the methods which set and
report those values for more information.
.ie n .IP "$trie\->add(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.el .IP "\f(CW$trie\fR\->add(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.IX Item "$trie->add(word, word1, ...)"
This method attempts to add the words to the trie.  Returns, in list
context, the words successfully added to the trie.  In scalar context, returns
the number of words successfully added.  As of this release, the only reason
a word would fail to be added is if it is already in the trie.
.ie n .IP "$trie\->add_all(\fI\fItrie\fI\fR, \fItrie1\fR, ...)" 4
.el .IP "\f(CW$trie\fR\->add_all(\fI\fItrie\fI\fR, \fItrie1\fR, ...)" 4
.IX Item "$trie->add_all(trie, trie1, ...)"
This method adds all of the words from the argument tries to the trie.  By
performing the traversal of both source and target tries simultaneously,
this mechanism is much faster first doing a lookup on one trie and then an
add on the other.  Has no return value.
.ie n .IP "$trie\->add_data(\fI\fIword\fI\fR => \fIdata0\fR, \fIword1\fR => \fIdata1\fR, ...)" 4
.el .IP "\f(CW$trie\fR\->add_data(\fI\fIword\fI\fR => \fIdata0\fR, \fIword1\fR => \fIdata1\fR, ...)" 4
.IX Item "$trie->add_data(word => data0, word1 => data1, ...)"
This method works in basically the same way as \f(CW\*(C`add()\*(C'\fR, except in addition to
adding words to the trie, it also adds data associated with those words.  Data
values may be overwritten by adding data for words already in the trie.  Its
return value is the same and applies only to new words added to the trie, not
data modified in existing words.
.ie n .IP "$trie\->remove(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.el .IP "\f(CW$trie\fR\->remove(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.IX Item "$trie->remove(word, word1, ...)"
This method attempts to remove the words from the trie.  Returns, in
list context, the words successfully removed from the trie.  In scalar context,
returns the number of words successfully removed.  As of this release, the only
reason a word would fail to be removed is if it is not already in the trie.
.ie n .IP "$trie\->delete_data(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.el .IP "\f(CW$trie\fR\->delete_data(\fI\fIword\fI\fR, \fIword1\fR, ...)" 4
.IX Item "$trie->delete_data(word, word1, ...)"
This method simply deletes data associated with words in the trie.  It
is the equivalent to perl's delete builtin operating on a hash.  It returns
the number of data items deleted in scalar context, or a list of words
for which data has been removed, in list context.
.ie n .IP "$trie\->lookup(\fIword\fR)" 4
.el .IP "\f(CW$trie\fR\->lookup(\fIword\fR)" 4
.IX Item "$trie->lookup(word)"
.PD 0
.ie n .IP "$trie\->lookup(\fIword\fR, \fIsuffix_length\fR)" 4
.el .IP "\f(CW$trie\fR\->lookup(\fIword\fR, \fIsuffix_length\fR)" 4
.IX Item "$trie->lookup(word, suffix_length)"
.PD
This method performs lookups on the trie.  In list context, it returns a
complete list of words in the trie which begin with \fIword\fR.
In scalar context, the value returned depends on the setting of the 'deepsearch'
option.  You can set this option while creating your Trie object, or by using
the deepsearch method.  Valid deepsearch values are:
.Sp
boolean: Will return a true value if any word in the trie begins with \fIword\fR.
This setting is the fastest.
.Sp
choose: Will return one word in the trie that begins with \fIword\fR, or undef if
nothing is found.  If \fIword\fR exists in the trie exactly, it will be returned.
.Sp
count: Will return a count of the words in the trie that begin with \fIword\fR.
This operation may require walking the entire tree, so it can possibly be
significantly slower than other options.
.Sp
prefix: Will return the longest entry in the trie that is a prefix of \fIword\fR.
For example, if you had a list of file system mount points in your trie, you
could use this option, pass in the full path of a file, and would be returned
the name of the mount point on which the file could be found.
.Sp
exact: If the exact word searched for exists in the trie, will return that
word (or the data associated therewith), undef otherwise.  This is essentially
equivalent to a hash lookup, but it does have utility in some cases.
.Sp
For reasons of backwards compatibility, 'choose' is the default value
of this option.
.Sp
To get a list of all words in the trie, use \f(CW\*(C`lookup("")\*(C'\fR in list context.
.Sp
If the \fIsuffix_length\fR option is provided, the behavior is a little bit
different:  Instead of returning words from the trie, it will instead return
suffixes that follow \fIword\fR, and those suffixes will be no longer than the
numerical value of the option.  If the option's value is negative, suffixes
of all lengths will be returned.  This option only has effect if the
call to \fBlookup()\fR is in list context, or if the 'deepsearch' parameter
is set to either 'count' or 'choose'.  It has no meaning for the other
scalar deepsearch settings, and will be ignored in those cases.
.Sp
For example, assume your trie contains 'foo', 'food' and 'fish'.
\&\f(CW\*(C`lookup(\*(Aqf\*(Aq, 1)\*(C'\fR would return 'o' and 'i'.  \f(CW\*(C`lookup(\*(Aqf\*(Aq, 3)\*(C'\fR would
return 'oo', 'ood' and 'ish'.  \f(CW\*(C`lookup(\*(Aqfo\*(Aq, \-1)\*(C'\fR would return 'o' and
\&'od'.  In scalar context, these calls would return what you'd expect, based
on the value of deepsearch, with the 'count' and 'choose' options operating
only over the set of suffixes.  That is, The first call would return 2
with 'count', and either 'o' or 'i' with 'choose'.
.Sp
Note that \f(CW\*(C`lookup("", \-1)\*(C'\fR is the same as \f(CW\*(C`lookup("")\*(C'\fR.
.ie n .IP "$trie\->lookup_data(\fIword\fR)" 4
.el .IP "\f(CW$trie\fR\->lookup_data(\fIword\fR)" 4
.IX Item "$trie->lookup_data(word)"
This method operates in essentially the same way as \f(CW\*(C`lookup()\*(C'\fR, with the
exception that in list context it returns a list of word => data value
pairs and in scalar context, where \f(CW\*(C`lookup()\*(C'\fR would return a word,
\&\f(CW\*(C`lookup_data()\*(C'\fR returns the data value associated with that word.  In
cases where the deepsearch setting is such that \f(CW\*(C`lookup()\*(C'\fR would
return a number, \f(CW\*(C`lookup_data()\*(C'\fR will return the same number.
.Sp
Please note that the return value in list context is \s-1NOT\s0 a hash.  It can
be coerced into a hash, and if you are not using any multi-character letters
in your trie, this will work fine.  However otherwise, if it is coerced into
a hash, all the of the array references (remember, words are array refs when
using multi-character letters) will be stringified, which renders them (for
the most part) useless.
.ie n .IP "$trie\->\fBdeepsearch()\fR" 4
.el .IP "\f(CW$trie\fR\->\fBdeepsearch()\fR" 4
.IX Item "$trie->deepsearch()"
.PD 0
.ie n .IP "$trie\->deepsearch(\fInew_setting\fR)" 4
.el .IP "\f(CW$trie\fR\->deepsearch(\fInew_setting\fR)" 4
.IX Item "$trie->deepsearch(new_setting)"
.PD
If option is specified, sets the deepsearch parameter.  Option may be one of:
\&'boolean', 'choose', 'count', 'prefix'.  Please see the documentation for the
lookup method for the details of what these options mean.  Returns the
current (new) value of the deepsearch parameter.
.ie n .IP "$trie\->\fBend_marker()\fR" 4
.el .IP "\f(CW$trie\fR\->\fBend_marker()\fR" 4
.IX Item "$trie->end_marker()"
.PD 0
.ie n .IP "$trie\->end_marker(\fInew_marker\fR)" 4
.el .IP "\f(CW$trie\fR\->end_marker(\fInew_marker\fR)" 4
.IX Item "$trie->end_marker(new_marker)"
.PD
If the marker is provided, sets the string used internally to indicate the
end of a word in the trie to that marker.  Doing this causes a complete
traversal of the trie, where all old end markers are replaced with the new
one.  This can get very slow, so try to call this method when the trie is
still small.  Returns the current (new) end marker value.
.ie n .IP "$trie\->\fBfreeze_end_marker()\fR" 4
.el .IP "\f(CW$trie\fR\->\fBfreeze_end_marker()\fR" 4
.IX Item "$trie->freeze_end_marker()"
.PD 0
.ie n .IP "$trie\->freeze_end_marker(\fInew_flag\fR)" 4
.el .IP "\f(CW$trie\fR\->freeze_end_marker(\fInew_flag\fR)" 4
.IX Item "$trie->freeze_end_marker(new_flag)"
.PD
If flag is provided and a true value, turns off checking and automatic
updating of the end marker.  If flag is provided and false, turns this
checking on.  Returns the current (new) truth value of this setting.
.SH "End Markers"
.IX Header "End Markers"
.SS "Overview"
.IX Subsection "Overview"
The following discussion is only important for those people using
multi-character letters, or words as array references.  If you are just
using this module with words as simple strings, you may disregard this
section.
.PP
First, it's important to understand how data is stored in the trie.  As
described above, the trie structure is basically just a complicated hash of
hashes, with each key of each has being a letter.  There needs to be a distinct
way of determining when we're at the end of a word; we can't just use the
end of the hash structure as a guide, because we need to distinguish between
the word \*(L"barn\*(R" being in the trie and the words \*(L"bar\*(R" and \*(L"barn\*(R" being there.
.PP
The answer is an end marker \*(-- a distinct token that signifies that we're
at the end of the word.  Using the above example, if \*(L"bar\*(R" and \*(L"barn\*(R" are
in the trie, then the keys of the hash at \*(L"r\*(R" would be \*(L"n\*(R" and this end
marker.  Choosing this end marker is easy when all letters are just one
character \*(-- we just choose any two-character string and we know that it will
never match a letter.  However, once we allow arbitrary multi-character
letters, then things get much more difficult: there is no possible end
marker which can be guaranteed to always work.  Here is where we enter
some dark water.
.SS "Dark Water"
.IX Subsection "Dark Water"
In order to make sure that the end marker is always safe, we must check
incoming letters on every word submission.  If the word is an array ref, then
each letter in it is compared to the current end marker.  This does add
overhead, but it's necessary.  If it is found that a letter does conflict
with the end marker, then we choose a new end marker.
.PP
In order to find a new end marker, we obviously need to find a string that
isn't already being used in the trie.  This requires a complete traversal of
the trie to collect a complete set of the letters in use.  Once we have this
it is a simple exercise to generate a new marker which is not in use.
.PP
Then we must replace the marker.  This of course requires a complete
traversal once again.  As you can see, this adds a bit of overhead to working
with multi-character letters, but it's neccessary to make sure things keep
working correctly.  This should be fine for people with small data sets,
or who just do a bunch of additions ahead of time and then only do lookups.
However, if computation time is important to you, there are ways to
avoid this mess.
.SS "Speeding Things Up"
.IX Subsection "Speeding Things Up"
One way to speed things up is to avoid the need to replace the end marker.
You can set the trie's end marker using the \f(CW\*(C`end_marker()\*(C'\fR method, or at
creation time, by passing the \f(CW\*(C`end_marker\*(C'\fR option to the trie in its
constructor's option hashref.  Note that setting the end marker causes
a trie traversal, as it must update existing data.  As such, you want to
set the end marker as soon as possible.
.PP
Note that end marker \s-1MUST\s0 be at least 2 characters long.
.PP
Just setting the end marker though, won't stop the trie from checking each
letter as you add arrayref words.  If you are 100% sure that the end
marker you set won't ever show up in an added word, you can either use
the \f(CW\*(C`freeze_end_marker()\*(C'\fR method or the \f(CW\*(C`freeze_end_marker\*(C'\fR construction
option to tell the trie not to check any more.  However, be careful \*(--
once this option is enabled, the data structure is no longer self-policing,
so if a letter that matches your end marker does end up slipping in, strange
things will begin to happen.
.SS "Examples"
.IX Subsection "Examples"
Here are some situations in which you might want to use the methods described
in the previous section.
.PP
Let's say your application takes user input data describing travel across
the united states, and each node in the trie is a two-letter state abbreviation.
In this case, it would probably be fairly safe to set your end marker to
something like '00'.  However, since this is user-supplied data, you don't
want to let some user break your whole system by entering '00', so you should
probably not freeze the end marker in this case.
.PP
Let's say you're using the trie for a networking application \*(-- your words
will be \s-1IP\s0 addresses, and your letters will be the four \*(L"quads\*(R" of an \s-1IP\s0
address.  In this case you can safely set your end marker to 'xx' or anything
with letters in it, and know that there will never be a collision.  It is
entirely reasonable to set the freeze tag in this case.
.SH "Future Work"
.IX Header "Future Work"
.IP "\(bu" 4
There are a few methods of compression that allow you same some amount of space 
in the trie.  I have to figure out which ones are worth implementing.  I may
end up making the different compression methods configurable.
.Sp
I have now made one of them the default.  It's the least effective one, of
course.
.IP "\(bu" 4
The ability to have Tree::Trie be backed by a \*(L"live\*(R" file instead of keeping
data in memory.  This is, unfortunately, more complicated than simply using
\&\s-1TIE,\s0 so this will take some amount of work.
.SH "Known Problems"
.IX Header "Known Problems"
.IP "\(bu" 4
None at this time.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2011 Avi Finkel <\fIavi@finkel.org\fR>
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  It may be used, redistributed and/or modified
under the terms of the Perl Artistic License (see
http://www.perl.com/perl/misc/Artistic.html)
