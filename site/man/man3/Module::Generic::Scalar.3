.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic::Scalar 3"
.TH Module::Generic::Scalar 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic::Scalar \- String Manipulation Object Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $s = Module::Generic::Scalar\->new( "John Doe" );
\&    print( $s\->substr( 0, 4 ), "\en" );
\&    # prints: John
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.2.3
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The purpos of this calss/package is to provide an object-oriented approach to string manipulation.
.PP
The object is overloaded, so it returns the embedded string when used as a string.
.PP
.Vb 1
\&    print( "I met with $s\en" );
.Ve
.PP
Would produce: I met with John Doe
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Provided with scalar reference, an array or just a regular string and this returns a new object.
.PP
If an array reference or an array-based object is provided like Module::Generic::Array, this will concatenate all the array elements
.SS "as_boolean"
.IX Subsection "as_boolean"
Returns a Module::Generic::Boolean object with its value set to true or false based on the value of the scalar object.
.PP
.Vb 9
\&    # $s is 1
\&    $s\->as_boolean; # sets to true
\&    # $s is 0
\&    $s\->as_boolean; # sets to false
\&    # $s is hello
\&    $s\->as_boolean: # sets to true
\&    # $s is undefined or empty
\&    $s\->as_boolean: # sets to false
\&    # etc...
.Ve
.PP
Module::Generic::Boolean objects are very useful because they can be used in perl as o or 1 to indicate false or true, but when used in json, they are automatically converted to \f(CW\*(C`false\*(C'\fR or \f(CW\*(C`true\*(C'\fR
.SS "as_string"
.IX Subsection "as_string"
Returns the object string as a string.
.PP
.Vb 3
\&    my $s = Module::Generic::Scalar\->new( "Mary Jane" );
\&    print( "Hello $s\en" );
\&    # Hello Mary Jane
.Ve
.SS "append"
.IX Subsection "append"
Provided with a string, and this will add it to the end of the string object.
.PP
.Vb 3
\&    # $s is \*(AqHello\*(Aq
\&    $s\->append( \*(Aq world\*(Aq );
\&    # now this is: Hello world
.Ve
.SS "capitalise"
.IX Subsection "capitalise"
Returns a new Module::Generic::Scalar object representing the string with the words capitalised, done in a smart way. That is the special words like \f(CW\*(C`and\*(C'\fR, \f(CW\*(C`but\*(C'\fR, \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`on\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`the\*(C'\fR, \f(CW\*(C`to\*(C'\fR, etc. are not capitalised.
.PP
This is based on the work done by John Gruber and Aristotle Pagaltzis <https://gist.github.com/gruber/9f9e8650d68b13ce4d78>
.SS "chomp"
.IX Subsection "chomp"
Just like \*(L"chomp\*(R" in perlfunc, this remove the trailing new lines in the string, if any.
.SS "chop"
.IX Subsection "chop"
Just like \*(L"chop\*(R" in perlfunc, this remove the trailing character in the string, no matter what it is.
.SS "clone"
.IX Subsection "clone"
Returns a copy of the object.
.SS "crypt"
.IX Subsection "crypt"
This takes a \*(L"salt\*(R" and returns an encrypted version of the string. See \*(L"crypt\*(R" in perlfunc. Note that this does not work well on some \s-1BSD\s0 systems.
.SS "defined"
.IX Subsection "defined"
Returns true or false whether the string object contains a defined string, i.e. not \f(CW\*(C`undef\*(C'\fR
.SS "fc"
.IX Subsection "fc"
Just like \*(L"fc\*(R" in perlfunc, provided with a string, this enables comparison with casefolding.
.PP
To quote from the manual: \*(L"Casefolding is the process of mapping strings to a form where case differences are erased\*(R".
.PP
.Vb 8
\&    lc($this) eq lc($that)    # Wrong!
\&    # or
\&    uc($this) eq uc($that)    # Also wrong!
\&    # or
\&    $this =~ /^\eQ$that\eE\ez/i  # Right!
\&    # And now
\&    my $s = Module::Generic::Scalar( $this );
\&    $s\->fc( $that );
.Ve
.SS "hex"
.IX Subsection "hex"
Returns the hex value of the string.
.SS "index"
.IX Subsection "index"
Given a sub string and an optional position, and this returns the position at which the sub string was found.
.PP
See \*(L"index\*(R" in perlfunc
.SS "is_alpha"
.IX Subsection "is_alpha"
Returns true if the string contains only alphabetic characters, or else it returns false.
.PP
This uses perl's \f(CW\*(C`[[:alpha:]]\*(C'\fR to test.
.SS "is_alpha_numeric"
.IX Subsection "is_alpha_numeric"
Returns true if the string contains only alphabetic or numeric characters, or else it returns false.
.PP
This uses perl's \f(CW\*(C`[[:alnum:]]\*(C'\fR to test.
.SS "is_empty"
.IX Subsection "is_empty"
Returns true if the string is zero in length, or else it returns false.
.SS "is_lower"
.IX Subsection "is_lower"
Returns true if the string contains only lower case characters, or else it returns false.
.PP
This uses perl's \f(CW\*(C`[[:lower:]]\*(C'\fR to test.
.SS "is_numeric"
.IX Subsection "is_numeric"
Returns true if the string contains only numeric characters, or else it returns false.
.PP
This uses \*(L"looks_like_number\*(R" in Scalar::Util
.SS "is_upper"
.IX Subsection "is_upper"
Returns true if the string contains only upper case characters, or else it returns false.
.PP
This uses perl's \f(CW\*(C`[[:upper:]]\*(C'\fR to test.
.SS "lc"
.IX Subsection "lc"
Given a string, this return a new Module::Generic::Scalar object with the string all in lower case.
.SS "lcfirst"
.IX Subsection "lcfirst"
Given a string, this return a new Module::Generic::Scalar object with the first character of the string in lower case.
.SS "left"
.IX Subsection "left"
Provided with a number and this will get the chunk starting from the left of the string object.
.PP
.Vb 2
\&    Module::Generic::Scalar\->new( "Hello world" )\->left( 5 );
\&    # will produce: Hello
.Ve
.PP
See also \*(L"right\*(R"
.SS "length"
.IX Subsection "length"
This returns the length of the string, as a Module::Generic::Number object.
.SS "like"
.IX Subsection "like"
Provided with a string or a regular express and this return the value of the regular expression evaluation against the object string.
.PP
.Vb 2
\&    my $s = "I disapprove of what you say, but I will defend to the death your right to say it";
\&    print( "Matches? ", $s\->like( qr/\ebapprove[[:blank:]\eh]+what\eb/ ) ? \*(Aqyes\*(Aq : \*(Aqno\*(Aq, "\en" ); # print yes
.Ve
.SS "ltrim"
.IX Subsection "ltrim"
This removes any new line and space characters, i.e. \f(CW\*(C`\er\*(C'\fR and \f(CW\*(C`\en\*(C'\fR at the \fBbegining\fR of the string.
.PP
It takes an optional argument that can be an alternative string to remove at the end of the sstring or a regular expression, such as one provided with \*(L"perlfunc/qr\*(R"
.PP
.Vb 1
\&    $s\->ltrim( qr/[[:blank:]\eh]+/ ); # Remove all kind of leading whitespaces
.Ve
.PP
It returns the object itself for chaining.
.PP
See also \*(L"rtrim\*(R"
.SS "match"
.IX Subsection "match"
Provided with a string or a regular expression like the one created with \*(L"qr\*(R" in perlfunc and this returns true or false whether the string object matched or not.
.PP
.Vb 4
\&    # $s is "Hello world"
\&    $s\->match( \*(Aqworld\*(Aq ); # pass
\&    $s\->match( qr/WORLD/i ); # pass
\&    $s\->match( \*(Aqmonde\*(Aq ); # obviously fail
.Ve
.SS "ord"
.IX Subsection "ord"
This returns the value of \*(L"ord\*(R" in perlfunc on the string, as a Module::Generic::Number object.
.SS "pad"
.IX Subsection "pad"
Provided with a number n and a string and this will create n instance of the string. If the number is positive, the string will be placed at the begining and if negative, it will be placed at the end
.PP
.Vb 2
\&    $s\->pad( 3, \*(AqX\*(Aq );
\&    # XXXHello world
\&
\&    $s\->padd( \-3, \*(AqX\*(Aq );
\&    # Hello worldXXX
.Ve
.SS "pos"
.IX Subsection "pos"
This sets or gets the position inside the string object. See \*(L"pos\*(R" in perlfunc for detail about this.
.SS "quotemeta"
.IX Subsection "quotemeta"
Given a string, this return a new Module::Generic::Scalar object with the given string characters escapeed with \*(L"quotemeta\*(R" in perlfunc.
.SS "replace"
.IX Subsection "replace"
Provided with a string or a regular expression and a replacement string and this will replace all instance of the string or regular expression with the replacement string provided.
.PP
.Vb 3
\&    # $s is Hello world
\&    $s\->replace( \*(Aq \*(Aq, \*(Aq_\*(Aq ); # Hello_world
\&    $s\->replace( qr/[[:blank:]\eh]+/, \*(Aq_\*(Aq ); # Hello_world
.Ve
.SS "reset"
.IX Subsection "reset"
This empty the string inside the object.
.SS "reverse"
.IX Subsection "reverse"
Given a string, this return a new Module::Generic::Scalar object with the given string cin reverse order.
.SS "right"
.IX Subsection "right"
Provided with a number and this will get the chunk starting from the right of the string object.
.PP
.Vb 2
\&    Module::Generic::Scalar\->new( "Hello world" )\->right( 5 );
\&    # will produce: world
.Ve
.PP
See also \*(L"left\*(R"
.SS "rindex"
.IX Subsection "rindex"
Given a sub string and an optional position, and this returns the position at which the sub string was found, starting from the end.
.PP
See \*(L"rindex\*(R" in perlfunc
.SS "rtrim"
.IX Subsection "rtrim"
This removes any new line and space characters, i.e. \f(CW\*(C`\er\*(C'\fR and \f(CW\*(C`\en\*(C'\fR at the \fBend\fR of the string.
.PP
It takes an optional argument that can be an alternative string to remove at the end of the sstring or a regular expression, such as one provided with \*(L"perlfunc/qr\*(R"
.PP
.Vb 1
\&    $s\->rtrim( qr/[[:blank:]\eh]+/ ); # Remove all kind of trailing whitespaces
.Ve
.PP
It returns the object itself for chaining.
.PP
See also \*(L"ltrim\*(R"
.SS "scalar"
.IX Subsection "scalar"
Returns the string within this scalar object. This calls \*(L"as_string\*(R"
.SS "set"
.IX Subsection "set"
Provided with a scalar reference or scalar-based object like Module::Generic::Scalar or an array reference and this sets the current string/.
.PP
This acts the exact same way as for \*(L"new\*(R", except it acts on the current object string.
.SS "split"
.IX Subsection "split"
Provided with a string or an expression and this returns the list in list context or, in scalar context, an array reference as an Module::Generic::Array object.
.PP
Be careful that you cannot just do like perl's original split such as:
.PP
.Vb 1
\&    my $a = $s\->split( /\en/ );
.Ve
.PP
Because \f(CW\*(C`/\en/\*(C'\fR is not passed as an argument, i.e. it results in no argument being passed, so you do need to either provide the expression as \f(CW"\en"\fR or as a regular expression:
.PP
.Vb 1
\&    my $a = $s\->split( qr/\en/ );
.Ve
.PP
It will warn you if no argument was provided.
.SS "sprintf"
.IX Subsection "sprintf"
Provided with a list of arguments, and this replace the placeholders just like \*(L"sprintf\*(R" in perlfunc does.
.SS "substr"
.IX Subsection "substr"
Provided with an offset, an optional length and an optional replacement string, and this return a new Module::Generic::Scalar object.
.PP
See \*(L"substr\*(R" in perlfunc for more information.
.SS "tr"
.IX Subsection "tr"
Provided with a search list and a replacement list and this will perform just like the perl core \*(L"tr\*(R" in perlfunc function.
.PP
It also accepts options like \f(CW\*(C`cdsr\*(C'\fR and returns the resulting value.
.SS "trim"
.IX Subsection "trim"
Provided with a target string or a regular expression, and this will remove any occurence of them in the string object.
.SS "uc"
.IX Subsection "uc"
Given a string, this return a new Module::Generic::Scalar object with the string all in upper case.
.SS "ucfirst"
.IX Subsection "ucfirst"
Given a string, this return a new Module::Generic::Scalar object with the first character of the string in upper case.
.SS "undef"
.IX Subsection "undef"
Sets the underlying string object to undef.
.PP
This would make
.PP
.Vb 1
\&    print( $s\->defined ? \*(Aqdefined\*(Aq : \*(Aqundefined\*(Aq, "\en" );
.Ve
.PP
return false, but becareful that you cannot do:
.PP
.Vb 1
\&    print( $s ? \*(Aqdefined\*(Aq : \*(Aqundefined\*(Aq, "\en" );
.Ve
.PP
Because \f(CW$s\fR is the object so it would always return true.
.PP
If you stringify it like
.PP
.Vb 1
\&    print( "$s" ? \*(Aqdefined\*(Aq : \*(Aqundefined\*(Aq, "\en" );
.Ve
.PP
It would still return as defined, because this would be a defined string, albeit empty
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Generic::Number, Module::Generic::Array, Module::Generic::Boolean, Module::Generic::Hash, Module::Generic::Dynamic
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2000\-2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated
files under the same terms as Perl itself.
