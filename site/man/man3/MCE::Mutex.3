.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MCE::Mutex 3"
.TH MCE::Mutex 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MCE::Mutex \- Locking for Many\-Core Engine
.SH "VERSION"
.IX Header "VERSION"
This document describes MCE::Mutex version 1.874
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use MCE::Mutex;
\&
\& my $mutex = MCE::Mutex\->new;
\&
\& {
\&     use MCE::Flow max_workers => 4;
\&
\&     mce_flow sub {
\&         $mutex\->lock;
\&
\&         # access shared resource
\&         my $wid = MCE\->wid; MCE\->say($wid); sleep 1;
\&
\&         $mutex\->unlock;
\&     };
\& }
\&
\& {
\&     use MCE::Hobo;
\&
\&     MCE::Hobo\->create(\*(Aqwork\*(Aq, $_) for 1..4;
\&     MCE::Hobo\->waitall;
\& }
\&
\& {
\&     use threads;
\&
\&     threads\->create(\*(Aqwork\*(Aq, $_)   for 5..8;
\&     $_\->join for ( threads\->list );
\& }
\&
\& sub work {
\&     my ($id) = @_;
\&     $mutex\->lock;
\&
\&     # access shared resource
\&     print $id, "\en";
\&     sleep 1;
\&
\&     $mutex\->unlock;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements locking methods that can be used to coordinate access
to shared data from multiple workers spawned as processes or threads.
.PP
The inspiration for this module came from reading Mutex for Ruby.
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
.SS "MCE::Mutex\->new ( )"
.IX Subsection "MCE::Mutex->new ( )"
.ie n .SS "MCE::Mutex\->new ( impl => ""Channel"" )"
.el .SS "MCE::Mutex\->new ( impl => ``Channel'' )"
.IX Subsection "MCE::Mutex->new ( impl => Channel )"
.ie n .SS "MCE::Mutex\->new ( impl => ""Flock"", [ path => ""/tmp/file.lock"" ] )"
.el .SS "MCE::Mutex\->new ( impl => ``Flock'', [ path => ``/tmp/file.lock'' ] )"
.IX Subsection "MCE::Mutex->new ( impl => Flock, [ path => /tmp/file.lock ] )"
.ie n .SS "MCE::Mutex\->new ( path => ""/tmp/file.lock"" )"
.el .SS "MCE::Mutex\->new ( path => ``/tmp/file.lock'' )"
.IX Subsection "MCE::Mutex->new ( path => /tmp/file.lock )"
Creates a new mutex.
.PP
Channel locking (the default), unless \f(CW\*(C`path\*(C'\fR is given, is through a pipe
or socket depending on the platform. The advantage of channel locking is
not having to re-establish handles inside new processes and threads.
.PP
For Fcntl-based locking, it is the responsibility of the caller to remove
the \f(CW\*(C`tempfile\*(C'\fR, associated with the mutex, when path is given. Otherwise,
it establishes a \f(CW\*(C`tempfile\*(C'\fR internally including removal on scope exit.
.ie n .SS "$mutex\->impl ( void )"
.el .SS "\f(CW$mutex\fP\->impl ( void )"
.IX Subsection "$mutex->impl ( void )"
Returns the implementation used for the mutex.
.PP
.Vb 2
\& $m1 = MCE::Mutex\->new( );
\& $m1\->impl();   # Channel
\&
\& $m2 = MCE::Mutex\->new( path => /tmp/my.lock );
\& $m2\->impl();   # Flock
\&
\& $m3 = MCE::Mutex\->new( impl => "Channel" );
\& $m3\->impl();   # Channel
\&
\& $m4 = MCE::Mutex\->new( impl => "Flock" );
\& $m4\->impl();   # Flock
.Ve
.PP
Current \s-1API\s0 available since 1.822.
.ie n .SS "$mutex\->lock ( void )"
.el .SS "\f(CW$mutex\fP\->lock ( void )"
.IX Subsection "$mutex->lock ( void )"
.ie n .SS "$mutex\->lock_exclusive ( void )"
.el .SS "\f(CW$mutex\fP\->lock_exclusive ( void )"
.IX Subsection "$mutex->lock_exclusive ( void )"
Attempts to grab an exclusive lock and waits if not available. Multiple calls
to mutex\->lock by the same process or thread is safe. The mutex will remain
locked until mutex\->unlock is called.
.PP
The method \f(CW\*(C`lock_exclusive\*(C'\fR is an alias for \f(CW\*(C`lock\*(C'\fR, available since 1.822.
.PP
.Vb 1
\& ( my $mutex = MCE::Mutex\->new( path => $0 ) )\->lock_exclusive;
.Ve
.ie n .SS "$mutex\->lock_shared ( void )"
.el .SS "\f(CW$mutex\fP\->lock_shared ( void )"
.IX Subsection "$mutex->lock_shared ( void )"
Like \f(CW\*(C`lock_exclusive\*(C'\fR, but attempts to grab a shared lock instead.
The \f(CW\*(C`lock_shared\*(C'\fR method is an alias to \f(CW\*(C`lock\*(C'\fR otherwise for non-Fcntl
implementations.
.PP
Current \s-1API\s0 available since 1.822.
.ie n .SS "$mutex\->unlock ( void )"
.el .SS "\f(CW$mutex\fP\->unlock ( void )"
.IX Subsection "$mutex->unlock ( void )"
Releases the lock. A held lock by an exiting process or thread is released
automatically.
.ie n .SS "$mutex\->synchronize ( sub { ... }, @_ )"
.el .SS "\f(CW$mutex\fP\->synchronize ( sub { ... }, \f(CW@_\fP )"
.IX Subsection "$mutex->synchronize ( sub { ... }, @_ )"
.ie n .SS "$mutex\->enter ( sub { ... }, @_ )"
.el .SS "\f(CW$mutex\fP\->enter ( sub { ... }, \f(CW@_\fP )"
.IX Subsection "$mutex->enter ( sub { ... }, @_ )"
Obtains a lock, runs the code block, and releases the lock after the block
completes. Optionally, the method is \f(CW\*(C`wantarray\*(C'\fR aware.
.PP
.Vb 4
\& my $val = $mutex\->synchronize( sub {
\&     # access shared resource
\&     return \*(Aqscalar\*(Aq;
\& });
\&
\& my @ret = $mutex\->enter( sub {
\&     # access shared resource
\&     return @list;
\& });
.Ve
.PP
The method \f(CW\*(C`enter\*(C'\fR is an alias for \f(CW\*(C`synchronize\*(C'\fR, available since 1.822.
.ie n .SS "$mutex\->timedwait ( timeout )"
.el .SS "\f(CW$mutex\fP\->timedwait ( timeout )"
.IX Subsection "$mutex->timedwait ( timeout )"
Blocks until obtaining an exclusive lock. A false value is returned
if the timeout is reached, and a true value otherwise. The default is
1 second when omitting timeout.
.PP
.Vb 1
\& my $mutex = MCE::Mutex\->new( path => $0 );
\&
\& # terminate script if a previous instance is still running
\&
\& exit unless $mutex\->timedwait( 2 );
\&
\& ...
.Ve
.PP
Current \s-1API\s0 available since 1.822.
.SH "INDEX"
.IX Header "INDEX"
\&\s-1MCE\s0, MCE::Core
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario E. Roy, <marioeroy AT gmail DOT com>
