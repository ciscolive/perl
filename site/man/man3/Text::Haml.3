.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Haml 3"
.TH Text::Haml 3 "2017-01-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Haml \- Haml Perl implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Text::Haml;
\&
\&    my $haml = Text::Haml\->new;
\&
\&    my $html = $haml\->render(\*(Aq%p foo\*(Aq); # <p>foo</p>
\&
\&    $html = $haml\->render(\*(Aq= $user\*(Aq, user => \*(Aqfriend\*(Aq); # <div>friend</div>
\&
\&    # Use Haml file
\&    $html = $haml\->render_file(\*(Aqtmpl/index.haml\*(Aq, user => \*(Aqfriend\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::Haml implements Haml
<http://haml.info/docs/yardoc/file.REFERENCE.html> specification.
.PP
Text::Haml passes specification tests written by Norman Clarke
https://github.com/haml/haml\-spec and supports only cross-language Haml
features. Do not expect ruby or Rails specific extensions to work.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Text::Haml implements the following attributes:
.ie n .SS """append"""
.el .SS "\f(CWappend\fP"
.IX Subsection "append"
Holds the string of code that is appended to the generated Perl code.
.ie n .SS """code"""
.el .SS "\f(CWcode\fP"
.IX Subsection "code"
Holds the Perl code.
.ie n .SS """compiled"""
.el .SS "\f(CWcompiled\fP"
.IX Subsection "compiled"
Holds compiled code.
.ie n .SS """encoding"""
.el .SS "\f(CWencoding\fP"
.IX Subsection "encoding"
.Vb 1
\&    $haml\->encoding(\*(Aqutf\-8\*(Aq);
.Ve
.PP
Default is utf\-8.
.ie n .SS """escape"""
.el .SS "\f(CWescape\fP"
.IX Subsection "escape"
Escape subroutine presented as string.
.PP
Default is
.PP
.Vb 10
\&    $haml\->escape(<<\*(AqEOF\*(Aq);
\&        my $s = shift;
\&        return unless defined $s;
\&        $s =~ s/&/&amp;/g;
\&        $s =~ s/</&lt;/g;
\&        $s =~ s/>/&gt;/g;
\&        $s =~ s/"/&quot;/g;
\&        $s =~ s/\*(Aq/&apos;/g;
\&        return $s;
\&    EOF
.Ve
.ie n .SS """escape_html"""
.el .SS "\f(CWescape_html\fP"
.IX Subsection "escape_html"
.Vb 1
\&    $haml\->escape_html(0);
.Ve
.PP
Switch on/off Haml output html escaping. Default is on.
.ie n .SS """filters"""
.el .SS "\f(CWfilters\fP"
.IX Subsection "filters"
Holds filters.
.ie n .SS """format"""
.el .SS "\f(CWformat\fP"
.IX Subsection "format"
.Vb 1
\&    $haml\->format(\*(Aqxhtml\*(Aq);
.Ve
.PP
Supported formats: xhtml, html, html5.
.PP
Default is xhtml.
.ie n .SS """namespace"""
.el .SS "\f(CWnamespace\fP"
.IX Subsection "namespace"
Holds the namespace under which the Perl package is generated.
.ie n .SS """prepend"""
.el .SS "\f(CWprepend\fP"
.IX Subsection "prepend"
Holds the string of code that is prepended to the generated Perl code.
.ie n .SS """vars"""
.el .SS "\f(CWvars\fP"
.IX Subsection "vars"
Holds the variables that are passed during the rendering.
.ie n .SS """vars_as_subs"""
.el .SS "\f(CWvars_as_subs\fP"
.IX Subsection "vars_as_subs"
When options is \fB\s-1NOT SET\s0\fR (by default) passed variables are normal Perl
variables and are used with \f(CW\*(C`$\*(C'\fR prefix.
.PP
.Vb 1
\&    $haml\->render(\*(Aq%p $var\*(Aq, var => \*(Aqhello\*(Aq);
.Ve
.PP
When this option is \fB\s-1SET\s0\fR passed variables are Perl lvalue
subroutines and are used without \f(CW\*(C`$\*(C'\fR prefix.
.PP
.Vb 1
\&    $haml\->render(\*(Aq%p var\*(Aq, var => \*(Aqhello\*(Aq);
.Ve
.PP
But if you declare Perl variable in a block, it must be used with \f(CW\*(C`$\*(C'\fR
prefix.
.PP
.Vb 4
\&    $haml\->render(\*(Aq<<EOF\*(Aq)
\&        \- my $foo;
\&        %p= $foo
\&    EOF
.Ve
.ie n .SS """helpers"""
.el .SS "\f(CWhelpers\fP"
.IX Subsection "helpers"
.Vb 4
\&    helpers => {
\&        foo => sub {
\&            my $self   = shift;
\&            my $string = shift;
\&
\&            $string =~ s/r/z/;
\&
\&            return $string;
\&        }
\&    }
.Ve
.PP
Holds helpers subroutines. Helpers can be called in Haml text as normal Perl
functions. See also add_helper.
.ie n .SS """helpers_arg"""
.el .SS "\f(CWhelpers_arg\fP"
.IX Subsection "helpers_arg"
.Vb 1
\&    $haml\->helpers_args($my_context);
.Ve
.PP
First argument passed to the helper (Text::Haml instance by default).
.ie n .SS """error"""
.el .SS "\f(CWerror\fP"
.IX Subsection "error"
.Vb 1
\&    $haml\->error;
.Ve
.PP
Holds the last error.
.ie n .SS """tape"""
.el .SS "\f(CWtape\fP"
.IX Subsection "tape"
Holds parsed haml elements.
.ie n .SS """path"""
.el .SS "\f(CWpath\fP"
.IX Subsection "path"
Holds path of Haml templates. Current directory is a default.
If you want to set several paths, arrayref can also be set up.
This way is the same as Text::Xslate.
.ie n .SS """cache"""
.el .SS "\f(CWcache\fP"
.IX Subsection "cache"
Holds cache level of Haml templates. 1 is a default.
0 means \*(L"Not cached\*(R", 1 means \*(L"Checked template mtime\*(R" and 2 means \*(L"Used always cached\*(R".
This way is the same as Text::Xslate.
.ie n .SS """cache_dir"""
.el .SS "\f(CWcache_dir\fP"
.IX Subsection "cache_dir"
Holds cache directory of Haml templates. \f(CW$ENV\fR{\s-1HOME\s0}/.text_haml_cache is a default.
Unless \f(CW$ENV\fR{\s-1HOME\s0}, File::Spec\->tempdir was used.
This way is the same as Text::Xslate.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
.Vb 1
\&    my $haml = Text::Haml\->new;
.Ve
.ie n .SS """add_helper"""
.el .SS "\f(CWadd_helper\fP"
.IX Subsection "add_helper"
.Vb 1
\&    $haml\->add_helper(current_time => sub { time });
.Ve
.PP
Adds a new helper.
.ie n .SS """add_filter"""
.el .SS "\f(CWadd_filter\fP"
.IX Subsection "add_filter"
.Vb 1
\&    $haml\->add_filter(compress => sub { $_[0] =~ s/\es+/ /g; $_[0]});
.Ve
.PP
Adds a new filter.
.ie n .SS """build"""
.el .SS "\f(CWbuild\fP"
.IX Subsection "build"
.Vb 1
\&    $haml\->build(@_);
.Ve
.PP
Builds the Perl code.
.ie n .SS """compile"""
.el .SS "\f(CWcompile\fP"
.IX Subsection "compile"
.Vb 1
\&    $haml\->compile;
.Ve
.PP
Compiles parsed code.
.ie n .SS """interpret"""
.el .SS "\f(CWinterpret\fP"
.IX Subsection "interpret"
.Vb 1
\&    $haml\->interpret(@_);
.Ve
.PP
Interprets compiled code.
.ie n .SS """parse"""
.el .SS "\f(CWparse\fP"
.IX Subsection "parse"
.Vb 1
\&    $haml\->parse(\*(Aq%p foo\*(Aq);
.Ve
.PP
Parses Haml string building a tree.
.ie n .SS """render"""
.el .SS "\f(CWrender\fP"
.IX Subsection "render"
.Vb 1
\&    my $text = $haml\->render(\*(Aq%p foo\*(Aq);
\&
\&    my $text = $haml\->render(\*(Aq%p var\*(Aq, var => \*(Aqhello\*(Aq);
.Ve
.PP
Renders Haml string. Returns undef on error. See error attribute.
.ie n .SS """render_file"""
.el .SS "\f(CWrender_file\fP"
.IX Subsection "render_file"
.Vb 1
\&    my $text = $haml\->render_file(\*(Aqfoo.haml\*(Aq, var => \*(Aqhello\*(Aq);
.Ve
.PP
A helper method that loads a file and passes it to the render method.
Since \*(L"%_\|_\|_\|_vars\*(R" is used internally, you cannot use this as parameter name.
.SH "PERL SPECIFIC IMPLEMENTATION ISSUES"
.IX Header "PERL SPECIFIC IMPLEMENTATION ISSUES"
.SS "String interpolation"
.IX Subsection "String interpolation"
Despite of existing string interpolation in Perl, Ruby interpolation is also
supported.
.PP
\&\f(CW$haml\fR\->render('%p Hello #{user}', user => 'foo')
.SS "Hash keys"
.IX Subsection "Hash keys"
When declaring tag attributes \f(CW\*(C`:\*(C'\fR symbol can be used.
.PP
\&\f(CW$haml\fR\->render(\*(L"%a{:href => 'bar'}\*(R");
.PP
Perl-style is supported but not recommented, since your Haml template won't
work with Ruby Haml implementation parser.
.PP
\&\f(CW$haml\fR\->render(\*(L"%a{href => 'bar'}\*(R");
.SS "Using with Data::Section::Simple"
.IX Subsection "Using with Data::Section::Simple"
When using the Data::Section::Simple, you need to unset the variable \f(CW\*(C`encoding\*(C'\fR in the constructor or using the \f(CW\*(C`encoding\*(C'\fR attribute of the Text::Haml:
.PP
.Vb 2
\&    use Data::Section::Simple qw/get_data_section/;
\&    my $vpath = get_data_section;
\&
\&    my $haml = Text::Haml\->new(cache => 0, path => $vpath, encoding => \*(Aq\*(Aq);
\&    # or
\&    #my $haml = Text::Haml\->new(cache => 0, path => $vpath);
\&    #$haml\->encoding(\*(Aq\*(Aq); # encoding attribute
\&
\&    my $index = $haml\->render_file(\*(Aqindex.haml\*(Aq);
\&    say $index;
\&
\&    _\|_DATA_\|_
\&
\&    @@ index.haml
\&    %strong XXXXX
.Ve
.PP
see <https://metacpan.org/pod/Data::Section::Simple#utf8\-pragma>
.SH "DEVELOPMENT"
.IX Header "DEVELOPMENT"
.SS "Repository"
.IX Subsection "Repository"
.Vb 1
\&    http://github.com/vti/text\-haml
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Viacheslav Tykhanovskyi, \f(CW\*(C`vti@cpan.org\*(C'\fR.
.SH "CREDITS"
.IX Header "CREDITS"
In order of appearance:
.PP
Nick Ragouzis
.PP
Norman Clarke
.PP
rightgo09
.PP
Breno G. de Oliveira (garu)
.PP
Yuya Tanaka
.PP
Wanradt Koell (wanradt)
.PP
Keedi Kim
.PP
Carlos Lima
.PP
Jason Younker
.PP
TheAthlete
.PP
Mark Aufflick (aufflick)
.PP
Graham Todd (grtodd)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009\-2017, Viacheslav Tykhanovskyi.
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
