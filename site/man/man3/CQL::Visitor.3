.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CQL::Visitor 3"
.TH CQL::Visitor 3 "2012-11-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CQL::Visitor \- visit nodes in a CQL parse tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package MyVisitor;
\&    use base qw( CQL::Visitor );
\&
\&    sub term {
\&        my ($self,$node) = @_;
\&        # do something to the node
\&    }
\&
\&    # later on
\&   
\&    my $parser = CQL::Parser\->new();
\&    my $root = $parser\->parse($cql);
\&
\&    my $visitor = MyVisitor\->new();
\&    $vistor\->visit($root);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CQL::Visitor provides a simple interface for visiting nodes in your parse tree.
It could be useful if you want to do something like change a query like this:
.PP
.Vb 1
\&    dc.title=foo and dc.creator=bar 
\&
\&    into
\&
\&    title=foo and creator=bar
.Ve
.PP
Or some similar procedure. You simply create a new subclass of CQL::Visitor
and override the appropriate method, such as \fBterm()\fR. Every term that is
encountered during the traversal will be handed off to your \fBterm()\fR method.
.PP
Note: at the moment only \fBterm()\fR is supported because that's what was needed, but
if you need other ones feel free to add them, or ask for them.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fBnew()\fP"
.IX Subsection "new()"
.SS "\fBvisit()\fP"
.IX Subsection "visit()"
Call this to traverse your parse tree, starting at the root.
.SS "\fBterm()\fP"
.IX Subsection "term()"
Your subclass should override this, and do something meaningful with the
CQL::TermNode object.
