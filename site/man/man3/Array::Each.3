.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Array::Each 3"
.TH Array::Each 3 "2013-01-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Array::Each \- iterate over one or more arrays, returning one or more
elements from each array followed by the array index.
.SH "VERSION"
.IX Header "VERSION"
This document refers to version 0.03 of Array::Each,
released March 26, 2004.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Array::Each;
\&
\& # one array
\& my @x = qw( a b c d e );
\&
\& my $one = Array::Each\->new( \e@x );
\& while( my( $x, $i ) = $one\->each() ) {
\&     printf "%3d: %s\en", $i, $x;
\& }
\&
\& # multiple arrays
\& my @y = ( 1,2,3,4,5 );
\&
\& my $set = Array::Each\->new( \e@x, \e@y );
\& while( my( $x, $y, $i ) = $set\->each() ) {
\&     printf "%3d: %s %s\en", $i, $x, $y;
\& }
\&
\& # groups of elements (note set=> parm syntax)
\& my @z = ( a=>1, b=>2, c=>3, d=>4, e=>5 );
\&
\& my $hash_like = Array::Each\->new( set=>[\e@z], group=>2 );
\& while( my( $key, $val ) = $hash_like\->each() ) {
\&     printf "%s => %s\en", $key, $val;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
Array::Each provides the \fBeach()\fR method to iterate over one or more
arrays, returning one or more elements from each, followed by the
array index.
.PP
Array::Each has an object oriented interface, so it does not export
any subroutines (or variables) into your program's namespace.
.PP
Use the \fBnew()\fR method to create an object that will hold the
iterator and other attributes for each set of arrays to iterate over,
e.g.,
.PP
.Vb 1
\& my $set = Array::Each\->new( \e@x, \e@y );
.Ve
.PP
Use the \fBeach()\fR method to iterate over the values in the array or
arrays.  This is typically done in a \fBwhile()\fR loop, as with perl's
builtin \fBeach()\fR function for hashes.
.PP
.Vb 3
\& while( my( $x, $y, $i ) = $set\->each() ) {
\&     printf "%3d: %s %s\en", $i, $x, $y;
\& }
.Ve
.PP
Like perl's, Array::Each's \fBeach()\fR returns an empty list (in list
context) when the end of the set of arrays is reached.  At that point,
the iterator is automatically rewound to the beginning, so you can
iterate over the same set of arrays again.
.SS "Initialization"
.IX Subsection "Initialization"
All attributes can be initialized via the call to the \fBnew()\fR method.
The attributes are: \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`iterator\*(C'\fR, \f(CW\*(C`rewind\*(C'\fR, \f(CW\*(C`bound\*(C'\fR,
\&\f(CW\*(C`undef\*(C'\fR, \f(CW\*(C`stop\*(C'\fR, \f(CW\*(C`group\*(C'\fR, and \f(CW\*(C`count\*(C'\fR.  In addition, every
attribute has accessor methods to set and get their values.  These
are explained in detail below.
.SS "Primary Methods"
.IX Subsection "Primary Methods"
.IP "new( \s-1ARRAYREFS\s0 )" 8
.IX Item "new( ARRAYREFS )"
.PD 0
.IP "new( set=>[\s-1ARRAYREFS\s0] ...other parms... )" 8
.IX Item "new( set=>[ARRAYREFS] ...other parms... )"
.IP "\fBnew()\fR" 8
.IX Item "new()"
.PD
Normally\*(--assuming all the attribute defaults are what you want\*(--simply
pass a list of array references to the \fBnew()\fR method like this:
.Sp
.Vb 1
\& my $obj = Array::Each\->new( \e@x, \e@y );
.Ve
.Sp
However, if you want to initialize any of the object's other
attributes, pass the array references in an anonymous array using
the \fBset=>\fR named parameter, like this:
.Sp
.Vb 1
\& my $obj = Array::Each\->new( set=>[\e@x, \e@y] );  # same as above
.Ve
.Sp
Then you can pass other attributes by name:
.Sp
.Vb 1
\& my $obj = Array::Each\->new( set=>[\e@x, \e@y], bound=>0, undef=>\*(Aq\*(Aq );
.Ve
.Sp
The attributes are: \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`iterator\*(C'\fR, \f(CW\*(C`rewind\*(C'\fR, \f(CW\*(C`bound\*(C'\fR, \f(CW\*(C`undef\*(C'\fR,
\&\f(CW\*(C`stop\*(C'\fR, \f(CW\*(C`group\*(C'\fR, and \f(CW\*(C`count\*(C'\fR, and are explained in detail below.
.IP "copy( \s-1ARRAYREFS\s0 )" 8
.IX Item "copy( ARRAYREFS )"
.PD 0
.IP "copy( set=>[\s-1ARRAYREFS\s0] ...other parms... )" 8
.IX Item "copy( set=>[ARRAYREFS] ...other parms... )"
.IP "\fBcopy()\fR" 8
.IX Item "copy()"
.PD
This method is similar to \fBnew()\fR in that it constructs a new object and
allows you to set any of the attributes.  But \fBcopy()\fR is intended to be
called with an existing Array::Each object.  The new copy will take all
of its attribute values from the existing object (in particular, the
set of arrays and current value of the iterator), unless you specify
differently, e.g.,
.Sp
.Vb 1
\& my $obj2 = $obj\->copy();
.Ve
.Sp
Thus we might generate permutations of an array like this:
.Sp
.Vb 10
\& sub permute {
\&     my $set1 = Array::Each\->new( @_ );
\&     my @permutations;
\&     while ( my @s1 = $set1\->each() ) {
\&         my $set2 = $set1\->copy();
\&         while ( my @s2 = $set2\->each() ) {
\&             # \-1 because each() returns array index, too
\&             push @permutations,
\&                 [ @s1[0..$#s1\-1], @s2[0..$#s2\-1] ];
\&         }
\&     }
\&     return @permutations
\& }
.Ve
.Sp
Note: currently, the \fBcopy()\fR method is implemented as an alias of the
\&\fBnew()\fR method.  But do not rely on this always to be the case, because
future versions of Array::Each may change this implementation detail.
So the rules are:
.Sp
1) use \fBnew()\fR when you create a new object using the class name, e.g.,
\&\f(CW\*(C`$obj = Array::Each\->new()\*(C'\fR.
.Sp
2) use \fBcopy()\fR when you create a copy of an existing object using the
object reference, e.g., \f(CW\*(C`$obj2 = $obj\->copy()\*(C'\fR.
.IP "\fBeach()\fR" 8
.IX Item "each()"
The \fBeach()\fR method for arrays is similar to the builtin perl function of
the same name for hashes.  Perl's \fBeach()\fR will iterate over a hash,
returning a key and its value at each pass.  Array::Each's \fBeach()\fR will
iterate over one or more arrays, each time returning one or more
values, followed by an array index, e.g.,
.Sp
.Vb 3
\& while( my( $x, $y, $i ) = $obj\->each() ) {
\&     printf "%3d: %s %s\en", $i, $x, $y;
\& }
.Ve
.Sp
In list context, Array::Each's \fBeach()\fR returns an empty list when
the end of the set of arrays is reached.  In scalar context, it
returns undef.  At that point, the iterator is automatically rewound
to the beginning, so you can iterate over the same set of arrays
again.
.Sp
See more examples above and below, and in Array::Each::Tutorial.
.Sp
Incidentally, for what it's worth, \fBeach()\fR returns just the array
index when called in scalar context, e.g.,
.Sp
.Vb 3
\& while( defined( my $i = $obj\->each() ) ) {
\&     printf "%3d\en", $i;
\& }
.Ve
.Sp
As the example implies, be aware that the first index returned will
likely be 0.
.SS "Utility Methods"
.IX Subsection "Utility Methods"
These methods are used internally and called automatically but can
be called manually as needed.
.IP "rewind( \s-1INDEX\s0 )" 8
.IX Item "rewind( INDEX )"
.PD 0
.IP "\fBrewind()\fR" 8
.IX Item "rewind()"
.PD
When you iterate over a set of arrays and reach the end, the iterator
for that set is automatically \*(L"rewound\*(R" to index 0 (or to the value of
the \f(CW\*(C`rewind\*(C'\fR attribute; see details about \f(CW\*(C`rewind\*(C'\fR below).
.Sp
But you can \fBrewind()\fR it manually at any time, e.g.,
.Sp
.Vb 1
\& $obj\->rewind();
.Ve
.Sp
You can also rewind it to a particular point by passing the array \s-1INDEX\s0
of the \fInext\fR desired iteration, e.g.,
.Sp
.Vb 1
\& $obj\->rewind( 10 );
.Ve
.Sp
The \fBrewind()\fR method returns the value passed to it, or the value
of the \f(CW\*(C`rewind\*(C'\fR attribute if no value is passed.
.IP "\fBincr_iterator()\fR" 8
.IX Item "incr_iterator()"
As \fBeach()\fR iterates over a set of arrays, it automatically increments
the iterator.  But you can increment it manually with \fBincr_iterator()\fR,
e.g.,
.Sp
.Vb 1
\& $obj\->incr_iterator();
.Ve
.Sp
Note: if the \f(CW\*(C`group\*(C'\fR attribute is set, this method will increment the
iterator by that amount; see details about \f(CW\*(C`group\*(C'\fR below.
.Sp
The \fBincr_iterator()\fR method returns the value of the iterator \fIprior\fR
to its being incremented.
.Sp
Currently, \fBincr_iterator()\fR does not take any parameters.  If you
want to increment the iterator by other than the usual amount,
first get its current value and then set the new value explicitly,
e.g.,
.Sp
.Vb 1
\& $obj\->set_iterator( $obj\->get_iterator() + $amount );
.Ve
.SS "Object Attributes and Accessor Methods"
.IX Subsection "Object Attributes and Accessor Methods"
Since all object attributes can be set when \fBnew()\fR is called,
ordinarily there is no need to call any of the accessor methods.
They are provided for completeness and for special cases.
.ie n .IP """set"", set_set( \s-1ARRAYREFS\s0 ), \fBget_set()\fR" 8
.el .IP "\f(CWset\fR, set_set( \s-1ARRAYREFS\s0 ), \fBget_set()\fR" 8
.IX Item "set, set_set( ARRAYREFS ), get_set()"
The \f(CW\*(C`set\*(C'\fR attribute is the list of arrays (i.e., the \*(L"set\*(R" of
arrays) to iterate over.  These arrays must be passed to the \fBnew()\fR,
\&\fBcopy()\fR, and \fBset_set()\fR methods as array references.  If no other
attributes are initialized when you call \fBnew()\fR, you can pass the
array references \*(L"directly\*(R", e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( \e@x, \e@y );
.Ve
.Sp
On the other hand, if you set other attributes when calling \fBnew()\fR,
you must pass the array references \*(L"indirectly\*(R" in an anonymous
array using the \fBset=>\fR named parameter, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y] );  # same as above
.Ve
.Sp
If you want to specify the set of arrays separately from the call to
\&\fBnew()\fR, you can do so by calling \fBset_set()\fR, e.g.,
.Sp
.Vb 2
\& $obj\->Array::Each\->new();   # ...
\& $obj\->set_set( \e@x, \e@y );  # same as above
.Ve
.Sp
Note, always pass the array references \*(L"directly\*(R" to \fBset_set()\fR, i.e.,
don't pass them inside an anonymous array.
.Sp
In list context, the \fBset_set()\fR method returns the list of array
references passed to it.  In scalar context, it returns the number
of references.  E.g.,
.Sp
.Vb 2
\& my @array_refs = $obj\->set_set( \e@x, \e@y );
\& my $num = $obj\->set_set( @array_refs );
.Ve
.Sp
Get the list of array references by calling \fBget_set()\fR, e.g.,
.Sp
.Vb 1
\& my @array_refs = $obj\->get_set();
.Ve
.Sp
(... yes, the term \*(L"set\*(R" is somewhat overloaded in this class.
Sorry about that.)
.ie n .IP """iterator"", set_iterator( \s-1INDEX\s0 ), \fBget_iterator()\fR" 8
.el .IP "\f(CWiterator\fR, set_iterator( \s-1INDEX\s0 ), \fBget_iterator()\fR" 8
.IX Item "iterator, set_iterator( INDEX ), get_iterator()"
The \f(CW\*(C`iterator\*(C'\fR value is where the \fInext\fR iteration will begin.
By default, it is set to 0, i.e., the first array index.  To set
a different initial value, pass the \fBiterator=>\fR named parameter
to the \fBnew()\fR (or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], iterator=>10 );
.Ve
.Sp
This will start the iteration at array index 10 instead of 0.
.Sp
(Note, this does \fInot\fR change where \fBrewind()\fR will rewind to.  To
change the rewind value, set the \f(CW\*(C`rewind\*(C'\fR attribute; see below.  Or
you can manually rewind to a particular index by calling the rewind
method with that value, e.g., \f(CW\*(C`$obj\->rewind( 10 )\*(C'\fR.)
.Sp
Set the iterator of an existing object with \fBset_iterator()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_iterator( 10 );
.Ve
.Sp
Again, this sets where the \fInext\fR iteration will begin.
.Sp
The \fBset_iterator()\fR method returns the value passed to it.
.Sp
Get the value of the iterator with \fBget_iterator()\fR, e.g.,
.Sp
.Vb 1
\& my $i = $obj\->get_iterator();
.Ve
.Sp
This is where the \fInext\fR iteration will begin, \fInot\fR where the last
one happened.
.Sp
Any integer >= 0 is valid for \f(CW\*(C`iterator\*(C'\fR.
.ie n .IP """rewind"", set_rewind( \s-1INDEX\s0 ), \fBget_rewind()\fR" 8
.el .IP "\f(CWrewind\fR, set_rewind( \s-1INDEX\s0 ), \fBget_rewind()\fR" 8
.IX Item "rewind, set_rewind( INDEX ), get_rewind()"
The \f(CW\*(C`rewind\*(C'\fR attribute is where \fBrewind()\fR will rewind to.  By
default, it is set to 0, i.e., the first array index.  To set a
different value, pass the \fBrewind=>\fR named parameter to the
\&\fBnew()\fR (or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], rewind=>10, iterator=>10 );
.Ve
.Sp
(Note: setting \f(CW\*(C`rewind\*(C'\fR doesn't change where the \fIinitial\fR iteration
begins; for that, set the \f(CW\*(C`iterator\*(C'\fR value as shown above.)
.Sp
Set an object's rewind value with \fBset_rewind()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_rewind( 10 );
.Ve
.Sp
The \fBset_rewind()\fR method returns the value passed to it.
.Sp
Get the rewind value with \fBget_rewind()\fR, e.g.,
.Sp
.Vb 1
\& my $rewind_val = $obj\->get_rewind();
.Ve
.Sp
Any integer >= 0 is valid for \f(CW\*(C`rewind\*(C'\fR.
.ie n .IP """bound"", set_bound( 0 or 1 ), \fBget_bound()\fR" 8
.el .IP "\f(CWbound\fR, set_bound( 0 or 1 ), \fBget_bound()\fR" 8
.IX Item "bound, set_bound( 0 or 1 ), get_bound()"
The \f(CW\*(C`bound\*(C'\fR attribute is a boolean flag and is 1 (true) by default.
When this attribute is true, the iteration over the set of arrays will
stop when the end of the shortest array is reached.  That is, the
iteration is \*(L"bound\*(R" by the shortest array.
.Sp
Note: ordinarily this means that no \*(L"non-existing\*(R" values will be
returned by \fBeach()\fR.  However, if the \f(CW\*(C`group\*(C'\fR attribute is set,
\&\*(L"non-existing\*(R" values may be returned even if \f(CW\*(C`bound\*(C'\fR is true.
\&\*(L"Non-existing\*(R" values are discussed below under \f(CW\*(C`undef\*(C'\fR.
.Sp
To set \f(CW\*(C`bound\*(C'\fR to 0 (false), pass the \fBbound=>\fR named parameter
to the \fBnew()\fR (or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], bound=>0 );
.Ve
.Sp
Or set the value with \fBset_bound()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_bound( 0 );  # now we\*(Aqre not bound by the shortest array
.Ve
.Sp
The \fBset_bound()\fR method returns the value passed to it.
.Sp
Get the value with \fBget_bound()\fR, e.g.,
.Sp
.Vb 1
\& my $bound_val = $obj\->get_bound();
.Ve
.Sp
The valid values for \f(CW\*(C`bound\*(C'\fR are 1 and 0.
.ie n .IP """undef"", set_undef( \s-1SCALAR\s0 or undef ), \fBget_undef()\fR" 8
.el .IP "\f(CWundef\fR, set_undef( \s-1SCALAR\s0 or undef ), \fBget_undef()\fR" 8
.IX Item "undef, set_undef( SCALAR or undef ), get_undef()"
The \f(CW\*(C`undef\*(C'\fR attribute is a scalar value that will be returned by
\&\fBeach()\fR when a \*(L"non-existing\*(R" array element is encountered.  By
default, this attribute's value is (perl's) undef.
.Sp
\&\*(L"Non-existing\*(R" array elements may be encountered if \f(CW\*(C`bound\*(C'\fR is false,
and the arrays are of different sizes.  In other words, the iteration
will continue to the end of the longest array.  When the ends of any
shorter arrays are surpassed, the value of the \f(CW\*(C`undef\*(C'\fR attribute will
be returned for the \*(L"missing\*(R" elements.  (But the shorter arrays will
\&\fInot\fR be extended.)
.Sp
\&\*(L"Non-existing\*(R" elements may also be encountered if \f(CW\*(C`group\*(C'\fR is set,
even if \f(CW\*(C`bound\*(C'\fR is true.  This is because if the shortest array's
size is not a multiple of the \f(CW\*(C`group\*(C'\fR value, the last iteration
will be \*(L"padded\*(R" using the value of the \f(CW\*(C`undef\*(C'\fR attribute.
.Sp
Note: \fBeach()\fR will \fInot\fR return the value of the \f(CW\*(C`undef\*(C'\fR attribute for
\&\fIexisting\fR array elements that are undefined.  Instead, it will return
the (perl) undef value, as normal.
.Sp
To set \f(CW\*(C`undef\*(C'\fR, pass the \fBundef=>\fR named parameter to the \fBnew()\fR
(or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], undef=>\*(Aq\*(Aq );
.Ve
.Sp
Or set the value with \fBset_undef()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_undef( 0 );
.Ve
.Sp
The \fBset_undef()\fR method returns the value passed to it.
.Sp
Get the value with \fBget_undef()\fR, e.g.,
.Sp
.Vb 1
\& my $undef_val = $obj\->get_undef();
.Ve
.Sp
Any value is valid for \f(CW\*(C`undef\*(C'\fR.
.ie n .IP """stop"", set_stop( \s-1INDEX\s0 ), \fBget_stop()\fR" 8
.el .IP "\f(CWstop\fR, set_stop( \s-1INDEX\s0 ), \fBget_stop()\fR" 8
.IX Item "stop, set_stop( INDEX ), get_stop()"
The \f(CW\*(C`stop\*(C'\fR attribute tells \fBeach()\fR where to stop its iterations.  By
default, \f(CW\*(C`stop\*(C'\fR is undefined, meaning \fBeach()\fR will stop where it wants,
depending on \f(CW\*(C`bound\*(C'\fR, \f(CW\*(C`group\*(C'\fR, and the sizes of the arrays.
.Sp
If \f(CW\*(C`bound\*(C'\fR is true and \f(CW\*(C`stop\*(C'\fR is set higher than \f(CW$#shortest_array\fR,
then \f(CW\*(C`stop\*(C'\fR will have no effect (it will never be reached).  If it is
set lower, then the iteration will stop \fIafter\fR that element has been
returned by \fBeach()\fR.
.Sp
If \f(CW\*(C`bound\*(C'\fR is false and the \f(CW\*(C`stop\*(C'\fR value is defined, then the
iteration will stop \fIafter\fR that element has been returned,
regardless of the sizes of the arrays.  If the end of any or all
of the arrays is surpassed, \fBeach()\fR will return the value of the
\&\f(CW\*(C`undef\*(C'\fR attribute in the place of any \*(L"non-existing\*(R" element; see
\&\f(CW\*(C`undef\*(C'\fR above.
.Sp
To set \f(CW\*(C`stop\*(C'\fR, pass the \fBstop=>\fR named parameter to the \fBnew()\fR
(or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], stop=>99 ); # give me 100
.Ve
.Sp
Or set the value with \fBset_stop()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_stop( 49 ); # give me 50 (probably)
.Ve
.Sp
The \fBset_stop()\fR method returns the value passed to it.
.Sp
Get the value with \fBget_stop()\fR, e.g.,
.Sp
.Vb 1
\& my $stop_index = $obj\->get_stop();
.Ve
.Sp
Any integer >= 0 is valid for \f(CW\*(C`stop\*(C'\fR.
.ie n .IP """group"", set_group( \s-1NUM_ELEMS\s0 ), \fBget_group()\fR" 8
.el .IP "\f(CWgroup\fR, set_group( \s-1NUM_ELEMS\s0 ), \fBget_group()\fR" 8
.IX Item "group, set_group( NUM_ELEMS ), get_group()"
The \f(CW\*(C`group\*(C'\fR attribute makes \fBeach()\fR return \fImultiple\fR elements from
each array.  For example, if you do this ...
.Sp
.Vb 4
\& my $obj = Array::Each\->new( set=>[\e@x, \e@y],
\&     group=>5, stop=>99, bound=>0 );
\& my @a = $obj\->each;
\& my $i = $obj\->get_iterator;
.Ve
.Sp
\&... then \f(CW@a\fR will contain 11 elements, 5 each from \f(CW@x\fR and \f(CW@y\fR and
the value of the iterator when \fBeach()\fR was called, namely 0. The
value of \f(CW$i\fR is 5, because when \f(CW\*(C`each\*(C'\fR was called, the iterator
was incremented by the value of \f(CW\*(C`group\*(C'\fR, i.e., \f(CW\*(C`0 + 5 == 5\*(C'\fR.
.Sp
By default, \f(CW\*(C`group\*(C'\fR is undefined.  Logically this is the same as
if it were set to 1.  (But leave it undefined if 1 is what you
want.)
.Sp
To set \f(CW\*(C`group\*(C'\fR, pass the \fBgroup=>\fR named parameter to the \fBnew()\fR
(or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], group=>5 );
.Ve
.Sp
Or set the value with \fBset_group()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_group( 5 );
.Ve
.Sp
The \fBset_group()\fR method returns the value passed to it.
.Sp
Get the value with \fBget_group()\fR, e.g.,
.Sp
.Vb 1
\& my $group_val = $obj\->get_group();
.Ve
.Sp
Any integer > 0 is valid for \f(CW\*(C`group\*(C'\fR.
.Sp
As discussed above, if \f(CW\*(C`group\*(C'\fR causes \fBeach()\fR to surpass the end of any
array, the value of \f(CW\*(C`undef\*(C'\fR will be returned for any \*(L"non-existing\*(R"
elements.
.ie n .IP """count"", set_count( \s-1BEGIN_VAL\s0 ), \fBget_count()\fR" 8
.el .IP "\f(CWcount\fR, set_count( \s-1BEGIN_VAL\s0 ), \fBget_count()\fR" 8
.IX Item "count, set_count( BEGIN_VAL ), get_count()"
The \f(CW\*(C`count\*(C'\fR attribute makes \fBeach()\fR return a count instead of the
array index.  When used, \f(CW\*(C`count\*(C'\fR will be returned and incremented
by 1 every time \fBeach()\fR returns array elements for a given Array::Each
object.  It is not automatically rewound.
.Sp
By default, \f(CW\*(C`count\*(C'\fR is undefined and \fBeach()\fR will ignore it.
.Sp
To set \f(CW\*(C`count\*(C'\fR, pass the \fBcount=>\fR named parameter to the \fBnew()\fR
(or \fBcopy()\fR) method, e.g.,
.Sp
.Vb 1
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y], count=>1 );
.Ve
.Sp
Or set the value with \fBset_count()\fR, e.g.,
.Sp
.Vb 1
\& $obj\->set_count( 1 );
.Ve
.Sp
The \fBset_count()\fR method returns the value passed to it.
.Sp
Get the value with \fBget_count()\fR, e.g.,
.Sp
.Vb 1
\& my $count_val = $obj\->get_count();
.Ve
.Sp
Any integer >= 0 is valid for \f(CW\*(C`count\*(C'\fR.
.Sp
See examples of using \f(CW\*(C`count\*(C'\fR in Array::Each::Tutorial.
.SS "Semi-Private Attributes and Accessor Methods"
.IX Subsection "Semi-Private Attributes and Accessor Methods"
.ie n .IP """_each"", _set_each( \s-1CODE_REF\s0 ), \fB_get_each_name()\fR, \fB_get_each_ref()\fR" 8
.el .IP "\f(CW_each\fR, _set_each( \s-1CODE_REF\s0 ), \fB_get_each_name()\fR, \fB_get_each_ref()\fR" 8
.IX Item "_each, _set_each( CODE_REF ), _get_each_name(), _get_each_ref()"
The \f(CW\*(C`_each\*(C'\fR attribute contains a reference to the subroutine
that will run when \fBeach()\fR is called.  Setting this attribute
is handled under the covers, so you needn't do anything.
.Sp
However, for debugging or testing, you may set the \f(CW\*(C`_each\*(C'\fR attribute
to one of:
.Sp
.Vb 4
\& \e&Array::Each::each_default
\& \e&Array::Each::each_unbound
\& \e&Array::Each::each_group
\& \e&Array::Each::each_complete
.Ve
.Sp
using either the \fB_each=>\fR named attribute in the call to \fBnew()\fR
or by calling \fB_set_each()\fR, e.g.,
.Sp
.Vb 3
\& $obj\->Array::Each\->new( set=>[\e@x, \e@y],
\&     _each=>\e&Array::Each::each_default );
\& $obj\->_set_each( \e&Array::Each::each_complete );
.Ve
.Sp
The \fB_set_each()\fR method returns the resulting value of \f(CW\*(C`_each\*(C'\fR (a
code reference).
.Sp
Setting \f(CW\*(C`_each\*(C'\fR this way may result in unexpected warning messages
and/or in some attributes being ignored, so don't do it except for
debugging or testing.  For example, \fBeach_default()\fR assumes that
most of the attributes are set to their default values, even if
they're not; \fBeach_unbound()\fR assumes \f(CW\*(C`bound\*(C'\fR is false; etc.
.Sp
Calling \fB_set_each()\fR without parameters will reset the \f(CW\*(C`_each\*(C'\fR
attribute to its appropriate value and correctly honor all of the
attributes.
.Sp
Get the \f(CW\*(C`_each\*(C'\fR (code ref) value with \fB_get_each_ref()\fR, e.g.,
.Sp
.Vb 1
\& my $each_ref = $obj\->_get_each_ref();
.Ve
.Sp
Get the \f(CW\*(C`_each\*(C'\fR \fIstringified\fR value with \fB_get_each_name()\fR, e.g.,
.Sp
.Vb 1
\& my $each_name = $obj\->_get_each_name();
.Ve
.Sp
While changing parameters may change the value of \f(CW\*(C`_each\*(C'\fR, do not
rely on a certain parameter combination always resulting in a
specific \f(CW\*(C`_each\*(C'\fR subroutine.
.SH "INHERITING"
.IX Header "INHERITING"
.ie n .IP """user""" 8
.el .IP "\f(CWuser\fR" 8
.IX Item "user"
The \f(CW\*(C`user\*(C'\fR attribute is reserved for use by classes that inherit
from Array::Each.  It may be used as needed without fear of colliding
with future versions of Array::Each.
.SH "BUGS"
.IX Header "BUGS"
Please feel free to report any bugs or suspected bugs to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Array::Each::Tutorial
.SH "AUTHOR"
.IX Header "AUTHOR"
Brad Baxter, bbaxter@cpan.org
.PP
Acknowledgments to Anno Siegel, Ben Morrow, and others on newsgroup
comp.lang.perl.misc, and to Damian Conway, author of \*(L"Object Oriented
Perl\*(R"[1].
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2004, Brad Baxter, All rights reserved.  This module is
free software.  It may be used, redistributed and/or modified under the
same terms as Perl itself.
.PP
.Vb 1
\& _\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&
\& [1] Conway, Damian, Object oriented Perl, Greenwich: Manning, 2000.
.Ve
