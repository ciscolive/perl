.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Set::Array 3"
.TH Set::Array 3 "2020-09-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Set::Array \- Arrays as objects with lots of handy methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`my $sao1 = Set::Array\->new(1,2,4,"hello",undef);\*(C'\fR
.PP
\&\f(CW\*(C`my $sao2 = Set::Array\->new(qw(a b c a b c));\*(C'\fR
.PP
\&\f(CW\*(C`print $sao1\->length; # prints 5\*(C'\fR
.PP
\&\f(CW\*(C`$sao2\->unique\->length\->print; # prints 3\*(C'\fR
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
Perl 5.6 or later
.PP
The 'Want' module by Robin Houston.  Available on \s-1CPAN.\s0
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Set::Array allows you to create arrays as objects and use OO-style methods
on them.  Many convenient methods are provided here that appear in the FAQs,
the Perl Cookbook or posts from comp.lang.perl.misc.
In addition, there are Set methods with corresponding (overloaded)
operators for the purpose of Set comparison, i.e. \fB+\fR, \fB==\fR, etc.
.PP
The purpose is to provide built-in methods for operations that people are
always asking how to do, and which already exist in languages like Ruby.  This
should (hopefully) improve code readability and/or maintainability.  The
other advantage to this module is method-chaining by which any number of
methods may be called on a single object in a single statement.
.SH "OBJECT BEHAVIOR"
.IX Header "OBJECT BEHAVIOR"
The exact behavior of the methods depends largely on the calling context.
.PP
\&\fBHere are the rules\fR:
.PP
* If a method is called in void context, the object itself is modified.
.PP
* If the method called is not the last method in a chain (i.e. it is called
  in object context), the object itself is modified by that method regardless
  of the 'final' context or method call.
.PP
* If a method is called in list or scalar context, a list or list refererence
  is returned, respectively. The object itself is \fB\s-1NOT\s0\fR modified.
.PP
Here is a quick example:
.PP
\&\f(CW\*(C`my $sao = Set::Array\->new(1,2,3,2,3);\*(C'\fR
.PP
\&\f(CW\*(C`my @uniq = $sao\->unique(); # Object unmodified.  \*(Aq@uniq\*(Aq contains 3 values.\*(C'\fR
.PP
\&\f(CW\*(C`$sao\->unique(); # Object modified, now contains 3 values\*(C'\fR
.PP
\&\fBHere are the exceptions\fR:
.PP
* Methods that report a value, such as boolean methods like \fI\f(BIexists()\fI\fR or
  other methods such as \fI\f(BIat()\fI\fR or \fI\f(BIas_hash()\fI\fR, never modify the object.
.PP
* The methods \fI\f(BIclear()\fI\fR, \fI\f(BIdelete()\fI\fR, \fI\f(BIdelete_at()\fI\fR, and \fIsplice\fR will
  \fBalways\fR modify the object. It seemed much too counterintuitive to call these
  methods in any context without actually deleting/clearing/substituting the items!
.PP
* The methods \fI\f(BIshift()\fI\fR and \fI\f(BIpop()\fI\fR will modify the object \fB\s-1AND\s0\fR return
  the value that was shifted or popped from the array.  Again, it seemed
  much too counterintuitive for something like \f(CW\*(C`$val = $sao\->shift\*(C'\fR to
  return a value while leaving the object unchanged.  If you
  really want the first or last value without modifying the object, you
  can always use the \fI\f(BIfirst()\fI\fR or \fI\f(BIlast()\fI\fR method, respectively.
.PP
* The methods \fI\f(BIcshift()\fI\fR and \fI\f(BIcpop()\fI\fR (for chainable-shift and chainable-pop)
  will modify the object \fBand return the object\fR. I.e. the value shifted or popped
  is discarded. See the docs below or the code at the end of t/test.t for examples.
.PP
* The \fI\f(BIjoin()\fI\fR method always returns a string and is really meant for use
  in conjunction with the \fI\f(BIprint()\fI\fR method.
.SH "BOOLEAN METHODS"
.IX Header "BOOLEAN METHODS"
In the following sections, the brackets in [val] indicate that val is a \fIoptional\fR parameter.
.SS "exists([val])"
.IX Subsection "exists([val])"
Returns 1 if \fIval\fR exists within the array, 0 otherwise.
.PP
If no value (or \fIundef\fR) is passed, then this method will test for the existence of undefined values within the array.
.SS "\fBis_empty()\fP"
.IX Subsection "is_empty()"
Returns 1 if the array is empty, 0 otherwise.  Empty is
defined as having a length of 0.
.SH "STANDARD METHODS"
.IX Header "STANDARD METHODS"
.SS "at(index)"
.IX Subsection "at(index)"
Returns the item at the given index (or \fIundef\fR).
.PP
A negative index may be used to count from the end of the array.
.PP
If no value (or \fIundef\fR) is specified, it will look for the first item
that is not defined.
.ie n .SS "bag($other_set, $reverse)"
.el .SS "bag($other_set, \f(CW$reverse\fP)"
.IX Subsection "bag($other_set, $reverse)"
Returns the union of both sets, including duplicates (i.e. everything).
.PP
Setting \f(CW$reverse\fR to 1 reverses the sets as the first step in the method.
.PP
Note: It does not reverse the contents of the sets.
.PP
See \*(L"General Notes\*(R" for the set of such methods, including a list of overloaded operators.
.SS "clear([1])"
.IX Subsection "clear([1])"
Empties the array (i.e. length becomes 0).
.PP
You may pass a \fI1\fR to this method to set each element of the array to \fIundef\fR rather
than truly empty it.
.SS "\fBcompact()\fP"
.IX Subsection "compact()"
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of defined items.
.Sp
The object is not modified.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of defined items.
.Sp
The object is not modified.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.Sp
The object \fIis\fR modified if it contains undefined items.
.SS "count([val])"
.IX Subsection "count([val])"
Returns the number of instances of \fIval\fR within the array.
.PP
If \fIval\fR is not specified (or is \fIundef\fR), the method will return the number of undefined values within the array.
.SS "\fBcpop()\fP"
.IX Subsection "cpop()"
The 'c' stands for 'chainable' pop.
.PP
Removes \fIand discards\fR the last element of the array.
.PP
Returns \fIthe object\fR.
.PP
.Vb 1
\&        Set::Array \-> new(1, 2, 3, 4, 5) \-> cpop \-> join \-> print;
.Ve
.PP
prints 1,2,3,4.
.PP
See also \fBcshift()\fR, \fBpop()\fR and \fBshift()\fR.
.SS "\fBcshift()\fP"
.IX Subsection "cshift()"
The 'c' stands for 'chainable' shift.
.PP
Removes \fIand discards\fR the first element of the array.
.PP
Returns \fIthe object\fR.
.PP
.Vb 1
\&        Set::Array \-> new(1, 2, 3, 4, 5) \-> cshift \-> join \-> print;
.Ve
.PP
prints 2,3,4,5.
.PP
See also \fBcpop()\fR, \fBpop()\fR and \fBshift()\fR.
.SS "delete(@list)"
.IX Subsection "delete(@list)"
Deletes all items within the object that match \fI\f(CI@list\fI\fR.
.PP
This method will die if \fI\f(CI@list\fI\fR is not defined.
.PP
If your goal is to delete undefined values from your object, use the \*(L"\fBcompact()\fR\*(R" method instead.
.PP
This method always modifies the object, if elements in \f(CW@list\fR match elements in the object.
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of unique items.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of unique items.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.SS "delete_at(index, [index])"
.IX Subsection "delete_at(index, [index])"
Deletes the item at the specified index.
.PP
If a second index is specified, a range of items is deleted.
.PP
You may use \-1 or the string 'end' to refer to the last element of the array.
.ie n .SS "difference($one, $two, $reverse)"
.el .SS "difference($one, \f(CW$two\fP, \f(CW$reverse\fP)"
.IX Subsection "difference($one, $two, $reverse)"
Returns all elements in the left set that are not in the right set.
.PP
Setting \f(CW$reverse\fR to 1 reverses the sets as the first step in the method.
.PP
Note: It does not reverse the contents of the sets.
.PP
See \*(L"General Notes\*(R" for the set of such methods, including a list of overloaded operators.
.PP
Study the sample code below carefully, since all of \f(CW$set1\fR, \f(CW$set8\fR and \f(CW$set9\fR get changed, perhaps when you were not
expecting them to be.
.PP
There is a problem however, with 2 bugs in the Want module (V 0.20), relating to want('\s-1OBJECT\s0') and \fBwantref()\fR both causing segfaults.
.PP
So, I have used Try::Tiny to capture a call to want('\s-1OBJECT\s0') in sub \fBdifference()\fR.
.PP
If an error is thrown, I just ignore it. This is horribly tacky, but after waiting 7 years (it is now 2012\-03\-07)
I have given up on expecting patches to Want.
.PP
Sample code:
.PP
.Vb 1
\&        #!/usr/bin/env perl
\&
\&        use strict;
\&        use warnings;
\&
\&        use Set::Array;
\&
\&        # \-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        my($set1) = Set::Array \-> new(qw(abc def ghi jkl mno) );
\&        my($set8) = Set::Array \-> new(@$set1);           # Duplicate for later.
\&        my($set9) = Set::Array \-> new(@$set1);           # Duplicate for later.
\&        my($set2) = Set::Array \-> new(qw(def jkl pqr));
\&        my($set3) = $set1 \- $set2;                       # Changes $set1. $set3 is a set.
\&        my($set4) = Set::Array \-> new(@{$set8 \- $set2}); # Changes $set8. $set4 is a set.
\&        my(@set5) = $set9 \-> difference($set2);          # Changes $set9. $set5 is an array.
\&
\&        print \*(Aq1: \*(Aq, join(\*(Aq, \*(Aq, @$set3), ". \en";
\&        print \*(Aq2: \*(Aq, join(\*(Aq, \*(Aq, @{$set4 \-> print}), ". \en";
\&        print \*(Aq3: \*(Aq, join(\*(Aq, \*(Aq, $set4 \-> print), ". \en";
\&        print \*(Aq4: \*(Aq, join(\*(Aq, \*(Aq, @set5), ". \en";
.Ve
.PP
The last 4 lines all produce the same, correct, output, so any of \f(CW$set3\fR, \f(CW$set4\fR or \f(CW$set5\fR is what you want.
.PP
See t/difference.pl.
.SS "\fBduplicates()\fP"
.IX Subsection "duplicates()"
Returns a list of N\-1 elements for each element which appears N times in the set.
.PP
For example, if you have set \*(L"X X Y Y Y\*(R", this method would return the list \*(L"X Y Y\*(R".
.PP
If you want the output to be \*(L"X Y\*(R", see \*(L"\fBunique()\fR\*(R".
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of duplicated items.
.Sp
The object is not modified.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of duplicated items.
.Sp
The object is not modified.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.Sp
The object \fIis\fR modified if it contains duplicated items.
.SS "fill(val, [start], [length])"
.IX Subsection "fill(val, [start], [length])"
Sets the selected elements of the array (which may be the entire array) to \fIval\fR.
.PP
The default value for \fIstart\fR is 0.
.PP
If length is not specified the entire array, however long it may be, will be filled.
.PP
A range may also be used for the \fIstart\fR parameter. A range must be a quoted string in '0..999' format.
.PP
E.g. \f(CW\*(C`$sao\->fill(\*(Aqx\*(Aq, \*(Aq3..65535\*(Aq);\*(C'\fR
.PP
The array length/size may not be expanded with this call \- it is only meant to
fill in already-existing elements.
.SS "\fBfirst()\fP"
.IX Subsection "first()"
Returns the first element of the array (or undef).
.SS "\fBflatten()\fP"
.IX Subsection "flatten()"
Causes a one-dimensional flattening of the array, recursively.
.PP
That is, for every element that is an array (or hash, or a ref to either an array or hash),
extract its elements into the array.
.PP
E.g. \f(CW\*(C`my $sa = Set::Array\->new([1,3,2],{one=>\*(Aqa\*(Aq,two=>\*(Aqb\*(Aq},x,y,z);\*(C'\fR
.PP
\&\f(CW\*(C`$sao\->flatten\->join(\*(Aq,\*(Aq)\->print; # prints "1,3,2,one,a,two,b,x,y,z"\*(C'\fR
.SS "foreach(sub ref)"
.IX Subsection "foreach(sub ref)"
Iterates over an array, executing the subroutine for each element in the array.
.PP
If you wish to modify or otherwise act directly on the contents of the array, use \fB\f(CB$_\fB\fR within
your sub reference.
.PP
E.g. To increment all elements in the array by one...
.PP
\&\f(CW\*(C`$sao\->foreach(sub{ ++$_ });\*(C'\fR
.SS "\fBget()\fP"
.IX Subsection "get()"
This is an alias for the \fB\fBindices()\fB\fR method.
.SS "index(val)"
.IX Subsection "index(val)"
Returns the index of the first element of the array object that contains \fIval\fR.
.PP
Returns \fIundef\fR if no value is found.
.PP
Note that there is no dereferencing here so if you are looking for an item
nested within a ref, use the \fIflatten\fR method first.
.SS "indices(val1, [val2], [valN])"
.IX Subsection "indices(val1, [val2], [valN])"
Returns an array consisting of the elements at the specified indices, or \fIundef\fR if the element
is out of range.
.PP
A range may also be used for each of the <valN> parameters. A range must be a quoted string in '0..999' format.
.SS "intersection($other_set)"
.IX Subsection "intersection($other_set)"
Returns all elements common to both sets.
.PP
Note: It does not eliminate duplicates. Call \*(L"\fBunique()\fR\*(R" if that is what you want.
.PP
You are strongly encouraged to examine line 19 of both t/intersection.1.pl and t/intersection.2.pl.
.PP
Setting \f(CW$reverse\fR to 1 reverses the sets as the first step in the method.
.PP
Note: It does not reverse the contents of the sets.
.PP
See \*(L"General Notes\*(R" for the set of such methods, including a list of overloaded operators.
.SS "is_equal($other_set)"
.IX Subsection "is_equal($other_set)"
Tests to see if the 2 sets are equal (regardless of order). Returns 1 for equal and 0 for not equal.
.PP
Setting \f(CW$reverse\fR to 1 reverses the sets as the first step in the method.
.PP
Since order is ignored, this parameter is irrelevant.
.PP
Note: It does not reverse the contents of the sets.
.PP
See \*(L"General Notes\*(R" for the set of such methods, including a list of overloaded operators.
.PP
See also \*(L"not_equal($other_set)\*(R".
.SS "join([string])"
.IX Subsection "join([string])"
Joins the elements of the list into a single string with the elements separated by the value of \fIstring\fR.
.PP
Useful in conjunction with the \fI\f(BIprint()\fI\fR method.
.PP
If no string is specified, then \fIstring\fR defaults to a comma.
.PP
e.g. \f(CW\*(C`$sao\->join(\*(Aq\-\*(Aq)\->print;\*(C'\fR
.SS "\fBlast()\fP"
.IX Subsection "last()"
Returns the last element of the array (or \fIundef\fR).
.SS "\fBlength()\fP"
.IX Subsection "length()"
Returns the number of elements within the array.
.SS "\fBmax()\fP"
.IX Subsection "max()"
Returns the maximum value of an array.
.PP
No effort is made to check for non-numeric data.
.SS "\fBnew()\fP"
.IX Subsection "new()"
This is the constructor.
.PP
See \*(L"difference($one, \f(CW$two\fR, \f(CW$reverse\fR)\*(R" for sample code.
.PP
See also \*(L"\fBflatten()\fR\*(R" for converting arrayrefs and hashrefs into lists.
.SS "not_equal($other_set)"
.IX Subsection "not_equal($other_set)"
Tests to see if the 2 sets are not equal (regardless of order). Returns 1 for not equal and 0 for equal.
.PP
Setting \f(CW$reverse\fR to 1 reverses the sets as the first step in the method.
.PP
Since order is ignored, this parameter is irrelevant.
.PP
Note: It does not reverse the contents of the sets.
.PP
See \*(L"General Notes\*(R" for the set of such methods, including a list of overloaded operators.
.PP
See also \*(L"is_equal($other_set)\*(R".
.SS "pack(template)"
.IX Subsection "pack(template)"
Packs the contents of the array into a string (in scalar context) or a single array element (in object
or void context).
.SS "\fBpop()\fP"
.IX Subsection "pop()"
Removes the last element from the array.
.PP
Returns the popped element.
.PP
See also \fBcpop()\fR, \fBcshift()\fR and \fBshift()\fR.
.SS "print([1])"
.IX Subsection "print([1])"
Prints the contents of the array.
.PP
If a \fI1\fR is provided as an argument, the output will automatically be terminated with a newline.
.PP
This also doubles as a 'contents' method, if you just want to make a copy
of the array, e.g. my \f(CW@copy\fR = \f(CW$sao\fR\->print;
.PP
Can be called in void or list context, e.g.
.PP
\&\f(CW\*(C`$sao\->print(); # or...\*(C'\fR
\&\f(CW\*(C`print "Contents of array are: ", $sao\->print();\*(C'\fR
.SS "push(list)"
.IX Subsection "push(list)"
Adds \fIlist\fR to the end of the array, where \fIlist\fR is either a scalar value or a list.
.PP
Returns an array or array reference in list or scalar context, respectively.
.PP
Note that it does \fBnot\fR return the length in scalar context. Use the \fIlength\fR method for that.
.SS "\fBreverse()\fP"
.IX Subsection "reverse()"
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of the items in the object, reversed.
.Sp
The object is not modified.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of the items in the object, reversed.
.Sp
The object is not modified.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.Sp
The object \fIis\fR modified, with its items being reversed.
.SS "rindex(val)"
.IX Subsection "rindex(val)"
Similar to the \fI\f(BIindex()\fI\fR method, except that it returns the index of the last \fIval\fR found within the array.
.PP
Returns \fIundef\fR if no value is found.
.SS "set(index, value)"
.IX Subsection "set(index, value)"
Sets the element at \fIindex\fR to \fIvalue\fR, replacing whatever may have already been there.
.SS "\fBshift()\fP"
.IX Subsection "shift()"
Shifts off the first element of the array and returns the shifted element.
.PP
See also \fBcpop()\fR, \fBcshift()\fR and \fBpop()\fR.
.SS "sort([coderef])"
.IX Subsection "sort([coderef])"
Sorts the contents of the array in alphabetical order, or in the order specified by the optional \fIcoderef\fR.
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of the items in the object, sorted.
.Sp
The object is not modified.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of the items in the object, sorted.
.Sp
The object is not modified.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.Sp
The object \fIis\fR modified by sorting its items.
.PP
Use your standard \fI\f(CI$a\fI\fR and \fI\f(CI$b\fI\fR variables within your sort sub:
.PP
Program:
.PP
.Vb 1
\&        #!/usr/bin/env perl
\&
\&        use Set::Array;
\&
\&        # \-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        my $s = Set::Array\->new(
\&                { name => \*(AqBerger\*(Aq, salary => 15000 },
\&                { name => \*(AqBerger\*(Aq, salary => 20000 },
\&                { name => \*(AqVera\*(Aq, salary => 25000 },
\&        );
\&
\&        my($subref) = sub{ $b\->{name} cmp $a\->{name} || $b\->{salary} <=> $a\->{salary} };
\&        my(@h)      = $s\->sort($subref);
\&
\&        for my $h (@h)
\&        {
\&                print "Name: $$h{name}. Salary: $$h{salary}. \en";
\&        }
.Ve
.PP
Output (because the sort subref puts \f(CW$b\fR before \f(CW$a\fR for name and salary):
.PP
.Vb 3
\&        Name: Vera. Salary: 25000.
\&        Name: Berger. Salary: 20000.
\&        Name: Berger. Salary: 15000.
.Ve
.SS "splice([offset], [length], [list])"
.IX Subsection "splice([offset], [length], [list])"
Splice the array starting at position \fIoffset\fR up to \fIlength\fR elements, and replace them with \fIlist\fR.
.PP
If no list is provided, all elements are deleted.
.PP
If length is omitted, everything from \fIoffset\fR onward is removed.
.PP
Returns an array or array ref in list or scalar context, respectively.
.PP
This method \fBalways\fR modifies the object, regardless of context.
.PP
If your goal was to grab a range of values without modifying the object, use the \fIindices\fR method instead.
.SS "\fBunique()\fP"
.IX Subsection "unique()"
Returns a list of 1 element for each element which appears N times in the set.
.PP
For example, if you have set \*(L"X X Y Y Y\*(R", this method would return the list \*(L"X Y\*(R".
.PP
If you want the output to be \*(L"X Y Y\*(R", see \*(L"\fBduplicates()\fR\*(R".
.IP "o In scalar context" 4
.IX Item "o In scalar context"
Returns an array ref of unique items.
.Sp
The object is not modified.
.IP "o In list context" 4
.IX Item "o In list context"
Returns an array of unique items.
.Sp
The object is not modified.
.IP "o In chained context" 4
.IX Item "o In chained context"
Returns the object.
.Sp
The object \fIis\fR modified if it contains duplicated items.
.SS "unshift(list)"
.IX Subsection "unshift(list)"
Prepends a scalar or list to array.
.PP
Note that this method returns an array or array reference in list or scalar context, respectively.
.PP
It does \fBnot\fR return the length of the array in scalar context. Use the \fIlength\fR method for that.
.SH "ODDBALL METHODS"
.IX Header "ODDBALL METHODS"
.SS "as_hash([$option])"
.IX Subsection "as_hash([$option])"
Returns a hash based on the current array, with each
even numbered element (including 0) serving as the key, and each odd element
serving as the value.
.PP
This can be switched by using \f(CW$option\fR, and setting it to \fIodd\fR,
in which case the even values serve as the values, and the odd elements serve as the keys.
.PP
The default value of \f(CW$option\fR is \fIeven\fR.
.PP
Of course, if you do not care about insertion order, you could just as well
do something like, \f(CW\*(C`$sao\->reverse\->as_hash;\*(C'\fR
.PP
This method does not actually modify the object itself in any way. It just returns a plain
hash in list context or a hash reference in scalar context. The reference
is not blessed, therefore if this method is called as part of a chain, it
must be the last method called.
.PP
\&\fI\f(CI$option\fI\fR can be specified in various ways:
.IP "undef" 4
.IX Item "undef"
When you do not supply a value for this parameter, the default is \fIeven\fR.
.IP "'odd' or 'even'" 4
.IX Item "'odd' or 'even'"
The value may be a string.
.Sp
This possibility was added in V 0.18.
.Sp
This is now the recommended alternative.
.IP "{key_option => 'odd'} or {key_option => 'even'}" 4
.IX Item "{key_option => 'odd'} or {key_option => 'even'}"
The value may be a hash ref, with 'key_option' as the hash key.
.Sp
This possibility was added in V 0.18.
.IP "(key_option => 'odd') or (key_option => 'even')" 4
.IX Item "(key_option => 'odd') or (key_option => 'even')"
The value may be a hash, with 'key_option' as the hash key.
.Sp
This was the original (badly-documented) alternative to undef, and it still supported in order to
make the code backwards-compatible.
.SS "impose([append/prepend], string)"
.IX Subsection "impose([append/prepend], string)"
Appends or prepends the specified string to each element in the array.
.PP
Specify the method with either 'append' or 'prepend'.
.PP
The default is 'append'.
.SS "\fBrandomize()\fP"
.IX Subsection "randomize()"
Randomizes the order of the elements within the array.
.SS "rotate(direction)"
.IX Subsection "rotate(direction)"
Moves the last item of the list to the front and shifts all other elements one to the right, or vice-versa,
depending on what you pass as the direction \- 'ftol' (first to last) or 'ltof' (last to first).
.PP
The default is 'ltof'.
.PP
e.g.
my \f(CW$sao\fR = Set::Array\->new(1,2,3);
.PP
\&\f(CW$sao\fR\->\fBrotate()\fR; # order is now 3,1,2
.PP
\&\f(CW$sao\fR\->rotate('ftol'); # order is back to 1,2,3
.SS "\fBto_hash()\fP"
.IX Subsection "to_hash()"
This is an alias for \fI\f(BIas_hash()\fI\fR.
.SH "OVERLOADED (COMPARISON) OPERATORS"
.IX Header "OVERLOADED (COMPARISON) OPERATORS"
.SS "General Notes"
.IX Subsection "General Notes"
For overloaded operators you may pass a Set::Array object, or just a normal
array reference (blessed or not) in any combination, so long as one is a
Set::Array object.  You may use either the operator or the equivalent method
call.
.PP
Warning: You should always experiment with these methods before using them in production.
Why? Because you may have unrealistic expectations that they \fIautomatially\fR eliminate duplicates, for example.
See the \*(L"\s-1FAQ\*(R"\s0 for more.
.PP
Examples (using the '==' operator or 'is_equal' method):
.PP
my \f(CW$sao1\fR = Set::Array\->new(1,2,3,4,5);
.PP
my \f(CW$sao2\fR = Set::Array\->new(1,2,3,4,5);
.PP
my \f(CW$ref1\fR = [1,2,3,4,5];
.PP
if($sao1 == \f(CW$sao2\fR)...         # valid
.PP
if($sao1 == \f(CW$ref1\fR)...         # valid
.PP
if($ref1 == \f(CW$sao2\fR)...         # valid
.PP
if($sao1\->is_equal($sao2))... # valid
.PP
if($sao1\->is_equal($ref1))... # valid
.PP
All of these operations return either a boolean value (for equality operators) or
an array (in list context) or array reference (in scalar context).
.PP
\&\fB&\fR or \fBbag\fR \- The union of both sets, including duplicates.
.PP
\&\fB\-\fR or \fBdifference\fR \- Returns all elements in the left set that are not in
the right set. See \*(L"difference($one, \f(CW$two\fR)\*(R" for details.
.PP
\&\fB==\fR or \fBis_equal\fR \- This tests for equality of the content of the sets,
though ignores order. Thus, comparing (1,2,3) and (3,1,2) will yield a \fItrue\fR
result.
.PP
\&\fB!=\fR or \fBnot_equal\fR \- Tests for inequality of the content of the sets.  Again,
order is ignored.
.PP
\&\fB*\fR or \fBintersection\fR \- Returns all elements that are common to both sets.
.PP
Be warned that that line says 'all elements', not 'unique elements'. You can call \*(L"unique\*(R"
is you need just the unique elements.
.PP
See t/intersection.*.pl for sample code with and without calling \fBunique()\fR.
.PP
\&\fB%\fR or \fBsymmetric_difference\fR or \fBsymm_diff\fR \- Returns all elements that are in one set
or the other, but not both.  Opposite of intersection.
.PP
\&\fB+\fR or \fBunion\fR \- Returns the union of both sets.  Duplicates excluded.
.SH "FAQ"
.IX Header "FAQ"
.SS "Why does the \fBintersection()\fP method include duplicates in the output?"
.IX Subsection "Why does the intersection() method include duplicates in the output?"
Because it is documented to do that. The docs above say:
.PP
"Returns all elements that are common to both sets.
.PP
Be warned that that line says 'all elements', not 'unique elements'. You can call \*(L"\fBunique()\fR\*(R"
is you need just the unique elements."
.PP
Those statements means what they says!
.PP
See t/intersection.*.pl for sample code with and without calling \fBunique()\fR.
.PP
The following section, \f(CW\*(C`EXAMPLES\*(C'\fR, contains other types of \s-1FAQ\s0 items.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
For our examples, I will create 3 different objects
.PP
my \f(CW$sao1\fR = Set::Array\->new(1,2,3,a,b,c,1,2,3);
.PP
my \f(CW$sao2\fR = Set::Array\->new(1,undef,2,undef,3,undef);
.PP
my \f(CW$sao3\fR = Set::Array\->new(1,2,3,['a','b','c'],{name=>\*(L"Dan\*(R"});
.PP
\&\fBHow do I...\fR
.PP
\&\fIget the number of unique elements within the array?\fR
.PP
\&\f(CW\*(C`$sao1\->unique()\->length();\*(C'\fR
.PP
\&\fIcount the number of non-undef elements within the array?\fR
.PP
\&\f(CW\*(C`$sao2\->compact()\->length();\*(C'\fR
.PP
\&\fIcount the number of unique elements within an array, excluding undef?\fR
.PP
\&\f(CW\*(C`$sao2\->compact()\->unique()\->length();\*(C'\fR
.PP
\&\fIprint a range of indices?\fR
.PP
\&\f(CW\*(C`$sao1\->indices(\*(Aq0..2\*(Aq)\->print();\*(C'\fR
.PP
\&\fItest to see if two Set::Array objects are equal?\fR
.PP
\&\f(CW\*(C`if($sao1 == $sao2){ ... }\*(C'\fR
.PP
\&\f(CW\*(C`if($sao1\->is_equal($sao2){ ... } # Same thing\*(C'\fR
.PP
\&\fIfill an array with a value, but only if it is not empty?\fR
.PP
\&\f(CW\*(C`if(!$sao1\->is_empty()){ $sao1\->fill(\*(Aqx\*(Aq) }\*(C'\fR
.PP
\&\fIshift an element off the array and return the shifted value?\fR
.PP
\&\f(CW\*(C`my $val = $sao1\->shift())\*(C'\fR
.PP
\&\fIshift an element off the array and return the array?\fR
.PP
\&\f(CW\*(C`my @array = $sao1\->delete_at(0)\*(C'\fR
.PP
\&\fIflatten an array and return a hash based on now-flattened array?, with odd
elements as the key?\fR
.PP
\&\f(CW\*(C`my %hash = $sao3\->flatten()\->reverse\->as_hash();\*(C'\fR
.PP
\&\fIdelete all elements within an array?\fR
.PP
\&\f(CW\*(C`$sao3\->clear();\*(C'\fR
.PP
\&\f(CW\*(C`$sao3\->splice();\*(C'\fR
.PP
\&\fImodify the object \s-1AND\s0 assign a value at the same time?\fR
.PP
\&\f(CW\*(C`my @unique = $sao1\->unique\->print;\*(C'\fR
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
There is a bug in the \fIWant\-0.05\fR module that currently prevents the use of
most of the overloaded operators, though you can still use the corresponding
method names.  The equality operators \fB==\fR and \fB!=\fR should work, however.
.PP
There are still bugs in Want V 0.20. See the discussion of \*(L"difference($one, \f(CW$two\fR)\*(R" for details.
.SH "FUTURE PLANS"
.IX Header "FUTURE PLANS"
Anyone want a built-in '\fBpermute()\fR' method?
.PP
I am always on the lookout for faster algorithms.  If you heve looked at the code
for a particular method and you know of a faster way, please email me.  Be
prepared to backup your claims with benchmarks (and the benchmark code you
used).  Tests on more than one operating system are preferable.  No, \fImap\fR is
not always faster \- \fIforeach\fR loops usually are in my experience.
.PP
More flexibility with the foreach method (perhaps with iterators?).
.PP
More tests.
.SH "THANKS"
.IX Header "THANKS"
Thanks to all the kind (and sometimes grumpy) folks at comp.lang.perl.misc who
helped me with problems and ideas I had.
.PP
Thanks also to Robin Houston for the 'Want' module!  Where would method
chaining be without it?
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author: Daniel Berger
djberg96 at hotmail dot com
imperator on \s-1IRC\s0 (freenode)
.PP
Maintainer since V 0.12: Ron Savage \fI<ron@savage.net.au>\fR (in 2005).
.PP
Home page: http://savage.net.au/index.html
