.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Netdisco::DB::ResultSet::Device 3"
.TH App::Netdisco::DB::ResultSet::Device 3 "2020-11-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "ADDITIONAL METHODS"
.IX Header "ADDITIONAL METHODS"
.ie n .SS "device_ips_with_address_or_name( $address_or_name )"
.el .SS "device_ips_with_address_or_name( \f(CW$address_or_name\fP )"
.IX Subsection "device_ips_with_address_or_name( $address_or_name )"
Returns a correlated subquery for the set of \f(CW\*(C`device_ip\*(C'\fR entries for each
device. The \s-1IP\s0 alias or dns matches the supplied \f(CW\*(C`address_or_name\*(C'\fR, using
\&\f(CW\*(C`ILIKE\*(C'\fR.
.ie n .SS "ports_with_mac( $mac )"
.el .SS "ports_with_mac( \f(CW$mac\fP )"
.IX Subsection "ports_with_mac( $mac )"
Returns a correlated subquery for the set of \f(CW\*(C`device_port\*(C'\fR entries for each
device. The port \s-1MAC\s0 address matches the supplied \f(CW\*(C`mac\*(C'\fR, using \f(CW\*(C`ILIKE\*(C'\fR.
.SS "with_times"
.IX Subsection "with_times"
This is a modifier for any \f(CW\*(C`search()\*(C'\fR (including the helpers below) which
will add the following additional synthesized columns to the result set:
.IP "uptime_age" 4
.IX Item "uptime_age"
.PD 0
.IP "first_seen_stamp" 4
.IX Item "first_seen_stamp"
.IP "last_discover_stamp" 4
.IX Item "last_discover_stamp"
.IP "last_macsuck_stamp" 4
.IX Item "last_macsuck_stamp"
.IP "last_arpnip_stamp" 4
.IX Item "last_arpnip_stamp"
.IP "since_first_seen" 4
.IX Item "since_first_seen"
.IP "since_last_discover" 4
.IX Item "since_last_discover"
.IP "since_last_macsuck" 4
.IX Item "since_last_macsuck"
.IP "since_last_arpnip" 4
.IX Item "since_last_arpnip"
.PD
.ie n .SS "search_aliases( {$name or $ip or $prefix}, \e%options? )"
.el .SS "search_aliases( {$name or \f(CW$ip\fP or \f(CW$prefix\fP}, \e%options? )"
.IX Subsection "search_aliases( {$name or $ip or $prefix}, %options? )"
Tries to find devices in Netdisco which have an identity corresponding to
\&\f(CW$name\fR, \f(CW$ip\fR or \f(CW$prefix\fR.
.PP
The search is across all aliases of the device, as well as its \*(L"root \s-1IP\*(R"\s0
identity. Note that this search will try \fBnot\fR to use \s-1DNS,\s0 in case the current
name for an \s-1IP\s0 does not correspond to the data within Netdisco.
.PP
Passing a zero value to the \f(CW\*(C`partial\*(C'\fR key of the \f(CW\*(C`options\*(C'\fR hashref will
prevent partial matching of a host name. Otherwise the default is to perform
a partial, case-insensitive search on the host name fields.
.ie n .SS "search_for_device( $name or $ip or $prefix )"
.el .SS "search_for_device( \f(CW$name\fP or \f(CW$ip\fP or \f(CW$prefix\fP )"
.IX Subsection "search_for_device( $name or $ip or $prefix )"
This is a wrapper for \f(CW\*(C`search_aliases\*(C'\fR which:
.IP "\(bu" 4
Disables partial matching on host names
.IP "\(bu" 4
Returns only the first result of any found devices
.PP
If no matching devices are found, \f(CW\*(C`undef\*(C'\fR is returned.
.SS "search_by_field( \e%cond, \e%attrs? )"
.IX Subsection "search_by_field( %cond, %attrs? )"
This variant of the standard \f(CW\*(C`search()\*(C'\fR method returns a ResultSet of Device
entries. It is written to support web forms which accept fields that match and
locate Devices in the database.
.PP
The hashref parameter should contain fields from the Device table which will
be intelligently used in a search query.
.PP
In addition, you can provide the key \f(CW\*(C`matchall\*(C'\fR which, given a True or False
value, controls whether fields must all match or whether any can match, to
select a row.
.PP
Supported keys:
.IP "matchall" 4
.IX Item "matchall"
If a True value, fields must all match to return a given row of the Device
table, otherwise any field matching will cause the row to be included in
results.
.IP "name" 4
.IX Item "name"
Can match the \f(CW\*(C`name\*(C'\fR field as a substring.
.IP "location" 4
.IX Item "location"
Can match the \f(CW\*(C`location\*(C'\fR field as a substring.
.IP "description" 4
.IX Item "description"
Can match the \f(CW\*(C`description\*(C'\fR field as a substring (usually this field contains
a description of the vendor operating system).
.IP "mac" 4
.IX Item "mac"
Will match exactly the \f(CW\*(C`mac\*(C'\fR field of the Device or any of its Interfaces.
.IP "model" 4
.IX Item "model"
Will match exactly the \f(CW\*(C`model\*(C'\fR field.
.IP "os" 4
.IX Item "os"
Will match exactly the \f(CW\*(C`os\*(C'\fR field, which is the operating system.
.IP "os_ver" 4
.IX Item "os_ver"
Will match exactly the \f(CW\*(C`os_ver\*(C'\fR field, which is the operating system software version.
.IP "vendor" 4
.IX Item "vendor"
Will match exactly the \f(CW\*(C`vendor\*(C'\fR (manufacturer).
.IP "dns" 4
.IX Item "dns"
Can match any of the Device \s-1IP\s0 address aliases as a substring.
.IP "ip" 4
.IX Item "ip"
Can be a string \s-1IP\s0 or a NetAddr::IP object, either way being treated as an
IPv4 or IPv6 prefix within which the device must have one \s-1IP\s0 address alias.
.IP "layers" 4
.IX Item "layers"
\&\s-1OSI\s0 Layers which the device must support.
.ie n .SS "search_fuzzy( $value )"
.el .SS "search_fuzzy( \f(CW$value\fP )"
.IX Subsection "search_fuzzy( $value )"
This method accepts a single parameter only and returns a ResultSet of rows
from the Device table where one field matches the passed parameter.
.PP
The following fields are inspected for a match:
.IP "contact" 4
.IX Item "contact"
.PD 0
.IP "serial" 4
.IX Item "serial"
.IP "module serials (exact)" 4
.IX Item "module serials (exact)"
.IP "location" 4
.IX Item "location"
.IP "name" 4
.IX Item "name"
.IP "mac (including port addresses)" 4
.IX Item "mac (including port addresses)"
.IP "description" 4
.IX Item "description"
.IP "dns" 4
.IX Item "dns"
.IP "ip (including aliases)" 4
.IX Item "ip (including aliases)"
.PD
.SS "carrying_vlan( \e%cond, \e%attrs? )"
.IX Subsection "carrying_vlan( %cond, %attrs? )"
.Vb 1
\& my $set = $rs\->carrying_vlan({ vlan => 123 });
.Ve
.PP
Like \f(CW\*(C`search()\*(C'\fR, this returns a ResultSet of matching rows from the Device
table.
.PP
The returned devices each are aware of the given Vlan.
.IP "\(bu" 4
The \f(CW\*(C`cond\*(C'\fR parameter must be a hashref containing a key \f(CW\*(C`vlan\*(C'\fR with
the value to search for.
.IP "\(bu" 4
Results are ordered by the Device \s-1DNS\s0 and \s-1IP\s0 fields.
.IP "\(bu" 4
Column \f(CW\*(C`pcount\*(C'\fR gives a count of the number of ports on the device
that are actually configured to carry the \s-1VLAN.\s0
.SS "carrying_vlan_name( \e%cond, \e%attrs? )"
.IX Subsection "carrying_vlan_name( %cond, %attrs? )"
.Vb 1
\& my $set = $rs\->carrying_vlan_name({ name => \*(AqBranch Office\*(Aq });
.Ve
.PP
Like \f(CW\*(C`search()\*(C'\fR, this returns a ResultSet of matching rows from the Device
table.
.PP
The returned devices each are aware of the named Vlan.
.IP "\(bu" 4
The \f(CW\*(C`cond\*(C'\fR parameter must be a hashref containing a key \f(CW\*(C`name\*(C'\fR with
the value to search for. The value may optionally include \s-1SQL\s0 wildcard
characters.
.IP "\(bu" 4
Results are ordered by the Device \s-1DNS\s0 and \s-1IP\s0 fields.
.IP "\(bu" 4
Column \f(CW\*(C`pcount\*(C'\fR gives a count of the number of ports on the device
that are actually configured to carry the \s-1VLAN.\s0
.ie n .SS "has_layer( $layer )"
.el .SS "has_layer( \f(CW$layer\fP )"
.IX Subsection "has_layer( $layer )"
.Vb 1
\& my $rset = $rs\->has_layer(3);
.Ve
.PP
This predefined \f(CW\*(C`search()\*(C'\fR returns a ResultSet of matching rows from the
Device table of devices advertising support of the supplied layer in the
\&\s-1OSI\s0 Model.
.IP "\(bu" 4
The \f(CW\*(C`layer\*(C'\fR parameter must be an integer between 1 and 7.
.SS "get_platforms"
.IX Subsection "get_platforms"
Returns a sorted list of Device models with the following columns only:
.IP "vendor" 4
.IX Item "vendor"
.PD 0
.IP "model" 4
.IX Item "model"
.IP "count" 4
.IX Item "count"
.PD
.PP
Where \f(CW\*(C`count\*(C'\fR is the number of instances of that Vendor's Model in the
Netdisco database.
.SS "get_releases"
.IX Subsection "get_releases"
Returns a sorted list of Device \s-1OS\s0 releases with the following columns only:
.IP "os" 4
.IX Item "os"
.PD 0
.IP "os_ver" 4
.IX Item "os_ver"
.IP "count" 4
.IX Item "count"
.PD
.PP
Where \f(CW\*(C`count\*(C'\fR is the number of devices running that \s-1OS\s0 release in the
Netdisco database.
.SS "with_port_count"
.IX Subsection "with_port_count"
This is a modifier for any \f(CW\*(C`search()\*(C'\fR which
will add the following additional synthesized column to the result set:
.IP "port_count" 4
.IX Item "port_count"
.SH "SPECIAL METHODS"
.IX Header "SPECIAL METHODS"
.SS "delete( \e%options? )"
.IX Subsection "delete( %options? )"
Overrides the built-in DBIx::Class delete method to more efficiently
handle the removal or archiving of nodes.
