.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Compare 3"
.TH DBIx::Compare 3 "2009-02-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Compare \- Compare database content
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use DBIx::Compare;
\&
\&        my $oDB_Comparison = db_comparison\->new($dbh1,$dbh2);
\&        $oDB_Comparison\->verbose;
\&        $oDB_Comparison\->compare;
\&        $oDB_Comparison\->deep_compare;
\&        $oDB_Comparison\->deep_compare(@aTable_Names);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Compare takes two database handles and performs comparisons of their table content.
.SH "DATABASE CONNECT DESCRIPTORS"
.IX Header "DATABASE CONNECT DESCRIPTORS"
The database name is required for some operations. Unfortunately the variety of possible syntax for a connection description makes extraction of this difficult. This problem is worked around by placing some restrictions on the syntax:
.PP
These connection descriptions are allowed:
.PP
.Vb 3
\&        "...[database|dbname]=mydb;..." or
\&        "mydb:..." or
\&        "mydb;..."
.Ve
.PP
i.e using the \*(L"database\*(R" or \*(L"dbname\*(R" keyword or else specifying the database name as the first field.
.PP
Other variants will result in the error:
	DBIx::Compare \s-1ERROR\s0; Cannot extract database name from connection string: ...";
.SH "COMPARISON METHODS"
.IX Header "COMPARISON METHODS"
.SS "deep_compare, deep_compare(@aTables)"
.IX Subsection "deep_compare, deep_compare(@aTables)"
When called without any arguments, this method performs a row-by-row comparison on any table that passes the rapid comparison test (see \*(L"compare\*(R"). Returns true if the tables are identical, false/undef if a difference was found. In verbose mode, reports differences found \fIas per\fR \*(L"compare\*(R", together with the table name and row number of any differences found by the row-by-row comparison.
.PP
When passed a list of table names, deep_compare is forced to perform the row-by-row comparison of each table, instead of only analysing those tables that pass the rapid comparison test. This can be useful to track down where the differences actually are.
.PP
All differences can also be returned using the \*(L"get_differences\*(R" method.
.SS "Rapid (low-level) comparisons"
.IX Subsection "Rapid (low-level) comparisons"
.IP "\fBcompare\fR" 4
.IX Item "compare"
Performs a low level comparison. Calls the methods compare_table_lists, compare_table_fields, compare_row_counts and (if available) compare_table_stats. Returns true if no differences are found, otherwise returns undef.
.IP "\fBcompare_table_lists\fR" 4
.IX Item "compare_table_lists"
Simple comparison of the table names. Returns true if no differences are found, otherwise returns undef. An array ref of tables unique to each database:host can be recovered with \fBget_differences()\fR, using the hash key \f(CW\*(AqTables unique to \f(CI[db name:host]\f(CW\*(Aq\fR
.IP "\fBcompare_table_fields\fR" 4
.IX Item "compare_table_fields"
Simple comparison of each table's field names. Returns true if no differences are found, otherwise returns undef. An array ref of fields unique to each database:host can be recovered with \fBget_differences()\fR, using the hash key \f(CW\*(AqFields unique to \f(CI[db name:host.table]\f(CW\*(Aq\fR
.IP "\fBcompare_row_counts\fR" 4
.IX Item "compare_row_counts"
Comparison of the row counts from each table. Can pass a table name, or will compare all tables. Returns true if no differences are found, otherwise returns undef. An array ref of tables with different row counts can be recovered with \fBget_differences()\fR, using the hash key \f(CW\*(AqRow count\*(Aq\fR.
.IP "\fBcompare_table_stats\fR" 4
.IX Item "compare_table_stats"
Aggregate (mathematical) comparisons of each table field. For numeric fields, compares the average, minimum, maximum and standard deviation of all values. For string fields, performs these comparisons on the length (in bytes) of each string. For date/time fields, performs these comparisons on the numeric value of the date/time (when possible). Clearly, the value of these comparisons will vary hugely \- but where there is enough variety in the table content, this can be informative of any differences.
.Sp
Returns true if no differences are found, or if the function is not supported for a particular database driver, or if there is no DBIx::Compare:: plug-in for that driver. Otherwise returns undef. An array ref of tables with different row counts can be recovered with \fBget_differences()\fR, using the hash key \f(CW\*(AqBad fields in table \f(CI[db name:host.table]\f(CW\*(Aq\fR.
.Sp
The \s-1SQL\s0 statements behind this method are provided by plug-in modules to DBIx::Compare, since the relevant \s-1SQL\s0 functions vary depending on the dialect. If a plug-in for your \s-1DBMS\s0 is not found, its easy enough to create one.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.IP "\fBnew($dbh1,$dbh2)\fR" 4
.IX Item "new($dbh1,$dbh2)"
You must pass two database handles at initialisation, and each database must be the same type.
.IP "\fBverbose\fR" 4
.IX Item "verbose"
Generates verbose output. Default is not verbose.
.IP "\fBget_primary_keys($table,$dbh)\fR" 4
.IX Item "get_primary_keys($table,$dbh)"
Returns the primary keys (in key order) for the given table/database, either as a list or as a comma separated string.
.IP "\fBget_differences\fR" 4
.IX Item "get_differences"
Returns a hashref of differences between the two databases, where keys are the source of the difference, and values are an array ref of the differences found (see comparison methods above for details).
.IP "\fBget_tables\fR" 4
.IX Item "get_tables"
Returns a table list. Returns a 2D list of tables in list context, or just a list of tables in database1 in scalar context;
.Sp
.Vb 2
\&        my @aList = $oDB_Comparison\->get_tables;        # returns ([\*(Aqtable1\*(Aq,\*(Aqtable2\*(Aq,etc],[\*(Aqtable1\*(Aq,\*(Aqtable2\*(Aq,etc])
\&        my $aList = $oDB_Comparison\->get_tables;        # returns [\*(Aqtable1\*(Aq,\*(Aqtable2\*(Aq,etc]
.Ve
.IP "\fBcommon_tables\fR" 4
.IX Item "common_tables"
Returns a list of tables common to both databases. Recursively cals \fBcompare_table_lists()\fR if not already called.
.IP "\fBsimilar_tables\fR" 4
.IX Item "similar_tables"
Returns a list of tables common to both databases and with identical row counts. Recursively cals \fBcompare_table_lists()\fR and \fBcompare_row_counts()\fR if not already called.
.IP "\fBfield_list($table)\fR" 4
.IX Item "field_list($table)"
Returns a list of fields for the particular table that are common in both databases.
.SH "AUTHOR"
.IX Header "AUTHOR"
Christopher Jones, Gynaecological Cancer Research Laboratories, \s-1UCL EGA\s0 Institute for Women's Health, University College London.
.PP
c.jones@ucl.ac.uk
.PP
With some enhancements and bug fixes from;
.PP
Mark Kirkwood, Catalyst \s-1IT\s0 Limited, New Zealand.
.PP
mark.kirkwood@gmail.com
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008 by Christopher Jones, University College London
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
