.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Table::Text 3"
.TH Data::Table::Text 3 "2020-11-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Data::Table::Text \- Write data in tabular text format.
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  use Data::Table::Text;
.Ve
.PP
# Print a table:
.PP
.Vb 4
\&  my $d =
\&   [[qq(a), qq(b\enbb), qq(c\encc\enccc\en)],
\&    [qq(1), qq(1\en22), qq(1\en22\en333\en)],
\&   ];
\&
\&  my $t = formatTable($d, [qw(A BB CCC)]);
\&
\&  ok $t eq <<END;
\&     A  BB  CCC
\&  1  a  b   c
\&        bb  cc
\&            ccc
\&  2  1   1    1
\&        22   22
\&            333
\&  END
.Ve
.PP
# Print a table containing tables and make it into a report:
.PP
.Vb 3
\&  my $D = [[qq(See the\entable\enopposite), $t],
\&           [qq(Or\enthis\enone),            $t],
\&          ];
\&
\&
\&  my $T = formatTable($D, [qw(Description Table)], head=><<END);
\&  Table of Tables.
\&
\&  Table has NNNN rows each of which contains a table.
\&  END
\&
\&  ok $T eq <<END;
\&  Table of Tables.
\&
\&  Table has 2 rows each of which contains a table.
\&
\&
\&     Description  Table
\&  1  See the         A  BB  CCC
\&     table        1  a  b   c
\&     opposite           bb  cc
\&                            ccc
\&                  2  1   1    1
\&                        22   22
\&                            333
\&  2  Or              A  BB  CCC
\&     this         1  a  b   c
\&     one                bb  cc
\&                            ccc
\&                  2  1   1    1
\&                        22   22
\&                            333
\&  END
.Ve
.PP
# Print an array of arrays:
.PP
.Vb 6
\&  my $aa = formatTable
\&   ([[qw(A   B   C  )],
\&     [qw(AA  BB  CC )],
\&     [qw(AAA BBB CCC)],
\&     [qw(1   22  333)]],
\&     [qw (aa  bb  cc)]);
\&
\&  ok $aa eq <<END;
\&     aa   bb   cc
\&  1  A    B    C
\&  2  AA   BB   CC
\&  3  AAA  BBB  CCC
\&  4    1   22  333
\&  END
.Ve
.PP
# Print an array of hashes:
.PP
.Vb 5
\&  my $ah = formatTable
\&   ([{aa=> "A",   bb => "B",   cc => "C" },
\&     {aa=> "AA",  bb => "BB",  cc => "CC" },
\&     {aa=> "AAA", bb => "BBB", cc => "CCC" },
\&     {aa=> 1,     bb => 22,    cc => 333 }]);
\&
\&  ok $ah eq <<END;
\&     aa   bb   cc
\&  1  A    B    C
\&  2  AA   BB   CC
\&  3  AAA  BBB  CCC
\&  4    1   22  333
\&  END
.Ve
.PP
# Print a hash of arrays:
.PP
.Vb 8
\&  my $ha = formatTable
\&   ({""     => ["aa",  "bb",  "cc"],
\&     "1"    => ["A",   "B",   "C"],
\&     "22"   => ["AA",  "BB",  "CC"],
\&     "333"  => ["AAA", "BBB", "CCC"],
\&     "4444" => [1,      22,    333]},
\&     [qw(Key A B C)]
\&     );
\&
\&  ok $ha eq <<END;
\&  Key   A    B    C
\&        aa   bb   cc
\&     1  A    B    C
\&    22  AA   BB   CC
\&   333  AAA  BBB  CCC
\&  4444    1   22  333
\&  END
.Ve
.PP
# Print a hash of hashes:
.PP
.Vb 5
\&  my $hh = formatTable
\&   ({a    => {aa=>"A",   bb=>"B",   cc=>"C" },
\&     aa   => {aa=>"AA",  bb=>"BB",  cc=>"CC" },
\&     aaa  => {aa=>"AAA", bb=>"BBB", cc=>"CCC" },
\&     aaaa => {aa=>1,     bb=>22,    cc=>333 }});
\&
\&  ok $hh eq <<END;
\&        aa   bb   cc
\&  a     A    B    C
\&  aa    AA   BB   CC
\&  aaa   AAA  BBB  CCC
\&  aaaa    1   22  333
\&  END
.Ve
.PP
# Print an array of scalars:
.PP
.Vb 1
\&  my $a = formatTable(["a", "bb", "ccc", 4], [q(#), q(Col)]);
\&
\&  ok $a eq <<END;
\&  #  Col
\&  0  a
\&  1  bb
\&  2  ccc
\&  3    4
\&  END
.Ve
.PP
# Print a hash of scalars:
.PP
.Vb 1
\&  my $h = formatTable({aa=>"AAAA", bb=>"BBBB", cc=>"333"}, [qw(Key Title)]);
\&
\&  ok $h eq <<END;
\&  Key  Title
\&  aa   AAAA
\&  bb   BBBB
\&  cc     333
\&  END
.Ve
.SH "Description"
.IX Header "Description"
Write data in tabular text format.
.PP
Version 20201030.
.PP
The following sections describe the methods in each functional area of this
module.  For an alphabetic listing of all methods by name see Index.
.SH "Immediately useful methods"
.IX Header "Immediately useful methods"
These methods are the ones most likely to be of immediate use to anyone using
this module for the first time:
.PP
absFromAbsPlusRel($a, \f(CW$r\fR)
.PP
Absolute file from an absolute file \fB\f(CB$a\fB\fR plus a relative file \fB\f(CB$r\fB\fR. In the event that the relative file \f(CW$r\fR is, in fact, an absolute file then it is returned as the result.
.PP
awsParallelProcessFiles($userData, \f(CW$parallel\fR, \f(CW$results\fR, \f(CW$files\fR, \f(CW%options\fR)
.PP
Process files in parallel across multiple Amazon Web Services <http://aws.amazon.com> instances if available or in series if not.  The data located by \fB\f(CB$userData\fB\fR is transferred from the primary instance, as determined by awsParallelPrimaryInstanceId, to all the secondary instances. \fB\f(CB$parallel\fB\fR contains a reference to a sub, parameterized by array \f(CW@_\fR = (a copy of the user data, the name of the file to process), which will be executed upon each session instance including the primary instance to update \f(CW$userData\fR. \fB\f(CB$results\fB\fR contains a reference to a sub, parameterized by array \f(CW@_\fR = (the user data, an array of results returned by each execution of \f(CW$parallel\fR), that will be called on the primary instance to process the results folders from each instance once their results folders have been copied back and merged into the results folder of the primary instance. \f(CW$results\fR should update its copy of \f(CW$userData\fR with the information received from each instance. \fB\f(CB$files\fB\fR is a reference to an array of the files to be processed: each file will be copied from the primary instance to each of the secondary instances before parallel processing starts. \fB\f(CB%options\fB\fR contains any parameters needed to interact with \s-1EC2\s0 <https://aws.amazon.com/ec2/>  via the Amazon Web Services Command Line Interface <https://aws.amazon.com/cli/>.  The returned result is that returned by sub \f(CW$results\fR.
.PP
clearFolder($folder, \f(CW$limitCount\fR, \f(CW$noMsg\fR)
.PP
Remove all the files and folders under and including the specified \fB\f(CB$folder\fB\fR as long as the number of files to be removed is less than the specified \fB\f(CB$limitCount\fB\fR. Sometimes the folder can be emptied but not removed \- perhaps because it a link, in this case a message is produced unless suppressed by the optional \fB\f(CB$nomsg\fB\fR parameter.
.PP
dateTimeStamp
.PP
Year-monthNumber-day at hours:minute:seconds
.PP
execPerlOnRemote($code, \f(CW$ip\fR)
.PP
Execute some Perl \fB\f(CB$code\fB\fR on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
filePathExt(@File)
.PP
Create a file name from a list of  names the last of which is assumed to be the extension of the file name. Identical to fpe.
.PP
fn($file)
.PP
Remove the path and extension from a file name.
.PP
formatTable($data, \f(CW$columnTitles\fR, \f(CW@options\fR)
.PP
Format various \fB\f(CB$data\fB\fR structures as a table with titles as specified by \fB\f(CB$columnTitles\fB\fR: either a reference to an array of column titles or a string each line of which contains the column title as the first word with the rest of the line describing that column.
.PP
Optionally create a report from the table using the report \fB\f(CB%options\fB\fR described in formatTableCheckKeys
.PP
genHash($bless, \f(CW%attributes\fR)
.PP
Return a \fB\f(CB$bless\fB\fRed hash with the specified \fB\f(CB$attributes\fB\fR accessible via lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> method calls. updateDocumentation will generate documentation at \*(L"Hash Definitions\*(R" for the hash defined by the call to genHash if the call is laid out as in the example below.
.PP
readFile($file)
.PP
Return the content of a file residing on the local machine interpreting the content of the file as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
readFileFromRemote($file, \f(CW$ip\fR)
.PP
Copy and read a \fB\f(CB$file\fB\fR from the remote machine whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp and return the content of \f(CW$file\fR interpreted as utf8 .
.PP
relFromAbsAgainstAbs($a, \f(CW$b\fR)
.PP
Relative file from one absolute file \fB\f(CB$a\fB\fR against another \fB\f(CB$b\fB\fR.
.PP
runInParallel($maximumNumberOfProcesses, \f(CW$parallel\fR, \f(CW$results\fR, \f(CW@array\fR)
.PP
Process the elements of an array in parallel using a maximum of \fB\f(CB$maximumNumberOfProcesses\fB\fR processes. sub \fB&$parallel\fR is forked to process each array element in parallel. The results returned by the forked copies of &$parallel are presented as a single array to sub \fB&$results\fR which is run in series. \fB\f(CB@array\fB\fR contains the elements to be processed. Returns the result returned by &$results.
.PP
searchDirectoryTreesForMatchingFiles(@FoldersandExtensions)
.PP
Search the specified directory trees for the files (not folders) that match the specified extensions. The argument list should include at least one path name to be useful. If no file extensions are supplied then all the files below the specified paths are returned.  Arguments wrapped in [] will be unwrapped.
.PP
writeFile($file, \f(CW$string\fR)
.PP
Write to a new \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>. Return the name of the \f(CW$file\fR written to on success else confess if the file already exists or any other error occurs.
.PP
writeFileToRemote($file, \f(CW$string\fR, \f(CW$ip\fR)
.PP
Write to a new \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8> then copy the \f(CW$file\fR to the remote server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. Return the name of the \f(CW$file\fR on success else confess if the file already exists or any other error occurs.
.PP
xxxr($cmd, \f(CW$ip\fR)
.PP
Execute a command \fB\f(CB$cmd\fB\fR via bash on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. The command will be run using the userid listed in \fI.ssh/config\fR
.SH "Time stamps"
.IX Header "Time stamps"
Date and timestamps as used in logs of long running commands.
.SS "\fBdateTimeStamp()\fP"
.IX Subsection "dateTimeStamp()"
Year-monthNumber-day at hours:minute:seconds
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok dateTimeStamp     =~ m(\eA\ed{4}\-\ed\ed\-\ed\ed at \ed\ed:\ed\ed:\ed\ed\eZ), q(dts);         # XXXXXXX
.Ve
.SS "\fBdateTimeStampName()\fP"
.IX Subsection "dateTimeStampName()"
Date time stamp without white space.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok dateTimeStampName =~ m(\eA_on_\ed{4}_\ed\ed_\ed\ed_at_\ed\ed_\ed\ed_\ed\ed\eZ);             # XXXXXXX
.Ve
.SS "\fBdateStamp()\fP"
.IX Subsection "dateStamp()"
Year-monthName-day
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok dateStamp         =~ m(\eA\ed{4}\-\ew{3}\-\ed\ed\eZ);                                  # XXXXXXX
.Ve
.SS "\fBversionCode()\fP"
.IX Subsection "versionCode()"
YYYYmmdd-HHMMSS
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok versionCode       =~ m(\eA\ed{8}\-\ed{6}\eZ);                                       # XXXXXXX
.Ve
.SS "\fBversionCodeDashed()\fP"
.IX Subsection "versionCodeDashed()"
YYYY\-mm\-dd\-HH:MM:SS
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok versionCodeDashed =~ m(\eA\ed{4}\-\ed\ed\-\ed\ed\-\ed\ed:\ed\ed:\ed\ed\eZ);                    # XXXXXXX
.Ve
.SS "\fBtimeStamp()\fP"
.IX Subsection "timeStamp()"
hours:minute:seconds
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok timeStamp         =~ m(\eA\ed\ed:\ed\ed:\ed\ed\eZ);                                    # XXXXXXX
.Ve
.SS "\fBmicroSecondsSinceEpoch()\fP"
.IX Subsection "microSecondsSinceEpoch()"
Micro seconds since unix epoch.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok microSecondsSinceEpoch > 47*365*24*60*60*1e6;                                  # XXXXXXX
.Ve
.SH "Command execution"
.IX Header "Command execution"
Various ways of processing commands and writing results.
.SS "ddd(@data)"
.IX Subsection "ddd(@data)"
Dump data
.PP
.Vb 2
\&     Parameter  Description
\&  1  @data      Messages
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ddd "Hello";                                                                      # XXXXXXX
.Ve
.ie n .SS "fff($line, $file, @m)"
.el .SS "fff($line, \f(CW$file\fP, \f(CW@m\fP)"
.IX Subsection "fff($line, $file, @m)"
Confess a message with a line position and a file that Geany will jump to if clicked on.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $line      Line
\&  2  $file      File
\&  3  @m         Messages
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  fff _\|_LINE_\|_, _\|_FILE_\|_, "Hello world";                                            # XXXXXXX
.Ve
.SS "lll(@messages)"
.IX Subsection "lll(@messages)"
Log messages with a time stamp and originating file and line number.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @messages  Messages
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  lll "Hello world";                                                                # XXXXXXX
.Ve
.SS "mmm(@messages)"
.IX Subsection "mmm(@messages)"
Log messages with a differential time in milliseconds and originating file and line number.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @messages  Messages
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  mmm "Hello world";                                                                # XXXXXXX
.Ve
.SS "xxx(@cmd)"
.IX Subsection "xxx(@cmd)"
Execute a shell command optionally checking its response. The command to execute is specified as one or more strings which are joined together after removing any new lines. Optionally the last string can be a regular expression that is used to test any non blank output generated by the execution of the command: if the regular expression fails the command and the command output are printed, else it is suppressed as being uninteresting. If such a regular expression is not supplied then the command and its non blank output lines are always printed.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @cmd       Command to execute followed by an optional regular expression to test the results
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&   {ok xxx("echo aaa")       =~ /aaa/;                                              # XXXXXXX
.Ve
.ie n .SS "xxxr($cmd, $ip)"
.el .SS "xxxr($cmd, \f(CW$ip\fP)"
.IX Subsection "xxxr($cmd, $ip)"
Execute a command \fB\f(CB$cmd\fB\fR via bash on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. The command will be run using the userid listed in \fI.ssh/config\fR
.PP
.Vb 3
\&     Parameter  Description
\&  1  $cmd       Command string
\&  2  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (0)
\&
\&   {ok xxxr q(pwd);  # XXXXXXX
\&
\&   }
.Ve
.SS "yyy($cmd)"
.IX Subsection "yyy($cmd)"
Execute a block of shell commands line by line after removing comments \- stop if there is a non zero return code from any command.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $cmd       Commands to execute separated by new lines
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok !yyy <<END;                                                                  # XXXXXXX
\&
\&  echo aaa
\&  echo bbb
\&  END
.Ve
.ie n .SS "zzz($cmd, $success, $returnCode, $message)"
.el .SS "zzz($cmd, \f(CW$success\fP, \f(CW$returnCode\fP, \f(CW$message\fP)"
.IX Subsection "zzz($cmd, $success, $returnCode, $message)"
Execute lines of commands after replacing new lines with && then check that the pipeline execution results in a return code of zero and that the execution results match the optional regular expression if one has been supplied; \fBconfess()\fR to an error if either check fails. To execute remotely, add \*(L"ssh ... 'echo start\*(R" as the first line and \*(L"echo end'\*(R" as the last line with the commands to be executed on the lines in between.
.PP
.Vb 5
\&     Parameter    Description
\&  1  $cmd         Commands to execute \- one per line with no trailing &&
\&  2  $success     Optional regular expression to check for acceptable results
\&  3  $returnCode  Optional regular expression to check the acceptable return codes
\&  4  $message     Message of explanation if any of the checks fail
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok zzz(<<END, qr(aaa\es*bbb)s);                                                    # XXXXXXX
\&
\&  echo aaa
\&  echo bbb
\&  END
.Ve
.ie n .SS "execPerlOnRemote($code, $ip)"
.el .SS "execPerlOnRemote($code, \f(CW$ip\fP)"
.IX Subsection "execPerlOnRemote($code, $ip)"
Execute some Perl \fB\f(CB$code\fB\fR on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $code      Code to execute
\&  2  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok execPerlOnRemote(<<\*(AqEND\*(Aq) =~ m(Hello from: t2.micro)i;  # XXXXXXX
\&
\&  #!/usr/bin/perl \-I/home/phil/perl/cpan/DataTableText/lib/
\&  use Data::Table::Text qw(:all);
\&
\&  say STDERR "Hello from: ", awsCurrentInstanceType;
\&  END
.Ve
.ie n .SS "parseCommandLineArguments($sub, $args, $valid)"
.el .SS "parseCommandLineArguments($sub, \f(CW$args\fP, \f(CW$valid\fP)"
.IX Subsection "parseCommandLineArguments($sub, $args, $valid)"
Call the specified \fB\f(CB$sub\fB\fR after classifying the specified array of [arguments] in \fB\f(CB$args\fB\fR into positional and keyword parameters. Keywords are always separated from their values by \fB=\fR. \f(CW$su\fRb([$positional], {keyword=>value}) will be called  with a reference to an array of positional parameters followed by a reference to a hash of keywords and their values. The value returned by \f(CW$sub\fR will be returned to the caller. The keywords names will be validated if \fB\f(CB$valid\fB\fR is either a reference to an array of valid keywords names or a hash of {valid keyword name => textual description}. Confess with a table of valid keywords definitions if \f(CW$valid\fR is specified and an invalid keyword argument is presented.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $sub       Sub to call
\&  2  $args      List of arguments to parse
\&  3  $valid     Optional list of valid parameters else all parameters will be accepted
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $r = parseCommandLineArguments {[@_]}  # XXXXXXX
\&
\&     [qw( aaa bbb \-c \-\-dd \-\-eee=EEEE \-f=F), q(\-\-gg=g g), q(\-\-hh=h h)];
\&    is_deeply $r,
\&      [["aaa", "bbb"],
\&       {c=>undef, dd=>undef, eee=>"EEEE", f=>"F", gg=>"g g", hh=>"h h"},
\&      ];
\&
\&  if (1)
\&
\&   {my $r = parseCommandLineArguments  # XXXXXXX
\&
\&     {ok 1;
\&      $_[1]
\&     }
\&     [qw(\-\-aAa=AAA \-\-bbB=BBB)], [qw(aaa bbb ccc)];
\&    is_deeply $r, {aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq};
\&   }
.Ve
.ie n .SS "call($sub, @our)"
.el .SS "call($sub, \f(CW@our\fP)"
.IX Subsection "call($sub, @our)"
Call the specified \fB\f(CB$sub\fB\fR in a separate child process, wait for it to complete, then copy back the named \fB\f(CB@our\fB\fR variables from the child process to the calling parent process effectively freeing any memory used during the call.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $sub       Sub to call
\&  2  @our       Names of our variable names with preceding sigils to copy back
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    our $a = q(1);
\&    our @a = qw(1);
\&    our %a = (a=>1);
\&    our $b = q(1);
\&    for(2..4) {
\&
\&      call {$a = $_  x 1e3; $a[0] = $_ x 1e2; $a{a} = $_ x 1e1; $b = 2;} qw($a @a %a);  # XXXXXXX
\&
\&      ok $a    == $_ x 1e3;
\&      ok $a[0] == $_ x 1e2;
\&      ok $a{a} == $_ x 1e1;
\&      ok $b    == 1;
\&     }
.Ve
.SH "Files and paths"
.IX Header "Files and paths"
Operations on files and paths.
.SS "Statistics"
.IX Subsection "Statistics"
Information about each file.
.PP
\fIfileSize($file)\fR
.IX Subsection "fileSize($file)"
.PP
Get the size of a \fB\f(CB$file\fB\fR in bytes.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeFile("zzz.data", "aaa");
\&
\&
\&    ok fileSize($f) == 3;                                                           # XXXXXXX
.Ve
.PP
\fIfileLargestSize(@files)\fR
.IX Subsection "fileLargestSize(@files)"
.PP
Return the largest \fB\f(CB$file\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @files     File names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = temporaryFolder;
\&    my @f = map {owf(fpe($d, $_, q(txt)), \*(AqX\*(Aq x ($_ ** 2 % 11))} 1..9;
\&
\&
\&    my $f = fileLargestSize(@f);  # XXXXXXX
\&
\&    ok fn($f) eq \*(Aq3\*(Aq, \*(Aqaaa\*(Aq;
\&
\&    my $b = folderSize($d);
\&    ok $b > 0, \*(Aqbbb\*(Aq;
\&
\&    my $c = processFilesInParallel(
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12);
\&
\&    ok 108 == $c, \*(Aqcc11\*(Aq;
\&
\&    my $C = processSizesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, map {[fileSize($_), $_]} (@f) x 12;
\&
\&    ok 108 == $C, \*(Aqcc2\*(Aq;
\&
\&    my $J = processJavaFilesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12;
\&
\&    ok 108 == $J, \*(Aqcc3\*(Aq;
\&
\&    clearFolder($d, 12);
.Ve
.PP
\fIfolderSize($folder)\fR
.IX Subsection "folderSize($folder)"
.PP
Get the size of a \fB\f(CB$folder\fB\fR in bytes.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $folder    Folder name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = temporaryFolder;
\&    my @f = map {owf(fpe($d, $_, q(txt)), \*(AqX\*(Aq x ($_ ** 2 % 11))} 1..9;
\&
\&    my $f = fileLargestSize(@f);
\&    ok fn($f) eq \*(Aq3\*(Aq, \*(Aqaaa\*(Aq;
\&
\&
\&    my $b = folderSize($d);  # XXXXXXX
\&
\&    ok $b > 0, \*(Aqbbb\*(Aq;
\&
\&    my $c = processFilesInParallel(
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12);
\&
\&    ok 108 == $c, \*(Aqcc11\*(Aq;
\&
\&    my $C = processSizesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, map {[fileSize($_), $_]} (@f) x 12;
\&
\&    ok 108 == $C, \*(Aqcc2\*(Aq;
\&
\&    my $J = processJavaFilesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12;
\&
\&    ok 108 == $J, \*(Aqcc3\*(Aq;
\&
\&    clearFolder($d, 12);
.Ve
.PP
\fIfileMd5Sum($file)\fR
.IX Subsection "fileMd5Sum($file)"
.PP
Get the Md5 sum of the content of a \fB\f(CB$file\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File or string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    fileMd5Sum(q(/etc/hosts));                                                      # XXXXXXX
\&
\&
\&    my $s = join \*(Aq\*(Aq, 1..100;
\&    my $m = q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum($s) eq $m;
\&
\&    my $f = writeFile(undef, $s);
\&
\&    ok fileMd5Sum($f) eq $m;  # XXXXXXX
\&
\&    unlink $f;
\&
\&    ok guidFromString(join \*(Aq\*(Aq, 1..100) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok guidFromMd5(stringMd5Sum(join(\*(Aq\*(Aq, 1..100))) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok md5FromGuid(q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de)) eq
\&                        q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum(q(X X X)) eq q(3c2b7c31b1011998bd7e1f66fb7c024d);
\&  }
\&
\&  if (1)
\&   {ok arraySum   (1..10) ==  55;
\&    ok arrayProduct(1..5) == 120;
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];
.Ve
.PP
\fIguidFromMd5($m)\fR
.IX Subsection "guidFromMd5($m)"
.PP
Create a guid from an md5 hash.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $m         Md5 hash
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $s = join \*(Aq\*(Aq, 1..100;
\&    my $m = q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum($s) eq $m;
\&
\&    my $f = writeFile(undef, $s);
\&    ok fileMd5Sum($f) eq $m;
\&    unlink $f;
\&
\&    ok guidFromString(join \*(Aq\*(Aq, 1..100) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&
\&    ok guidFromMd5(stringMd5Sum(join(\*(Aq\*(Aq, 1..100))) eq  # XXXXXXX
\&
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok md5FromGuid(q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de)) eq
\&                        q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum(q(X X X)) eq q(3c2b7c31b1011998bd7e1f66fb7c024d);
\&  }
\&
\&  if (1)
\&   {ok arraySum   (1..10) ==  55;
\&    ok arrayProduct(1..5) == 120;
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];
.Ve
.PP
\fImd5FromGuid($G)\fR
.IX Subsection "md5FromGuid($G)"
.PP
Recover an md5 sum from a guid.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $G         Guid
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $s = join \*(Aq\*(Aq, 1..100;
\&    my $m = q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum($s) eq $m;
\&
\&    my $f = writeFile(undef, $s);
\&    ok fileMd5Sum($f) eq $m;
\&    unlink $f;
\&
\&    ok guidFromString(join \*(Aq\*(Aq, 1..100) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok guidFromMd5(stringMd5Sum(join(\*(Aq\*(Aq, 1..100))) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&
\&    ok md5FromGuid(q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de)) eq  # XXXXXXX
\&
\&                        q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum(q(X X X)) eq q(3c2b7c31b1011998bd7e1f66fb7c024d);
\&  }
\&
\&  if (1)
\&   {ok arraySum   (1..10) ==  55;
\&    ok arrayProduct(1..5) == 120;
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];
.Ve
.PP
\fIguidFromString($string)\fR
.IX Subsection "guidFromString($string)"
.PP
Create a guid representation of the md5 sum <https://en.wikipedia.org/wiki/MD5> of the content of a string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $s = join \*(Aq\*(Aq, 1..100;
\&    my $m = q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum($s) eq $m;
\&
\&    my $f = writeFile(undef, $s);
\&    ok fileMd5Sum($f) eq $m;
\&    unlink $f;
\&
\&
\&    ok guidFromString(join \*(Aq\*(Aq, 1..100) eq  # XXXXXXX
\&
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok guidFromMd5(stringMd5Sum(join(\*(Aq\*(Aq, 1..100))) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok md5FromGuid(q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de)) eq
\&                        q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&    ok stringMd5Sum(q(X X X)) eq q(3c2b7c31b1011998bd7e1f66fb7c024d);
\&  }
\&
\&  if (1)
\&   {ok arraySum   (1..10) ==  55;
\&    ok arrayProduct(1..5) == 120;
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];
.Ve
.PP
\fIfileModTime($file)\fR
.IX Subsection "fileModTime($file)"
.PP
Get the modified time of a \fB\f(CB$file\fB\fR as seconds since the epoch.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fileModTime($0) =~ m(\eA\ed+\eZ)s;                                                # XXXXXXX
.Ve
.PP
\fIfileOutOfDate($make, \f(CI$target\fI, \f(CI@source\fI)\fR
.IX Subsection "fileOutOfDate($make, $target, @source)"
.PP
Calls the specified sub \fB\f(CB$make\fB\fR for each source file that is missing and then again against the \fB\f(CB$target\fB\fR file if any of the \fB\f(CB@source\fB\fR files were missing or the \f(CW$target\fR file is older than any of the \f(CW@source\fR files or if the target does not exist. The file name is passed to the sub each time in \f(CW$_\fR. Returns the files to be remade in the order they should be made.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $make      Make with this sub
\&  2  $target    Target file
\&  3  @source    Source files
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my @Files = qw(a b c);
\&    my @files = (@Files, qw(d));
\&    writeFile($_, $_), sleep 1 for @Files;
\&
\&    my $a = \*(Aq\*(Aq;
\&
\&    my @a = fileOutOfDate {$a .= $_} q(a), @files;  # XXXXXXX
\&
\&    ok $a eq \*(Aqda\*(Aq;
\&    is_deeply [@a], [qw(d a)];
\&
\&    my $b = \*(Aq\*(Aq;
\&
\&    my @b = fileOutOfDate {$b .= $_} q(b), @files;  # XXXXXXX
\&
\&    ok $b eq \*(Aqdb\*(Aq;
\&    is_deeply [@b], [qw(d b)];
\&
\&    my $c = \*(Aq\*(Aq;
\&
\&    my @c = fileOutOfDate {$c .= $_} q(c), @files;  # XXXXXXX
\&
\&    ok $c eq \*(Aqdc\*(Aq;
\&    is_deeply [@c], [qw(d c)];
\&
\&    my $d = \*(Aq\*(Aq;
\&
\&    my @d = fileOutOfDate {$d .= $_} q(d), @files;  # XXXXXXX
\&
\&    ok $d eq \*(Aqd\*(Aq;
\&    is_deeply [@d], [qw(d)];
\&
\&
\&    my @A = fileOutOfDate {} q(a), @Files;  # XXXXXXX
\&
\&
\&    my @B = fileOutOfDate {} q(b), @Files;  # XXXXXXX
\&
\&
\&    my @C = fileOutOfDate {} q(c), @Files;  # XXXXXXX
\&
\&    is_deeply [@A], [qw(a)];
\&    is_deeply [@B], [qw(b)];
\&    is_deeply [@C], [];
\&    unlink for @Files;
.Ve
.PP
\fIfirstFileThatExists(@files)\fR
.IX Subsection "firstFileThatExists(@files)"
.PP
Returns the name of the first file from \fB\f(CB@files\fB\fR that exists or \fBundef\fR if none of the named \f(CW@files\fR exist.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @files     Files to check
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = temporaryFolder;
\&
\&
\&    ok $d eq firstFileThatExists("$d/$d", $d);                                      # XXXXXXX
.Ve
.PP
\fIfileInWindowsFormat($file)\fR
.IX Subsection "fileInWindowsFormat($file)"
.PP
Convert a unix \fB\f(CB$file\fB\fR name to windows format
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {ok fileInWindowsFormat(fpd(qw(/a b c d))) eq q(\ea\eb\ec\ed\e\e);  # XXXXXXX
\&
\&   }
.Ve
.SS "Components"
.IX Subsection "Components"
File names and components.
.PP
\fIFusion\fR
.IX Subsection "Fusion"
.PP
Create file names from file name components.
.PP
filePath(@file)
.IX Subsection "filePath(@file)"
.PP
Create a file name from a list of  names. Identical to fpf.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @file      File name components
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok filePath   (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";  # XXXXXXX
\&
\&    ok filePathDir(qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";
\&    ok filePathDir(\*(Aq\*(Aq, qw(aaa))              eq "aaa/";
\&    ok filePathDir(\*(Aq\*(Aq)                       eq "";
\&    ok filePathExt(qw(aaa xxx))              eq "aaa.xxx";
\&    ok filePathExt(qw(aaa bbb xxx))          eq "aaa/bbb.xxx";
\&
\&    ok fpd        (qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";
\&    ok fpf        (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";
\&    ok fpe        (qw(aaa bbb xxx))          eq "aaa/bbb.xxx";
.Ve
.PP
\&\fBfpf\fR is a synonym for filePath.
.PP
filePathDir(@file)
.IX Subsection "filePathDir(@file)"
.PP
Create a folder name from a list of  names. Identical to fpd.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @file      Directory name components
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok filePath   (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";
\&
\&    ok filePathDir(qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";  # XXXXXXX
\&
\&
\&    ok filePathDir(\*(Aq\*(Aq, qw(aaa))              eq "aaa/";  # XXXXXXX
\&
\&
\&    ok filePathDir(\*(Aq\*(Aq)                       eq "";  # XXXXXXX
\&
\&    ok filePathExt(qw(aaa xxx))              eq "aaa.xxx";
\&    ok filePathExt(qw(aaa bbb xxx))          eq "aaa/bbb.xxx";
\&
\&    ok fpd        (qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";
\&    ok fpf        (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";
\&    ok fpe        (qw(aaa bbb xxx))          eq "aaa/bbb.xxx";
.Ve
.PP
\&\fBfpd\fR is a synonym for filePathDir.
.PP
filePathExt(@File)
.IX Subsection "filePathExt(@File)"
.PP
Create a file name from a list of  names the last of which is assumed to be the extension of the file name. Identical to fpe.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @File      File name components and extension
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    ok filePath   (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";
\&    ok filePathDir(qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";
\&    ok filePathDir(\*(Aq\*(Aq, qw(aaa))              eq "aaa/";
\&    ok filePathDir(\*(Aq\*(Aq)                       eq "";
\&
\&    ok filePathExt(qw(aaa xxx))              eq "aaa.xxx";  # XXXXXXX
\&
\&
\&    ok filePathExt(qw(aaa bbb xxx))          eq "aaa/bbb.xxx";  # XXXXXXX
\&
\&
\&    ok fpd        (qw(/aaa bbb ccc ddd))     eq "/aaa/bbb/ccc/ddd/";
\&    ok fpf        (qw(/aaa bbb ccc ddd.eee)) eq "/aaa/bbb/ccc/ddd.eee";
\&    ok fpe        (qw(aaa bbb xxx))          eq "aaa/bbb.xxx";
.Ve
.PP
\&\fBfpe\fR is a synonym for filePathExt.
.PP
\fIFission\fR
.IX Subsection "Fission"
.PP
Get file name components from a file name.
.PP
fp($file)
.IX Subsection "fp($file)"
.PP
Get the path from a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fp (q(a/b/c.d.e))  eq q(a/b/);                                                 # XXXXXXX
.Ve
.PP
fpn($file)
.IX Subsection "fpn($file)"
.PP
Remove the extension from a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fpn(q(a/b/c.d.e))  eq q(a/b/c.d);                                              # XXXXXXX
.Ve
.PP
fn($file)
.IX Subsection "fn($file)"
.PP
Remove the path and extension from a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fn (q(a/b/c.d.e))  eq q(c.d);                                                  # XXXXXXX
.Ve
.PP
fne($file)
.IX Subsection "fne($file)"
.PP
Remove the path from a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fne(q(a/b/c.d.e))  eq q(c.d.e);                                                # XXXXXXX
.Ve
.PP
fe($file)
.IX Subsection "fe($file)"
.PP
Get the extension of a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok fe (q(a/b/c.d.e))  eq q(e);                                                    # XXXXXXX
.Ve
.PP
checkFile($file)
.IX Subsection "checkFile($file)"
.PP
Return the name of the specified file if it exists, else confess the maximum extent of the path that does exist.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to check
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = filePath   (my @d = qw(a b c d));
\&
\&    my $f = filePathExt(qw(a b c d e x));
\&
\&    my $F = filePathExt(qw(a b c e d));
\&
\&    createEmptyFile($f);
\&
\&
\&    ok  eval{checkFile($d)};                                                        # XXXXXXX
\&
\&
\&
\&    ok  eval{checkFile($f)};                                                        # XXXXXXX
.Ve
.PP
quoteFile($file)
.IX Subsection "quoteFile($file)"
.PP
Quote a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok quoteFile(fpe(qw(a "b" c))) eq q("a/\e"b\e".c");                                 # XXXXXXX
.Ve
.PP
removeFilePrefix($prefix, \f(CW@files\fR)
.IX Subsection "removeFilePrefix($prefix, @files)"
.PP
Removes a file \fB\f(CB$prefix\fB\fR from an array of \fB\f(CB@files\fB\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $prefix    File prefix
\&  2  @files     Array of file names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [qw(a b)], [&removeFilePrefix(qw(a/ a/a a/b))];                         # XXXXXXX
\&
\&
\&
\&  is_deeply [qw(b)],   [&removeFilePrefix("a/", "a/b")];                            # XXXXXXX
.Ve
.PP
swapFilePrefix($file, \f(CW$known\fR, \f(CW$new\fR)
.IX Subsection "swapFilePrefix($file, $known, $new)"
.PP
Swaps the start of a \fB\f(CB$file\fB\fR name from a \fB\f(CB$known\fB\fR name to a \fB\f(CB$new\fB\fR one if the file does in fact start with the \f(CW$known\fR name otherwise returns the original file name as it is. If the optional \f(CW$new\fR prefix is omitted then the \f(CW$known\fR prefix is removed from the \f(CW$file\fR name.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $file      File name
\&  2  $known     Existing prefix
\&  3  $new       Optional new prefix defaults to q()
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok swapFilePrefix(q(/aaa/bbb.txt), q(/aaa/), q(/AAA/)) eq q(/AAA/bbb.txt);        # XXXXXXX
.Ve
.PP
setFileExtension($file, \f(CW$extension\fR)
.IX Subsection "setFileExtension($file, $extension)"
.PP
Given a \fB\f(CB$file\fB\fR, change its extension to \fB\f(CB$extension\fB\fR. Removes the extension if no \f(CW$extension\fR is specified.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $file       File name
\&  2  $extension  Optional new extension
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok setFileExtension(q(.c),     q(d)) eq q(.d);                                    # XXXXXXX
\&
\&
\&
\&  ok setFileExtension(q(b.c),    q(d)) eq q(b.d);                                   # XXXXXXX
\&
\&
\&
\&  ok setFileExtension(q(/a/b.c), q(d)) eq q(/a/b.d);                                # XXXXXXX
.Ve
.PP
swapFolderPrefix($file, \f(CW$known\fR, \f(CW$new\fR)
.IX Subsection "swapFolderPrefix($file, $known, $new)"
.PP
Given a \fB\f(CB$file\fB\fR, swap the folder name of the \f(CW$file\fR from \fB\f(CB$known\fB\fR to \fB\f(CB$new\fB\fR if the file \f(CW$file\fR starts with the \f(CW$known\fR folder name else return the \f(CW$file\fR as it is.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $file      File name
\&  2  $known     Existing prefix
\&  3  $new       New prefix
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $g = fpd(qw(a b c d));
\&    my $h = fpd(qw(a b cc dd));
\&    my $i = fpe($g, qw(aaa txt));
\&
\&
\&    my $j = swapFolderPrefix($i, $g, $h);  # XXXXXXX
\&
\&    ok $j =~ m(a/b/cc/dd/)s;
.Ve
.PP
fullyQualifiedFile($file, \f(CW$prefix\fR)
.IX Subsection "fullyQualifiedFile($file, $prefix)"
.PP
Check whether a \fB\f(CB$file\fB\fR name is fully qualified or not and, optionally, whether it is fully qualified with a specified \fB\f(CB$prefix\fB\fR or not.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File name to test
\&  2  $prefix    File name prefix
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok  fullyQualifiedFile(q(/a/b/c.d));                                              # XXXXXXX
\&
\&
\&
\&  ok  fullyQualifiedFile(q(/a/b/c.d), q(/a/b));                                     # XXXXXXX
\&
\&
\&
\&  ok !fullyQualifiedFile(q(/a/b/c.d), q(/a/c));                                     # XXXXXXX
\&
\&
\&
\&  ok !fullyQualifiedFile(q(c.d));                                                   # XXXXXXX
.Ve
.PP
fullyQualifyFile($file)
.IX Subsection "fullyQualifyFile($file)"
.PP
Return the fully qualified name of a file.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (0)
\&
\&   {ok fullyQualifyFile(q(perl/cpan)) eq q(/home/phil/perl/cpan/);  # XXXXXXX
\&
\&   }
.Ve
.PP
removeDuplicatePrefixes($file)
.IX Subsection "removeDuplicatePrefixes($file)"
.PP
Remove duplicated leading directory names from a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok q(a/b.c) eq removeDuplicatePrefixes("a/a/b.c");                                # XXXXXXX
\&
\&
\&
\&  ok q(a/b.c) eq removeDuplicatePrefixes("a/b.c");                                  # XXXXXXX
\&
\&
\&
\&  ok q(b.c) eq removeDuplicatePrefixes("b.c");                                      # XXXXXXX
.Ve
.PP
containingFolderName($file)
.IX Subsection "containingFolderName($file)"
.PP
The name of a folder containing a file
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok containingFolderName(q(/a/b/c.d)) eq q(b);                                     # XXXXXXX
.Ve
.SS "Position"
.IX Subsection "Position"
Position in the file system.
.PP
\fI\f(BIcurrentDirectory()\fI\fR
.IX Subsection "currentDirectory()"
.PP
Get the current working directory.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    currentDirectory;                                                               # XXXXXXX
.Ve
.PP
\fI\f(BIcurrentDirectoryAbove()\fI\fR
.IX Subsection "currentDirectoryAbove()"
.PP
Get the path to the folder above the current working folder.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    currentDirectoryAbove;                                                          # XXXXXXX
.Ve
.PP
\fIparseFileName($file)\fR
.IX Subsection "parseFileName($file)"
.PP
Parse a file name into (path, name, extension) considering .. to be always part of the path and using \fBundef\fR to mark missing components.  This differs from (fp, fn, fe) which return q() for missing components and do not interpret . or .. as anything special
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name to parse
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply [parseFileName "/home/phil/test.data"], ["/home/phil/", "test", "data"];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "/home/phil/test"],      ["/home/phil/", "test"];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "phil/test.data"],       ["phil/",       "test", "data"];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "phil/test"],            ["phil/",       "test"];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "test.data"],            [undef,         "test", "data"];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "phil/"],                [qw(phil/)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "/phil"],                [qw(/ phil)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "/"],                    [qw(/)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "/var/www/html/translations/"], [qw(/var/www/html/translations/)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "a.b/c.d.e"],            [qw(a.b/ c.d e)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "./a.b"],                [qw(./ a b)];  # XXXXXXX
\&
\&
\&    is_deeply [parseFileName "./../../a.b"],          [qw(./../../ a b)];  # XXXXXXX
\&
\&   }
.Ve
.PP
\fI\f(BIfullFileName()\fI\fR
.IX Subsection "fullFileName()"
.PP
Full name of a file.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    fullFileName(fpe(qw(a txt)));                                                   # XXXXXXX
.Ve
.PP
\fIrelFromAbsAgainstAbs($a, \f(CI$b\fI)\fR
.IX Subsection "relFromAbsAgainstAbs($a, $b)"
.PP
Relative file from one absolute file \fB\f(CB$a\fB\fR against another \fB\f(CB$b\fB\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $a         Absolute file to be made relative
\&  2  $b         Against this absolute file.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok "bbb.pl"                 eq relFromAbsAgainstAbs("/home/la/perl/bbb.pl", "/home/la/perl/aaa.pl");    # XXXXXXX
\&
\&
\&
\&  ok "../perl/bbb.pl"         eq relFromAbsAgainstAbs("/home/la/perl/bbb.pl", "/home/la/java/aaa.jv");    # XXXXXXX
.Ve
.PP
\fIabsFromAbsPlusRel($a, \f(CI$r\fI)\fR
.IX Subsection "absFromAbsPlusRel($a, $r)"
.PP
Absolute file from an absolute file \fB\f(CB$a\fB\fR plus a relative file \fB\f(CB$r\fB\fR. In the event that the relative file \f(CW$r\fR is, in fact, an absolute file then it is returned as the result.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $a         Absolute file
\&  2  $r         Relative file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok "/home/la/perl/aaa.pl"   eq absFromAbsPlusRel("/home/la/perl/bbb",      "aaa.pl");                   # XXXXXXX
\&
\&
\&
\&  ok "/home/la/perl/aaa.pl"   eq absFromAbsPlusRel("/home/il/perl/bbb.pl",   "../../la/perl/aaa.pl");      # XXXXXXX
.Ve
.PP
\fIabsFile($file)\fR
.IX Subsection "absFile($file)"
.PP
Return the name of the given file if it a fully qualified file name else returns \fBundef\fR. See: fullyQualifiedFile to check the initial prefix of the file name as well.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to test
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok "/aaa/"                  eq absFile(qw(/aaa/));                                # XXXXXXX
.Ve
.PP
\fIsumAbsAndRel(@files)\fR
.IX Subsection "sumAbsAndRel(@files)"
.PP
Combine zero or more absolute and relative names of \fB\f(CB@files\fB\fR starting at the current working folder to get an absolute file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @files     Absolute and relative file names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok "/aaa/bbb/ccc/ddd.txt"   eq sumAbsAndRel(qw(/aaa/AAA/ ../bbb/bbb/BBB/ ../../ccc/ddd.txt));   # XXXXXXX
.Ve
.SS "Temporary"
.IX Subsection "Temporary"
Temporary files and folders
.PP
\fI\f(BItemporaryFile()\fI\fR
.IX Subsection "temporaryFile()"
.PP
Create a new, empty, temporary file.
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&    my $d = fpd(my $D = temporaryDirectory, qw(a));
\&    my $f = fpe($d, qw(bbb txt));
\&    ok !\-d $d;
\&    eval q{checkFile($f)};
\&    my $r = $@;
\&    my $q = quotemeta($D);
\&    ok nws($r) =~ m(Can only find.+?: $q)s;
\&    makePath($f);
\&    ok \-d $d;
\&    ok \-d $D;
\&    rmdir $_ for $d, $D;
\&
\&    my $e = temporaryFolder;                                                      # Same as temporyDirectory
\&    ok \-d $e;
\&    clearFolder($e, 2);
\&
\&
\&    my $t = temporaryFile;  # XXXXXXX
\&
\&    ok  \-f $t;
\&    unlink $t;
\&    ok !\-f $t;
\&
\&    if (0)
\&     {makePathRemote($e);                                                         # Make a path on the remote system
\&     }
.Ve
.PP
\fI\f(BItemporaryFolder()\fI\fR
.IX Subsection "temporaryFolder()"
.PP
Create a new, empty, temporary folder.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $D = temporaryFolder;  # XXXXXXX
\&
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&    is_deeply [findDirs($D)], [$D, $d];
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
\&
\&    my $d = fpd(my $D = temporaryDirectory, qw(a));
\&    my $f = fpe($d, qw(bbb txt));
\&    ok !\-d $d;
\&    eval q{checkFile($f)};
\&    my $r = $@;
\&    my $q = quotemeta($D);
\&    ok nws($r) =~ m(Can only find.+?: $q)s;
\&    makePath($f);
\&    ok \-d $d;
\&    ok \-d $D;
\&    rmdir $_ for $d, $D;
\&
\&
\&    my $e = temporaryFolder;                                                      # Same as temporyDirectory  # XXXXXXX
\&
\&    ok \-d $e;
\&    clearFolder($e, 2);
\&
\&    my $t = temporaryFile;
\&    ok  \-f $t;
\&    unlink $t;
\&    ok !\-f $t;
\&
\&    if (0)
\&     {makePathRemote($e);                                                         # Make a path on the remote system
\&     }
.Ve
.PP
\&\fBtemporaryDirectory\fR is a synonym for temporaryFolder.
.SS "Find"
.IX Subsection "Find"
Find files and folders below a folder.
.PP
\fIfindFiles($folder, \f(CI$filter\fI)\fR
.IX Subsection "findFiles($folder, $filter)"
.PP
Find all the files under a \fB\f(CB$folder\fB\fR and optionally \fB\f(CB$filter\fB\fR the selected files with a regular expression.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $folder    Folder to start the search with
\&  2  $filter    Optional regular expression to filter files
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];  # XXXXXXX
\&
\&    is_deeply [findDirs($D)], [$D, $d];
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
.Ve
.PP
\fIfindDirs($folder, \f(CI$filter\fI)\fR
.IX Subsection "findDirs($folder, $filter)"
.PP
Find all the folders under a \fB\f(CB$folder\fB\fR and optionally \fB\f(CB$filter\fB\fR the selected folders with a regular expression.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $folder    Folder to start the search with
\&  2  $filter    Optional regular expression to filter files
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&
\&    is_deeply [findDirs($D)], [$D, $d];  # XXXXXXX
\&
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
.Ve
.PP
\fIfileList($pattern)\fR
.IX Subsection "fileList($pattern)"
.PP
Files that match a given search pattern interpreted by \*(L"bsd_glob\*(R" in perlfunc.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $pattern   Search pattern
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 9
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&    is_deeply [findDirs($D)], [$D, $d];
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],  # XXXXXXX
\&
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&
\&    my @g = fileList(qq($D/*/*.txt));  # XXXXXXX
\&
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
.Ve
.PP
\fIsearchDirectoryTreesForMatchingFiles(@FoldersandExtensions)\fR
.IX Subsection "searchDirectoryTreesForMatchingFiles(@FoldersandExtensions)"
.PP
Search the specified directory trees for the files (not folders) that match the specified extensions. The argument list should include at least one path name to be useful. If no file extensions are supplied then all the files below the specified paths are returned.  Arguments wrapped in [] will be unwrapped.
.PP
.Vb 2
\&     Parameter              Description
\&  1  @FoldersandExtensions  Mixture of folder names and extensions
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&    is_deeply [findDirs($D)], [$D, $d];
\&
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],  # XXXXXXX
\&
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
.Ve
.PP
\fIhashifyFolderStructure(@files)\fR
.IX Subsection "hashifyFolderStructure(@files)"
.PP
Hashify a list of file names to get the corresponding folder structure.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @files     File names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply hashifyFolderStructure(qw(/a/a/a /a/a/b /a/b/a /a/b/b)),  # XXXXXXX
\&
\&     {"" => {a => {a => { a => "/a/a/a", b => "/a/a/b" },
\&                   b => { a => "/a/b/a", b => "/a/b/b" },
\&                  },
\&            },
\&     };
.Ve
.PP
\fIcountFileExtensions(@folders)\fR
.IX Subsection "countFileExtensions(@folders)"
.PP
Return a hash which counts the file extensions in and below the folders in the specified list.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @folders   Folders to search
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    countFileExtensions(q(/home/phil/perl/));                                       # XXXXXXX
.Ve
.PP
\fIcountFileTypes($maximumNumberOfProcesses, \f(CI@folders\fI)\fR
.IX Subsection "countFileTypes($maximumNumberOfProcesses, @folders)"
.PP
Return a hash which counts, in parallel with a maximum number of processes: \fB\f(CB$maximumNumberOfProcesses\fB\fR, the results of applying the \fBfile\fR command to each file ina nd under the specified \fB\f(CB@folders\fB\fR.
.PP
.Vb 3
\&     Parameter                  Description
\&  1  $maximumNumberOfProcesses  Maximum number of processes to run in parallel
\&  2  @folders                   Folders to search
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    countFileTypes(4, q(/home/phil/perl/));                                         # XXXXXXX
.Ve
.PP
\fImatchPath($file)\fR
.IX Subsection "matchPath($file)"
.PP
Return the deepest folder that exists along a given file name path.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = filePath   (my @d = qw(a b c d));
\&
\&
\&    ok matchPath($d) eq $d;                                                         # XXXXXXX
.Ve
.PP
\fIfindFileWithExtension($file, \f(CI@ext\fI)\fR
.IX Subsection "findFileWithExtension($file, @ext)"
.PP
Find the first file that exists with a path and name of \fB\f(CB$file\fB\fR and an extension drawn from <@ext>.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File name minus extensions
\&  2  @ext       Possible extensions
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = createEmptyFile(fpe(my $d = temporaryFolder, qw(a jpg)));
\&
\&
\&    my $F = findFileWithExtension(fpf($d, q(a)), qw(txt data jpg));                 # XXXXXXX
\&
\&
\&    ok $F eq "jpg";
.Ve
.PP
\fIclearFolder($folder, \f(CI$limitCount\fI, \f(CI$noMsg\fI)\fR
.IX Subsection "clearFolder($folder, $limitCount, $noMsg)"
.PP
Remove all the files and folders under and including the specified \fB\f(CB$folder\fB\fR as long as the number of files to be removed is less than the specified \fB\f(CB$limitCount\fB\fR. Sometimes the folder can be emptied but not removed \- perhaps because it a link, in this case a message is produced unless suppressed by the optional \fB\f(CB$nomsg\fB\fR parameter.
.PP
.Vb 4
\&     Parameter    Description
\&  1  $folder      Folder
\&  2  $limitCount  Maximum number of files to remove to limit damage
\&  3  $noMsg       No message if the folder cannot be completely removed.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&    is_deeply [findDirs($D)], [$D, $d];
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&
\&    clearFolder($D, 5);  # XXXXXXX
\&
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
\&
\&    ok !\-d $D;
.Ve
.SS "Read and write files"
.IX Subsection "Read and write files"
Read and write strings from and to files creating paths to any created files as needed.
.PP
\fIreadFile($file)\fR
.IX Subsection "readFile($file)"
.PP
Return the content of a file residing on the local machine interpreting the content of the file as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      Name of file to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeFile(undef,  "aaa");
\&
\&    is_deeply [readFile $f], ["aaa"];  # XXXXXXX
\&
\&
\&    appendFile($f, "bbb");
\&
\&    is_deeply [readFile $f], ["aaabbb"];  # XXXXXXX
\&
\&
\&    my $F = writeTempFile(qw(aaa bbb));
\&
\&    is_deeply [readFile $F], ["aaa
\&", "bbb
\&"];  # XXXXXXX
\&
\&
\&    eval {writeFile($f,  q(ccc))};
\&    ok $@ =~ m(File already exists:)i;
\&
\&    overWriteFile($F,    q(ccc));
\&
\&    ok   readFile($F) eq q(ccc);  # XXXXXXX
\&
\&
\&    unlink $f, $F;
.Ve
.PP
\fI\f(BIreadStdIn()\fI\fR
.IX Subsection "readStdIn()"
.PP
Return the contents of \s-1STDIN\s0 and return the results as either an array or a string. Terminate with Ctrl-D if testing manually \- \s-1STDIN\s0 remains open allowing this method to be called again to receive another block of data.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = qq(aaaa);
\&    open(STDIN, "<", writeTempFile($d));
\&
\&    ok qq($d
\&) eq readStdIn;  # XXXXXXX
.Ve
.PP
\fIreadFileFromRemote($file, \f(CI$ip\fI)\fR
.IX Subsection "readFileFromRemote($file, $ip)"
.PP
Copy and read a \fB\f(CB$file\fB\fR from the remote machine whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp and return the content of \f(CW$file\fR interpreted as utf8 .
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      Name of file to read
\&  2  $ip        Optional ip address of server
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $f = writeFileToRemote(undef, q(aaaa));
\&    unlink $f;
\&
\&    ok readFileFromRemote($f) eq q(aaaa);  # XXXXXXX
\&
\&    unlink $f;
.Ve
.PP
\fIevalFile($file)\fR
.IX Subsection "evalFile($file)"
.PP
Read a file containing Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8>, \*(L"eval\*(R" in perlfunc the content, confess to any errors and then return any result with lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> methods to access each hash element.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&    my $f = dumpFile(undef, $d);
\&
\&    is_deeply evalFile($f), $d;  # XXXXXXX
\&
\&
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;  # XXXXXXX
\&
\&    unlink $f, $F;
\&
\&    my $j = dumpFileAsJson(undef, $d);
\&    is_deeply evalFileAsJson($j), $d;
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;
\&    unlink $j, $J;
.Ve
.PP
\fIevalFileAsJson($file)\fR
.IX Subsection "evalFileAsJson($file)"
.PP
Read a \fB\f(CB$file\fB\fR containing Json <https://en.wikipedia.org/wiki/JSON> and return the corresponding Perl <http://www.perl.org/> data structure.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&    my $f = dumpFile(undef, $d);
\&    is_deeply evalFile($f), $d;
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;
\&    unlink $f, $F;
\&
\&    my $j = dumpFileAsJson(undef, $d);
\&
\&    is_deeply evalFileAsJson($j), $d;  # XXXXXXX
\&
\&
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;  # XXXXXXX
\&
\&    unlink $j, $J;
.Ve
.PP
\fIevalGZipFile($file)\fR
.IX Subsection "evalGZipFile($file)"
.PP
Read a file compressed with gzip <https://en.wikipedia.org/wiki/Gzip> containing Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8>, \*(L"eval\*(R" in perlfunc the content, confess to any errors and then return any result with lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> methods to access each hash element. This is slower than using Storable <https://metacpan.org/pod/Storable> but does produce much smaller files, see also: dumpGZipFile.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $d = [1, 2, 3=>{a=>4, b=>5}];
\&    my $file = dumpGZipFile(q(zzz.zip), $d);
\&    ok \-e $file;
\&
\&    my $D = evalGZipFile($file);  # XXXXXXX
\&
\&    is_deeply $d, $D;
\&    unlink $file;
.Ve
.PP
\fIretrieveFile($file)\fR
.IX Subsection "retrieveFile($file)"
.PP
Retrieve a \fB\f(CB$file\fB\fR created via Storable <https://metacpan.org/pod/Storable>.  This is much faster than evalFile as the stored data is not in text format.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = storeFile(undef, my $d = [qw(aaa bbb ccc)]);
\&
\&    my $s = retrieveFile($f);  # XXXXXXX
\&
\&    is_deeply $s, $d;
\&    unlink $f;
.Ve
.PP
\fIreadBinaryFile($file)\fR
.IX Subsection "readBinaryFile($file)"
.PP
Read a binary file on the local machine.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeBinaryFile(undef, 0xff x 8);
\&
\&
\&    my $s = readBinaryFile($f);                                                      # XXXXXXX
\&
\&
\&    ok $s eq 0xff x 8;
.Ve
.PP
\fIreadGZipFile($file)\fR
.IX Subsection "readGZipFile($file)"
.PP
Read the specified file containing compressed Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8> through gzip <https://en.wikipedia.org/wiki/Gzip>.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to read.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $s = \*(AqX\*(Aqx1e3;
\&    my $file = writeGZipFile(q(zzz.zip), $s);
\&    ok \-e $file;
\&
\&    my $S = readGZipFile($file);  # XXXXXXX
\&
\&    ok $s eq $S;
\&    ok length($s) == length($S);
\&    unlink $file;
.Ve
.PP
\fImakePath($file)\fR
.IX Subsection "makePath($file)"
.PP
Make the path for the specified file name or folder on the local machine. Confess to any failure.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File or folder name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = fpd(my $D = temporaryDirectory, qw(a));
\&    my $f = fpe($d, qw(bbb txt));
\&    ok !\-d $d;
\&    eval q{checkFile($f)};
\&    my $r = $@;
\&    my $q = quotemeta($D);
\&    ok nws($r) =~ m(Can only find.+?: $q)s;
\&
\&    makePath($f);  # XXXXXXX
\&
\&    ok \-d $d;
\&    ok \-d $D;
\&    rmdir $_ for $d, $D;
\&
\&    my $e = temporaryFolder;                                                      # Same as temporyDirectory
\&    ok \-d $e;
\&    clearFolder($e, 2);
\&
\&    my $t = temporaryFile;
\&    ok  \-f $t;
\&    unlink $t;
\&    ok !\-f $t;
\&
\&    if (0)
\&     {makePathRemote($e);                                                         # Make a path on the remote system
\&     }
.Ve
.PP
\fImakePathRemote($file, \f(CI$ip\fI)\fR
.IX Subsection "makePathRemote($file, $ip)"
.PP
Make the path for the specified \fB\f(CB$file\fB\fR or folder on the Amazon Web Services <http://aws.amazon.com> instance whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. Confess to any failures.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File or folder name
\&  2  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&    my $d = fpd(my $D = temporaryDirectory, qw(a));
\&    my $f = fpe($d, qw(bbb txt));
\&    ok !\-d $d;
\&    eval q{checkFile($f)};
\&    my $r = $@;
\&    my $q = quotemeta($D);
\&    ok nws($r) =~ m(Can only find.+?: $q)s;
\&    makePath($f);
\&    ok \-d $d;
\&    ok \-d $D;
\&    rmdir $_ for $d, $D;
\&
\&    my $e = temporaryFolder;                                                      # Same as temporyDirectory
\&    ok \-d $e;
\&    clearFolder($e, 2);
\&
\&    my $t = temporaryFile;
\&    ok  \-f $t;
\&    unlink $t;
\&    ok !\-f $t;
\&
\&    if (0)
\&
\&     {makePathRemote($e);                                                         # Make a path on the remote system  # XXXXXXX
\&
\&     }
.Ve
.PP
\fIoverWriteFile($file, \f(CI$string\fI)\fR
.IX Subsection "overWriteFile($file, $string)"
.PP
Write to a \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>. Return the name of the \f(CW$file\fR on success else confess to any failures. If the file already exists it will be overwritten.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File to write to or B<undef> for a temporary file
\&  2  $string    Unicode string to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $f = writeFile(undef,  "aaa");
\&    is_deeply [readFile $f], ["aaa"];
\&
\&    appendFile($f, "bbb");
\&    is_deeply [readFile $f], ["aaabbb"];
\&
\&    my $F = writeTempFile(qw(aaa bbb));
\&    is_deeply [readFile $F], ["aaa
\&", "bbb
\&"];
\&
\&    eval {writeFile($f,  q(ccc))};
\&    ok $@ =~ m(File already exists:)i;
\&
\&
\&    overWriteFile($F,    q(ccc));  # XXXXXXX
\&
\&    ok   readFile($F) eq q(ccc);
\&
\&    unlink $f, $F;
.Ve
.PP
\&\fBowf\fR is a synonym for overWriteFile.
.PP
\fIwriteFile($file, \f(CI$string\fI)\fR
.IX Subsection "writeFile($file, $string)"
.PP
Write to a new \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>. Return the name of the \f(CW$file\fR written to on success else confess if the file already exists or any other error occurs.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      New file to write to or B<undef> for a temporary file
\&  2  $string    String to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeFile(undef,  "aaa");  # XXXXXXX
\&
\&    is_deeply [readFile $f], ["aaa"];
\&
\&    appendFile($f, "bbb");
\&    is_deeply [readFile $f], ["aaabbb"];
\&
\&    my $F = writeTempFile(qw(aaa bbb));
\&    is_deeply [readFile $F], ["aaa
\&", "bbb
\&"];
\&
\&
\&    eval {writeFile($f,  q(ccc))};  # XXXXXXX
\&
\&    ok $@ =~ m(File already exists:)i;
\&
\&    overWriteFile($F,    q(ccc));
\&    ok   readFile($F) eq q(ccc);
\&
\&    unlink $f, $F;
.Ve
.PP
\fIwriteTempFile(@strings)\fR
.IX Subsection "writeTempFile(@strings)"
.PP
Write an array of strings as lines to a temporary file and return the file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @strings   Array of lines
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $f = writeFile(undef,  "aaa");
\&    is_deeply [readFile $f], ["aaa"];
\&
\&    appendFile($f, "bbb");
\&    is_deeply [readFile $f], ["aaabbb"];
\&
\&
\&    my $F = writeTempFile(qw(aaa bbb));  # XXXXXXX
\&
\&    is_deeply [readFile $F], ["aaa
\&", "bbb
\&"];
\&
\&    eval {writeFile($f,  q(ccc))};
\&    ok $@ =~ m(File already exists:)i;
\&
\&    overWriteFile($F,    q(ccc));
\&    ok   readFile($F) eq q(ccc);
\&
\&    unlink $f, $F;
.Ve
.PP
\fIwriteFileToRemote($file, \f(CI$string\fI, \f(CI$ip\fI)\fR
.IX Subsection "writeFileToRemote($file, $string, $ip)"
.PP
Write to a new \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8> then copy the \f(CW$file\fR to the remote server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. Return the name of the \f(CW$file\fR on success else confess if the file already exists or any other error occurs.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $file      New file to write to or B<undef> for a temporary file
\&  2  $string    String to write
\&  3  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeFileToRemote(undef, q(aaaa));  # XXXXXXX
\&
\&    unlink $f;
\&    ok readFileFromRemote($f) eq q(aaaa);
\&    unlink $f;
.Ve
.PP
\fIoverWriteBinaryFile($file, \f(CI$string\fI)\fR
.IX Subsection "overWriteBinaryFile($file, $string)"
.PP
Write to \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, the binary content in \fB\f(CB$string\fB\fR. If the \f(CW$file\fR already exists it is overwritten. Return the name of the \f(CW$file\fR on success else confess.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File to write to or B<undef> for a temporary file
\&  2  $string    L<Unicode|https://en.wikipedia.org/wiki/Unicode> string to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&  if (1)
\&   {vec(my $a, 0, 8) = 254;
\&    vec(my $b, 0, 8) = 255;
\&    ok dump($a) eq dump("FE");
\&    ok dump($b) eq dump("FF");
\&    ok length($a) == 1;
\&    ok length($b) == 1;
\&
\&    my $s = $a.$a.$b.$b;
\&    ok length($s) == 4;
\&
\&    my $f = eval {writeFile(undef, $s)};
\&    ok fileSize($f) == 8;
\&
\&    eval {writeBinaryFile($f, $s)};
\&    ok $@ =~ m(Binary file already exists:)s;
\&
\&
\&    eval {overWriteBinaryFile($f, $s)};  # XXXXXXX
\&
\&    ok !$@;
\&    ok fileSize($f) == 4;
\&
\&    ok $s eq eval {readBinaryFile($f)};
\&
\&    copyBinaryFile($f, my $F = temporaryFile);
\&    ok $s eq readBinaryFile($F);
\&    unlink $f, $F;
\&   }
.Ve
.PP
\fIwriteBinaryFile($file, \f(CI$string\fI)\fR
.IX Subsection "writeBinaryFile($file, $string)"
.PP
Write to a new \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, the binary content in \fB\f(CB$string\fB\fR. Return the name of the \f(CW$file\fR on success else confess if the file already exists or any other error occurs.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      New file to write to or B<undef> for a temporary file
\&  2  $string    String to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeBinaryFile(undef, 0xff x 8);                                        # XXXXXXX
\&
\&
\&    my $s = readBinaryFile($f);
\&
\&    ok $s eq 0xff x 8;
\&
\&  if (1)
\&   {vec(my $a, 0, 8) = 254;
\&    vec(my $b, 0, 8) = 255;
\&    ok dump($a) eq dump("FE");
\&    ok dump($b) eq dump("FF");
\&    ok length($a) == 1;
\&    ok length($b) == 1;
\&
\&    my $s = $a.$a.$b.$b;
\&    ok length($s) == 4;
\&
\&    my $f = eval {writeFile(undef, $s)};
\&    ok fileSize($f) == 8;
\&
\&
\&    eval {writeBinaryFile($f, $s)};  # XXXXXXX
\&
\&    ok $@ =~ m(Binary file already exists:)s;
\&
\&    eval {overWriteBinaryFile($f, $s)};
\&    ok !$@;
\&    ok fileSize($f) == 4;
\&
\&    ok $s eq eval {readBinaryFile($f)};
\&
\&    copyBinaryFile($f, my $F = temporaryFile);
\&    ok $s eq readBinaryFile($F);
\&    unlink $f, $F;
\&   }
.Ve
.PP
\fIdumpFile($file, \f(CI$structure\fI)\fR
.IX Subsection "dumpFile($file, $structure)"
.PP
Dump to a \fB\f(CB$file\fB\fR the referenced data \fB\f(CB$structure\fB\fR.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $file       File to write to or B<undef> for a temporary file
\&  2  $structure  Address of data structure to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&
\&    my $f = dumpFile(undef, $d);  # XXXXXXX
\&
\&    is_deeply evalFile($f), $d;
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;
\&    unlink $f, $F;
\&
\&    my $j = dumpFileAsJson(undef, $d);
\&    is_deeply evalFileAsJson($j), $d;
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;
\&    unlink $j, $J;
.Ve
.PP
\fIdumpTempFile($structure)\fR
.IX Subsection "dumpTempFile($structure)"
.PP
Dump a data structure to a temporary file and return the name of the file created
.PP
.Vb 2
\&     Parameter   Description
\&  1  $structure  Data structure to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&    my $f = dumpFile(undef, $d);
\&    is_deeply evalFile($f), $d;
\&
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;  # XXXXXXX
\&
\&    unlink $f, $F;
\&
\&    my $j = dumpFileAsJson(undef, $d);
\&    is_deeply evalFileAsJson($j), $d;
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;
\&    unlink $j, $J;
.Ve
.PP
\fIdumpFileAsJson($file, \f(CI$structure\fI)\fR
.IX Subsection "dumpFileAsJson($file, $structure)"
.PP
Dump to a \fB\f(CB$file\fB\fR the referenced data \fB\f(CB$structure\fB\fR represented as Json <https://en.wikipedia.org/wiki/JSON> string.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $file       File to write to or B<undef> for a temporary file
\&  2  $structure  Address of data structure to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&    my $f = dumpFile(undef, $d);
\&    is_deeply evalFile($f), $d;
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;
\&    unlink $f, $F;
\&
\&
\&    my $j = dumpFileAsJson(undef, $d);  # XXXXXXX
\&
\&    is_deeply evalFileAsJson($j), $d;
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;
\&    unlink $j, $J;
.Ve
.PP
\fIdumpTempFileAsJson($structure)\fR
.IX Subsection "dumpTempFileAsJson($structure)"
.PP
Dump a data structure represented as Json <https://en.wikipedia.org/wiki/JSON> string to a temporary file and return the name of the file created.
.PP
.Vb 2
\&     Parameter   Description
\&  1  $structure  Data structure to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $d = [qw(aaa bbb ccc), [{aaa=>\*(AqAAA\*(Aq, bbb=>\*(AqBBB\*(Aq}]];
\&    my $f = dumpFile(undef, $d);
\&    is_deeply evalFile($f), $d;
\&    is_deeply evalFile(my $F = dumpTempFile($d)), $d;
\&    unlink $f, $F;
\&
\&    my $j = dumpFileAsJson(undef, $d);
\&    is_deeply evalFileAsJson($j), $d;
\&
\&    is_deeply evalFileAsJson(my $J = dumpTempFileAsJson($d)), $d;  # XXXXXXX
\&
\&    unlink $j, $J;
.Ve
.PP
\fIstoreFile($file, \f(CI$structure\fI)\fR
.IX Subsection "storeFile($file, $structure)"
.PP
Store into a \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, a data \fB\f(CB$structure\fB\fR via Storable <https://metacpan.org/pod/Storable>.  This is much faster than dumpFile but the stored results are not easily modified.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $file       File to write to or B<undef> for a temporary file
\&  2  $structure  Address of data structure to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = storeFile(undef, my $d = [qw(aaa bbb ccc)]);  # XXXXXXX
\&
\&    my $s = retrieveFile($f);
\&    is_deeply $s, $d;
\&    unlink $f;
.Ve
.PP
\fIwriteGZipFile($file, \f(CI$string\fI)\fR
.IX Subsection "writeGZipFile($file, $string)"
.PP
Write to a \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, through gzip <https://en.wikipedia.org/wiki/Gzip> a \fB\f(CB$string\fB\fR whose content is encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File to write to
\&  2  $string    String to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = \*(AqX\*(Aqx1e3;
\&
\&    my $file = writeGZipFile(q(zzz.zip), $s);  # XXXXXXX
\&
\&    ok \-e $file;
\&    my $S = readGZipFile($file);
\&    ok $s eq $S;
\&    ok length($s) == length($S);
\&    unlink $file;
.Ve
.PP
\fIdumpGZipFile($file, \f(CI$structure\fI)\fR
.IX Subsection "dumpGZipFile($file, $structure)"
.PP
Write to a \fB\f(CB$file\fB\fR a data \fB\f(CB$structure\fB\fR through gzip <https://en.wikipedia.org/wiki/Gzip>. This technique produces files that are a lot more compact files than those produced by Storable <https://metacpan.org/pod/Storable>, but the execution time is much longer. See also: evalGZipFile.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $file       File to write
\&  2  $structure  Reference to data
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = [1, 2, 3=>{a=>4, b=>5}];
\&
\&    my $file = dumpGZipFile(q(zzz.zip), $d);  # XXXXXXX
\&
\&    ok \-e $file;
\&    my $D = evalGZipFile($file);
\&    is_deeply $d, $D;
\&    unlink $file;
.Ve
.PP
\fIwriteFiles($hash, \f(CI$old\fI, \f(CI$new\fI)\fR
.IX Subsection "writeFiles($hash, $old, $new)"
.PP
Write the values of a \fB\f(CB$hash\fB\fR reference into files identified by the key of each value using overWriteFile optionally swapping the prefix of each file from \fB\f(CB$old\fB\fR to \fB\f(CB$new\fB\fR.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $hash      Hash of key value pairs representing files and data
\&  2  $old       Optional old prefix
\&  3  $new       New prefix
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&
\&    writeFiles($files);  # XXXXXXX
\&
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&
\&    writeFiles($files);  # XXXXXXX
\&
\&    ok !moveFileNoClobber  ($a1, $a2);
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fIreadFiles(@folders)\fR
.IX Subsection "readFiles(@folders)"
.PP
Read all the files in the specified list of folders into a hash.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @folders   Folders to read
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&
\&    my $ra = readFiles($a);  # XXXXXXX
\&
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&
\&    my $rb = readFiles($b);  # XXXXXXX
\&
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&    ok !moveFileNoClobber  ($a1, $a2);
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fIappendFile($file, \f(CI$string\fI)\fR
.IX Subsection "appendFile($file, $string)"
.PP
Append to \fB\f(CB$file\fB\fR a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded with utf8 <https://en.wikipedia.org/wiki/UTF-8>, creating the \f(CW$file\fR first if necessary. Return the name of the \f(CW$file\fR on success else confess. The \f(CW$file\fR being appended to is locked before the write with \*(L"flock\*(R" in perlfunc to allow  multiple processes to append linearly to the same file.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File to append to
\&  2  $string    String to append
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $f = writeFile(undef,  "aaa");
\&    is_deeply [readFile $f], ["aaa"];
\&
\&
\&    appendFile($f, "bbb");  # XXXXXXX
\&
\&    is_deeply [readFile $f], ["aaabbb"];
\&
\&    my $F = writeTempFile(qw(aaa bbb));
\&    is_deeply [readFile $F], ["aaa
\&", "bbb
\&"];
\&
\&    eval {writeFile($f,  q(ccc))};
\&    ok $@ =~ m(File already exists:)i;
\&
\&    overWriteFile($F,    q(ccc));
\&    ok   readFile($F) eq q(ccc);
\&
\&    unlink $f, $F;
.Ve
.PP
\fIcreateEmptyFile($file)\fR
.IX Subsection "createEmptyFile($file)"
.PP
Create an empty file unless the file already exists and return the name of the file else confess if the file cannot be created.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to create or B<undef> for a temporary file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $D = temporaryFolder;
\&    ok \-d $D;
\&    my $d = fpd($D, q(ddd));
\&    ok !\-d $d;
\&
\&    my @f = map {createEmptyFile(fpe($d, $_, qw(txt)))} qw(a b c);  # XXXXXXX
\&
\&    is_deeply [sort map {fne $_} findFiles($d, qr(txt\eZ))], [qw(a.txt b.txt c.txt)];
\&    is_deeply [findDirs($D)], [$D, $d];
\&    is_deeply [sort map {fne $_} searchDirectoryTreesForMatchingFiles($d)],
\&              ["a.txt", "b.txt", "c.txt"];
\&    is_deeply [sort map {fne $_} fileList("$d/*.txt")],
\&              ["a.txt", "b.txt", "c.txt"];
\&    ok \-e $_ for @f;
\&
\&    my @g = fileList(qq($D/*/*.txt));
\&    ok @g == 3;
\&
\&    clearFolder($D, 5);
\&    ok !\-e $_ for @f;
\&    ok !\-d $D;
.Ve
.PP
\fIsetPermissionsForFile($file, \f(CI$permissions\fI)\fR
.IX Subsection "setPermissionsForFile($file, $permissions)"
.PP
Apply chmod <https://linux.die.net/man/1/chmod> to a \fB\f(CB$file\fB\fR to set its \fB\f(CB$permissions\fB\fR.
.PP
.Vb 3
\&     Parameter     Description
\&  1  $file         File
\&  2  $permissions  Permissions settings per chmod
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $f = temporaryFile();
\&
\&    setPermissionsForFile($f, q(ugo=r));  # XXXXXXX
\&
\&    my $a = qx(ls \-la $f);
\&    ok $a =~ m(\-r\-\-r\-\-r\-\-)s;
\&
\&    setPermissionsForFile($f, q(u=rwx));  # XXXXXXX
\&
\&    my $b = qx(ls \-la $f);
\&    ok $b =~ m(\-rwxr\-\-r\-\-)s;
\&   }
.Ve
.PP
\fInumberOfLinesInFile($file)\fR
.IX Subsection "numberOfLinesInFile($file)"
.PP
Return the number of lines in a file.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $f = writeFile(undef, "a
\&b
\&");
\&
\&
\&    ok numberOfLinesInFile($f) == 2;                                                # XXXXXXX
.Ve
.PP
\fIoverWriteHtmlFile($file, \f(CI$data\fI)\fR
.IX Subsection "overWriteHtmlFile($file, $data)"
.PP
Write an \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML> file to /var/www/html and make it readable
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      Target file relative to /var/www/html
\&  2  $data      Data to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    overWriteHtmlFile   (q(index.html), q(<html><h1>Hello</h1></html>));  # XXXXXXX
\&
\&    overWritePerlCgiFile(q(gen.pl),     q(...));
.Ve
.PP
\fIoverWritePerlCgiFile($file, \f(CI$data\fI)\fR
.IX Subsection "overWritePerlCgiFile($file, $data)"
.PP
Write a Perl <http://www.perl.org/> file to /usr/lib/cgi\-bin and make it executable after checking it for syntax errors
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      Target file relative to /var/www/html
\&  2  $data      Data to write
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    overWriteHtmlFile   (q(index.html), q(<html><h1>Hello</h1></html>));
\&
\&    overWritePerlCgiFile(q(gen.pl),     q(...));  # XXXXXXX
.Ve
.SS "Copy"
.IX Subsection "Copy"
Copy files and folders. The \fB\eAcopy.*Md5Normalized.*\eZ\fR methods can be used to ensure that files have collision proof names that collapse duplicate content even when copied to another folder.
.PP
\fIcopyFile($source, \f(CI$target\fI)\fR
.IX Subsection "copyFile($source, $target)"
.PP
Copy the \fB\f(CB$source\fB\fR file encoded in utf8 to the specified \fB\f(CB$target\fB\fR file in and return \f(CW$target\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&
\&    copyFile($a1, $a2);  # XXXXXXX
\&
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&    ok !moveFileNoClobber  ($a1, $a2);
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fImoveFileNoClobber($source, \f(CI$target\fI)\fR
.IX Subsection "moveFileNoClobber($source, $target)"
.PP
Rename the \fB\f(CB$source\fB\fR file, which must exist, to the \fB\f(CB$target\fB\fR file but only if the \f(CW$target\fR file does not exist already.  Returns 1 if the \f(CW$source\fR file was successfully renamed to the \f(CW$target\fR file else 0.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&
\&    ok !moveFileNoClobber  ($a1, $a2);  # XXXXXXX
\&
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&
\&    ok  moveFileNoClobber  ($a2, $a1);  # XXXXXXX
\&
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fImoveFileWithClobber($source, \f(CI$target\fI)\fR
.IX Subsection "moveFileWithClobber($source, $target)"
.PP
Rename the \fB\f(CB$source\fB\fR file, which must exist, to the \fB\f(CB$target\fB\fR file but only if the \f(CW$target\fR file does not exist already.  Returns 1 if the \f(CW$source\fR file was successfully renamed to the \f(CW$target\fR file else 0.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&    ok !moveFileNoClobber  ($a1, $a2);
\&
\&    ok  moveFileWithClobber($a1, $a2);  # XXXXXXX
\&
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fIcopyFileToFolder($source, \f(CI$targetFolder\fI)\fR
.IX Subsection "copyFileToFolder($source, $targetFolder)"
.PP
Copy the file named in \fB\f(CB$source\fB\fR to the specified \fB\f(CB$targetFolder\fB/\fR or if \f(CW$targetFolder\fR/ is in fact a file into the folder containing this file and return the target file name. Confesses instead of copying if the target already exists.
.PP
.Vb 3
\&     Parameter      Description
\&  1  $source        Source file
\&  2  $targetFolder  Target folder
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $sd = temporaryFolder;
\&    my $td = temporaryFolder;
\&    my $sf = writeFile fpe($sd, qw(test data)), q(aaaa);
\&
\&    my $tf = copyFileToFolder($sf, $td);  # XXXXXXX
\&
\&    ok readFile($tf) eq q(aaaa);
\&    ok fp ($tf) eq $td;
\&    ok fne($tf) eq q(test.data);
.Ve
.PP
\fInameFromString($string, \f(CI%options\fI)\fR
.IX Subsection "nameFromString($string, %options)"
.PP
Create a readable name from an arbitrary string of text.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    String
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok q(help) eq nameFromString(q(!@#$%^help_\|_\|_<>?><?>));  # XXXXXXX
\&
\&
\&  ok q(bm_The_skyscraper_analogy) eq nameFromString(<<END);  # XXXXXXX
\&
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  </bookmap>
\&  END
\&
\&  ok q(bm_The_skyscraper_analogy_An_exciting_tale_of_two_skyscrapers_that_meet_in_downtown_Houston)
\&
\&     eq nameFromString(<<END);  # XXXXXXX
\&
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  An exciting tale of two skyscrapers that meet in downtown Houston
\&  <concept><html>
\&  </bookmap>
\&  END
\&
\&  ok q(bm_the_skyscraper_analogy) eq nameFromStringRestrictedToTitle(<<END);
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  An exciting tale of two skyscrapers that meet in downtown Houston
\&  <concept><html>
\&  </bookmap>
\&  END
.Ve
.PP
\fInameFromStringRestrictedToTitle($string, \f(CI%options\fI)\fR
.IX Subsection "nameFromStringRestrictedToTitle($string, %options)"
.PP
Create a readable name from a string of text that might contain a title tag \- fall back to nameFromString if that is not possible.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    String
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  ok q(help) eq nameFromString(q(!@#$%^help_\|_\|_<>?><?>));
\&  ok q(bm_The_skyscraper_analogy) eq nameFromString(<<END);
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  </bookmap>
\&  END
\&
\&  ok q(bm_The_skyscraper_analogy_An_exciting_tale_of_two_skyscrapers_that_meet_in_downtown_Houston)
\&     eq nameFromString(<<END);
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  An exciting tale of two skyscrapers that meet in downtown Houston
\&  <concept><html>
\&  </bookmap>
\&  END
\&
\&
\&  ok q(bm_the_skyscraper_analogy) eq nameFromStringRestrictedToTitle(<<END);  # XXXXXXX
\&
\&  <bookmap id="b1">
\&  <title>The skyscraper analogy</title>
\&  An exciting tale of two skyscrapers that meet in downtown Houston
\&  <concept><html>
\&  </bookmap>
\&  END
.Ve
.PP
\fIuniqueNameFromFile($source)\fR
.IX Subsection "uniqueNameFromFile($source)"
.PP
Create a unique name from a file name and the md5 sum of its content
.PP
.Vb 2
\&     Parameter  Description
\&  1  $source    Source file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = owf(q(test.txt), join "", 1..100);
\&
\&    ok uniqueNameFromFile($f) eq q(test_ef69caaaeea9c17120821a9eb6c7f1de.txt);  # XXXXXXX
\&
\&    unlink $f;
.Ve
.PP
\fInameFromFolder($file)\fR
.IX Subsection "nameFromFolder($file)"
.PP
Create a name from the last folder in the path of a file name.  Return undef if the file does not have a path.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok nameFromFolder(fpe(qw( a b c d e))) eq q(c);  # XXXXXXX
.Ve
.PP
\fIcopyFileMd5Normalized($source, \f(CI$Target\fI)\fR
.IX Subsection "copyFileMd5Normalized($source, $Target)"
.PP
Normalize the name of the specified \fB\f(CB$source\fB\fR file to the md5 sum of its content, retaining its current extension, while placing the original file name in a companion file if the companion file does not already exist.  If no \fB\f(CB$target\fB\fR folder is supplied the file is renamed to its normalized form in situ, otherwise it is copied to the target folder and renamed there. A companion file for the \fB\f(CB$source\fB\fR file is created by removing the extension of the normalized file and writing the original \fB\f(CB$source\fB\fR file name to it unless such a file already exists as we assume that it contains the 'original' original name of the \fB\f(CB$source\fB\fR file. If the \fB\f(CB$source\fB\fR file is copied to a new location then the companion file is copied as well to maintain the link back to the original name of the file.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $Target    Target folder or a file in the target folder
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&    my $A = copyFileMd5NormalizedCreate($a, $content, q(jpg), $a);
\&    ok readFile($A) eq $content;
\&
\&    ok $A eq copyFileMd5Normalized($A);  # XXXXXXX
\&
\&
\&
\&    my $B = copyFileMd5Normalized($A, $b);  # XXXXXXX
\&
\&    ok readFile($B) eq $content;
\&
\&    ok $B eq copyFileMd5Normalized($B);  # XXXXXXX
\&
\&
\&
\&    my $C = copyFileMd5Normalized($B, $c);  # XXXXXXX
\&
\&    ok readFile($C) eq $content;
\&
\&    ok $C eq copyFileMd5Normalized($C);  # XXXXXXX
\&
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readFile($_) eq $content for $A, $B, $C;
\&    ok copyFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($A);
\&    ok 4 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($B);
\&    ok 2 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($C);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    clearFolder($dir, 10);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
.Ve
.PP
\fIcopyFileMd5NormalizedName($content, \f(CI$extension\fI, \f(CI%options\fI)\fR
.IX Subsection "copyFileMd5NormalizedName($content, $extension, %options)"
.PP
Name a file using the \s-1GB\s0 Standard
.PP
.Vb 4
\&     Parameter   Description
\&  1  $content    Content
\&  2  $extension  Extension
\&  3  %options    Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok copyFileMd5NormalizedName(<<END, q(txt)) eq  # XXXXXXX
\&
\&  <p>Hello<b>World</b></p>
\&  END
\&  q(Hello_World_6ba23858c1b4811660896c324acac6fa.txt);
.Ve
.PP
\fIcopyFileMd5NormalizedCreate($Folder, \f(CI$content\fI, \f(CI$extension\fI, \f(CI$companionContent\fI, \f(CI%options\fI)\fR
.IX Subsection "copyFileMd5NormalizedCreate($Folder, $content, $extension, $companionContent, %options)"
.PP
Create a file in the specified \fB\f(CB$folder\fB\fR whose name is constructed from the md5 sum of the specified \fB\f(CB$content\fB\fR, whose content is \fB\f(CB$content\fB\fR, whose extension is \fB\f(CB$extension\fB\fR and which has a companion file with the same name minus the extension which contains the specified \fB\f(CB$companionContent\fB\fR.  Such a file can be copied multiple times by copyFileMd5Normalized regardless of the other files in the target folders.
.PP
.Vb 6
\&     Parameter          Description
\&  1  $Folder            Target folder or a file in that folder
\&  2  $content           Content of the file
\&  3  $extension         File extension
\&  4  $companionContent  Contents of the companion file
\&  5  %options           Options.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&
\&    my $A = copyFileMd5NormalizedCreate($a, $content, q(jpg), $a);  # XXXXXXX
\&
\&    ok readFile($A) eq $content;
\&    ok $A eq copyFileMd5Normalized($A);
\&
\&    my $B = copyFileMd5Normalized($A, $b);
\&    ok readFile($B) eq $content;
\&    ok $B eq copyFileMd5Normalized($B);
\&
\&    my $C = copyFileMd5Normalized($B, $c);
\&    ok readFile($C) eq $content;
\&    ok $C eq copyFileMd5Normalized($C);
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readFile($_) eq $content for $A, $B, $C;
\&    ok copyFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($A);
\&    ok 4 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($B);
\&    ok 2 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($C);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    clearFolder($dir, 10);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
.Ve
.PP
\fIcopyFileMd5NormalizedGetCompanionContent($source)\fR
.IX Subsection "copyFileMd5NormalizedGetCompanionContent($source)"
.PP
Return the content of the companion file to the specified \fB\f(CB$source\fB\fR file after it has been normalized via copyFileMd5Normalized or copyFileMd5NormalizedCreate or return \fBundef\fR if the corresponding companion file does not exist.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $source    Source file.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&    my $A = copyFileMd5NormalizedCreate($a, $content, q(jpg), $a);
\&    ok readFile($A) eq $content;
\&    ok $A eq copyFileMd5Normalized($A);
\&
\&    my $B = copyFileMd5Normalized($A, $b);
\&    ok readFile($B) eq $content;
\&    ok $B eq copyFileMd5Normalized($B);
\&
\&    my $C = copyFileMd5Normalized($B, $c);
\&    ok readFile($C) eq $content;
\&    ok $C eq copyFileMd5Normalized($C);
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readFile($_) eq $content for $A, $B, $C;
\&
\&    ok copyFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;  # XXXXXXX
\&
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($A);
\&    ok 4 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($B);
\&    ok 2 == searchDirectoryTreesForMatchingFiles($dir);
\&    copyFileMd5NormalizedDelete($C);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    clearFolder($dir, 10);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
.Ve
.PP
\fIcopyFileMd5NormalizedDelete($file)\fR
.IX Subsection "copyFileMd5NormalizedDelete($file)"
.PP
Delete a normalized and its companion file
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&    my $A = copyFileMd5NormalizedCreate($a, $content, q(jpg), $a);
\&    ok readFile($A) eq $content;
\&    ok $A eq copyFileMd5Normalized($A);
\&
\&    my $B = copyFileMd5Normalized($A, $b);
\&    ok readFile($B) eq $content;
\&    ok $B eq copyFileMd5Normalized($B);
\&
\&    my $C = copyFileMd5Normalized($B, $c);
\&    ok readFile($C) eq $content;
\&    ok $C eq copyFileMd5Normalized($C);
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readFile($_) eq $content for $A, $B, $C;
\&    ok copyFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    copyFileMd5NormalizedDelete($A);  # XXXXXXX
\&
\&    ok 4 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    copyFileMd5NormalizedDelete($B);  # XXXXXXX
\&
\&    ok 2 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    copyFileMd5NormalizedDelete($C);  # XXXXXXX
\&
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
\&
\&    clearFolder($dir, 10);
\&    ok 0 == searchDirectoryTreesForMatchingFiles($dir);
.Ve
.PP
\fIcopyBinaryFile($source, \f(CI$target\fI)\fR
.IX Subsection "copyBinaryFile($source, $target)"
.PP
Copy the binary file \fB\f(CB$source\fB\fR to a file named <%target> and return the target file name,
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&  if (1)
\&   {vec(my $a, 0, 8) = 254;
\&    vec(my $b, 0, 8) = 255;
\&    ok dump($a) eq dump("FE");
\&    ok dump($b) eq dump("FF");
\&    ok length($a) == 1;
\&    ok length($b) == 1;
\&
\&    my $s = $a.$a.$b.$b;
\&    ok length($s) == 4;
\&
\&    my $f = eval {writeFile(undef, $s)};
\&    ok fileSize($f) == 8;
\&
\&    eval {writeBinaryFile($f, $s)};
\&    ok $@ =~ m(Binary file already exists:)s;
\&
\&    eval {overWriteBinaryFile($f, $s)};
\&    ok !$@;
\&    ok fileSize($f) == 4;
\&
\&    ok $s eq eval {readBinaryFile($f)};
\&
\&
\&    copyBinaryFile($f, my $F = temporaryFile);  # XXXXXXX
\&
\&    ok $s eq readBinaryFile($F);
\&    unlink $f, $F;
\&   }
.Ve
.PP
\fIcopyBinaryFileMd5Normalized($source, \f(CI$Target\fI)\fR
.IX Subsection "copyBinaryFileMd5Normalized($source, $Target)"
.PP
Normalize the name of the specified \fB\f(CB$source\fB\fR file to the md5 sum of its content, retaining its current extension, while placing the original file name in a companion file if the companion file does not already exist.  If no \fB\f(CB$target\fB\fR folder is supplied the file is renamed to its normalized form in situ, otherwise it is copied to the target folder and renamed there. A companion file for the \fB\f(CB$source\fB\fR file is created by removing the extension of the normalized file and writing the original \fB\f(CB$source\fB\fR file name to it unless such a file already exists as we assume that it contains the 'original' original name of the \fB\f(CB$source\fB\fR file. If the \fB\f(CB$source\fB\fR file is copied to a new location then the companion file is copied as well to maintain the link back to the original name of the file.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $Target    Target folder or a file in the target folder
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&    my $A = copyBinaryFileMd5NormalizedCreate($a, $content, q(jpg), $a);
\&    ok readBinaryFile($A) eq $content;
\&
\&    ok $A eq copyBinaryFileMd5Normalized($A);  # XXXXXXX
\&
\&
\&
\&    my $B = copyBinaryFileMd5Normalized($A, $b);  # XXXXXXX
\&
\&    ok readBinaryFile($B) eq $content;
\&
\&    ok $B eq copyBinaryFileMd5Normalized($B);  # XXXXXXX
\&
\&
\&
\&    my $C = copyBinaryFileMd5Normalized($B, $c);  # XXXXXXX
\&
\&    ok readBinaryFile($C) eq $content;
\&
\&    ok $C eq copyBinaryFileMd5Normalized($C);  # XXXXXXX
\&
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readBinaryFile($_) eq $content for $A, $B, $C;
\&    ok copyBinaryFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    clearFolder($dir, 10);
.Ve
.PP
\fIcopyBinaryFileMd5NormalizedCreate($Folder, \f(CI$content\fI, \f(CI$extension\fI, \f(CI$companionContent\fI)\fR
.IX Subsection "copyBinaryFileMd5NormalizedCreate($Folder, $content, $extension, $companionContent)"
.PP
Create a file in the specified \fB\f(CB$folder\fB\fR whose name is constructed from the md5 sum of the specified \fB\f(CB$content\fB\fR, whose content is \fB\f(CB$content\fB\fR, whose extension is \fB\f(CB$extension\fB\fR and which has a companion file with the same name minus the extension  which contains the specified \fB\f(CB$companionContent\fB\fR.  Such a file can be copied multiple times by copyBinaryFileMd5Normalized regardless of the other files in the target folders while retaining the original name information.
.PP
.Vb 5
\&     Parameter          Description
\&  1  $Folder            Target folder or a file in that folder
\&  2  $content           Content of the file
\&  3  $extension         File extension
\&  4  $companionContent  Optional content of the companion file.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&
\&    my $A = copyBinaryFileMd5NormalizedCreate($a, $content, q(jpg), $a);  # XXXXXXX
\&
\&    ok readBinaryFile($A) eq $content;
\&    ok $A eq copyBinaryFileMd5Normalized($A);
\&
\&    my $B = copyBinaryFileMd5Normalized($A, $b);
\&    ok readBinaryFile($B) eq $content;
\&    ok $B eq copyBinaryFileMd5Normalized($B);
\&
\&    my $C = copyBinaryFileMd5Normalized($B, $c);
\&    ok readBinaryFile($C) eq $content;
\&    ok $C eq copyBinaryFileMd5Normalized($C);
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readBinaryFile($_) eq $content for $A, $B, $C;
\&    ok copyBinaryFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    clearFolder($dir, 10);
.Ve
.PP
\fIcopyBinaryFileMd5NormalizedGetCompanionContent($source)\fR
.IX Subsection "copyBinaryFileMd5NormalizedGetCompanionContent($source)"
.PP
Return the original name of the specified \fB\f(CB$source\fB\fR file after it has been normalized via copyBinaryFileMd5Normalized or copyBinaryFileMd5NormalizedCreate or return \fBundef\fR if the corresponding companion file does not exist.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $source    Source file.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $dir = temporaryFolder;
\&    my $a = fpe($dir, qw(a a jpg));
\&    my $b = fpe($dir, qw(b a jpg));
\&    my $c = fpe($dir, qw(c a jpg));
\&
\&    my $content = join \*(Aq\*(Aq, 1..1e3;
\&
\&    my $A = copyBinaryFileMd5NormalizedCreate($a, $content, q(jpg), $a);
\&    ok readBinaryFile($A) eq $content;
\&    ok $A eq copyBinaryFileMd5Normalized($A);
\&
\&    my $B = copyBinaryFileMd5Normalized($A, $b);
\&    ok readBinaryFile($B) eq $content;
\&    ok $B eq copyBinaryFileMd5Normalized($B);
\&
\&    my $C = copyBinaryFileMd5Normalized($B, $c);
\&    ok readBinaryFile($C) eq $content;
\&    ok $C eq copyBinaryFileMd5Normalized($C);
\&
\&    ok fne($A) eq fne($_) for $B, $C;
\&    ok readBinaryFile($_) eq $content for $A, $B, $C;
\&
\&    ok copyBinaryFileMd5NormalizedGetCompanionContent($_) eq $a for $A, $B, $C;  # XXXXXXX
\&
\&
\&    ok 6 == searchDirectoryTreesForMatchingFiles($dir);
\&    clearFolder($dir, 10);
.Ve
.PP
\fIcopyFileToRemote($file, \f(CI$ip\fI)\fR
.IX Subsection "copyFileToRemote($file, $ip)"
.PP
Copy the specified local \fB\f(CB$file\fB\fR to the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      Source file
\&  2  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (0)
\&
\&   {copyFileToRemote     (q(/home/phil/perl/cpan/aaa.txt));  # XXXXXXX
\&
\&    copyFileFromRemote   (q(/home/phil/perl/cpan/aaa.txt));
\&    copyFolderToRemote   (q(/home/phil/perl/cpan/));
\&    mergeFolderFromRemote(q(/home/phil/perl/cpan/));
\&   }
.Ve
.PP
\fIcopyFileFromRemote($file, \f(CI$ip\fI)\fR
.IX Subsection "copyFileFromRemote($file, $ip)"
.PP
Copy the specified \fB\f(CB$file\fB\fR from the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      Source file
\&  2  $ip        Optional ip address
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (0)
\&   {copyFileToRemote     (q(/home/phil/perl/cpan/aaa.txt));
\&
\&    copyFileFromRemote   (q(/home/phil/perl/cpan/aaa.txt));  # XXXXXXX
\&
\&    copyFolderToRemote   (q(/home/phil/perl/cpan/));
\&    mergeFolderFromRemote(q(/home/phil/perl/cpan/));
\&   }
.Ve
.PP
\fIcopyFolder($source, \f(CI$target\fI)\fR
.IX Subsection "copyFolder($source, $target)"
.PP
Copy the \fB\f(CB$source\fB\fR folder to the \fB\f(CB$target\fB\fR folder after clearing the \f(CW$target\fR folder.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&
\&    copyFolder($a, $b);  # XXXXXXX
\&
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&    mergeFolder($a, $b);
\&    ok \-e $b1; ok  \-e $b2;
\&
\&
\&    copyFolder($a, $b);  # XXXXXXX
\&
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&    ok !moveFileNoClobber  ($a1, $a2);
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fImergeFolder($source, \f(CI$target\fI)\fR
.IX Subsection "mergeFolder($source, $target)"
.PP
Copy the \fB\f(CB$source\fB\fR folder into the \fB\f(CB$target\fB\fR folder retaining any existing files not replaced by copied files.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $source    Source file
\&  2  $target    Target file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $d = temporaryFolder;
\&    my $a = fpd($d, q(aaa));
\&    my $b = fpd($d, q(bbb));
\&    my $c = fpd($d, q(ccc));
\&    my ($a1, $a2) = map {fpe($a, $_, q(txt))} 1..2;
\&    my ($b1, $b2) = map {fpe($b, $_, q(txt))} 1..2;
\&    my $files = {$a1 => "1111", $a2 => "2222"};
\&
\&    writeFiles($files);
\&    my $ra = readFiles($a);
\&    is_deeply $files, $ra;
\&    copyFolder($a, $b);
\&    my $rb = readFiles($b);
\&    is_deeply [sort values %$ra], [sort values %$rb];
\&
\&    unlink $a2;
\&
\&    mergeFolder($a, $b);  # XXXXXXX
\&
\&    ok \-e $b1; ok  \-e $b2;
\&
\&    copyFolder($a, $b);
\&    ok \-e $b1; ok !\-e $b2;
\&
\&    copyFile($a1, $a2);
\&    ok readFile($a1) eq readFile($a2);
\&
\&    writeFiles($files);
\&    ok !moveFileNoClobber  ($a1, $a2);
\&    ok  moveFileWithClobber($a1, $a2);
\&    ok !\-e $a1;
\&    ok readFile($a2) eq q(1111);
\&    ok  moveFileNoClobber  ($a2, $a1);
\&    ok !\-e $a2;
\&    ok readFile($a1) eq q(1111);
\&
\&    clearFolder(q(aaa), 11);
\&    clearFolder(q(bbb), 11);
.Ve
.PP
\fIcopyFolderToRemote($Source, \f(CI$ip\fI)\fR
.IX Subsection "copyFolderToRemote($Source, $ip)"
.PP
Copy the specified local \fB\f(CB$Source\fB\fR folder to the corresponding remote folder on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. The default userid supplied by \fI.ssh/config\fR will be used on the remote server.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $Source    Source file
\&  2  $ip        Optional ip address of server
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&  if (0)
\&   {copyFileToRemote     (q(/home/phil/perl/cpan/aaa.txt));
\&    copyFileFromRemote   (q(/home/phil/perl/cpan/aaa.txt));
\&
\&    copyFolderToRemote   (q(/home/phil/perl/cpan/));  # XXXXXXX
\&
\&    mergeFolderFromRemote(q(/home/phil/perl/cpan/));
\&   }
.Ve
.PP
\fImergeFolderFromRemote($Source, \f(CI$ip\fI)\fR
.IX Subsection "mergeFolderFromRemote($Source, $ip)"
.PP
Merge the specified \fB\f(CB$Source\fB\fR folder from the corresponding remote folder on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp. The default userid supplied by \fI.ssh/config\fR will be used on the remote server.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $Source    Source file
\&  2  $ip        Optional ip address of server
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (0)
\&   {copyFileToRemote     (q(/home/phil/perl/cpan/aaa.txt));
\&    copyFileFromRemote   (q(/home/phil/perl/cpan/aaa.txt));
\&    copyFolderToRemote   (q(/home/phil/perl/cpan/));
\&
\&    mergeFolderFromRemote(q(/home/phil/perl/cpan/));  # XXXXXXX
\&
\&   }
.Ve
.SH "Testing"
.IX Header "Testing"
Methods to assist with testing
.SS "removeFilePathsFromStructure($structure)"
.IX Subsection "removeFilePathsFromStructure($structure)"
Remove all file paths from a specified \fB\f(CB$structure\fB\fR to make said \f(CW$structure\fR testable with \*(L"is_deeply\*(R" in Test::More.
.PP
.Vb 2
\&     Parameter   Description
\&  1  $structure  Data structure reference
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $d = {"/home/aaa/bbb.txt"=>1, "ccc/ddd.txt"=>2, "eee.txt"=>3};
\&
\&    my $D = removeFilePathsFromStructure($d);  # XXXXXXX
\&
\&
\&
\&    is_deeply removeFilePathsFromStructure($d),  # XXXXXXX
\&
\&     {"bbb.txt"=>1, "ddd.txt"=>2, "eee.txt"=>3};
\&
\&    ok writeStructureTest($d, q($d)) eq <<\*(AqEND\*(Aq;
\&
\&    is_deeply removeFilePathsFromStructure($d),  # XXXXXXX
\&
\&     { "bbb.txt" => 1, "ddd.txt" => 2, "eee.txt" => 3 };
\&  END
\&   }
.Ve
.ie n .SS "writeStructureTest($structure, $expr)"
.el .SS "writeStructureTest($structure, \f(CW$expr\fP)"
.IX Subsection "writeStructureTest($structure, $expr)"
Write a test for a data \fB\f(CB$structure\fB\fR with file names in it.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $structure  Data structure reference
\&  2  $expr       Expression
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&  if (1)
\&   {my $d = {"/home/aaa/bbb.txt"=>1, "ccc/ddd.txt"=>2, "eee.txt"=>3};
\&    my $D = removeFilePathsFromStructure($d);
\&
\&    is_deeply removeFilePathsFromStructure($d),
\&     {"bbb.txt"=>1, "ddd.txt"=>2, "eee.txt"=>3};
\&
\&
\&    ok writeStructureTest($d, q($d)) eq <<\*(AqEND\*(Aq;  # XXXXXXX
\&
\&    is_deeply removeFilePathsFromStructure($d),
\&     { "bbb.txt" => 1, "ddd.txt" => 2, "eee.txt" => 3 };
\&  END
\&   }
.Ve
.SH "Images"
.IX Header "Images"
Image operations.
.SS "imageSize($image)"
.IX Subsection "imageSize($image)"
Return (width, height) of an \fB\f(CB$image\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $image     File containing image
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($width, $height) = imageSize(fpe(qw(a image jpg)));                         # XXXXXXX
.Ve
.ie n .SS "convertDocxToFodt($inputFile, $outputFile)"
.el .SS "convertDocxToFodt($inputFile, \f(CW$outputFile\fP)"
.IX Subsection "convertDocxToFodt($inputFile, $outputFile)"
Convert a \fIdocx\fR \fB\f(CB$inputFile\fB\fR file to a \fIfodt\fR \fB\f(CB$outputFile\fB\fR using \fBunoconv\fR which must not be running elsewhere at the time.  Unoconv can be installed via:
.PP
.Vb 1
\&  sudo apt install sharutils unoconv
.Ve
.PP
Parameters:
.PP
.Vb 3
\&     Parameter    Description
\&  1  $inputFile   Input file
\&  2  $outputFile  Output file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    convertDocxToFodt(fpe(qw(a docx)), fpe(qw(a fodt)));                            # XXXXXXX
.Ve
.ie n .SS "cutOutImagesInFodtFile($inputFile, $outputFolder, $imagePrefix)"
.el .SS "cutOutImagesInFodtFile($inputFile, \f(CW$outputFolder\fP, \f(CW$imagePrefix\fP)"
.IX Subsection "cutOutImagesInFodtFile($inputFile, $outputFolder, $imagePrefix)"
Cut out the images embedded in a \fBfodt\fR file, perhaps produced via convertDocxToFodt, placing them in the specified folder and replacing them in the source file with:
.PP
.Vb 1
\&  <image href="$imageFile" outputclass="imageType">.
.Ve
.PP
This conversion requires that you have both Imagemagick <https://www.imagemagick.org/script/index.php> and unoconv installed on your system:
.PP
.Vb 1
\&    sudo apt install sharutils  imagemagick unoconv
.Ve
.PP
Parameters:
.PP
.Vb 4
\&     Parameter      Description
\&  1  $inputFile     Input file
\&  2  $outputFolder  Output folder for images
\&  3  $imagePrefix   A prefix to be added to image file names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    cutOutImagesInFodtFile(fpe(qw(source fodt)), fpd(qw(images)), q(image));        # XXXXXXX
.Ve
.SH "Encoding and Decoding"
.IX Header "Encoding and Decoding"
Encode and decode using Json <https://en.wikipedia.org/wiki/JSON> and Mime.
.SS "unbless($d)"
.IX Subsection "unbless($d)"
Remove the effects of bless from a Perl <http://www.perl.org/> data \fB\f(CB$structure\fB\fR enabling it to be converted to Json <https://en.wikipedia.org/wiki/JSON> or compared with Test::More::is_deeply.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $d         Unbless a L<Perl|http://www.perl.org/> data structure.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&  if (1)
\&   {my $a = {};
\&    ok ref($a)      eq  q(HASH);
\&    my $b =   bless $a, q(aaaa);
\&    ok ref($a)      eq  q(aaaa);
\&
\&    my $c = unbless $b;  # XXXXXXX
\&
\&    ok ref($c)      eq  q(HASH);
\&   }
.Ve
.SS "encodeJson($structure)"
.IX Subsection "encodeJson($structure)"
Convert a Perl <http://www.perl.org/> data \fB\f(CB$structure\fB\fR to a Json <https://en.wikipedia.org/wiki/JSON> string.
.PP
.Vb 2
\&     Parameter   Description
\&  1  $structure  Data to encode
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $A = encodeJson(my $a = {a=>1,b=>2, c=>[1..2]});  # XXXXXXX
\&
\&    my $b = decodeJson($A);
\&    is_deeply $a, $b;
.Ve
.SS "decodeJson($string)"
.IX Subsection "decodeJson($string)"
Convert a Json <https://en.wikipedia.org/wiki/JSON> \fB\f(CB$string\fB\fR to a Perl <http://www.perl.org/> data structure.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    Data to decode
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $A = encodeJson(my $a = {a=>1,b=>2, c=>[1..2]});
\&
\&    my $b = decodeJson($A);  # XXXXXXX
\&
\&    is_deeply $a, $b;
.Ve
.SS "encodeBase64($string)"
.IX Subsection "encodeBase64($string)"
Encode an Ascii <https://en.wikipedia.org/wiki/ASCII> \fB\f(CB$string\fB\fR in base 64.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to encode
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $A = encodeBase64(my $a = "Hello World" x 10);  # XXXXXXX
\&
\&    my $b = decodeBase64($A);
\&    ok $a eq $b;
.Ve
.SS "decodeBase64($string)"
.IX Subsection "decodeBase64($string)"
Decode an Ascii <https://en.wikipedia.org/wiki/ASCII> \fB\f(CB$string\fB\fR in base 64.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to decode
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $A = encodeBase64(my $a = "Hello World" x 10);
\&
\&    my $b = decodeBase64($A);  # XXXXXXX
\&
\&    ok $a eq $b;
.Ve
.SS "convertUnicodeToXml($string)"
.IX Subsection "convertUnicodeToXml($string)"
Convert a \fB\f(CB$string\fB\fR with Unicode <https://en.wikipedia.org/wiki/Unicode> codepoints that are not directly representable in Ascii <https://en.wikipedia.org/wiki/ASCII> into string that replaces these code points with their representation in Xml <https://en.wikipedia.org/wiki/XML> making the string usable in Xml <https://en.wikipedia.org/wiki/XML> documents.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok convertUnicodeToXml(\*(Aqsetenta e tre\*^s\*(Aq) eq q(setenta e tr&#234;s);               # XXXXXXX
.Ve
.SS "asciiToHexString($ascii)"
.IX Subsection "asciiToHexString($ascii)"
Encode an Ascii <https://en.wikipedia.org/wiki/ASCII> string as a string of hexadecimal <https://en.wikipedia.org/wiki/Hexadecimal> digits.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $ascii     Ascii string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok asciiToHexString("Hello World!") eq                  "48656c6c6f20576f726c6421";  # XXXXXXX
\&
\&    ok                  "Hello World!"  eq hexToAsciiString("48656c6c6f20576f726c6421");
.Ve
.SS "hexToAsciiString($hex)"
.IX Subsection "hexToAsciiString($hex)"
Decode a string of hexadecimal <https://en.wikipedia.org/wiki/Hexadecimal> digits as an Ascii <https://en.wikipedia.org/wiki/ASCII> string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $hex       Hexadecimal string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok asciiToHexString("Hello World!") eq                  "48656c6c6f20576f726c6421";
\&
\&    ok                  "Hello World!"  eq hexToAsciiString("48656c6c6f20576f726c6421");  # XXXXXXX
.Ve
.SS "wwwEncode($string)"
.IX Subsection "wwwEncode($string)"
Percent encode a url <https://en.wikipedia.org/wiki/URL> per: https://en.wikipedia.org/wiki/Percent\-encoding#Percent\-encoding_reserved_characters
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok wwwEncode(q(a  {b} <c>)) eq q(a%20%20%7bb%7d%20%3cc%3e);  # XXXXXXX
\&
\&
\&    ok wwwEncode(q(../))        eq q(%2e%2e/);  # XXXXXXX
\&
\&
\&    ok wwwDecode(wwwEncode $_) eq $_ for q(a  {b} <c>), q(a  b|c),  # XXXXXXX
\&
\&      q(%), q(%%), q(%%.%%);
\&
\&
\&  sub wwwEncode($)                                                                 # XXXXXXX
\&
\&   {my ($string) = @_;                                                            # String
\&    join \*(Aq\*(Aq, map {$translatePercentEncoding{$_}//$_} split //, $string
\&   }
.Ve
.SS "wwwDecode($string)"
.IX Subsection "wwwDecode($string)"
Percent decode a url <https://en.wikipedia.org/wiki/URL> \fB\f(CB$string\fB\fR per: https://en.wikipedia.org/wiki/Percent\-encoding#Percent\-encoding_reserved_characters
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok wwwEncode(q(a  {b} <c>)) eq q(a%20%20%7bb%7d%20%3cc%3e);
\&    ok wwwEncode(q(../))        eq q(%2e%2e/);
\&
\&    ok wwwDecode(wwwEncode $_) eq $_ for q(a  {b} <c>), q(a  b|c),  # XXXXXXX
\&
\&      q(%), q(%%), q(%%.%%);
\&
\&
\&  sub wwwDecode($)                                                                 # XXXXXXX
\&
\&   {my ($string) = @_;                                                            # String
\&    my $r = \*(Aq\*(Aq;
\&    my @s = split //, $string;
\&    while(@s)
\&     {my $c = shift @s;
\&      if ($c eq q(%) and @s >= 2)
\&       {$c .= shift(@s).shift(@s);
\&        $r .= $TranslatePercentEncoding{$c}//$c;
\&       }
\&      else
\&       {$r .= $c;
\&       }
\&     }
\&    $r =~ s(%0d0a) (
\&)gs;                                                        # Awkward characters that appear in urls
\&    $r =~ s(\e+)     ( )gs;
\&    $r
\&   }
.Ve
.ie n .SS "printPerlDataAsXml($data, $width)"
.el .SS "printPerlDataAsXml($data, \f(CW$width\fP)"
.IX Subsection "printPerlDataAsXml($data, $width)"
Print a Perl data structure as xml
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Perl data structure
\&  2  $width     Ideal width for Xml \- default is 80
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  my $perlData = {a=>1, b=>[{c=>[3,4]}, {d=>[5,6]}, {e=>7}], f=>8};
\&
\&  my $xml = printPerlDataAsXml($perlData);  # XXXXXXX
\&
\&
\&  is_deeply $xml, trim(<<END);
\&  <hash>
\&      <a>1</a>
\&      <b>
\&      <array>
\&                  <e><hash><c><array><e>3</e><e>4</e></array></c></hash></e>
\&                  <e><hash><d><array><e>5</e><e>6</e></array></d></hash></e>
\&                  <e><hash><e>7</e></hash></e>
\&                  </array>
\&      </b>
\&      <f>8</f>
\&      </hash>
\&  END
.Ve
.SH "Numbers"
.IX Header "Numbers"
Numeric operations,
.SS "powerOfTwo($n)"
.IX Subsection "powerOfTwo($n)"
Test whether a number \fB\f(CB$n\fB\fR is a power of two, return the power if it is else \fBundef\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $n         Number to check
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok  powerOfTwo(1) == 0;                                                           # XXXXXXX
\&
\&
\&
\&  ok  powerOfTwo(2) == 1;                                                           # XXXXXXX
\&
\&
\&
\&  ok !powerOfTwo(3);                                                                # XXXXXXX
\&
\&
\&
\&  ok  powerOfTwo(4) == 2;                                                           # XXXXXXX
.Ve
.SS "containingPowerOfTwo($n)"
.IX Subsection "containingPowerOfTwo($n)"
Find log two of the lowest power of two greater than or equal to a number \fB\f(CB$n\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $n         Number to check
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok  containingPowerOfTwo(1) == 0;                                                 # XXXXXXX
\&
\&
\&
\&  ok  containingPowerOfTwo(2) == 1;                                                 # XXXXXXX
\&
\&
\&
\&  ok  containingPowerOfTwo(3) == 2;                                                 # XXXXXXX
\&
\&
\&
\&  ok  containingPowerOfTwo(4) == 2;                                                 # XXXXXXX
.Ve
.SS "Minima and Maxima"
.IX Subsection "Minima and Maxima"
Find the smallest and largest elements of arrays.
.PP
\fImin(@m)\fR
.IX Subsection "min(@m)"
.PP
Find the minimum number in a list of numbers confessing to any ill defined values.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @m         Numbers
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    ok !max;
\&    ok max(1) == 1;
\&    ok max(1,4,2,3) == 4;
\&
\&
\&    ok min(1) == 1;  # XXXXXXX
\&
\&
\&    ok min(5,4,2,3) == 2;  # XXXXXXX
.Ve
.PP
\fIindexOfMin(@m)\fR
.IX Subsection "indexOfMin(@m)"
.PP
Find the index of the minimum number in a list of numbers confessing to any ill defined values.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @m         Numbers
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok indexOfMin(qw(2 3 1 2)) == 2;                                                # XXXXXXX
.Ve
.PP
\fImax(@m)\fR
.IX Subsection "max(@m)"
.PP
Find the maximum number in a list of numbers confessing to any ill defined values.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @m         Numbers
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok !max;  # XXXXXXX
\&
\&
\&    ok max(1) == 1;  # XXXXXXX
\&
\&
\&    ok max(1,4,2,3) == 4;  # XXXXXXX
\&
\&
\&    ok min(1) == 1;
\&    ok min(5,4,2,3) == 2;
.Ve
.PP
\fIindexOfMax(@m)\fR
.IX Subsection "indexOfMax(@m)"
.PP
Find the index of the maximum number in a list of numbers confessing to any ill defined values.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @m         Numbers
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&   {ok indexOfMax(qw(2 3 1 2)) == 1;                                                # XXXXXXX
.Ve
.PP
\fIarraySum(@a)\fR
.IX Subsection "arraySum(@a)"
.PP
Find the sum of any strings that look like numbers in an array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @a         Array to sum
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&   {ok arraySum   (1..10) ==  55;                                                   # XXXXXXX
.Ve
.PP
\fIarrayProduct(@a)\fR
.IX Subsection "arrayProduct(@a)"
.PP
Find the product of any strings that look like numbers in an array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @a         Array to multiply
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok arrayProduct(1..5) == 120;                                                   # XXXXXXX
.Ve
.PP
\fIarrayTimes($multiplier, \f(CI@a\fI)\fR
.IX Subsection "arrayTimes($multiplier, @a)"
.PP
Multiply by \fB\f(CB$multiplier\fB\fR each element of the array \fB\f(CB@a\fB\fR and return as the result.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $multiplier  Multiplier
\&  2  @a           Array to multiply and return
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];                               # XXXXXXX
.Ve
.SH "Sets"
.IX Header "Sets"
Set operations.
.SS "mergeHashesBySummingValues(@h)"
.IX Subsection "mergeHashesBySummingValues(@h)"
Merge a list of hashes \fB\f(CB@h\fB\fR by summing their values
.PP
.Vb 2
\&     Parameter  Description
\&  1  @h         List of hashes to be summed
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply +{a=>1, b=>2, c=>3},
\&
\&      mergeHashesBySummingValues  # XXXXXXX
\&
\&        +{a=>1,b=>1, c=>1}, +{b=>1,c=>1}, +{c=>1};
.Ve
.SS "invertHashOfHashes($h)"
.IX Subsection "invertHashOfHashes($h)"
Invert a hash of hashes: given {a}{b} = c return {b}{c} = c
.PP
.Vb 2
\&     Parameter  Description
\&  1  $h         Hash of hashes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $h =  {a=>{A=>q(aA), B=>q(aB)}, b=>{A=>q(bA), B=>q(bB)}};
\&    my $g =  {A=>{a=>q(aA), b=>q(bA)}, B=>{a=>q(aB), b=>q(bB)}};
\&
\&
\&    is_deeply invertHashOfHashes($h), $g;  # XXXXXXX
\&
\&
\&    is_deeply invertHashOfHashes($g), $h;  # XXXXXXX
.Ve
.SS "unionOfHashKeys(@h)"
.IX Subsection "unionOfHashKeys(@h)"
Form the union of the keys of the specified hashes \fB\f(CB@h\fB\fR as one hash whose keys represent the union.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @h         List of hashes to be united
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply  unionOfHashKeys  # XXXXXXX
\&
\&     ({a=>1,b=>2}, {b=>1,c=>1}, {c=>2}),
\&      {a=>1, b=>2, c=>2};
\&
\&    is_deeply  intersectionOfHashKeys
\&     ({a=>1,b=>2},{b=>1,c=>1},{b=>3,c=>2}),
\&      {b=>1};
\&   }
.Ve
.SS "intersectionOfHashKeys(@h)"
.IX Subsection "intersectionOfHashKeys(@h)"
Form the intersection of the keys of the specified hashes \fB\f(CB@h\fB\fR as one hash whose keys represent the intersection.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @h         List of hashes to be intersected
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (1)
\&   {is_deeply  unionOfHashKeys
\&     ({a=>1,b=>2}, {b=>1,c=>1}, {c=>2}),
\&      {a=>1, b=>2, c=>2};
\&
\&
\&    is_deeply  intersectionOfHashKeys  # XXXXXXX
\&
\&     ({a=>1,b=>2},{b=>1,c=>1},{b=>3,c=>2}),
\&      {b=>1};
\&   }
.Ve
.SS "unionOfHashesAsArrays(@h)"
.IX Subsection "unionOfHashesAsArrays(@h)"
Form the union of the specified hashes \fB\f(CB@h\fB\fR as one hash whose values are a array of corresponding values from each hash
.PP
.Vb 2
\&     Parameter  Description
\&  1  @h         List of hashes to be united
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply  unionOfHashesAsArrays  # XXXXXXX
\&
\&     ({a=>1,b=>2}, {b=>1,c=>1}, {c=>2}),
\&      {a=>[1], b=>[2,1], c=>[undef,1,2]};
\&
\&    is_deeply  intersectionOfHashesAsArrays
\&     ({a=>1,b=>2},{b=>1,c=>1},{b=>3,c=>2}),
\&      {b=>[2,1,3]};
\&   }
.Ve
.SS "intersectionOfHashesAsArrays(@h)"
.IX Subsection "intersectionOfHashesAsArrays(@h)"
Form the intersection of the specified hashes \fB\f(CB@h\fB\fR as one hash whose values are an array of corresponding values from each hash
.PP
.Vb 2
\&     Parameter  Description
\&  1  @h         List of hashes to be intersected
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (1)
\&   {is_deeply  unionOfHashesAsArrays
\&     ({a=>1,b=>2}, {b=>1,c=>1}, {c=>2}),
\&      {a=>[1], b=>[2,1], c=>[undef,1,2]};
\&
\&
\&    is_deeply  intersectionOfHashesAsArrays  # XXXXXXX
\&
\&     ({a=>1,b=>2},{b=>1,c=>1},{b=>3,c=>2}),
\&      {b=>[2,1,3]};
\&   }
.Ve
.SS "setUnion(@s)"
.IX Subsection "setUnion(@s)"
Union of sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
.Vb 2
\&     Parameter  Description
\&  1  @s         Array of arrays of strings and/or hashes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [qw(a b c)],     [setUnion(qw(a b c a a b b b))];  # XXXXXXX
\&
\&
\&    is_deeply [qw(a b c d e)], [setUnion {a=>1, b=>2, e=>3}, [qw(c d e)], qw(e)];  # XXXXXXX
.Ve
.SS "setIntersection(@s)"
.IX Subsection "setIntersection(@s)"
Intersection of sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
.Vb 2
\&     Parameter  Description
\&  1  @s         Array of arrays of strings and/or hashes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [qw(a b c)], [setIntersection[qw(e f g a b c )],[qw(a A b B c C)]];  # XXXXXXX
\&
\&
\&    is_deeply [qw(e)],   [setIntersection {a=>1, b=>2, e=>3}, [qw(c d e)], qw(e)];  # XXXXXXX
.Ve
.SS "setIntersectionOverUnion(@s)"
.IX Subsection "setIntersectionOverUnion(@s)"
Returns the size of the intersection over the size of the union of one or more sets \fB\f(CB@s\fB\fR represented as arrays and/or hashes
.PP
.Vb 2
\&     Parameter  Description
\&  1  @s         Array of arrays of strings and/or hashes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = setIntersectionOverUnion {a=>1, b=>2, e=>3}, [qw(c d e)], qw(e);  # XXXXXXX
\&
\&    ok $f > 0.199999 && $f < 2.00001;
.Ve
.ie n .SS "setPartitionOnIntersectionOverUnion($confidence, @sets)"
.el .SS "setPartitionOnIntersectionOverUnion($confidence, \f(CW@sets\fP)"
.IX Subsection "setPartitionOnIntersectionOverUnion($confidence, @sets)"
Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@sets\fB\fR so that within each partition the setIntersectionOverUnion of any two sets in the partition is never less than the specified level of \fI\f(CI$confidence\fI**2\fR
.PP
.Vb 3
\&     Parameter    Description
\&  1  $confidence  Minimum setIntersectionOverUnion
\&  2  @sets        Array of arrays of strings and/or hashes representing sets
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [setPartitionOnIntersectionOverUnion  # XXXXXXX
\&
\&     (0.80,
\&       [qw(a A   b c d e)],
\&       [qw(a A B b c d e)],
\&       [qw(a A B C b c d)],
\&     )],
\&    [[["A", "B", "a".."e"],
\&      ["A",      "a".."e"]],
\&     [["A".."C", "a".."d"]],
\&    ];
\&  }
\&
\&
\&
\&
\&  if (1) {
\&  is_deeply [setPartitionOnIntersectionOverUnionOfSetsOfWords
\&     (0.80,
\&       [qw(a A   b c d e)],
\&       [qw(a A B b c d e)],
\&       [qw(a A B C b c d)],
\&     )],
\&   [[["a", "A", "B", "C", "b", "c", "d"]],
\&    [["a", "A", "B", "b" .. "e"], ["a", "A", "b" .. "e"]],
\&   ];
.Ve
.ie n .SS "setPartitionOnIntersectionOverUnionOfSetsOfWords($confidence, @sets)"
.el .SS "setPartitionOnIntersectionOverUnionOfSetsOfWords($confidence, \f(CW@sets\fP)"
.IX Subsection "setPartitionOnIntersectionOverUnionOfSetsOfWords($confidence, @sets)"
Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@sets\fB\fR of words so that within each partition the setIntersectionOverUnion of any two sets of words in the partition is never less than the specified \fI\f(CI$confidence\fI**2\fR
.PP
.Vb 3
\&     Parameter    Description
\&  1  $confidence  Minimum setIntersectionOverUnion
\&  2  @sets        Array of arrays of strings and/or hashes representing sets
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [setPartitionOnIntersectionOverUnionOfSetsOfWords  # XXXXXXX
\&
\&     (0.80,
\&       [qw(a A   b c d e)],
\&       [qw(a A B b c d e)],
\&       [qw(a A B C b c d)],
\&     )],
\&   [[["a", "A", "B", "C", "b", "c", "d"]],
\&    [["a", "A", "B", "b" .. "e"], ["a", "A", "b" .. "e"]],
\&   ];
.Ve
.ie n .SS "setPartitionOnIntersectionOverUnionOfStringSets($confidence, @strings)"
.el .SS "setPartitionOnIntersectionOverUnionOfStringSets($confidence, \f(CW@strings\fP)"
.IX Subsection "setPartitionOnIntersectionOverUnionOfStringSets($confidence, @strings)"
Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@strings\fB\fR, each set represented by a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fI\f(CI$confidence\fI**2\fR
.PP
.Vb 3
\&     Parameter    Description
\&  1  $confidence  Minimum setIntersectionOverUnion
\&  2  @strings     Sets represented by strings
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [setPartitionOnIntersectionOverUnionOfStringSets  # XXXXXXX
\&
\&     (0.80,
\&       q(The Emu            are seen here sometimes.),
\&       q(The Emu, Gnu       are seen here sometimes.),
\&       q(The Emu, Gnu, Colt are seen here.),
\&     )],
\&   [["The Emu, Gnu, Colt are seen here."],
\&    ["The Emu, Gnu       are seen here sometimes.",
\&     "The Emu            are seen here sometimes.",
\&    ]];
.Ve
.ie n .SS "setPartitionOnIntersectionOverUnionOfHashStringSets($confidence, $hashSet)"
.el .SS "setPartitionOnIntersectionOverUnionOfHashStringSets($confidence, \f(CW$hashSet\fP)"
.IX Subsection "setPartitionOnIntersectionOverUnionOfHashStringSets($confidence, $hashSet)"
Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB$hashSet\fB\fR represented by a hash, each hash value being a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fB\f(CB$confidence\fB**2\fR and the partition entries are the hash keys of the string sets.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $confidence  Minimum setIntersectionOverUnion
\&  2  $hashSet     Sets represented by the hash value strings
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [setPartitionOnIntersectionOverUnionOfHashStringSets  # XXXXXXX
\&
\&     (0.80,
\&       {e  =>q(The Emu            are seen here sometimes.),
\&        eg =>q(The Emu, Gnu       are seen here sometimes.),
\&        egc=>q(The Emu, Gnu, Colt are seen here.),
\&       }
\&     )],
\&   [["e", "eg"], ["egc"]];
.Ve
.ie n .SS "setPartitionOnIntersectionOverUnionOfHashStringSetsInParallel($confidence, $hashSet)"
.el .SS "setPartitionOnIntersectionOverUnionOfHashStringSetsInParallel($confidence, \f(CW$hashSet\fP)"
.IX Subsection "setPartitionOnIntersectionOverUnionOfHashStringSetsInParallel($confidence, $hashSet)"
Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB$hashSet\fB\fR represented by a hash, each hash value being a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fB\f(CB$confidence\fB**2\fR and the partition entries are the hash keys of the string sets. The partition is performed in square root parallel.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $confidence  Minimum setIntersectionOverUnion
\&  2  $hashSet     Sets represented by the hash value strings
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 9
\&    my $N = 8;
\&    my %s;
\&    for     my $a(\*(Aqa\*(Aq..\*(Aqz\*(Aq)
\&     {my @w;
\&      for   my $b(\*(Aqa\*(Aq..\*(Aqe\*(Aq)
\&       {for my $c(\*(Aqa\*(Aq..\*(Aqe\*(Aq)
\&         {push @w, qq($a$b$c);
\&         }
\&       }
\&
\&      for   my $i(1..$N)
\&       {$s{qq($a$i)} = join \*(Aq \*(Aq, @w;
\&       }
\&     }
\&
\&    my $expected =
\&     [["a1" .. "a8"],
\&      ["b1" .. "b8"],
\&      ["c1" .. "c8"],
\&      ["d1" .. "d8"],
\&      ["e1" .. "e8"],
\&      ["f1" .. "f8"],
\&      ["g1" .. "g8"],
\&      ["h1" .. "h8"],
\&      ["i1" .. "i8"],
\&      ["j1" .. "j8"],
\&      ["k1" .. "k8"],
\&      ["l1" .. "l8"],
\&      ["m1" .. "m8"],
\&      ["n1" .. "n8"],
\&      ["o1" .. "o8"],
\&      ["p1" .. "p8"],
\&      ["q1" .. "q8"],
\&      ["r1" .. "r8"],
\&      ["s1" .. "s8"],
\&      ["t1" .. "t8"],
\&      ["u1" .. "u8"],
\&      ["v1" .. "v8"],
\&      ["w1" .. "w8"],
\&      ["x1" .. "x8"],
\&      ["y1" .. "y8"],
\&      ["z1" .. "z8"],
\&     ];
\&
\&    is_deeply $expected,
\&     [setPartitionOnIntersectionOverUnionOfHashStringSets          (0.50, \e%s)];
\&
\&    my $expectedInParallel =
\&     ["a1 a2 a3 a4 a5 a6 a7 a8",                                                  # Same strings in multiple parallel processes
\&      "b1 b2 b3 b4 b5 b6 b7 b8",
\&      "b1 b2 b3 b4 b5 b6 b7 b8",
\&      "c1 c2 c3 c4 c5 c6 c7 c8",
\&      "d1 d2 d3 d4 d5 d6 d7 d8",
\&      "d1 d2 d3 d4 d5 d6 d7 d8",
\&      "e1 e2 e3 e4 e5 e6 e7 e8",
\&      "f1 f2 f3 f4 f5 f6 f7 f8",
\&      "f1 f2 f3 f4 f5 f6 f7 f8",
\&      "g1 g2 g3 g4 g5 g6 g7 g8",
\&      "h1 h2 h3 h4 h5 h6 h7 h8",
\&      "h1 h2 h3 h4 h5 h6 h7 h8",
\&      "i1 i2 i3 i4 i5 i6 i7 i8",
\&      "j1 j2 j3 j4 j5 j6 j7 j8",
\&      "j1 j2 j3 j4 j5 j6 j7 j8",
\&      "k1 k2 k3 k4 k5 k6 k7 k8",
\&      "l1 l2 l3 l4 l5 l6 l7 l8",
\&      "l1 l2 l3 l4 l5 l6 l7 l8",
\&      "m1 m2 m3 m4 m5 m6 m7 m8",
\&      "n1 n2 n3 n4 n5 n6 n7 n8",
\&      "n1 n2 n3 n4 n5 n6 n7 n8",
\&      "o1 o2 o3 o4 o5 o6 o7 o8",
\&      "p1 p2 p3 p4 p5 p6 p7 p8",
\&      "q1 q2 q3 q4 q5 q6 q7 q8",
\&      "q1 q2 q3 q4 q5 q6 q7 q8",
\&      "r1 r2 r3 r4 r5 r6 r7 r8",
\&      "s1 s2 s3 s4 s5 s6 s7 s8",
\&      "s1 s2 s3 s4 s5 s6 s7 s8",
\&      "t1 t2 t3 t4 t5 t6 t7 t8",
\&      "u1 u2 u3 u4 u5 u6 u7 u8",
\&      "u1 u2 u3 u4 u5 u6 u7 u8",
\&      "v1 v2 v3 v4 v5 v6 v7 v8",
\&      "w1 w2 w3 w4 w5 w6 w7 w8",
\&      "w1 w2 w3 w4 w5 w6 w7 w8",
\&      "x1 x2 x3 x4 x5 x6 x7 x8",
\&      "y1 y2 y3 y4 y5 y6 y7 y8",
\&      "y1 y2 y3 y4 y5 y6 y7 y8",
\&      "z1 z2 z3 z4 z5 z6 z7 z8",
\&     ];
\&
\&    if (1)
\&
\&     {my @p = setPartitionOnIntersectionOverUnionOfHashStringSetsInParallel  # XXXXXXX
\&
\&       (0.50, \e%s);
\&
\&      is_deeply $expectedInParallel, [sort map {join \*(Aq \*(Aq, @$_} @p];
\&     }
.Ve
.ie n .SS "contains($item, @array)"
.el .SS "contains($item, \f(CW@array\fP)"
.IX Subsection "contains($item, @array)"
Returns the indices at which an \fB\f(CB$item\fB\fR matches elements of the specified \fB\f(CB@array\fB\fR. If the item is a regular expression then it is matched as one, else it is a number it is matched as a number, else as a string.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $item      Item
\&  2  @array     Array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [1],       [contains(1,0..1)];                                          # XXXXXXX
\&
\&
\&
\&  is_deeply [1,3],     [contains(1, qw(0 1 0 1 0 0))];                              # XXXXXXX
\&
\&
\&
\&  is_deeply [0, 5],    [contains(\*(Aqa\*(Aq, qw(a b c d e a b c d e))];                    # XXXXXXX
\&
\&
\&
\&  is_deeply [0, 1, 5], [contains(qr(a+), qw(a baa c d e aa b c d e))];              # XXXXXXX
.Ve
.ie n .SS "countOccurencesInString($inString, $searchFor)"
.el .SS "countOccurencesInString($inString, \f(CW$searchFor\fP)"
.IX Subsection "countOccurencesInString($inString, $searchFor)"
Returns the number of occurrences in \fB\f(CB$inString\fB\fR of \fB\f(CB$searchFor\fB\fR.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $inString   String to search in
\&  2  $searchFor  String to search for.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {ok countOccurencesInString(q(a<b>c<b><b>d), q(<b>)) == 3;  # XXXXXXX
\&
\&   }
.Ve
.SS "\fBpartitionStringsOnPrefixBySize()\fP"
.IX Subsection "partitionStringsOnPrefixBySize()"
Partition a hash of strings and associated sizes into partitions with either a maximum size \fB\f(CB$maxSize\fB\fR or only one element; the hash \fB\f(CB%Sizes\fB\fR consisting of a mapping {string=>size}; with each partition being named with the shortest string prefix that identifies just the strings in that partition. Returns a list of {prefix => size}... describing each partition.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {my $ps = \e&partitionStringsOnPrefixBySize;  # XXXXXXX
\&
\&
\&    is_deeply {&$ps(1)}, {};
\&    is_deeply {&$ps(1, 1=>0)},      {q()=>0};
\&    is_deeply {&$ps(1, 1=>1)},      {q()=>1};
\&    is_deeply {&$ps(1, 1=>2)},      {1=>2};
\&    is_deeply {&$ps(1, 1=>1,2=>1)}, {1=>1,2=>1};
\&    is_deeply {&$ps(2, 11=>1,12=>1, 21=>1,22=>1)}, {1=>2, 2=>2};
\&    is_deeply {&$ps(2, 111=>1,112=>1,113=>1, 121=>1,122=>1,123=>1, 131=>1,132=>1,133=>1)}, { 111 => 1, 112 => 1, 113 => 1, 121 => 1, 122 => 1, 123 => 1, 131 => 1, 132 => 1, 133 => 1 };
\&
\&    for(3..8)
\&     {is_deeply {&$ps($_, 111=>1,112=>1,113=>1, 121=>1,122=>1,123=>1, 131=>1,132=>1,133=>1)}, { 11 => 3, 12 => 3, 13 => 3 };
\&     }
\&
\&    is_deeply {&$ps(9, 111=>1,112=>1,113=>1, 121=>1,122=>1,123=>1, 131=>1,132=>1,133=>1)}, { q()=> 9};
\&    is_deeply {&$ps(3, 111=>1,112=>1,113=>1, 121=>1,122=>1,123=>1, 131=>1,132=>1,133=>2)}, { 11 => 3, 12 => 3, 131 => 1, 132 => 1, 133 => 2 };
\&    is_deeply {&$ps(4, 111=>1,112=>1,113=>1, 121=>1,122=>1,123=>1, 131=>1,132=>1,133=>2)}, { 11 => 3, 12 => 3, 13 => 4 };
\&
\&   }
.Ve
.SS "transitiveClosure($h)"
.IX Subsection "transitiveClosure($h)"
Transitive closure of a hash of hashes
.PP
.Vb 2
\&     Parameter  Description
\&  1  $h         Hash of hashes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply transitiveClosure({a=>{b=>1, c=>2}, b=>{d=>3}, c=>{d=>4}}),  # XXXXXXX
\&
\&     {end => [{ b => 1, c => 1, d => 4 }, { d => 1 }],
\&      start => { a => 0, b => 1, c => 1 },
\&     };
\&   }
.Ve
.SH "Format"
.IX Header "Format"
Format data structures as tables.
.SS "maximumLineLength($string)"
.IX Subsection "maximumLineLength($string)"
Find the longest line in a \fB\f(CB$string\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String of lines of text
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok 3 == maximumLineLength(<<END);                                                 # XXXXXXX
\&
\&  a
\&  bb
\&  ccc
\&  END
.Ve
.SS "formatTableBasic($data)"
.IX Subsection "formatTableBasic($data)"
Tabularize an array of arrays of text.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $data      Reference to an array of arrays of data to be formatted as a table.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = [[qw(a 1)], [qw(bb 22)], [qw(ccc 333)], [qw(dddd 4444)]];
\&
\&    ok formatTableBasic($d) eq <<END, q(ftb);  # XXXXXXX
\&
\&  a        1
\&  bb      22
\&  ccc    333
\&  dddd  4444
\&  END
\&    }
\&
\&  if (0) {
\&    my %pids;
\&    sub{startProcess {} %pids, 1; ok 1 >= keys %pids}\->() for 1..8;
\&    waitForAllStartedProcessesToFinish(%pids);
\&    ok !keys(%pids)
.Ve
.ie n .SS "formatTable($data, $columnTitles, @options)"
.el .SS "formatTable($data, \f(CW$columnTitles\fP, \f(CW@options\fP)"
.IX Subsection "formatTable($data, $columnTitles, @options)"
Format various \fB\f(CB$data\fB\fR structures as a table with titles as specified by \fB\f(CB$columnTitles\fB\fR: either a reference to an array of column titles or a string each line of which contains the column title as the first word with the rest of the line describing that column.
.PP
Optionally create a report from the table using the report \fB\f(CB%options\fB\fR described in formatTableCheckKeys
.PP
.Vb 4
\&     Parameter      Description
\&  1  $data          Data to be formatted
\&  2  $columnTitles  Optional reference to an array of titles or string of column descriptions
\&  3  @options       Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok formatTable                                                                    # XXXXXXX
\&
\&
\&   ([[qw(A    B    C    D   )],
\&
\&     [qw(AA   BB   CC   DD  )],
\&
\&     [qw(AAA  BBB  CCC  DDD )],
\&
\&     [qw(AAAA BBBB CCCC DDDD)],
\&
\&     [qw(1    22   333  4444)]], [qw(aa bb cc)]) eq <<END;
\&     aa    bb    cc
\&  1  A     B     C     D
\&  2  AA    BB    CC    DD
\&  3  AAA   BBB   CCC   DDD
\&  4  AAAA  BBBB  CCCC  DDDD
\&  5     1    22   333  4444
\&  END
\&
\&
\&  ok formatTable                                                                    # XXXXXXX
\&
\&
\&   ([[qw(1     B   C)],
\&
\&     [qw(22    BB  CC)],
\&
\&     [qw(333   BBB CCC)],
\&
\&     [qw(4444  22  333)]], [qw(aa bb cc)]) eq <<END;
\&     aa    bb   cc
\&  1     1  B    C
\&  2    22  BB   CC
\&  3   333  BBB  CCC
\&  4  4444   22  333
\&  END
\&
\&
\&  ok formatTable                                                                    # XXXXXXX
\&
\&
\&   ([{aa=>\*(AqA\*(Aq,   bb=>\*(AqB\*(Aq,   cc=>\*(AqC\*(Aq},
\&
\&     {aa=>\*(AqAA\*(Aq,  bb=>\*(AqBB\*(Aq,  cc=>\*(AqCC\*(Aq},
\&
\&     {aa=>\*(AqAAA\*(Aq, bb=>\*(AqBBB\*(Aq, cc=>\*(AqCCC\*(Aq},
\&
\&     {aa=>\*(Aq1\*(Aq,   bb=>\*(Aq22\*(Aq,  cc=>\*(Aq333\*(Aq}
\&
\&     ]) eq <<END;
\&     aa   bb   cc
\&  1  A    B    C
\&  2  AA   BB   CC
\&  3  AAA  BBB  CCC
\&  4    1   22  333
\&  END
\&
\&
\&  ok formatTable                                                                    # XXXXXXX
\&
\&
\&   ({\*(Aq\*(Aq=>[qw(aa bb cc)],
\&
\&      1=>[qw(A B C)],
\&
\&      22=>[qw(AA BB CC)],
\&
\&      333=>[qw(AAA BBB CCC)],
\&
\&      4444=>[qw(1 22 333)]}) eq <<END;
\&        aa   bb   cc
\&     1  A    B    C
\&    22  AA   BB   CC
\&   333  AAA  BBB  CCC
\&  4444    1   22  333
\&  END
\&
\&
\&  ok formatTable                                                                    # XXXXXXX
\&
\&
\&   ({1=>{aa=>\*(AqA\*(Aq, bb=>\*(AqB\*(Aq, cc=>\*(AqC\*(Aq},
\&
\&     22=>{aa=>\*(AqAA\*(Aq, bb=>\*(AqBB\*(Aq, cc=>\*(AqCC\*(Aq},
\&
\&     333=>{aa=>\*(AqAAA\*(Aq, bb=>\*(AqBBB\*(Aq, cc=>\*(AqCCC\*(Aq},
\&
\&     4444=>{aa=>\*(Aq1\*(Aq, bb=>\*(Aq22\*(Aq, cc=>\*(Aq333\*(Aq}}) eq <<END;
\&        aa   bb   cc
\&     1  A    B    C
\&    22  AA   BB   CC
\&   333  AAA  BBB  CCC
\&  4444    1   22  333
\&  END
\&
\&
\&  ok formatTable({aa=>\*(AqA\*(Aq, bb=>\*(AqB\*(Aq, cc=>\*(AqC\*(Aq}, [qw(aaaa bbbb)]) eq <<END;            # XXXXXXX
\&
\&  aaaa  bbbb
\&  aa    A
\&  bb    B
\&  cc    C
\&  END
\&
\&    my $file = fpe(qw(report txt));                                               # Create a report
\&
\&    my $t = formatTable  # XXXXXXX
\&
\&     ([["a",undef], [undef, "b0ac"]],                                           # Data \- please replace 0a with a new line
\&      [undef, "BC"],                                                              # Column titles
\&      file=>$file,                                                                # Output file
\&      head=><<END);                                                               # Header
\&  Sample report.
\&
\&  Table has NNNN rows.
\&  END
\&    ok \-e $file;
\&    ok readFile($file) eq $t;
\&    unlink $file;
\&    ok nws($t) eq nws(<<END);
\&  Sample report.
\&
\&  Table has 2 rows.
\&
\&  This file: report.txt
\&
\&        BC
\&  1  a
\&  2     b
\&        c
\&  END
.Ve
.SS "formattedTablesReport(@options)"
.IX Subsection "formattedTablesReport(@options)"
Report of all the reports created. The optional parameters are the same as for formatTable
.PP
.Vb 2
\&     Parameter  Description
\&  1  @options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    @formatTables = ();
\&
\&    for my $m(2..8)
\&     {formatTable([map {[$_, $_*$m]} 1..$m], [q(Single), qq(* $m)],
\&        title=>qq(Multiply by $m));
\&     }
\&
\&
\&    ok nws(formattedTablesReport) eq nws(<<END);  # XXXXXXX
\&
\&     Rows  Title          File
\&  1     2  Multiply by 2
\&  2     3  Multiply by 3
\&  3     4  Multiply by 4
\&  4     5  Multiply by 5
\&  5     6  Multiply by 6
\&  6     7  Multiply by 7
\&  7     8  Multiply by 8
\&  END
.Ve
.ie n .SS "summarizeColumn($data, $column)"
.el .SS "summarizeColumn($data, \f(CW$column\fP)"
.IX Subsection "summarizeColumn($data, $column)"
Count the number of unique instances of each value a column in a table assumes.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Table == array of arrays
\&  2  $column    Column number to summarize.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply
\&
\&     [summarizeColumn([map {[$_]} qw(A B D B C D C D A C D C B B D)], 0)],  # XXXXXXX
\&
\&     [[5, "D"], [4, "B"], [4, "C"], [2, "A"]];
\&
\&    ok nws(formatTable
\&     ([map {[split m//, $_]} qw(AA CB CD BC DC DD CD AD AA DC CD CC BB BB BD)],
\&      [qw(Col\-1 Col\-2)],
\&       summarize=>1)) eq nws(<<\*(AqEND\*(Aq);
\&
\&  Summary_of_column                \- Count of unique values found in each column                     Use the Geany flick capability by placing your cursor on the first word
\&  Comma_Separated_Values_of_column \- Comma separated list of the unique values found in each column  of these lines and pressing control + down arrow to see each sub report.
\&
\&      Col\-1  Col\-2
\&   1  A      A
\&   2  C      B
\&   3  C      D
\&   4  B      C
\&   5  D      C
\&   6  D      D
\&   7  C      D
\&   8  A      D
\&   9  A      A
\&  10  D      C
\&  11  C      D
\&  12  C      C
\&  13  B      B
\&  14  B      B
\&  15  B      D
\&
\&  Summary_of_column_Col\-1
\&     Count  Col\-1
\&  1      5  C
\&  2      4  B
\&  3      3  A
\&  4      3  D
\&
\&  Comma_Separated_Values_of_column_Col\-1: "A","B","C","D"
\&
\&  Summary_of_column_Col\-2
\&     Count  Col\-2
\&  1      6  D
\&  2      4  C
\&  3      3  B
\&  4      2  A
\&
\&  Comma_Separated_Values_of_column_Col\-2: "A","B","C","D"
\&  END
.Ve
.ie n .SS "keyCount($maxDepth, $ref)"
.el .SS "keyCount($maxDepth, \f(CW$ref\fP)"
.IX Subsection "keyCount($maxDepth, $ref)"
Count keys down to the specified level.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $maxDepth  Maximum depth to count to
\&  2  $ref       Reference to an array or a hash
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $a = [[1..3],       {map{$_=>1} 1..3}];
\&
\&    my $h = {a=>[1..3], b=>{map{$_=>1} 1..3}};
\&
\&
\&    ok keyCount(2, $a) == 6;                                                        # XXXXXXX
\&
\&
\&
\&    ok keyCount(2, $h) == 6;                                                        # XXXXXXX
.Ve
.ie n .SS "formatHtmlTable($data, %options)"
.el .SS "formatHtmlTable($data, \f(CW%options\fP)"
.IX Subsection "formatHtmlTable($data, %options)"
Format an array of arrays of scalars as an html table using the  \fB\f(CB%options\fB\fR described in formatTableCheckKeys.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Data to be formatted
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {my $t = formatHtmlTable  # XXXXXXX
\&
\&     ([
\&        [qw(1 a)],
\&        [qw(2 b)],
\&      ],
\&     title  => q(Sample html table),
\&     head   => q(Head NNNN rows),
\&     foot   => q(Footer),
\&     columns=> <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&    my $T = <<\*(AqEND\*(Aq;
\&  <h1>Sample html table</h1>
\&
\&  <p>Head 2 rows</p>
\&
\&  <p><table borders="0" cellpadding="10" cellspacing="5">
\&
\&  <tr><th><span title="The source number">source</span><th><span title="The target letter">target</span>
\&  <tr><td>1<td>a
\&  <tr><td>2<td>b
\&  </table></p>
\&
\&  <p><pre>
\&  source  The source number
\&  target  The target letter
\&
\&  </pre></p>
\&
\&  <p>Footer</p>
\&
\&  <span class="options" style="display: none">{
\&    columns => "source The source number
\&target The target letter
\&",
\&    foot    => "Footer",
\&    head    => "Head NNNN rows",
\&    rows    => 2,
\&    title   => "Sample html table",
\&  }</span>
\&  END
\&
\&    ok "$t
\&" eq $T;
\&   }
.Ve
.ie n .SS "formatHtmlTablesIndex($reports, $title, $url, $columns)"
.el .SS "formatHtmlTablesIndex($reports, \f(CW$title\fP, \f(CW$url\fP, \f(CW$columns\fP)"
.IX Subsection "formatHtmlTablesIndex($reports, $title, $url, $columns)"
Create an index of html reports.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $reports   Reports folder
\&  2  $title     Title of report of reports
\&  3  $url       $url to get files
\&  4  $columns   Number of columns \- defaults to 1
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $reports = temporaryFolder;
\&
\&    formatHtmlAndTextTables
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?), q(/a/),
\&       [[qw(1 /a/a)],
\&        [qw(2 /a/b)],
\&       ],
\&     title   => q(Bad files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(bad.html),
\&     facet   => q(files), aspectColor => "red",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&    formatHtmlAndTextTables
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?file=), q(/a/),
\&       [[qw(1 /a/a1)],
\&        [qw(2 /a/b2)],
\&        [qw(3 /a/b3)],
\&       ],
\&     title   => q(Good files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(good.html),
\&     facet   => q(files), aspectColor => "green",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&    formatHtmlAndTextTablesWaitPids;
\&
\&
\&    my $result = formatHtmlTablesIndex($reports, q(TITLE), q(/cgi\-bin/getFile.pl?file=));  # XXXXXXX
\&
\&    ok $result =~ m(3.*Good files);
\&    ok $result =~ m(2.*Bad files);
\&  #  ok $result =~ m(green.*>3<.*>Good files);
\&  #  ok $result =~ m(red.*>2<.*>Bad files);
\&
\&    clearFolder($reports, 11);
\&   }
.Ve
.SS "\fBformatHtmlAndTextTablesWaitPids()\fP"
.IX Subsection "formatHtmlAndTextTablesWaitPids()"
Wait on all table formatting pids to complete
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $reports = temporaryFolder;
\&
\&    formatHtmlAndTextTables
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?), q(/a/),
\&       [[qw(1 /a/a)],
\&        [qw(2 /a/b)],
\&       ],
\&     title   => q(Bad files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(bad.html),
\&     facet   => q(files), aspectColor => "red",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&    formatHtmlAndTextTables
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?file=), q(/a/),
\&       [[qw(1 /a/a1)],
\&        [qw(2 /a/b2)],
\&        [qw(3 /a/b3)],
\&       ],
\&     title   => q(Good files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(good.html),
\&     facet   => q(files), aspectColor => "green",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&
\&    formatHtmlAndTextTablesWaitPids;  # XXXXXXX
\&
\&
\&    my $result = formatHtmlTablesIndex($reports, q(TITLE), q(/cgi\-bin/getFile.pl?file=));
\&    ok $result =~ m(3.*Good files);
\&    ok $result =~ m(2.*Bad files);
\&  #  ok $result =~ m(green.*>3<.*>Good files);
\&  #  ok $result =~ m(red.*>2<.*>Bad files);
\&
\&    clearFolder($reports, 11);
\&   }
.Ve
.ie n .SS "formatHtmlAndTextTables($reports, $html, $getFile, $filePrefix, $data, %options)"
.el .SS "formatHtmlAndTextTables($reports, \f(CW$html\fP, \f(CW$getFile\fP, \f(CW$filePrefix\fP, \f(CW$data\fP, \f(CW%options\fP)"
.IX Subsection "formatHtmlAndTextTables($reports, $html, $getFile, $filePrefix, $data, %options)"
Create text and html versions of a tabular report
.PP
.Vb 7
\&     Parameter    Description
\&  1  $reports     Folder to contain text reports
\&  2  $html        Folder to contain html reports
\&  3  $getFile     L<url|https://en.wikipedia.org/wiki/URL> to get files
\&  4  $filePrefix  File prefix to be removed from file entries or array of file prefixes
\&  5  $data        Data
\&  6  %options     Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $reports = temporaryFolder;
\&
\&
\&    formatHtmlAndTextTables  # XXXXXXX
\&
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?), q(/a/),
\&       [[qw(1 /a/a)],
\&        [qw(2 /a/b)],
\&       ],
\&     title   => q(Bad files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(bad.html),
\&     facet   => q(files), aspectColor => "red",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&
\&    formatHtmlAndTextTables  # XXXXXXX
\&
\&     ($reports, $reports, q(/cgi\-bin/getFile.pl?file=), q(/a/),
\&       [[qw(1 /a/a1)],
\&        [qw(2 /a/b2)],
\&        [qw(3 /a/b3)],
\&       ],
\&     title   => q(Good files),
\&     head    => q(Head NNNN rows),
\&     foot    => q(Footer),
\&     file    => q(good.html),
\&     facet   => q(files), aspectColor => "green",
\&     columns => <<END,
\&  source The source number
\&  target The target letter
\&  END
\&     );
\&
\&    formatHtmlAndTextTablesWaitPids;
\&
\&    my $result = formatHtmlTablesIndex($reports, q(TITLE), q(/cgi\-bin/getFile.pl?file=));
\&    ok $result =~ m(3.*Good files);
\&    ok $result =~ m(2.*Bad files);
\&  #  ok $result =~ m(green.*>3<.*>Good files);
\&  #  ok $result =~ m(red.*>2<.*>Bad files);
\&
\&    clearFolder($reports, 11);
\&   }
.Ve
.SH "Lines"
.IX Header "Lines"
Load data structures from lines.
.SS "loadArrayFromLines($string)"
.IX Subsection "loadArrayFromLines($string)"
Load an array from lines of text in a string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create an array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadArrayFromLines <<END;                                               # XXXXXXX
\&
\&  a a
\&  b b
\&  END
\&
\&    is_deeply $s, [q(a a), q(b b)];
\&
\&    ok formatTable($s) eq <<END;
\&  0  a a
\&  1  b b
\&  END
.Ve
.SS "loadHashFromLines($string)"
.IX Subsection "loadHashFromLines($string)"
Load a hash: first word of each line is the key and the rest is the value.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create a hash
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadHashFromLines <<END;                                                # XXXXXXX
\&
\&  a 10 11 12
\&  b 20 21 22
\&  END
\&
\&    is_deeply $s, {a => q(10 11 12), b =>q(20 21 22)};
\&
\&    ok formatTable($s) eq <<END;
\&  a  10 11 12
\&  b  20 21 22
\&  END
.Ve
.SS "loadArrayArrayFromLines($string)"
.IX Subsection "loadArrayArrayFromLines($string)"
Load an array of arrays from lines of text: each line is an array of words.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create an array of arrays
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadArrayArrayFromLines <<END;                                          # XXXXXXX
\&
\&  A B C
\&  AA BB CC
\&  END
\&
\&    is_deeply $s, [[qw(A B C)], [qw(AA BB CC)]];
\&
\&    ok formatTable($s) eq <<END;
\&  1  A   B   C
\&  2  AA  BB  CC
\&  END
.Ve
.SS "loadHashArrayFromLines($string)"
.IX Subsection "loadHashArrayFromLines($string)"
Load a hash of arrays from lines of text: the first word of each line is the key, the remaining words are the array contents.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create a hash of arrays
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadHashArrayFromLines <<END;                                           # XXXXXXX
\&
\&  a A B C
\&  b AA BB CC
\&  END
\&
\&    is_deeply $s, {a =>[qw(A B C)], b => [qw(AA BB CC)] };
\&
\&    ok formatTable($s) eq <<END;
\&  a  A   B   C
\&  b  AA  BB  CC
\&  END
.Ve
.SS "loadArrayHashFromLines($string)"
.IX Subsection "loadArrayHashFromLines($string)"
Load an array of hashes from lines of text: each line is a hash of words.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create an array of arrays
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadArrayHashFromLines <<END;                                           # XXXXXXX
\&
\&  A 1 B 2
\&  AA 11 BB 22
\&  END
\&
\&    is_deeply $s, [{A=>1, B=>2}, {AA=>11, BB=>22}];
\&
\&    ok formatTable($s) eq <<END;
\&     A  AA  B  BB
\&  1  1      2
\&  2     11     22
\&  END
.Ve
.SS "loadHashHashFromLines($string)"
.IX Subsection "loadHashHashFromLines($string)"
Load a hash of hashes from lines of text: the first word of each line is the key, the remaining words are the sub hash contents.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    The string of lines from which to create a hash of arrays
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $s = loadHashHashFromLines <<END;                                            # XXXXXXX
\&
\&  a A 1 B 2
\&  b AA 11 BB 22
\&  END
\&
\&    is_deeply $s, {a=>{A=>1, B=>2}, b=>{AA=>11, BB=>22}};
\&
\&    ok formatTable($s) eq <<END;
\&     A  AA  B  BB
\&  a  1      2
\&  b     11     22
\&  END
.Ve
.ie n .SS "checkKeys($hash, $permitted)"
.el .SS "checkKeys($hash, \f(CW$permitted\fP)"
.IX Subsection "checkKeys($hash, $permitted)"
Check the keys in a \fBhash\fR conform to those \fB\f(CB$permitted\fB\fR.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $hash       The hash to test
\&  2  $permitted  A hash of the permitted keys and their meanings
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    eval q{checkKeys({a=>1, b=>2, d=>3}, {a=>1, b=>2, c=>3})};                      # XXXXXXX
\&
\&
\&    ok nws($@) =~ m(\eAInvalid options chosen: d Permitted.+?: a 1 b 2 c 3);
.Ve
.SH "LVALUE methods"
.IX Header "LVALUE methods"
Replace \f(CW$a\fR\->{\fBvalue\fR} = \f(CW$b\fR with \f(CW$a\fR\->\fBvalue\fR = \f(CW$b\fR which reduces the amount of typing required, is easier to read and provides a hard check that {\fBvalue\fR} is spelled correctly.
.SS "genLValueScalarMethods(@names)"
.IX Subsection "genLValueScalarMethods(@names)"
Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods in the current package, A method whose value has not yet been set will return a new scalar with value \fBundef\fR. Suffixing \fBX\fR to the scalar name will confess if a value has not been set.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @names     List of method names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    package Scalars;
\&
\&    my $a = bless{};
\&
\&
\&    Data::Table::Text::genLValueScalarMethods(qw(aa bb cc));                        # XXXXXXX
\&
\&
\&    $a\->aa = \*(Aqaa\*(Aq;
\&
\&    Test::More::ok  $a\->aa eq \*(Aqaa\*(Aq;
\&
\&    Test::More::ok !$a\->bb;
\&
\&    Test::More::ok  $a\->bbX eq q();
\&
\&    $a\->aa = undef;
\&
\&    Test::More::ok !$a\->aa;
.Ve
.SS "addLValueScalarMethods(@names)"
.IX Subsection "addLValueScalarMethods(@names)"
Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods in the current package if they do not already exist. A method whose value has not yet been set will return a new scalar with value \fBundef\fR. Suffixing \fBX\fR to the scalar name will confess if a value has not been set.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @names     List of method names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $class = "Data::Table::Text::Test";
\&
\&    my $a = bless{}, $class;
\&
\&
\&    addLValueScalarMethods(qq(${class}::$_)) for qw(aa bb aa bb);                   # XXXXXXX
\&
\&
\&    $a\->aa = \*(Aqaa\*(Aq;
\&
\&    ok  $a\->aa eq \*(Aqaa\*(Aq;
\&
\&    ok !$a\->bb;
\&
\&    ok  $a\->bbX eq q();
\&
\&    $a\->aa = undef;
\&
\&    ok !$a\->aa;
.Ve
.SS "genLValueScalarMethodsWithDefaultValues(@names)"
.IX Subsection "genLValueScalarMethodsWithDefaultValues(@names)"
Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods with default values in the current package. A reference to a method whose value has not yet been set will return a scalar whose value is the name of the method.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @names     List of method names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    package ScalarsWithDefaults;
\&
\&    my $a = bless{};
\&
\&
\&    Data::Table::Text::genLValueScalarMethodsWithDefaultValues(qw(aa bb cc));       # XXXXXXX
\&
\&
\&    Test::More::ok $a\->aa eq \*(Aqaa\*(Aq;
.Ve
.SS "genLValueArrayMethods(@names)"
.IX Subsection "genLValueArrayMethods(@names)"
Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> array methods in the current package. A reference to a method that has no yet been set will return a reference to an empty array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @names     List of method names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    package Arrays;
\&
\&    my $a = bless{};
\&
\&
\&    Data::Table::Text::genLValueArrayMethods(qw(aa bb cc));                         # XXXXXXX
\&
\&
\&    $a\->aa\->[1] = \*(Aqaa\*(Aq;
\&
\&    Test::More::ok $a\->aa\->[1] eq \*(Aqaa\*(Aq;
.Ve
.SS "genLValueHashMethods(@names)"
.IX Subsection "genLValueHashMethods(@names)"
Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> hash methods in the current package. A reference to a method that has no yet been set will return a reference to an empty hash.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @names     Method names
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    package Hashes;
\&
\&    my $a = bless{};
\&
\&
\&    Data::Table::Text::genLValueHashMethods(qw(aa bb cc));                          # XXXXXXX
\&
\&
\&    $a\->aa\->{a} = \*(Aqaa\*(Aq;
\&
\&    Test::More::ok $a\->aa\->{a} eq \*(Aqaa\*(Aq;
.Ve
.ie n .SS "genHash($bless, %attributes)"
.el .SS "genHash($bless, \f(CW%attributes\fP)"
.IX Subsection "genHash($bless, %attributes)"
Return a \fB\f(CB$bless\fB\fRed hash with the specified \fB\f(CB$attributes\fB\fR accessible via lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> method calls. updateDocumentation will generate documentation at \*(L"Hash Definitions\*(R" for the hash defined by the call to genHash if the call is laid out as in the example below.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $bless       Package name
\&  2  %attributes  Hash of attribute names and values
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $o = genHash(q(TestHash),                                                  # Definition of a blessed hash.  # XXXXXXX
\&
\&        a=>q(aa),                                                                 # Definition of attribute aa.
\&        b=>q(bb),                                                                 # Definition of attribute bb.
\&       );
\&    ok $o\->a eq q(aa);
\&    is_deeply $o, {a=>"aa", b=>"bb"};
\&
\&    my $p = genHash(q(TestHash),  # XXXXXXX
\&
\&      c=>q(cc),                                                                   # Definition of attribute cc.
\&     );
\&    ok $p\->c eq q(cc);
\&    ok $p\->a =  q(aa);
\&    ok $p\->a eq q(aa);
\&    is_deeply $p, {a=>"aa", c=>"cc"};
\&
\&    loadHash($p, a=>11, b=>22);                                                   # Load the hash
\&    is_deeply $p, {a=>11, b=>22, c=>"cc"};
\&
\&    my $r = eval {loadHash($p, d=>44)};                                           # Try to load the hash
\&    ok $@ =~ m(Cannot load attribute: d);
.Ve
.ie n .SS "loadHash($hash, %attributes)"
.el .SS "loadHash($hash, \f(CW%attributes\fP)"
.IX Subsection "loadHash($hash, %attributes)"
Load the specified blessed \fB\f(CB$hash\fB\fR generated with genHash with \fB\f(CB%attributes\fB\fR. Confess to any unknown attribute names.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $hash        Hash
\&  2  %attributes  Hash of attribute names and values to be loaded
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my $o = genHash(q(TestHash),                                                  # Definition of a blessed hash.
\&        a=>q(aa),                                                                 # Definition of attribute aa.
\&        b=>q(bb),                                                                 # Definition of attribute bb.
\&       );
\&    ok $o\->a eq q(aa);
\&    is_deeply $o, {a=>"aa", b=>"bb"};
\&    my $p = genHash(q(TestHash),
\&      c=>q(cc),                                                                   # Definition of attribute cc.
\&     );
\&    ok $p\->c eq q(cc);
\&    ok $p\->a =  q(aa);
\&    ok $p\->a eq q(aa);
\&    is_deeply $p, {a=>"aa", c=>"cc"};
\&
\&
\&    loadHash($p, a=>11, b=>22);                                                   # Load the hash  # XXXXXXX
\&
\&    is_deeply $p, {a=>11, b=>22, c=>"cc"};
\&
\&
\&    my $r = eval {loadHash($p, d=>44)};                                           # Try to load the hash  # XXXXXXX
\&
\&    ok $@ =~ m(Cannot load attribute: d);
.Ve
.SS "reloadHashes($d)"
.IX Subsection "reloadHashes($d)"
Ensures that all the hashes within a tower of data structures have LValue methods to get and set their current keys.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $d         Data structure
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (1)
\&   {my $a = bless [bless {aaa=>42}, "AAAA"], "BBBB";
\&    eval {$a\->[0]\->aaa};
\&    ok $@ =~ m(\eACan.t locate object method .aaa. via package .AAAA.);
\&
\&    reloadHashes($a);  # XXXXXXX
\&
\&    ok $a\->[0]\->aaa == 42;
\&   }
\&
\&  if (1)
\&   {my $a = bless [bless {ccc=>42}, "CCCC"], "DDDD";
\&    eval {$a\->[0]\->ccc};
\&    ok $@ =~ m(\eACan.t locate object method .ccc. via package .CCCC.);
\&
\&    reloadHashes($a);  # XXXXXXX
\&
\&    ok $a\->[0]\->ccc == 42;
\&   }
.Ve
.ie n .SS "setPackageSearchOrder($set, @search)"
.el .SS "setPackageSearchOrder($set, \f(CW@search\fP)"
.IX Subsection "setPackageSearchOrder($set, @search)"
Set a package search order for methods requested in the current package via \s-1AUTOLOAD.\s0
.PP
.Vb 3
\&     Parameter  Description
\&  1  $set       Package to set
\&  2  @search    Package names in search order.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&  if (1)
\&   {if (1)
\&     {package AAAA;
\&
\&      sub aaaa{q(AAAAaaaa)}
\&      sub bbbb{q(AAAAbbbb)}
\&      sub cccc{q(AAAAcccc)}
\&     }
\&    if (1)
\&     {package BBBB;
\&
\&      sub aaaa{q(BBBBaaaa)}
\&      sub bbbb{q(BBBBbbbb)}
\&      sub dddd{q(BBBBdddd)}
\&     }
\&    if (1)
\&     {package CCCC;
\&
\&      sub aaaa{q(CCCCaaaa)}
\&      sub dddd{q(CCCCdddd)}
\&      sub eeee{q(CCCCeeee)}
\&     }
\&
\&
\&    setPackageSearchOrder(_\|_PACKAGE_\|_, qw(CCCC BBBB AAAA));  # XXXXXXX
\&
\&
\&    ok &aaaa eq q(CCCCaaaa);
\&    ok &bbbb eq q(BBBBbbbb);
\&    ok &cccc eq q(AAAAcccc);
\&
\&    ok &aaaa eq q(CCCCaaaa);
\&    ok &bbbb eq q(BBBBbbbb);
\&    ok &cccc eq q(AAAAcccc);
\&
\&    ok &dddd eq q(CCCCdddd);
\&    ok &eeee eq q(CCCCeeee);
\&
\&
\&    setPackageSearchOrder(_\|_PACKAGE_\|_, qw(AAAA BBBB CCCC));  # XXXXXXX
\&
\&
\&    ok &aaaa eq q(AAAAaaaa);
\&    ok &bbbb eq q(AAAAbbbb);
\&    ok &cccc eq q(AAAAcccc);
\&
\&    ok &aaaa eq q(AAAAaaaa);
\&    ok &bbbb eq q(AAAAbbbb);
\&    ok &cccc eq q(AAAAcccc);
\&
\&    ok &dddd eq q(BBBBdddd);
\&    ok &eeee eq q(CCCCeeee);
\&   }
.Ve
.ie n .SS "isSubInPackage($package, $sub)"
.el .SS "isSubInPackage($package, \f(CW$sub\fP)"
.IX Subsection "isSubInPackage($package, $sub)"
Test whether the specified \fB\f(CB$package\fB\fR contains the subroutine <$sub>.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $package   Package name
\&  2  $sub       Subroutine name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {sub AAAA::Call {q(AAAA)}
\&
\&    sub BBBB::Call {q(BBBB)}
\&    sub BBBB::call {q(bbbb)}
\&
\&    if (1)
\&     {package BBBB;
\&      use Test::More;
\&      *ok = *Test::More::ok;
\&
\&      *isSubInPackage = *Data::Table::Text::isSubInPackage;  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(AAAA), q(Call));  # XXXXXXX
\&
\&
\&      ok !isSubInPackage(q(AAAA), q(call));  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(BBBB), q(Call));  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(BBBB), q(call));  # XXXXXXX
\&
\&      ok Call eq q(BBBB);
\&      ok call eq q(bbbb);
\&      &Data::Table::Text::overrideMethods(qw(AAAA BBBB Call call));
\&
\&      *isSubInPackage = *Data::Table::Text::isSubInPackage;  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(AAAA), q(Call));  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(AAAA), q(call));  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(BBBB), q(Call));  # XXXXXXX
\&
\&
\&      ok  isSubInPackage(q(BBBB), q(call));  # XXXXXXX
\&
\&      ok Call eq q(AAAA);
\&      ok call eq q(bbbb);
\&      package AAAA;
\&      use Test::More;
\&      *ok = *Test::More::ok;
\&      ok  Call eq q(AAAA);
\&      ok &call eq q(bbbb);
\&     }
\&   }
.Ve
.ie n .SS "overrideMethods($from, $to, @methods)"
.el .SS "overrideMethods($from, \f(CW$to\fP, \f(CW@methods\fP)"
.IX Subsection "overrideMethods($from, $to, @methods)"
For each method, if it exists in package \fB\f(CB$from\fB\fR then export it to package \fB\f(CB$to\fB\fR replacing any existing method in \fB\f(CB$to\fB\fR, otherwise export the method from package \fB\f(CB$to\fB\fR to package \fB\f(CB$from\fB\fR in order to merge the behavior of the \fB\f(CB$from\fB\fR and \fB\f(CB$to\fB\fR packages with respect to the named methods with duplicates resolved if favour of package \fB\f(CB$from\fB\fR.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $from      Name of package from which to import methods
\&  2  $to        Package into which to import the methods
\&  3  @methods   List of methods to try importing.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {sub AAAA::Call {q(AAAA)}
\&
\&    sub BBBB::Call {q(BBBB)}
\&    sub BBBB::call {q(bbbb)}
\&
\&    if (1)
\&     {package BBBB;
\&      use Test::More;
\&      *ok = *Test::More::ok;
\&      *isSubInPackage = *Data::Table::Text::isSubInPackage;
\&      ok  isSubInPackage(q(AAAA), q(Call));
\&      ok !isSubInPackage(q(AAAA), q(call));
\&      ok  isSubInPackage(q(BBBB), q(Call));
\&      ok  isSubInPackage(q(BBBB), q(call));
\&      ok Call eq q(BBBB);
\&      ok call eq q(bbbb);
\&
\&      &Data::Table::Text::overrideMethods(qw(AAAA BBBB Call call));  # XXXXXXX
\&
\&      *isSubInPackage = *Data::Table::Text::isSubInPackage;
\&      ok  isSubInPackage(q(AAAA), q(Call));
\&      ok  isSubInPackage(q(AAAA), q(call));
\&      ok  isSubInPackage(q(BBBB), q(Call));
\&      ok  isSubInPackage(q(BBBB), q(call));
\&      ok Call eq q(AAAA);
\&      ok call eq q(bbbb);
\&      package AAAA;
\&      use Test::More;
\&      *ok = *Test::More::ok;
\&      ok  Call eq q(AAAA);
\&      ok &call eq q(bbbb);
\&     }
\&   }
.Ve
.PP
This is a static method and so should either be imported or invoked as:
.PP
.Vb 1
\&  Data::Table::Text::overrideMethods
.Ve
.SS "overrideAndReabsorbMethods(@packages)"
.IX Subsection "overrideAndReabsorbMethods(@packages)"
Override methods down the list of \fB\f(CB@packages\fB\fR then reabsorb any unused methods back up the list of packages so that all the packages have the same methods as the last package with methods from packages mentioned earlier overriding methods from packages mentioned later.  The methods to override and reabsorb are listed by the sub \fBoverridableMethods\fR in the last package in the packages list. Confess to any errors.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @packages  List of packages
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok overrideAndReabsorbMethods(qw(main Edit::Xml Data::Edit::Xml));              # XXXXXXX
.Ve
.PP
This is a static method and so should either be imported or invoked as:
.PP
.Vb 1
\&  Data::Table::Text::overrideAndReabsorbMethods
.Ve
.ie n .SS "assertPackageRefs($package, @refs)"
.el .SS "assertPackageRefs($package, \f(CW@refs\fP)"
.IX Subsection "assertPackageRefs($package, @refs)"
Confirm that the specified references are to the specified package
.PP
.Vb 3
\&     Parameter  Description
\&  1  $package   Package
\&  2  @refs      References
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    eval q{assertPackageRefs(q(bbb), bless {}, q(aaa))};  # XXXXXXX
\&
\&    ok $@ =~ m(\eAWanted reference to bbb, but got aaa);
.Ve
.SS "assertRef(@refs)"
.IX Subsection "assertRef(@refs)"
Confirm that the specified references are to the package into which this routine has been exported.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @refs      References
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    eval q{assertRef(bless {}, q(aaa))};  # XXXXXXX
\&
\&    ok $@ =~ m(\eAWanted reference to Data::Table::Text, but got aaa);
.Ve
.SS "arrayToHash(@array)"
.IX Subsection "arrayToHash(@array)"
Create a hash reference from an array
.PP
.Vb 2
\&     Parameter  Description
\&  1  @array     Array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply arrayToHash(qw(a b c)), {a=>1, b=>1, c=>1};                             # XXXXXXX
.Ve
.SS "flattenArrayAndHashValues(@array)"
.IX Subsection "flattenArrayAndHashValues(@array)"
Flatten an array of scalars, array and hash references to make an array of scalars by flattening the array references and hash values.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @array     Array to flatten
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [1..5], [flattenArrayAndHashValues([1], [[2]], {a=>3, b=>[4, [5]]})], \*(Aqggg\*(Aq;   # XXXXXXX
.Ve
.SS "getSubName($sub)"
.IX Subsection "getSubName($sub)"
Returns the (package, name, file, line) of a perl \fB\f(CB$sub\fB\fR reference.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $sub       Reference to a sub with a name.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  is_deeply [(getSubName(\e&dateTime))[0,1]], ["Data::Table::Text", "dateTime"];     # XXXXXXX
.Ve
.SH "Strings"
.IX Header "Strings"
Actions on strings.
.SS "stringMd5Sum($string)"
.IX Subsection "stringMd5Sum($string)"
Get the Md5 sum of a \fB\f(CB$string\fB\fR that might contain utf8 <https://en.wikipedia.org/wiki/UTF-8> code points.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $s = join \*(Aq\*(Aq, 1..100;
\&    my $m = q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&
\&    ok stringMd5Sum($s) eq $m;  # XXXXXXX
\&
\&
\&    my $f = writeFile(undef, $s);
\&    ok fileMd5Sum($f) eq $m;
\&    unlink $f;
\&
\&    ok guidFromString(join \*(Aq\*(Aq, 1..100) eq
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&
\&    ok guidFromMd5(stringMd5Sum(join(\*(Aq\*(Aq, 1..100))) eq  # XXXXXXX
\&
\&       q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de);
\&
\&    ok md5FromGuid(q(GUID\-ef69caaa\-eea9\-c171\-2082\-1a9eb6c7f1de)) eq
\&                        q(ef69caaaeea9c17120821a9eb6c7f1de);
\&
\&
\&    ok stringMd5Sum(q(X X X)) eq q(3c2b7c31b1011998bd7e1f66fb7c024d);  # XXXXXXX
\&
\&  }
\&
\&  if (1)
\&   {ok arraySum   (1..10) ==  55;
\&    ok arrayProduct(1..5) == 120;
\&    is_deeply[arrayTimes(2, 1..5)], [qw(2 4 6 8 10)];
.Ve
.ie n .SS "indentString($string, $indent)"
.el .SS "indentString($string, \f(CW$indent\fP)"
.IX Subsection "indentString($string, $indent)"
Indent lines contained in a string or formatted table by the specified string.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    The string of lines to indent
\&  2  $indent    The indenting string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $t = [qw(aa bb cc)];
\&    my $d = [[qw(A B C)], [qw(AA BB CC)], [qw(AAA BBB CCC)],  [qw(1 22 333)]];
\&
\&    my $s = indentString(formatTable($d), \*(Aq  \*(Aq)."
\&";  # XXXXXXX
\&
\&
\&    ok $s eq <<END;
\&    1  A    B    C
\&    2  AA   BB   CC
\&    3  AAA  BBB  CCC
\&    4    1   22  333
\&  END
.Ve
.ie n .SS "replaceStringWithString($string, $source, $target)"
.el .SS "replaceStringWithString($string, \f(CW$source\fP, \f(CW$target\fP)"
.IX Subsection "replaceStringWithString($string, $source, $target)"
Replace all instances in \fB\f(CB$string\fB\fR of \fB\f(CB$source\fB\fR with \fB\f(CB$target\fB\fR
.PP
.Vb 4
\&     Parameter  Description
\&  1  $string    String in which to replace substrings
\&  2  $source    The string to be replaced
\&  3  $target    The replacement string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok replaceStringWithString(q(abababZ), q(ab), q(c)) eq q(cccZ), \*(Aqeee\*(Aq;            # XXXXXXX
.Ve
.ie n .SS "formatString($string, $width)"
.el .SS "formatString($string, \f(CW$width\fP)"
.IX Subsection "formatString($string, $width)"
Format the specified \fB\f(CB$string\fB\fR so it can be displayed in \fB\f(CB$width\fB\fR columns.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    The string of text to format
\&  2  $width     The formatted width.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok formatString(<<END, 16) eq  <<END, \*(Aqfff\*(Aq;                                      # XXXXXXX
\&
\&  Now is the time for all
\&  good men to come to the rescue
\&  of the ailing B<party>.
\&  END
.Ve
.SS "isBlank($string)"
.IX Subsection "isBlank($string)"
Test whether a string is blank.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok isBlank("");                                                                   # XXXXXXX
\&
\&
\&
\&  ok isBlank("
\& ");                                                               # XXXXXXX
.Ve
.SS "trim($string)"
.IX Subsection "trim($string)"
Remove any white space from the front and end of a string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok trim(" a b ") eq join \*(Aq \*(Aq, qw(a b);                                            # XXXXXXX
.Ve
.ie n .SS "pad($string, $length, $padding)"
.el .SS "pad($string, \f(CW$length\fP, \f(CW$padding\fP)"
.IX Subsection "pad($string, $length, $padding)"
Pad the specified \fB\f(CB$string\fB\fR to a multiple of the specified \fB\f(CB$length\fB\fR  with blanks or the specified padding character to a multiple of a specified length.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $string    String
\&  2  $length    Tab width
\&  3  $padding   Padding string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok  pad(\*(Aqabc  \*(Aq, 2).\*(Aq=\*(Aq       eq "abc =";                                         # XXXXXXX
\&
\&
\&
\&  ok  pad(\*(Aqabc  \*(Aq, 3).\*(Aq=\*(Aq       eq "abc=";                                          # XXXXXXX
\&
\&
\&
\&  ok  pad(\*(Aqabc  \*(Aq, 4, q(.)).\*(Aq=\*(Aq eq "abc.=";                                         # XXXXXXX
.Ve
.ie n .SS "firstNChars($string, $length)"
.el .SS "firstNChars($string, \f(CW$length\fP)"
.IX Subsection "firstNChars($string, $length)"
First N characters of a string.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    String
\&  2  $length    Length
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok firstNChars(q(abc), 2) eq q(ab);                                               # XXXXXXX
\&
\&
\&
\&  ok firstNChars(q(abc), 4) eq q(abc);                                              # XXXXXXX
.Ve
.ie n .SS "nws($string, $length)"
.el .SS "nws($string, \f(CW$length\fP)"
.IX Subsection "nws($string, $length)"
Normalize white space in a string to make comparisons easier. Leading and trailing white space is removed; blocks of white space in the interior are reduced to a single space.  In effect: this puts everything on one long line with never more than one space at a time. Optionally a maximum length is applied to the normalized string.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $string    String to normalize
\&  2  $length    Maximum length of result
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok nws(qq(a  b    c)) eq q(a b c);                                                # XXXXXXX
.Ve
.SS "deduplicateSequentialWordsInString($s)"
.IX Subsection "deduplicateSequentialWordsInString($s)"
Remove sequentially duplicate words in a string
.PP
.Vb 2
\&     Parameter  Description
\&  1  $s         String to deduplicate
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok deduplicateSequentialWordsInString(<<END) eq qq(\e(aa \e[bb \e\-cc dd ee
\&);  # XXXXXXX
\&
\&  (aa [bb bb \-cc cc dd dd dd dd ee ee ee ee
\&  END
.Ve
.SS "detagString($string)"
.IX Subsection "detagString($string)"
Remove \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML> or Xml <https://en.wikipedia.org/wiki/XML> tags from a string
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to detag
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok detagString(q(<a><a href="aaaa">a </a><a/>b </a>c)) eq q(a b c), \*(Aqhhh\*(Aq;        # XXXXXXX
.Ve
.SS "parseIntoWordsAndStrings($string)"
.IX Subsection "parseIntoWordsAndStrings($string)"
Parse a \fB\f(CB$string\fB\fR into words and quoted strings. A quote following a space introduces a string, else a quote is just part of the containing word.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to parse
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {is_deeply
\&
\&     [parseIntoWordsAndStrings(  # XXXXXXX
\&
\&  q( aa12!    a\*(Aqb   "aa !! ++ bb"  \*(Aq  \*(Aq,      \*(Aq"\*(Aq  "\*(Aq"  ""   \*(Aq\*(Aq.))  ],
\&   ["aa12!", "a\*(Aqb", "aa !! ++ bb", "  ", ",", \*(Aq"\*(Aq, "\*(Aq", "",  "", \*(Aq.\*(Aq];
\&   }
.Ve
.ie n .SS "stringsAreNotEqual($a, $b)"
.el .SS "stringsAreNotEqual($a, \f(CW$b\fP)"
.IX Subsection "stringsAreNotEqual($a, $b)"
Return the common start followed by the two non equal tails of two non equal strings or an empty list if the strings are equal.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $a         First string
\&  2  $b         Second string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok        !stringsAreNotEqual(q(abc), q(abc));  # XXXXXXX
\&
\&
\&    ok         stringsAreNotEqual(q(abc), q(abd));  # XXXXXXX
\&
\&
\&    is_deeply [stringsAreNotEqual(q(abc), q(abd))], [qw(ab c d)];  # XXXXXXX
\&
\&
\&    is_deeply [stringsAreNotEqual(q(ab),  q(abd))], [q(ab), \*(Aq\*(Aq, q(d)];  # XXXXXXX
.Ve
.SS "printQw(@words)"
.IX Subsection "printQw(@words)"
Print an array of words in \fBqw()\fR format.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @words     Array of words
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok printQw(qw(a b c)) eq q(qw(a b c));                                            # XXXXXXX
.Ve
.SS "numberOfLinesInString($string)"
.IX Subsection "numberOfLinesInString($string)"
The number of lines in a string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    ok numberOfLinesInString("a
\&b
\&") == 2;                                        # XXXXXXX
.Ve
.SS "javaPackage($java)"
.IX Subsection "javaPackage($java)"
Extract the package name from a java string or file.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $java      Java file if it exists else the string of java
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $j = writeFile(undef, <<END);
\&  // Test
\&  package com.xyz;
\&  END
\&
\&    ok javaPackage($j)           eq "com.xyz";  # XXXXXXX
\&
\&    ok javaPackageAsFileName($j) eq "com/xyz";
\&    unlink $j;
\&
\&    my $p = writeFile(undef, <<END);
\&  package a::b;
\&  END
\&    ok perlPackage($p)           eq "a::b";
\&    unlink $p;
.Ve
.SS "javaPackageAsFileName($java)"
.IX Subsection "javaPackageAsFileName($java)"
Extract the package name from a java string or file and convert it to a file name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $java      Java file if it exists else the string of java
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $j = writeFile(undef, <<END);
\&  // Test
\&  package com.xyz;
\&  END
\&    ok javaPackage($j)           eq "com.xyz";
\&
\&    ok javaPackageAsFileName($j) eq "com/xyz";  # XXXXXXX
\&
\&    unlink $j;
\&
\&    my $p = writeFile(undef, <<END);
\&  package a::b;
\&  END
\&    ok perlPackage($p)           eq "a::b";
\&    unlink $p;
.Ve
.SS "perlPackage($perl)"
.IX Subsection "perlPackage($perl)"
Extract the package name from a perl string or file.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $perl      Perl file if it exists else the string of perl
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $j = writeFile(undef, <<END);
\&  // Test
\&  package com.xyz;
\&  END
\&    ok javaPackage($j)           eq "com.xyz";
\&    ok javaPackageAsFileName($j) eq "com/xyz";
\&    unlink $j;
\&
\&    my $p = writeFile(undef, <<END);
\&  package a::b;
\&  END
\&
\&    ok perlPackage($p)           eq "a::b";                                         # XXXXXXX
\&
\&    unlink $p;
\&
\&    my $p = writeFile(undef, <<END);
\&  package a::b;
\&  END
\&
\&
\&    ok perlPackage($p)           eq "a::b";                                         # XXXXXXX
.Ve
.SS "javaScriptExports($fileOrString)"
.IX Subsection "javaScriptExports($fileOrString)"
Extract the Javascript functions marked for export in a file or string.  Functions are marked for export by placing function in column 1 followed by //E on the same line.  The end of the exported function is located by
 }
.PP
.Vb 2
\&     Parameter      Description
\&  1  $fileOrString  File or string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok javaScriptExports(<<END) eq <<END;  # XXXXXXX
\&
\&  function aaa()            //E
\&   {console.log(\*(Aqaaa\*(Aq);
.Ve
.SS "chooseStringAtRandom(@strings)"
.IX Subsection "chooseStringAtRandom(@strings)"
Choose a string at random from the list of \fB\f(CB@strings\fB\fR supplied.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @strings   Strings to chose from
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok q(a) eq chooseStringAtRandom(qw(a a a a));                                     # XXXXXXX
.Ve
.SH "Arrays of Arrays"
.IX Header "Arrays of Arrays"
Operations on arrays of arrays
.SS "lengthOfLongestSubArray($a)"
.IX Subsection "lengthOfLongestSubArray($a)"
Given an array of arrays find the length of the longest sub array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $a         Array reference
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {ok 3 == lengthOfLongestSubArray [[1..2], [1..3], [1..3], []];  # XXXXXXX
\&
\&   }
.Ve
.ie n .SS "cmpArrays($a, $b)"
.el .SS "cmpArrays($a, \f(CW$b\fP)"
.IX Subsection "cmpArrays($a, $b)"
Apply \fBcmp()\fR to two arrays of strings
.PP
.Vb 3
\&     Parameter  Description
\&  1  $a         Array A
\&  2  $b         Array B
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok cmpArrays([qw(a b)],   [qw(a a)])   == +1;  # XXXXXXX
\&
\&
\&    ok cmpArrays([qw(a b)],   [qw(a c)])   == \-1;  # XXXXXXX
\&
\&
\&    ok cmpArrays([qw(a b)],   [qw(a b a)]) == \-1;  # XXXXXXX
\&
\&
\&    ok cmpArrays([qw(a b a)], [qw(a b)])   == +1;  # XXXXXXX
\&
\&
\&    ok cmpArrays([qw(a b)],   [qw(a b)])   ==  0;  # XXXXXXX
.Ve
.SH "Unicode"
.IX Header "Unicode"
Translate Ascii <https://en.wikipedia.org/wiki/ASCII> alphanumerics in strings to various Unicode <https://en.wikipedia.org/wiki/Unicode> blocks.
.SS "mathematicalBoldString($string)"
.IX Subsection "mathematicalBoldString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalBoldString                   (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);    # XXXXXXX
.Ve
.SS "mathematicalBoldStringUndo($string)"
.IX Subsection "mathematicalBoldStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold..
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalBoldStringUndo               (q(XXXXXX XXX XXXXXXX)) eq q(APPLES and ORANGES);    # XXXXXXX
.Ve
.SS "mathematicalBoldItalicString($string)"
.IX Subsection "mathematicalBoldItalicString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalBoldItalicString             (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);     # XXXXXXX
.Ve
.SS "mathematicalBoldItalicStringUndo($string)"
.IX Subsection "mathematicalBoldItalicStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalBoldItalicStringUndo         (q(XXXXXX XXX XXXXXXX))  eq q(APPLES and ORANGES);    # XXXXXXX
.Ve
.SS "mathematicalSansSerifString($string)"
.IX Subsection "mathematicalSansSerifString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifString              (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);     # XXXXXXX
.Ve
.SS "mathematicalSansSerifStringUndo($string)"
.IX Subsection "mathematicalSansSerifStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifStringUndo          (q(XXXXXX XXX XXXXXXX))  eq q(APPLES and ORANGES);    # XXXXXXX
.Ve
.SS "mathematicalSansSerifBoldString($string)"
.IX Subsection "mathematicalSansSerifBoldString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifBoldString          (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);     # XXXXXXX
.Ve
.SS "mathematicalSansSerifBoldStringUndo($string)"
.IX Subsection "mathematicalSansSerifBoldStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifBoldStringUndo      (q(XXXXXX XXX XXXXXXX)) eq q(APPLES and ORANGES);     # XXXXXXX
.Ve
.SS "mathematicalSansSerifItalicString($string)"
.IX Subsection "mathematicalSansSerifItalicString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifItalicString        (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);      # XXXXXXX
.Ve
.SS "mathematicalSansSerifItalicStringUndo($string)"
.IX Subsection "mathematicalSansSerifItalicStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifItalicStringUndo    (q(XXXXXX XXX XXXXXXX)) eq q(APPLES and ORANGES);      # XXXXXXX
.Ve
.SS "mathematicalSansSerifBoldItalicString($string)"
.IX Subsection "mathematicalSansSerifBoldItalicString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifBoldItalicString    (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);     # XXXXXXX
.Ve
.SS "mathematicalSansSerifBoldItalicStringUndo($string)"
.IX Subsection "mathematicalSansSerifBoldItalicStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold Italic.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalSansSerifBoldItalicStringUndo(q(XXXXXX XXX XXXXXXX)) eq q(APPLES and ORANGES);     # XXXXXXX
.Ve
.SS "mathematicalMonoSpaceString($string)"
.IX Subsection "mathematicalMonoSpaceString($string)"
Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical MonoSpace.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalMonoSpaceString              (q(APPLES and ORANGES)) eq q(XXXXXX XXX XXXXXXX);    # XXXXXXX
.Ve
.SS "mathematicalMonoSpaceStringUndo($string)"
.IX Subsection "mathematicalMonoSpaceStringUndo($string)"
Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical MonoSpace.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok mathematicalMonoSpaceStringUndo          (q(XXXXXX XXX XXXXXXX)) eq q(APPLES and ORANGES);    # XXXXXXX
.Ve
.SS "boldString($string)"
.IX Subsection "boldString($string)"
Convert alphanumerics in a string to bold.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok boldString(q(zZ)) eq q(XX);                                                    # XXXXXXX
.Ve
.SS "boldStringUndo($string)"
.IX Subsection "boldStringUndo($string)"
Undo alphanumerics in a string to bold.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&  if (1)
\&   {my $n = 1234567890;
\&
\&    ok boldStringUndo            (boldString($n))             == $n;  # XXXXXXX
\&
\&    ok enclosedStringUndo        (enclosedString($n))         == $n;
\&    ok enclosedReversedStringUndo(enclosedReversedString($n)) == $n;
\&    ok superScriptStringUndo     (superScriptString($n))      == $n;
\&    ok subScriptStringUndo       (subScriptString($n))        == $n;
\&   }
.Ve
.SS "enclosedString($string)"
.IX Subsection "enclosedString($string)"
Convert alphanumerics in a string to enclosed alphanumerics.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok enclosedString(q(hello world 1234)) eq q(XXXXX XXXXX XXXX);           # XXXXXXX
.Ve
.SS "enclosedStringUndo($string)"
.IX Subsection "enclosedStringUndo($string)"
Undo alphanumerics in a string to enclosed alphanumerics.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&  if (1)
\&   {my $n = 1234567890;
\&    ok boldStringUndo            (boldString($n))             == $n;
\&
\&    ok enclosedStringUndo        (enclosedString($n))         == $n;  # XXXXXXX
\&
\&    ok enclosedReversedStringUndo(enclosedReversedString($n)) == $n;
\&    ok superScriptStringUndo     (superScriptString($n))      == $n;
\&    ok subScriptStringUndo       (subScriptString($n))        == $n;
\&   }
.Ve
.SS "enclosedReversedString($string)"
.IX Subsection "enclosedReversedString($string)"
Convert alphanumerics in a string to enclosed reversed alphanumerics.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok enclosedReversedString(q(hello world 1234)) eq q(XXXXX XXXXX XXXX);   # XXXXXXX
.Ve
.SS "enclosedReversedStringUndo($string)"
.IX Subsection "enclosedReversedStringUndo($string)"
Undo alphanumerics in a string to enclosed reversed alphanumerics.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (1)
\&   {my $n = 1234567890;
\&    ok boldStringUndo            (boldString($n))             == $n;
\&    ok enclosedStringUndo        (enclosedString($n))         == $n;
\&
\&    ok enclosedReversedStringUndo(enclosedReversedString($n)) == $n;  # XXXXXXX
\&
\&    ok superScriptStringUndo     (superScriptString($n))      == $n;
\&    ok subScriptStringUndo       (subScriptString($n))        == $n;
\&   }
.Ve
.SS "superScriptString($string)"
.IX Subsection "superScriptString($string)"
Convert alphanumerics in a string to super scripts
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok superScriptString(1234567890) eq q(XXXXXXXXXX);                                # XXXXXXX
.Ve
.SS "superScriptStringUndo($string)"
.IX Subsection "superScriptStringUndo($string)"
Undo alphanumerics in a string to super scripts
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&  if (1)
\&   {my $n = 1234567890;
\&    ok boldStringUndo            (boldString($n))             == $n;
\&    ok enclosedStringUndo        (enclosedString($n))         == $n;
\&    ok enclosedReversedStringUndo(enclosedReversedString($n)) == $n;
\&
\&    ok superScriptStringUndo     (superScriptString($n))      == $n;  # XXXXXXX
\&
\&    ok subScriptStringUndo       (subScriptString($n))        == $n;
\&   }
.Ve
.SS "subScriptString($string)"
.IX Subsection "subScriptString($string)"
Convert alphanumerics in a string to sub scripts
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok subScriptString(1234567890)   eq q(XXXXXXXXXX);                                # XXXXXXX
.Ve
.SS "subScriptStringUndo($string)"
.IX Subsection "subScriptStringUndo($string)"
Undo alphanumerics in a string to sub scripts
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String to convert
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  if (1)
\&   {my $n = 1234567890;
\&    ok boldStringUndo            (boldString($n))             == $n;
\&    ok enclosedStringUndo        (enclosedString($n))         == $n;
\&    ok enclosedReversedStringUndo(enclosedReversedString($n)) == $n;
\&    ok superScriptStringUndo     (superScriptString($n))      == $n;
\&
\&    ok subScriptStringUndo       (subScriptString($n))        == $n;  # XXXXXXX
\&
\&   }
.Ve
.SS "isFileUtf8($file)"
.IX Subsection "isFileUtf8($file)"
Return the file name quoted if its contents are in utf8 else return undef
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File to test
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $f = writeFile(undef, "aaa");
\&
\&    ok isFileUtf8 $f;  # XXXXXXX
.Ve
.SH "Unix domain communications"
.IX Header "Unix domain communications"
Send messages between processes via a unix domain socket.
.SS "newUdsrServer(@parms)"
.IX Subsection "newUdsrServer(@parms)"
Create a communications server \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @parms     Attributes per L<Udsr Definition|/Udsr Definition>
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $N = 20;
\&
\&    my $s = newUdsrServer(serverAction=>sub  # XXXXXXX
\&
\&     {my ($u) = @_;
\&      my $r = $u\->read;
\&      $u\->write(qq(Hello from server $r));
\&     });
\&
\&    my $p = newProcessStarter(min(100, $N));                                      # Run some clients
\&    for my $i(1..$N)
\&     {$p\->start(sub
\&       {my $count = 0;
\&        for my $j(1..$N)
\&         {my $c = newUdsrClient;
\&          my $m = qq(Hello from client $i x $j);
\&          $c\->write($m);
\&          my $r = $c\->read;
\&          ++$count if $r eq qq(Hello from server $m);
\&         }
\&        [$count]
\&       });
\&     }
\&
\&    my $count;
\&    for my $r($p\->finish)                                                         # Consolidate results
\&     {my ($c) = @$r;
\&      $count += $c;
\&     }
\&
\&    ok $count == $N*$N;                                                           # Check results and kill
\&    $s\->kill;
.Ve
.SS "newUdsrClient(@parms)"
.IX Subsection "newUdsrClient(@parms)"
Create a new communications client \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @parms     Attributes per L<Udsr Definition|/Udsr Definition>
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    my $N = 20;
\&    my $s = newUdsrServer(serverAction=>sub
\&     {my ($u) = @_;
\&      my $r = $u\->read;
\&      $u\->write(qq(Hello from server $r));
\&     });
\&
\&    my $p = newProcessStarter(min(100, $N));                                      # Run some clients
\&    for my $i(1..$N)
\&     {$p\->start(sub
\&       {my $count = 0;
\&        for my $j(1..$N)
\&
\&         {my $c = newUdsrClient;  # XXXXXXX
\&
\&          my $m = qq(Hello from client $i x $j);
\&          $c\->write($m);
\&          my $r = $c\->read;
\&          ++$count if $r eq qq(Hello from server $m);
\&         }
\&        [$count]
\&       });
\&     }
\&
\&    my $count;
\&    for my $r($p\->finish)                                                         # Consolidate results
\&     {my ($c) = @$r;
\&      $count += $c;
\&     }
\&
\&    ok $count == $N*$N;                                                           # Check results and kill
\&    $s\->kill;
.Ve
.ie n .SS "Udsr::write($u, $msg)"
.el .SS "Udsr::write($u, \f(CW$msg\fP)"
.IX Subsection "Udsr::write($u, $msg)"
Write a communications message to the newUdsrServer or the newUdsrClient.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $u         Communicator
\&  2  $msg       Message
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    my $N = 20;
\&    my $s = newUdsrServer(serverAction=>sub
\&     {my ($u) = @_;
\&      my $r = $u\->read;
\&      $u\->write(qq(Hello from server $r));
\&     });
\&
\&    my $p = newProcessStarter(min(100, $N));                                      # Run some clients
\&    for my $i(1..$N)
\&     {$p\->start(sub
\&       {my $count = 0;
\&        for my $j(1..$N)
\&         {my $c = newUdsrClient;
\&          my $m = qq(Hello from client $i x $j);
\&          $c\->write($m);
\&          my $r = $c\->read;
\&          ++$count if $r eq qq(Hello from server $m);
\&         }
\&        [$count]
\&       });
\&     }
\&
\&    my $count;
\&    for my $r($p\->finish)                                                         # Consolidate results
\&     {my ($c) = @$r;
\&      $count += $c;
\&     }
\&
\&    ok $count == $N*$N;                                                           # Check results and kill
\&    $s\->kill;
.Ve
.SS "Udsr::read($u)"
.IX Subsection "Udsr::read($u)"
Read a message from the newUdsrServer or the newUdsrClient.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $u         Communicator
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    my $N = 20;
\&    my $s = newUdsrServer(serverAction=>sub
\&     {my ($u) = @_;
\&      my $r = $u\->read;
\&      $u\->write(qq(Hello from server $r));
\&     });
\&
\&    my $p = newProcessStarter(min(100, $N));                                      # Run some clients
\&    for my $i(1..$N)
\&     {$p\->start(sub
\&       {my $count = 0;
\&        for my $j(1..$N)
\&         {my $c = newUdsrClient;
\&          my $m = qq(Hello from client $i x $j);
\&          $c\->write($m);
\&          my $r = $c\->read;
\&          ++$count if $r eq qq(Hello from server $m);
\&         }
\&        [$count]
\&       });
\&     }
\&
\&    my $count;
\&    for my $r($p\->finish)                                                         # Consolidate results
\&     {my ($c) = @$r;
\&      $count += $c;
\&     }
\&
\&    ok $count == $N*$N;                                                           # Check results and kill
\&    $s\->kill;
.Ve
.SS "Udsr::kill($u)"
.IX Subsection "Udsr::kill($u)"
Kill a communications server.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $u         Communicator
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    my $N = 20;
\&    my $s = newUdsrServer(serverAction=>sub
\&     {my ($u) = @_;
\&      my $r = $u\->read;
\&      $u\->write(qq(Hello from server $r));
\&     });
\&
\&    my $p = newProcessStarter(min(100, $N));                                      # Run some clients
\&    for my $i(1..$N)
\&     {$p\->start(sub
\&       {my $count = 0;
\&        for my $j(1..$N)
\&         {my $c = newUdsrClient;
\&          my $m = qq(Hello from client $i x $j);
\&          $c\->write($m);
\&          my $r = $c\->read;
\&          ++$count if $r eq qq(Hello from server $m);
\&         }
\&        [$count]
\&       });
\&     }
\&
\&    my $count;
\&    for my $r($p\->finish)                                                         # Consolidate results
\&     {my ($c) = @$r;
\&      $count += $c;
\&     }
\&
\&    ok $count == $N*$N;                                                           # Check results and kill
\&    $s\->kill;
.Ve
.ie n .SS "Udsr::webUser($u, $folder)"
.el .SS "Udsr::webUser($u, \f(CW$folder\fP)"
.IX Subsection "Udsr::webUser($u, $folder)"
Create a systemd installed server that processes http requests using a specified userid. The systemd and \s-1CGI\s0 files plus an installation script are written to the specified folder after it has been cleared. The serverAction attribute contains the code to be executed by the server: it should contain a sub <https://perldoc.perl.org/perlsub.html> \fBgenResponse($hash)\fR which will be called with a hash of the \s-1CGI\s0 variables. This sub <https://perldoc.perl.org/perlsub.html> should return the response to be sent back to the client. Returns the installation script file name.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $u         Communicator
\&  2  $folder    Folder to contain server code
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (0)
\&   {my $fold = fpd(qw(/home phil zzz));                                           # Folder to contain server code
\&    my $name = q(test);                                                           # Service
\&    my $user = q(phil);                                                           # User
\&
\&    my $udsr = newUdsr                                                            # Create a Udsr parameter list
\&     (serviceName => $name,
\&      serviceUser => $user,
\&      socketPath  => qq(/home/phil/$name.socket),
\&      serverAction=> <<\*(AqEND\*(Aq
\&  my $user = userId;
\&  my $list = qx(ls \-l);
\&  my $dtts = dateTimeStamp;
\&  return <<END2;
\&  Content\-type: text/html
\&
\&  <h1>Hello World to you $user on $dtts!</h1>
\&
\&  <pre>
\&  $list
\&  </pre>
\&  END2
\&  END
\&     );
\&
\&
\&    Udsr::webUser($udsr, $fold);                                                  # Create and install web service interface  # XXXXXXX
\&
\&    my $ip = awsIp;
\&    say STDERR qx(curl http://$ip/cgi\-bin/$name/client.pl);                       # Enable port 80 on AWS first
\&   }
.Ve
.SS "www"
.IX Subsection "www"
Web processing
.PP
\fIwwwGitHubAuth($saveUserDetails, \f(CI$clientId\fI, \f(CI$clientSecret\fI, \f(CI$code\fI, \f(CI$state\fI)\fR
.IX Subsection "wwwGitHubAuth($saveUserDetails, $clientId, $clientSecret, $code, $state)"
.PP
Logon as a GitHub <https://github.com> oauth <https://en.wikipedia.org/wiki/OAuth> app per: <https://github.com/settings/developers>. If no oauth <https://en.wikipedia.org/wiki/OAuth> code is supplied then a web page is printed that allows the user to request that such a code be sent to the server.  If a valid code is received, by the server then it is converted to a oauth <https://en.wikipedia.org/wiki/OAuth> token which is handed to sub <https://perldoc.perl.org/perlsub.html> saveUserDetails.
.PP
.Vb 6
\&     Parameter         Description
\&  1  $saveUserDetails  Process user token once obtained from GitHub
\&  2  $clientId         Client id
\&  3  $clientSecret     Client secret
\&  4  $code             OAuth code
\&  5  $state            Random string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    wwwHeader;
\&
\&
\&    wwwGitHubAuth  # XXXXXXX
\&
\&     {my ($user, $state, $token, $scope, $type) = @_;
\&     }
\&    q(12345678901234567890), q(1234567890123456789012345678901234567890),
\&    q(12345678901234567890123456789012), q(12345678901234567890);
.Ve
.SH "Cloud Cover"
.IX Header "Cloud Cover"
Useful for operating across the cloud.
.SS "\fBmakeDieConfess()\fP"
.IX Subsection "makeDieConfess()"
Force die to confess where the death occurred
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    makeDieConfess                                                                  # XXXXXXX
.Ve
.SS "\fBawsIp()\fP"
.IX Subsection "awsIp()"
Get ip address of server at Amazon Web Services <http://aws.amazon.com>.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok saveAwsIp(q(0.0.0.0)) eq awsIp;  # XXXXXXX
.Ve
.SS "\fBsaveAwsIp()\fP"
.IX Subsection "saveAwsIp()"
Make the server at Amazon Web Services <http://aws.amazon.com> with the given \s-1IP\s0 address the default primary server as used by all the methods whose names end in \fBr\fR or \fBRemote\fR. Returns the given \s-1IP\s0 address.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok saveAwsIp(q(0.0.0.0)) eq awsIp;  # XXXXXXX
.Ve
.SS "awsMetaData($item)"
.IX Subsection "awsMetaData($item)"
Get an item of meta data for the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $item      Meta data field
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsMetaData(q(instance\-id))    eq q(i\-06a4b221b30bf7a37);                    # XXXXXXX
.Ve
.SS "\fBawsCurrentIp()\fP"
.IX Subsection "awsCurrentIp()"
Get the ip address of the \s-1AWS\s0 server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    awsCurrentIp;  # XXXXXXX
\&
\&    confirmHasCommandLineCommand(q(find));
\&
\&
\&    ok awsCurrentIp                   eq q(31.41.59.26);                            # XXXXXXX
.Ve
.SS "\fBawsCurrentInstanceId()\fP"
.IX Subsection "awsCurrentInstanceId()"
Get the instance id of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsCurrentInstanceId           eq q(i\-06a4b221b30bf7a37);                    # XXXXXXX
.Ve
.SS "\fBawsCurrentAvailabilityZone()\fP"
.IX Subsection "awsCurrentAvailabilityZone()"
Get the availability zone of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsCurrentAvailabilityZone     eq q(us\-east\-2a);                             # XXXXXXX
.Ve
.SS "\fBawsCurrentRegion()\fP"
.IX Subsection "awsCurrentRegion()"
Get the region of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsCurrentRegion               eq q(us\-east\-2);                              # XXXXXXX
.Ve
.SS "\fBawsCurrentInstanceType()\fP"
.IX Subsection "awsCurrentInstanceType()"
Get the instance type of the Amazon Web Services <http://aws.amazon.com> server if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsCurrentInstanceType         eq q(r4.4xlarge);                             # XXXXXXX
.Ve
.ie n .SS "awsExecCli($command, %options)"
.el .SS "awsExecCli($command, \f(CW%options\fP)"
.IX Subsection "awsExecCli($command, %options)"
Execute an AWs command and return its response
.PP
.Vb 3
\&     Parameter  Description
\&  1  $command   Command to execute
\&  2  %options   Aws cli options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsExecCli(q(aws s3 ls)) =~ m(ryffine)i;  # XXXXXXX
\&
\&    my $p = awsExecCliJson(q(aws ec2 describe\-vpcs), region=>q(us\-east\-1));
\&    ok $p\->Vpcs\->[0]\->VpcId =~ m(\eAvpc\-)i;
.Ve
.ie n .SS "awsExecCliJson($command, %options)"
.el .SS "awsExecCliJson($command, \f(CW%options\fP)"
.IX Subsection "awsExecCliJson($command, %options)"
Execute an AWs command and decode the json so produced
.PP
.Vb 3
\&     Parameter  Description
\&  1  $command   Command to execute
\&  2  %options   Aws cli options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsExecCli(q(aws s3 ls)) =~ m(ryffine)i;
\&
\&    my $p = awsExecCliJson(q(aws ec2 describe\-vpcs), region=>q(us\-east\-1));  # XXXXXXX
\&
\&    ok $p\->Vpcs\->[0]\->VpcId =~ m(\eAvpc\-)i;
.Ve
.SS "awsEc2DescribeInstances(%options)"
.IX Subsection "awsEc2DescribeInstances(%options)"
Describe the Amazon Web Services <http://aws.amazon.com> instances running in a \fB\f(CB$region\fB\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (region => q(us\-east\-2), profile=>q(fmc));
\&
\&    my $r = awsEc2DescribeInstances              (%options);  # XXXXXXX
\&
\&    my %i = awsEc2DescribeInstancesGetIPAddresses(%options);
\&    is_deeply \e%i, { "i\-068a7176ba9140057" => { "18.221.162.39" => 1 } };
.Ve
.SS "awsEc2DescribeInstancesGetIPAddresses(%options)"
.IX Subsection "awsEc2DescribeInstancesGetIPAddresses(%options)"
Return a hash of {instanceId => public ip address} for all running instances on Amazon Web Services <http://aws.amazon.com> with ip addresses.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my %options = (region => q(us\-east\-2), profile=>q(fmc));
\&    my $r = awsEc2DescribeInstances              (%options);
\&
\&    my %i = awsEc2DescribeInstancesGetIPAddresses(%options);  # XXXXXXX
\&
\&    is_deeply \e%i, { "i\-068a7176ba9140057" => { "18.221.162.39" => 1 } };
.Ve
.ie n .SS "awsEc2InstanceIpAddress($instanceId, %options)"
.el .SS "awsEc2InstanceIpAddress($instanceId, \f(CW%options\fP)"
.IX Subsection "awsEc2InstanceIpAddress($instanceId, %options)"
Return the \s-1IP\s0 address of a named instance on Amazon Web Services <http://aws.amazon.com> else return \fBundef\fR.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $instanceId  Instance id
\&  2  %options     Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok q(3.33.133.233) eq awsEc2InstanceIpAddress  # XXXXXXX
\&
\&      ("i\-xxx", region => q(us\-east\-2), profile=>q(fmc));
.Ve
.ie n .SS "awsEc2CreateImage($name, %options)"
.el .SS "awsEc2CreateImage($name, \f(CW%options\fP)"
.IX Subsection "awsEc2CreateImage($name, %options)"
Create an image snap shot with the specified \fB\f(CB$name\fB\fR of the \s-1AWS\s0 server we are currently running on if we are running on an \s-1AWS\s0 server else return false. It is safe to shut down the instance immediately after initiating the snap shot \- the snap continues even though the instance has terminated.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $name      Image name
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&       awsEc2CreateImage(q(099 Gold));                                              # XXXXXXX
.Ve
.ie n .SS "awsEc2FindImagesWithTagValue($value, %options)"
.el .SS "awsEc2FindImagesWithTagValue($value, \f(CW%options\fP)"
.IX Subsection "awsEc2FindImagesWithTagValue($value, %options)"
Find images with a tag that matches the specified regular expression \fB\f(CB$value\fB\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $value     Regular expression
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply
\&
\&     [awsEc2FindImagesWithTagValue(qr(boot)i, region=>\*(Aqus\-east\-2\*(Aq,  # XXXXXXX
\&
\&      profile=>\*(Aqfmc\*(Aq)],
\&     ["ami\-011b4273c6123ae76"];
.Ve
.SS "awsEc2DescribeImages(%options)"
.IX Subsection "awsEc2DescribeImages(%options)"
Describe images available.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    awsEc2DescribeImages(region => q(us\-east\-2), profile=>q(fmc));  # XXXXXXX
.Ve
.SS "awsCurrentLinuxSpotPrices(%options)"
.IX Subsection "awsCurrentLinuxSpotPrices(%options)"
Return {instance type} = cheapest spot price in dollars per hour for the given region
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&     awsCurrentLinuxSpotPrices(region => q(us\-east\-2), profile=>q(fmc));  # XXXXXXX
.Ve
.ie n .SS "awsEc2DescribeInstanceType($instanceType, %options)"
.el .SS "awsEc2DescribeInstanceType($instanceType, \f(CW%options\fP)"
.IX Subsection "awsEc2DescribeInstanceType($instanceType, %options)"
Return details of the specified instance type.
.PP
.Vb 3
\&     Parameter      Description
\&  1  $instanceType  Instance type name
\&  2  %options       Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $i = awsEc2DescribeInstanceType  # XXXXXXX
\&
\&     ("m4.large", region=>\*(Aqus\-east\-2\*(Aq, profile=>\*(Aqfmc\*(Aq);
\&
\&    is_deeply $i\->{VCpuInfo},
\&     {DefaultCores          => 1,
\&      DefaultThreadsPerCore => 2,
\&      DefaultVCpus          => 2,
\&      ValidCores            => [1],
\&      ValidThreadsPerCore   => [1, 2],
\&      };
.Ve
.ie n .SS "awsEc2ReportSpotInstancePrices($instanceTypeRe, %options)"
.el .SS "awsEc2ReportSpotInstancePrices($instanceTypeRe, \f(CW%options\fP)"
.IX Subsection "awsEc2ReportSpotInstancePrices($instanceTypeRe, %options)"
Report the prices of all the spot instances whose type matches a regular expression \fB\f(CB$instanceTypeRe\fB\fR. The report is sorted by price in millidollars per cpu ascending.
.PP
.Vb 3
\&     Parameter        Description
\&  1  $instanceTypeRe  Regular expression for instance type name
\&  2  %options         Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $a = awsEc2ReportSpotInstancePrices  # XXXXXXX
\&
\&     (qr(\e.metal), region=>\*(Aqus\-east\-2\*(Aq, profile=>\*(Aqfmc\*(Aq);
\&    ok $a\->report eq <<END;
\&  CPUs by price
\&
\&  10 instances types found on 2019\-12\-24 at 22:53:26
\&
\&  Cheapest Instance Type: m5.metal
\&  Price Per Cpu hour    : 6.65      in millidollars per hour
\&
\&     Column         Description
\&  1  Instance_Type  Instance type name
\&  2  Price          Price in millidollars per hour
\&  3  CPUs           Number of Cpus
\&  4  Price_per_CPU  The price per CPU in millidollars per hour
\&
\&      Instance_Type  Price  CPUs  Price_per_CPU
\&   1  m5.metal         638    96           6.65
\&   2  r5.metal         668    96           6.97
\&   3  r5d.metal        668    96           6.97
\&   4  m5d.metal        826    96           8.61
\&   5  c5d.metal        912    96           9.50
\&   6  c5.metal        1037    96          10.81
\&   7  c5n.metal        912    72          12.67
\&   8  i3.metal        1497    72          20.80
\&   9  z1d.metal       1339    48          27.90
\&  10  i3en.metal      3254    96          33.90
\&  END
.Ve
.ie n .SS "awsEc2RequestSpotInstances($count, $instanceType, $ami, $price, $securityGroup, $key, %options)"
.el .SS "awsEc2RequestSpotInstances($count, \f(CW$instanceType\fP, \f(CW$ami\fP, \f(CW$price\fP, \f(CW$securityGroup\fP, \f(CW$key\fP, \f(CW%options\fP)"
.IX Subsection "awsEc2RequestSpotInstances($count, $instanceType, $ami, $price, $securityGroup, $key, %options)"
Request spot instances as long as they can be started within the next minute. Return a list of spot instance request ids one for each instance requested.
.PP
.Vb 8
\&     Parameter       Description
\&  1  $count          Number of instances
\&  2  $instanceType   Instance type
\&  3  $ami            AMI
\&  4  $price          Price in dollars per hour
\&  5  $securityGroup  Security group
\&  6  $key            Key name
\&  7  %options        Options.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $r = awsEc2RequestSpotInstances  # XXXXXXX
\&
\&     (2, q(t2.micro), "ami\-xxx", 0.01, q(xxx), q(yyy),
\&      region=>\*(Aqus\-east\-2\*(Aq, profile=>\*(Aqfmc\*(Aq);
.Ve
.SS "awsEc2DescribeSpotInstances(%options)"
.IX Subsection "awsEc2DescribeSpotInstances(%options)"
Return a hash {spot instance request => spot instance details} describing the status of active spot instances.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $r = awsEc2DescribeSpotInstances(region => q(us\-east\-2), profile=>q(fmc));  # XXXXXXX
.Ve
.ie n .SS "awsEc2Tag($resource, $name, $value, %options)"
.el .SS "awsEc2Tag($resource, \f(CW$name\fP, \f(CW$value\fP, \f(CW%options\fP)"
.IX Subsection "awsEc2Tag($resource, $name, $value, %options)"
Tag an Ec2 resource with the supplied tags.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $resource  Resource
\&  2  $name      Tag name
\&  3  $value     Tag value
\&  4  %options   Options.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    awsEc2Tag  # XXXXXXX
\&
\&     ("i\-xxxx", Name=>q(Conversion), region => q(us\-east\-2), profile=>q(fmc));
.Ve
.SS "confirmHasCommandLineCommand($cmd)"
.IX Subsection "confirmHasCommandLineCommand($cmd)"
Check that the specified b<$cmd> is present on the current system.  Use \f(CW$ENV\fR{\s-1PATH\s0} to add folders containing commands as necessary.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $cmd       Command to check for
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    awsCurrentIp;
\&
\&    confirmHasCommandLineCommand(q(find));  # XXXXXXX
.Ve
.SS "numberOfCpus($scale)"
.IX Subsection "numberOfCpus($scale)"
Number of cpus scaled by an optional factor \- but only if you have nproc. If you do not have nproc but do have a convenient way for determining the number of cpus on your system please let me know.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $scale     Scale factor
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok numberOfCpus(8) >= 8, \*(Aqddd\*(Aq;                                                   # XXXXXXX
.Ve
.SS "ipAddressViaArp($hostName)"
.IX Subsection "ipAddressViaArp($hostName)"
Get the ip address of a server on the local network by hostname via arp
.PP
.Vb 2
\&     Parameter  Description
\&  1  $hostName  Host name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ipAddressViaArp(q(secarias));                                                   # XXXXXXX
.Ve
.SS "parseS3BucketAndFolderName($name)"
.IX Subsection "parseS3BucketAndFolderName($name)"
Parse an S3 <https://aws.amazon.com/s3/> bucket/folder name into a bucket and a folder name removing any initial s3://.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $name      Bucket/folder name
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply [parseS3BucketAndFolderName(q(s3://bbbb/ffff/dddd/))], [qw(bbbb ffff/dddd/)], q(iii);  # XXXXXXX
\&
\&
\&    is_deeply [parseS3BucketAndFolderName(q(s3://bbbb/))],           [qw(bbbb), q()];  # XXXXXXX
\&
\&
\&    is_deeply [parseS3BucketAndFolderName(q(     bbbb/))],           [qw(bbbb), q()];  # XXXXXXX
\&
\&
\&    is_deeply [parseS3BucketAndFolderName(q(     bbbb))],            [qw(bbbb), q()];  # XXXXXXX
\&
\&   }
.Ve
.ie n .SS "saveCodeToS3($saveCodeEvery, $folder, $zipFileName, $bucket, $S3Parms)"
.el .SS "saveCodeToS3($saveCodeEvery, \f(CW$folder\fP, \f(CW$zipFileName\fP, \f(CW$bucket\fP, \f(CW$S3Parms\fP)"
.IX Subsection "saveCodeToS3($saveCodeEvery, $folder, $zipFileName, $bucket, $S3Parms)"
Save source code every \fB\f(CB$saveCodeEvery\fB\fR seconds by zipping folder \fB\f(CB$folder\fB\fR to zip file \fB\f(CB$zipFileName\fB\fR then saving this zip file in the specified S3 <https://aws.amazon.com/s3/> \fB\f(CB$bucket\fB\fR using any additional S3 <https://aws.amazon.com/s3/> parameters in \fB\f(CB$S3Parms\fB\fR.
.PP
.Vb 6
\&     Parameter       Description
\&  1  $saveCodeEvery  Save every seconds
\&  2  $folder         Folder to save
\&  3  $zipFileName    Zip file name
\&  4  $bucket         Bucket/key
\&  5  $S3Parms        Additional S3 parameters like profile or region as a string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    saveCodeToS3(1200, q(.), q(projectName), q(bucket/folder), q(\-\-quiet));         # XXXXXXX
.Ve
.SS "addCertificate($file)"
.IX Subsection "addCertificate($file)"
Add a certificate to the current ssh session.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      File containing certificate
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    addCertificate(fpf(qw(.ssh cert)));                                             # XXXXXXX
.Ve
.SS "\fBhostName()\fP"
.IX Subsection "hostName()"
The name of the host we are running on.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    hostName;                                                                       # XXXXXXX
.Ve
.SS "userId($user)"
.IX Subsection "userId($user)"
Get or confirm the userid we are currently running under.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $user      Userid to confirm
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    userId;                                                                         # XXXXXXX
.Ve
.ie n .SS "awsTranslateText($string, $language, $cacheFolder, $Options)"
.el .SS "awsTranslateText($string, \f(CW$language\fP, \f(CW$cacheFolder\fP, \f(CW$Options\fP)"
.IX Subsection "awsTranslateText($string, $language, $cacheFolder, $Options)"
Translate \fB\f(CB$text\fB\fR from English to a specified \fB\f(CB$language\fB\fR using \s-1AWS\s0 Translate with the specified global \fB\f(CB$options\fB\fR and return the translated string.  Translations are cached in the specified \fB\f(CB$cacheFolder\fB\fR for reuse were feasible.
.PP
.Vb 5
\&     Parameter     Description
\&  1  $string       String to translate
\&  2  $language     Language code
\&  3  $cacheFolder  Cache folder
\&  4  $Options      Aws global options string
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsTranslateText("Hello", "it", ".translations/") eq q(Ciao);                # XXXXXXX
.Ve
.SH "AWS parallel"
.IX Header "AWS parallel"
Parallel computing across multiple instances running on Amazon Web Services <http://aws.amazon.com>.
.SS "\fBonAws()\fP"
.IX Subsection "onAws()"
Returns 1 if we are on \s-1AWS\s0 else return 0.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok  onAws;  # XXXXXXX
\&
\&    ok !onAwsSecondary;
\&    ok  onAwsPrimary;
.Ve
.SS "\fBonAwsPrimary()\fP"
.IX Subsection "onAwsPrimary()"
Return 1 if we are on Amazon Web Services <http://aws.amazon.com> and we are on the primary session instance as defined by awsParallelPrimaryInstanceId, return 0 if we are on a secondary session instance, else return \fBundef\fR if we are not on Amazon Web Services <http://aws.amazon.com>.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok  onAws;
\&    ok !onAwsSecondary;
\&
\&    ok  onAwsPrimary;  # XXXXXXX
.Ve
.SS "\fBonAwsSecondary()\fP"
.IX Subsection "onAwsSecondary()"
Return 1 if we are on Amazon Web Services <http://aws.amazon.com> but we are not on the primary session instance as defined by awsParallelPrimaryInstanceId, return 0 if we are on the primary session instance, else return \fBundef\fR if we are not on Amazon Web Services <http://aws.amazon.com>.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok  onAws;
\&
\&    ok !onAwsSecondary;  # XXXXXXX
\&
\&    ok  onAwsPrimary;
.Ve
.SS "awsParallelPrimaryInstanceId(%options)"
.IX Subsection "awsParallelPrimaryInstanceId(%options)"
Return the instance id of the primary instance. The primary instance is the instance at Amazon Web Services <http://aws.amazon.com> that we communicate with \- it controls all the secondary instances that form part of the parallel session. The primary instance is located by finding the first running instance in instance Id order whose Name tag contains the word \fIprimary\fR. If no running instance has been identified as the primary instance, then the first viable instance is made the primary. The ip address of the primary is recorded in \fI/tmp/awsPrimaryIpAddress.data\fR so that it can be quickly reused by xxxr, copyFolderToRemote, mergeFolderFromRemote etc. Returns the instanceId of the primary instance or \fBundef\fR if no suitable instance exists.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok "i\-xxx" eq awsParallelPrimaryInstanceId  # XXXXXXX
\&
\&     (region => q(us\-east\-2), profile=>q(fmc));
.Ve
.ie n .SS "awsParallelSpreadFolder($folder, %options)"
.el .SS "awsParallelSpreadFolder($folder, \f(CW%options\fP)"
.IX Subsection "awsParallelSpreadFolder($folder, %options)"
On Amazon Web Services <http://aws.amazon.com>: copies a specified \fB\f(CB$folder\fB\fR from the primary instance, see: awsParallelPrimaryInstanceId, in parallel, to all the secondary instances in the session. If running locally: copies the specified folder to all Amazon Web Services <http://aws.amazon.com> session instances both primary and secondary.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $folder    Fully qualified folder name
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $d = temporaryFolder;
\&    my ($f1, $f2) = map {fpe($d, $_, q(txt))} 1..2;
\&    my $files = {$f1 => "1111", $f2 => "2222"};
\&
\&    writeFiles($files);
\&
\&    awsParallelSpreadFolder($d);  # XXXXXXX
\&
\&    clearFolder($d, 3);
\&
\&    awsParallelGatherFolder($d);
\&    my $r = readFiles($d);
\&    is_deeply $files, $r;
\&    clearFolder($d, 3);
.Ve
.ie n .SS "awsParallelGatherFolder($folder, %options)"
.el .SS "awsParallelGatherFolder($folder, \f(CW%options\fP)"
.IX Subsection "awsParallelGatherFolder($folder, %options)"
On Amazon Web Services <http://aws.amazon.com>: merges all the files in the specified \fB\f(CB$folder\fB\fR on each secondary instance to the corresponding folder on the primary instance in parallel.  If running locally: merges all the files in the specified folder on each Amazon Web Services <http://aws.amazon.com> session instance (primary and secondary) to the corresponding folder on the local machine.  The folder merges are done in parallel which makes it impossible to rely on the order of the merges.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $folder    Fully qualified folder name
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $d = temporaryFolder;
\&    my ($f1, $f2) = map {fpe($d, $_, q(txt))} 1..2;
\&    my $files = {$f1 => "1111", $f2 => "2222"};
\&
\&    writeFiles($files);
\&    awsParallelSpreadFolder($d);
\&    clearFolder($d, 3);
\&
\&
\&    awsParallelGatherFolder($d);  # XXXXXXX
\&
\&    my $r = readFiles($d);
\&    is_deeply $files, $r;
\&    clearFolder($d, 3);
.Ve
.SS "awsParallelPrimaryIpAddress(%options)"
.IX Subsection "awsParallelPrimaryIpAddress(%options)"
Return the \s-1IP\s0 addresses of any primary instance on Amazon Web Services <http://aws.amazon.com>.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsParallelPrimaryIpAddress eq      q(3.1.4.4);  # XXXXXXX
\&
\&
\&    is_deeply [awsParallelSecondaryIpAddresses], [qw(3.1.4.5 3.1.4.6)];
\&
\&    is_deeply [awsParallelIpAddresses],  [qw(3.1.4.4 3.1.4.5 3.1.4.6)];
.Ve
.SS "awsParallelSecondaryIpAddresses(%options)"
.IX Subsection "awsParallelSecondaryIpAddresses(%options)"
Return a list containing the \s-1IP\s0 addresses of any secondary instances on Amazon Web Services <http://aws.amazon.com>.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsParallelPrimaryIpAddress eq      q(3.1.4.4);
\&
\&
\&    is_deeply [awsParallelSecondaryIpAddresses], [qw(3.1.4.5 3.1.4.6)];  # XXXXXXX
\&
\&
\&    is_deeply [awsParallelIpAddresses],  [qw(3.1.4.4 3.1.4.5 3.1.4.6)];
.Ve
.SS "awsParallelIpAddresses(%options)"
.IX Subsection "awsParallelIpAddresses(%options)"
Return the \s-1IP\s0 addresses of all the Amazon Web Services <http://aws.amazon.com> session instances.
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok awsParallelPrimaryIpAddress eq      q(3.1.4.4);
\&
\&    is_deeply [awsParallelSecondaryIpAddresses], [qw(3.1.4.5 3.1.4.6)];
\&
\&
\&    is_deeply [awsParallelIpAddresses],  [qw(3.1.4.4 3.1.4.5 3.1.4.6)];  # XXXXXXX
.Ve
.SS "getCodeContext($sub)"
.IX Subsection "getCodeContext($sub)"
Recreate the code context for a referenced sub
.PP
.Vb 2
\&     Parameter  Description
\&  1  $sub       Sub reference
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok getCodeContext(\e&getCodeContext) =~ m(use strict)ims;                          # XXXXXXX
.Ve
.ie n .SS "awsParallelProcessFiles($userData, $parallel, $results, $files, %options)"
.el .SS "awsParallelProcessFiles($userData, \f(CW$parallel\fP, \f(CW$results\fP, \f(CW$files\fP, \f(CW%options\fP)"
.IX Subsection "awsParallelProcessFiles($userData, $parallel, $results, $files, %options)"
Process files in parallel across multiple Amazon Web Services <http://aws.amazon.com> instances if available or in series if not.  The data located by \fB\f(CB$userData\fB\fR is transferred from the primary instance, as determined by awsParallelPrimaryInstanceId, to all the secondary instances. \fB\f(CB$parallel\fB\fR contains a reference to a sub, parameterized by array \f(CW@_\fR = (a copy of the user data, the name of the file to process), which will be executed upon each session instance including the primary instance to update \f(CW$userData\fR. \fB\f(CB$results\fB\fR contains a reference to a sub, parameterized by array \f(CW@_\fR = (the user data, an array of results returned by each execution of \f(CW$parallel\fR), that will be called on the primary instance to process the results folders from each instance once their results folders have been copied back and merged into the results folder of the primary instance. \f(CW$results\fR should update its copy of \f(CW$userData\fR with the information received from each instance. \fB\f(CB$files\fB\fR is a reference to an array of the files to be processed: each file will be copied from the primary instance to each of the secondary instances before parallel processing starts. \fB\f(CB%options\fB\fR contains any parameters needed to interact with \s-1EC2\s0 <https://aws.amazon.com/ec2/>  via the Amazon Web Services Command Line Interface <https://aws.amazon.com/cli/>.  The returned result is that returned by sub \f(CW$results\fR.
.PP
.Vb 6
\&     Parameter  Description
\&  1  $userData  User data or undef
\&  2  $parallel  Parallel sub reference
\&  3  $results   Series sub reference
\&  4  $files     [files to process]
\&  5  %options   Aws cli options.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $N = 2001;                                                                 # Number of files to process
\&    my $options = q(region => q(us\-east\-2), profile=>q(fmc));                     # Aws cli options
\&    my %options = eval "($options)";
\&
\&    for my $dir(q(/home/phil/perl/cpan/DataTableText/lib/Data/Table/),            # Folders we will need on aws
\&                q(/home/phil/.aws/))
\&     {awsParallelSpreadFolder($dir, %options);
\&     }
\&
\&    my $d = temporaryFolder;                                                      # Create a temporary folder
\&    my $resultsFile = fpe($d, qw(results data));                                  # Save results in this temporary file
\&
\&    if (my $r = execPerlOnRemote(join "
\&",                                       # Execute some code on a server
\&      getCodeContext(\e&awsParallelProcessFilesTestParallel),                      # Get code context of the sub we want to call.
\&      <<SESSIONLEADER))                                                           # Launch code on session leader
\&  use Data::Table::Text qw(:all);
\&
\&
\&  my \e$r = awsParallelProcessFiles                                                # Process files on multiple L<Amazon Web Services|http://aws.amazon.com> instances in parallel  # XXXXXXX
\&
\&   ({file=>4, time=>timeStamp},                                                   # User data
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestParallel,                   # Reference to code to execute in parallel on each session instance
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestResults,                    # Reference to code to execute in series to merge the results of each parallel computation
\&    [map {writeFile(fpe(q($d), \e$_, qw(txt)), \e$_)} 1..$N],                       # Files to process
\&    $options);                                                                    # Aws cli options as we will be running on Aws
\&
\&  storeFile(q($resultsFile), \e$r);                                                # Save results in a file
\&
\&  SESSIONLEADER
\&
\&     {copyFileFromRemote($resultsFile);                                           # Retrieve user data
\&
\&      my $userData = retrieveFile($resultsFile);                                  # Recover user data
\&      my @i = awsParallelSecondaryIpAddresses(%options);                          # Ip addresses of secondary instances
\&      my @I = keys $userData\->{ip}\->%*;
\&      is_deeply [sort @i], [sort @I];                                             # Each secondary ip address was used
\&
\&      ok $userData\->{file}  == 4;                                                 # Prove we can pass data in and get it back
\&      ok $userData\->{merge} == 1 + @i, \*(Aqii\*(Aq;                                      # Number of merges
\&
\&      my %f; my %i;                                                               # Files processed on each ip
\&      for   my $i(sort keys $userData\->{ipFile}\->%*)                              # Ip
\&       {for my $f(sort keys $userData\->{ipFile}{$i}\->%*)                          # File
\&         {$f{fn($f)}++;                                                           # Files processed
\&          $i{$i}++;                                                               # Count files on each ip
\&         }
\&       }
\&
\&      is_deeply \e%f, {map {$_=>1} 1..$N};                                         # Check each file was processed
\&
\&      if (1)
\&       {my @rc; my @ra;                                                           # Range of number of files processed on each ip \- computed, actually counted
\&        my $l = $N/@i\-1;                                                          # Lower limit of number of files per IP address
\&        my $h = $N/@i+1;                                                          # Upper limit of number of files per IP address
\&        for   my $i(keys %i)
\&         {my $nc = $i{$i};                                                        # Number of files processed on this ip \- computed
\&          my $na = $userData\->{ip}{$i};                                           # Number of files processed on this ip \- actually counted
\&          push @rc, ($nc >= $l and $nc <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&          push @ra, ($na >= $l and $na <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&         }
\&        ok @i == grep {$_} @ra;                                                   # Check each ip processed the expected number of files
\&        ok @i == grep {$_} @rc;
\&       }
\&
\&      ok $userData\->{files}{&fpe($d, qw(4 txt))} eq                               # Check the computed MD5 sum for the specified file
\&         q(a87ff679a2f3e71d9181a67b7542122c);
\&     }
\&
\&  if (0)                                                                           # Process files in series on local machine
\&   {my $N = 42;
\&    my $d = temporaryFolder;
\&
\&
\&    my $r = awsParallelProcessFiles                                               # Process files in series on local machine  # XXXXXXX
\&
\&     ({file => 4},                                                                # User data
\&      \e&Data::Table::Text::awsParallelProcessFilesTestParallel,                   # Code to execute on each session instance including the session leader written as a string because it has to be shipped to each instance
\&      \e&Data::Table::Text::awsParallelProcessFilesTestResults,                    # Code to execute in series on the session leader to analyze the results of the parallel runs
\&      [map {writeFile(fpe($d, $_, qw(txt)), $_)} 1..$N],                          # Files to process
\&      ());                                                                        # No Aws cli options as we are running locally
\&
\&    ok $r\->{file}            ==  4, \*(Aqaaa\*(Aq;                                        # Prove we can pass data in and get it back
\&    ok $r\->{merge}           ==  1, \*(Aqbbb\*(Aq;                                        # Only one merge as we are running locally
\&
\&    ok $r\->{ip}{localHost}   == $N, \*(Aqccc\*(Aq;                                        # Number of files processed locally
\&    ok keys($r\->{files}\->%*) == $N;                                               # Number of files processed
\&    ok $r\->{files}{fpe($d, qw(4 txt))} eq q(a87ff679a2f3e71d9181a67b7542122c);    # Check the computed MD5 sum for the specified file
\&
\&    clearFolder($d, $N+2);
\&   }
.Ve
.SH "S3"
.IX Header "S3"
Work with S3 as if it were a file system.
.ie n .SS "s3ListFilesAndSizes($folderOrFile, %options)"
.el .SS "s3ListFilesAndSizes($folderOrFile, \f(CW%options\fP)"
.IX Subsection "s3ListFilesAndSizes($folderOrFile, %options)"
Return {file=>size} for all the files in a specified \fB\f(CB$folderOrFile\fB\fR on S3 using the specified \fB\f(CB%options\fB\fR if any.
.PP
.Vb 3
\&     Parameter      Description
\&  1  $folderOrFile  Source on S3 \- which will be truncated to a folder name
\&  2  %options       Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)  # XXXXXXX
\&
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3FileExists($file, %options)"
.el .SS "s3FileExists($file, \f(CW%options\fP)"
.IX Subsection "s3FileExists($file, %options)"
Return (name, size, date, time) for a \fB\f(CB$file\fB\fR that exists on S3 else () using the specified \fB\f(CB%options\fB\fR if any.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File on S3 \- which will be truncated to a folder name
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&
\&     {my @r = s3FileExists($file, %options);  # XXXXXXX
\&
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3WriteFile($fileS3, $fileLocal, %options)"
.el .SS "s3WriteFile($fileS3, \f(CW$fileLocal\fP, \f(CW%options\fP)"
.IX Subsection "s3WriteFile($fileS3, $fileLocal, %options)"
Write to a file \fB\f(CB$fileS3\fB\fR on S3 the contents of a local file \fB\f(CB$fileLocal\fB\fR using the specified \fB\f(CB%options\fB\fR if any.  \f(CW$fileLocal\fR will be removed if \f(CW%options\fR contains a key cleanUp with a true value.
.PP
.Vb 4
\&     Parameter   Description
\&  1  $fileS3     File to write to on S3
\&  2  $fileLocal  String to write into file
\&  3  %options    Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&
\&      s3WriteFile($file, $f, %options);  # XXXXXXX
\&
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3WriteString($file, $string, %options)"
.el .SS "s3WriteString($file, \f(CW$string\fP, \f(CW%options\fP)"
.IX Subsection "s3WriteString($file, $string, %options)"
Write to a \fB\f(CB$file\fB\fR on S3 the contents of \fB\f(CB$string\fB\fR using the specified \fB\f(CB%options\fB\fR if any.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $file      File to write to on S3
\&  2  $string    String to write into file
\&  3  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&
\&     {       s3WriteString($file, $data, %options);  # XXXXXXX
\&
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3ReadFile($file, $local, %options)"
.el .SS "s3ReadFile($file, \f(CW$local\fP, \f(CW%options\fP)"
.IX Subsection "s3ReadFile($file, $local, %options)"
Read from a \fB\f(CB$file\fB\fR on S3 and write the contents to a local file \fB\f(CB$local\fB\fR using the specified \fB\f(CB%options\fB\fR if any.  Any pre existing version of the local file \f(CW$local\fR will be deleted.  Returns whether the local file exists after completion of the download.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $file      File to read from on S3
\&  2  $local     Local file to write to
\&  3  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&
\&      s3ReadFile ($file, $f, %options);  # XXXXXXX
\&
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3ReadString($file, %options)"
.el .SS "s3ReadString($file, \f(CW%options\fP)"
.IX Subsection "s3ReadString($file, %options)"
Read from a \fB\f(CB$file\fB\fR on S3 and return the contents as a string using specified \fB\f(CB%options\fB\fR if any.  Any pre existing version of \f(CW$local\fR will be deleted.  Returns whether the local file exists after completion of the download.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $file      File to read from on S3
\&  2  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&
\&      my $r = s3ReadString($file,        %options);  # XXXXXXX
\&
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3DownloadFolder($folder, $local, %options)"
.el .SS "s3DownloadFolder($folder, \f(CW$local\fP, \f(CW%options\fP)"
.IX Subsection "s3DownloadFolder($folder, $local, %options)"
Download a specified \fB\f(CB$folder\fB\fR on S3 to a \fB\f(CB$local\fB\fR folder using the specified \fB\f(CB%options\fB\fR if any.  Any existing data in the \f(CW$local\fR folder will be will be deleted if delete=>1 is specified as an option. Returns \fBundef on failure\fR else the name of the \fB\f(CB$local\fB\fR on success.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $folder    Folder to read from on S3
\&  2  $local     Local folder to write to
\&  3  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&
\&    s3DownloadFolder  # XXXXXXX
\&
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3ZipFolder($source, $target, %options)"
.el .SS "s3ZipFolder($source, \f(CW$target\fP, \f(CW%options\fP)"
.IX Subsection "s3ZipFolder($source, $target, %options)"
Zip the specified \fB\f(CB$source\fB\fR folder and write it to the named \fB\f(CB$target\fB\fR file on S3.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $source    Source folder
\&  2  $target    Target file on S3
\&  3  %options   S3 options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    s3ZipFolder(q(home/phil/r/), q(s3://bucket/r.zip));  # XXXXXXX
\&
\&
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);  # XXXXXXX
\&
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.ie n .SS "s3ZipFolders($map, %options)"
.el .SS "s3ZipFolders($map, \f(CW%options\fP)"
.IX Subsection "s3ZipFolders($map, %options)"
Zip local folders and upload them to S3 in parallel.  \fB\f(CB$map\fB\fR maps source folder names on the local machine to target folders on S3. \fB\f(CB%options\fB\fR contains any additional Amazon Web Services <http://aws.amazon.com> cli options.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $map       Source folder to S3 mapping
\&  2  %options   S3 options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %options = (profile => q(fmc));
\&
\&    s3DownloadFolder
\&     (q(s3://bucket/folder/), q(home/phil/s3/folder/), %options, delete=>1);
\&
\&    s3ZipFolder ( q(home/phil/s3/folder/) => q(s3://bucket/folder/),  %options);
\&
\&
\&    s3ZipFolders({q(home/phil/s3/folder/) => q(s3://bucket/folder/)}, %options);  # XXXXXXX
\&
\&
\&    is_deeply
\&     {s3ListFilesAndSizes(q(s3://salesforce.dita/originals4/images), %options)
\&     },
\&     {"s3://salesforce.dita/originals4/images/business_plan_sections.png" =>
\&       ["originals4/images/business_plan_sections.png",
\&        112525,
\&        "2019\-08\-13",
\&        "20:01:10",
\&       ],
\&      "s3://salesforce.dita/originals4/images/non\-referenced.png" =>
\&       ["originals4/images/non\-referenced.png",
\&        19076,
\&        "2019\-08\-20",
\&        "01:25:04",
\&       ],
\&     };
\&
\&    my $data = q(0123456789);
\&    my $file = q(s3://salesforce.dita/zzz/111.txt);
\&
\&    if (1)
\&     {       s3WriteString($file, $data, %options);
\&      my $r = s3ReadString($file,        %options);
\&      ok $r eq $data;
\&     }
\&
\&    if (1)
\&     {my @r = s3FileExists($file, %options);
\&      ok $r[0] eq "zzz/111.txt";
\&      ok $r[1] ==  10;
\&     }
\&
\&    if (1)
\&     {my $d = $data x 2;
\&      my $f = writeFile(undef, $d);
\&
\&      s3WriteFile($file, $f, %options);
\&      unlink $f;
\&      s3ReadFile ($file, $f, %options);
\&      ok readFile($f) eq $d;
\&      unlink $f;
\&     }
.Ve
.SH "GitHub"
.IX Header "GitHub"
Simple interactions with GitHub <https://github.com> \- for more complex interactions please use GitHub::Crud.
.ie n .SS "downloadGitHubPublicRepo($user, $repo)"
.el .SS "downloadGitHubPublicRepo($user, \f(CW$repo\fP)"
.IX Subsection "downloadGitHubPublicRepo($user, $repo)"
Get the contents of a public repo on GitHub and place them in a temporary folder whose name is returned to the caller or confess if no such repo exists.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $user      GitHub user
\&  2  $repo      GitHub repo
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&       downloadGitHubPublicRepo(q(philiprbrenan), q(psr));                          # XXXXXXX
.Ve
.ie n .SS "downloadGitHubPublicRepoFile($user, $repo, $file)"
.el .SS "downloadGitHubPublicRepoFile($user, \f(CW$repo\fP, \f(CW$file\fP)"
.IX Subsection "downloadGitHubPublicRepoFile($user, $repo, $file)"
Get the contents of a \fB\f(CB$user\fB\fR \fB\f(CB$repo\fB\fR \fB\f(CB$file\fB\fR from  a public repo on GitHub and return them as a string.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $user      GitHub user
\&  2  $repo      GitHub repository
\&  3  $file      File name in repository
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok &downloadGitHubPublicRepoFile(qw(philiprbrenan pleaseChangeDita index.html));  # XXXXXXX
.Ve
.SH "Processes"
.IX Header "Processes"
Start processes, wait for them to terminate and retrieve their results
.ie n .SS "startProcess($sub, $pids, $maximum)"
.el .SS "startProcess($sub, \f(CW$pids\fP, \f(CW$maximum\fP)"
.IX Subsection "startProcess($sub, $pids, $maximum)"
Start new processes while the number of child processes recorded in \fB%$pids\fR is less than the specified \fB\f(CB$maximum\fB\fR.  Use waitForAllStartedProcessesToFinish to wait for all these processes to finish.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $sub       Sub to start
\&  2  $pids      Hash in which to record the process ids
\&  3  $maximum   Maximum number of processes to run at a time
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %pids;
\&
\&    sub{startProcess {} %pids, 1; ok 1 >= keys %pids}\->() for 1..8;  # XXXXXXX
\&
\&    waitForAllStartedProcessesToFinish(%pids);
\&    ok !keys(%pids)
.Ve
.SS "waitForAllStartedProcessesToFinish($pids)"
.IX Subsection "waitForAllStartedProcessesToFinish($pids)"
Wait until all the processes started by startProcess have finished.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $pids      Hash of started process ids
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my %pids;
\&    sub{startProcess {} %pids, 1; ok 1 >= keys %pids}\->() for 1..8;
\&
\&    waitForAllStartedProcessesToFinish(%pids);  # XXXXXXX
\&
\&    ok !keys(%pids)
.Ve
.ie n .SS "newProcessStarter($maximumNumberOfProcesses, %options)"
.el .SS "newProcessStarter($maximumNumberOfProcesses, \f(CW%options\fP)"
.IX Subsection "newProcessStarter($maximumNumberOfProcesses, %options)"
Create a new process starter with which to start parallel processes up to a specified \fB\f(CB$maximumNumberOfProcesses\fB\fR maximum number of parallel processes at a time, wait for all the started processes to finish and then optionally retrieve their saved results as an array from the folder named by \fB\f(CB$transferArea\fB\fR.
.PP
.Vb 3
\&     Parameter                  Description
\&  1  $maximumNumberOfProcesses  Maximum number of processes to start
\&  2  %options                   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  if (1)
\&   {my $N = 100;
\&    my $l = q(logFile.txt);
\&    unlink $l;
\&
\&    my $s = newProcessStarter(4);  # XXXXXXX
\&
\&       $s\->processingTitle   = q(Test processes);
\&       $s\->totalToBeStarted  = $N;
\&       $s\->processingLogFile = $l;
\&
\&    for my $i(1..$N)
\&     {Data::Table::Text::Starter::start($s, sub{$i*$i});
\&     }
\&
\&    is_deeply
\&     [sort {$a <=> $b} Data::Table::Text::Starter::finish($s)],
\&     [map {$_**2} 1..$N];
\&
\&    ok readFile($l) =~ m(Finished $N processes for: Test processes)s;
\&    clearFolder($s\->transferArea, 1e3);
\&    unlink $l;
\&   }
.Ve
.ie n .SS "Data::Table::Text::Starter::start($starter, $sub)"
.el .SS "Data::Table::Text::Starter::start($starter, \f(CW$sub\fP)"
.IX Subsection "Data::Table::Text::Starter::start($starter, $sub)"
Start a new process to run the specified \fB\f(CB$sub\fB\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $starter   Starter
\&  2  $sub       Sub to be run.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 8
\&  if (1)
\&   {my $N = 100;
\&    my $l = q(logFile.txt);
\&    unlink $l;
\&    my $s = newProcessStarter(4);
\&       $s\->processingTitle   = q(Test processes);
\&       $s\->totalToBeStarted  = $N;
\&       $s\->processingLogFile = $l;
\&
\&    for my $i(1..$N)
\&
\&     {Data::Table::Text::Starter::start($s, sub{$i*$i});  # XXXXXXX
\&
\&     }
\&
\&    is_deeply
\&     [sort {$a <=> $b} Data::Table::Text::Starter::finish($s)],
\&     [map {$_**2} 1..$N];
\&
\&    ok readFile($l) =~ m(Finished $N processes for: Test processes)s;
\&    clearFolder($s\->transferArea, 1e3);
\&    unlink $l;
\&   }
.Ve
.SS "Data::Table::Text::Starter::finish($starter)"
.IX Subsection "Data::Table::Text::Starter::finish($starter)"
Wait for all started processes to finish and return their results as an array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $starter   Starter
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 8
\&  if (1)
\&   {my $N = 100;
\&    my $l = q(logFile.txt);
\&    unlink $l;
\&    my $s = newProcessStarter(4);
\&       $s\->processingTitle   = q(Test processes);
\&       $s\->totalToBeStarted  = $N;
\&       $s\->processingLogFile = $l;
\&
\&    for my $i(1..$N)
\&     {Data::Table::Text::Starter::start($s, sub{$i*$i});
\&     }
\&
\&    is_deeply
\&
\&     [sort {$a <=> $b} Data::Table::Text::Starter::finish($s)],  # XXXXXXX
\&
\&     [map {$_**2} 1..$N];
\&
\&    ok readFile($l) =~ m(Finished $N processes for: Test processes)s;
\&    clearFolder($s\->transferArea, 1e3);
\&    unlink $l;
\&   }
.Ve
.SS "squareArray(@array)"
.IX Subsection "squareArray(@array)"
Create a two dimensional square array from a one dimensional linear array.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @array     Array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [squareArray @{[1..4]} ], [[1, 2], [3, 4]];  # XXXXXXX
\&
\&
\&    is_deeply [squareArray @{[1..22]}],  # XXXXXXX
\&
\&     [[1 .. 5], [6 .. 10], [11 .. 15], [16 .. 20], [21, 22]];
\&
\&
\&    is_deeply [1..$_], [deSquareArray squareArray @{[1..$_]}] for 1..22;  # XXXXXXX
\&
\&
\&    ok $_ == countSquareArray         squareArray @{[1..$_]}  for 222;  # XXXXXXX
\&
\&
\&    is_deeply [rectangularArray(3, 1..11)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9]];
\&
\&    is_deeply [rectangularArray(3, 1..12)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray(3, 1..13)],
\&              [[1, 4, 7, 10, 13],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray2(3, 1..5)],
\&              [[1, 2, 3],
\&               [4, 5]];
\&
\&    is_deeply [rectangularArray2(3, 1..6)],
\&              [[1, 2, 3],
\&               [4, 5, 6]];
\&
\&    is_deeply [rectangularArray2(3, 1..7)],
\&              [[1, 2, 3],
\&               [4, 5, 6],
\&               [7]];
.Ve
.SS "deSquareArray(@square)"
.IX Subsection "deSquareArray(@square)"
Create a one dimensional array from a two dimensional array of arrays
.PP
.Vb 2
\&     Parameter  Description
\&  1  @square    Array of arrays
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    is_deeply [squareArray @{[1..4]} ], [[1, 2], [3, 4]];
\&    is_deeply [squareArray @{[1..22]}],
\&     [[1 .. 5], [6 .. 10], [11 .. 15], [16 .. 20], [21, 22]];
\&
\&
\&    is_deeply [1..$_], [deSquareArray squareArray @{[1..$_]}] for 1..22;  # XXXXXXX
\&
\&    ok $_ == countSquareArray         squareArray @{[1..$_]}  for 222;
\&
\&    is_deeply [rectangularArray(3, 1..11)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9]];
\&
\&    is_deeply [rectangularArray(3, 1..12)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray(3, 1..13)],
\&              [[1, 4, 7, 10, 13],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray2(3, 1..5)],
\&              [[1, 2, 3],
\&               [4, 5]];
\&
\&    is_deeply [rectangularArray2(3, 1..6)],
\&              [[1, 2, 3],
\&               [4, 5, 6]];
\&
\&    is_deeply [rectangularArray2(3, 1..7)],
\&              [[1, 2, 3],
\&               [4, 5, 6],
\&               [7]];
.Ve
.ie n .SS "rectangularArray($first, @array)"
.el .SS "rectangularArray($first, \f(CW@array\fP)"
.IX Subsection "rectangularArray($first, @array)"
Create a two dimensional rectangular array whose first dimension is \fB\f(CB$first\fB\fR from a one dimensional linear array.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First dimension size
\&  2  @array     Array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    is_deeply [squareArray @{[1..4]} ], [[1, 2], [3, 4]];
\&    is_deeply [squareArray @{[1..22]}],
\&     [[1 .. 5], [6 .. 10], [11 .. 15], [16 .. 20], [21, 22]];
\&
\&    is_deeply [1..$_], [deSquareArray squareArray @{[1..$_]}] for 1..22;
\&    ok $_ == countSquareArray         squareArray @{[1..$_]}  for 222;
\&
\&
\&    is_deeply [rectangularArray(3, 1..11)],  # XXXXXXX
\&
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9]];
\&
\&
\&    is_deeply [rectangularArray(3, 1..12)],  # XXXXXXX
\&
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&
\&    is_deeply [rectangularArray(3, 1..13)],  # XXXXXXX
\&
\&              [[1, 4, 7, 10, 13],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray2(3, 1..5)],
\&              [[1, 2, 3],
\&               [4, 5]];
\&
\&    is_deeply [rectangularArray2(3, 1..6)],
\&              [[1, 2, 3],
\&               [4, 5, 6]];
\&
\&    is_deeply [rectangularArray2(3, 1..7)],
\&              [[1, 2, 3],
\&               [4, 5, 6],
\&               [7]];
.Ve
.ie n .SS "rectangularArray2($second, @array)"
.el .SS "rectangularArray2($second, \f(CW@array\fP)"
.IX Subsection "rectangularArray2($second, @array)"
Create a two dimensional rectangular array whose second dimension is \fB\f(CB$second\fB\fR from a one dimensional linear array.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $second    Second dimension size
\&  2  @array     Array
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    is_deeply [squareArray @{[1..4]} ], [[1, 2], [3, 4]];
\&    is_deeply [squareArray @{[1..22]}],
\&     [[1 .. 5], [6 .. 10], [11 .. 15], [16 .. 20], [21, 22]];
\&
\&    is_deeply [1..$_], [deSquareArray squareArray @{[1..$_]}] for 1..22;
\&    ok $_ == countSquareArray         squareArray @{[1..$_]}  for 222;
\&
\&    is_deeply [rectangularArray(3, 1..11)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9]];
\&
\&    is_deeply [rectangularArray(3, 1..12)],
\&              [[1, 4, 7, 10],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&    is_deeply [rectangularArray(3, 1..13)],
\&              [[1, 4, 7, 10, 13],
\&               [2, 5, 8, 11],
\&               [3, 6, 9, 12]];
\&
\&
\&    is_deeply [rectangularArray2(3, 1..5)],  # XXXXXXX
\&
\&              [[1, 2, 3],
\&               [4, 5]];
\&
\&
\&    is_deeply [rectangularArray2(3, 1..6)],  # XXXXXXX
\&
\&              [[1, 2, 3],
\&               [4, 5, 6]];
\&
\&
\&    is_deeply [rectangularArray2(3, 1..7)],  # XXXXXXX
\&
\&              [[1, 2, 3],
\&               [4, 5, 6],
\&               [7]];
.Ve
.SS "callSubInParallel($sub)"
.IX Subsection "callSubInParallel($sub)"
Call a sub reference in parallel to avoid memory fragmentation and return its results.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $sub       Sub reference
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my %a = (a=>1, b=>2);
\&
\&    my %b = callSubInParallel {return %a};  # XXXXXXX
\&
\&    is_deeply \e%a, \e%b;
\&
\&    my $f = temporaryFile;
\&    ok \-e $f;
\&
\&    my $a = callSubInOverlappedParallel
\&      sub {$a{a}++; owf($f, "Hello World")},
\&      sub {q(aaaa)};
\&
\&    ok $a           =~ m(aaaa)i;
\&    ok $a{a}        == 1;
\&    ok readFile($f) =~ m(Hello World)i;
.Ve
.ie n .SS "callSubInOverlappedParallel($child, $parent)"
.el .SS "callSubInOverlappedParallel($child, \f(CW$parent\fP)"
.IX Subsection "callSubInOverlappedParallel($child, $parent)"
Call the \fB\f(CB$child\fB\fR sub reference in parallel in a separate child process and ignore its results while calling the \fB\f(CB$parent\fB\fR sub reference in the parent process and returning its results.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Sub reference to call in child process
\&  2  $parent    Sub reference to call in parent process
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my %a = (a=>1, b=>2);
\&    my %b = callSubInParallel {return %a};
\&    is_deeply \e%a, \e%b;
\&
\&    my $f = temporaryFile;
\&    ok \-e $f;
\&
\&
\&    my $a = callSubInOverlappedParallel  # XXXXXXX
\&
\&      sub {$a{a}++; owf($f, "Hello World")},
\&      sub {q(aaaa)};
\&
\&    ok $a           =~ m(aaaa)i;
\&    ok $a{a}        == 1;
\&    ok readFile($f) =~ m(Hello World)i;
.Ve
.ie n .SS "runInParallel($maximumNumberOfProcesses, $parallel, $results, @array)"
.el .SS "runInParallel($maximumNumberOfProcesses, \f(CW$parallel\fP, \f(CW$results\fP, \f(CW@array\fP)"
.IX Subsection "runInParallel($maximumNumberOfProcesses, $parallel, $results, @array)"
Process the elements of an array in parallel using a maximum of \fB\f(CB$maximumNumberOfProcesses\fB\fR processes. sub \fB&$parallel\fR is forked to process each array element in parallel. The results returned by the forked copies of &$parallel are presented as a single array to sub \fB&$results\fR which is run in series. \fB\f(CB@array\fB\fR contains the elements to be processed. Returns the result returned by &$results.
.PP
.Vb 5
\&     Parameter                  Description
\&  1  $maximumNumberOfProcesses  Maximum number of processes
\&  2  $parallel                  Parallel sub
\&  3  $results                   Results sub
\&  4  @array                     Array of items to process
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my @N = 1..100;
\&    my $N = 100;
\&    my $R = 0; $R += $_*$_ for 1..$N;
\&
\&    ok 338350 == $R;
\&
\&    ok $R == runInSquareRootParallel
\&       (4,
\&        sub {my ($p) = @_; $p * $p},
\&        sub {my $p = 0; $p += $_ for @_; $p},
\&        @{[1..$N]}
\&       );
\&
\&
\&    ok $R == runInParallel  # XXXXXXX
\&
\&       (4,
\&        sub {my ($p) = @_; $p * $p},
\&        sub {my $p = 0; $p += $_ for @_; $p},
\&        @{[1..$N]}
\&       );
.Ve
.ie n .SS "runInSquareRootParallel($maximumNumberOfProcesses, $parallel, $results, @array)"
.el .SS "runInSquareRootParallel($maximumNumberOfProcesses, \f(CW$parallel\fP, \f(CW$results\fP, \f(CW@array\fP)"
.IX Subsection "runInSquareRootParallel($maximumNumberOfProcesses, $parallel, $results, @array)"
Process the elements of an array in square root parallel using a maximum of \fB\f(CB$maximumNumberOfProcesses\fB\fR processes. sub \fB&$parallel\fR is forked to process each block of array elements in parallel. The results returned by the forked copies of &$parallel are presented as a single array to sub \fB&$results\fR which is run in series. \fB\f(CB@array\fB\fR contains the elements to be processed. Returns the result returned by &$results..
.PP
.Vb 5
\&     Parameter                  Description
\&  1  $maximumNumberOfProcesses  Maximum number of processes
\&  2  $parallel                  Parallel sub
\&  3  $results                   Results sub
\&  4  @array                     Array of items to process
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my @N = 1..100;
\&    my $N = 100;
\&    my $R = 0; $R += $_*$_ for 1..$N;
\&
\&    ok 338350 == $R;
\&
\&
\&    ok $R == runInSquareRootParallel  # XXXXXXX
\&
\&       (4,
\&        sub {my ($p) = @_; $p * $p},
\&        sub {my $p = 0; $p += $_ for @_; $p},
\&        @{[1..$N]}
\&       );
\&
\&    ok $R == runInParallel
\&       (4,
\&        sub {my ($p) = @_; $p * $p},
\&        sub {my $p = 0; $p += $_ for @_; $p},
\&        @{[1..$N]}
\&       );
.Ve
.ie n .SS "packBySize($N, @sizes)"
.el .SS "packBySize($N, \f(CW@sizes\fP)"
.IX Subsection "packBySize($N, @sizes)"
Given \fB\f(CB$N\fB\fR buckets and a list \fB\f(CB@sizes\fB\fR of ([size of file, name of file]...) pack the file names into buckets so that each bucket contains approximately the same number of bytes.  In general this is an \s-1NP\s0 problem.  Packing largest first into emptiest bucket produces an N**2 heuristic if the buckets are scanned linearly, or N*log(N) if a binary tree is used.  This solution is a compromise at N**3/2 which has the benefits of simple code yet good performance.  Returns ([file names ...]).
.PP
.Vb 3
\&     Parameter  Description
\&  1  $N         Number of buckets
\&  2  @sizes     Sizes
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $M = 7;
\&    my $N = 15;
\&
\&    my @b = packBySize($M, map {[$_, $_]} 1..$N);  # XXXXXXX
\&
\&    my @B; my $B = 0;
\&    for my $b(@b)
\&     {my $n = 0;
\&      for(@$b)
\&       {$n += $_;
\&        $B += $_;
\&       }
\&      push @B, $n;
\&     }
\&    ok $B == $N * ($N + 1) / 2;
\&    is_deeply [@B], [16, 20, 16, 18, 16, 18, 16];
.Ve
.ie n .SS "processSizesInParallel($parallel, $results, @sizes)"
.el .SS "processSizesInParallel($parallel, \f(CW$results\fP, \f(CW@sizes\fP)"
.IX Subsection "processSizesInParallel($parallel, $results, @sizes)"
Process items of known size in parallel using (8 * the number of CPUs) processes with the process each item is assigned to depending on the size of the item so that each process is loaded with approximately the same number of bytes of data in total from the items it processes.
.PP
Each item is processed by sub \fB\f(CB$parallel\fB\fR and the results of processing all items is processed by \fB\f(CB$results\fB\fR where the items are taken from \fB\f(CB@sizes\fB\fR. Each &$\fBparallel()\fR receives an item from \f(CW@files\fR. &$\fBresults()\fR receives an array of all the results returned by &$\fBparallel()\fR.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $parallel  Parallel sub
\&  2  $results   Results sub
\&  3  @sizes     Array of [size; item] to process by size
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = temporaryFolder;
\&    my @f = map {owf(fpe($d, $_, q(txt)), \*(AqX\*(Aq x ($_ ** 2 % 11))} 1..9;
\&
\&    my $f = fileLargestSize(@f);
\&    ok fn($f) eq \*(Aq3\*(Aq, \*(Aqaaa\*(Aq;
\&
\&    my $b = folderSize($d);
\&    ok $b > 0, \*(Aqbbb\*(Aq;
\&
\&    my $c = processFilesInParallel(
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12);
\&
\&    ok 108 == $c, \*(Aqcc11\*(Aq;
\&
\&
\&    my $C = processSizesInParallel  # XXXXXXX
\&
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, map {[fileSize($_), $_]} (@f) x 12;
\&
\&    ok 108 == $C, \*(Aqcc2\*(Aq;
\&
\&    my $J = processJavaFilesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12;
\&
\&    ok 108 == $J, \*(Aqcc3\*(Aq;
\&
\&    clearFolder($d, 12);
.Ve
.ie n .SS "processFilesInParallel($parallel, $results, @files)"
.el .SS "processFilesInParallel($parallel, \f(CW$results\fP, \f(CW@files\fP)"
.IX Subsection "processFilesInParallel($parallel, $results, @files)"
Process files in parallel using (8 * the number of CPUs) processes with the process each file is assigned to depending on the size of the file so that each process is loaded with approximately the same number of bytes of data in total from the files it processes.
.PP
Each file is processed by sub \fB\f(CB$parallel\fB\fR and the results of processing all files is processed by \fB\f(CB$results\fB\fR where the files are taken from \fB\f(CB@files\fB\fR. Each \fB&$parallel\fR receives a file from \fB\f(CB@files\fB\fR. \fB&$results\fR receives an array of all the results returned by \fB&$parallel\fR.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $parallel  Parallel sub
\&  2  $results   Results sub
\&  3  @files     Array of files to process by size
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = temporaryFolder;
\&    my @f = map {owf(fpe($d, $_, q(txt)), \*(AqX\*(Aq x ($_ ** 2 % 11))} 1..9;
\&
\&    my $f = fileLargestSize(@f);
\&    ok fn($f) eq \*(Aq3\*(Aq, \*(Aqaaa\*(Aq;
\&
\&    my $b = folderSize($d);
\&    ok $b > 0, \*(Aqbbb\*(Aq;
\&
\&
\&    my $c = processFilesInParallel(  # XXXXXXX
\&
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12);
\&
\&    ok 108 == $c, \*(Aqcc11\*(Aq;
\&
\&    my $C = processSizesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, map {[fileSize($_), $_]} (@f) x 12;
\&
\&    ok 108 == $C, \*(Aqcc2\*(Aq;
\&
\&    my $J = processJavaFilesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12;
\&
\&    ok 108 == $J, \*(Aqcc3\*(Aq;
\&
\&    clearFolder($d, 12);
.Ve
.ie n .SS "processJavaFilesInParallel($parallel, $results, @files)"
.el .SS "processJavaFilesInParallel($parallel, \f(CW$results\fP, \f(CW@files\fP)"
.IX Subsection "processJavaFilesInParallel($parallel, $results, @files)"
Process java files of known size in parallel using (the number of CPUs) processes with the process each item is assigned to depending on the size of the java item so that each process is loaded with approximately the same number of bytes of data in total from the java files it processes.
.PP
Each java item is processed by sub \fB\f(CB$parallel\fB\fR and the results of processing all java files is processed by \fB\f(CB$results\fB\fR where the java files are taken from \fB\f(CB@sizes\fB\fR. Each &$\fBparallel()\fR receives a java item from \f(CW@files\fR. &$\fBresults()\fR receives an array of all the results returned by &$\fBparallel()\fR.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $parallel  Parallel sub
\&  2  $results   Results sub
\&  3  @files     Array of [size; java item] to process by size
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $d = temporaryFolder;
\&    my @f = map {owf(fpe($d, $_, q(txt)), \*(AqX\*(Aq x ($_ ** 2 % 11))} 1..9;
\&
\&    my $f = fileLargestSize(@f);
\&    ok fn($f) eq \*(Aq3\*(Aq, \*(Aqaaa\*(Aq;
\&
\&    my $b = folderSize($d);
\&    ok $b > 0, \*(Aqbbb\*(Aq;
\&
\&    my $c = processFilesInParallel(
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12);
\&
\&    ok 108 == $c, \*(Aqcc11\*(Aq;
\&
\&    my $C = processSizesInParallel
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, map {[fileSize($_), $_]} (@f) x 12;
\&
\&    ok 108 == $C, \*(Aqcc2\*(Aq;
\&
\&
\&    my $J = processJavaFilesInParallel  # XXXXXXX
\&
\&      sub
\&       {my ($file) = @_;
\&        [&fileSize($file), $file]
\&       },
\&      sub
\&       {scalar @_;
\&       }, (@f) x 12;
\&
\&    ok 108 == $J, \*(Aqcc3\*(Aq;
\&
\&    clearFolder($d, 12);
.Ve
.ie n .SS "syncFromS3InParallel($maxSize, $source, $target, $Profile, $options)"
.el .SS "syncFromS3InParallel($maxSize, \f(CW$source\fP, \f(CW$target\fP, \f(CW$Profile\fP, \f(CW$options\fP)"
.IX Subsection "syncFromS3InParallel($maxSize, $source, $target, $Profile, $options)"
Download from S3 <https://aws.amazon.com/s3/> by using \*(L"aws s3 sync \-\-exclude '*' \-\-include '...'\*(R" in parallel to sync collections of two or more files no greater then \fB\f(CB$maxSize\fB\fR or single files greater than \f(CW$maxSize\fR from the \fB\f(CB$source\fB\fR folder on S3 <https://aws.amazon.com/s3/> to the local folder \fB\f(CB$target\fB\fR using the specified \fB\f(CB$Profile\fB\fR and \fB\f(CB$options\fB\fR \- then execute the entire command again without the \-\-exclude and \-\-include options in series which might now run faster due to the prior downloads.
.PP
.Vb 6
\&     Parameter  Description
\&  1  $maxSize   The maximum collection size
\&  2  $source    The source folder on S3
\&  3  $target    The target folder locally
\&  4  $Profile   Aws cli profile
\&  5  $options   Aws cli options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (0)
\&
\&   {syncFromS3InParallel 1e5,  # XXXXXXX
\&
\&      q(xxx/originals3/),
\&      q(/home/phil/xxx/),
\&      q(phil), q(\-\-quiet);
\&
\&    syncToS3InParallel 1e5,
\&      q(/home/phil/xxx/),
\&      q(xxx/originals3/),
\&      q(phil), q(\-\-quiet);
\&   }
.Ve
.ie n .SS "syncToS3InParallel($maxSize, $source, $target, $Profile, $options)"
.el .SS "syncToS3InParallel($maxSize, \f(CW$source\fP, \f(CW$target\fP, \f(CW$Profile\fP, \f(CW$options\fP)"
.IX Subsection "syncToS3InParallel($maxSize, $source, $target, $Profile, $options)"
Upload to S3 <https://aws.amazon.com/s3/> by using \*(L"aws s3 sync \-\-exclude '*' \-\-include '...'\*(R" in parallel to sync collections of two or more files no greater then \fB\f(CB$maxSize\fB\fR or single files greater than \f(CW$maxSize\fR from the \fB\f(CB$source\fB\fR folder locally to the target folder \fB\f(CB$target\fB\fR on S3 <https://aws.amazon.com/s3/> using the specified \fB\f(CB$Profile\fB\fR and \fB\f(CB$options\fB\fR \- then execute the entire command again without the \-\-exclude and \-\-include options in series which might now run faster due to the prior uploads.
.PP
.Vb 6
\&     Parameter  Description
\&  1  $maxSize   The maximum collection size
\&  2  $source    The target folder locally
\&  3  $target    The source folder on S3
\&  4  $Profile   Aws cli profile
\&  5  $options   Aws cli options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&  if (0)
\&   {syncFromS3InParallel 1e5,
\&      q(xxx/originals3/),
\&      q(/home/phil/xxx/),
\&      q(phil), q(\-\-quiet);
\&
\&
\&    syncToS3InParallel 1e5,  # XXXXXXX
\&
\&      q(/home/phil/xxx/),
\&      q(xxx/originals3/),
\&      q(phil), q(\-\-quiet);
\&   }
.Ve
.SS "childPids($p)"
.IX Subsection "childPids($p)"
Recursively find the pids of all the sub processes of a \fB\f(CB$process\fB\fR and all their sub processes and so on returning the specified pid and all its child pids as a list.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $p         Process
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [childPids(2702)], [2702..2705];  # XXXXXXX
.Ve
.ie n .SS "newServiceIncarnation($service, $file)"
.el .SS "newServiceIncarnation($service, \f(CW$file\fP)"
.IX Subsection "newServiceIncarnation($service, $file)"
Create a new service incarnation to record the start up of a new instance of a service and return the description as a Data::Exchange::Service Definition hash.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $service   Service name
\&  2  $file      Optional details file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {my $s = newServiceIncarnation("aaa", q(bbb.txt));  # XXXXXXX
\&
\&    is_deeply $s\->check, $s;
\&
\&    my $t = newServiceIncarnation("aaa", q(bbb.txt));  # XXXXXXX
\&
\&    is_deeply $t\->check, $t;
\&    ok $t\->start >= $s\->start+1;
\&    ok !$s\->check(1);
\&    unlink q(bbb.txt);
\&   }
.Ve
.ie n .SS "Data::Exchange::Service::check($service, $continue)"
.el .SS "Data::Exchange::Service::check($service, \f(CW$continue\fP)"
.IX Subsection "Data::Exchange::Service::check($service, $continue)"
Check that we are the current incarnation of the named service with details obtained from newServiceIncarnation. If the optional \fB\f(CB$continue\fB\fR flag has been set then return the service details if this is the current service incarnation else \fBundef\fR. Otherwise if the \fB\f(CB$continue\fB\fR flag is false confess unless this is the current service incarnation thus bringing the earlier version of this service to an abrupt end.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $service   Current service details
\&  2  $continue  Return result if B<$continue> is true else confess if the service has been replaced
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 9
\&  if (1)
\&   {my $s = newServiceIncarnation("aaa", q(bbb.txt));
\&    is_deeply $s\->check, $s;
\&    my $t = newServiceIncarnation("aaa", q(bbb.txt));
\&    is_deeply $t\->check, $t;
\&    ok $t\->start >= $s\->start+1;
\&    ok !$s\->check(1);
\&    unlink q(bbb.txt);
\&   }
.Ve
.SH "Conversions"
.IX Header "Conversions"
Perform various conversions from \s-1STDIN\s0 to \s-1STDOUT\s0
.ie n .SS "convertPerlToJavaScript($in, $out)"
.el .SS "convertPerlToJavaScript($in, \f(CW$out\fP)"
.IX Subsection "convertPerlToJavaScript($in, $out)"
Convert Perl to Javascript
.PP
.Vb 3
\&     Parameter  Description
\&  1  $in        Input file name or STDIN if undef
\&  2  $out       Output file name or STDOUT if undefined
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  if (1)
\&   {my $i = writeTempFile(<<\*(AqEND\*(Aq);
\&  sub test($$)                                                                    #P A test method
\&   {my ($file, $data) = @_;                                                       # Parameter 1, parameter 2
\&    if (fullyQualifiedFile($file)) {return qq($data)}                             # File is already fully qualified
\&   } # test
.Ve
.SH "Documentation"
.IX Header "Documentation"
Extract, format and update documentation for a perl module.
.ie n .SS "parseDitaRef($ref, $File, $TopicId)"
.el .SS "parseDitaRef($ref, \f(CW$File\fP, \f(CW$TopicId\fP)"
.IX Subsection "parseDitaRef($ref, $File, $TopicId)"
Parse a dita reference \fB\f(CB$ref\fB\fR into its components (file name, topic id, id) . Optionally supply a base file name \fB\f(CB$File\fB\fR> to make the the file component absolute and/or a a default the topic id \fB\f(CB$TopicId\fB\fR to use if the topic id is not present in the reference.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $ref       Reference to parse
\&  2  $File      Default absolute file
\&  3  $TopicId   Default topic id
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    is_deeply [parseDitaRef(q(a#b/c))], [qw(a b c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(a#./c))], [q(a), q(), q(c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(a#/c))],  [q(a), q(), q(c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(a#c))],   [q(a), q(), q(c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(#b/c))],  [q(),  qw(b c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(#b))],    [q(),  q(), q(b)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(#./c))],  [q(),  q(), q(c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(#/c))],   [q(),  q(), q(c)];  # XXXXXXX
\&
\&
\&    is_deeply [parseDitaRef(q(#c))],    [q(),  q(), q(c)];  # XXXXXXX
.Ve
.SS "parseXmlDocType($string)"
.IX Subsection "parseXmlDocType($string)"
Parse an Xml <https://en.wikipedia.org/wiki/XML> \s-1DOCTYPE\s0 and return a hash indicating its components
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing a DOCTYPE
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  if (1)
\&
\&   {is_deeply parseXmlDocType(<<END),  # XXXXXXX
\&
\&  <!DOCTYPE reference PUBLIC "\-//OASIS//DTD DITA Reference//EN" "reference.dtd">
\&  ...
\&  END
\&     {localDtd => "reference.dtd",
\&      public   => 1,
\&      publicId => "\-//OASIS//DTD DITA Reference//EN",
\&      root     => "reference",
\&     };
\&
\&
\&    is_deeply parseXmlDocType(<<END),  # XXXXXXX
\&
\&  ...
\&  <!DOCTYPE concept PUBLIC "\-//OASIS//DTD DITA Task//EN" "concept.dtd" []>
\&  ...
\&  )),
\&  END
\&       {localDtd => "concept.dtd",
\&        public   => 1,
\&        publicId => "\-//OASIS//DTD DITA Task//EN",
\&        root     => "concept",
\&       };
\&   }
.Ve
.ie n .SS "reportSettings($sourceFile, $reportFile)"
.el .SS "reportSettings($sourceFile, \f(CW$reportFile\fP)"
.IX Subsection "reportSettings($sourceFile, $reportFile)"
Report the current values of parameterless subs in a \fB\f(CB$sourceFile\fB\fR that match \eAsub\es+(\ew+)\es*\e{ and optionally write the report to \fB\f(CB$reportFile\fB\fR. Return the text of the report.
.PP
.Vb 3
\&     Parameter    Description
\&  1  $sourceFile  Source file
\&  2  $reportFile  Optional report file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  reportSettings($0);                                                               # XXXXXXX
.Ve
.SS "reportAttributes($sourceFile)"
.IX Subsection "reportAttributes($sourceFile)"
Report the attributes present in a \fB\f(CB$sourceFile\fB\fR
.PP
.Vb 2
\&     Parameter    Description
\&  1  $sourceFile  Source file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = temporaryFile;
\&
\&    my $f = writeFile(undef, <<\*(AqEND\*(Aq.<<END2);
\&  #!perl \-I/home/phil/perl/cpan/DataTableText/lib/
\&  use Data::Table::Text qw(reportAttributeSettings);
\&  sub attribute {1}                                                               # An attribute
\&  sub replaceable($)                                                              #r A replaceable method
\&   {
.Ve
.SS "reportAttributeSettings($reportFile)"
.IX Subsection "reportAttributeSettings($reportFile)"
Report the current values of the attribute methods in the calling file and optionally write the report to \fB\f(CB$reportFile\fB\fR. Return the text of the report.
.PP
.Vb 2
\&     Parameter    Description
\&  1  $reportFile  Optional report file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = temporaryFile;
\&
\&    my $f = writeFile(undef, <<\*(AqEND\*(Aq.<<END2);
\&  #!perl \-I/home/phil/perl/cpan/DataTableText/lib/
\&
\&  use Data::Table::Text qw(reportAttributeSettings);  # XXXXXXX
\&
\&  sub attribute {1}                                                               # An attribute
\&  sub replaceable($)                                                              #r A replaceable method
\&   {
.Ve
.SS "reportReplacableMethods($sourceFile)"
.IX Subsection "reportReplacableMethods($sourceFile)"
Report the replaceable methods marked with #r in a \fB\f(CB$sourceFile\fB\fR
.PP
.Vb 2
\&     Parameter    Description
\&  1  $sourceFile  Source file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = temporaryFile;
\&
\&    my $f = writeFile(undef, <<\*(AqEND\*(Aq.<<END2);
\&  #!perl \-I/home/phil/perl/cpan/DataTableText/lib/
\&  use Data::Table::Text qw(reportAttributeSettings);
\&  sub attribute {1}                                                               # An attribute
\&  sub replaceable($)                                                              #r A replaceable method
\&   {
\&
\&
\&  sub reportReplacableMethods($)                                                   # XXXXXXX
\&
\&   {my ($sourceFile) = @_;                                                        # Source file
\&    my $s = readFile($sourceFile);
\&    my %s;
\&    for my $l(split /
\&/, $s)                                                     # Find the attribute subs
\&     {if ($l =~ m(\eAsub\es*(\ew+).*?#\ew*r\ew*\es+(.*)\eZ))
\&       {$s{$1} = $2;
\&       }
\&     }
\&    \e%s
\&   }
.Ve
.SS "reportExportableMethods($sourceFile)"
.IX Subsection "reportExportableMethods($sourceFile)"
Report the exportable methods marked with #e in a \fB\f(CB$sourceFile\fB\fR
.PP
.Vb 2
\&     Parameter    Description
\&  1  $sourceFile  Source file
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $d = temporaryFile;
\&
\&    my $f = writeFile(undef, <<\*(AqEND\*(Aq.<<END2);
\&  #!perl \-I/home/phil/perl/cpan/DataTableText/lib/
\&  use Data::Table::Text qw(reportAttributeSettings);
\&  sub attribute {1}                                                               # An attribute
\&  sub replaceable($)                                                              #r A replaceable method
\&   {
.Ve
.ie n .SS "htmlToc($replace, $html)"
.el .SS "htmlToc($replace, \f(CW$html\fP)"
.IX Subsection "htmlToc($replace, $html)"
Generate a table of contents for some html.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $replace   Sub\-string within the html to be replaced with the toc
\&  2  $html      String of html
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok nws(htmlToc("XXXX", <<END)), \*(AqhtmlToc\*(Aq                                         # XXXXXXX
\&
\&  <h1 id="1" otherprops="1">Chapter 1</h1>
\&    <h2 id="11" otherprops="11">Section 1</h1>
\&  <h1 id="2" otherprops="2">Chapter 2</h1>
\&  XXXX
\&  END
\&
\&    eq nws(<<END);
\&  <h1 id="1" otherprops="1">Chapter 1</h1>
\&    <h2 id="11" otherprops="11">Section 1</h1>
\&  <h1 id="2" otherprops="2">Chapter 2</h1>
\&  <table cellspacing=10 border=0>
\&  <tr><td>&nbsp;
\&  <tr><td align=right>1<td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#1">Chapter 1</a>
\&  <tr><td align=right>2<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#11">Section 1</a>
\&  <tr><td>&nbsp;
\&  <tr><td align=right>3<td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#2">Chapter 2</a>
\&  </table>
\&  END
.Ve
.SS "expandWellKnownUrlsInPerlFormat($string)"
.IX Subsection "expandWellKnownUrlsInPerlFormat($string)"
Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L<url\-name> using the Perl \s-1POD\s0 syntax
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing url names to expand
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok expandWellKnownUrlsInDitaFormat(q(L[github])) eq
\&      q(<xref scope="external" format="html" href="https://github.com">GitHub</xref>);
\&
\&    ok expandWellKnownUrlsInHtmlFormat(q(L[github])) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(L<GitHub|https://github.com>)) eq  # XXXXXXX
\&
\&      q(L<GitHub|https://github.com>);
\&
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(github))    eq q(github);  # XXXXXXX
\&
\&
\&    ok expandWellKnownUrlsInHtmlFromPerl(q(L<GitHub|https://github.com>)) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPod2Html(<<END) eq eval \*(Aq"aaa
.Ve
.PP
bbb
"';
  aaa GitHub <https://github.com> bbb
  \s-1END\s0
.SS "expandWellKnownUrlsInHtmlFormat($string)"
.IX Subsection "expandWellKnownUrlsInHtmlFormat($string)"
Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] using the html \fBa\fR tag.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing url names to expand
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok expandWellKnownUrlsInDitaFormat(q(L[github])) eq
\&      q(<xref scope="external" format="html" href="https://github.com">GitHub</xref>);
\&
\&
\&    ok expandWellKnownUrlsInHtmlFormat(q(L[github])) eq  # XXXXXXX
\&
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(L<GitHub|https://github.com>)) eq
\&      q(L<GitHub|https://github.com>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(github))    eq q(github);
\&
\&    ok expandWellKnownUrlsInHtmlFromPerl(q(L<GitHub|https://github.com>)) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPod2Html(<<END) eq eval \*(Aq"aaa
.Ve
.PP
bbb
"';
  aaa GitHub <https://github.com> bbb
  \s-1END\s0
.SS "expandWellKnownUrlsInHtmlFromPerl($string)"
.IX Subsection "expandWellKnownUrlsInHtmlFromPerl($string)"
Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] using the html \fBa\fR tag.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing url names to expand
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok expandWellKnownUrlsInDitaFormat(q(L[github])) eq
\&      q(<xref scope="external" format="html" href="https://github.com">GitHub</xref>);
\&
\&    ok expandWellKnownUrlsInHtmlFormat(q(L[github])) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(L<GitHub|https://github.com>)) eq
\&      q(L<GitHub|https://github.com>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(github))    eq q(github);
\&
\&
\&    ok expandWellKnownUrlsInHtmlFromPerl(q(L<GitHub|https://github.com>)) eq  # XXXXXXX
\&
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPod2Html(<<END) eq eval \*(Aq"aaa
.Ve
.PP
bbb
"';
  aaa GitHub <https://github.com> bbb
  \s-1END\s0
.SS "expandWellKnownUrlsInPod2Html($string)"
.IX Subsection "expandWellKnownUrlsInPod2Html($string)"
Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format =begin html format
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing url names to expand
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    ok expandWellKnownUrlsInDitaFormat(q(L[github])) eq
\&      q(<xref scope="external" format="html" href="https://github.com">GitHub</xref>);
\&
\&    ok expandWellKnownUrlsInHtmlFormat(q(L[github])) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(L<GitHub|https://github.com>)) eq
\&      q(L<GitHub|https://github.com>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(github))    eq q(github);
\&
\&    ok expandWellKnownUrlsInHtmlFromPerl(q(L<GitHub|https://github.com>)) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&
\&    ok expandWellKnownUrlsInPod2Html(<<END) eq eval \*(Aq"aaa
.Ve
.PP
bbb
"';  # \s-1XXXXXXX\s0
.PP
.Vb 2
\&  aaa L<GitHub|https://github.com> bbb
\&  END
.Ve
.SS "expandWellKnownUrlsInDitaFormat($string)"
.IX Subsection "expandWellKnownUrlsInDitaFormat($string)"
Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] in the L[Dita] \fBxref\fRformat.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing url names to expand
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    ok expandWellKnownUrlsInDitaFormat(q(L[github])) eq  # XXXXXXX
\&
\&      q(<xref scope="external" format="html" href="https://github.com">GitHub</xref>);
\&
\&    ok expandWellKnownUrlsInHtmlFormat(q(L[github])) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(L<GitHub|https://github.com>)) eq
\&      q(L<GitHub|https://github.com>);
\&
\&    ok expandWellKnownUrlsInPerlFormat(q(github))    eq q(github);
\&
\&    ok expandWellKnownUrlsInHtmlFromPerl(q(L<GitHub|https://github.com>)) eq
\&      q(<a format="html" href="https://github.com">GitHub</a>);
\&
\&    ok expandWellKnownUrlsInPod2Html(<<END) eq eval \*(Aq"aaa
.Ve
.PP
bbb
"';
  aaa GitHub <https://github.com> bbb
  \s-1END\s0
.SS "expandNewLinesInDocumentation($s)"
.IX Subsection "expandNewLinesInDocumentation($s)"
Expand new lines in documentation, specifically
 for new line and
.PP
.Vb 1
\& for two new lines.
\&
\&     Parameter  Description
\&  1  $s         String to be expanded
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok expandNewLinesInDocumentation(q(a
\&
\&  b
\&  c
\&)) eq <<END;  # XXXXXXX
\&
\&  a
\&
\&    b
\&    c
\&  END
.Ve
.ie n .SS "extractCodeBlock($comment, $file)"
.el .SS "extractCodeBlock($comment, \f(CW$file\fP)"
.IX Subsection "extractCodeBlock($comment, $file)"
Extract the block of code delimited by \fB\f(CB$comment\fB\fR, starting at qq($comment\-begin), ending at qq($comment\-end) from the named \fB\f(CB$file\fB\fR else the current Perl program \f(CW$0\fR and return it as a string or confess if this is not possible.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $comment   Comment delimiting the block of code
\&  2  $file      File to read from if not $0
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&  ok extractCodeBlock(q(#CODEBLOCK), $INC{"Data/Table/Text.pm"}) eq <<\*(AqEND\*(Aq;  # XXXXXXX
\&
\&    my $a = 1;
\&    my $b = 2;
\&  END
.Ve
.SS "updateDocumentation($perlModule)"
.IX Subsection "updateDocumentation($perlModule)"
Update the documentation for a Perl module from the comments in its source code. Comments between the lines marked with:
.PP
.Vb 1
\&  #Dn title # description
.Ve
.PP
and:
.PP
.Vb 1
\&  #D
.Ve
.PP
where n is either 1, 2 or 3 indicating the heading level of the section and the # is in column 1.
.PP
Methods are formatted as:
.PP
.Vb 2
\&  sub name(signature)      #FLAGS comment describing method
\&   {my ($parameters) = @_; # comments for each parameter separated by commas.
.Ve
.PP
\&\s-1FLAGS\s0 can be chosen from:
.IP "I" 4
.IX Item "I"
method of interest to new users
.IP "P" 4
.IX Item "P"
private method
.IP "r" 4
.IX Item "r"
optionally replaceable method
.IP "R" 4
.IX Item "R"
required replaceable method
.IP "S" 4
.IX Item "S"
static method
.IP "X" 4
.IX Item "X"
die rather than received a returned \fBundef\fR result
.PP
Other flags will be handed to the method extractDocumentationFlags(flags to process, method name) found in the file being documented, this method should return [the additional documentation for the method, the code to implement the flag].
.PP
Text following 'Example:' in the comment (if present) will be placed after the parameters list as an example. Lines containing comments consisting of '#T'.methodName will also be aggregated and displayed as examples for that method.
.PP
Lines formatted as:
.PP
.Vb 1
\&  BEGIN{*source=*target}
.Ve
.PP
starting in column 1 will define a synonym for a method.
.PP
Lines formatted as:
.PP
.Vb 1
\&  #C emailAddress text
.Ve
.PP
will be aggregated in the acknowledgments section at the end of the documentation.
.PP
The character sequence \fB\en\fR in the comment will be expanded to one new line, \fB\em\fR to two new lines and \fBL\fR\fB<$_\fR>,\fBL\fR\fB<confess\fR>,\fBL\fR\fB<die\fR>,\fBL\fR\fB<eval\fR>,\fBL\fR\fB<lvalueMethod\fR> to links to the perl documentation.
.PP
Search for '#D1': in <https://metacpan.org/source/PRBRENAN/Data\-Table\-Text\-20180810/lib/Data/Table/Text.pm> to see  more examples of such documentation in action \- although it is quite difficult to see as it looks just like normal comments placed in the code.
.PP
Parameters:
.PP
.Vb 2
\&     Parameter    Description
\&  1  $perlModule  Optional file name with caller\*(Aqs file being the default
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&   {my $s = updateDocumentation(<<\*(AqEND\*(Aq =~ s(#) (#)gsr =~ s(~) ()gsr);              # XXXXXXX
\&
\&  package Sample::Module;
\&
\&  #D1 Samples                                                                      # Sample methods.
\&
\&  sub sample($@)                                                                  #R Documentation for the:  sample() method.  See also L<Data::Table::Text::sample2|/Data::Table::Text::sample2>. #Tsample .
\&   {my ($node, @context) = @_;                                                    # Node, optional context
\&    1
\&   }
\&
\&  ~BEGIN{*smpl=*sample}
\&
\&  sub Data::Table::Text::sample2(\e&@)                                             #PS Documentation for the sample2() method.
\&   {my ($sub, @context) = @_;                                                     # Sub to call, context.
\&    1
\&   }
\&
\&  ok sample(undef, qw(a b c)) == 1;                                               #Tsample
\&
\&  if (1)                                                                          #Tsample
\&   {ok sample(q(a), qw(a b c))  == 2;
\&    ok sample(undef, qw(a b c)) == 1;
\&   }
\&
\&  ok sample(<<END2)) == 1;                                                        #Tsample
\&  sample data
\&  END2
\&
\&    ok $s =~ m/=head2 Data::Table::Text::sample2.\e$sub, \e@context/;
.Ve
.SS "Data::Exchange::Service Definition"
.IX Subsection "Data::Exchange::Service Definition"
Service details.
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
file
.IX Subsection "file"
.PP
The file in which the service start details is being recorded.
.PP
service
.IX Subsection "service"
.PP
The name of the service.
.PP
start
.IX Subsection "start"
.PP
The time this service was started time plus a minor hack to simplify testing.
.SS "Data::Table::Text::AwsEc2Price Definition"
.IX Subsection "Data::Table::Text::AwsEc2Price Definition"
Prices of selected aws ec2 instance types
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
cheapestInstance
.IX Subsection "cheapestInstance"
.PP
The instance type that has the lowest \s-1CPU\s0 cost
.PP
pricePerCpu
.IX Subsection "pricePerCpu"
.PP
The cost of the cheapest \s-1CPU\s0 In millidollars per hour
.PP
report
.IX Subsection "report"
.PP
Report showing the cost of other selected instances
.SS "Data::Table::Text::Python::Documentation Definition"
.IX Subsection "Data::Table::Text::Python::Documentation Definition"
Documentation extracted from Python source files
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
classDefinitions
.IX Subsection "classDefinitions"
.PP
Class definitions
.PP
classFiles
.IX Subsection "classFiles"
.PP
Class files
.PP
comments
.IX Subsection "comments"
.PP
Comments for each def
.PP
errors
.IX Subsection "errors"
.PP
Errors encountered
.PP
parameters
.IX Subsection "parameters"
.PP
Parameters for each def
.PP
tests
.IX Subsection "tests"
.PP
Tests for each def
.PP
testsCommon
.IX Subsection "testsCommon"
.PP
Common line for tests
.SS "Data::Table::Text::Starter Definition"
.IX Subsection "Data::Table::Text::Starter Definition"
Process starter definition.
.PP
\fIInput fields\fR
.IX Subsection "Input fields"
.PP
processingLogFile
.IX Subsection "processingLogFile"
.PP
Optional: name of a file to which process start and end information should be appended
.PP
processingTitle
.IX Subsection "processingTitle"
.PP
Optional: title describing the processing being performed.
.PP
totalToBeStarted
.IX Subsection "totalToBeStarted"
.PP
Optionally: the total number of processes to be started \- if this is supplied then an estimate of the finish time for this processing is printed to the log file every time a process starts or finishes.
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
autoRemoveTransferArea
.IX Subsection "autoRemoveTransferArea"
.PP
If true then automatically clear the transfer area at the end of processing.
.PP
maximumNumberOfProcesses
.IX Subsection "maximumNumberOfProcesses"
.PP
The maximum number of processes to start in parallel at one time. If this limit is exceeded, the start of subsequent processes will be delayed until processes started earlier have finished.
.PP
pids
.IX Subsection "pids"
.PP
A hash of pids representing processes started but not yet completed.
.PP
processFinishTime
.IX Subsection "processFinishTime"
.PP
{pid} == time the process finished.
.PP
processStartTime
.IX Subsection "processStartTime"
.PP
{pid} == time the process was started.
.PP
processingLogFileHandle
.IX Subsection "processingLogFileHandle"
.PP
Handle for log file if a log file was supplied
.PP
resultsArray
.IX Subsection "resultsArray"
.PP
Consolidated array of results.
.PP
startTime
.IX Subsection "startTime"
.PP
Start time
.PP
transferArea
.IX Subsection "transferArea"
.PP
The name of the folder in which files transferring results from the child to the parent process will be stored.
.SS "TestHash Definition"
.IX Subsection "TestHash Definition"
Definition of a blessed hash.
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
a
.IX Subsection "a"
.PP
Definition of attribute aa.
.PP
b
.IX Subsection "b"
.PP
Definition of attribute bb.
.PP
c
.IX Subsection "c"
.PP
Definition of attribute cc.
.SS "Udsr Definition"
.IX Subsection "Udsr Definition"
Package name
.PP
\fIInput fields\fR
.IX Subsection "Input fields"
.PP
headerLength
.IX Subsection "headerLength"
.PP
Length of fixed header which carries the length of the following message
.PP
serverAction
.IX Subsection "serverAction"
.PP
Server action sub, which receives a communicator every time a client creates a new connection. If this server is going to be started by systemd  as a service with the specified serverName then this is the a actual text of the code that will be installed as a \s-1CGI\s0 script and run in response to an incoming transaction in a separate process with the userid set to serviceUser. It receives the text of the http request from the browser as parameter 1 and should return the text to be sent back to the browser.
.PP
serviceName
.IX Subsection "serviceName"
.PP
Service name for install by systemd
.PP
serviceUser
.IX Subsection "serviceUser"
.PP
Userid for service
.PP
socketPath
.IX Subsection "socketPath"
.PP
Socket file
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
client
.IX Subsection "client"
.PP
Client socket and connection socket
.PP
serverPid
.IX Subsection "serverPid"
.PP
Server pid which can be used to kill the server via kill q(kill), \f(CW$pid\fR
.SH "Attributes"
.IX Header "Attributes"
The following is a list of all the attributes in this package.  A method coded
with the same name in your package will over ride the method of the same name
in this package and thus provide your value for the attribute in place of the
default value supplied for this attribute by this package.
.SS "Replaceable Attribute List"
.IX Subsection "Replaceable Attribute List"
awsEc2DescribeInstancesCache awsIpFile nameFromStringMaximumLength wwwHeader
.SS "awsEc2DescribeInstancesCache"
.IX Subsection "awsEc2DescribeInstancesCache"
File in which to cache latest results from describe instances to avoid being throttled
.SS "awsIpFile"
.IX Subsection "awsIpFile"
File in which to save \s-1IP\s0 address of primary instance on Aws
.SS "nameFromStringMaximumLength"
.IX Subsection "nameFromStringMaximumLength"
Maximum length of a name generated from a string
.SS "wwwHeader"
.IX Subsection "wwwHeader"
Html header
.SH "Private Methods"
.IX Header "Private Methods"
.SS "denormalizeFolderName($name)"
.IX Subsection "denormalizeFolderName($name)"
Remove any trailing folder separator from a folder name.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $name      Folder name
.Ve
.SS "renormalizeFolderName($name)"
.IX Subsection "renormalizeFolderName($name)"
Normalize a folder name by ensuring it has a single trailing directory separator.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $name      Name
.Ve
.SS "findAllFilesAndFolders($folder)"
.IX Subsection "findAllFilesAndFolders($folder)"
Find all the files and folders under a folder.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $folder    Folder to start the search with
.Ve
.SS "readUtf16File($file)"
.IX Subsection "readUtf16File($file)"
Read a file containing Unicode <https://en.wikipedia.org/wiki/Unicode> encoded in utf\-16.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $file      Name of file to read
.Ve
.SS "\fBbinModeAllUtf8()\fP"
.IX Subsection "binModeAllUtf8()"
Set \s-1STDOUT\s0 and \s-1STDERR\s0 to accept utf8 without complaint.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    binModeAllUtf8;                                                                 # XXXXXXX
.Ve
.ie n .SS "convertImageToJpx690($Source, $target, $Size, $Tiles)"
.el .SS "convertImageToJpx690($Source, \f(CW$target\fP, \f(CW$Size\fP, \f(CW$Tiles\fP)"
.IX Subsection "convertImageToJpx690($Source, $target, $Size, $Tiles)"
Convert a \fB\f(CB$source\fB\fR image to a \fB\f(CB$target\fB\fR image in jpx format using versions of Imagemagick <https://www.imagemagick.org/script/index.php> version 6.9.0 and above. The size in pixels of each jpx tile may be specified by the optional \fB\f(CB$Size\fB\fR parameter which defaults to \fB256\fR. \fB\f(CB$Tiles\fB\fR optionally provides an upper limit on the number of each tiles in each dimension.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $Source    Source file
\&  2  $target    Target folder (as multiple files will be created)
\&  3  $Size      Optional size of each tile \- defaults to 256
\&  4  $Tiles     Optional limit on the number of tiles in either dimension
.Ve
.ie n .SS "convertImageToJpx($Source, $target, $Size, $Tiles)"
.el .SS "convertImageToJpx($Source, \f(CW$target\fP, \f(CW$Size\fP, \f(CW$Tiles\fP)"
.IX Subsection "convertImageToJpx($Source, $target, $Size, $Tiles)"
Convert a \fB\f(CB$source\fB\fR image to a \fB\f(CB$target\fB\fR image in jpx format. The size in pixels of each jpx tile may be specified by the optional \fB\f(CB$Size\fB\fR parameter which defaults to \fB256\fR. \fB\f(CB$Tiles\fB\fR optionally provides an upper limit on the number of each tiles in each dimension.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $Source    Source file
\&  2  $target    Target folder (as multiple files will be created)
\&  3  $Size      Optional size of each tile \- defaults to 256
\&  4  $Tiles     Optional limit in either direction on the number of tiles
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    convertImageToJpx(fpe(qw(a image jpg)), fpe(qw(a image jpg)), 256);             # XXXXXXX
.Ve
.SS "setCombination(@s)"
.IX Subsection "setCombination(@s)"
Count the elements in sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
.Vb 2
\&     Parameter  Description
\&  1  @s         Array of arrays of strings and/or hashes
.Ve
.ie n .SS "formatTableMultiLine($data, $separator)"
.el .SS "formatTableMultiLine($data, \f(CW$separator\fP)"
.IX Subsection "formatTableMultiLine($data, $separator)"
Tabularize text that has new lines in it.
.PP
.Vb 3
\&     Parameter   Description
\&  1  $data       Reference to an array of arrays of data to be formatted as a table
\&  2  $separator  Optional line separator to use instead of new line for each row.
.Ve
.SS "formatTableClearUpLeft($data)"
.IX Subsection "formatTableClearUpLeft($data)"
Blank identical column values up and left
.PP
.Vb 2
\&     Parameter  Description
\&  1  $data      Array of arrays
.Ve
.ie n .SS "formatTableAA($data, $title, %options)"
.el .SS "formatTableAA($data, \f(CW$title\fP, \f(CW%options\fP)"
.IX Subsection "formatTableAA($data, $title, %options)"
Tabularize an array of arrays.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $data      Data to be formatted
\&  2  $title     Reference to an array of titles
\&  3  %options   Options
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&   ok formatTable
\&    ([[1,1,1],[1,1,2],[1,2,2],[1,2,3]], [], clearUpLeft=>1) eq <<END;             # Clear matching columns
\&
\&  1  1  1  1
\&  2        2
\&  3     2  2
\&  4        3
\&  END
.Ve
.ie n .SS "formatTableHA($data, $title)"
.el .SS "formatTableHA($data, \f(CW$title\fP)"
.IX Subsection "formatTableHA($data, $title)"
Tabularize a hash of arrays.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Data to be formatted
\&  2  $title     Optional titles
.Ve
.SS "formatTableAH($data)"
.IX Subsection "formatTableAH($data)"
Tabularize an array of hashes.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $data      Data to be formatted
.Ve
.SS "formatTableHH($data)"
.IX Subsection "formatTableHH($data)"
Tabularize a hash of hashes.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $data      Data to be formatted
.Ve
.ie n .SS "formatTableA($data, $title)"
.el .SS "formatTableA($data, \f(CW$title\fP)"
.IX Subsection "formatTableA($data, $title)"
Tabularize an array.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Data to be formatted
\&  2  $title     Optional title
.Ve
.ie n .SS "formatTableH($data, $title)"
.el .SS "formatTableH($data, \f(CW$title\fP)"
.IX Subsection "formatTableH($data, $title)"
Tabularize a hash.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $data      Data to be formatted
\&  2  $title     Optional title
.Ve
.SS "\fBformatTableCheckKeys()\fP"
.IX Subsection "formatTableCheckKeys()"
Options available for formatting tables
.ie n .SS "reloadHashes2($d, $progress)"
.el .SS "reloadHashes2($d, \f(CW$progress\fP)"
.IX Subsection "reloadHashes2($d, $progress)"
Ensures that all the hashes within a tower of data structures have LValue methods to get and set their current keys.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $d         Data structure
\&  2  $progress  Progress
.Ve
.ie n .SS "showHashes2($d, $keys, $progress)"
.el .SS "showHashes2($d, \f(CW$keys\fP, \f(CW$progress\fP)"
.IX Subsection "showHashes2($d, $keys, $progress)"
Create a map of all the keys within all the hashes within a tower of data structures.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $d         Data structure
\&  2  $keys      Keys found
\&  3  $progress  Progress
.Ve
.SS "showHashes($d)"
.IX Subsection "showHashes($d)"
Create a map of all the keys within all the hashes within a tower of data structures.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $d         Data structure
.Ve
.SS "newUdsr(@parms)"
.IX Subsection "newUdsr(@parms)"
Create a communicator \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
.Vb 2
\&     Parameter  Description
\&  1  @parms     Attributes per L<Udsr Definition|/Udsr Definition>
.Ve
.SS "awsInstanceId(%options)"
.IX Subsection "awsInstanceId(%options)"
Create an instance-id from the specified \fB\f(CB%options\fB\fR
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.SS "awsProfile(%options)"
.IX Subsection "awsProfile(%options)"
Create a profile keyword from the specified \fB\f(CB%options\fB\fR
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.SS "awsRegion(%options)"
.IX Subsection "awsRegion(%options)"
Create a region keyword from the specified \fB\f(CB%options\fB\fR
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.SS "\fBgetNumberOfCpus()\fP"
.IX Subsection "getNumberOfCpus()"
Number of cpus
.ie n .SS "saveSourceToS3($aws, $saveIntervalInSeconds)"
.el .SS "saveSourceToS3($aws, \f(CW$saveIntervalInSeconds\fP)"
.IX Subsection "saveSourceToS3($aws, $saveIntervalInSeconds)"
Save source code.
.PP
.Vb 3
\&     Parameter               Description
\&  1  $aws                    Aws target file and keywords
\&  2  $saveIntervalInSeconds  Save internal
.Ve
.ie n .SS "awsParallelProcessFilesTestParallel($userData, $file)"
.el .SS "awsParallelProcessFilesTestParallel($userData, \f(CW$file\fP)"
.IX Subsection "awsParallelProcessFilesTestParallel($userData, $file)"
Test running on Amazon Web Services <http://aws.amazon.com> in parallel.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $userData  User data
\&  2  $file      File to process.
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $N = 2001;                                                                 # Number of files to process
\&    my $options = q(region => q(us\-east\-2), profile=>q(fmc));                     # Aws cli options
\&    my %options = eval "($options)";
\&
\&    for my $dir(q(/home/phil/perl/cpan/DataTableText/lib/Data/Table/),            # Folders we will need on aws
\&                q(/home/phil/.aws/))
\&     {awsParallelSpreadFolder($dir, %options);
\&     }
\&
\&    my $d = temporaryFolder;                                                      # Create a temporary folder
\&    my $resultsFile = fpe($d, qw(results data));                                  # Save results in this temporary file
\&
\&    if (my $r = execPerlOnRemote(join "
\&",                                       # Execute some code on a server
\&
\&      getCodeContext(\e&awsParallelProcessFilesTestParallel),                      # Get code context of the sub we want to call.  # XXXXXXX
\&
\&      <<SESSIONLEADER))                                                           # Launch code on session leader
\&  use Data::Table::Text qw(:all);
\&
\&  my \e$r = awsParallelProcessFiles                                                # Process files on multiple L<Amazon Web Services|http://aws.amazon.com> instances in parallel
\&   ({file=>4, time=>timeStamp},                                                   # User data
\&
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestParallel,                   # Reference to code to execute in parallel on each session instance  # XXXXXXX
\&
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestResults,                    # Reference to code to execute in series to merge the results of each parallel computation
\&    [map {writeFile(fpe(q($d), \e$_, qw(txt)), \e$_)} 1..$N],                       # Files to process
\&    $options);                                                                    # Aws cli options as we will be running on Aws
\&
\&  storeFile(q($resultsFile), \e$r);                                                # Save results in a file
\&
\&  SESSIONLEADER
\&
\&     {copyFileFromRemote($resultsFile);                                           # Retrieve user data
\&
\&      my $userData = retrieveFile($resultsFile);                                  # Recover user data
\&      my @i = awsParallelSecondaryIpAddresses(%options);                          # Ip addresses of secondary instances
\&      my @I = keys $userData\->{ip}\->%*;
\&      is_deeply [sort @i], [sort @I];                                             # Each secondary ip address was used
\&
\&      ok $userData\->{file}  == 4;                                                 # Prove we can pass data in and get it back
\&      ok $userData\->{merge} == 1 + @i, \*(Aqii\*(Aq;                                      # Number of merges
\&
\&      my %f; my %i;                                                               # Files processed on each ip
\&      for   my $i(sort keys $userData\->{ipFile}\->%*)                              # Ip
\&       {for my $f(sort keys $userData\->{ipFile}{$i}\->%*)                          # File
\&         {$f{fn($f)}++;                                                           # Files processed
\&          $i{$i}++;                                                               # Count files on each ip
\&         }
\&       }
\&
\&      is_deeply \e%f, {map {$_=>1} 1..$N};                                         # Check each file was processed
\&
\&      if (1)
\&       {my @rc; my @ra;                                                           # Range of number of files processed on each ip \- computed, actually counted
\&        my $l = $N/@i\-1;                                                          # Lower limit of number of files per IP address
\&        my $h = $N/@i+1;                                                          # Upper limit of number of files per IP address
\&        for   my $i(keys %i)
\&         {my $nc = $i{$i};                                                        # Number of files processed on this ip \- computed
\&          my $na = $userData\->{ip}{$i};                                           # Number of files processed on this ip \- actually counted
\&          push @rc, ($nc >= $l and $nc <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&          push @ra, ($na >= $l and $na <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&         }
\&        ok @i == grep {$_} @ra;                                                   # Check each ip processed the expected number of files
\&        ok @i == grep {$_} @rc;
\&       }
\&
\&      ok $userData\->{files}{&fpe($d, qw(4 txt))} eq                               # Check the computed MD5 sum for the specified file
\&         q(a87ff679a2f3e71d9181a67b7542122c);
\&     }
.Ve
.ie n .SS "awsParallelProcessFilesTestResults($userData, @results)"
.el .SS "awsParallelProcessFilesTestResults($userData, \f(CW@results\fP)"
.IX Subsection "awsParallelProcessFilesTestResults($userData, @results)"
Test results of running on Amazon Web Services <http://aws.amazon.com> in parallel.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $userData  User data from primary instance instance or process
\&  2  @results   Results from each parallel instance or process
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $N = 2001;                                                                 # Number of files to process
\&    my $options = q(region => q(us\-east\-2), profile=>q(fmc));                     # Aws cli options
\&    my %options = eval "($options)";
\&
\&    for my $dir(q(/home/phil/perl/cpan/DataTableText/lib/Data/Table/),            # Folders we will need on aws
\&                q(/home/phil/.aws/))
\&     {awsParallelSpreadFolder($dir, %options);
\&     }
\&
\&    my $d = temporaryFolder;                                                      # Create a temporary folder
\&    my $resultsFile = fpe($d, qw(results data));                                  # Save results in this temporary file
\&
\&    if (my $r = execPerlOnRemote(join "
\&",                                       # Execute some code on a server
\&      getCodeContext(\e&awsParallelProcessFilesTestParallel),                      # Get code context of the sub we want to call.
\&      <<SESSIONLEADER))                                                           # Launch code on session leader
\&  use Data::Table::Text qw(:all);
\&
\&  my \e$r = awsParallelProcessFiles                                                # Process files on multiple L<Amazon Web Services|http://aws.amazon.com> instances in parallel
\&   ({file=>4, time=>timeStamp},                                                   # User data
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestParallel,                   # Reference to code to execute in parallel on each session instance
\&
\&    \e\e\e&Data::Table::Text::awsParallelProcessFilesTestResults,                    # Reference to code to execute in series to merge the results of each parallel computation  # XXXXXXX
\&
\&    [map {writeFile(fpe(q($d), \e$_, qw(txt)), \e$_)} 1..$N],                       # Files to process
\&    $options);                                                                    # Aws cli options as we will be running on Aws
\&
\&  storeFile(q($resultsFile), \e$r);                                                # Save results in a file
\&
\&  SESSIONLEADER
\&
\&     {copyFileFromRemote($resultsFile);                                           # Retrieve user data
\&
\&      my $userData = retrieveFile($resultsFile);                                  # Recover user data
\&      my @i = awsParallelSecondaryIpAddresses(%options);                          # Ip addresses of secondary instances
\&      my @I = keys $userData\->{ip}\->%*;
\&      is_deeply [sort @i], [sort @I];                                             # Each secondary ip address was used
\&
\&      ok $userData\->{file}  == 4;                                                 # Prove we can pass data in and get it back
\&      ok $userData\->{merge} == 1 + @i, \*(Aqii\*(Aq;                                      # Number of merges
\&
\&      my %f; my %i;                                                               # Files processed on each ip
\&      for   my $i(sort keys $userData\->{ipFile}\->%*)                              # Ip
\&       {for my $f(sort keys $userData\->{ipFile}{$i}\->%*)                          # File
\&         {$f{fn($f)}++;                                                           # Files processed
\&          $i{$i}++;                                                               # Count files on each ip
\&         }
\&       }
\&
\&      is_deeply \e%f, {map {$_=>1} 1..$N};                                         # Check each file was processed
\&
\&      if (1)
\&       {my @rc; my @ra;                                                           # Range of number of files processed on each ip \- computed, actually counted
\&        my $l = $N/@i\-1;                                                          # Lower limit of number of files per IP address
\&        my $h = $N/@i+1;                                                          # Upper limit of number of files per IP address
\&        for   my $i(keys %i)
\&         {my $nc = $i{$i};                                                        # Number of files processed on this ip \- computed
\&          my $na = $userData\->{ip}{$i};                                           # Number of files processed on this ip \- actually counted
\&          push @rc, ($nc >= $l and $nc <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&          push @ra, ($na >= $l and $na <= $h) ? 1 : 0;                            # 1 \- in range, 0 \- out of range
\&         }
\&        ok @i == grep {$_} @ra;                                                   # Check each ip processed the expected number of files
\&        ok @i == grep {$_} @rc;
\&       }
\&
\&      ok $userData\->{files}{&fpe($d, qw(4 txt))} eq                               # Check the computed MD5 sum for the specified file
\&         q(a87ff679a2f3e71d9181a67b7542122c);
\&     }
.Ve
.SS "s3Profile(%options)"
.IX Subsection "s3Profile(%options)"
Return an S3 profile keyword from an S3 option set
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.SS "s3Delete(%options)"
.IX Subsection "s3Delete(%options)"
Return an S3 \-\-delete keyword from an S3 option set
.PP
.Vb 2
\&     Parameter  Description
\&  1  %options   Options
.Ve
.ie n .SS "Data::Table::Text::Starter::logEntry($starter, $finish)"
.el .SS "Data::Table::Text::Starter::logEntry($starter, \f(CW$finish\fP)"
.IX Subsection "Data::Table::Text::Starter::logEntry($starter, $finish)"
Create a log entry showing progress and eta.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $starter   Starter
\&  2  $finish    0 \- start; 1 \- finish
.Ve
.SS "Data::Table::Text::Starter::averageProcessTime($starter)"
.IX Subsection "Data::Table::Text::Starter::averageProcessTime($starter)"
Average elapsed time spent by each process
.PP
.Vb 2
\&     Parameter  Description
\&  1  $starter   Starter
.Ve
.ie n .SS "Data::Table::Text::Starter::say($starter, @message)"
.el .SS "Data::Table::Text::Starter::say($starter, \f(CW@message\fP)"
.IX Subsection "Data::Table::Text::Starter::say($starter, @message)"
Write to the log file if it is available.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $starter   Starter
\&  2  @message   Text to write to log file.
.Ve
.SS "Data::Table::Text::Starter::waitOne($starter)"
.IX Subsection "Data::Table::Text::Starter::waitOne($starter)"
Wait for at least one process to finish and consolidate its results.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $starter   Starter
.Ve
.SS "countSquareArray(@square)"
.IX Subsection "countSquareArray(@square)"
Count the number of elements in a square array
.PP
.Vb 2
\&     Parameter  Description
\&  1  @square    Array of arrays
.Ve
.ie n .SS "processSizesInParallelN($N, $parallel, $results, @sizes)"
.el .SS "processSizesInParallelN($N, \f(CW$parallel\fP, \f(CW$results\fP, \f(CW@sizes\fP)"
.IX Subsection "processSizesInParallelN($N, $parallel, $results, @sizes)"
Process items of known size in parallel using the specified number \fB\f(CB$N\fB\fR processes with the process each file is assigned to depending on the size of the file so that each process is loaded with approximately the same number of bytes of data in total from the files it processes.
.PP
Each file is processed by sub \fB\f(CB$parallel\fB\fR and the results of processing all files is processed by \fB\f(CB$results\fB\fR where the files are taken from \fB\f(CB@files\fB\fR. Each \fB&$parallel\fR receives a file from \fB\f(CB@files\fB\fR. \fB&$results\fR receives an array of all the results returned by \fB&$parallel\fR.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $N         Number of processes
\&  2  $parallel  Parallel sub
\&  3  $results   Results sub
\&  4  @sizes     Array of [size; item] to process by size
.Ve
.SS "\fBwellKnownUrls()\fP"
.IX Subsection "wellKnownUrls()"
Short names for some well known urls
.SS "reinstateWellKnown($string)"
.IX Subsection "reinstateWellKnown($string)"
Contract references to well known Urls to their abbreviated form
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    Source string
.Ve
.SS "\fBformatSourcePodAsHtml()\fP"
.IX Subsection "formatSourcePodAsHtml()"
Format the \s-1POD\s0 <https://perldoc.perl.org/perlpod.html> in the current source file as \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML>.
.SS "extractTest($string)"
.IX Subsection "extractTest($string)"
Remove example markers from test code.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $string    String containing test line
.Ve
.ie n .SS "docUserFlags($flags, $perlModule, $package, $name)"
.el .SS "docUserFlags($flags, \f(CW$perlModule\fP, \f(CW$package\fP, \f(CW$name\fP)"
.IX Subsection "docUserFlags($flags, $perlModule, $package, $name)"
Generate documentation for a method by calling the extractDocumentationFlags method in the package being documented, passing it the flags for a method and the name of the method. The called method should return the documentation to be inserted for the named method.
.PP
.Vb 5
\&     Parameter    Description
\&  1  $flags       Flags
\&  2  $perlModule  File containing documentation
\&  3  $package     Package containing documentation
\&  4  $name        Name of method to be processed
.Ve
.SS "updatePerlModuleDocumentation($perlModule)"
.IX Subsection "updatePerlModuleDocumentation($perlModule)"
Update the documentation in a \fB\f(CB$perlModule\fB\fR and display said documentation in a web browser.
.PP
.Vb 2
\&     Parameter    Description
\&  1  $perlModule  File containing the code of the perl module
.Ve
.SS "extractPythonDocumentationFromFiles(@sources)"
.IX Subsection "extractPythonDocumentationFromFiles(@sources)"
Extract python documentation from the specified files
.PP
.Vb 2
\&     Parameter  Description
\&  1  @sources   Python source files
.Ve
.SH "Synonyms"
.IX Header "Synonyms"
\&\fBfpd\fR is a synonym for filePathDir \- Create a folder name from a list of  names.
.PP
\&\fBfpe\fR is a synonym for filePathExt \- Create a file name from a list of  names the last of which is assumed to be the extension of the file name.
.PP
\&\fBfpf\fR is a synonym for filePath \- Create a file name from a list of  names.
.PP
\&\fBowf\fR is a synonym for overWriteFile \- Write to a \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
\&\fBtemporaryDirectory\fR is a synonym for temporaryFolder \- Create a new, empty, temporary folder.
.SH "Index"
.IX Header "Index"
1 absFile \- Return the name of the given file if it a fully qualified file name else returns \fBundef\fR.
.PP
2 absFromAbsPlusRel \- Absolute file from an absolute file \fB\f(CB$a\fB\fR plus a relative file \fB\f(CB$r\fB\fR.
.PP
3 addCertificate \- Add a certificate to the current ssh session.
.PP
4 addLValueScalarMethods \- Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods in the current package if they do not already exist.
.PP
5 appendFile \- Append to \fB\f(CB$file\fB\fR a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded with utf8 <https://en.wikipedia.org/wiki/UTF-8>, creating the \f(CW$file\fR first if necessary.
.PP
6 arrayProduct \- Find the product of any strings that look like numbers in an array.
.PP
7 arraySum \- Find the sum of any strings that look like numbers in an array.
.PP
8 arrayTimes \- Multiply by \fB\f(CB$multiplier\fB\fR each element of the array \fB\f(CB@a\fB\fR and return as the result.
.PP
9 arrayToHash \- Create a hash reference from an array
.PP
10 asciiToHexString \- Encode an Ascii <https://en.wikipedia.org/wiki/ASCII> string as a string of hexadecimal <https://en.wikipedia.org/wiki/Hexadecimal> digits.
.PP
11 assertPackageRefs \- Confirm that the specified references are to the specified package
.PP
12 assertRef \- Confirm that the specified references are to the package into which this routine has been exported.
.PP
13 awsCurrentAvailabilityZone \- Get the availability zone of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
14 awsCurrentInstanceId \- Get the instance id of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
15 awsCurrentInstanceType \- Get the instance type of the Amazon Web Services <http://aws.amazon.com> server if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
16 awsCurrentIp \- Get the ip address of the \s-1AWS\s0 server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
17 awsCurrentLinuxSpotPrices \- Return {instance type} = cheapest spot price in dollars per hour for the given region
.PP
18 awsCurrentRegion \- Get the region of the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
19 awsEc2CreateImage \- Create an image snap shot with the specified \fB\f(CB$name\fB\fR of the \s-1AWS\s0 server we are currently running on if we are running on an \s-1AWS\s0 server else return false.
.PP
20 awsEc2DescribeImages \- Describe images available.
.PP
21 awsEc2DescribeInstances \- Describe the Amazon Web Services <http://aws.amazon.com> instances running in a \fB\f(CB$region\fB\fR.
.PP
22 awsEc2DescribeInstancesGetIPAddresses \- Return a hash of {instanceId => public ip address} for all running instances on Amazon Web Services <http://aws.amazon.com> with ip addresses.
.PP
23 awsEc2DescribeInstanceType \- Return details of the specified instance type.
.PP
24 awsEc2DescribeSpotInstances \- Return a hash {spot instance request => spot instance details} describing the status of active spot instances.
.PP
25 awsEc2FindImagesWithTagValue \- Find images with a tag that matches the specified regular expression \fB\f(CB$value\fB\fR.
.PP
26 awsEc2InstanceIpAddress \- Return the \s-1IP\s0 address of a named instance on Amazon Web Services <http://aws.amazon.com> else return \fBundef\fR.
.PP
27 awsEc2ReportSpotInstancePrices \- Report the prices of all the spot instances whose type matches a regular expression \fB\f(CB$instanceTypeRe\fB\fR.
.PP
28 awsEc2RequestSpotInstances \- Request spot instances as long as they can be started within the next minute.
.PP
29 awsEc2Tag \- Tag an Ec2 resource with the supplied tags.
.PP
30 awsExecCli \- Execute an AWs command and return its response
.PP
31 awsExecCliJson \- Execute an AWs command and decode the json so produced
.PP
32 awsInstanceId \- Create an instance-id from the specified \fB\f(CB%options\fB\fR
.PP
33 awsIp \- Get ip address of server at Amazon Web Services <http://aws.amazon.com>.
.PP
34 awsMetaData \- Get an item of meta data for the Amazon Web Services <http://aws.amazon.com> server we are currently running on if we are running on an Amazon Web Services <http://aws.amazon.com> server else return a blank string.
.PP
35 awsParallelGatherFolder \- On Amazon Web Services <http://aws.amazon.com>: merges all the files in the specified \fB\f(CB$folder\fB\fR on each secondary instance to the corresponding folder on the primary instance in parallel.
.PP
36 awsParallelIpAddresses \- Return the \s-1IP\s0 addresses of all the Amazon Web Services <http://aws.amazon.com> session instances.
.PP
37 awsParallelPrimaryInstanceId \- Return the instance id of the primary instance.
.PP
38 awsParallelPrimaryIpAddress \- Return the \s-1IP\s0 addresses of any primary instance on Amazon Web Services <http://aws.amazon.com>.
.PP
39 awsParallelProcessFiles \- Process files in parallel across multiple Amazon Web Services <http://aws.amazon.com> instances if available or in series if not.
.PP
40 awsParallelProcessFilesTestParallel \- Test running on Amazon Web Services <http://aws.amazon.com> in parallel.
.PP
41 awsParallelProcessFilesTestResults \- Test results of running on Amazon Web Services <http://aws.amazon.com> in parallel.
.PP
42 awsParallelSecondaryIpAddresses \- Return a list containing the \s-1IP\s0 addresses of any secondary instances on Amazon Web Services <http://aws.amazon.com>.
.PP
43 awsParallelSpreadFolder \- On Amazon Web Services <http://aws.amazon.com>: copies a specified \fB\f(CB$folder\fB\fR from the primary instance, see: awsParallelPrimaryInstanceId, in parallel, to all the secondary instances in the session.
.PP
44 awsProfile \- Create a profile keyword from the specified \fB\f(CB%options\fB\fR
.PP
45 awsRegion \- Create a region keyword from the specified \fB\f(CB%options\fB\fR
.PP
46 awsTranslateText \- Translate \fB\f(CB$text\fB\fR from English to a specified \fB\f(CB$language\fB\fR using \s-1AWS\s0 Translate with the specified global \fB\f(CB$options\fB\fR and return the translated string.
.PP
47 binModeAllUtf8 \- Set \s-1STDOUT\s0 and \s-1STDERR\s0 to accept utf8 without complaint.
.PP
48 boldString \- Convert alphanumerics in a string to bold.
.PP
49 boldStringUndo \- Undo alphanumerics in a string to bold.
.PP
50 call \- Call the specified \fB\f(CB$sub\fB\fR in a separate child process, wait for it to complete, then copy back the named \fB\f(CB@our\fB\fR variables from the child process to the calling parent process effectively freeing any memory used during the call.
.PP
51 callSubInOverlappedParallel \- Call the \fB\f(CB$child\fB\fR sub reference in parallel in a separate child process and ignore its results while calling the \fB\f(CB$parent\fB\fR sub reference in the parent process and returning its results.
.PP
52 callSubInParallel \- Call a sub reference in parallel to avoid memory fragmentation and return its results.
.PP
53 checkFile \- Return the name of the specified file if it exists, else confess the maximum extent of the path that does exist.
.PP
54 checkKeys \- Check the keys in a \fBhash\fR conform to those \fB\f(CB$permitted\fB\fR.
.PP
55 childPids \- Recursively find the pids of all the sub processes of a \fB\f(CB$process\fB\fR and all their sub processes and so on returning the specified pid and all its child pids as a list.
.PP
56 chooseStringAtRandom \- Choose a string at random from the list of \fB\f(CB@strings\fB\fR supplied.
.PP
57 clearFolder \- Remove all the files and folders under and including the specified \fB\f(CB$folder\fB\fR as long as the number of files to be removed is less than the specified \fB\f(CB$limitCount\fB\fR.
.PP
58 cmpArrays \- Apply \fBcmp()\fR to two arrays of strings
.PP
59 confirmHasCommandLineCommand \- Check that the specified b<$cmd> is present on the current system.
.PP
60 containingFolderName \- The name of a folder containing a file
.PP
61 containingPowerOfTwo \- Find log two of the lowest power of two greater than or equal to a number \fB\f(CB$n\fB\fR.
.PP
62 contains \- Returns the indices at which an \fB\f(CB$item\fB\fR matches elements of the specified \fB\f(CB@array\fB\fR.
.PP
63 convertDocxToFodt \- Convert a \fIdocx\fR \fB\f(CB$inputFile\fB\fR file to a \fIfodt\fR \fB\f(CB$outputFile\fB\fR using \fBunoconv\fR which must not be running elsewhere at the time.
.PP
64 convertImageToJpx \- Convert a \fB\f(CB$source\fB\fR image to a \fB\f(CB$target\fB\fR image in jpx format.
.PP
65 convertImageToJpx690 \- Convert a \fB\f(CB$source\fB\fR image to a \fB\f(CB$target\fB\fR image in jpx format using versions of Imagemagick <https://www.imagemagick.org/script/index.php> version 6.
.PP
66 convertPerlToJavaScript \- Convert Perl to Javascript
.PP
67 convertUnicodeToXml \- Convert a \fB\f(CB$string\fB\fR with Unicode <https://en.wikipedia.org/wiki/Unicode> codepoints that are not directly representable in Ascii <https://en.wikipedia.org/wiki/ASCII> into string that replaces these code points with their representation in Xml <https://en.wikipedia.org/wiki/XML> making the string usable in Xml <https://en.wikipedia.org/wiki/XML> documents.
.PP
68 copyBinaryFile \- Copy the binary file \fB\f(CB$source\fB\fR to a file named <%target> and return the target file name,
.PP
69 copyBinaryFileMd5Normalized \- Normalize the name of the specified \fB\f(CB$source\fB\fR file to the md5 sum of its content, retaining its current extension, while placing the original file name in a companion file if the companion file does not already exist.
.PP
70 copyBinaryFileMd5NormalizedCreate \- Create a file in the specified \fB\f(CB$folder\fB\fR whose name is constructed from the md5 sum of the specified \fB\f(CB$content\fB\fR, whose content is \fB\f(CB$content\fB\fR, whose extension is \fB\f(CB$extension\fB\fR and which has a companion file with the same name minus the extension  which contains the specified \fB\f(CB$companionContent\fB\fR.
.PP
71 copyBinaryFileMd5NormalizedGetCompanionContent \- Return the original name of the specified \fB\f(CB$source\fB\fR file after it has been normalized via copyBinaryFileMd5Normalized or copyBinaryFileMd5NormalizedCreate or return \fBundef\fR if the corresponding companion file does not exist.
.PP
72 copyFile \- Copy the \fB\f(CB$source\fB\fR file encoded in utf8 to the specified \fB\f(CB$target\fB\fR file in and return \f(CW$target\fR.
.PP
73 copyFileFromRemote \- Copy the specified \fB\f(CB$file\fB\fR from the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
74 copyFileMd5Normalized \- Normalize the name of the specified \fB\f(CB$source\fB\fR file to the md5 sum of its content, retaining its current extension, while placing the original file name in a companion file if the companion file does not already exist.
.PP
75 copyFileMd5NormalizedCreate \- Create a file in the specified \fB\f(CB$folder\fB\fR whose name is constructed from the md5 sum of the specified \fB\f(CB$content\fB\fR, whose content is \fB\f(CB$content\fB\fR, whose extension is \fB\f(CB$extension\fB\fR and which has a companion file with the same name minus the extension which contains the specified \fB\f(CB$companionContent\fB\fR.
.PP
76 copyFileMd5NormalizedDelete \- Delete a normalized and its companion file
.PP
77 copyFileMd5NormalizedGetCompanionContent \- Return the content of the companion file to the specified \fB\f(CB$source\fB\fR file after it has been normalized via copyFileMd5Normalized or copyFileMd5NormalizedCreate or return \fBundef\fR if the corresponding companion file does not exist.
.PP
78 copyFileMd5NormalizedName \- Name a file using the \s-1GB\s0 Standard
.PP
79 copyFileToFolder \- Copy the file named in \fB\f(CB$source\fB\fR to the specified \fB\f(CB$targetFolder\fB/\fR or if \f(CW$targetFolder\fR/ is in fact a file into the folder containing this file and return the target file name.
.PP
80 copyFileToRemote \- Copy the specified local \fB\f(CB$file\fB\fR to the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
81 copyFolder \- Copy the \fB\f(CB$source\fB\fR folder to the \fB\f(CB$target\fB\fR folder after clearing the \f(CW$target\fR folder.
.PP
82 copyFolderToRemote \- Copy the specified local \fB\f(CB$Source\fB\fR folder to the corresponding remote folder on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
83 countFileExtensions \- Return a hash which counts the file extensions in and below the folders in the specified list.
.PP
84 countFileTypes \- Return a hash which counts, in parallel with a maximum number of processes: \fB\f(CB$maximumNumberOfProcesses\fB\fR, the results of applying the \fBfile\fR command to each file ina nd under the specified \fB\f(CB@folders\fB\fR.
.PP
85 countOccurencesInString \- Returns the number of occurrences in \fB\f(CB$inString\fB\fR of \fB\f(CB$searchFor\fB\fR.
.PP
86 countSquareArray \- Count the number of elements in a square array
.PP
87 createEmptyFile \- Create an empty file unless the file already exists and return the name of the file else confess if the file cannot be created.
.PP
88 currentDirectory \- Get the current working directory.
.PP
89 currentDirectoryAbove \- Get the path to the folder above the current working folder.
.PP
90 cutOutImagesInFodtFile \- Cut out the images embedded in a \fBfodt\fR file, perhaps produced via convertDocxToFodt, placing them in the specified folder and replacing them in the source file with:
.PP
.Vb 1
\&  <image href="$imageFile" outputclass="imageType">.
.Ve
.PP
91 Data::Exchange::Service::check \- Check that we are the current incarnation of the named service with details obtained from newServiceIncarnation.
.PP
92 Data::Table::Text::Starter::averageProcessTime \- Average elapsed time spent by each process
.PP
93 Data::Table::Text::Starter::finish \- Wait for all started processes to finish and return their results as an array.
.PP
94 Data::Table::Text::Starter::logEntry \- Create a log entry showing progress and eta.
.PP
95 Data::Table::Text::Starter::say \- Write to the log file if it is available.
.PP
96 Data::Table::Text::Starter::start \- Start a new process to run the specified \fB\f(CB$sub\fB\fR.
.PP
97 Data::Table::Text::Starter::waitOne \- Wait for at least one process to finish and consolidate its results.
.PP
98 dateStamp \- Year-monthName-day
.PP
99 dateTimeStamp \- Year-monthNumber-day at hours:minute:seconds
.PP
100 dateTimeStampName \- Date time stamp without white space.
.PP
101 ddd \- Dump data
.PP
102 decodeBase64 \- Decode an Ascii <https://en.wikipedia.org/wiki/ASCII> \fB\f(CB$string\fB\fR in base 64.
.PP
103 decodeJson \- Convert a Json <https://en.wikipedia.org/wiki/JSON> \fB\f(CB$string\fB\fR to a Perl <http://www.perl.org/> data structure.
.PP
104 deduplicateSequentialWordsInString \- Remove sequentially duplicate words in a string
.PP
105 denormalizeFolderName \- Remove any trailing folder separator from a folder name.
.PP
106 deSquareArray \- Create a one dimensional array from a two dimensional array of arrays
.PP
107 detagString \- Remove \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML> or Xml <https://en.wikipedia.org/wiki/XML> tags from a string
.PP
108 docUserFlags \- Generate documentation for a method by calling the extractDocumentationFlags method in the package being documented, passing it the flags for a method and the name of the method.
.PP
109 downloadGitHubPublicRepo \- Get the contents of a public repo on GitHub and place them in a temporary folder whose name is returned to the caller or confess if no such repo exists.
.PP
110 downloadGitHubPublicRepoFile \- Get the contents of a \fB\f(CB$user\fB\fR \fB\f(CB$repo\fB\fR \fB\f(CB$file\fB\fR from  a public repo on GitHub and return them as a string.
.PP
111 dumpFile \- Dump to a \fB\f(CB$file\fB\fR the referenced data \fB\f(CB$structure\fB\fR.
.PP
112 dumpFileAsJson \- Dump to a \fB\f(CB$file\fB\fR the referenced data \fB\f(CB$structure\fB\fR represented as Json <https://en.wikipedia.org/wiki/JSON> string.
.PP
113 dumpGZipFile \- Write to a \fB\f(CB$file\fB\fR a data \fB\f(CB$structure\fB\fR through gzip <https://en.wikipedia.org/wiki/Gzip>.
.PP
114 dumpTempFile \- Dump a data structure to a temporary file and return the name of the file created
.PP
115 dumpTempFileAsJson \- Dump a data structure represented as Json <https://en.wikipedia.org/wiki/JSON> string to a temporary file and return the name of the file created.
.PP
116 enclosedReversedString \- Convert alphanumerics in a string to enclosed reversed alphanumerics.
.PP
117 enclosedReversedStringUndo \- Undo alphanumerics in a string to enclosed reversed alphanumerics.
.PP
118 enclosedString \- Convert alphanumerics in a string to enclosed alphanumerics.
.PP
119 enclosedStringUndo \- Undo alphanumerics in a string to enclosed alphanumerics.
.PP
120 encodeBase64 \- Encode an Ascii <https://en.wikipedia.org/wiki/ASCII> \fB\f(CB$string\fB\fR in base 64.
.PP
121 encodeJson \- Convert a Perl <http://www.perl.org/> data \fB\f(CB$structure\fB\fR to a Json <https://en.wikipedia.org/wiki/JSON> string.
.PP
122 evalFile \- Read a file containing Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8>, \*(L"eval\*(R" in perlfunc the content, confess to any errors and then return any result with lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> methods to access each hash element.
.PP
123 evalFileAsJson \- Read a \fB\f(CB$file\fB\fR containing Json <https://en.wikipedia.org/wiki/JSON> and return the corresponding Perl <http://www.perl.org/> data structure.
.PP
124 evalGZipFile \- Read a file compressed with gzip <https://en.wikipedia.org/wiki/Gzip> containing Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8>, \*(L"eval\*(R" in perlfunc the content, confess to any errors and then return any result with lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> methods to access each hash element.
.PP
125 execPerlOnRemote \- Execute some Perl \fB\f(CB$code\fB\fR on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
126 expandNewLinesInDocumentation \- Expand new lines in documentation, specifically
 for new line and
.PP
.Vb 1
\& for two new lines.
.Ve
.PP
127 expandWellKnownUrlsInDitaFormat \- Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] in the L[Dita] \fBxref\fRformat.
.PP
128 expandWellKnownUrlsInHtmlFormat \- Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] using the html \fBa\fR tag.
.PP
129 expandWellKnownUrlsInHtmlFromPerl \- Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L[url\-name] using the html \fBa\fR tag.
.PP
130 expandWellKnownUrlsInPerlFormat \- Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format L<url\-name> using the Perl \s-1POD\s0 syntax
.PP
131 expandWellKnownUrlsInPod2Html \- Expand short url <https://en.wikipedia.org/wiki/URL> names found in a string in the format =begin html format
.PP
132 extractCodeBlock \- Extract the block of code delimited by \fB\f(CB$comment\fB\fR, starting at qq($comment\-begin), ending at qq($comment\-end) from the named \fB\f(CB$file\fB\fR else the current Perl program \f(CW$0\fR and return it as a string or confess if this is not possible.
.PP
133 extractPythonDocumentationFromFiles \- Extract python documentation from the specified files
.PP
134 extractTest \- Remove example markers from test code.
.PP
135 fe \- Get the extension of a file name.
.PP
136 fff \- Confess a message with a line position and a file that Geany will jump to if clicked on.
.PP
137 fileInWindowsFormat \- Convert a unix \fB\f(CB$file\fB\fR name to windows format
.PP
138 fileLargestSize \- Return the largest \fB\f(CB$file\fB\fR.
.PP
139 fileList \- Files that match a given search pattern interpreted by \*(L"bsd_glob\*(R" in perlfunc.
.PP
140 fileMd5Sum \- Get the Md5 sum of the content of a \fB\f(CB$file\fB\fR.
.PP
141 fileModTime \- Get the modified time of a \fB\f(CB$file\fB\fR as seconds since the epoch.
.PP
142 fileOutOfDate \- Calls the specified sub \fB\f(CB$make\fB\fR for each source file that is missing and then again against the \fB\f(CB$target\fB\fR file if any of the \fB\f(CB@source\fB\fR files were missing or the \f(CW$target\fR file is older than any of the \f(CW@source\fR files or if the target does not exist.
.PP
143 filePath \- Create a file name from a list of  names.
.PP
144 filePathDir \- Create a folder name from a list of  names.
.PP
145 filePathExt \- Create a file name from a list of  names the last of which is assumed to be the extension of the file name.
.PP
146 fileSize \- Get the size of a \fB\f(CB$file\fB\fR in bytes.
.PP
147 findAllFilesAndFolders \- Find all the files and folders under a folder.
.PP
148 findDirs \- Find all the folders under a \fB\f(CB$folder\fB\fR and optionally \fB\f(CB$filter\fB\fR the selected folders with a regular expression.
.PP
149 findFiles \- Find all the files under a \fB\f(CB$folder\fB\fR and optionally \fB\f(CB$filter\fB\fR the selected files with a regular expression.
.PP
150 findFileWithExtension \- Find the first file that exists with a path and name of \fB\f(CB$file\fB\fR and an extension drawn from <@ext>.
.PP
151 firstFileThatExists \- Returns the name of the first file from \fB\f(CB@files\fB\fR that exists or \fBundef\fR if none of the named \f(CW@files\fR exist.
.PP
152 firstNChars \- First N characters of a string.
.PP
153 flattenArrayAndHashValues \- Flatten an array of scalars, array and hash references to make an array of scalars by flattening the array references and hash values.
.PP
154 fn \- Remove the path and extension from a file name.
.PP
155 fne \- Remove the path from a file name.
.PP
156 folderSize \- Get the size of a \fB\f(CB$folder\fB\fR in bytes.
.PP
157 formatHtmlAndTextTables \- Create text and html versions of a tabular report
.PP
158 formatHtmlAndTextTablesWaitPids \- Wait on all table formatting pids to complete
.PP
159 formatHtmlTable \- Format an array of arrays of scalars as an html table using the  \fB\f(CB%options\fB\fR described in formatTableCheckKeys.
.PP
160 formatHtmlTablesIndex \- Create an index of html reports.
.PP
161 formatSourcePodAsHtml \- Format the \s-1POD\s0 <https://perldoc.perl.org/perlpod.html> in the current source file as \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML>.
.PP
162 formatString \- Format the specified \fB\f(CB$string\fB\fR so it can be displayed in \fB\f(CB$width\fB\fR columns.
.PP
163 formatTable \- Format various \fB\f(CB$data\fB\fR structures as a table with titles as specified by \fB\f(CB$columnTitles\fB\fR: either a reference to an array of column titles or a string each line of which contains the column title as the first word with the rest of the line describing that column.
.PP
164 formatTableA \- Tabularize an array.
.PP
165 formatTableAA \- Tabularize an array of arrays.
.PP
166 formatTableAH \- Tabularize an array of hashes.
.PP
167 formatTableBasic \- Tabularize an array of arrays of text.
.PP
168 formatTableCheckKeys \- Options available for formatting tables
.PP
169 formatTableClearUpLeft \- Blank identical column values up and left
.PP
170 formatTableH \- Tabularize a hash.
.PP
171 formatTableHA \- Tabularize a hash of arrays.
.PP
172 formatTableHH \- Tabularize a hash of hashes.
.PP
173 formatTableMultiLine \- Tabularize text that has new lines in it.
.PP
174 formattedTablesReport \- Report of all the reports created.
.PP
175 fp \- Get the path from a file name.
.PP
176 fpn \- Remove the extension from a file name.
.PP
177 fullFileName \- Full name of a file.
.PP
178 fullyQualifiedFile \- Check whether a \fB\f(CB$file\fB\fR name is fully qualified or not and, optionally, whether it is fully qualified with a specified \fB\f(CB$prefix\fB\fR or not.
.PP
179 fullyQualifyFile \- Return the fully qualified name of a file.
.PP
180 genHash \- Return a \fB\f(CB$bless\fB\fRed hash with the specified \fB\f(CB$attributes\fB\fR accessible via lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> method calls.
.PP
181 genLValueArrayMethods \- Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> array methods in the current package.
.PP
182 genLValueHashMethods \- Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> hash methods in the current package.
.PP
183 genLValueScalarMethods \- Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods in the current package, A method whose value has not yet been set will return a new scalar with value \fBundef\fR.
.PP
184 genLValueScalarMethodsWithDefaultValues \- Generate lvalue method <http://perldoc.perl.org/perlsub.html#Lvalue-subroutines> scalar methods with default values in the current package.
.PP
185 getCodeContext \- Recreate the code context for a referenced sub
.PP
186 getNumberOfCpus \- Number of cpus
.PP
187 getSubName \- Returns the (package, name, file, line) of a perl \fB\f(CB$sub\fB\fR reference.
.PP
188 guidFromMd5 \- Create a guid from an md5 hash.
.PP
189 guidFromString \- Create a guid representation of the md5 sum <https://en.wikipedia.org/wiki/MD5> of the content of a string.
.PP
190 hashifyFolderStructure \- Hashify a list of file names to get the corresponding folder structure.
.PP
191 hexToAsciiString \- Decode a string of hexadecimal <https://en.wikipedia.org/wiki/Hexadecimal> digits as an Ascii <https://en.wikipedia.org/wiki/ASCII> string.
.PP
192 hostName \- The name of the host we are running on.
.PP
193 htmlToc \- Generate a table of contents for some html.
.PP
194 imageSize \- Return (width, height) of an \fB\f(CB$image\fB\fR.
.PP
195 indentString \- Indent lines contained in a string or formatted table by the specified string.
.PP
196 indexOfMax \- Find the index of the maximum number in a list of numbers confessing to any ill defined values.
.PP
197 indexOfMin \- Find the index of the minimum number in a list of numbers confessing to any ill defined values.
.PP
198 intersectionOfHashesAsArrays \- Form the intersection of the specified hashes \fB\f(CB@h\fB\fR as one hash whose values are an array of corresponding values from each hash
.PP
199 intersectionOfHashKeys \- Form the intersection of the keys of the specified hashes \fB\f(CB@h\fB\fR as one hash whose keys represent the intersection.
.PP
200 invertHashOfHashes \- Invert a hash of hashes: given {a}{b} = c return {b}{c} = c
.PP
201 ipAddressViaArp \- Get the ip address of a server on the local network by hostname via arp
.PP
202 isBlank \- Test whether a string is blank.
.PP
203 isFileUtf8 \- Return the file name quoted if its contents are in utf8 else return undef
.PP
204 isSubInPackage \- Test whether the specified \fB\f(CB$package\fB\fR contains the subroutine <$sub>.
.PP
205 javaPackage \- Extract the package name from a java string or file.
.PP
206 javaPackageAsFileName \- Extract the package name from a java string or file and convert it to a file name.
.PP
207 javaScriptExports \- Extract the Javascript functions marked for export in a file or string.
.PP
208 keyCount \- Count keys down to the specified level.
.PP
209 lengthOfLongestSubArray \- Given an array of arrays find the length of the longest sub array.
.PP
210 lll \- Log messages with a time stamp and originating file and line number.
.PP
211 loadArrayArrayFromLines \- Load an array of arrays from lines of text: each line is an array of words.
.PP
212 loadArrayFromLines \- Load an array from lines of text in a string.
.PP
213 loadArrayHashFromLines \- Load an array of hashes from lines of text: each line is a hash of words.
.PP
214 loadHash \- Load the specified blessed \fB\f(CB$hash\fB\fR generated with genHash with \fB\f(CB%attributes\fB\fR.
.PP
215 loadHashArrayFromLines \- Load a hash of arrays from lines of text: the first word of each line is the key, the remaining words are the array contents.
.PP
216 loadHashFromLines \- Load a hash: first word of each line is the key and the rest is the value.
.PP
217 loadHashHashFromLines \- Load a hash of hashes from lines of text: the first word of each line is the key, the remaining words are the sub hash contents.
.PP
218 makeDieConfess \- Force die to confess where the death occurred
.PP
219 makePath \- Make the path for the specified file name or folder on the local machine.
.PP
220 makePathRemote \- Make the path for the specified \fB\f(CB$file\fB\fR or folder on the Amazon Web Services <http://aws.amazon.com> instance whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
221 matchPath \- Return the deepest folder that exists along a given file name path.
.PP
222 mathematicalBoldItalicString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold Italic.
.PP
223 mathematicalBoldItalicStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold Italic.
.PP
224 mathematicalBoldString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold.
.PP
225 mathematicalBoldStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Bold.
.PP
226 mathematicalMonoSpaceString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical MonoSpace.
.PP
227 mathematicalMonoSpaceStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical MonoSpace.
.PP
228 mathematicalSansSerifBoldItalicString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold Italic.
.PP
229 mathematicalSansSerifBoldItalicStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold Italic.
.PP
230 mathematicalSansSerifBoldString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold.
.PP
231 mathematicalSansSerifBoldStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Bold.
.PP
232 mathematicalSansSerifItalicString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Italic.
.PP
233 mathematicalSansSerifItalicStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif Italic.
.PP
234 mathematicalSansSerifString \- Convert alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif.
.PP
235 mathematicalSansSerifStringUndo \- Undo alphanumerics in a string to Unicode <https://en.wikipedia.org/wiki/Unicode> Mathematical Sans Serif.
.PP
236 max \- Find the maximum number in a list of numbers confessing to any ill defined values.
.PP
237 maximumLineLength \- Find the longest line in a \fB\f(CB$string\fB\fR.
.PP
238 md5FromGuid \- Recover an md5 sum from a guid.
.PP
239 mergeFolder \- Copy the \fB\f(CB$source\fB\fR folder into the \fB\f(CB$target\fB\fR folder retaining any existing files not replaced by copied files.
.PP
240 mergeFolderFromRemote \- Merge the specified \fB\f(CB$Source\fB\fR folder from the corresponding remote folder on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
241 mergeHashesBySummingValues \- Merge a list of hashes \fB\f(CB@h\fB\fR by summing their values
.PP
242 microSecondsSinceEpoch \- Micro seconds since unix epoch.
.PP
243 min \- Find the minimum number in a list of numbers confessing to any ill defined values.
.PP
244 mmm \- Log messages with a differential time in milliseconds and originating file and line number.
.PP
245 moveFileNoClobber \- Rename the \fB\f(CB$source\fB\fR file, which must exist, to the \fB\f(CB$target\fB\fR file but only if the \f(CW$target\fR file does not exist already.
.PP
246 moveFileWithClobber \- Rename the \fB\f(CB$source\fB\fR file, which must exist, to the \fB\f(CB$target\fB\fR file but only if the \f(CW$target\fR file does not exist already.
.PP
247 nameFromFolder \- Create a name from the last folder in the path of a file name.
.PP
248 nameFromString \- Create a readable name from an arbitrary string of text.
.PP
249 nameFromStringRestrictedToTitle \- Create a readable name from a string of text that might contain a title tag \- fall back to nameFromString if that is not possible.
.PP
250 newProcessStarter \- Create a new process starter with which to start parallel processes up to a specified \fB\f(CB$maximumNumberOfProcesses\fB\fR maximum number of parallel processes at a time, wait for all the started processes to finish and then optionally retrieve their saved results as an array from the folder named by \fB\f(CB$transferArea\fB\fR.
.PP
251 newServiceIncarnation \- Create a new service incarnation to record the start up of a new instance of a service and return the description as a Data::Exchange::Service Definition hash.
.PP
252 newUdsr \- Create a communicator \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
253 newUdsrClient \- Create a new communications client \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
254 newUdsrServer \- Create a communications server \- a means to communicate between processes on the same machine via Udsr::read and Udsr::write.
.PP
255 numberOfCpus \- Number of cpus scaled by an optional factor \- but only if you have nproc.
.PP
256 numberOfLinesInFile \- Return the number of lines in a file.
.PP
257 numberOfLinesInString \- The number of lines in a string.
.PP
258 nws \- Normalize white space in a string to make comparisons easier.
.PP
259 onAws \- Returns 1 if we are on \s-1AWS\s0 else return 0.
.PP
260 onAwsPrimary \- Return 1 if we are on Amazon Web Services <http://aws.amazon.com> and we are on the primary session instance as defined by awsParallelPrimaryInstanceId, return 0 if we are on a secondary session instance, else return \fBundef\fR if we are not on Amazon Web Services <http://aws.amazon.com>.
.PP
261 onAwsSecondary \- Return 1 if we are on Amazon Web Services <http://aws.amazon.com> but we are not on the primary session instance as defined by awsParallelPrimaryInstanceId, return 0 if we are on the primary session instance, else return \fBundef\fR if we are not on Amazon Web Services <http://aws.amazon.com>.
.PP
262 overrideAndReabsorbMethods \- Override methods down the list of \fB\f(CB@packages\fB\fR then reabsorb any unused methods back up the list of packages so that all the packages have the same methods as the last package with methods from packages mentioned earlier overriding methods from packages mentioned later.
.PP
263 overrideMethods \- For each method, if it exists in package \fB\f(CB$from\fB\fR then export it to package \fB\f(CB$to\fB\fR replacing any existing method in \fB\f(CB$to\fB\fR, otherwise export the method from package \fB\f(CB$to\fB\fR to package \fB\f(CB$from\fB\fR in order to merge the behavior of the \fB\f(CB$from\fB\fR and \fB\f(CB$to\fB\fR packages with respect to the named methods with duplicates resolved if favour of package \fB\f(CB$from\fB\fR.
.PP
264 overWriteBinaryFile \- Write to \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, the binary content in \fB\f(CB$string\fB\fR.
.PP
265 overWriteFile \- Write to a \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
266 overWriteHtmlFile \- Write an \s-1HTML\s0 <https://en.wikipedia.org/wiki/HTML> file to /var/www/html and make it readable
.PP
267 overWritePerlCgiFile \- Write a Perl <http://www.perl.org/> file to /usr/lib/cgi\-bin and make it executable after checking it for syntax errors
.PP
268 packBySize \- Given \fB\f(CB$N\fB\fR buckets and a list \fB\f(CB@sizes\fB\fR of ([size of file, name of file].
.PP
269 pad \- Pad the specified \fB\f(CB$string\fB\fR to a multiple of the specified \fB\f(CB$length\fB\fR  with blanks or the specified padding character to a multiple of a specified length.
.PP
270 parseCommandLineArguments \- Call the specified \fB\f(CB$sub\fB\fR after classifying the specified array of [arguments] in \fB\f(CB$args\fB\fR into positional and keyword parameters.
.PP
271 parseDitaRef \- Parse a dita reference \fB\f(CB$ref\fB\fR into its components (file name, topic id, id) .
.PP
272 parseFileName \- Parse a file name into (path, name, extension) considering .
.PP
273 parseIntoWordsAndStrings \- Parse a \fB\f(CB$string\fB\fR into words and quoted strings.
.PP
274 parseS3BucketAndFolderName \- Parse an S3 <https://aws.amazon.com/s3/> bucket/folder name into a bucket and a folder name removing any initial s3://.
.PP
275 parseXmlDocType \- Parse an Xml <https://en.wikipedia.org/wiki/XML> \s-1DOCTYPE\s0 and return a hash indicating its components
.PP
276 partitionStringsOnPrefixBySize \- Partition a hash of strings and associated sizes into partitions with either a maximum size \fB\f(CB$maxSize\fB\fR or only one element; the hash \fB\f(CB%Sizes\fB\fR consisting of a mapping {string=>size}; with each partition being named with the shortest string prefix that identifies just the strings in that partition.
.PP
277 perlPackage \- Extract the package name from a perl string or file.
.PP
278 powerOfTwo \- Test whether a number \fB\f(CB$n\fB\fR is a power of two, return the power if it is else \fBundef\fR.
.PP
279 printPerlDataAsXml \- Print a Perl data structure as xml
.PP
280 printQw \- Print an array of words in \fBqw()\fR format.
.PP
281 processFilesInParallel \- Process files in parallel using (8 * the number of CPUs) processes with the process each file is assigned to depending on the size of the file so that each process is loaded with approximately the same number of bytes of data in total from the files it processes.
.PP
282 processJavaFilesInParallel \- Process java files of known size in parallel using (the number of CPUs) processes with the process each item is assigned to depending on the size of the java item so that each process is loaded with approximately the same number of bytes of data in total from the java files it processes.
.PP
283 processSizesInParallel \- Process items of known size in parallel using (8 * the number of CPUs) processes with the process each item is assigned to depending on the size of the item so that each process is loaded with approximately the same number of bytes of data in total from the items it processes.
.PP
284 processSizesInParallelN \- Process items of known size in parallel using the specified number \fB\f(CB$N\fB\fR processes with the process each file is assigned to depending on the size of the file so that each process is loaded with approximately the same number of bytes of data in total from the files it processes.
.PP
285 quoteFile \- Quote a file name.
.PP
286 readBinaryFile \- Read a binary file on the local machine.
.PP
287 readFile \- Return the content of a file residing on the local machine interpreting the content of the file as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
288 readFileFromRemote \- Copy and read a \fB\f(CB$file\fB\fR from the remote machine whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp and return the content of \f(CW$file\fR interpreted as utf8 .
.PP
289 readFiles \- Read all the files in the specified list of folders into a hash.
.PP
290 readGZipFile \- Read the specified file containing compressed Unicode <https://en.wikipedia.org/wiki/Unicode> content represented as utf8 <https://en.wikipedia.org/wiki/UTF-8> through gzip <https://en.wikipedia.org/wiki/Gzip>.
.PP
291 readStdIn \- Return the contents of \s-1STDIN\s0 and return the results as either an array or a string.
.PP
292 readUtf16File \- Read a file containing Unicode <https://en.wikipedia.org/wiki/Unicode> encoded in utf\-16.
.PP
293 rectangularArray \- Create a two dimensional rectangular array whose first dimension is \fB\f(CB$first\fB\fR from a one dimensional linear array.
.PP
294 rectangularArray2 \- Create a two dimensional rectangular array whose second dimension is \fB\f(CB$second\fB\fR from a one dimensional linear array.
.PP
295 reinstateWellKnown \- Contract references to well known Urls to their abbreviated form
.PP
296 relFromAbsAgainstAbs \- Relative file from one absolute file \fB\f(CB$a\fB\fR against another \fB\f(CB$b\fB\fR.
.PP
297 reloadHashes \- Ensures that all the hashes within a tower of data structures have LValue methods to get and set their current keys.
.PP
298 reloadHashes2 \- Ensures that all the hashes within a tower of data structures have LValue methods to get and set their current keys.
.PP
299 removeDuplicatePrefixes \- Remove duplicated leading directory names from a file name.
.PP
300 removeFilePathsFromStructure \- Remove all file paths from a specified \fB\f(CB$structure\fB\fR to make said \f(CW$structure\fR testable with \*(L"is_deeply\*(R" in Test::More.
.PP
301 removeFilePrefix \- Removes a file \fB\f(CB$prefix\fB\fR from an array of \fB\f(CB@files\fB\fR.
.PP
302 renormalizeFolderName \- Normalize a folder name by ensuring it has a single trailing directory separator.
.PP
303 replaceStringWithString \- Replace all instances in \fB\f(CB$string\fB\fR of \fB\f(CB$source\fB\fR with \fB\f(CB$target\fB\fR
.PP
304 reportAttributes \- Report the attributes present in a \fB\f(CB$sourceFile\fB\fR
.PP
305 reportAttributeSettings \- Report the current values of the attribute methods in the calling file and optionally write the report to \fB\f(CB$reportFile\fB\fR.
.PP
306 reportExportableMethods \- Report the exportable methods marked with #e in a \fB\f(CB$sourceFile\fB\fR
.PP
307 reportReplacableMethods \- Report the replaceable methods marked with #r in a \fB\f(CB$sourceFile\fB\fR
.PP
308 reportSettings \- Report the current values of parameterless subs in a \fB\f(CB$sourceFile\fB\fR that match \eAsub\es+(\ew+)\es*\e{ and optionally write the report to \fB\f(CB$reportFile\fB\fR.
.PP
309 retrieveFile \- Retrieve a \fB\f(CB$file\fB\fR created via Storable <https://metacpan.org/pod/Storable>.
.PP
310 runInParallel \- Process the elements of an array in parallel using a maximum of \fB\f(CB$maximumNumberOfProcesses\fB\fR processes.
.PP
311 runInSquareRootParallel \- Process the elements of an array in square root parallel using a maximum of \fB\f(CB$maximumNumberOfProcesses\fB\fR processes.
.PP
312 s3Delete \- Return an S3 \-\-delete keyword from an S3 option set
.PP
313 s3DownloadFolder \- Download a specified \fB\f(CB$folder\fB\fR on S3 to a \fB\f(CB$local\fB\fR folder using the specified \fB\f(CB%options\fB\fR if any.
.PP
314 s3FileExists \- Return (name, size, date, time) for a \fB\f(CB$file\fB\fR that exists on S3 else () using the specified \fB\f(CB%options\fB\fR if any.
.PP
315 s3ListFilesAndSizes \- Return {file=>size} for all the files in a specified \fB\f(CB$folderOrFile\fB\fR on S3 using the specified \fB\f(CB%options\fB\fR if any.
.PP
316 s3Profile \- Return an S3 profile keyword from an S3 option set
.PP
317 s3ReadFile \- Read from a \fB\f(CB$file\fB\fR on S3 and write the contents to a local file \fB\f(CB$local\fB\fR using the specified \fB\f(CB%options\fB\fR if any.
.PP
318 s3ReadString \- Read from a \fB\f(CB$file\fB\fR on S3 and return the contents as a string using specified \fB\f(CB%options\fB\fR if any.
.PP
319 s3WriteFile \- Write to a file \fB\f(CB$fileS3\fB\fR on S3 the contents of a local file \fB\f(CB$fileLocal\fB\fR using the specified \fB\f(CB%options\fB\fR if any.
.PP
320 s3WriteString \- Write to a \fB\f(CB$file\fB\fR on S3 the contents of \fB\f(CB$string\fB\fR using the specified \fB\f(CB%options\fB\fR if any.
.PP
321 s3ZipFolder \- Zip the specified \fB\f(CB$source\fB\fR folder and write it to the named \fB\f(CB$target\fB\fR file on S3.
.PP
322 s3ZipFolders \- Zip local folders and upload them to S3 in parallel.
.PP
323 saveAwsIp \- Make the server at Amazon Web Services <http://aws.amazon.com> with the given \s-1IP\s0 address the default primary server as used by all the methods whose names end in \fBr\fR or \fBRemote\fR.
.PP
324 saveCodeToS3 \- Save source code every \fB\f(CB$saveCodeEvery\fB\fR seconds by zipping folder \fB\f(CB$folder\fB\fR to zip file \fB\f(CB$zipFileName\fB\fR then saving this zip file in the specified S3 <https://aws.amazon.com/s3/> \fB\f(CB$bucket\fB\fR using any additional S3 <https://aws.amazon.com/s3/> parameters in \fB\f(CB$S3Parms\fB\fR.
.PP
325 saveSourceToS3 \- Save source code.
.PP
326 searchDirectoryTreesForMatchingFiles \- Search the specified directory trees for the files (not folders) that match the specified extensions.
.PP
327 setCombination \- Count the elements in sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
328 setFileExtension \- Given a \fB\f(CB$file\fB\fR, change its extension to \fB\f(CB$extension\fB\fR.
.PP
329 setIntersection \- Intersection of sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
330 setIntersectionOverUnion \- Returns the size of the intersection over the size of the union of one or more sets \fB\f(CB@s\fB\fR represented as arrays and/or hashes
.PP
331 setPackageSearchOrder \- Set a package search order for methods requested in the current package via \s-1AUTOLOAD.\s0
.PP
332 setPartitionOnIntersectionOverUnion \- Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@sets\fB\fR so that within each partition the setIntersectionOverUnion of any two sets in the partition is never less than the specified level of \fI\f(CI$confidence\fI**2\fR
.PP
333 setPartitionOnIntersectionOverUnionOfHashStringSets \- Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB$hashSet\fB\fR represented by a hash, each hash value being a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fB\f(CB$confidence\fB**2\fR and the partition entries are the hash keys of the string sets.
.PP
334 setPartitionOnIntersectionOverUnionOfHashStringSetsInParallel \- Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB$hashSet\fB\fR represented by a hash, each hash value being a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fB\f(CB$confidence\fB**2\fR and the partition entries are the hash keys of the string sets.
.PP
335 setPartitionOnIntersectionOverUnionOfSetsOfWords \- Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@sets\fB\fR of words so that within each partition the setIntersectionOverUnion of any two sets of words in the partition is never less than the specified \fI\f(CI$confidence\fI**2\fR
.PP
336 setPartitionOnIntersectionOverUnionOfStringSets \- Partition, at a level of \fB\f(CB$confidence\fB\fR between 0 and 1, a set of sets \fB\f(CB@strings\fB\fR, each set represented by a string containing words and punctuation, each word possibly capitalized, so that within each partition the setPartitionOnIntersectionOverUnionOfSetsOfWords of any two sets of words in the partition is never less than the specified \fI\f(CI$confidence\fI**2\fR
.PP
337 setPermissionsForFile \- Apply chmod <https://linux.die.net/man/1/chmod> to a \fB\f(CB$file\fB\fR to set its \fB\f(CB$permissions\fB\fR.
.PP
338 setUnion \- Union of sets \fB\f(CB@s\fB\fR represented as arrays of strings and/or the keys of hashes
.PP
339 showHashes \- Create a map of all the keys within all the hashes within a tower of data structures.
.PP
340 showHashes2 \- Create a map of all the keys within all the hashes within a tower of data structures.
.PP
341 squareArray \- Create a two dimensional square array from a one dimensional linear array.
.PP
342 startProcess \- Start new processes while the number of child processes recorded in \fB%$pids\fR is less than the specified \fB\f(CB$maximum\fB\fR.
.PP
343 storeFile \- Store into a \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, a data \fB\f(CB$structure\fB\fR via Storable <https://metacpan.org/pod/Storable>.
.PP
344 stringMd5Sum \- Get the Md5 sum of a \fB\f(CB$string\fB\fR that might contain utf8 <https://en.wikipedia.org/wiki/UTF-8> code points.
.PP
345 stringsAreNotEqual \- Return the common start followed by the two non equal tails of two non equal strings or an empty list if the strings are equal.
.PP
346 subScriptString \- Convert alphanumerics in a string to sub scripts
.PP
347 subScriptStringUndo \- Undo alphanumerics in a string to sub scripts
.PP
348 sumAbsAndRel \- Combine zero or more absolute and relative names of \fB\f(CB@files\fB\fR starting at the current working folder to get an absolute file name.
.PP
349 summarizeColumn \- Count the number of unique instances of each value a column in a table assumes.
.PP
350 superScriptString \- Convert alphanumerics in a string to super scripts
.PP
351 superScriptStringUndo \- Undo alphanumerics in a string to super scripts
.PP
352 swapFilePrefix \- Swaps the start of a \fB\f(CB$file\fB\fR name from a \fB\f(CB$known\fB\fR name to a \fB\f(CB$new\fB\fR one if the file does in fact start with the \f(CW$known\fR name otherwise returns the original file name as it is.
.PP
353 swapFolderPrefix \- Given a \fB\f(CB$file\fB\fR, swap the folder name of the \f(CW$file\fR from \fB\f(CB$known\fB\fR to \fB\f(CB$new\fB\fR if the file \f(CW$file\fR starts with the \f(CW$known\fR folder name else return the \f(CW$file\fR as it is.
.PP
354 syncFromS3InParallel \- Download from S3 <https://aws.amazon.com/s3/> by using "aws s3 sync \-\-exclude '*' \-\-include '.
.PP
355 syncToS3InParallel \- Upload to S3 <https://aws.amazon.com/s3/> by using "aws s3 sync \-\-exclude '*' \-\-include '.
.PP
356 temporaryFile \- Create a new, empty, temporary file.
.PP
357 temporaryFolder \- Create a new, empty, temporary folder.
.PP
358 timeStamp \- hours:minute:seconds
.PP
359 transitiveClosure \- Transitive closure of a hash of hashes
.PP
360 trim \- Remove any white space from the front and end of a string.
.PP
361 Udsr::kill \- Kill a communications server.
.PP
362 Udsr::read \- Read a message from the newUdsrServer or the newUdsrClient.
.PP
363 Udsr::webUser \- Create a systemd installed server that processes http requests using a specified userid.
.PP
364 Udsr::write \- Write a communications message to the newUdsrServer or the newUdsrClient.
.PP
365 unbless \- Remove the effects of bless from a Perl <http://www.perl.org/> data \fB\f(CB$structure\fB\fR enabling it to be converted to Json <https://en.wikipedia.org/wiki/JSON> or compared with Test::More::is_deeply.
.PP
366 unionOfHashesAsArrays \- Form the union of the specified hashes \fB\f(CB@h\fB\fR as one hash whose values are a array of corresponding values from each hash
.PP
367 unionOfHashKeys \- Form the union of the keys of the specified hashes \fB\f(CB@h\fB\fR as one hash whose keys represent the union.
.PP
368 uniqueNameFromFile \- Create a unique name from a file name and the md5 sum of its content
.PP
369 updateDocumentation \- Update the documentation for a Perl module from the comments in its source code.
.PP
370 updatePerlModuleDocumentation \- Update the documentation in a \fB\f(CB$perlModule\fB\fR and display said documentation in a web browser.
.PP
371 userId \- Get or confirm the userid we are currently running under.
.PP
372 versionCode \- YYYYmmdd-HHMMSS
.PP
373 versionCodeDashed \- YYYY\-mm\-dd\-HH:MM:SS
.PP
374 waitForAllStartedProcessesToFinish \- Wait until all the processes started by startProcess have finished.
.PP
375 wellKnownUrls \- Short names for some well known urls
.PP
376 writeBinaryFile \- Write to a new \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, the binary content in \fB\f(CB$string\fB\fR.
.PP
377 writeFile \- Write to a new \fB\f(CB$file\fB\fR, after creating a path to the \f(CW$file\fR with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
378 writeFiles \- Write the values of a \fB\f(CB$hash\fB\fR reference into files identified by the key of each value using overWriteFile optionally swapping the prefix of each file from \fB\f(CB$old\fB\fR to \fB\f(CB$new\fB\fR.
.PP
379 writeFileToRemote \- Write to a new \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, a \fB\f(CB$string\fB\fR of Unicode <https://en.wikipedia.org/wiki/Unicode> content encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8> then copy the \f(CW$file\fR to the remote server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
380 writeGZipFile \- Write to a \fB\f(CB$file\fB\fR, after creating a path to the file with makePath if necessary, through gzip <https://en.wikipedia.org/wiki/Gzip> a \fB\f(CB$string\fB\fR whose content is encoded as utf8 <https://en.wikipedia.org/wiki/UTF-8>.
.PP
381 writeStructureTest \- Write a test for a data \fB\f(CB$structure\fB\fR with file names in it.
.PP
382 writeTempFile \- Write an array of strings as lines to a temporary file and return the file name.
.PP
383 wwwDecode \- Percent decode a url <https://en.wikipedia.org/wiki/URL> \fB\f(CB$string\fB\fR per: https://en.
.PP
384 wwwEncode \- Percent encode a url <https://en.wikipedia.org/wiki/URL> per: https://en.
.PP
385 wwwGitHubAuth \- Logon as a GitHub <https://github.com> oauth <https://en.wikipedia.org/wiki/OAuth> app per: <https://github.>
.PP
386 xxx \- Execute a shell command optionally checking its response.
.PP
387 xxxr \- Execute a command \fB\f(CB$cmd\fB\fR via bash on the server whose ip address is specified by \fB\f(CB$ip\fB\fR or returned by awsIp.
.PP
388 yyy \- Execute a block of shell commands line by line after removing comments \- stop if there is a non zero return code from any command.
.PP
389 zzz \- Execute lines of commands after replacing new lines with && then check that the pipeline execution results in a return code of zero and that the execution results match the optional regular expression if one has been supplied; \fBconfess()\fR to an error if either check fails.
.SH "Installation"
.IX Header "Installation"
This module is written in 100% Pure Perl and, thus, it is easy to read,
comprehend, use, modify and install via \fBcpan\fR:
.PP
.Vb 1
\&  sudo cpan install Data::Table::Text
.Ve
.SH "Author"
.IX Header "Author"
philiprbrenan@gmail.com <mailto:philiprbrenan@gmail.com>
.PP
<http://www.appaapps.com>
.SH "Copyright"
.IX Header "Copyright"
Copyright (c) 2016\-2019 Philip R Brenan.
.PP
This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.
.SH "Acknowledgements"
.IX Header "Acknowledgements"
Thanks to the following people for their help with this module:
.IP "mim@cpan.org <mailto:mim@cpan.org>" 4
.IX Item "mim@cpan.org <mailto:mim@cpan.org>"
Testing on windows
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 19101:" 4
.IX Item "Around line 19101:"
Unterminated L<...> sequence
