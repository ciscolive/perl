.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "BasicReadNamedCol 3"
.TH BasicReadNamedCol 3 "2006-04-30" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::BasicReadNamedCol \- Methods to easily read data from spreadsheets with columns in the order you want based on the names of the column headings
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides methods for simple reading of a Excel spreadsheet, where the columns
are returned in the order defined.
.PP
Assumes a specific format of the spreadsheet where the first row of
data defined the names of the columns.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Spreadsheet::BasicReadNamedCol;
\&
\& my $xlsFileName = \*(AqExcel Price Sheet 021203.xls\*(Aq;
\& my @columnHeadings = (
\&    \*(AqSupplier Part Number\*(Aq,
\&    \*(AqCustomer Price\*(Aq,
\&    \*(AqCurrency Code\*(Aq,
\&    \*(AqPrice UOM\*(Aq,
\&    \*(AqShort Description\*(Aq,
\&    \*(AqLong Description\*(Aq,
\& );
\&
\& my $ss = new Spreadsheet::BasicReadNamedCol($xlsFileName) ||
\&    die "Could not open \*(Aq$xlsFileName\*(Aq: $!";
\& $ss\->setColumns(@columnHeadings);
\&
\& # Print each row of the spreadsheet in the order defined in
\& # the columnHeadings array
\& my $row = 0;
\& while (my $data = $ss\->getNextRow())
\& {
\&    $row++;
\&    print join(\*(Aq|\*(Aq, $row, @$data), "\en";
\& }
.Ve
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
The following modules are required:
.PP
.Vb 2
\& Spreadsheet::BasicRead
\& Spreadsheet::ParseExcel
.Ve
.SH "METHODS"
.IX Header "METHODS"
There are no class methods, the object methods are described below.
Private class method start with the underscore character '_' and
should be treated as \fIPrivate\fR.
.SS "new"
.IX Subsection "new"
Called to create a new BasicReadNamedCol object.  The arguments can
be either a single string (see '\s-1SYNOPSIS\s0')
which is taken as the filename of the spreadsheet of as named arguments.
.PP
.Vb 7
\& eg.  my $ss = Spreadsheet::BasicReadNamedCol\->new(
\&                  columns       => \e@columnNames,
\&                  fileName      => \*(AqMyExcelSpreadSheet.xls\*(Aq,
\&                  skipHeadings  => 1,
\&                  skipBlankRows => 1,
\&                  log           => $log,
\&                  );
.Ve
.PP
The following named arguments are available:
.IP "columns" 4
.IX Item "columns"
Value expected to be an array reference to a list of column
names that appear in the first line of the spreadsheet.  The
order of the column names defines the order in which the data
is returned by the 'getNextRow' method.
.Sp
This is really useful where spreadsheet files from sources out
of your control are not consistant in the ordering of columns.
.Sp
Note that the match on column name uses the following pattern match:
.Sp
.Vb 1
\& if ($realColName =~ /^\eQ$name/i)
\&
\& where:
\&   realColName \- is the actual column name in the spreadsheet and
\&   name        \- is the pattern to match
.Ve
.IP "skipHeadings" 4
.IX Item "skipHeadings"
Don't output the headings line in the first call to
\&'getNextRow' if true.
.IP "skipBlankRows" 4
.IX Item "skipBlankRows"
Skip blank lines in the spreadsheet if true.
.IP "setColumns(array or array_ref)" 4
.IX Item "setColumns(array or array_ref)"
Sets the order that columns will be returned in based on the
names in the array provided.  The names are expected to match
the values in the first row of the spreadsheet.
.IP "log" 4
.IX Item "log"
Use the File::Log object to log exceptions.
.IP "fileName" 4
.IX Item "fileName"
The name (and optionally path) of the spreadsheet file to process.
.SS "\fBgetNextRow()\fP"
.IX Subsection "getNextRow()"
Get the next row of data from the spreadsheet.  The data is
returned as an array reference.
.PP
.Vb 1
\&  eg.  $rowDataArrayRef = $ss\->getNextRow();
.Ve
.SS "\fBnumSheets()\fP"
.IX Subsection "numSheets()"
Returns the number of sheets in the spreadsheet
.SS "openSpreadsheet(fileName)"
.IX Subsection "openSpreadsheet(fileName)"
Open a new spreadsheet file and set the current sheet to the first
sheet.  The name and optionally path of the
spreadsheet file is a required argument to this method.
.SS "\fBcurrentSheetNum()\fP"
.IX Subsection "currentSheetNum()"
Returns the current sheet number or undef if there is no current sheet.
\&'setCurrentSheetNum' can be called to set the
current sheet.
.SS "\fBcurrentSheetName()\fP"
.IX Subsection "currentSheetName()"
Return the name of the current sheet or undef if the current sheet is
not defined.  see 'setCurrentSheetNum'.
.SS "setCurrentSheetNum(num)"
.IX Subsection "setCurrentSheetNum(num)"
Sets the current sheet to the integer value 'num' passed as the required
argument to this method.  Note that this should not be bigger than
the value returned by 'numSheets'.
.SS "\fBgetNextSheet()\fP"
.IX Subsection "getNextSheet()"
Returns the next sheet \*(L"ssBook\*(R" object or undef if there are no more sheets
to process.  If there is no current sheet defined the first sheet
is returned.
.SS "\fBgetFirstSheet()\fP"
.IX Subsection "getFirstSheet()"
Returns the first sheet \*(L"ssBook\*(R" object.
.SS "cellValue(row, col)"
.IX Subsection "cellValue(row, col)"
Returns the value of the cell defined by (row, col)in the current sheet.
.SS "\fBgetFirstRow()\fP"
.IX Subsection "getFirstRow()"
Returns the first row of data from the spreadsheet (possibly skipping the
column headings  'skipHeadings') as an array reference.
.SS "setHeadingRow(rowNumber)"
.IX Subsection "setHeadingRow(rowNumber)"
Sets the effective minimum row for the spreadsheet to 'rowNumber', since it
is assumed that the heading is on this row and anything above the heading is
not relavent.
.PP
\&\fBNote:\fR the row (and column) numbers are zero indexed.
.SS "logexp(message)"
.IX Subsection "logexp(message)"
Logs an exception message (can be a list of strings) using the File::Log
object if it was defined and then calls die message.
.SS "logmsg(debug, message)"
.IX Subsection "logmsg(debug, message)"
If a File::Log object was passed as a named argument 'new') and
if 'debug' (integer value) is equal to or greater than the current debug
Level (see File::Log) then the message is added to the log file.
.PP
If a File::Log object was not passed to new then the message is output to
\&\s-1STDERR.\s0
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
None
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Spreadsheet::BasicRead
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Greg George, IT Technology Solutions P/L, Australia
\& Mobile: 0404\-892\-159, Email: gng@cpan.org
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1999\- Greg George. All rights reserved. This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "CVS ID"
.IX Header "CVS ID"
\&\f(CW$Id:\fR BasicReadNamedCol.pm,v 1.3 2006/04/30 05:57:29 Greg Exp $
.SH "UPDATE HISTORY"
.IX Header "UPDATE HISTORY"
\&\f(CW$Log:\fR BasicReadNamedCol.pm,v $
Revision 1.3  2006/04/30 05:57:29  Greg
\&\- removed tabs from file
.PP
Revision 1.2  2006/03/07 10:03:26  Greg
\&\- minor pod changes
.PP
Revision 1.1  2006/03/05 03:07:58  Greg
\&\- initial \s-1CPAN\s0 upload
.PP
Revision 1.0  2003/12/02 23:58:34  gxg6
\&\- Initial development, need \s-1POD\s0
