.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Milter::Authentication::Handler 3"
.TH Mail::Milter::Authentication::Handler 3 "2020-09-30" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Milter::Authentication::Handler \- Handler superclass
.SH "VERSION"
.IX Header "VERSION"
version 2.20200930.2
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Handle the milter requests and pass off to individual handlers
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew( \fP\f(CI$thischild\fP\fI )\fP"
.IX Subsection "new( $thischild )"
my \f(CW$object\fR = Mail::Milter::Authentication::Handler\->new( \f(CW$thischild\fR );
.PP
Takes the argument of the current Mail::Milter::Authentication object
and creates a new handler object.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fI\fP\f(BIget_version()\fP\fI\fP"
.IX Subsection "get_version()"
Return the version of this handler
.SS "\fIstatus( \fP\f(CI$status\fP\fI )\fP"
.IX Subsection "status( $status )"
Set the status of the current child as visible by ps.
.SS "\fI\fP\f(BIconfig()\fP\fI\fP"
.IX Subsection "config()"
Return the configuration hashref.
.SS "\fIhandler_config( \fP\f(CI$type\fP\fI )\fP"
.IX Subsection "handler_config( $type )"
Return the configuration for the current handler.
.SS "\fI\fP\f(BIhandler_type()\fP\fI\fP"
.IX Subsection "handler_type()"
Return the current handler type.
.SS "\fIset_return( \fP\f(CI$code\fP\fI )\fP"
.IX Subsection "set_return( $code )"
Set the return code to be passed back to the \s-1MTA.\s0
.SS "\fI\fP\f(BIget_return()\fP\fI\fP"
.IX Subsection "get_return()"
Get the current return code.
.SS "\fI\fP\f(BIget_reject_mail()\fP\fI\fP"
.IX Subsection "get_reject_mail()"
Get the reject mail reason (or undef)
.SS "\fI\fP\f(BIclear_reject_mail()\fP\fI\fP"
.IX Subsection "clear_reject_mail()"
Clear the reject mail reason
.SS "\fI\fP\f(BIget_defer_mail()\fP\fI\fP"
.IX Subsection "get_defer_mail()"
Get the defer mail reason (or undef)
.SS "\fI\fP\f(BIclear_defer_mail()\fP\fI\fP"
.IX Subsection "clear_defer_mail()"
Clear the defer mail reason
.SS "\fI\fP\f(BIget_quarantine_mail()\fP\fI\fP"
.IX Subsection "get_quarantine_mail()"
Get the quarantine mail reason (or undef)
.SS "\fI\fP\f(BIclear_quarantine_mail()\fP\fI\fP"
.IX Subsection "clear_quarantine_mail()"
Clear the quarantine mail reason
.SS "\fI\fP\f(BIget_top_handler()\fP\fI\fP"
.IX Subsection "get_top_handler()"
Return the current top Handler object.
.SS "\fIis_handler_loaded( \fP\f(CI$name\fP\fI )\fP"
.IX Subsection "is_handler_loaded( $name )"
Check if the named handler is loaded.
.SS "\fIget_handler( \fP\f(CI$name\fP\fI )\fP"
.IX Subsection "get_handler( $name )"
Return the named handler object.
.SS "\fIget_callbacks( \fP\f(CI$callback\fP\fI )\fP"
.IX Subsection "get_callbacks( $callback )"
Return the list of handlers which have callbacks for the given event in the order they must be called in.
.SS "\fIset_object_maker( \fP\f(CI$name\fP\fI, \fP\f(CI$ref\fP\fI )\fP"
.IX Subsection "set_object_maker( $name, $ref )"
Register an object maker for type 'name'
.SS "\fIget_object( \fP\f(CI$name\fP\fI )\fP"
.IX Subsection "get_object( $name )"
Return the named object from the object store.
.PP
Object 'resolver' will be created if it does not already exist.
.PP
Object 'spf_server' will be created by the \s-1SPF\s0 handler if it does not already exist.
.PP
Handlers may register makers for other types as required.
.SS "\fIset_object( \fP\f(CI$name\fP\fI, \fP\f(CI$object\fP\fI, \fP\f(CI$destroy\fP\fI )\fP"
.IX Subsection "set_object( $name, $object, $destroy )"
Store the given object in the object store with the given name.
.PP
If \f(CW$destroy\fR then the object will be destroyed when the connection to the child closes
.SS "\fIdestroy_object( \fP\f(CI$name\fP\fI )\fP"
.IX Subsection "destroy_object( $name )"
Remove the reference to the named object from the object store.
.SS "\fI\fP\f(BIdestroy_all_objects()\fP\fI\fP"
.IX Subsection "destroy_all_objects()"
Remove the references to all objects currently stored in the object store.
.PP
Certain objects (resolver and spf_server) are not destroyed for performance reasons.
.SS "\fIexit_on_close( \fP\f(CI$error\fP\fI )\fP"
.IX Subsection "exit_on_close( $error )"
Exit this child once it has completed, do not process further requests with this child.
.SS "\fIreject_mail( \fP\f(CI$reason\fP\fI )\fP"
.IX Subsection "reject_mail( $reason )"
Reject mail with the given reason
.SS "\fIquarantine_mail( \fP\f(CI$reason\fP\fI )\fP"
.IX Subsection "quarantine_mail( $reason )"
Request quarantine mail with the given reason
.SS "\fIdefer_mail( \fP\f(CI$reason\fP\fI )\fP"
.IX Subsection "defer_mail( $reason )"
Defer mail with the given reason
.SS "\fI\fP\f(BIclear_all_symbols()\fP\fI\fP"
.IX Subsection "clear_all_symbols()"
Clear the symbol store.
.SS "\fI\fP\f(BIclear_symbols()\fP\fI\fP"
.IX Subsection "clear_symbols()"
Clear the symbol store but do not remove the Connect symbols.
.SS "\fIset_symbol( \fP\f(CI$code\fP\fI, \fP\f(CI$key\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "set_symbol( $code, $key, $value )"
Store the key value pair in the symbol store with the given code (event stage).
.SS "\fIget_symbol( \fP\f(CI$searchkey\fP\fI )\fP"
.IX Subsection "get_symbol( $searchkey )"
Return a value from the symbol store, searches all codes for the given key.
.SS "\fI\fP\f(BItempfail_on_error()\fP\fI\fP"
.IX Subsection "tempfail_on_error()"
Returns a \s-1TEMP FAIL\s0 to the calling \s-1MTA\s0 if the configuration is set to do so.
.PP
Config can be set for all, authenticated, local, and trusted connections.
.SS "\fIcan_sort_header( \fP\f(CI$header\fP\fI )\fP"
.IX Subsection "can_sort_header( $header )"
Returns 1 is this handler has a header_sort method capable or sorting entries for \f(CW$header\fR
Returns 0 otherwise
.SS "\fI\fP\f(BIheader_sort()\fP\fI\fP"
.IX Subsection "header_sort()"
Sorting function for sorting the Authentication-Results headers
Calls out to _\|_HANDLER_\|_\->\fBheader_sort()\fR to sort headers of a particular type if available,
otherwise sorts alphabetically.
.SS "\fI\fP\f(BIadd_headers()\fP\fI\fP"
.IX Subsection "add_headers()"
Send the header changes to the \s-1MTA.\s0
.SS "\fIprepend_header( \fP\f(CI$field\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "prepend_header( $field, $value )"
Add a trace header to the email.
.SS "\fIadd_auth_header( \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "add_auth_header( $value )"
Add a section to the authentication header for this email.
.SS "\fIadd_c_auth_header( \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "add_c_auth_header( $value )"
Add a section to the authentication header for this email, and to any subsequent emails for this connection.
.SS "\fIappend_header( \fP\f(CI$field\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "append_header( $field, $value )"
Add a normal header to the email.
.SH "METRICS METHODS"
.IX Header "METRICS METHODS"
.SS "\fIget_json( \fP\f(CI$file\fP\fI )\fP"
.IX Subsection "get_json( $file )"
Return json data from external file
.SS "\fImetric_register( \fP\f(CI$id\fP\fI, \fP\f(CI$help\fP\fI )\fP"
.IX Subsection "metric_register( $id, $help )"
Register a metric type
.SS "\fImetric_count( \fP\f(CI$id\fP\fI, \fP\f(CI$labels\fP\fI, \fP\f(CI$count\fP\fI )\fP"
.IX Subsection "metric_count( $id, $labels, $count )"
Increment a metrics counter by \f(CW$count\fR (defaults to 1 if undef)
.SS "\fImetric_set( \fP\f(CI$id\fP\fI, \fP\f(CI$labels\fP\fI, \fP\f(CI$count\fP\fI )\fP"
.IX Subsection "metric_set( $id, $labels, $count )"
Set a metrics counter to \f(CW$count\fR
.SS "\fI\fP\f(BImetric_send()\fP\fI\fP"
.IX Subsection "metric_send()"
Send metrics to the parent
.SS "\fI\fP\f(BIregister_metrics()\fP\fI\fP"
.IX Subsection "register_metrics()"
Return details of the metrics this module exports.
.SH "RBL METHODS"
.IX Header "RBL METHODS"
.SS "\fIrbl_check_ip( \fP\f(CI$ip\fP\fI, \fP\f(CI$list\fP\fI )\fP"
.IX Subsection "rbl_check_ip( $ip, $list )"
Check the given \s-1IP\s0 address against an rbl list.
.PP
Returns true is listed.
.SS "\fIrbl_check_domain( \fP\f(CI$domain\fP\fI, \fP\f(CI$list\fP\fI )\fP"
.IX Subsection "rbl_check_domain( $domain, $list )"
Check the given domain against an rbl list.
.PP
Returns true is listed.
.SH "TIMEOUT METHODS"
.IX Header "TIMEOUT METHODS"
.SS "\fI\fP\f(BIget_microseconds()\fP\fI\fP"
.IX Subsection "get_microseconds()"
Return the current time in microseconds
.SS "\fIget_microseconds_since( \fP\f(CI$time\fP\fI )\fP"
.IX Subsection "get_microseconds_since( $time )"
Return the number of microseconds since the given time (in microseconds)
.SS "\fIis_exception_type( \fP\f(CI$exception\fP\fI )\fP"
.IX Subsection "is_exception_type( $exception )"
Given a Mail::Milter::Authentication::Exception object, this return
the exception object type.
Otherwise returns undef.
.SS "\fIhandle_exception( \fP\f(CI$exception\fP\fI )\fP"
.IX Subsection "handle_exception( $exception )"
Handle exceptions thrown, this method currently handles the
timeout type, by re-throwing the exception.
.PP
Should be called in Handlers when handling local exceptions, such that the
higher level timeout exceptions are properly handled.
.SS "\fI\fP\f(BIget_time_remaining()\fP\fI\fP"
.IX Subsection "get_time_remaining()"
Return the time remaining (in microseconds) for the current Handler section level
callback timeout.
.SS "\fIset_alarm( \fP\f(CI$microseconds\fP\fI )\fP"
.IX Subsection "set_alarm( $microseconds )"
Set a timeout alarm for \f(CW$microseconds\fR, and set the time remaining
in the top level handler object.
.SS "\fIset_handler_alarm( \fP\f(CI$microseconds\fP\fI )\fP"
.IX Subsection "set_handler_alarm( $microseconds )"
Set an alarm for \f(CW$microseconds\fR, or the current time remaining for the section callback, whichever
is the lower. This should be used in Handler timeouts to ensure that a local timeout never goes for
longer than the current handler section, or protocol section level timeout.
.SS "\fI\fP\f(BIreset_alarm()\fP\fI\fP"
.IX Subsection "reset_alarm()"
Reset the alarm to the current time remaining in the section or protocol level timeouts.
.PP
This should be called in Handlers after local timeouts have completed, to reset the higher level
timeout alarm value.
.SS "\fI\fP\f(BIclear_overall_timeout()\fP\fI\fP"
.IX Subsection "clear_overall_timeout()"
Clear the current Handler level timeout, should be called from the Protocol layer, never from the Handler layer.
.SS "\fIset_overall_timeout( \fP\f(CI$microseconds\fP\fI )\fP"
.IX Subsection "set_overall_timeout( $microseconds )"
Set the time in microseconds after which the Handler layer should timeout, called from the Protocol later, never from the Handler layer.
.SS "\fIget_type_timeout( \fP\f(CI$type\fP\fI )\fP"
.IX Subsection "get_type_timeout( $type )"
For a given timeout type, return the configured timeout value, or the current handler level timeout, whichever is lower.
.SS "\fI\fP\f(BIcheck_timeout()\fP\fI\fP"
.IX Subsection "check_timeout()"
Manually check the current timeout, and throw if it has passed.
.SH "CALLBACK METHODS"
.IX Header "CALLBACK METHODS"
.SS "\fI\fP\f(BItop_dequeue_callback()\fP\fI\fP"
.IX Subsection "top_dequeue_callback()"
Top level handler for dequeue.
.SS "\fI\fP\f(BItop_setup_callback()\fP\fI\fP"
.IX Subsection "top_setup_callback()"
Top level handler for handler setup.
.SS "\fIremap_connect_callback( \fP\f(CI$hostname\fP\fI, \fP\f(CI$ip\fP\fI )\fP"
.IX Subsection "remap_connect_callback( $hostname, $ip )"
Top level handler for the connect event for remapping only.
.SS "\fI\fP\f(BItop_metrics_callback()\fP\fI\fP"
.IX Subsection "top_metrics_callback()"
Top level handler for the metrics event.
.SS "\fItop_connect_callback( \fP\f(CI$hostname\fP\fI, \fP\f(CI$ip\fP\fI )\fP"
.IX Subsection "top_connect_callback( $hostname, $ip )"
Top level handler for the connect event.
.SS "\fIremap_helo_callback( \fP\f(CI$helo_host\fP\fI )\fP"
.IX Subsection "remap_helo_callback( $helo_host )"
Top level handler for the \s-1HELO\s0 event for remapping only.
.SS "\fItop_helo_callback( \fP\f(CI$helo_host\fP\fI )\fP"
.IX Subsection "top_helo_callback( $helo_host )"
Top level handler for the \s-1HELO\s0 event.
.SS "\fItop_envfrom_callback( \fP\f(CI$env_from\fP\fI )\fP"
.IX Subsection "top_envfrom_callback( $env_from )"
Top level handler for the \s-1MAIL FROM\s0 event.
.SS "\fItop_envrcpt_callback( \fP\f(CI$env_to\fP\fI )\fP"
.IX Subsection "top_envrcpt_callback( $env_to )"
Top level handler for the \s-1RCPT TO\s0 event.
.SS "\fItop_header_callback( \fP\f(CI$header\fP\fI, \fP\f(CI$value\fP\fI, \fP\f(CI$original\fP\fI )\fP"
.IX Subsection "top_header_callback( $header, $value, $original )"
Top level handler for the \s-1BODY\s0 header event.
.SS "\fI\fP\f(BItop_eoh_callback()\fP\fI\fP"
.IX Subsection "top_eoh_callback()"
Top level handler for the \s-1BODY\s0 end of headers event.
.SS "\fItop_body_callback( \fP\f(CI$body_chunk\fP\fI )\fP"
.IX Subsection "top_body_callback( $body_chunk )"
Top level handler for the \s-1BODY\s0 body chunk event.
.SS "\fI\fP\f(BItop_eom_callback()\fP\fI\fP"
.IX Subsection "top_eom_callback()"
Top level handler for the \s-1BODY\s0 end of message event.
.SS "\fI\fP\f(BIapply_policy()\fP\fI\fP"
.IX Subsection "apply_policy()"
Apply policy to the message, currently a nop.
.SS "\fI\fP\f(BItop_abort_callback()\fP\fI\fP"
.IX Subsection "top_abort_callback()"
Top level handler for the abort event.
.SS "\fI\fP\f(BItop_close_callback()\fP\fI\fP"
.IX Subsection "top_close_callback()"
Top level handler for the close event.
.SS "\fI\fP\f(BItop_addheader_callback()\fP\fI\fP"
.IX Subsection "top_addheader_callback()"
Top level handler for the add header event.
.PP
Called after the Authentication-Results header has been added, but before any other headers.
.SH "HELPER METHODS"
.IX Header "HELPER METHODS"
.SS "\fIadd_dequeue($key,$data)\fP"
.IX Subsection "add_dequeue($key,$data)"
Write serialized \f(CW$data\fR into the queue for later dequeueing
.SS "\fIget_dequeue_list($key)\fP"
.IX Subsection "get_dequeue_list($key)"
Return an ArrayRef of all queued items for \f(CW$key\fR
.PP
This may be a list of filenames, or may be a list of some
other \s-1ID,\s0 it should not be assumed that this value is
useful outside of the dequeue methods.
.PP
Used in get_dequeue_object and delete_dequeue_object
.SS "\fIget_dequeue($id)\fP"
.IX Subsection "get_dequeue($id)"
Return a previously queued item
.SS "\fIdelete_dequeue($id)\fP"
.IX Subsection "delete_dequeue($id)"
Delete a previously queued item
.SS "\fI\fP\f(BIis_local_ip_address()\fP\fI\fP"
.IX Subsection "is_local_ip_address()"
Is the current connection from a local ip address?
.PP
Requires the LocalIP Handler to be loaded.
.SS "\fI\fP\f(BIis_trusted_ip_address()\fP\fI\fP"
.IX Subsection "is_trusted_ip_address()"
Is the current connection from a trusted ip address?
.PP
Requires the TrustedIP Handler to be loaded.
.SS "\fI\fP\f(BIis_encrypted()\fP\fI\fP"
.IX Subsection "is_encrypted()"
Is the current connection encrypted?
.PP
Requires the \s-1TLS\s0 Handler to be loaded.
.PP
In \s-1SMTP\s0 mode this is only available \s-1AFTER\s0 the eoh call.
.PP
Returns undef if the state is not yet known.
.SS "\fI\fP\f(BIis_authenticated()\fP\fI\fP"
.IX Subsection "is_authenticated()"
Is the current connection authenticated?
.PP
Requires the Auth Handler to be loaded.
.SS "\fI\fP\f(BIip_address()\fP\fI\fP"
.IX Subsection "ip_address()"
Return the ip address of the current connection.
.SS "\fIformat_ctext( \fP\f(CI$text\fP\fI )\fP"
.IX Subsection "format_ctext( $text )"
Format text as ctext for use in headers.
.PP
Deprecated.
.SS "\fIformat_ctext_no_space( \fP\f(CI$text\fP\fI )\fP"
.IX Subsection "format_ctext_no_space( $text )"
Format text as ctext with no spaces for use in headers.
.PP
Deprecated.
.SS "\fIformat_header_comment( \fP\f(CI$comment\fP\fI )\fP"
.IX Subsection "format_header_comment( $comment )"
Format text as a comment for use in headers.
.PP
Deprecated.
.SS "\fIformat_header_entry( \fP\f(CI$key\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "format_header_entry( $key, $value )"
Format text as a key value pair for use in authentication header.
.PP
Deprecated.
.SS "\fIget_domain_from( \fP\f(CI$address\fP\fI )\fP"
.IX Subsection "get_domain_from( $address )"
Extract a single domain from an email address.
.SS "\fIget_domains_from( \fP\f(CI$address\fP\fI )\fP"
.IX Subsection "get_domains_from( $address )"
Extract the domains from an email address as an arrayref.
.SS "\fIget_address_from( \fP\f(CI$text\fP\fI )\fP"
.IX Subsection "get_address_from( $text )"
Extract a single email address from a string.
.SS "\fIget_addresses_from( \fP\f(CI$text\fP\fI )\fP"
.IX Subsection "get_addresses_from( $text )"
Extract all email address from a string as an arrayref.
.SS "\fI\fP\f(BIget_my_hostname()\fP\fI\fP"
.IX Subsection "get_my_hostname()"
Return the effective hostname of the \s-1MTA.\s0
.SH "LOGGING METHODS"
.IX Header "LOGGING METHODS"
.SS "\fIdbgout( \fP\f(CI$key\fP\fI, \fP\f(CI$value\fP\fI, \fP\f(CI$priority\fP\fI )\fP"
.IX Subsection "dbgout( $key, $value, $priority )"
Send output to debug and/or Mail Log.
.PP
priority is a standard Syslog priority.
.SS "\fIlog_error( \fP\f(CI$error\fP\fI )\fP"
.IX Subsection "log_error( $error )"
Log an error.
.SS "\fI\fP\f(BIdbgoutwrite()\fP\fI\fP"
.IX Subsection "dbgoutwrite()"
Write out logs to disc.
.PP
Logs are not written immediately, they are written at the end of a connection so we can
include a queue id. This is not available at the start of the process.
.SH "LOW LEVEL METHODS"
.IX Header "LOW LEVEL METHODS"
.SS "\fI\fP\f(BIsmfis_continue()\fP\fI\fP"
.IX Subsection "smfis_continue()"
Return Continue code.
.SS "\fI\fP\f(BIsmfis_tempfail()\fP\fI\fP"
.IX Subsection "smfis_tempfail()"
Return TempFail code.
.SS "\fI\fP\f(BIsmfis_reject()\fP\fI\fP"
.IX Subsection "smfis_reject()"
Return Reject code.
.SS "\fI\fP\f(BIsmfis_discard()\fP\fI\fP"
.IX Subsection "smfis_discard()"
Return Discard code.
.SS "\fI\fP\f(BIsmfis_accept()\fP\fI\fP"
.IX Subsection "smfis_accept()"
Return Accept code.
.SS "\fIwrite_packet( \fP\f(CI$type\fP\fI, \fP\f(CI$data\fP\fI )\fP"
.IX Subsection "write_packet( $type, $data )"
Write a packet to the \s-1MTA\s0 (calls Protocol object)
.SS "\fIadd_header( \fP\f(CI$key\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "add_header( $key, $value )"
Write an Add Header packet to the \s-1MTA\s0 (calls Protocol object)
.SS "\fIinsert_header( \fP\f(CI$index\fP\fI, \fP\f(CI$key\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "insert_header( $index, $key, $value )"
Write an Insert Header packet to the \s-1MTA\s0 (calls Protocol object)
.SS "\fIchange_header( \fP\f(CI$key\fP\fI, \fP\f(CI$index\fP\fI, \fP\f(CI$value\fP\fI )\fP"
.IX Subsection "change_header( $key, $index, $value )"
Write a Change Header packet to the \s-1MTA\s0 (calls Protocol object)
.SH "WRITING HANDLERS"
.IX Header "WRITING HANDLERS"
tbc
.SH "AUTHOR"
.IX Header "AUTHOR"
Marc Bradshaw <marc@marcbradshaw.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Marc Bradshaw.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
