.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Group 3"
.TH Test::Group 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Group \- Group together related tests in a test suite
.SH "VERSION"
.IX Header "VERSION"
Test::Group version 0.20
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Basics:
.PP
.Vb 2
\&    use Test::More no_plan => 1;
\&    use Test::Group;
\&
\&    test "hammering the server" => sub {
\&        ok(I_can_connect);
\&        for(1..1000) {
\&           ok(I_can_make_a_request);
\&        }
\&    }; # Don\*(Aqt forget the semicolon here!
.Ve
.PP
Failed subtests are displayed \fIbefore\fR the result of the test they belong to.
For instance,
.PP
.Vb 2
\&    use Test::More no_plan => 1;
\&    use Test::Group;
\&
\&    test "this test group will fail", sub {
\&        ok 1, "sub test blah";
\&        is "foo", "bar", "I so wish they were the same...";
\&        ok 1;
\&        like   "blah blah blah", qr/bla/;
\&    };
.Ve
.PP
produces something like this:
.PP
.Vb 8
\&    #   Failed test \*(AqI so wish they were the same...\*(Aq
\&    #   in test.pl at line 6.
\&    #          got: \*(Aqfoo\*(Aq
\&    #     expected: \*(Aqbar\*(Aq
\&    not ok 1 \- this test group will fail
\&    #   Failed test \*(Aqthis test group will fail\*(Aq
\&    #   in test.pl at line 9.
\&    1..1
.Ve
.PP
Exceptions in tests are not fatal:
.PP
.Vb 4
\&    test "this test will fail but the suite will proceed", sub {
\&        pass;
\&        die;
\&    };
.Ve
.PP
Test::More style \s-1TODO\s0 support:
.PP
.Vb 4
\&    test "a test with TODO in the name is marked TODO" => sub {
\&          pass("this part is done");
\&          fail("but I\*(Aqm not finished with this one yet");
\&    };
\&
\&    {
\&      local $TODO = "Test::More\*(Aqs good old method also works";
\&      test "this test is not finished yet" => sub {
\&          pass;
\&          fail;
\&      };
\&    };
.Ve
.PP
Misc:
.PP
.Vb 2
\&    # Don\*(Aqt catch exceptions raised in test groups later on
\&    Test::Group\->dont_catch_exceptions;
\&
\&    # log caught exceptions in /tmp/log
\&    Test::Group\->logfile("/tmp/log");
\&
\&    # skip the next group of test
\&    skip_next_test "network not available" if (! Network\->available());
\&    test "bla", sub {
\&        my $ftp = Net::FTP\->new("some.host.name");
\&        # ...
\&    };
\&
\&    begin_skipping_tests "reason";
\&
\&    test "this test will not run" => sub {
\&        # ...
\&    };
\&
\&    end_skipping_tests;
\&
\&    # from now on, skip all tests whose names do not match /bla/
\&    test_only qr/bla/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Fed up with counting tests to discover what went wrong in your last
test run?  Tired of squinting at your test source to find out where on
earth the faulty test predicate is called, and what it is supposed to
check for?  Then this module is for you!
.PP
\&\fITest::Group\fR allows for grouping together related tests in a
standard \fITest::More\fR\-style script. (If you are not already familiar
with Test::More, now would be the time to go take a look.)
\&\fITest::Group\fR provides a bunch of maintainability and scalability
advantages to large test suites:
.IP "\(bu" 4
related tests can be grouped and given a name. The intent of the test
author is therefore made explicit with much less effort than would be
needed to name all the individual tests;
.IP "\(bu" 4
the test output is much shorter and more readable: only failed
subtests show a diagnostic, while test groups with no problems inside
produce a single friendly \f(CW\*(C`ok\*(C'\fR line;
.IP "\(bu" 4
no more tedious test counting: running an arbitrarily large or
variable number of tests (e.g. in loops) is now hassle-free and
doesn't clutter the test output.
.PP
Authors of \fITest::*\fR modules may also find \fITest::Group\fR of
interest, because it allows for composing several Test::More
predicates into a single one (see \*(L"Reflexivity\*(R").
.SH "FEATURES"
.IX Header "FEATURES"
.SS "Blocking Exceptions"
.IX Subsection "Blocking Exceptions"
By default, calls to \*(L"die\*(R" in perlfunc and other exceptions from within
a test group cause it to fail and terminates execution of the group,
but does not terminate whole script.  This relieves the programmer
from having to worry about code that may throw in tests.
.PP
This behavior can be disabled totally using \*(L"dont_catch_exceptions\*(R".
Exceptions can also be trapped as usual using \*(L"eval\*(R" in perlfunc or
otherwise from inside a group, in which case the test code of course
has full control on what to do next (this is how one should test error
management, by the way).
.PP
When Test::Group is set to block errors (the default setting, see also
\&\*(L"catch_exceptions\*(R"), the error messages are displayed as part of the
test name, which some may not find very readable.  Therefore, one can
use a \*(L"logfile\*(R" instead.
.SS "Skipping Groups"
.IX Subsection "Skipping Groups"
\&\fITest::Group\fR can skip single test groups or a range of them
(consecutive or matched by a regex), which helps shortening the debug
cycle even more in test-driven programming.  When a test group is
skipped, the code within it is simply not executed, and the test is
marked as skipped wrt Test::Builder.  See \*(L"skip_next_test\*(R",
\&\*(L"skip_next_tests\*(R", \*(L"begin_skipping_tests\*(R", \*(L"end_skipping_tests\*(R"
and \*(L"test_only\*(R" for details.
.SS "Reflexivity"
.IX Subsection "Reflexivity"
Test groups integrate with Test::Builder by acting as a single big
test; therefore, \fITest::Group\fR is fully reflexive.  A particularly
attractive consequence is that constructing new Test::More
predicates is straightforward with \fITest::Group\fR.  For example,
.PP
.Vb 2
\&    use Test::Builder;
\&    use Test::Group;
\&
\&    sub foobar_ok {
\&        my ($text, $name) = @_;
\&        $name ||= "foobar_ok";
\&        local $Test::Builder::Level = $Test::Builder::Level + 1;
\&        test $name => sub {
\&           local $Test::Group::InPredicate = 1;
\&           like($text, qr/foo/, "foo ok");
\&           like($text, qr/bar/, "bar ok");
\&        };
\&    }
.Ve
.PP
defines a new test predicate \fIfoobar_ok\fR that will \s-1DWIM\s0 regardless of
the caller's testing style: for \*(L"classical\*(R" Test::Simple or
Test::More users, \fIfoobar_ok\fR will act as just another \fI*_ok\fR
predicate (in particular, it always counts for a single test, honors
\&\*(L"\s-1TODO: BLOCK\*(R"\s0 in Test::More constructs, etc); and of course, users of
\&\fITest::Group\fR can freely call \fIfoobar_ok\fR from within a group.
.PP
Adding 1 to \f(CW$Test::Builder::Level\fR causes the location of the call
to \fBfoobar_ok()\fR to be shown if a test fails, see Test::Builder.
.PP
Setting \f(CW$Test::Group::InPredicate\fR to a true value prevents the
location of individual failing tests within test groups from being
shown.
.SS "\s-1TODO\s0 Tests"
.IX Subsection "TODO Tests"
As shown in \*(L"\s-1SYNOPSIS\*(R"\s0, Test::More's concept of \s-1TODO\s0 tests is
supported by \fITest::Group\fR: a group is in \s-1TODO\s0 state if the \f(CW$TODO\fR
variable is set by the time it starts, or if the test name contains
the word \f(CW\*(C`TODO\*(C'\fR.  Note, however, that setting \f(CW$TODO\fR from \fBinside\fR
the test group (that is, \fBafter\fR the group starts) will not do what
you mean:
.PP
.Vb 5
\&   test "something" => sub {
\&       local $TODO = "this test does not work yet";
\&       pass;                                         # GOTCHA!
\&       fail;
\&   };
.Ve
.PP
Here \f(CW\*(C`pass\*(C'\fR is an unexpected success, and therefore the whole test
group will report a \s-1TODO\s0 success despite the test not actually being a
success (that is, it would \fBalso\fR be defective if one were to comment
out the \f(CW\*(C`local $TODO\*(C'\fR line).  This semantics, on the other hand,
DWIMs for marking a \fBportion\fR of the test group as \s-1TODO:\s0
.PP
.Vb 7
\&   test "something" => sub {
\&       pass;
\&       {
\&          local $TODO = "this part does not work yet";
\&          fail;
\&       }
\&   };
.Ve
.PP
Finally, there is a subtle gotcha to be aware of when setting \f(CW$TODO\fR
outside a test group (that's the second one, so maybe you should not
do that to begin with).  In this case, the value of \f(CW$TODO\fR is set to
undef \fBinside\fR the group.  In other words, this test (similar to the
one to be found in \*(L"\s-1SYNOPSIS\*(R"\s0) will succeed as expected:
.PP
.Vb 9
\&    {
\&      local $TODO = "not quite done yet";
\&      test "foo" => sub {
\&          fail;
\&          pass;              # NOT an unexpected success, as
\&                             # this is simply a subtest of the whole
\&                             # test "foo", which will fail.
\&      };
\&    }
.Ve
.SS "\s-1OUTPUT FORMAT\s0"
.IX Subsection "OUTPUT FORMAT"
As seen briefly in \*(L"\s-1SYNOPSIS\*(R"\s0, only top-level test groups (and toplevel
Test::More tests if any) produce a single \*(L"ok\*(R" or \*(L"not ok\*(R" summary line.  Failed
sub-tests produce non-scoring comment messages (prefixed with \*(L"#\*(R"); successful
sub-tests are silent.  This is different from, and predates, the
\&\*(L"subtest\*(R" in Test::More functionality.
.PP
However, if you enable the experimental \*(L"use_subtest\*(R" feature then
\&\fITest::Group\fR will use the same underlying mechanism as
\&\*(L"subtest\*(R" in Test::More and produce very similar output.
.SS "\s-1PLUGIN INTERFACE\s0"
.IX Subsection "PLUGIN INTERFACE"
A simple plugin interface allows module authors to write extensions
to \fITest::Group\fR.  See Test::Group::Extending for details.
.PP
The following extensions are distributed with \fITest::Group\fR:
.PP
Test::Group::Plan, Test::Group::NoWarnings
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
All functions below are intended to be called from the test
script. They are all exported by default.
.PP
\fItest ($name, \f(CI$groupsub\fI)\fR
.IX Subsection "test ($name, $groupsub)"
.PP
Executes \fI\f(CI$groupsub\fI\fR, which must be a reference to a subroutine, in a
controlled environment and groups the results of all
Test::Builder\-style subtests launched inside into a single call to
\&\*(L"ok\*(R" in Test::Builder, regardless of their number.  If the test group is
to be skipped (as discussed in \*(L"Skipping Groups\*(R"), calls
\&\*(L"skip\*(R" in Test::Builder once instead.
.PP
In case the test group is \fBnot\fR skipped, the first parameter to
\&\*(L"ok\*(R" in Test::Builder and the value of the \s-1TODO\s0 string during same (see
\&\*(L"\s-1TODO: BLOCK\*(R"\s0 in Test::More) are determined according to the following
algorithm:
.IP "1." 4
if the test group terminates by throwing an exception, or terminates
normally but without calling any subtest, it fails.
.IP "2." 4
otherwise, if any subtest failed outside of a \s-1TODO\s0 block, the group
fails.
.IP "3." 4
otherwise, if any subtest \fBsucceeds\fR inside of a \s-1TODO\s0 block, the
group is flagged as an unexpected success.
.IP "4." 4
otherwise, if any subtest fails inside of a \s-1TODO\s0 block, the group
results in a \s-1TODO\s0 (excused) failure.
.IP "5." 4
otherwise, the test group managed to avert all hazards and is a
straight success (tada!!).
.PP
If any sub-tests failed in \fI\f(CI$groupsub\fI\fR, diagnostics will be
propagated using \*(L"diag\*(R" in Test::Builder as usual.
.PP
The return value of \fItest\fR is 1 if the test group is a success
(including a \s-1TODO\s0 unexpected success), 0 if it is a failure (including
a \s-1TODO\s0 excused failure), and undef if the test group was skipped.
.PP
\fIskip_next_tests ($number)\fR
.IX Subsection "skip_next_tests ($number)"
.PP
\fIskip_next_tests ($number, \f(CI$reason\fI)\fR
.IX Subsection "skip_next_tests ($number, $reason)"
.PP
Skips the \f(CW$number\fR following groups of tests with reason \f(CW$reason\fR.  Dies
if we are currently skipping tests already.
.PP
\fIskip_next_test ()\fR
.IX Subsection "skip_next_test ()"
.PP
\fIskip_next_test ($reason)\fR
.IX Subsection "skip_next_test ($reason)"
.PP
Equivalent to:
.PP
.Vb 2
\&    skip_next_tests 1;
\&    skip_next_tests 1, $reason;
.Ve
.PP
\fIbegin_skipping_tests ()\fR
.IX Subsection "begin_skipping_tests ()"
.PP
.Vb 2
\&    begin_skipping_tests;
\&    begin_skipping_tests "reason";
.Ve
.PP
Skips all subsequent groups of tests until blocked by
\&\*(L"end_skipping_tests\*(R".
.PP
\fIend_skipping_tests ()\fR
.IX Subsection "end_skipping_tests ()"
.PP
Cancels the effect of \*(L"begin_skipping_tests\*(R". Has no effect if we
are not currently skipping tests.
.PP
\fItest_only ()\fR
.IX Subsection "test_only ()"
.PP
.Vb 3
\&    test_only "bla()", "reason";
\&    test_only qr/^bla/;
\&    test_only sub { /bla/ };
.Ve
.PP
Skip all groups of tests whose name does not match the criteria.  The
criteria can be a plain string, a regular expression or a function.
.PP
.Vb 1
\&    test_only;
.Ve
.PP
Resets to normal behavior.
.SS "\s-1PLUGIN FUNCTIONS\s0"
.IX Subsection "PLUGIN FUNCTIONS"
The following function relates to the plugin interface. It is not
exported by default.  See Test::Group::Extending for details.
.PP
\fInext_test_plugin ($plugin)\fR
.IX Subsection "next_test_plugin ($plugin)"
.PP
Installs a plugin for the next test group. \fI\f(CI$plugin\fI\fR must be a
subroutine reference.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
A handful of class methods are available to tweak the behavior of this
module on a global basis. They are to be invoked like this:
.PP
.Vb 1
\&   Test::Group\->foo(@args);
.Ve
.SS "verbose ($level)"
.IX Subsection "verbose ($level)"
Sets verbosity level to \f(CW$level\fR, where 0 means quietest.
.PP
At level 1 and above there is a diagnostic line for the start of each
test group.
.PP
At level 2 there is a diagnostic line showing the result of each
subtest within top-level test groups. At level 3, the subtests of test
groups nested within top level test groups also get diagnostic lines,
and so on.
.PP
The default verbosity level is 0, or the value of the
\&\f(CW\*(C`PERL_TEST_GROUP_VERBOSE\*(C'\fR environment variable if it is set.
.SS "catch_exceptions ()"
.IX Subsection "catch_exceptions ()"
Causes exceptions thrown from within the sub reference passed to
\&\*(L"test\*(R" to be blocked; in this case, the test currently running will
fail but the suite will proceed. This is the default behavior.
.PP
Note that \fIcatch_exceptions\fR only deals with exceptions arising
inside \fItest\fR blocks; those thrown by surrounding code (if any) still
cause the test script to terminate as usual unless other appropriate
steps are taken.
.SS "dont_catch_exceptions ()"
.IX Subsection "dont_catch_exceptions ()"
Reverses the effect of \*(L"catch_exceptions\*(R", and causes exceptions
thrown from a \*(L"test\*(R" sub reference to be fatal to the whole suite.
This only takes effect for test subs that run after
\&\fI\f(BIdont_catch_exceptions()\fI\fR returns; in other words this is \fBnot\fR a
whole-script pragma.
.SS "logfile ($classstate_logfile)"
.IX Subsection "logfile ($classstate_logfile)"
Sets the log file for caught exceptions to \fI\f(CI$classstate_logfile\fI\fR.
From this point on, all exceptions thrown from within a text group
(assuming they are caught, see \*(L"catch_exceptions\*(R") will be written
to \fI\f(CI$classstate_logfile\fI\fR instead of being passed on to
\&\*(L"diag\*(R" in Test::More. This is very convenient with exceptions with a
huge text representation (say an instance of Error containing a
stack trace).
.SS "use_subtest ()"
.IX Subsection "use_subtest ()"
This feature is experimental.
.PP
Causes \fITest::Group\fR to use Test::Builder's \fBsubtest()\fR feature as
the test aggregation method, rather than doing black magic behind the
scenes.
.PP
It is a fatal error to call \fBuse_subtest()\fR if Test::Builder is too
old to support subtests.  To use subtests if they are available but
fall back to normal operation if they are not, you can do:
.PP
.Vb 1
\&  eval { Test::Group\->use_subtest };
.Ve
.PP
\&\fITest::Group\fR's exception handling mechanism is bypassed under
\&\fBuse_subtest()\fR, since \fBTest::Builder::subtest()\fR has its own exception
handling system.
.SS "no_subtest ()"
.IX Subsection "no_subtest ()"
Turns off use_subtest.
.SH "BUGS"
.IX Header "BUGS"
This class uses a somewhat unhealthy dose of black magic to take over
control from Test::Builder when running inside a \*(L"test\*(R" group
sub.  While the temporary re-blessing trick used therein is thought to
be very robust, it is not very elegant.
.PP
The experimental \fBuse_subtest()\fR feature allows you to avoid the black
magic if your Test::Builder is recent enough to support subtests.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Simple, Test::More, Test::Builder, and friends
.PP
The \f(CW\*(C`perl\-qa\*(C'\fR project, <http://qa.perl.org/>.
.SS "Similar modules on \s-1CPAN\s0"
.IX Subsection "Similar modules on CPAN"
Test::Class can be used to turn a test suite into a full-fledged
object class of its own, in xUnit style.  It also happens to support a
similar form of test grouping using the \f(CW\*(C`:Test(no_plan)\*(C'\fR or \f(CW\*(C`:Tests\*(C'\fR
attributes.  Switching over to \fITest::Class\fR will make a test suite
more rugged and provide a number of advantages, but it will also
dilute the \*(L"quick-and-dirty\*(R" aspect of .t files somewhat. This may or
may not be what you want: for example, the author of this module
enjoys programming most when writing tests, because the most infamous
Perl hacks are par for the course then :\-).  Anyway \s-1TIMTOWTDI,\s0 and
\&\fITest::Group\fR is a way to reap some of the benefits of \fITest::Class\fR
(e.g. running only part of the test suite) without changing one's
programming style too much.
.SH "AUTHORS"
.IX Header "AUTHORS"
Nick Cleaton <ncleaton@cpan.org>
.PP
Dominique Quatravaux <domq@cpan.org>
.PP
Nicolas M. Thie\*'ry <nthiery@users.sf.net>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2004 by \s-1IDEALX\s0 <http://www.idealx.com>
.PP
Copyright (c) 2009 by Nick Cleaton and Dominique Quatravaux
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.1 or,
at your option, any later version of Perl 5 you may have available.
