.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Generator 3"
.TH HTTP::Request::Generator 3 "2020-10-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Generator \- generate HTTP requests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::Request::Generator \*(Aqgenerate_requests\*(Aq;
\&
\&    @requests = generate_requests(
\&        method  => \*(AqGET\*(Aq,
\&        pattern => \*(Aqhttps://example.com/{bar,foo,gallery}/[00..99].html\*(Aq,
\&    );
\&
\&    # generates 300 requests from
\&    #     https://example.com/bar/00.html to
\&    #     https://example.com/gallery/99.html
\&
\&    @requests = generate_requests(
\&        method => \*(AqPOST\*(Aq,
\&        host   => [\*(Aqexample.com\*(Aq,\*(Aqwww.example.com\*(Aq],
\&        path   => \*(Aq/profiles/:name\*(Aq,
\&        url_params => {
\&            name => [\*(AqCorion\*(Aq,\*(AqCo\-Rion\*(Aq],
\&        },
\&        query_params => {
\&            stars => [2,3],
\&        },
\&        body_params => {
\&            comment => [\*(AqSome comment\*(Aq, \*(AqAnother comment, A++\*(Aq],
\&        },
\&        headers => [
\&            {
\&                "Content\-Type" => \*(Aqtext/plain; encoding=UTF\-8\*(Aq,
\&                Cookie => \*(Aqmy_session_id\*(Aq,
\&            },
\&            {
\&                "Content\-Type" => \*(Aqtext/plain; encoding=Latin\-1\*(Aq,
\&                Cookie => \*(Aqmy_session_id\*(Aq,
\&            },
\&        ],
\&    );
\&    # Generates 32 requests out of the combinations
\&
\&    for my $req (@requests) {
\&        $ua\->request( $req );
\&    };
.Ve
.ie n .SS """expand_curl_pattern"""
.el .SS "\f(CWexpand_curl_pattern\fP"
.IX Subsection "expand_curl_pattern"
.Vb 2
\&    my %res = expand_curl_pattern( \*(Aqhttps://\*(Aq );
\&    #
.Ve
.PP
Expands a curl-style pattern to a pattern using positional placeholders.
See the \f(CW\*(C`curl\*(C'\fR documentation on the patterns.
.ie n .SS """generate_requests( %options )"""
.el .SS "\f(CWgenerate_requests( %options )\fP"
.IX Subsection "generate_requests( %options )"
.Vb 10
\&  my $g = generate_requests(
\&      url => \*(Aq/profiles/:name\*(Aq,
\&      url_params => [\*(AqMark\*(Aq,\*(AqJohn\*(Aq],
\&      wrap => sub {
\&          my( $req ) = @_;
\&          # Fix up some values
\&          $req\->{headers}\->{\*(AqContent\-Length\*(Aq} = 666;
\&          return $req;
\&      },
\&  );
\&  while( my $r = $g\->()) {
\&      send_request( $r );
\&  };
.Ve
.PP
This function creates data structures that are suitable for sending off
a mass of similar but different \s-1HTTP\s0 requests. All array references are expanded
into the cartesian product of their contents. The above example would create
two requests:
.PP
.Vb 2
\&      url => \*(Aq/profiles/Mark,
\&      url => \*(Aq/profiles/John\*(Aq,
.Ve
.PP
\&\f(CW\*(C`generate_requests\*(C'\fR returns an iterator in scalar context. In list context, it
returns the complete list of requests:
.PP
.Vb 10
\&  my @requests = generate_requests(
\&      url => \*(Aq/profiles/:name\*(Aq,
\&      url_params => [\*(AqMark\*(Aq,\*(AqJohn\*(Aq],
\&      wrap => sub {
\&          my( $req ) = @_;
\&          # Fix up some values
\&          $req\->{headers}\->{\*(AqContent\-Length\*(Aq} = 666;
\&          return $req;
\&      },
\&  );
\&  for my $r (@requests) {
\&      send_request( $r );
\&  };
.Ve
.PP
Note that returning a list instead of the iterator will use up quite some memory
quickly, as the list will be the cartesian product of the input parameters.
.PP
There are helper functions
that will turn that data into a data structure suitable for your \s-1HTTP\s0 framework
of choice.
.PP
.Vb 9
\&  {
\&    method => \*(AqGET\*(Aq,
\&    url => \*(Aq/profiles/Mark\*(Aq,
\&    scheme => \*(Aqhttp\*(Aq,
\&    port => 80,
\&    headers => {},
\&    body_params => {},
\&    query_params => {},
\&  }
.Ve
.PP
As a shorthand for creating lists, you can use the \f(CW\*(C`pattern\*(C'\fR option, which
will expand a string into a set of requests. \f(CW\*(C`{}\*(C'\fR will expand into alternatives
while \f(CW\*(C`[xx..yy]\*(C'\fR will expand into the range \f(CW\*(C`xx\*(C'\fR to \f(CW\*(C`yy\*(C'\fR. Note that these
lists will be expanded in memory.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBpattern\fR" 4
.IX Item "pattern"
.Vb 1
\&    pattern => \*(Aqhttps://example.{com,org,net}/page_[00..99].html\*(Aq,
.Ve
.Sp
Generate URLs from this pattern instead of \f(CW\*(C`query_params\*(C'\fR, \f(CW\*(C`url_params\*(C'\fR
and \f(CW\*(C`url\*(C'\fR.
.IP "\fBurl\fR" 4
.IX Item "url"
\&\s-1URL\s0 template to use.
.IP "\fBurl_params\fR" 4
.IX Item "url_params"
Parameters to replace in the \f(CW\*(C`url\*(C'\fR template.
.IP "\fBbody_params\fR" 4
.IX Item "body_params"
Parameters to replace in the \s-1POST\s0 body.
.IP "\fBquery_params\fR" 4
.IX Item "query_params"
Parameters to replace in the \s-1GET\s0 request.
.IP "\fBhost\fR" 4
.IX Item "host"
Hostname(s) to use.
.IP "\fBport\fR" 4
.IX Item "port"
Port(s) to use.
.IP "\fBheaders\fR" 4
.IX Item "headers"
Headers to use. Currently, no templates are generated for the headers. You have
to specify complete sets of headers for each alternative.
.IP "\fBlimit\fR" 4
.IX Item "limit"
Limit the number of requests generated.
.ie n .SS """as_http_request"""
.el .SS "\f(CWas_http_request\fP"
.IX Subsection "as_http_request"
.Vb 5
\&    generate_requests(
\&        method => \*(AqPOST\*(Aq,
\&        url    => \*(Aq/feedback/:item\*(Aq,
\&        wrap => \e&HTTP::Request::Generator::as_http_request,
\&    )
.Ve
.PP
Converts the request data to a HTTP::Request object.
.ie n .SS """as_dancer"""
.el .SS "\f(CWas_dancer\fP"
.IX Subsection "as_dancer"
.Vb 5
\&    generate_requests(
\&        method => \*(AqPOST\*(Aq,
\&        url    => \*(Aq/feedback/:item\*(Aq,
\&        wrap => \e&HTTP::Request::Generator::as_dancer,
\&    )
.Ve
.PP
Converts the request data to a Dancer::Request object.
.PP
During the creation of Dancer::Request objects, \f(CW%ENV\fR will be empty except
for \f(CW$ENV{TMP}\fR and \f(CW$ENV{TEMP}\fR.
.PP
This function needs and dynamically loads the following modules:
.PP
Dancer::Request
.PP
HTTP::Request
.ie n .SS """as_plack"""
.el .SS "\f(CWas_plack\fP"
.IX Subsection "as_plack"
.Vb 5
\&    generate_requests(
\&        method => \*(AqPOST\*(Aq,
\&        url    => \*(Aq/feedback/:item\*(Aq,
\&        wrap => \e&HTTP::Request::Generator::as_plack,
\&    )
.Ve
.PP
Converts the request data to a Plack::Request object.
.PP
During the creation of Plack::Request objects, \f(CW%ENV\fR will be empty except
for \f(CW$ENV{TMP}\fR and \f(CW$ENV{TEMP}\fR.
.PP
This function needs and dynamically loads the following modules:
.PP
Plack::Request
.PP
HTTP::Headers
.PP
Hash::MultiValue
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The Curl Manpage <https://curl.haxx.se/docs/manpage.html> for the pattern syntax
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/HTTP\-Request\-Generator>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is <https://perlmonks.org/>.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=HTTP\-Request\-Generator>
or via mail to HTTP\-Request\-Generator\-Bugs@rt.cpan.org <mailto:HTTP-Request-Generator-Bugs@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2017\-2019 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
