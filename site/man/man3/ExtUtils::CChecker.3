.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtUtils::CChecker 3"
.TH ExtUtils::CChecker 3 "2020-07-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"ExtUtils::CChecker" \- configure\-time utilities for using C headers,
libraries, or OS features
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Module::Build;
\& use ExtUtils::CChecker;
\&
\& my $cc = ExtUtils::CChecker\->new;
\& 
\& $cc\->assert_compile_run(
\&    diag => "no PF_MOONLASER",
\&    source => <<\*(AqEOF\*(Aq );
\& #include <stdio.h>
\& #include <sys/socket.h>
\& int main(int argc, char *argv[]) {
\&   printf("PF_MOONLASER is %d\en", PF_MOONLASER);
\&   return 0;
\& }
\& EOF
\&
\& Module::Build\->new(
\&   ...
\& )\->create_build_script;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Often Perl modules are written to wrap functionality found in existing C
headers, libraries, or to use OS-specific features. It is useful in the
\&\fIBuild.PL\fR or \fIMakefile.PL\fR file to check for the existance of these
requirements before attempting to actually build the module.
.PP
Objects in this class provide an extension around ExtUtils::CBuilder to
simplify the creation of a \fI.c\fR file, compiling, linking and running it, to
test if a certain feature is present.
.PP
It may also be necessary to search for the correct library to link against,
or for the right include directories to find header files in. This class also
provides assistance here.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .SS "$cc = ExtUtils::CChecker\->new( %args )"
.el .SS "\f(CW$cc\fP = ExtUtils::CChecker\->new( \f(CW%args\fP )"
.IX Subsection "$cc = ExtUtils::CChecker->new( %args )"
Returns a new instance of a \f(CW\*(C`ExtUtils::CChecker\*(C'\fR object. Takes the following
named parameters:
.IP "defines_to => \s-1PATH\s0" 8
.IX Item "defines_to => PATH"
If given, defined symbols will be written to a C preprocessor \fI.h\fR file of
the given name, instead of by adding extra \f(CW\*(C`\-D\f(CISYMBOL\f(CW\*(C'\fR arguments to the
compiler flags.
.IP "quiet => \s-1BOOL\s0" 8
.IX Item "quiet => BOOL"
If given, sets the \f(CW\*(C`quiet\*(C'\fR option to the underlying \f(CW\*(C`ExtUtils::CBuilder\*(C'\fR
instance. If absent, defaults to enabled. To disable quietness, i.e. to print
more verbosely, pass a defined-but-false value, such as \f(CW0\fR.
.IP "config => \s-1HASH\s0" 8
.IX Item "config => HASH"
If given, passed through as the configuration of the underlying
\&\f(CW\*(C`ExtUtils::CBuilder\*(C'\fR instance.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$dirs = $cc\->include_dirs"
.el .SS "\f(CW$dirs\fP = \f(CW$cc\fP\->include_dirs"
.IX Subsection "$dirs = $cc->include_dirs"
Returns the currently-configured include directories in an \s-1ARRAY\s0 reference.
.ie n .SS "$flags = $cc\->extra_compiler_flags"
.el .SS "\f(CW$flags\fP = \f(CW$cc\fP\->extra_compiler_flags"
.IX Subsection "$flags = $cc->extra_compiler_flags"
Returns the currently-configured extra compiler flags in an \s-1ARRAY\s0 reference.
.ie n .SS "$flags = $cc\->extra_linker_flags"
.el .SS "\f(CW$flags\fP = \f(CW$cc\fP\->extra_linker_flags"
.IX Subsection "$flags = $cc->extra_linker_flags"
Returns the currently-configured extra linker flags in an \s-1ARRAY\s0 reference.
.ie n .SS "$cc\->push_include_dirs( @dirs )"
.el .SS "\f(CW$cc\fP\->push_include_dirs( \f(CW@dirs\fP )"
.IX Subsection "$cc->push_include_dirs( @dirs )"
Adds more include directories
.ie n .SS "$cc\->push_extra_compiler_flags( @flags )"
.el .SS "\f(CW$cc\fP\->push_extra_compiler_flags( \f(CW@flags\fP )"
.IX Subsection "$cc->push_extra_compiler_flags( @flags )"
Adds more compiler flags
.ie n .SS "$cc\->push_extra_linker_flags( @flags )"
.el .SS "\f(CW$cc\fP\->push_extra_linker_flags( \f(CW@flags\fP )"
.IX Subsection "$cc->push_extra_linker_flags( @flags )"
Adds more linker flags
.ie n .SS "$success = $cc\->try_compile_run( %args )"
.el .SS "\f(CW$success\fP = \f(CW$cc\fP\->try_compile_run( \f(CW%args\fP )"
.IX Subsection "$success = $cc->try_compile_run( %args )"
.ie n .SS "$success = $cc\->try_compile_run( $source )"
.el .SS "\f(CW$success\fP = \f(CW$cc\fP\->try_compile_run( \f(CW$source\fP )"
.IX Subsection "$success = $cc->try_compile_run( $source )"
Try to compile, link, and execute a C program whose source is given. Returns
true if the program compiled and linked, and exited successfully. Returns
false if any of these steps fail.
.PP
Takes the following named arguments. If a single argument is given, that is
taken as the source string.
.IP "\(bu" 8
source => \s-1STRING\s0
.Sp
The source code of the C program to try compiling, building, and running.
.IP "\(bu" 8
extra_compiler_flags => \s-1ARRAY\s0
.Sp
Optional. If specified, pass extra flags to the compiler.
.IP "\(bu" 8
extra_linker_flags => \s-1ARRAY\s0
.Sp
Optional. If specified, pass extra flags to the linker.
.IP "\(bu" 8
define => \s-1STRING\s0
.Sp
Optional. If specified, then the named symbol will be defined if the program
ran successfully. This will either on the C compiler commandline (by passing
an option \f(CW\*(C`\-D\f(CISYMBOL\f(CW\*(C'\fR), or in the \f(CW\*(C`defines_to\*(C'\fR file.
.ie n .SS "$cc\->assert_compile_run( %args )"
.el .SS "\f(CW$cc\fP\->assert_compile_run( \f(CW%args\fP )"
.IX Subsection "$cc->assert_compile_run( %args )"
Calls \f(CW\*(C`try_compile_run\*(C'\fR. If it fails, die with an \f(CW\*(C`OS unsupported\*(C'\fR message.
Useful to call from \fIBuild.PL\fR or \fIMakefile.PL\fR.
.PP
Takes one extra optional argument:
.IP "\(bu" 8
diag => \s-1STRING\s0
.Sp
If present, this string will be appended to the failure message if one is
generated. It may provide more useful information to the user on why the \s-1OS\s0 is
unsupported.
.ie n .SS "$success = $cc\->try_find_include_dirs_for( %args )"
.el .SS "\f(CW$success\fP = \f(CW$cc\fP\->try_find_include_dirs_for( \f(CW%args\fP )"
.IX Subsection "$success = $cc->try_find_include_dirs_for( %args )"
Try to compile, link and execute the given source, using extra include
directories.
.PP
When a usable combination is found, the directories required are stored in the
object for use in further compile operations, or returned by \f(CW\*(C`include_dirs\*(C'\fR.
The method then returns true.
.PP
If no a usable combination is found, it returns false.
.PP
Takes the following arguments:
.IP "\(bu" 8
source => \s-1STRING\s0
.Sp
Source code to compile
.IP "\(bu" 8
dirs => \s-1ARRAY\s0 of ARRAYs
.Sp
Gives a list of sets of dirs. Each set of dirs should be strings in its own
array reference.
.IP "\(bu" 8
define => \s-1STRING\s0
.Sp
Optional. If specified, then the named symbol will be defined if the program
ran successfully. This will either on the C compiler commandline (by passing
an option \f(CW\*(C`\-D\f(CISYMBOL\f(CW\*(C'\fR), or in the \f(CW\*(C`defines_to\*(C'\fR file.
.ie n .SS "$success = $cc\->try_find_libs_for( %args )"
.el .SS "\f(CW$success\fP = \f(CW$cc\fP\->try_find_libs_for( \f(CW%args\fP )"
.IX Subsection "$success = $cc->try_find_libs_for( %args )"
Try to compile, link and execute the given source, when linked against a
given set of extra libraries.
.PP
When a usable combination is found, the libraries required are stored in the
object for use in further link operations, or returned by
\&\f(CW\*(C`extra_linker_flags\*(C'\fR. The method then returns true.
.PP
If no usable combination is found, it returns false.
.PP
Takes the following arguments:
.IP "\(bu" 8
source => \s-1STRING\s0
.Sp
Source code to compile
.IP "\(bu" 8
libs => \s-1ARRAY\s0 of STRINGs
.Sp
Gives a list of sets of libraries. Each set of libraries should be
space-separated.
.IP "\(bu" 8
define => \s-1STRING\s0
.Sp
Optional. If specified, then the named symbol will be defined if the program
ran successfully. This will either on the C compiler commandline (by passing
an option \f(CW\*(C`\-D\f(CISYMBOL\f(CW\*(C'\fR), or in the \f(CW\*(C`defines_to\*(C'\fR file.
.ie n .SS "$cc\->find_include_dirs_for( %args )"
.el .SS "\f(CW$cc\fP\->find_include_dirs_for( \f(CW%args\fP )"
.IX Subsection "$cc->find_include_dirs_for( %args )"
.ie n .SS "$cc\->find_libs_for( %args )"
.el .SS "\f(CW$cc\fP\->find_libs_for( \f(CW%args\fP )"
.IX Subsection "$cc->find_libs_for( %args )"
Calls \f(CW\*(C`try_find_include_dirs_for\*(C'\fR or \f(CW\*(C`try_find_libs_for\*(C'\fR respectively. If it
fails, die with an \f(CW\*(C`OS unsupported\*(C'\fR message.
.PP
Each method takes one extra optional argument:
.IP "\(bu" 8
diag => \s-1STRING\s0
.Sp
If present, this string will be appended to the failure message if one is
generated. It may provide more useful information to the user on why the \s-1OS\s0 is
unsupported.
.ie n .SS "$mb = $cc\->new_module_build( %args )"
.el .SS "\f(CW$mb\fP = \f(CW$cc\fP\->new_module_build( \f(CW%args\fP )"
.IX Subsection "$mb = $cc->new_module_build( %args )"
Construct and return a new Module::Build object, preconfigured with the
\&\f(CW\*(C`include_dirs\*(C'\fR, \f(CW\*(C`extra_compiler_flags\*(C'\fR and \f(CW\*(C`extra_linker_flags\*(C'\fR options
that have been configured on this object, by the above methods.
.PP
This is provided as a simple shortcut for the common use case, that a
\&\fIBuild.PL\fR file is using the \f(CW\*(C`ExtUtils::CChecker\*(C'\fR object to detect the
required arguments to pass.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Socket Libraries"
.IX Subsection "Socket Libraries"
Some operating systems provide the \s-1BSD\s0 sockets \s-1API\s0 in their primary \fIlibc\fR.
Others keep it in a separate library which should be linked against. The
following example demonstrates how this would be handled.
.PP
.Vb 1
\& use ExtUtils::CChecker;
\&
\& my $cc = ExtUtils::CChecker\->new;
\&
\& $cc\->find_libs_for(
\&    diag => "no socket()",
\&    libs => [ "", "socket nsl" ],
\&    source => q[
\& #include <sys/socket.h>
\& int main(int argc, char *argv) {
\&   int fd = socket(PF_INET, SOCK_STREAM, 0);
\&   if(fd < 0)
\&     return 1;
\&   return 0;
\& }
\& ] );
\&
\& $cc\->new_module_build(
\&    module_name => "Your::Name::Here",
\&    requires => {
\&       \*(AqIO::Socket\*(Aq => 0,
\&    },
\&    ...
\& )\->create_build_script;
.Ve
.PP
By using the \f(CW\*(C`new_module_build\*(C'\fR method, the detected \f(CW\*(C`extra_linker_flags\*(C'\fR
value has been automatically passed into the new \f(CW\*(C`Module::Build\*(C'\fR object.
.SS "Testing For Optional Features"
.IX Subsection "Testing For Optional Features"
Sometimes a function or ability may be optionally provided by the \s-1OS,\s0 or you
may wish your module to be useable when only partial support is provided,
without requiring it all to be present. In these cases it is traditional to
detect the presence of this optional feature in the \fIBuild.PL\fR script, and
define a symbol to declare this fact if it is found. The \s-1XS\s0 code can then use
this symbol to select between differing implementations. For example, the
\&\fIBuild.PL\fR:
.PP
.Vb 1
\& use ExtUtils::CChecker;
\&
\& my $cc = ExtUtils::CChecker\->new;
\&
\& $cc\->try_compile_run(
\&    define => "HAVE_MANGO",
\&    source => <<\*(AqEOF\*(Aq );
\& #include <mango.h>
\& #include <unistd.h>
\& int main(void) {
\&   if(mango() != 0)
\&     exit(1);
\&   exit(0);
\& }
\& EOF
\&
\& $cc\->new_module_build(
\&    ...
\& )\->create_build_script;
.Ve
.PP
If the C code compiles and runs successfully, and exits with a true status,
the symbol \f(CW\*(C`HAVE_MANGO\*(C'\fR will be defined on the compiler commandline. This
allows the \s-1XS\s0 code to detect it, for example
.PP
.Vb 10
\& int
\& mango()
\&   CODE:
\& #ifdef HAVE_MANGO
\&     RETVAL = mango();
\& #else
\&     croak("mango() not implemented");
\& #endif
\&   OUTPUT:
\&     RETVAL
.Ve
.PP
This module will then still compile even if the operating system lacks this
particular function. Trying to invoke the function at runtime will simply
throw an exception.
.SS "Linux Kernel Headers"
.IX Subsection "Linux Kernel Headers"
Operating systems built on top of the \fILinux\fR kernel often share a looser
association with their kernel version than most other operating systems. It
may be the case that the running kernel is newer, containing more features,
than the distribution's \fIlibc\fR headers would believe. In such circumstances
it can be difficult to make use of new socket options, \f(CW\*(C`ioctl()\*(C'\fRs, etc..
without having the constants that define them and their parameter structures,
because the relevant header files are not visible to the compiler. In this
case, there may be little choice but to pull in some of the kernel header
files, which will provide the required constants and structures.
.PP
The Linux kernel headers can be found using the \fI/lib/modules\fR directory. A
fragment in \fIBuild.PL\fR like the following, may be appropriate.
.PP
.Vb 1
\& chomp( my $uname_r = \`uname \-r\` );
\&
\& my @dirs = (
\&    [],
\&    [ "/lib/modules/$uname_r/source/include" ],
\& );
\&
\& $cc\->find_include_dirs_for(
\&    diag => "no PF_MOONLASER",
\&    dirs => \e@dirs,
\&    source => <<\*(AqEOF\*(Aq );
\& #include <sys/socket.h>
\& #include <moon/laser.h>
\& int family = PF_MOONLASER;
\& struct laserwl lwl;
\& int main(int argc, char *argv[]) {
\&   return 0;
\& }
\& EOF
.Ve
.PP
This fragment will first try to compile the program as it stands, hoping that
the \fIlibc\fR headers will be sufficient. If it fails, it will then try
including the kernel headers, which should make the constant and structure
visible, allowing the program to compile.
.ie n .SS "Creating an ""#include"" file"
.el .SS "Creating an \f(CW#include\fP file"
.IX Subsection "Creating an #include file"
Sometimes, rather than setting defined symbols on the compiler commandline, it
is preferrable to have them written to a C preprocessor include (\fI.h\fR) file.
This may be beneficial for cross-platform portability concerns, as not all C
compilers may take extra \f(CW\*(C`\-D\*(C'\fR arguments on the command line, or platforms may
have small length restrictions on the length of a command line.
.PP
.Vb 1
\& use ExtUtils::CChecker;
\&
\& my $cc = ExtUtils::CChecker\->new(
\&    defines_to => "mymodule\-config.h",
\& );
\&
\& $cc\->try_compile_run(
\&    define => "HAVE_MANGO",
\&    source => <<\*(AqEOF\*(Aq );
\& #include <mango.h>
\& #include <unistd.h>
\& #include "mymodule\-config.h"
\& int main(void) {
\&   if(mango() != 0)
\&     exit(1);
\&   exit(0);
\& }
\& EOF
.Ve
.PP
Because the \fImymodule\-config.h\fR file is written and flushed after every
define operation, it will still be useable in later C fragments to test for
features detected in earlier ones.
.PP
It is suggested not to name the file simply \fIconfig.h\fR, as the core of Perl
itself has a file of that name containing its own compile-time detected
configuration. A confusion between the two could lead to surprising results.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
