.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::HexDump::Range 3"
.TH Data::HexDump::Range 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::HexDump::Range \- Hexadecimal Range Dumper with color, bitfields and skip ranges
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $hdr = Data::HexDump::Range\->new() ;
\&  
\&  print $hdr\->dump([[\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq],[\*(Aqimage type\*(Aq, 2, \*(Aqgreen\*(Aq]],  $data) ;
\&  print $hdr\->dump(\*(Aqmagic cookie, 12, red :image type, 2, green\*(Aq,  $data) ;
\&  
\&  $hdr\->gather([\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq], $data) ; 
\&  $hdr\->gather([\*(Aqimage type\*(Aq, 2, \*(Aqgreen\*(Aq], $other_data) ;
\&  
\&  print $hdr\->dump_gathered() ;
\&  $hdr\->reset() ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates a dump from binary data and user defined \fIrange\fR descriptions. The goal of this module is
to create an easy to understand dump of binary data.
.PP
This achieved through:
.IP "\(bu" 2
Highlighted (colors) dump that is easier to understand than a monochrome blob of hex data
.IP "\(bu" 2
Multiple rendering modes with different output formats
.IP "\(bu" 2
Bitfield rendering
.IP "\(bu" 2
Skipping uninterresting data
.IP "\(bu" 2
The possibility to describe complex structures
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
The shortest perl dumper is \f(CW\*(C`perl \-ne \*(AqBEGIN{$/=\e16} printf "%07x0: @{[unpack q{(H2)*}]}\en", $.\-1\*(Aq\*(C'\fR, courtesy of a golfing session 
with Andrew Rodland <arodland@cpan.org> aka \fIhobbs\fR. \fIpriodev\fR, \fItm604\fR, \fIKhisanth\fR and other provided valuable insight particularely  with the html output.
.PP
\&\fBhexd\fR from libma <http://www.ioplex.com/~miallen/libmba/> is nice tools that inspired me to write this module. This module offers many
more options but \fBhexd\fR may be a better  alternative If you need very fast dump generation.
.PP
\&\fBData::HexDump::Range\fR splits binary data according to user defined \fIranges\fR and renderes them as a \fBhex\fR or/and \fBdecimal\fR data dump.
The data dump can be rendered in \s-1ANSI, ASCII\s0 or \s-1HTML.\s0
.SS "Rendered Columns"
.IX Subsection "Rendered Columns"
You can choose which columns are rendered by setting options when creating a Data::HexDump::Range object.
The default rendering  includes the following
.PP
.Vb 1
\&  RANGE_NAME OFFSET CUMULATIVE_OFFSET HEX_DUMP ASCII_DUMP
.Ve
.PP
which corresponds to the object below:
.PP
.Vb 4
\&  Data::HexDump::Range\->new
\&        (
\&        FORMAT => \*(AqANSI\*(Aq,
\&        COLOR => \*(Aqcycle\*(Aq,
\&        
\&        ORIENTATION => \*(Aqhorizontal\*(Aq,
\&        
\&        DISPLAY_RANGE_NAME => 1 ,
\&        
\&        DISPLAY_OFFSET  => 1 ,
\&        OFFSET_FORMAT => \*(Aqhex\*(Aq,
\&        
\&        DISPLAY_HEX_DUMP => 1,
\&        DISPLAY_ASCII_DUMP => 1,
\&        
\&        DATA_WIDTH => 16,
\&        ) ;
.Ve
.PP
If you decided that you wanted the binary data to be showed in decimal instead for hexadecimal, you' set \s-1DISPLAY_HEX_DUMP\s0 => 0 and \s-1DISPLAY_DEC_DUMP\s0 => 1.
See new for all the possible options. Most option are also available from the command line utility \fIhdr\fR.
.SS "Orientation"
.IX Subsection "Orientation"
The examples below show the output of the following command:
.PP
.Vb 1
\&  $>hdr \-r \*(Aqmagic cookie,12:padding, 32:header,5:data, 20:extra data,#:header,5:data,40:footer,4\*(Aq \-col \-o ver \-display_ruler lib/Data/HexDump/Range.pm
.Ve
.PP
\fIVertical orientation\fR
.IX Subsection "Vertical orientation"
.PP
In this orientation mode, each range displayed on a separate line.
.PP
.Vb 10
\&  RANGE_NAME       OFFSET   CUMULATI HEX_DUMP                                         ASCII_DUMP        
\&                                     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f   0123456789012345  
\&  magic cookie     00000000 00000000 0a 70 61 63 6b 61 67 65 20 44 61 74              .package Dat     
\&  padding          0000000c 00000000                                     61 3a 3a 48              a::H 
\&  padding          00000010 00000004 65 78 44 75 6d 70 3a 3a 52 61 6e 67 65 20 3b 0a  exDump::Range ;. 
\&  padding          00000020 00000014 0a 75 73 65 20 73 74 72 69 63 74 3b              .use strict;     
\&  header           0000002c 00000000                                     0a 75 73 65              .use 
\&  header           00000030 00000004 20                                                                
\&  data             00000031 00000000    77 61 72 6e 69 6e 67 73 20 3b 0a 75 73 65 20   warnings ;.use  
\&  data             00000040 0000000f 43 61 72 70 20                                   Carp             
\&  "extra data" 
\&  header           00000045 00000000                3b 0a 0a 42 45                         ;..BE       
\&  data             0000004a 00000000                               47 49 4e 20 0a 7b            GIN .{ 
\&  data             00000050 00000006 0a 0a 75 73 65 20 53 75 62 3a 3a 45 78 70 6f 72  ..use Sub::Expor 
\&  data             00000060 00000016 74 65 72 20 2d 73 65 74 75 70 20 3d 3e 20 0a 09  ter \-setup => .. 
\&  data             00000070 00000026 7b 0a                                            {.               
\&  footer           00000072 00000000       09 65 78 70                                  .exp
.Ve
.PP
In colors:
.PP
\fIHorizontal orientation\fR
.IX Subsection "Horizontal orientation"
.PP
In this mode, the data are packed together in the dump
.PP
.Vb 10
\& OFFSET   HEX_DUMP                                         ASCII_DUMP       RANGE_NAME
\&          0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f   0123456789012345
\& 00000000 0a 70 61 63 6b 61 67 65 20 44 61 74 61 3a 3a 48  .package Data::H magic cookie, padding,
\& 00000020 65 78 44 75 6d 70 3a 3a 52 61 6e 67 65 20 3b 0a  exDump::Range ;. padding,
\& 00000030 0a 75 73 65 20 73 74 72 69 63 74 3b 0a 75 73 65  .use strict;.use padding, header,
\& 00000050 20 77 61 72 6e 69 6e 67 73 20 3b 0a 75 73 65 20   warnings ;.use  header, data,
\& 00000070 43 61 72 70 20 3b 0a 0a 42 45 47 49 4e 20 0a 7b  Carp ;..BEGIN .{ data, "extra data", header, data,
\& 000000a0 0a 0a 75 73 65 20 53 75 62 3a 3a 45 78 70 6f 72  ..use Sub::Expor data,
\& 000000b0 74 65 72 20 2d 73 65 74 75 70 20 3d 3e 20 0a 09  ter \-setup => .. data,
\& 000000c0 7b 0a 09 65 78 70                                {..exp           data, footer,
.Ve
.PP
In colors:
.SS "Range definition"
.IX Subsection "Range definition"
.Vb 1
\&  my $simple_range = [\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq] ;
.Ve
.PP
Ranges are Array references containing two to four  elements:
.IP "\(bu" 2
name \- a string
.IP "\(bu" 2
size \- an integer or a format \- a string
.IP "\(bu" 2
color \- a string or undef
.IP "\(bu" 2
user information \- a very short string descibing  the range or undef
.PP
Any of the elements can be replaced by a subroutine reference. See \*(L"Dynamic range definition\*(R" below.
.PP
You can also pass the ranges as a string. The hdr command line range dumper that was installed by this module uses the string format.
.PP
Example:
.PP
.Vb 1
\& $>hdr \-\-col \-display_ruler \-o ver \-r \*(Aqheader,12:name,10:magic,2:offset,4:BITMAP,4,bright_yellow:ff,x2b2:fx,b32:f0,b16:field,x8b8:field2, b17:footer,20\*(Aq my_binary
.Ve
.PP
\fISize field format\fR
.IX Subsection "Size field format"
.PP
The size field is used to defined if the range is a normal range, a comment, a bitfield or a skip range. The formats are a s follows:
.PP
.Vb 1
\&                  format                          range example
\&                  
\&  normal range => integer                         header, 4, bright_blue
\&  comment      => #                               data section start, # 
\&  extra header => @                               header, @, red 
\&  bitfield     => [XInteger][xInteger]bInteger    bitfield, X2x4b4         # X is byte offset, x is bit offset
\&  skip range   => xInteger                        boring, X256,, comment
.Ve
.PP
Note that the integer part can be a hexadecimal value starting with \fI0x\fR
.PP
\fIColoring\fR
.IX Subsection "Coloring"
.PP
Ranges and ranges names are displayed according to the color field in the range definition.
.PP
The color definition is one of:
.IP "\(bu" 2
A user defined color name found in \fB\s-1COLOR_NAMES\s0\fR (see new)
.IP "\(bu" 2
An ansi color definition \- 'blue on_yellow'
.IP "\(bu" 2
undef \- will be repaced by a white color or picked from a cyclic color list (see \fB\s-1COLOR\s0\fR in new).
.PP
\fILinear ranges\fR
.IX Subsection "Linear ranges"
.PP
For simple data formats, your can put all the your range descriptions in a array:
.PP
.Vb 7
\&  my $image_ranges =
\&        [
\&          [\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq],
\&          [\*(Aqsize\*(Aq, 10, \*(Aqyellow\*(Aq],
\&          [\*(Aqdata\*(Aq, 10, \*(Aqblue on_yellow\*(Aq],
\&          [\*(Aqtimestamp\*(Aq, 5, \*(Aqgreen\*(Aq],
\&        ] ;
.Ve
.PP
\fIStructured Ranges\fR
.IX Subsection "Structured Ranges"
.PP
.Vb 5
\&  my $data_range = # definition to re\-use
\&        [
\&          [\*(Aqdata header\*(Aq, 5, \*(Aqblue on_yellow\*(Aq],
\&          [\*(Aqdata\*(Aq, 100, \*(Aqblue\*(Aq],
\&        ] ;
\&                        
\&  my $structured_range = 
\&        [
\&          [
\&            [\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq],
\&            [\*(Aqpadding\*(Aq, 88, \*(Aqyellow\*(Aq],
\&            $data_range, 
\&          ],
\&                
\&          [
\&            [\*(Aqextra data\*(Aq, 12, undef],
\&            [
\&              $data_range, 
\&              [\*(Aqfooter\*(Aq, 4, \*(Aqyellow on_red\*(Aq],
\&            ]
\&          ],
\&        ]
.Ve
.PP
Comment ranges
.IX Subsection "Comment ranges"
.PP
If the size of a range is the string '#', the whole range is considered a comment
.PP
.Vb 5
\&  my $range_defintion_with_comments = 
\&        [
\&          [\*(Aqcomment text\*(Aq, \*(Aq#\*(Aq, \*(Aqoptional color for meta range\*(Aq],
\&          [\*(Aqmagic cookie\*(Aq, 12, \*(Aqred\*(Aq],
\&          [\*(Aqpadding\*(Aq, 88, \*(Aqyellow\*(Aq],
\&            
\&          [
\&            [\*(Aqanother comment\*(Aq, \*(Aq#\*(Aq],
\&            [\*(Aqdata header\*(Aq, 5, \*(Aqblue on_yellow\*(Aq],
\&            [\*(Aqdata\*(Aq, 100, \*(Aqblue\*(Aq],
\&          ],
\&        ] ;
.Ve
.PP
Extra header
.IX Subsection "Extra header"
.PP
If the size of a range is the string '@', and extra header is inserted in the output. This is useful when 
you have very long  output and want an extra header.
.PP
\fIBitfields\fR
.IX Subsection "Bitfields"
.PP
Bitfields can be up to 32 bits long and can overlap each other. Bitfields are applied on the previously defined range.
.PP
In the example below, bitfields \fIff, fx, f0\fR are extracted form the data defined by the \fI\s-1BITMAP\s0\fR range.
.PP
.Vb 10
\&                 .\-\-\-\-\-\-\-\-\-\-\-\-.                      .\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\& .\-\-\-.           | data range |                      | data hexdump |
\& | b |           \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq                      \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\& | i |                  |                                    |
\& | t |     BITMAP  <\-\-\-\-\*(Aq   00000000 00000000 0a 70 61 63 <\-\-\*(Aq                                 .pac           
\& | f |   ^ .ff              02 .. 03          \-\- \-\- \-\- 00    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-00\-\-  .bitfield: \-\-\-.
\& | i |\-\-\-> .fx              00 .. 31          0a 70 61 63    00001010011100000110000101100011  .bitfield: .pac
\& | e |   v .f0              00 .. 15          \-\- \-\- 61 63    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-0110000101100011  .bitfield: \-\-ac
\& | l |                         ^                    ^                     ^                          ^
\& | d |                         |                    |                     |                          |
\& | s |             .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.    .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\& \*(Aq\-\-\-\*(Aq             | start bit .. end bit | bitfields hexdump | bitfield binary dump |    | bitfield ascci dump |
\&                   \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq    \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
The the format definiton  is: an optional \*(L"x (for offset) + offset\*(R" + \*(L"b (for bits) + number of bits\*(R". Eg: \fIx8b8\fR second byte in \s-1MYDATA.\s0
.PP
An example output containing normal data and bifields dumps using the comand below.
.PP
.Vb 1
\&  $>hdr  \-r \*(Aqheader,12:BITMAP,4,bright_yellow:ff,x2b2:fx,b32:f0,b16:footer,16\*(Aq \-o ver file_name
.Ve
.PP
By default bitfields are not displayed  in horizontal mode.
.PP
\fISkip ranges\fR
.IX Subsection "Skip ranges"
.PP
If the size format is 'X' + number, that number of bytes is skipped from the data. \fBData::HexDump::Range\fR
will display the skip range in the dump but not the data.
.PP
In the command below, the range 'skip' removes 32 bytes from the display. '>>' is prepended to the range name.
.PP
Command: \fIhdr \-r 'magic cookie, 5   :other,37  :bf,b8   :skip,X32,, I skipped :more, 20'  \-rul \-col \-o ver\fR
.PP
.Vb 10
\&  RANGE_NAME       OFFSET   CUMULATI HEX_DUMP                                         ASCII_DUMP        
\&                                     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f   0123456789012345  
\&  magic cookie     00000000 00000000 44 61 74 61 3a                                   Data:            
\&  other            00000005 00000000                3a 48 65 78 44 75 6d 70 3a 3a 52       :HexDump::R 
\&  other            00000010 0000000b 61 6e 67 65 0a 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d  ange.=========== 
\&  other            00000020 0000001b 3d 3d 3d 3d 3d 3d 3d 3d 3d 0a                    =========.       
\&  .bf              00 .. 07          \-\- \-\- \-\- 0a    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-00001010  .bitfield: \-\-\-.  
\&  >>skip           0000002a 00000049 00 00 00 20 bytes skipped                                         
\&  more             0000004a 00000000                               20 63 6f 6c 6f 72             color 
\&  more             00000050 00000006 2c 20 62 69 74 66 69 65 6c 64 73 20 61 6e        , bitfields an
.Ve
.PP
in color:
.PP
\fIDynamic range definition\fR
.IX Subsection "Dynamic range definition"
.PP
The whole range can be replaced by a subroutine reference or elements of the range can be replaced by
a subroutine definition.
.PP
.Vb 5
\&  my $dynamic_range =
\&        [
\&          [\e&name, \e&size, \e&color, \e&comment ],
\&          [\e&define_range] # returns a range definition
\&        ] ;
.Ve
.PP
'name' sub ref
.IX Subsection "'name' sub ref"
.PP
.Vb 6
\&  sub cloth_size
\&  {
\&  my ($self, $data, $used_data, $size, $range) = @_ ;
\&  my %types = (O => \*(AqS\*(Aq, 1 => \*(AqM\*(Aq, 2 => \*(AqL\*(Aq,) ;
\&  return \*(Aqsize:\*(Aq . ($types{$data} // \*(Aq?\*(Aq) ;
\&  }
\&  
\&  $hdr\->dump([\e&cloth_size, 1, \*(Aqyellow\*(Aq], $data) ;
.Ve
.PP
'size' sub ref
.IX Subsection "'size' sub ref"
.PP
.Vb 5
\&  sub cloth_size
\&  {
\&  my ($self, $data, $used_data, $size, $range) = @_ ;
\&  return unpack "a", $data ;
\&  }
\&  
\&  $hdr\->dump([\*(Aqdata\*(Aq, \e&get_size, \*(Aqyellow\*(Aq], $data) ;
.Ve
.PP
'color' sub ref
.IX Subsection "'color' sub ref"
.PP
.Vb 2
\&  my $flip_flop = 1 ;
\&  my @colors = (\*(Aqgreen\*(Aq, \*(Aqred\*(Aq) ;
\&  
\&  sub alternate_color {$flip_flop ^= 1 ; return $colors[$flip_flop] }
\&  
\&  $hdr\->dump([\*(Aqdata\*(Aq, 100, \e&alternate_color], $data) ;
.Ve
.PP
'range' sub ref
.IX Subsection "'range' sub ref"
.PP
.Vb 1
\&  sub define_range([\*(Aqwhole range\*(Aq, 5, \*(Aqon_yellow\*(Aq]}
\&  
\&  $hdr\->dump([\e&define_range], $data) ;
.Ve
.ie n .SS "define_range($data, $offset)"
.el .SS "define_range($data, \f(CW$offset\fP)"
.IX Subsection "define_range($data, $offset)"
Returns a range description for the next range to dump
.PP
\&\fIArguments\fR \- See gather
.IP "\(bu" 2
\&\f(CW$self\fR \- A Data::HexDump::Range object
.IP "\(bu" 2
\&\f(CW$data\fR \- Binary string \- the data passed to the \fIdump\fR method
.IP "\(bu" 2
\&\f(CW$offset\fR \- Integer \- current offset in \f(CW$data\fR
.PP
\&\fIReturns\fR \-
.IP "\(bu" 2
\&\f(CW$range\fR \- An array reference containing a name, size and color and user_information
.Sp
\&\s-1OR\s0
.IP "\(bu" 2
undef \- Ignore this range
.IP "\(bu" 2
\&\f(CW$comment\fR \- String \- an optional comment that will be displayed if \s-1DUMP_RANGE_DESCRIPTION\s0 is set.
.PP

.IX Subsection ""
.PP
\&\fBNote\fR this is, very, different from \*(L"User defined range generator\*(R" below.
.PP
\fIUser defined range generator\fR
.IX Subsection "User defined range generator"
.PP
A subroutine reference can be passed as a range definition. The subroutine will be called repetitively
till the data is exhausted or the subroutine returns \fIundef\fR.
.PP
.Vb 3
\&  sub my_parser 
\&        {
\&        my ($data, $offset) = @_ ;
\&        
\&        my $first_byte = unpack ("x$offset C", $data) ;
\&        
\&        $offset < length($data)
\&                ?  $first_byte == ord(0)
\&                        ? [\*(Aqfrom odd\*(Aq, 5, \*(Aqblue on_yellow\*(Aq]
\&                        : [\*(Aqfrom even\*(Aq, 3, \*(Aqgreen\*(Aq]
\&                : undef ;
\&        }
\&  
\&  my $hdr = Data::HexDump::Range\->new() ;
\&  print $hdr\->dump(\e&my_parser, \*(Aq01\*(Aq x 50) ;
.Ve
.ie n .SS "my_parser($data, $offset)"
.el .SS "my_parser($data, \f(CW$offset\fP)"
.IX Subsection "my_parser($data, $offset)"
Returns a range description for the next range to dump
.PP
\&\fIArguments\fR \- See gather
.IP "\(bu" 2
\&\f(CW$self\fR \- A Data::HexDump::Range object
.IP "\(bu" 2
\&\f(CW$data\fR \- Binary string \- the data passed to the \fIdump\fR method
.IP "\(bu" 2
\&\f(CW$offset\fR \- Integer \- current offset in \f(CW$data\fR
.PP
\&\fIReturns\fR \-
.IP "\(bu" 2
\&\f(CW$range\fR \- An array reference containing a name, size and color
.Sp
\&\s-1OR\s0
.IP "\(bu" 2
undef \- Done parsing
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See hdr_examples.pod in the distribution.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new(\s-1NAMED_ARGUMENTS\s0)"
.IX Subsection "new(NAMED_ARGUMENTS)"
Create a Data::HexDump::Range object.
.PP
.Vb 1
\&  my $hdr = Data::HexDump::Range\->new() ; # use default setup
\&  
\&  my $hdr = Data::HexDump::Range\->new
\&                (
\&                FORMAT => \*(AqANSI\*(Aq|\*(AqASCII\*(Aq|\*(AqHTML\*(Aq,
\&                COLOR => \*(Aqbw\*(Aq | \*(Aqcycle\*(Aq,
\&                OFFSET_FORMAT => \*(Aqhex\*(Aq | \*(Aqdec\*(Aq,
\&                DATA_WIDTH => 16 | 20 | ... ,
\&                DISPLAY_RANGE_NAME => 1 ,
\&                MAXIMUM_RANGE_NAME_SIZE => 16,
\&                DISPLAY_COLUMN_NAMES => 0,
\&                DISPLAY_RULER => 0,
\&                DISPLAY_OFFSET  => 1 ,
\&                DISPLAY_CUMULATIVE_OFFSET  => 1 ,
\&                DISPLAY_ZERO_SIZE_RANGE_WARNING => 1,
\&                DISPLAY_ZERO_SIZE_RANGE => 1,
\&                DISPLAY_RANGE_SIZE => 1,
\&                DISPLAY_ASCII_DUMP => 1 ,
\&                DISPLAY_HEX_DUMP => 1,
\&                DISPLAY_HEXASCII_DUMP => 0,
\&                DISPLAY_DEC_DUMP => 0,
\&                COLOR_NAMES => {},
\&                ORIENTATION => \*(Aqhorizontal\*(Aq,
\&                ) ;
.Ve
.PP
\&\fIArguments\fR \- All arguments are optional. Default values are listed below.
.IP "\(bu" 2
\&\s-1NAME\s0 \- String \- Name of the Data::HexDump::Range object, set to 'Anonymous' by default
.IP "\(bu" 2
\&\s-1INTERACTION\s0 \- Hash reference \- Set of subs that are used to display information to the user
.Sp
Useful if you use Data::HexDump::Range in an application without terminal.
.IP "\(bu" 2
\&\s-1VERBOSE\s0 \- Boolean \- Display information about the creation of the object. Default is \fIfalse\fR
.IP "\(bu" 2
\&\s-1DUMP_ORIGINAL_RANGE_DESCRIPTION\s0 \- Boolean \- Diplays the un-processed range descritption.
.Sp
With \fB\s-1DUMP_RANGE_DESCRIPTION\s0\fR, this fields can be used to peek into what range descriptions the module get and how they are
transformed  into the format that is internally used by the module. These are for debugging purpose and you should normally not need to used them.
.Sp
.Vb 5
\& Original range description
\& |\- 0 = \*(AqData\*(Aq
\& |\- 1 = \*(Aq128\*(Aq
\& |\- 2 = undef
\& \`\- 3 = undef
\& 
\& Original range description
\& |\- 0 = CODE(0x1dc5230)
\& |\- 1 = undef
\& |\- 2 = undef
\& \`\- 3 = undef
.Ve
.IP "\(bu" 2
\&\s-1DUMP_RANGE_DESCRIPTION\s0 \- Boolean \- Diplays the processed range descritption in plain text before the dump
.Sp
.Vb 10
\& 128\->26:Data
\& |\- COLOR = undef
\& |\- DATA = \*(Aq_blah_blah_blah_blah_blah[\en]\*(Aq
\& |\- IS_BITFIELD = \*(Aq0\*(Aq
\& |\- IS_COMMENT = \*(Aq0\*(Aq
\& |\- IS_SKIP = \*(Aq0\*(Aq
\& |\- NAME = \*(Aq128\->26:Data\*(Aq
\& |\- OFFSET = \*(Aq20\*(Aq
\& |\- unpack format = \*(Aqx20 a26\*(Aq
\& \`\- USER_INFORMATION = undef
.Ve
.IP "\(bu" 2
\&\s-1FORMAT\s0 \- String \- format of the dump string generated by Data::HexDump::Range.
.Sp
Default is \fB\s-1ANSI\s0\fR which allows for colors. Other formats are '\s-1ASCII\s0' and '\s-1HTML\s0'.
.IP "\(bu" 2
\&\s-1COLOR\s0 \- String 'cycle', 'no_cycle', 'bw'
.Sp
Controls the coloring policy of ranges
.RS 2
.IP "\(bu" 2
cycle: if the range definition contains a color does not define a color, a color is automatically assigned
.IP "\(bu" 2
no_cycle: only ranges with a color defined are colorized
.IP "\(bu" 2
bw: no color is used even if the range contains a color definition
.RE
.RS 2
.RE
.IP "\(bu" 2
\&\s-1OFFSET_FORMAT\s0 \- String \- 'hex' or 'dec'
.Sp
If set to 'hex', the offset will be displayed in base 16. When set to 'dec' the offset is displayed
in base 10. Default is 'hex'.
.IP "\(bu" 2
\&\s-1DATA_WIDTH\s0 \- Integer \- Number of elements displayed per line. Default is 16.
.IP "\(bu" 2
\&\s-1DISPLAY_RANGE_NAME\s0 \- Boolean \- If set, range names are displayed in the dump.
.IP "\(bu" 2
\&\s-1MAXIMUM_RANGE_NAME_SIZE\s0 \- Integer \- maximum size of a range name (horizontal mode). Default size is 16.
.IP "\(bu" 2
\&\s-1DISPLAY_COLUMN_NAMES\s0 \- Boolean \-  If set, the column names are displayed. Default \fIfalse\fR
.IP "\(bu" 2
\&\s-1DISPLAY_RULER\s0 \- Boolean \- if set, a ruler is displayed above the dump, Default is \fIfalse\fR
.IP "\(bu" 2
\&\s-1DISPLAY_OFFSET\s0 \- Boolean \- If set, the offset column is displayed. Default \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_CUMULATIVE_OFFSET\s0 \- Boolean \- If set, the cumulative offset column is displayed in 'vertical' rendering mode. Default is \fItrue\fR
.IP "\(bu" 2
\&\s-1OFFSET_START\s0 \- Integer \- value added to the offset.
.IP "\(bu" 2
\&\s-1DISPLAY_ZERO_SIZE_RANGE\s0 \- Boolean \- if set, ranges that do not consume data are displayed. default is \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_ZERO_SIZE_RANGE_WARNING\s0 \- Boolean \- if set, a warning is emitted if ranges that do not consume data. Default is \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_COMMENT_RANGE\s0 \- Boolean \- if set, comment ranges are displayed. default is \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_RANGE_SIZE\s0 \- Bolean \- if set the range size is prepended to the name. Default \fIfalse\fR
.IP "\(bu" 2
\&\s-1DISPLAY_ASCII_DUMP\s0 \- Boolean \- If set, the \s-1ASCII\s0 representation of the binary data is displayed. Default is \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_HEX_DUMP\s0 \- Boolean \- If set, the hexadecimal dump column is displayed. Default is \fItrue\fR
.IP "\(bu" 2
\&\s-1DISPLAY_HEXASCII_DUMP\s0 \- Boolean \- If set, the comined hexadecimal and \s-1ASCII\s0 dump column is displayed. Default is \fIfalse\fR
.IP "\(bu" 2
\&\s-1DISPLAY_DEC_DUMP\s0 \- Boolean \- If set, the decimall dump column is displayed. Default is \fIfalse\fR
.IP "\(bu" 2
\&\s-1DISPLAY_BITFIELD_SOURCE\s0 \- Boolean \- if set an extra column indicating the source of bitfields is displayed
.IP "\(bu" 2
\&\s-1MAXIMUM_BITFIELD_SOURCE_SIZE\s0 \- Integer \- maximum size of the bifield source column
.IP "\(bu" 2
\&\s-1DISPLAY_USER_INFORMATION\s0 \- Boolean \- if set an extra column displaying user supplied information is shown
.IP "\(bu" 2
\&\s-1MAXIMUM_USER_INFORMATION_SIZE\s0 \- Integer \- maximum size of theuser information column
.IP "\(bu" 2
\&\s-1DISPLAY_BITFIELDS\s0 \- Boolean \- if set the bitfields are displayed
.IP "\(bu" 2
\&\s-1BIT_ZERO_ON_LEFT\s0 \- Boolean \- if set the bit of index 0 is on left growing to the right. Default \fIfalse\fR
.IP "\(bu" 2
\&\s-1COLOR_NAMES\s0 \- A hash reference
.Sp
.Vb 6
\&  {
\&  ANSI =>
\&        {
\&        header => \*(Aqyellow on_blue\*(Aq,
\&        data => \*(Aqyellow on_black\*(Aq,
\&        },
\&        
\&  HTML =>
\&        {
\&        header => \*(AqFFFF00 0000FF\*(Aq,
\&        data => \*(AqFFFF00 000000\*(Aq,
\&        },
\&  }
.Ve
.IP "\(bu" 2
\&\s-1ORIENTATION\s0 \- String \- 'vertical' or 'horizontal' (the default).
.PP
\&\fIReturns\fR \- Nothing
.PP
\&\fIExceptions\fR \- Dies if an unsupported option is passed.
.ie n .SS "gather($range_description, $data, $offset, $size)"
.el .SS "gather($range_description, \f(CW$data\fP, \f(CW$offset\fP, \f(CW$size\fP)"
.IX Subsection "gather($range_description, $data, $offset, $size)"
Dump the data, up to \f(CW$size\fR, according to the description. The data dump is kept in the object so you can
merge multiple gathered dumps and get a single rendering.
.PP
.Vb 2
\&  $hdr\->gather($range_description, $data, $offset, $size)
\&  $hdr\->gather($range_description, $more_data)
\&  
\&  print $hdr\->dump_gathered() ;
.Ve
.PP
\&\fIArguments\fR
.IP "\(bu" 2
\&\f(CW$range_description\fR \- See \*(L"Range definition\*(R"
.IP "\(bu" 2
\&\f(CW$data\fR \- A string \- binary data to dump
.IP "\(bu" 2
\&\f(CW$offset\fR \- dump data from offset
.RS 2
.IP "\(bu" 2
undef \- start from first byte
.RE
.RS 2
.RE
.IP "\(bu" 2
\&\f(CW$size\fR \- amount of data to dump
.RS 2
.IP "\(bu" 2
undef \- use range description
.IP "\(bu" 2
\&\s-1CONSUME_ALL_DATA\s0 \- apply range descritption till all data is consumed
.RE
.RS 2
.RE
.PP
\&\fIReturns\fR \- An integer \- the number of processed bytes
.PP
\&\fIExceptions\fR \- See _gather
.SS "\fBdump_gathered()\fP"
.IX Subsection "dump_gathered()"
Returns the dump string for the gathered data.
.PP
.Vb 2
\&  $hdr\->gather($range_description, $data, $size)
\&  $hdr\->gather($range_description, $data, $size)
\&  
\&  print $hdr\->dump_gathered() ;
.Ve
.PP
\&\fIArguments\fR \- None
.PP
\&\fIReturns\fR \- A string \- the binary data formated according to the rnage descriptions
.PP
\&\fIExceptions\fR \- None
.ie n .SS "dump($range_description, $data, $offset, $size)"
.el .SS "dump($range_description, \f(CW$data\fP, \f(CW$offset\fP, \f(CW$size\fP)"
.IX Subsection "dump($range_description, $data, $offset, $size)"
Dump the data, up to \f(CW$size\fR, according to the description
.PP
\&\fIArguments\fR \- See gather
.PP
\&\fIReturns\fR \- A string \-  the formated dump
.PP
\&\fIExceptions\fR \- dies if the range description is invalid
.ie n .SS "get_dump_and_consumed_data_size($range_description, $data, $offset, $size)"
.el .SS "get_dump_and_consumed_data_size($range_description, \f(CW$data\fP, \f(CW$offset\fP, \f(CW$size\fP)"
.IX Subsection "get_dump_and_consumed_data_size($range_description, $data, $offset, $size)"
Dump the data, from \f(CW$offset\fR up to \f(CW$size\fR, according to the \f(CW$range_description\fR
.PP
\&\fIArguments\fR \- See gather
.PP
\&\fIReturns\fR \-
.IP "\(bu" 2
A string \-  the formated dump
.IP "\(bu" 2
An integer \- the number of bytes consumed by the range specification
.PP
\&\fIExceptions\fR \- dies if the range description is invalid
.SS "\fBreset()\fP"
.IX Subsection "reset()"
Clear the gathered dump
.PP
\&\fIArguments\fR \- None
.PP
\&\fIReturns\fR \- Nothing
.PP
\&\fIExceptions\fR \- None
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
None so far.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&        Nadim ibn hamouda el Khemir
\&        CPAN ID: NKH
\&        mailto: nadim@cpan.org
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright Nadim Khemir 2010\-2012.
.PP
This program is free software; you can redistribute it and/or
modify it under the terms of either:
.IP "\(bu" 4
the \s-1GNU\s0 General Public License as published by the Free
Software Foundation; either version 1, or (at your option) any
later version, or
.IP "\(bu" 4
the Artistic License version 2.0.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Data::HexDump::Range
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Data\-HexDump\-Range>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
Please report any bugs or feature requests to  L <bug\-data\-hexdump\-range@rt.cpan.org>.
.Sp
We will be notified, and then you'll automatically be notified of progress on
your bug as we make changes.
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Data\-HexDump\-Range>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Hexdumper, Data::ParseBinary, Convert::Binary::C, Parse::Binary
