.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Admin::DSNManager 3"
.TH DBIx::Admin::DSNManager 3 "2020-09-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Admin::DSNManager \- Manage a file of DSNs, for both testing and production
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&        #!/usr/bin/env perl
\&
\&        use strict;
\&        use warnings;
\&
\&        use DBIx::Admin::DSNManager;
\&
\&        us Try::Tiny;
\&
\&        # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        try
\&        {
\&                my($man1) = DBIx::Admin::DSNManager \-> new
\&                (
\&                        config  => {\*(AqPg.1\*(Aq => {dsn => \*(Aqdbi:Pg:dbname=test\*(Aq, username => \*(Aqme\*(Aq, active => 1} },
\&                        verbose => 1,
\&                );
\&
\&                my($file_name) = \*(Aq/tmp/dsn.ini\*(Aq;
\&
\&                $man1 \-> write($file_name);
\&
\&                my($man2) = DBIx::Admin::DSNManager \-> new
\&                (
\&                        file_name => $file_name,
\&                        verbose   => 1,
\&                );
\&
\&                $man2 \-> report;
\&        }
\&        catch
\&        {
\&                print "DBIx::Admin::DSNManager died. Error: $_";
\&        };
.Ve
.PP
See scripts/synopsis.pl.
.SH "Description"
.IX Header "Description"
DBIx::Admin::DSNManager manages a file of DSNs, for both testing and production.
.PP
The INI-style format was selected, rather than, say, using an SQLite database, so that casual users could edit
the file without needing to know \s-1SQL\s0 and without having to install the command line program sqlite3.
.PP
Each \s-1DSN\s0 is normally for something requiring manual preparation, such as creating the database named in the \s-1DSN.\s0
.PP
In the case of SQLite, etc, where manual intervention is not required, you can still put the \s-1DSN\s0 in
dsn.ini.
.PP
One major use of this module is to avoid environment variable overload, since it is common to test Perl modules
by setting the env vars \f(CW$DBI_DSN\fR, \f(CW$DBI_USER\fR and \f(CW$DBI_PASS\fR.
.PP
But then the problem becomes: What do you do when you want to run tests against a set of databases servers?
Some modules define sets of env vars, one set per database server, with awkward and hard-to-guess names.
This is messy and obscure.
.PP
DBIx::Admin::DSNManager is a solution to this problem.
.SH "Database Creation"
.IX Header "Database Creation"
By design, DBIx::Admin::DSNManager does not provide a create-database option.
.PP
For database servers like Postgres, MySQL, etc, you must create users, and give them the createdb privilege.
Such actions are outside the scope of this module.
.PP
For database servers like SQLite, any code can create a database anyway, but you can use options in dsn.ini
to indicate the \s-1DSN\s0 is inactive, or not to be used for testing. See \*(L"The Format of dsn.ini\*(R" below.
.SH "Testing 'v' Production"
.IX Header "Testing 'v' Production"
Of course, you may have DSNs in dsn.ini which you don't want to be used for testing.
.PP
Here's a policy for handling such situations:
.IP "o An explicit use_for_testing flag" 4
.IX Item "o An explicit use_for_testing flag"
Each \s-1DSN\s0 in the file can be marked with the option 'use_for_testing = 0', to stop usage for testing,
or 'use_for_testing = 1', to allow usage for testing.
.Sp
The default is 0 \- do not use for testing.
.IP "o An implicit \s-1DSN\s0" 4
.IX Item "o An implicit DSN"
For cases like SQLite, testing code can either look in dsn.ini, or manufacture a temporary directory and file name
for testing.
.Sp
This leads to a new question: If the testing code finds a \s-1DSN\s0 in dsn.ini which is marked use_for_testing = 0,
should that code still generate another \s-1DSN\s0 for testing? My suggestions is: Yes, since the one in dsn.ini does
not indicate that all possible DSNs should be blocked from testing.
.SH "The Format of dsn.ini"
.IX Header "The Format of dsn.ini"
On disk, dsn.ini is a typical INI-style file. In \s-1RAM\s0 it is a hashref of config options. E.g.:
.PP
.Vb 1
\&        config => {\*(AqPg.1\*(Aq => {dsn => \*(Aqdbi:Pg:dbname=test\*(Aq, ...}, \*(AqPg.2\*(Aq => {...} }
.Ve
.PP
where config is the name of the module getter/setter which provides access to the hashref.
.IP "o Sections" 4
.IX Item "o Sections"
Section names are unique, case-sensitive, strings.
.Sp
So 2 Postgres sections might be:
.Sp
.Vb 2
\&        [Pg.1]
\&        ...
\&
\&        [Pg.2]
\&        ...
.Ve
.IP "o Connexion info within each section" 4
.IX Item "o Connexion info within each section"
Each section can have these keys:
.RS 4
.IP "o A \s-1DSN\s0 string" 4
.IX Item "o A DSN string"
A typical Postgres dsn would be:
.Sp
dsn = dbi:Pg:dbname=test
.Sp
A dsn key is mandatory within each section.
.Sp
The \s-1DSN\s0 names the driver to use and the database.
.IP "o A Username string" 4
.IX Item "o A Username string"
E.g.: username = testuser
.Sp
A username is optional.
.Sp
If a username is not provided for a dsn, the empty string is used.
.IP "o A Password string" 4
.IX Item "o A Password string"
E.g.: password = testpass
.Sp
A password is optional.
.Sp
If a password is not provided for a dsn, the empty string is used.
.IP "o \s-1DSN\s0 Attributes as a hashref" 4
.IX Item "o DSN Attributes as a hashref"
E.g.:
.Sp
attributes = {AutoCommit => 1, PrintError => 0, RaiseError = 1}
.Sp
Attributes are optional.
.Sp
Their format is exactly the same as for \s-1DBI\s0.
.Sp
If attributes are not provided, they default to the example above.
.IP "o A Boolean active flag" 4
.IX Item "o A Boolean active flag"
E.g.: active = 0
.Sp
or active = 1
.Sp
The active key is optional.
.Sp
If the active key is not provided for a dsn, it defaults to 0 \- do not use.
.Sp
This key means you can easily disable a \s-1DSN\s0 without having to delete the section, or comment it all out.
.IP "o A Boolean testing flag" 4
.IX Item "o A Boolean testing flag"
E.g.: use_for_testing = 0
.Sp
or use_for_testing = 1
.Sp
The use_for_testing key is optional.
.Sp
If the use_for_testing key is not provided for a dsn, it defaults to 0 \- do not use for testing.
.RE
.RS 4
.RE
.PP
So, a sample dsn.ini file looks like:
.PP
.Vb 6
\&        [Pg.1]
\&        dsn=dbi:Pg:dbname=test1
\&        username=user1
\&        password=pass1
\&        attributes = {AutoCommit => 1, PrintError => 0, RaiseError => 1}
\&        use_for_testing = 0
\&
\&        [Pg.2]
\&        dsn=dbi:Pg:dbname=test2
\&        username=user2
\&        password=pass2
\&        active = 0
\&        use_for_testing = 1
\&
\&        [SQLite.1]
\&        dsn=dbi:SQLite:dbname=/tmp/test.module.sqlite
.Ve
.PP
This file is read by Config::Tiny. Check its docs for details, but there is one thing to be aware of:
Config::Tiny does not recognize comments at the ends of lines. So:
.PP
key = value # A comment.
.PP
sets key to 'value # A comment.', which is probably not what you intended.
.SH "Constructor and Initialization"
.IX Header "Constructor and Initialization"
Calling \f(CW\*(C`new()\*(C'\fR returns a object of type DBIx::Admin::DSNManager, or dies.
.PP
\&\f(CW\*(C`new()\*(C'\fR takes a hash of key/value pairs, some of which might be mandatory. Further, some combinations
might be mandatory.
.PP
The keys are listed here in alphabetical order.
.PP
They are lower-case because they are (also) method names, meaning they can be called to set or get the value
at any time.
.PP
But a warning: In some cases, setting them after this module has used the previous value, will have no effect.
All such cases are documented (or should be).
.IP "o config => {...}" 4
.IX Item "o config => {...}"
Specifies a hashref to use as the initial value of the internal config hashref which holds the set of DSNs.
.Sp
This hashref is keyed by section name, with each key pointing to a hashref of dsn data. E.g.:
.Sp
.Vb 1
\&        config => {\*(AqPg.1\*(Aq => {dsn => \*(Aqdbi:Pg:dbname=test\*(Aq, ...}, \*(AqPg.2\*(Aq => {...} }
.Ve
.Sp
Default: undef.
.ie n .IP "o file_name => $string" 4
.el .IP "o file_name => \f(CW$string\fR" 4
.IX Item "o file_name => $string"
Specifies the name of the file holding the DSNs.
.Sp
If specified, the code reads this file and populates the hashref returned by \f(CW\*(C`config()\*(C'\fR.
.Sp
This key is optional.
.Sp
Default: ''.
.IP "o verbose => 0 | 1" 4
.IX Item "o verbose => 0 | 1"
Specify more or less output.
.Sp
Default: 0.
.SH "Methods"
.IX Header "Methods"
.SS "config([{...}])"
.IX Subsection "config([{...}])"
Here, the [] indicate an optional parameter.
.PP
Get or set the internal config hashref holding all the \s-1DSN\s0 data.
.PP
If called as config({...}), set the config hashref to the parameter.
.PP
If called as \fBconfig()\fR, return the config hashref.
.SS "hashref2string($hashref)"
.IX Subsection "hashref2string($hashref)"
Returns a string corresponding to the \f(CW$hashref\fR.
.PP
{} is converted to '{}'.
.SS "read($file_name)"
.IX Subsection "read($file_name)"
Read \f(CW$file_name\fR using Config::Tiny and set the config hashref.
.SS "report([{...}])"
.IX Subsection "report([{...}])"
Here, the [] indicate an optional parameter.
.PP
If called as \f(CW$object\fR \-> report, print both \f(CW$object\fR \-> file_name, and the contents of the config hashref, to \s-1STDERR.\s0
.PP
If called as \f(CW$object\fR \-> report({...}), print just the contents of the hashref, to \s-1STDERR.\s0
.SS "string2hashref($s)"
.IX Subsection "string2hashref($s)"
Returns a hashref built from the string.
.PP
The string is expected to be something like '{AutoCommit => 1, PrintError => 0}'.
.PP
The empty string is returned as {}.
.SS "validate([{...}])"
.IX Subsection "validate([{...}])"
Here, the [] indicate an optional parameter.
.PP
Validate the given or config hashref.
.PP
Returns the validated hashref.
.PP
If a hashref is not supplied, validate the config one.
.PP
Currently, the checks are:
.IP "o There must be at least 1 section" 4
.IX Item "o There must be at least 1 section"
.PD 0
.IP "o All sections must have a 'dsn' key" 4
.IX Item "o All sections must have a 'dsn' key"
.PD
.SS "write([$file_name,][{...}])"
.IX Subsection "write([$file_name,][{...}])"
Here, the [] indicate an optional parameter.
.PP
Write the given or config hashref to \f(CW$file_name\fR.
.PP
The [] mean a parameter is optional.
.PP
If called as \f(CW$object\fR \-> write('dsn.ini'), write the config hashref to \f(CW$file_name\fR.
.PP
If called as \f(CW$object\fR \-> write('dsn.ini', {...}), write the given hashref to \f(CW$file_name\fR.
.PP
If called as \f(CW$object\fR \-> write({...}), write the given hashref to \f(CW$object\fR \-> file_name.
.PP
File::Slurp is used to write this file, since these hashes are not of type \f(CW\*(C`Config::Tiny\*(C'\fR.
.SS "See Also"
.IX Subsection "See Also"
DBIx::Admin::CreateTable.
.PP
DBIx::Admin::TableInfo.
.SH "Version Numbers"
.IX Header "Version Numbers"
Version numbers < 1.00 represent development versions. From 1.00 up, they are production versions.
.SH "Support"
.IX Header "Support"
Log a bug on \s-1RT:\s0 <https://rt.cpan.org/Public/Dist/Display.html?Name=DBIx\-Admin\-DSNManager>.
.SH "Author"
.IX Header "Author"
DBIx::Admin::DSNManager was written by Ron Savage \fI<ron@savage.net.au>\fR in 2010.
.PP
Home page: <http://savage.net.au/index.html>.
.SH "Copyright"
.IX Header "Copyright"
Australian copyright (c) 2010, Ron Savage.
.PP
.Vb 4
\&        All Programs of mine are \*(AqOSI Certified Open Source Software\*(Aq;
\&        you can redistribute them and/or modify them under the terms of
\&        The Artistic License, a copy of which is available at:
\&        http://www.opensource.org/licenses/index.html
.Ve
