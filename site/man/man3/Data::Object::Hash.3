.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object::Hash 3"
.TH Data::Object::Hash 3 "2020-04-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object::Hash
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Hash Class for Perl 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Hash;
\&
\&  my $hash = Data::Object::Hash\->new({1..4});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides methods for manipulating hash data.
.SH "INHERITS"
.IX Header "INHERITS"
This package inherits behaviors from:
.PP
Data::Object::Kind
.SH "INTEGRATES"
.IX Header "INTEGRATES"
This package integrates behaviors from:
.PP
Data::Object::Role::Dumpable
.PP
Data::Object::Role::Proxyable
.PP
Data::Object::Role::Throwable
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Data::Object::Types
.SH "METHODS"
.IX Header "METHODS"
This package implements the following methods:
.SS "clear"
.IX Subsection "clear"
.Vb 1
\&  clear() : HashLike
.Ve
.PP
The clear method is an alias to the empty method.
.IP "clear example #1" 4
.IX Item "clear example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->clear; # {}
.Ve
.SS "count"
.IX Subsection "count"
.Vb 1
\&  count() : Num
.Ve
.PP
The count method returns the total number of keys defined.
.IP "count example #1" 4
.IX Item "count example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..4});
\&
\&  $hash\->count; # 2
.Ve
.SS "defined"
.IX Subsection "defined"
.Vb 1
\&  defined() : Num
.Ve
.PP
The defined method returns true if the value matching the key specified in the
argument if defined, otherwise returns false.
.IP "defined example #1" 4
.IX Item "defined example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->defined;
.Ve
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  delete(Num $arg1) : Any
.Ve
.PP
The delete method returns the value matching the key specified in the argument
and returns the value.
.IP "delete example #1" 4
.IX Item "delete example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->delete(1); # 2
.Ve
.SS "each"
.IX Subsection "each"
.Vb 1
\&  each(CodeRef $arg1, Any @args) : Any
.Ve
.PP
The each method executes callback for each element in the hash passing the
routine the key and value at the current position in the loop.
.IP "each example #1" 4
.IX Item "each example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->each(sub {
\&    my ($key, $value) = @_;
\&
\&    [$key, $value]
\&  });
.Ve
.SS "each_key"
.IX Subsection "each_key"
.Vb 1
\&  each_key(CodeRef $arg1, Any @args) : Any
.Ve
.PP
The each_key method executes callback for each element in the hash passing the
routine the key at the current position in the loop.
.IP "each_key example #1" 4
.IX Item "each_key example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->each_key(sub {
\&    my ($key) = @_;
\&
\&    [$key]
\&  });
.Ve
.SS "each_n_values"
.IX Subsection "each_n_values"
.Vb 1
\&  each_n_values(Num $arg1, CodeRef $arg2, Any @args) : Any
.Ve
.PP
The each_n_values method executes callback for each element in the hash passing
the routine the next n values until all values have been seen.
.IP "each_n_values example #1" 4
.IX Item "each_n_values example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->each_n_values(4, sub {
\&    my (@values) = @_;
\&
\&    # $values[1] # 2
\&    # $values[2] # 4
\&    # $values[3] # 6
\&    # $values[4] # 8
\&
\&    [@values]
\&  });
.Ve
.SS "each_value"
.IX Subsection "each_value"
.Vb 1
\&  each_value(CodeRef $arg1, Any @args) : Any
.Ve
.PP
The each_value method executes callback for each element in the hash passing
the routine the value at the current position in the loop.
.IP "each_value example #1" 4
.IX Item "each_value example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->each_value(sub {
\&    my ($value) = @_;
\&
\&    [$value]
\&  });
.Ve
.SS "empty"
.IX Subsection "empty"
.Vb 1
\&  empty() : HashLike
.Ve
.PP
The empty method drops all elements from the hash.
.IP "empty example #1" 4
.IX Item "empty example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->empty; # {}
.Ve
.SS "eq"
.IX Subsection "eq"
.Vb 1
\&  eq(Any $arg1) : Num
.Ve
.PP
The eq method will throw an exception if called.
.IP "eq example #1" 4
.IX Item "eq example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->eq({});
.Ve
.SS "exists"
.IX Subsection "exists"
.Vb 1
\&  exists(Num $arg1) : Num
.Ve
.PP
The exists method returns true if the value matching the key specified in the
argument exists, otherwise returns false.
.IP "exists example #1" 4
.IX Item "exists example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8,9,undef});
\&
\&  $hash\->exists(1); # 1; true
.Ve
.IP "exists example #2" 4
.IX Item "exists example #2"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8,9,undef});
\&
\&  $hash\->exists(0); # 0; false
.Ve
.SS "filter_exclude"
.IX Subsection "filter_exclude"
.Vb 1
\&  filter_exclude(Str @args) : HashRef
.Ve
.PP
The filter_exclude method returns a hash reference consisting of all key/value
pairs in the hash except for the pairs whose keys are specified in the
arguments.
.IP "filter_exclude example #1" 4
.IX Item "filter_exclude example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->filter_exclude(1,3); # {5=>6,7=>8}
.Ve
.SS "filter_include"
.IX Subsection "filter_include"
.Vb 1
\&  filter_include(Str @args) : HashRef
.Ve
.PP
The filter_include method returns a hash reference consisting of only key/value
pairs whose keys are specified in the arguments.
.IP "filter_include example #1" 4
.IX Item "filter_include example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->filter_include(1,3); # {1=>2,3=>4}
.Ve
.SS "fold"
.IX Subsection "fold"
.Vb 1
\&  fold(Str $arg1, HashRef $arg2, HashRef $arg3) : HashRef
.Ve
.PP
The fold method returns a single-level hash reference consisting of key/value
pairs whose keys are paths (using dot-notation where the segments correspond to
nested hash keys and array indices) mapped to the nested values.
.IP "fold example #1" 4
.IX Item "fold example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({3,[4,5,6],7,{8,8,9,9}});
\&
\&  $hash\->fold; # {\*(Aq3:0\*(Aq=>4,\*(Aq3:1\*(Aq=>5,\*(Aq3:2\*(Aq=>6,\*(Aq7.8\*(Aq=>8,\*(Aq7.9\*(Aq=>9}
.Ve
.SS "ge"
.IX Subsection "ge"
.Vb 1
\&  ge(Any $arg1) : Num
.Ve
.PP
The ge method will throw an exception if called.
.IP "ge example #1" 4
.IX Item "ge example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->ge({});
.Ve
.SS "get"
.IX Subsection "get"
.Vb 1
\&  get(Str $arg1) : Any
.Ve
.PP
The get method returns the value of the element in the hash whose key
corresponds to the key specified in the argument.
.IP "get example #1" 4
.IX Item "get example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->get(5); # 6
.Ve
.SS "grep"
.IX Subsection "grep"
.Vb 1
\&  grep(CodeRef $arg1, Any $arg2) : HashRef
.Ve
.PP
The grep method executes callback for each key/value pair in the hash passing
the routine the key and value at the current position in the loop and returning
a new hash reference containing the elements for which the argument evaluated
true.
.IP "grep example #1" 4
.IX Item "grep example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..4});
\&
\&  $hash\->grep(sub {
\&    my ($value) = @_;
\&
\&    $value >= 3
\&  });
\&
\&  # {3=>4}
.Ve
.SS "gt"
.IX Subsection "gt"
.Vb 1
\&  gt(Any $arg1) : Num
.Ve
.PP
The gt method will throw an exception if called.
.IP "gt example #1" 4
.IX Item "gt example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->gt({});
.Ve
.SS "head"
.IX Subsection "head"
.Vb 1
\&  head() : Any
.Ve
.PP
The head method will throw an exception if called.
.IP "head example #1" 4
.IX Item "head example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->head;
.Ve
.SS "invert"
.IX Subsection "invert"
.Vb 1
\&  invert() : Any
.Ve
.PP
The invert method returns the hash after inverting the keys and values
respectively. Note, keys with undefined values will be dropped, also, this
method modifies the hash.
.IP "invert example #1" 4
.IX Item "invert example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8,9,undef,10,\*(Aq\*(Aq});
\&
\&  $hash\->invert; # {\*(Aq\*(Aq=>10,2=>1,4=>3,6=>5,8=>7}
.Ve
.SS "iterator"
.IX Subsection "iterator"
.Vb 1
\&  iterator() : CodeRef
.Ve
.PP
The iterator method returns a code reference which can be used to iterate over
the hash. Each time the iterator is executed it will return the values of the
next element in the hash until all elements have been seen, at which point the
iterator will return an undefined value.
.IP "iterator example #1" 4
.IX Item "iterator example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  my $iterator = $hash\->iterator;
\&
\&  # while (my $value = $iterator\->next) {
\&  #     say $value; # 2
\&  # }
.Ve
.SS "join"
.IX Subsection "join"
.Vb 1
\&  join() : Any
.Ve
.PP
The join method will throw an exception if called.
.IP "join example #1" 4
.IX Item "join example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->join;
.Ve
.SS "keys"
.IX Subsection "keys"
.Vb 1
\&  keys() : ArrayRef
.Ve
.PP
The keys method returns an array reference consisting of all the keys in the
hash.
.IP "keys example #1" 4
.IX Item "keys example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->keys; # [1,3,5,7]
.Ve
.SS "kvslice"
.IX Subsection "kvslice"
.Vb 1
\&  kvslice(Str @args) : HashRef
.Ve
.PP
The kvslice method returns a hash reference containing the elements in the hash
at the key(s) specified in the arguments.
.IP "kvslice example #1" 4
.IX Item "kvslice example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->kvslice(1,5); # {1=>2,5=>6}
.Ve
.SS "le"
.IX Subsection "le"
.Vb 1
\&  le(Any $arg1) : Num
.Ve
.PP
The le method will throw an exception if called.
.IP "le example #1" 4
.IX Item "le example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->le;
.Ve
.SS "length"
.IX Subsection "length"
.Vb 1
\&  length() : Num
.Ve
.PP
The length method returns the number of keys in the hash.
.IP "length example #1" 4
.IX Item "length example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->length; # 4
.Ve
.SS "list"
.IX Subsection "list"
.Vb 1
\&  list() : (Any)
.Ve
.PP
The list method returns a shallow copy of the underlying hash reference as an
array reference.
.IP "list example #1" 4
.IX Item "list example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  [$hash\->list];
.Ve
.SS "lookup"
.IX Subsection "lookup"
.Vb 1
\&  lookup(Str $arg1) : Any
.Ve
.PP
The lookup method returns the value of the element in the hash whose key
corresponds to the key specified in the argument. The key can be a string which
references (using dot-notation) nested keys within the hash. This method will
return undefined if the value is undef or the location expressed in the
argument can not be resolved. Please note, keys containing dots (periods) are
not handled.
.IP "lookup example #1" 4
.IX Item "lookup example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..3,{4,{5,6,7,{8,9,10,11}}}});
\&
\&  $hash\->lookup(\*(Aq3.4.7\*(Aq); # {8=>9,10=>11}
.Ve
.IP "lookup example #2" 4
.IX Item "lookup example #2"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..3,{4,{5,6,7,{8,9,10,11}}}});
\&
\&  $hash\->lookup(\*(Aq3.4\*(Aq); # {5=>6,7=>{8=>9,10=>11}}
.Ve
.IP "lookup example #3" 4
.IX Item "lookup example #3"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..3,{4,{5,6,7,{8,9,10,11}}}});
\&
\&  $hash\->lookup(1); # 2
.Ve
.SS "lt"
.IX Subsection "lt"
.Vb 1
\&  lt(Any $arg1) : Num
.Ve
.PP
The lt method will throw an exception if called.
.IP "lt example #1" 4
.IX Item "lt example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->lt({});
.Ve
.SS "map"
.IX Subsection "map"
.Vb 1
\&  map(CodeRef $arg1, Any $arg2) : ArrayRef
.Ve
.PP
The map method executes callback for each key/value in the hash passing the
routine the value at the current position in the loop and returning a new hash
reference containing the elements for which the argument returns a value or
non-empty list.
.IP "map example #1" 4
.IX Item "map example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..4});
\&
\&  $hash\->map(sub {
\&    $_[0] + 1
\&  });
.Ve
.SS "merge"
.IX Subsection "merge"
.Vb 1
\&  merge() : HashRef
.Ve
.PP
The merge method returns a hash reference where the elements in the hash and
the elements in the argument(s) are merged. This operation performs a deep
merge and clones the datasets to ensure no side-effects. The merge behavior
merges hash references only, all other data types are assigned with precendence
given to the value being merged.
.IP "merge example #1" 4
.IX Item "merge example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->merge({7,7,9,9}); # {1=>2,3=>4,5=>6,7=>7,9=>9}
.Ve
.SS "ne"
.IX Subsection "ne"
.Vb 1
\&  ne(Any $arg1) : Num
.Ve
.PP
The ne method will throw an exception if called.
.IP "ne example #1" 4
.IX Item "ne example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new;
\&
\&  $hash\->ne({});
.Ve
.SS "pairs"
.IX Subsection "pairs"
.Vb 1
\&  pairs() : ArrayRef
.Ve
.PP
The pairs method is an alias to the pairs_array method.
.IP "pairs example #1" 4
.IX Item "pairs example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->pairs; # [[1,2],[3,4],[5,6],[7,8]]
.Ve
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&  reset() : HashLike
.Ve
.PP
The reset method returns nullifies the value of each element in the hash.
.IP "reset example #1" 4
.IX Item "reset example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->reset; # {1=>undef,3=>undef,5=>undef,7=>undef}
.Ve
.SS "reverse"
.IX Subsection "reverse"
.Vb 1
\&  reverse() : HashRef
.Ve
.PP
The reverse method returns a hash reference consisting of the hash's keys and
values inverted. Note, keys with undefined values will be dropped.
.IP "reverse example #1" 4
.IX Item "reverse example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8,9,undef});
\&
\&  $hash\->reverse; # {8=>7,6=>5,4=>3,2=>1}
.Ve
.SS "set"
.IX Subsection "set"
.Vb 1
\&  set(Str $arg1, Any $arg2) : Any
.Ve
.PP
The set method returns the value of the element in the hash corresponding to
the key specified by the argument after updating it to the value of the second
argument.
.IP "set example #1" 4
.IX Item "set example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->set(1,10); # 10
.Ve
.IP "set example #2" 4
.IX Item "set example #2"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->set(1,12); # 12
.Ve
.IP "set example #3" 4
.IX Item "set example #3"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->set(1,0); # 0
.Ve
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  slice(Str @args) : ArrayRef
.Ve
.PP
The slice method returns an array reference of the values that correspond to
the key(s) specified in the arguments.
.IP "slice example #1" 4
.IX Item "slice example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->slice(1,3); # [2,4]
.Ve
.SS "sort"
.IX Subsection "sort"
.Vb 1
\&  sort() : Any
.Ve
.PP
The sort method will throw an exception if called.
.IP "sort example #1" 4
.IX Item "sort example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->sort;
.Ve
.SS "tail"
.IX Subsection "tail"
.Vb 1
\&  tail() : Any
.Ve
.PP
The tail method will throw an exception if called.
.IP "tail example #1" 4
.IX Item "tail example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->tail;
.Ve
.SS "unfold"
.IX Subsection "unfold"
.Vb 1
\&  unfold() : HashRef
.Ve
.PP
The unfold method processes previously folded hash references and returns an
unfolded hash reference where the keys, which are paths (using dot-notation
where the segments correspond to nested hash keys and array indices), are used
to created nested hash and/or array references.
.IP "unfold example #1" 4
.IX Item "unfold example #1"
.Vb 3
\&  my $hash = Data::Object::Hash\->new(
\&    {\*(Aq3:0\*(Aq=>4,\*(Aq3:1\*(Aq=>5,\*(Aq3:2\*(Aq=>6,\*(Aq7.8\*(Aq=>8,\*(Aq7.9\*(Aq=>9}
\&  );
\&
\&  $hash\->unfold; # {3=>[4,5,6],7,{8,8,9,9}}
.Ve
.SS "values"
.IX Subsection "values"
.Vb 1
\&  values() : ArrayRef
.Ve
.PP
The values method returns an array reference consisting of the values of the
elements in the hash.
.IP "values example #1" 4
.IX Item "values example #1"
.Vb 1
\&  my $hash = Data::Object::Hash\->new({1..8});
\&
\&  $hash\->values; # [2,4,6,8]
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object/issues>
