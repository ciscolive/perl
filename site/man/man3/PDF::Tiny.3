.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PDF::Tiny 3"
.TH PDF::Tiny 3 "2017-07-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDF::Tiny \- Minimal Lightweight PDF Library
.SH "VERSION"
.IX Header "VERSION"
Version 0.09
.PP
This is an alpha version.  The \s-1API\s0 is still subject to change.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PDF::Tiny;
\&
\&  # Count pages
\&  my $filename = "filename.pdf"
\&  my $pdf = new PDF::Tiny $filename;
\&  my $page_count = $pdf\->page_count;
\&  print "$filename has $page_count page", \*(Aqs\*(Aqx($page_count!=1), ".\en";
\&
\&  # Extract pages
\&  my $source_pdf  = new PDF::Tiny "other.pdf";
\&  my $new_pdf     = new PDF::Tiny version => $source_pdf\->version;
\&  # Get just the first three
\&  for (0..2) {
\&    $new_pdf\->import_page($source_pdf, $_);
\&  }
\&  $new_pdf\->print(fh => \e*STDOUT); # or filename => "out.pdf"
\&
\&  # Change title (low\-level stuff)
\&  my $pdf = new PDF::Tiny "foo.pdf";
\&  $pdf\->trailer\->[1]\->{Info}
\&    ||= PDF::Tiny::make_ref($pdf\->add_obj(PDF::Tiny::make_dict({})));
\&  $pdf\->vivify_obj(\*(Aqstr\*(Aq, \*(Aq/Info\*(Aq, \*(Aq/Title\*(Aq)\->[1] = "Tie Tool";
\&  $pdf\->append;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very lightweight (and limited) \s-1PDF\s0 parser.  If you need to do
some simple \s-1PDF\s0 processing on a web server with limited \s-1RAM\s0 and \s-1CPU,\s0 and if
slurping the entire file into memory is not an option, this module may well
be for you, at the cost of far less functionality than other solutions out
there.
.PP
This module really does assume you know something about the \s-1PDF\s0 format.
This documentation includes a brief section on \*(L"\s-1THE PDF FILE FORMAT\*(R"\s0, if
you are too lazy to read the specification.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
.IP "\(bu" 4
Encrypted PDFs are not supported.
.IP "\(bu" 4
The only stream encoding supported is FlateEncoding.  In practice, I have
never seen any other encoding used in PDFs, except for graphics, so this is
probably not a problem.
.IP "\(bu" 4
Streams are only decoded, not encoded.
.IP "\(bu" 4
Append mode only modifies the existing file.  It will not write to a new
file.  Duplicate the file first if this is a problem.
.IP "\(bu" 4
Files with \s-1PDF 1.5\s0 (Acrobat 6) cross-reference and object streams cannot be
appended to (updated incrementally).
.IP "\(bu" 4
Hybrid-reference files (files with alternate cross-reference tables for
different \s-1PDF\s0 versions) are not fully supported.  The objects referenced
only by streams will be ignored.  I have never actually seen such a file.
.IP "\(bu" 4
There is no capability (yet) in this module for handling text strings.
The title example in the \*(L"\s-1SYNOPSIS\*(R"\s0 is limited to \s-1ASCII\s0 unless you read
the \s-1PDF\s0 spec and encode the string yourself.
.IP "\(bu" 4
There are very few high-level functions.  If you know your way around the \s-1PDF\s0 spec, you can accomplish a lot with this module.  If not, your mileage
may vary (but do read \*(L"\s-1THE PDF FILE FORMAT\*(R"\s0, below).  (I am open to
suggestions for additions, but they need to be fairly general and tiny
enough to implement in a Tiny module.)
.IP "\(bu" 4
There is not much error checking.  PDFs are generally assumed to be
well-formed.  If they are not, or if you use the low-level functions
incorrectly, you may get errors that are hard to debug.
.SH "INTERFACE"
.IX Header "INTERFACE"
This section uses many terms that are explained in \*(L"\s-1THE PDF FILE FORMAT\*(R"\s0
and the \*(L"\s-1GLOSSARY\*(R"\s0, below.
.SS "Constructor"
.IX Subsection "Constructor"
You can create a \s-1PDF\s0 from scratch:
.PP
.Vb 1
\&  $pdf = new PDF::Tiny;
.Ve
.PP
Or open an existing file:
.PP
.Vb 1
\&  $pdf = new PDF::Tiny $filename;
.Ve
.PP
The constructor also accepts hash-style arguments:
.PP
.Vb 5
\&  $pdf = new PDF::Tiny
\&             filename => "foo.pdf",
\&             empty    => 0,
\&             version  => "1.4",
\&  ;
.Ve
.PP
If \f(CW\*(C`filename\*(C'\fR is absent, it is assumed that a \s-1PDF\s0 file is being created
from scratch.
.PP
\&\f(CW\*(C`empty\*(C'\fR is a boolean parameter (ignored if a file name is given).  When it
is false (the default), the new PDF::Tiny object will contain a root and a
pages object (the latter containing a Kids array and a Count of 0).  If
\&\f(CW\*(C`empty\*(C'\fR is true, the root and the pages array will be absent.  Only use
this if you are going to add the root yourself.  (A \s-1PDF\s0 without a root and
a page tree is not well-formed.  High-level methods may not work until you
have added those.)
.PP
\&\f(CW\*(C`version\*(C'\fR specifies the version of the \s-1PDF\s0 format.  It is ignored when
opening an existing file.  It defaults to 1.4 when creating a \s-1PDF\s0 from
scratch.  If you are going to make a \s-1PDF\s0 file that contains pages from
another \s-1PDF,\s0 you should probably set it to the version of the other \s-1PDF\s0
file.
.SS "High-Level Methods"
.IX Subsection "High-Level Methods"
.IP "page_count" 4
.IX Item "page_count"
Returns the number of pages in the \s-1PDF.\s0
.IP "delete_page" 4
.IX Item "delete_page"
.Vb 1
\&  $pdf\->delete_page(7);
.Ve
.Sp
Deletes the specified page.  Pages are numbered from 0.  Negative numbers
count from the end.  \-1 means the last page.
.IP "import_page" 4
.IX Item "import_page"
.Vb 1
\&  $pdf\->import_page($source_pdf, $num, $offset)
.Ve
.Sp
Imports the specified page from another \s-1PDF.\s0  \f(CW$offset\fR specifies where to
put it in the new \s-1PDF.\s0  0 means before the first page.  \-1 means before the
last page.  \f(CW\*(C`undef\*(C'\fR means at the very end.
.IP "append" 4
.IX Item "append"
Appends the modifications to the end of an existing \s-1PDF\s0 file.  (PDFs
support incremental updates.)  This does not work with PDFs created from
scratch or with PDFs containing cross-reference streams (version 1.5 and
later).
.Sp
The PDF::Tiny object is not usable after you call \f(CW\*(C`append\*(C'\fR.  This is for
speedâ€™s sake.  It is not worth doing extra work to keep an object
functional that may not even be used again.  Just re-open the file if you
need to continue doing stuff after calling \f(CW\*(C`append\*(C'\fR.
.Sp
\&\f(CW\*(C`append\*(C'\fR can be handy if you are batch-processing huge files and making
tiny changes (e.g., changing the title), but there are some gotchas.  See
\&\*(L"modified\*(R".  (The gotchas do not apply if you are only using high-level
methods to make changes.)
.IP "print" 4
.IX Item "print"
.Vb 2
\&  $pdf\->print(fh => $handle);
\&  $pdf\->print(filename => "foo.pdf");
.Ve
.Sp
Produces a \s-1PDF\s0 file from scratch.  Orphaned objects (indirect objects not
referenced anywhere) are not included.  However, no objects are renumbered,
so you may get a bloated cross-reference table.  (See also \f(CW\*(C`import_obj\*(C'\fR.)
If a filehandle is passed, it is not closed afterwards.
.Sp
Since the file is not actually read into memory in full, \f(CW\*(C`print\*(C'\fR needs
access to the original file.  It cannot read and clobber it at the same
time.  So \f(CW\*(C`filename\*(C'\fR must not be the file that was originally opened,
unless you deleted it before calling \f(CW\*(C`print\*(C'\fR.
.IP "version" 4
.IX Item "version"
An lvalue accessor function returning (optionally setting) the version of
the \s-1PDF\s0 file format.
.SS "Low-Level Methods"
.IX Subsection "Low-Level Methods"
.RS 4
modified
.Sp
.Vb 4
\&  $pdf\->modified;                     # get the hash
\&  $pdf\->modified("1 0");              # mark 1 0 as modified
\&  $pdf\->modified("/Info", "/Title");  # mark the indirect object con\-
\&                                      # taining the title as modified
.Ve
.Sp
This method returns a reference to a hash of modified indirect objects.
This is used to determine which objects need to be included in an
incremental update.  If you pass arguments, the object in question will be
marked as modified.
.Sp
If you are doing an incremental update and modifying objects by hand, you
will need to call this for every object that is modified.  The exceptions
are as follows:
.IP "\(bu" 4
Objects that are imported with \f(CW\*(C`import_obj\*(C'\fR
.IP "\(bu" 4
Objects added with \f(CW\*(C`add_obj\*(C'\fR
.IP "\(bu" 4
Objects returned by \f(CW\*(C`vivify_obj\*(C'\fR
.IP "\(bu" 4
Any changes made by the high-level methods
.RE
.RS 4
.Sp
All of those methods themselves mark the objects as modified.
.Sp
The arguments follow the same format as described below for \*(L"get_obj\*(R",
except that the first argument must be an object id (\*(L"1 0\*(R"), a trailer
entry (\*(L"/Info\*(R") or the word \*(L"trailer\*(R".
.Sp
\&\fBWarning\fR: Getting this right can be tricky.  If a modified object is not
marked as such, the changes made will not be saved by \f(CW\*(C`append\*(C'\fR.  If the
file is small enough, it might be better to use the \f(CW\*(C`print\*(C'\fR method and
avoid this pitfall.
.Sp
The hash format is as follows:
.Sp
.Vb 4
\&   # obj num    value should always be true
\&  { \*(Aq1 0\*(Aq     => 1,
\&    \*(Aq2017 0\*(Aq  => 1,
\&     ... }
.Ve
.Sp
(Yes, you can edit the hash manually.)
.Sp
objects
.Sp
Returns a reference to a hash of all parsed indirect objects.  See
\&\*(L"\s-1GUTS\*(R"\s0.
.Sp
.Vb 1
\&  { \*(Aq1 0\*(Aq => $obj, \*(Aq2 0\*(Aq => $obj2, ... }
.Ve
.Sp
trailer
.Sp
Returns the \s-1PDF\s0 trailer dictionary as a parsed object.  If the \s-1PDF\s0 has
cross-reference streams, then the trailer is actually the dictionary of the
last cross-reference stream.
.Sp
In the latter case, any entries specific to cross-reference streams will be
omitted by \f(CW\*(C`print\*(C'\fR.  (The list used is based on the \s-1PDF 1.7\s0 reference.)
.Sp
read_obj
.Sp
.Vb 1
\&  $pdf\->read_obj("4 0")
.Ve
.Sp
Reads the specified object from the file and stores it as a token sequence
or flat object
(see \*(L"\s-1GUTS\*(R"\s0) in the \f(CW\*(C`objects\*(C'\fR hash.  The stored object is also returned.
.Sp
If the object already exists in memory, it is simply returned.
.Sp
get_obj
.Sp
.Vb 1
\&  $pdf\->get_obj("4 0")
.Ve
.Sp
Reads an indirect object from the file (if necessary), and parses and
returns it.  If it is already in the \f(CW\*(C`objects\*(C'\fR hash, it is upgraded to a
first-class object (if it was flat or a token sequence) and then
returned.  If the object cannot be found, or if it is null, nothing is
returned (\f(CW\*(C`undef\*(C'\fR or
empty list).  See also
\&\*(L"vivify_obj\*(R".
.Sp
.Vb 1
\&  $pdf\->get_obj("4 0", "/Pages", "/Kids", 3);
.Ve
.Sp
Dereferences several levels of objects.  In this example, \*(L"4 0\*(R" is probably
the root object (a dictionary), with a Pages entry (also a dictionary),
with a Kids entry (an array), and it returns element 3 of the Kids array.
If element 3 is a reference, the object it points to is returned.
.Sp
The slash is not optional.  It is used to distinguish between dictionary
and array elements.  The characters following the slash must not be escaped
(whereas in \s-1PDF\s0 source they can be escaped).
.Sp
.Vb 1
\&  $pdf\->get_obj("/Root", "/Pages", "/Kids");
.Ve
.Sp
The first argument may be a dictionary element, in which case the lookup
begins at the trailer dictionary.
.Sp
.Vb 2
\&  $root = $pdf\->get_obj("/Root");
\&  $pdf\->get_obj($root, "/Pages", "/Kids");
.Ve
.Sp
The first argument may also be a parsed object.
.Sp
.Vb 1
\&  $pdf\->get_obj($root);
.Ve
.Sp
If you pass just a single parsed object, it will be returned, unless it is
actually an indirect reference, in which case the object will be looked up
and returned.
.Sp
vivify_obj
.Sp
.Vb 1
\&  $pdf\->vivify_obj($type, ...)
.Ve
.Sp
The first argument must be one of the types listed in \*(L"\s-1GUTS\*(R"\s0.  The
remaining arguments are those accepted by \f(CW\*(C`get_obj\*(C'\fR.  An object of the
specified type will be vivified, along with all the intervening objects
(whose type, array or dictionary, is determined by whether the element
begins with a slash).  None of the vivified objects will be indirect
objects.
.Sp
Any object returned by \f(CW\*(C`vivify_obj\*(C'\fR (whether vivified or not) will be
marked as modified, under the assumption that you are going to modify it.
.Sp
get_page
.Sp
.Vb 1
\&  $pdf\->get_page($num)
.Ve
.Sp
Returns the parsed object associated with the page in question.  Pages are
numbered from 0.  Negative numbers count from the end.  \-1 means the last
page.
.Sp
import_obj
.Sp
.Vb 1
\&  $pdf\->import_obj($other_pdf, $object)
.Ve
.Sp
Imports an object, and all other objects it references, from another \s-1PDF\s0
file.  (This entails making sure that each imported object gets renumbered
to a number that the destination \f(CW$pdf\fR is not already using.)  This method
keeps track of which indirect objects have been imported already, so it can
be called multiple times without duplicating the same objects.  (It also
means that subsequent changes to objects in the source \s-1PDF\s0 will go
unnoticed.)
.Sp
\&\f(CW$object\fR may be a string or a parsed object.
.Sp
If \f(CW$object\fR is a string, it must be an object id (\*(L"1 0\*(R").  The return value
will also be an object id.
.Sp
If it is a parsed object, the object itself will not be added to the \f(CW$pdf\fRâ€™s
list of indirect objects, because it is assumed that it will be inserted
directly inside another object.  (Or you can pass the return value to
\&\f(CW\*(C`add_obj\*(C'\fR.)  All objects it references though (by numeric id) will be
imported.  The object itself will be cloned and the new value returned
(with all references to other objects updated).
.Sp
\&\fBWarning\fR: If you try to import pages from another \s-1PDF\s0 document with this,
watch out for the â€˜/Parentâ€™ link from each page to its parent page array.
Youâ€™ll end up pulling in the parent page array, too, bloating your \s-1PDF\s0 with
page data that will not be displayed.
.Sp
This can also be used to renumber all the objects in a \s-1PDF\s0 (excluding
orphans), to avoid bloated cross-reference tables (but this does entail
reading the entire file into memory):
.Sp
.Vb 9
\& my $new_pdf = new PDF\*(AqTiny version => $old_pdf\->version,
\&                            empty   => 1;
\& my $new_trailer = $new_pdf\->trailer\->[1];
\& my $old_trailer = $old_pdf\->trailer\->[1];
\& $new_trailer\->{Root} =
\&     $new_pdf\->import_obj($old_pdf, $old_trailer\->{Root});
\& $new_trailer\->{Info} =
\&     $new_pdf\->import_obj($old_pdf, $old_trailer\->{Info})
\&  if $old_trailer\->{Info};
.Ve
.Sp
add_obj
.Sp
.Vb 1
\&  $pdf\->add_obj($parsed_obj);
.Ve
.Sp
Adds a new indirect object to the \s-1PDF\s0 and returns the id that got used.
.Sp
decode_stream
.Sp
.Vb 3
\&  $pdf\->decode_stream($parsed_obj)
\&  $pdf\->decode_stream("10 0")
\&  $pdf\->decode_stream(qw< /Root /Pages /Kids 0 /Content >)
.Ve
.Sp
Decodes a stream and returns it.  Currently the only filter supported is
FlateDecode and the only predictor function supported is \s-1PNG.\s0
.Sp
This is an lvalue function, so you can call it like this to avoid copying
the stream yet again after decoding:
.Sp
.Vb 1
\&  $streamref = \e$self\->decode_stream(...)
.Ve
.Sp
(This also means you can assign to the \f(CW\*(C`decode_stream\*(C'\fR call, which is
pointless.)
.RE
.SS "Functions"
.IX Subsection "Functions"
None of these functions is exported.  Call each one with a \f(CW\*(C`PDF::Tiny::\*(C'\fR
prefix.
.IP "tokenize" 4
.IX Item "tokenize"
(Spelt \f(CW\*(C`tokenise\*(C'\fR on Thursdays.)
.Sp
.Vb 2
\&  PDF::Tiny::tokenize($string)
\&  PDF::Tiny::tokenize($string, $delimiter_re, \e&more)
.Ve
.Sp
A low-level function used to break a piece of \s-1PDF\s0 source into a sequence of
tokens.  Returns a list of strings.  Whitespace is stripped, so if you want
to join it back into a string, use the \f(CW\*(C`join_tokens\*(C'\fR function.
.Sp
The \f(CW$string\fR passed as an argument is consumed.  It must not be read-only.
.Sp
The second argument is a regular expression matching the token to stop on
(e.g., \f(CW\*(C`qr/^endobj\ez/\*(C'\fR).  It only works for plain keywords, not strings,
number, names, or what have you.  The third argument is a function that is
expected to read more into \f(CW$string\fR if the ending delimiter is not found.
These two arguments are used internally when parsing \s-1PDF\s0 files.
.IP "join_tokens" 4
.IX Item "join_tokens"
.Vb 1
\&  PDF::Tiny::join_tokens(@tokens)
.Ve
.Sp
Joins a list of tokens into a string, supplying necessary whitespace.
.IP "parse_string" 4
.IX Item "parse_string"
.Vb 2
\&  PDF::Tiny::parse_string($string)
\&  PDF::Tiny::parse_string($string, $delimiter_re)
.Ve
.Sp
Turns a string of tokens into a parsed object.  If \f(CW$delimiter_re\fR is
supplied, any token than matches it will be the last token processed.  It
only works for plain keywords (e.g., endobj, stream), not strings, number,
names, or what have you.
.IP "parse_tokens" 4
.IX Item "parse_tokens"
.Vb 1
\&  PDF::Tiny::parse_tokens(@tokens)
.Ve
.Sp
Turns a list of tokens into a parsed object.
.IP "serialize" 4
.IX Item "serialize"
(Also \f(CW\*(C`serialise\*(C'\fR.)
.Sp
.Vb 1
\&  PDF::Tiny::serialize($parsed_obj)
.Ve
.Sp
Serializes a parsed object.  If the object is a stream, the stream content
is not serialized (to avoid copying a potentially large stream).  The
serialized output contains everything up to and including the word â€˜streamâ€™
and the line feed that follows.
.IP "make_bool" 4
.IX Item "make_bool"
.Vb 1
\&  PDF::Tiny::make_bool(1) # or 0
.Ve
.Sp
Returns a parsed boolean object.
.IP "make_num" 4
.IX Item "make_num"
.Vb 2
\&  PDF::Tiny::make_num(1)
\&  PDF::Tiny::make_num(1.1)
.Ve
.Sp
Returns a parsed number object.
.IP "make_str" 4
.IX Item "make_str"
.Vb 1
\&  PDF::Tiny::make_str("yuhu")
.Ve
.Sp
Returns a parsed string object.
.IP "make_name" 4
.IX Item "make_name"
.Vb 1
\&  PDF::Tiny::make_name("Catalog")
.Ve
.Sp
Returns a parsed name (identifier) object.  The name must be given without
the initial slash.
.IP "make_array" 4
.IX Item "make_array"
.Vb 1
\&  PDF::Tiny::make_array([...])
.Ve
.Sp
Returns a parsed array object that references the very same array passed to
it.
.IP "make_dict" 4
.IX Item "make_dict"
.Vb 1
\&  PDF::Tiny::make_dict({...})
.Ve
.Sp
Returns a parsed dictionary (hash) object that references the very same
hash passed to it.
.IP "make_stream" 4
.IX Item "make_stream"
.Vb 1
\&  PDF::Tiny::make_stream($dict, $content)
.Ve
.Sp
Returns a parsed stream object.  \f(CW$dict\fR must be a parsed dictionary object.
\&\f(CW$content\fR contains the content of the stream.
.IP "make_null" 4
.IX Item "make_null"
.Vb 1
\&  PDF::Tiny::make_null()
.Ve
.Sp
Returns a parsed null object (the same one every time).
.IP "make_ref" 4
.IX Item "make_ref"
.Vb 1
\&  PDF::Tiny::make_ref("1 0")
.Ve
.Sp
Returns a parsed indirect object reference.
.SH "THE PDF FILE FORMAT"
.IX Header "THE PDF FILE FORMAT"
The body of a \s-1PDF\s0 file consists of a collection of what are called objects,
in no particular order.  Each has a numeric id that consists of two numbers
separated by space.  Here is an example of what they look like:
.PP
.Vb 3
\&  23 0 obj
\&  << /Type /Catalog /Pages 3 0 R >>
\&  endobj
.Ve
.PP
This is object number 23 0.  The \f(CW\*(C`<<\*(C'\fR and \f(CW\*(C`>>\*(C'\fR indicate a
dictionary object (like a hash).  The value of the â€˜Typeâ€™ entry is the name
â€˜Catalogâ€™ (a slash before it indicates a name, or identifier).  The value
of the â€˜Pagesâ€™ entry is a reference to object number 3 0.
.PP
Everything is an object.
.PP
In \s-1PDF\s0 parlance, even something as simple as a number is called an object.
An object embedded directly inside another one (such as the number in
\&\f(CW\*(C`<< /Length 1 >>\*(C'\fR is called a \fIdirect object\fR.  An object with a
numeric \s-1ID\s0 (such as 23 0) is called an \fIindirect object\fR.  An object \s-1ID\s0
followed by the keyword \f(CW\*(C`R\*(C'\fR is called an \fIindirect reference\fR.
.PP
Since the indirect objects can be in any order, there follows a
cross-reference table giving the exact location in the file of each
indirect object.
.PP
After the cross-reference table is the trailer, an example of which is the
following:
.PP
.Vb 7
\&  trailer
\&  << /Size 34 /Root 23 0 R /Info 1 0 R
\&     /ID [ <e2ca9df8c15ea42d17d5d724f61808b1>
\&           <e2ca9df8c15ea42d17d5d724f61808b1> ] >>
\&  startxref
\&  7749
\&  %%EOF
.Ve
.PP
Try opening an existing \s-1PDF\s0 file in a text editor (make sure it is \s-1PDF 1.4\s0
[Acrobat 5] format or earlier).  To see the structure of
a \s-1PDF\s0 file, start with the trailer dictionary.  Metadata are stored in
the â€˜Infoâ€™ entry, which here refers to object 1 0.  For the actual document
structure, you want to look at the â€˜Rootâ€™ entry, which points to the
document root or catalogue.  That is object 23 0, shown above.  If you find
object 3 0 you will see that it is a dictionary containing a â€˜Kidsâ€™ array
of references to page objects, etc.
.PP
Now, the actual content of pages is in a different language from the \s-1PDF\s0
structure, which is described here.  It goes inside a stream object,
referenced by the pages, which is usually compressed with Deflate encoding.
(This module does not handle streams per se, but its low-level functions
will allow you to get to them.)  Even though the language for drawing pages
is not the same as that used for \s-1PDF\s0 structure, it follows the same
tokenization rules, so you can use this moduleâ€™s \f(CW\*(C`tokenize\*(C'\fR function if
you are writing your own stream-processing code.
.SH "GUTS"
.IX Header "GUTS"
Guts of the PDF::Tiny objects.
.PP
Nothing is an object.
.PP
By that I mean that PDF::Tiny does not use Perl objects to represent \s-1PDF\s0
objects.  Rather, it uses array refs.  These are referred to throughout
this documentation as parsed objects.
.PP
A parsed object looks like this:
.PP
.Vb 12
\&  [ $type, $value ]
\&  [ \*(Aqnum\*(Aq, 3 ]       # a number
\&  [ \*(Aqdict\*(Aq, {...} ]  # a PDF dictionary (i.e., hash)
\&  [ \*(Aqstr\*(Aq, \*(Aqfoo\*(Aq ]   # The string \*(Aqfoo\*(Aq
\&  [ \*(Aqarray\*(Aq, [...] ] # An array
\&  [ \*(Aqbool\*(Aq, 1 ]      # A boolean
\&  [ \*(Aqname\*(Aq, "Root" ] # The name (identifier) /Root
\&  [ \*(Aqref\*(Aq, "2 0" ]   # A reference to an indirect object
\&  [ \*(Aqnull\*(Aq ]         # This special value has one element
\&  [ \*(Aqstream\*(Aq, $dict, $content ] # This exception has a parsed dictionary
\&                                # object for element 1 and the stream
\&                                # content for element 2
.Ve
.PP
The values of dictionaries and arrays are also parsed objects.
.PP
The value of an indirect reference (not really an object) consists of two
integers without leading zeroes (except 0 itself) separated by a space.
Even though \f(CW"000\en001 R"\fR is a valid reference in \s-1PDF\s0 syntax, this module
always parses it as \*(L"0 1\*(R", which is important since it is used as a hash
key.
.PP
The various \f(CW\*(C`make_*\*(C'\fR functions can be used to create these.
.PP
There are also two special cases, which are handled transparently like the
other objects (and converted into them if necessary by \f(CW\*(C`get_obj\*(C'\fR):
.PP
.Vb 2
\&  [ \*(Aqflat\*(Aq, \*(Aq.......\*(Aq ]                # A flattened (serialized) object
\&  [ \*(Aqtokens\*(Aq, [$token1, $token2, ...]] # A sequence of tokens
.Ve
.PP
So the following three are equivalent:
.PP
.Vb 3
\&  [ \*(Aqdict\*(Aq, { Type => [ \*(Aqname\*(Aq, \*(AqCatalog\*(Aq ], Pages => [\*(Aqref\*(Aq, \*(Aq2 0\*(Aq] } ]
\&  [ \*(Aqflat\*(Aq, \*(Aq<</Type/Catalog/Pages 2 0 R>>\*(Aq ]
\&  [ \*(Aqtokens\*(Aq, [qw \*(Aq<< /Type /Catalog /Pages 2 0 R >>\*(Aq] ]
.Ve
.PP
(This does not apply to the trailer.  Do not flatten the trailer.)
.PP
Also, streams cannot be stored in flat or tokenized format, but their
dictionaries can:
.PP
.Vb 5
\&  [ \*(Aqstream\*(Aq, [\*(Aqdict\*(Aq, { Length => [\*(Aqnum\*(Aq, 9] }], \*(Aqscream!!!\*(Aq ]
\&  [ \*(Aqstream\*(Aq, [\*(Aqtokens\*(Aq, [\*(Aq<<\*(Aq,\*(Aq/Length\*(Aq,\*(Aq9\*(Aq,\*(Aq>>\*(Aq]], \*(Aqscream!!!\*(Aq ]
\&  [ \*(Aqstream\*(Aq, [\*(Aqflat\*(Aq, \*(Aq<</Length 9>>\*(Aq], \*(Aqscream!!!\*(Aq ]
\&  # Invalid:
\&  [ \*(Aqflat\*(Aq,  "<</Length 9>>stream\enscream!!!" ]
.Ve
.SH "GLOSSARY"
.IX Header "GLOSSARY"
.IP "content stream" 4
.IX Item "content stream"
The contents of \s-1PDF\s0 pages are stored in stream objects called \fIcontent
streams\fR.  (PDF::Tiny only deals with the structure of \s-1PDF\s0 files, not the
contents of pages, though it will decode a content stream upon request.)
.IP "cross-reference stream" 4
.IX Item "cross-reference stream"
A cross-reference table stored in a compact format specific to Acrobat 6.0
(\s-1PDF 1.5\s0) and later.  PDF::Reuse, \s-1CAM::PDF\s0, \s-1PDF::API2\s0 and
PDF::Tiny can read, but not write them.
.IP "cross-reference table" 4
.IX Item "cross-reference table"
A table of offsets within a \s-1PDF\s0 file that indicate where indirect objects
are to be found.
.IP "direct object" 4
.IX Item "direct object"
A \s-1PDF\s0 object embedded directly inside another \s-1PDF\s0 object.
.IP "incremental update" 4
.IX Item "incremental update"
The process of appending changes to the end of a file, instead of rewriting
the file from scratch.
.IP "indirect object" 4
.IX Item "indirect object"
A \s-1PDF\s0 object with an \s-1ID,\s0 that gets referenced by its \s-1ID.\s0
.IP "indirect reference" 4
.IX Item "indirect reference"
A parsed object containing an object \s-1ID,\s0 representing a \s-1PDF\s0 sequence such
as \*(L"1 0 R\*(R".
.IP "object \s-1ID\s0" 4
.IX Item "object ID"
Two numbers separate by a space; e.g. \*(L"1 0\*(R".  While \s-1PDF\s0 syntax allows
initial zeroes and any whitespace, PDF::Tiny does not internally.  All
functions expecting an object \s-1ID\s0 require exactly one space and no leading
zeroes (except for 0 itself).
.IP "object stream" 4
.IX Item "object stream"
A compact way of storing objects, specific to Acrobat 6.0 (\s-1PDF 1.5\s0) and
later.
.IP "parsed object" 4
.IX Item "parsed object"
This term is used throughout this documentation to refer to the array-ref
form that all \s-1PDF\s0 objects take when parsed by this module.  It is used even
if the object was created from scratch, and not the result of parsing.
.IP "ram hog" 4
.IX Item "ram hog"
A mythical creature with the horns of a sheep and the snout of a swine.
This term is also used to refer to memorivorous software.  This module aims
not to be such.  Of course if you access every object in a huge \s-1PDF,\s0 you
can defeat that aim.
.IP "text string" 4
.IX Item "text string"
\&\s-1PDF\s0 strings that are \fInot\fR part of content streams (e.g., metadata such as
the title and author) are called \fItext strings\fR as long as they represent
text.  Which strings represent text depends on the context in the \s-1PDF\s0 file
(a bit like Perl scalars).
.SH "OTHER PDF MODULES"
.IX Header "OTHER PDF MODULES"
Why yet another \s-1PDF\s0 module, considering how many there are?  Most of the
other solutions were insufficiently lightweight for my needs.  (In
particular, I needed to write a web service that would serve a single page
at a time from a collection of PDFs, some of which are 200MB.  I needed it
to be very responsive.)
.PP
\&\s-1PDF::API2\s0 (probably the best \s-1PDF\s0 module), \s-1CAM::PDF\s0,
and PDF::Extract all read the entire file into memory.
.PP
Text::PDF is quite fast compared with the others, but I could not figure
out how to use it, except to get a page count.
.PP
PDF::Reuse is fast, but it has trouble with some \s-1PDF\s0 files, and it
provides no page count feature (something I needed).
.PP
PDF::Xtract I did not find out about until after writing this module.
It is a fork of PDF::Extract.
.PP
That said, there is no reason why you could not use PDF::Tiny in conjunction with
other modules.  \s-1CAM::PDF,\s0 for example, can generate PDFs from scratch
fairly efficiently, but is slow at extracting pages from large PDFs.  You
could use it to
generate a \s-1PDF,\s0 and then use PDF::Tiny to add pages afterwards from some
other \s-1PDF.\s0  (Or extract pages with PDF::Tiny to a small \s-1PDF,\s0 and then
import them with \s-1CAM::PDF.\s0)
.SS "Compatibility"
.IX Subsection "Compatibility"
Unfortunately, many of the modules mentioned above do not fully understand
\&\s-1PDF\s0 syntax, or interpret the spec too strictly, such that they are unable
to read certain PDFs.  I have a large scanned book in the form of a \s-1PDF\s0
produced by \s-1ABBYY\s0 FineReader.  I tried rewriting it with
\&\f(CW\*(C`PDF::Tiny\->new($old)\->print(filename => $new)\*(C'\fR, and then I tested
both PDFs with the above modules.  The results (with an Acrobat 6 column as
a bonus):
.PP
.Vb 12
\&                                 PDF producer
\&  PDF reader        | FineReader | PDF::Tiny | Acrobat 6+
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-
\&  CAM::PDF 1.60     | no         | yes       | yes
\&  PDF::API2 2.032   | yes        | yes       | yes
\&  PDF::Tiny 0.05    | yes        | yes       | yes
\&  Text::PDF 0.31    | no         | no        | no
\&  PDF::Reuse 0.39   | yes*       | no        | yes
\&  PDF::Extract 3.04 | yes        | no        | no
\&  PDF::Xtract 0.08  | yes        | no        | no
\&  Adobe Acrobat     | yes        | yes       | yes
\&  Apple Preview     | yes        | yes       | yes
\&
\&  * It has trouble with the cross\-reference table, such that it may or
\&    may not be able to extract the information you want.  It happened
\&    to work for my purposes, but was slow and produced a bloated file.
\&    (The bug is fixed in the git repository and may be gone by the
\&    time you read this.)
.Ve
.PP
Part of the reason for the large number of noes in the middle column is
that PDF::Tiny tries to
get the files as
compact as possible as fast as is possible with a reasonably small amount
of code.  To avoid reaching the \s-1PDF\s0 line length limit (which means entering
a more complex and slower code path), it emits line breaks between tokens
wherever whitespace is mandatory.  It is probably the only \s-1PDF\s0 producer
that does that.
.PP
I have filed bug reports against all the modules that have a no in either
column.  I hope I do not have to slow down PDF::Tiny to work with these
other modules.
.PP
(If this proves to be a problem for anyone, let me know, and I can change
the way it outputs whitespace.)
.SS "Benchmarks"
.IX Subsection "Benchmarks"
Okay, so I took the \s-1PDF\s0 mentioned above (169.5 \s-1MB\s0 in size, containing 253
scanned pages) and benchmarked (1) fetching a page count and (2) extracting
a single page, which are the two tasks for which I am using PDF::Tiny.  The
benchmark code (which uses Dumbbench) can be found in the \fIbenchmark\fR
file in the distribution.  The results (on a 2.8 GHz Intel Core 2 Duo):
.PP
.Vb 8
\&                      Page count | Page extraction | Resulting file size
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  PDF::Tiny 0.07    | 0.010197 s |   0.08735 s     | 952   KB
\&  CAM::PDF 1.60     | 0.6923   s |   1.1849  s     | 995   KB
\&  PDF::API2 2.033   | 1.7974   s |   2.1135  s     | 953   KB
\&  PDF::Xtract 0.08  | 3.7902   s |   3.7805  s     | 992   KB
\&  PDF::Reuse 0.39   | N/A        |  15.36    s     | 169.5 MB
\&  PDF::Extract 3.04 | N/A        | 158.54    s     | 954   KB
.Ve
.PP
Some explanation of the numbers:  \s-1CAM::PDF\s0 and PDF::Xtract do not renumber
objects, so they end up with a bloated 40K cross-reference table.
PDF::Reuse drags in the
entire contents of the source \s-1PDF\s0 but only includes one of its pages in the
page tree.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
perl 5.10 or higher and core modules.
.PP
This modules tries to be true to its Tininess by not loading any other
modules unless absolutely necessary.  When loaded it loads warnings.
.PP
The \f(CW\*(C`import_obj\*(C'\fR method loads Hash::Util::FieldHash.  And
\&\f(CW\*(C`import_page\*(C'\fR calls \f(CW\*(C`import_obj\*(C'\fR.
.PP
The \f(CW\*(C`decode_stream\*(C'\fR method loads Compress::Zlib if the stream is
compressed.  The constructor calls \f(CW\*(C`decode_stream\*(C'\fR if the \s-1PDF\s0 has
cross-reference streams (\s-1PDF 1\s0.5/Acrobat 6).
.SH "BUGS"
.IX Header "BUGS"
Probably lots.  Most of the limitations could be considered bugs.  Most of
the limitations could also be considered features, because they make the
module Tiny.
.PP
This module is badly in need of tests.  (Or it needs to be tested badly.)
No doubt more tests will uncover bugs.
.PP
Please send bug reports to
bug\-PDF\-Tiny@rt.cpan.org <mailto:bug-PDF-Tiny@rt.cpan.org>.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Pali for his contributions.
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
Copyright (C) 2017 Father Chrysostomos <sprout [at] cpan
[dot] org>
.PP
This program is free software; you may redistribute it, modify it or both
under the same terms as perl.  The full text of the license can be found
in the \s-1LICENSE\s0 file included with this module.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 210:" 4
.IX Item "Around line 210:"
You can't have =items (as at line 228) unless the first thing after the =over is an =item
