.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::EX::Module 3"
.TH Getopt::EX::Module 3 "2020-10-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Getopt::EX::Module \- RC/Module data container
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Getopt::EX::Module;
\&
\&  my $bucket = Getopt::EX::Module\->new(
\&        BASECLASS => $baseclass,
\&        FILE => $file_name  /  MODULE => $module_name,
\&        );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is usually used from Getopt::EX::Loader, and keeps
all data about loaded rc file or module.
.PP
After user defined module was loaded, subroutine \f(CW\*(C`initialize\*(C'\fR is
called if it exists in the module.  At this time, container object is
passed to the function as the first argument and following command
argument pointer as the second.  So you can use it to directly touch
the object contents through class interface.
.PP
Following \f(CW\*(C`initialize\*(C'\fR, function defined with module option is called.
.PP
Finally subroutine \f(CW\*(C`finalize\*(C'\fR is called if defined, to finalize start
up process of the module.
.SH "RC FILE FORMAT"
.IX Header "RC FILE FORMAT"
.IP "\fBoption\fR \fIname\fR \fIstring\fR" 7
.IX Item "option name string"
Define option \fIname\fR.  Argument \fIstring\fR is processed by
\&\fIshellwords\fR routine defined in Text::ParseWords module.  Be sure
that this module sometimes requires escape backslashes.
.Sp
Any kind of string can be used for option name but it is not combined
with other options.
.Sp
.Vb 2
\&    option \-\-fromcode \-\-outside=\*(Aq(?s)\e/\e*.*?\e*\e/\*(Aq
\&    option \-\-fromcomment \-\-inside=\*(Aq(?s)\e/\e*.*?\e*\e/\*(Aq
.Ve
.Sp
If the option named \fBdefault\fR is defined, it will be used as a
default option.
.Sp
For the purpose to include following arguments within replaced
strings, two special notations can be used in option definition.
.Sp
String \f(CW\*(C`$<n>\*(C'\fR is replaced by the \fIn\fRth argument after the
substituted option, where \fIn\fR is number start from one.  Because \f(CW\*(C`$<0>\*(C'\fR is replaced by the defined option itself, you have to care
about infinite loop.
.Sp
String \f(CW\*(C`$<shift>\*(C'\fR is replaced by following command line argument
and the argument is removed from list.
.Sp
For example, when
.Sp
.Vb 1
\&    option \-\-line \-\-le &line=$<shift>
.Ve
.Sp
is defined, command
.Sp
.Vb 1
\&    greple \-\-line 10,20\-30,40
.Ve
.Sp
will be evaluated as this:
.Sp
.Vb 1
\&    greple \-\-le &line=10,20\-30,40
.Ve
.Sp
There are special arguments to manipulate option behavior and the rest
of arguments.  Argument \f(CW\*(C`$<move>\*(C'\fR moves all following arguments
there, \f(CW\*(C`$<remove>\*(C'\fR just removes them, and \f(CW\*(C`$<copy>\*(C'\fR copies
them.  These does not work when included as a part of string.
.Sp
They take optional one or two parameters, those are passed to Perl
\&\f(CW\*(C`splice\*(C'\fR function as \fIoffset\fR and \fIlength\fR.  \f(CW\*(C`$<move(0,1)>\*(C'\fR is
same as \f(CW\*(C`$<shift>\*(C'\fR; \f(CW\*(C`$<copy(0,1)>\*(C'\fR is same as \f(CW\*(C`$<1>\*(C'\fR;
\&\f(CW\*(C`$<move>\*(C'\fR is same as \f(CW\*(C`$<move(0)>\*(C'\fR; \f(CW\*(C`$<move(\-1)>\*(C'\fR moves
the last argument; \f(CW\*(C`$move(1,1)\*(C'\fR moves second argument.  Next
example exchange following two arguments.
.Sp
.Vb 1
\&    option \-\-exch $<move(1,1)>
.Ve
.Sp
You can use recently introduced \f(CW\*(C`$<ignore>\*(C'\fR to ignore the
argument.  Because \f(CW\*(C`$<move(0,0)>\*(C'\fR does nothing, it effectively
equivalent and existing module sometimes use it.
.Sp
.Vb 2
\&    option \-\-deprecated $<ignore>
\&    option \-\-deprecated $<move(0,0)>
.Ve
.IP "\fBexpand\fR \fIname\fR \fIstring\fR" 7
.IX Item "expand name string"
Define local option \fIname\fR.  Command \fBexpand\fR is almost same as
command \fBoption\fR in terms of its function.  However, option defined
by this command is expanded in, and only in, the process of
definition, while option definition is expanded when command arguments
are processed.
.Sp
This is similar to string macro defined by following \fBdefine\fR
command.  But macro expantion is done by simple string replacement, so
you have to use \fBexpand\fR to define option composed by multiple
arguments.
.IP "\fBdefine\fR \fIname\fR \fIstring\fR" 7
.IX Item "define name string"
Define string macro.  This is similar to \fBoption\fR, but argument is
not processed by \fIshellwords\fR and treated just a simple text, so
meta-characters can be included without escape.  Macro expansion is
done for option definition and other macro definition.  Macro is not
evaluated in command line option.  Use option directive if you want to
use in command line,
.Sp
.Vb 3
\&    define (#kana) \ep{InKatakana}
\&    option \-\-kanalist \-\-nocolor \-o \-\-join \-\-re \*(Aq(#kana)+(\en(#kana)+)*\*(Aq
\&    help   \-\-kanalist List up Katakana string
.Ve
.Sp
Here-document can be used to define string inluding newlines.
.Sp
.Vb 5
\&    define _\|_script_\|_ <<EOS
\&    {
\&        ...
\&    }  
\&    EOS
.Ve
.Sp
Special macro \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR is pre-defined to module name.
.IP "\fBhelp\fR \fIname\fR" 7
.IX Item "help name"
Define help message for option \fIname\fR.
.IP "\fBbuiltin\fR \fIspec\fR \fIvariable\fR" 7
.IX Item "builtin spec variable"
Define built-in option which should be processed by option parser.
Defined option spec can be taken by \fBbuiltin\fR method, and script is
responsible to give them to parser.
.Sp
Arguments are assumed to be Getopt::Long style spec, and
\&\fIvariable\fR is string start with \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR.  They will be
replaced by a reference to the object which the string represent.
.IP "\fBautoload\fR \fImodule\fR \fIoptions\fR" 7
.IX Item "autoload module options"
Define module which should be loaded automatically when specified
option is found in the command arguments.
.Sp
For example,
.Sp
.Vb 1
\&    autoload \-Mdig \-\-dig
.Ve
.Sp
replaces option "\fI\-\-dig\fR\*(L" to \*(R"\fI\-Mdig \-\-dig\fR", and \fIdig\fR module is
loaded before processing \fI\-\-dig\fR option.
.IP "\fBmode\fR [\fIno\fR]\fIname\fR" 7
.IX Item "mode [no]name"
Set or unset mode \fIname\fR.  Currently, \fBfunciton\fR and \fBwildcard\fR can
be used as a name.  See \s-1METHODS\s0 section.
.Sp
Next is an example used in App::Greple::subst::dyncmap module to
produce parameters on the fly.
.Sp
.Vb 2
\&    mode function
\&    option \-\-dyncmap &dyncmap($<shift>)
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR \fIconfigure option\fR" 4
.IX Item "new configure option"
Create object.  Parameters are just passed to \f(CW\*(C`configure\*(C'\fR method.
.IP "\fBconfigure\fR" 4
.IX Item "configure"
Configure object.  Parameter is passed in hash name and value style.
.RS 4
.IP "\fB\s-1BASECLASS\s0\fR => \fIclass\fR" 4
.IX Item "BASECLASS => class"
Set base class.
.IP "\fB\s-1FILE\s0\fR => \fIfilename\fR" 4
.IX Item "FILE => filename"
Load file.
.IP "\fB\s-1MODULE\s0\fR => \fImodulename\fR" 4
.IX Item "MODULE => modulename"
Load module.
.RE
.RS 4
.RE
.IP "\fBdefine\fR \fIname\fR, \fImacro\fR" 4
.IX Item "define name, macro"
Define macro.
.IP "\fBsetopt\fR \fIname\fR, \fIoption\fR" 4
.IX Item "setopt name, option"
Set option.
.IP "\fBsetlocal\fR \fIname\fR, \fIoption\fR" 4
.IX Item "setlocal name, option"
Set option which is effective only in the module.
.IP "\fBgetopt\fR \fIname\fR" 4
.IX Item "getopt name"
Get option.  Takes option name and return it's definition if
available.  It doesn't return \fIdefault\fR option, get it by \fIdefault\fR
method.
.IP "\fBdefault\fR" 4
.IX Item "default"
Get default option.  Use \f(CW\*(C`setopt(default => ...)\*(C'\fR to set.
.IP "\fBbuiltin\fR" 4
.IX Item "builtin"
Get built-in options.
.IP "\fBautoload\fR" 4
.IX Item "autoload"
Set autoload module.
.IP "\fBmode\fR" 4
.IX Item "mode"
Set argument treatment mode.  Arguments produced by option expansion
will be the subject of post-process.  This method define the behavior
of it.
.RS 4
.IP "\fBmode\fR(\fBfunction\fR => 1)" 4
.IX Item "mode(function => 1)"
Interpret the argument start with '&' as a function, and replace it by
the result of the function call.
.IP "\fBmode\fR(\fBwildcard\fR => 1)" 4
.IX Item "mode(wildcard => 1)"
Replace wildcard argument by matched file names.
.RE
.RS 4
.RE
