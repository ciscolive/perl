.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Selenium::Remote::Driver 3"
.TH Test::Selenium::Remote::Driver 3 "2020-10-19" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Selenium::Remote::Driver
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A subclass of Selenium::Remote::Driver.  which provides useful testing
functions.
.PP
This is an \fIexperimental\fR addition to the Selenium::Remote::Driver
distribution, and some interfaces may change.
.SH "Methods"
.IX Header "Methods"
.ie n .SS "new ( %opts )"
.el .SS "new ( \f(CW%opts\fP )"
.IX Subsection "new ( %opts )"
This will create a new Test::Selenium::Remote::Driver object, which subclasses
Selenium::Remote::Driver.  This subclass provides useful testing
functions.  It is modeled on Test::WWW::Selenium.
.PP
Environment vars can be used to specify options to pass to
Selenium::Remote::Driver. \s-1ENV\s0 vars are prefixed with \f(CW\*(C`TWD_\*(C'\fR.
( After the old fork name, \*(L"Test::WebDriver\*(R" )
.PP
Set the Selenium server address with \f(CW$TWD_HOST\fR and \f(CW$TWD_PORT\fR.
.PP
Pick which browser is used using the  \f(CW$TWD_BROWSER\fR, \f(CW$TWD_VERSION\fR,
\&\f(CW$TWD_PLATFORM\fR, \f(CW$TWD_JAVASCRIPT\fR, \f(CW$TWD_EXTRA_CAPABILITIES\fR.
.PP
See Selenium::Remote::Driver for the meanings of these options.
.SS "verbose"
.IX Subsection "verbose"
Enable/disable debugging output, or view the status of verbosity.
.ie n .SS "server_is_running( $host, $port )"
.el .SS "server_is_running( \f(CW$host\fP, \f(CW$port\fP )"
.IX Subsection "server_is_running( $host, $port )"
Returns true if a Selenium server is running.  The host and port
parameters are optional, and default to \f(CW\*(C`localhost:4444\*(C'\fR.
.PP
Environment vars \f(CW\*(C`TWD_HOST\*(C'\fR and \f(CW\*(C`TWD_PORT\*(C'\fR can also be used to
determine the server to check.
.SS "error_handler"
.IX Subsection "error_handler"
As for Selenium::Remote::Driver, this class also supports adding an
optional \f(CW\*(C`error_handler\*(C'\fR attribute during instantiation :
.PP
.Vb 3
\&    my $test_driver = Test::Selenium::Remote::Driver\->new(
\&        error_handler => sub { print $_[1]; croak \*(Aqgoodbye\*(Aq; }
\&    );
.Ve
.PP
Additionally, you can set and/or clear it at any time on an
already-instantiated driver:
.PP
.Vb 2
\&    # later, change the error handler to something else
\&    $driver\->error_handler( sub { print $_[1]; croak \*(Aqhello\*(Aq; } );
\&
\&    # stop handling errors manually and use the default S:R:D behavior
\&    # (we will croak about the exception)
\&    $driver\->clear_error_handler;
.Ve
.PP
Your error handler will receive two arguments,
The first argument is the \f(CW$driver\fR object itself.
Due to some specificities of this class, the second argument passed to the
handler can be:
.IP "the error message from the Webdriver" 4
.IX Item "the error message from the Webdriver"
This is the case when the error message is raised by a WebDriver failure
.ie n .IP """Failed to find ...""" 4
.el .IP "``Failed to find ...''" 4
.IX Item "Failed to find ..."
This message is raised when the Webdriver call is successful but the failure
occurs on the test performed aftwerwards. This is the case for functions like
\&\f(CW\*(C`body_text_like\*(C'\fR, \f(CW\*(C`body_text_unlike\*(C'\fR, \f(CW\*(C`body_text_contains\*(C'\fR, \f(CW\*(C`body_text_lacks\*(C'\fR,
\&\f(CW\*(C`content_like\*(C'\fR, \f(CW\*(C`content_unlike\*(C'\fR, \f(CW\*(C`content_contains\*(C'\fR, \f(CW\*(C`content_lacks\*(C'\fR.
.PP
If you set your own handler, you should not rely that much on the message returned.
You should also remember that you are entirely responsible for handling exceptions,
which means that should the error handler be called, it means that the test you are
doing has failed, so you should croak.
.PP
You should also call \fBfail()\fR in your handler, in case the function called raised a
webdriver error, because, as exceptions are not caught anymore when you specify a
handler, the function will not fail anymore, which translates to a 'ok' in your \s-1TAP\s0
output if you do not handle it properly.
.SH "Testing Methods"
.IX Header "Testing Methods"
The following testing methods are available. For
more documentation, see the related test methods in Selenium::Remote::Driver
(And feel free to submit a patch to flesh out the documentation for these here).
Defaults for optional arguments \fBshould\fR be the same as for their analogues in
Selenium::Remote::Driver and Selenium::Remote::WebElement.
.PP
.Vb 4
\&    alert_text_is
\&    alert_text_isnt
\&    alert_text_like
\&    alert_text_unlike
\&
\&    current_window_handle_is
\&    current_window_handle_isnt
\&    current_window_handle_like
\&    current_window_handle_unlike
\&
\&    window_handles_is
\&    window_handles_isnt
\&    window_handles_like
\&    window_handles_unlike
\&
\&    window_size_is
\&    window_size_isnt
\&    window_size_like
\&    window_size_unlike
\&
\&    window_position_is
\&    window_position_isnt
\&    window_position_like
\&    window_position_unlike
\&
\&    current_url_is
\&    current_url_isnt
\&    current_url_like
\&    current_url_unlike
\&
\&    title_is
\&    title_isnt
\&    title_like
\&    title_unlike
\&
\&
\&    active_element_is
\&    active_element_isnt
\&    active_element_like
\&    active_element_unlike
\&
\&    # Basically the same as \*(Aqcontent_like()\*(Aq, but content_like() supports multiple regex\*(Aqs.
\&    page_source_is
\&    page_source_isnt
\&    page_source_like
\&    page_source_unlike
\&
\&    send_keys_to_active_element_ok
\&    send_keys_to_alert_ok
\&    send_keys_to_prompt_ok
\&    send_modifier_ok
\&
\&    accept_alert_ok
\&    dismiss_alert_ok
\&
\&    move_mouse_to_location_ok # TODO
\&    move_to_ok # TODO
\&
\&    get_ok
\&    go_back_ok
\&    go_forward_ok
\&    add_cookie_ok
\&    get_page_source_ok
\&
\&    find_element_ok($search_target)
\&    find_element_ok($search_target)
\&
\&    find_elements_ok
\&    find_child_element_ok
\&    find_child_elements_ok
\&
\&    compare_elements_ok
\&
\&    click_ok
\&    double_click_ok
.Ve
.ie n .SS "$twd\->type_element_ok($search_target [,$locator], $keys, [, $desc ]);"
.el .SS "\f(CW$twd\fP\->type_element_ok($search_target [,$locator], \f(CW$keys\fP, [, \f(CW$desc\fP ]);"
.IX Subsection "$twd->type_element_ok($search_target [,$locator], $keys, [, $desc ]);"
.Vb 1
\&   $twd\->type_element_ok( $search_target [,$locator], $keys [, $desc ] );
.Ve
.PP
Use \*(L"find_element\*(R" in Selenium::Remote::Driver to resolve the \f(CW$search_target\fR
to a web element and an optional locator, and then type \f(CW$keys\fR into it, providing an optional test
label.
.ie n .SS "$twd\->element_text_is($search_target[,$finder],$expected_text [,$desc]);"
.el .SS "\f(CW$twd\fP\->element_text_is($search_target[,$finder],$expected_text [,$desc]);"
.IX Subsection "$twd->element_text_is($search_target[,$finder],$expected_text [,$desc]);"
.Vb 1
\&    $twd\->element_text_is($search_target[,$finder],$expected_text [,$desc]);
.Ve
.ie n .SS "$twd\->element_value_is($search_target[,$finder],$expected_value [,$desc]);"
.el .SS "\f(CW$twd\fP\->element_value_is($search_target[,$finder],$expected_value [,$desc]);"
.IX Subsection "$twd->element_value_is($search_target[,$finder],$expected_value [,$desc]);"
.Vb 1
\&    $twd\->element_value_is($search_target[,$finder],$expected_value [,$desc]);
.Ve
.ie n .SS "$twd\->click_element_ok($search_target [,$finder ,$desc]);"
.el .SS "\f(CW$twd\fP\->click_element_ok($search_target [,$finder ,$desc]);"
.IX Subsection "$twd->click_element_ok($search_target [,$finder ,$desc]);"
.Vb 1
\&    $twd\->click_element_ok($search_target [,$finder ,$desc]);
.Ve
.PP
Find an element and then click on it.
.ie n .SS "$twd\->clear_element_ok($search_target [,$finder ,$desc]);"
.el .SS "\f(CW$twd\fP\->clear_element_ok($search_target [,$finder ,$desc]);"
.IX Subsection "$twd->clear_element_ok($search_target [,$finder ,$desc]);"
.Vb 1
\&    $twd\->clear_element_ok($search_target [,$finder ,$desc]);
.Ve
.PP
Find an element and then clear on it.
.ie n .SS "$twd\->is_element_displayed_ok($search_target [,$finder ,$desc]);"
.el .SS "\f(CW$twd\fP\->is_element_displayed_ok($search_target [,$finder ,$desc]);"
.IX Subsection "$twd->is_element_displayed_ok($search_target [,$finder ,$desc]);"
.Vb 1
\&    $twd\->is_element_displayed_ok($search_target [,$finder ,$desc]);
.Ve
.PP
Find an element and check to confirm that it is displayed. (visible)
.ie n .SS "$twd\->is_element_enabled_ok($search_target [,$finder ,$desc]);"
.el .SS "\f(CW$twd\fP\->is_element_enabled_ok($search_target [,$finder ,$desc]);"
.IX Subsection "$twd->is_element_enabled_ok($search_target [,$finder ,$desc]);"
.Vb 1
\&    $twd\->is_element_enabled_ok($search_target [,$finder ,$desc]);
.Ve
.PP
Find an element and check to confirm that it is enabled.
.ie n .SS "$twd\->find_element_ok($search_target [,$finder, $desc ]);"
.el .SS "\f(CW$twd\fP\->find_element_ok($search_target [,$finder, \f(CW$desc\fP ]);"
.IX Subsection "$twd->find_element_ok($search_target [,$finder, $desc ]);"
.Vb 1
\&   $twd\->find_element_ok( $search_target [,$finder, $desc ] );
.Ve
.PP
Returns true if \f(CW$search_target\fR is successfully found on the page. \f(CW$search_target\fR
is passed to \*(L"find_element\*(R" in Selenium::Remote::Driver using a finder or the \f(CW\*(C`default_finder\*(C'\fR
if none passed.
See there for more details on the format for \f(CW\*(C`find_element_ok()\*(C'\fR.
.ie n .SS "$twd\->find_no_element_ok($search_target [,$finder, $desc ]);"
.el .SS "\f(CW$twd\fP\->find_no_element_ok($search_target [,$finder, \f(CW$desc\fP ]);"
.IX Subsection "$twd->find_no_element_ok($search_target [,$finder, $desc ]);"
.Vb 1
\&   $twd\->find_no_element_ok( $search_target [,$finder, $desc ] );
.Ve
.PP
Returns true if \f(CW$search_target\fR is \fInot\fR found on the page. \f(CW$search_target\fR
is passed to \*(L"find_element\*(R" in Selenium::Remote::Driver using a finder or the
\&\f(CW\*(C`default_finder\*(C'\fR if none passed. See there for more details on the format for \f(CW\*(C`find_no_element_ok()\*(C'\fR.
.ie n .SS "$twd\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$twd\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->content_like( $regex [, $desc ] )"
.Vb 2
\&   $twd\->content_like( $regex [, $desc ] )
\&   $twd\->content_like( [$regex_1, $regex_2] [, $desc ] )
.Ve
.PP
Tells if the content of the page matches \fI\f(CI$regex\fI\fR. If an arrayref of regex's
are provided, one 'test' is run for each regex against the content of the
current page.
.PP
A default description of 'Content is like \*(L"$regex\*(R"' will be provided if there
is no description.
.ie n .SS "$twd\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$twd\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->content_unlike( $regex [, $desc ] )"
.Vb 2
\&   $twd\->content_unlike( $regex [, $desc ] )
\&   $twd\->content_unlike( [$regex_1, $regex_2] [, $desc ] )
.Ve
.PP
Tells if the content of the page does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR. If an arrayref of regex's
are provided, one 'test' is run for each regex against the content of the
current page.
.PP
A default description of 'Content is unlike \*(L"$regex\*(R"' will be provided if there
is no description.
.ie n .SS "$twd\->body_text_like( $regex [, $desc ] )"
.el .SS "\f(CW$twd\fP\->body_text_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->body_text_like( $regex [, $desc ] )"
.Vb 2
\&   $twd\->body_text_like( $regex [, $desc ] )
\&   $twd\->body_text_like( [$regex_1, $regex_2] [, $desc ] )
.Ve
.PP
Tells if the text of the page (as returned by \f(CW\*(C`get_body()\*(C'\fR)  matches
\&\fI\f(CI$regex\fI\fR. If an arrayref of regex's are provided, one 'test' is run for each
regex against the content of the current page.
.PP
A default description of 'Content is like \*(L"$regex\*(R"' will be provided if there
is no description.
.PP
To also match the \s-1HTML\s0 see, \f(CW\*(C`content_unlike()\*(C'\fR.
.ie n .SS "$twd\->body_text_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$twd\fP\->body_text_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->body_text_unlike( $regex [, $desc ] )"
.Vb 2
\&   $twd\->body_text_unlike( $regex [, $desc ] )
\&   $twd\->body_text_unlike( [$regex_1, $regex_2] [, $desc ] )
.Ve
.PP
Tells if the text of the page (as returned by \f(CW\*(C`get_body()\*(C'\fR)
 does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR. If an arrayref of regex's
are provided, one 'test' is run for each regex against the content of the
current page.
.PP
A default description of 'Text is unlike \*(L"$regex\*(R"' will be provided if there
is no description.
.PP
To also match the \s-1HTML\s0 see, \f(CW\*(C`content_unlike()\*(C'\fR.
.ie n .SS "$twd\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$twd\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->content_contains( $str [, $desc ] )"
.Vb 2
\&   $twd\->content_contains( $str [, $desc ] )
\&   $twd\->content_contains( [$str_1, $str_2] [, $desc ] )
.Ve
.PP
Tells if the content of the page contains \fI\f(CI$str\fI\fR. If an arrayref of strngs's
are provided, one 'test' is run for each string against the content of the
current page.
.PP
A default description of 'Content contains \*(L"$str\*(R"' will be provided if there
is no description.
.ie n .SS "$twd\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$twd\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->content_lacks( $str [, $desc ] )"
.Vb 2
\&   $twd\->content_lacks( $str [, $desc ] )
\&   $twd\->content_lacks( [$str_1, $str_2] [, $desc ] )
.Ve
.PP
Tells if the content of the page does \s-1NOT\s0 contain \fI\f(CI$str\fI\fR. If an arrayref of strings
are provided, one 'test' is run for each string against the content of the
current page.
.PP
A default description of 'Content lacks \*(L"$str\*(R"' will be provided if there
is no description.
.ie n .SS "$twd\->body_text_contains( $str [, $desc ] )"
.el .SS "\f(CW$twd\fP\->body_text_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->body_text_contains( $str [, $desc ] )"
.Vb 2
\&   $twd\->body_text_contains( $str [, $desc ] )
\&   $twd\->body_text_contains( [$str_1, $str_2] [, $desc ] )
.Ve
.PP
Tells if the text of the page (as returned by \f(CW\*(C`get_body()\*(C'\fR) contains
\&\fI\f(CI$str\fI\fR. If an arrayref of strings are provided, one 'test' is run for each
regex against the content of the current page.
.PP
A default description of 'Text contains \*(L"$str\*(R"' will be provided if there
is no description.
.PP
To also match the \s-1HTML\s0 see, \f(CW\*(C`content_uncontains()\*(C'\fR.
.ie n .SS "$twd\->body_text_lacks( $str [, $desc ] )"
.el .SS "\f(CW$twd\fP\->body_text_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$twd->body_text_lacks( $str [, $desc ] )"
.Vb 2
\&   $twd\->body_text_lacks( $str [, $desc ] )
\&   $twd\->body_text_lacks( [$str_1, $str_2] [, $desc ] )
.Ve
.PP
Tells if the text of the page (as returned by \f(CW\*(C`get_body()\*(C'\fR)
 does \s-1NOT\s0 contain \fI\f(CI$str\fI\fR. If an arrayref of strings
are provided, one 'test' is run for each regex against the content of the
current page.
.PP
A default description of 'Text lacks \*(L"$str\*(R"' will be provided if there
is no description.
.PP
To also match the \s-1HTML\s0 see, \f(CW\*(C`content_lacks()\*(C'\fR.
.SH "NOTES"
.IX Header "NOTES"
This module was forked from Test::WebDriver 0.01.
.PP
For Best Practice \- I recommend subclassing Test::Selenium::Remote::Driver for your application,
and then refactoring common or app specific methods into MyApp::WebDriver so that
your test files do not have much duplication.  As your app changes, you can update
MyApp::WebDriver rather than all the individual test files.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Created by: Luke Closs <lukec@cpan.org>, but inspired by
 Test::WWW::Selenium and its authors.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Test::WebDriver work was sponsored by Prime Radiant, Inc.
Mark Stosberg <mark@stosberg.com> forked it as Test::Selenium::Remote::Driver
and significantly expanded it.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Parts Copyright (c) 2012 Prime Radiant, Inc.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
