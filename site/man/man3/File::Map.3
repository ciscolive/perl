.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Map 3"
.TH File::Map 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Map \- Memory mapping made simple and safe.
.SH "VERSION"
.IX Header "VERSION"
version 0.67
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use File::Map \*(Aqmap_file\*(Aq;
\& 
\& map_file my $map, $filename, \*(Aq+<\*(Aq;
\& $map =~ s/bar/quz/g;
\& substr $map, 1024, 11, "Hello world";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::Map maps files or anonymous memory into perl variables.
.SS "Advantages of memory mapping"
.IX Subsection "Advantages of memory mapping"
.IP "\(bu" 4
Unlike normal perl variables, mapped memory is (usually) shared between threads or forked processes.
.IP "\(bu" 4
It is an efficient way to slurp an entire file. Unlike for example File::Slurp, this module returns almost immediately, loading the pages lazily on access. This means you only 'pay' for the parts of the file you actually use.
.IP "\(bu" 4
Perl usually doesn't return memory to the system while running, mapped memory can be returned.
.SS "Advantages of this module over other similar modules"
.IX Subsection "Advantages of this module over other similar modules"
.IP "\(bu" 4
Safety and Speed
.Sp
This module is safe yet fast. Alternatives are either fast but can cause segfaults or lose the mapping when not used correctly, or are safe but rather slow. File::Map is as fast as a normal string yet safe.
.IP "\(bu" 4
Simplicity
.Sp
It offers a simple interface targeted at common usage patterns
.RS 4
.IP "\(bu" 4
Files are mapped into a variable that can be read just like any other variable, and it can be written to using standard Perl techniques such as regexps and \f(CW\*(C`substr\*(C'\fR.
.IP "\(bu" 4
Files can be mapped using a set of simple functions. There is no need to know weird constants or the order of 6 arguments.
.IP "\(bu" 4
It will automatically unmap the file when the scalar gets destroyed. This works correctly even in multi-threaded programs.
.RE
.RS 4
.RE
.IP "\(bu" 4
Portability
.Sp
File::Map supports Unix and Windows.
.IP "\(bu" 4
Thread synchronization
.Sp
It has built-in support for thread synchronization.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Mapping"
.IX Subsection "Mapping"
The following functions for mapping a variable are available for exportation. Note that all of these functions throw exceptions on errors, unless noted otherwise.
.PP
\fImap_handle \f(CI$lvalue\fI, \f(CI$filehandle\fI, \f(CI$mode\fI = '<', \f(CI$offset\fI = 0, \f(CI$length\fI = \-s(*handle) \- \f(CI$offset\fI\fR
.IX Subsection "map_handle $lvalue, $filehandle, $mode = '<', $offset = 0, $length = -s(*handle) - $offset"
.PP
Use a filehandle to map into an lvalue. \f(CW$filehandle\fR should be a scalar filehandle. \f(CW$mode\fR uses the same format as \f(CW\*(C`open\*(C'\fR does (it currently accepts \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`+<\*(C'\fR, \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`+>\*(C'\fR). \f(CW$offset\fR and \f(CW$length\fR are byte positions in the file, and default to mapping the whole file.
.PP
\fI* map_file \f(CI$lvalue\fI, \f(CI$filename\fI, \f(CI$mode\fI = '<', \f(CI$offset\fI = 0, \f(CI$length\fI = \-s($filename) \- \f(CI$offset\fI\fR
.IX Subsection "* map_file $lvalue, $filename, $mode = '<', $offset = 0, $length = -s($filename) - $offset"
.PP
Open a file and map it into an lvalue. Other than \f(CW$filename\fR, all arguments work as in map_handle.
.PP
\fI* map_anonymous \f(CI$lvalue\fI, \f(CI$length\fI, \f(CI$type\fI\fR
.IX Subsection "* map_anonymous $lvalue, $length, $type"
.PP
Map an anonymous piece of memory. \f(CW$type\fR can be either \f(CW\*(Aqshared\*(Aq\fR, in which case it will be shared with child processes, or \f(CW\*(Aqprivate\*(Aq\fR, which won't be shared.
.PP
\fI* sys_map \f(CI$lvalue\fI, \f(CI$length\fI, \f(CI$protection\fI, \f(CI$flags\fI, \f(CI$filehandle\fI, \f(CI$offset\fI = 0\fR
.IX Subsection "* sys_map $lvalue, $length, $protection, $flags, $filehandle, $offset = 0"
.PP
Low level map operation. It accepts the same constants as mmap does (except its first argument obviously). If you don't know how mmap works you probably shouldn't be using this.
.PP
\fI* unmap \f(CI$lvalue\fI\fR
.IX Subsection "* unmap $lvalue"
.PP
Unmap a variable. Note that normally this is not necessary as variables are unmapped automatically at destruction, but it is included for completeness.
.PP
\fI* remap \f(CI$lvalue\fI, \f(CI$new_size\fI\fR
.IX Subsection "* remap $lvalue, $new_size"
.PP
Try to remap \f(CW$lvalue\fR to a new size. This call is linux specific and not supported on other systems. For a file backed mapping a file must be long enough to hold the new size, otherwise you can expect bus faults. For an anonymous map it must be private, shared maps can not be remapped. \fBUse with caution\fR.
.SS "Auxiliary"
.IX Subsection "Auxiliary"
\fI* sync \f(CI$lvalue\fI, \f(CI$synchronous\fI = 1\fR
.IX Subsection "* sync $lvalue, $synchronous = 1"
.PP
Flush changes made to the memory map back to disk. Mappings are always flushed when unmapped, so this is usually not necessary. If \f(CW$synchronous\fR is true and your operating system supports it, the flushing will be done synchronously.
.PP
\fI* pin \f(CI$lvalue\fI\fR
.IX Subsection "* pin $lvalue"
.PP
Disable paging for this map, thus locking it in physical memory. Depending on your operating system there may be limits on pinning.
.PP
\fI* unpin \f(CI$lvalue\fI\fR
.IX Subsection "* unpin $lvalue"
.PP
Unlock the map from physical memory.
.PP
\fI* advise \f(CI$lvalue\fI, \f(CI$advice\fI\fR
.IX Subsection "* advise $lvalue, $advice"
.PP
Advise a certain memory usage pattern. This is not implemented on all operating systems, and may be a no-op. The following values for \f(CW$advice\fR are always accepted:.
.IP "\(bu" 2
normal
.Sp
Specifies that the application has no advice to give on its behavior with respect to the mapped variable. It is the default characteristic if no advice is given.
.IP "\(bu" 2
random
.Sp
Specifies that the application expects to access the mapped variable in a random order.
.IP "\(bu" 2
sequential
.Sp
Specifies that the application expects to access the mapped variable sequentially from start to end.
.IP "\(bu" 2
willneed
.Sp
Specifies that the application expects to access the mapped variable in the near future.
.IP "\(bu" 2
dontneed
.Sp
Specifies that the application expects that it will not access the mapped variable in the near future.
.PP
On some systems there may be more values available, but this can not be relied on. Unknown values for \f(CW$advice\fR will cause a warning but are further ignored.
.PP
\fI* protect \f(CI$lvalue\fI, \f(CI$mode\fI\fR
.IX Subsection "* protect $lvalue, $mode"
.PP
Change the memory protection of the mapping. \f(CW$mode\fR takes the same format as \f(CW\*(C`open\*(C'\fR, but also accepts sys_map style constants.
.SS "Locking"
.IX Subsection "Locking"
These locking functions provide locking for threads for the mapped region. The mapped region has an internal lock and condition variable. The condition variable functions(\f(CW\*(C`wait_until\*(C'\fR, \f(CW\*(C`notify\*(C'\fR, \f(CW\*(C`broadcast\*(C'\fR) can only be used inside a locked block. If your perl has been compiled without thread support the condition functions will not be available.
.PP
\fI* lock_map \f(CI$lvalue\fI\fR
.IX Subsection "* lock_map $lvalue"
.PP
Lock \f(CW$lvalue\fR until the end of the scope. If your perl does not support threads, this will be a no-op.
.PP
\fI* wait_until { block } \f(CI$lvalue\fI\fR
.IX Subsection "* wait_until { block } $lvalue"
.PP
Wait for block to become true. After every failed attempt, wait for a signal. It returns the value returned by the block.
.PP
\fI* notify \f(CI$lvalue\fI\fR
.IX Subsection "* notify $lvalue"
.PP
This will signal to one listener that the map is available.
.PP
\fI* broadcast \f(CI$lvalue\fI\fR
.IX Subsection "* broadcast $lvalue"
.PP
This will signal to all listeners that the map is available.
.SS "Constants"
.IX Subsection "Constants"
.IP "\s-1PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC, MAP_ANONYMOUS, MAP_SHARED, MAP_PRIVATE, MAP_ANON, MAP_FILE\s0" 4
.IX Item "PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC, MAP_ANONYMOUS, MAP_SHARED, MAP_PRIVATE, MAP_ANON, MAP_FILE"
These constants are used for sys_map. If you think you need them your mmap manpage will explain them, but in most cases you can skip sys_map altogether.
.SH "EXPORTS"
.IX Header "EXPORTS"
All previously mentioned functions are available for exportation, but none are exported by default. Some functions may not be available on your \s-1OS\s0 or your version of perl as specified above. A number of tags are defined to make importation easier.
.IP "\(bu" 4
:map
.Sp
map_handle, map_file, map_anonymous, sys_map, unmap
.IP "\(bu" 4
:extra
.Sp
remap, sync, pin, unpin, advise, protect
.IP "\(bu" 4
:lock
.Sp
lock_map, wait_until, notify, broadcast
.IP "\(bu" 4
:constants
.Sp
\&\s-1PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC, MAP_ANONYMOUS, MAP_SHARED, MAP_PRIVATE, MAP_ANON, MAP_FILE\s0
.IP "\(bu" 4
:all
.Sp
All functions defined in this module.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.SS "Exceptions"
.IX Subsection "Exceptions"
.IP "\(bu" 4
Could not <function name>: this variable is not memory mapped
.Sp
An attempt was made to \f(CW\*(C`sync\*(C'\fR, \f(CW\*(C`remap\*(C'\fR, \f(CW\*(C`unmap\*(C'\fR, \f(CW\*(C`pin\*(C'\fR, \f(CW\*(C`unpin\*(C'\fR, \f(CW\*(C`advise\*(C'\fR or \f(CW\*(C`lock_map\*(C'\fR an unmapped variable.
.IP "\(bu" 4
Could not <function name>: <system error>
.Sp
Your \s-1OS\s0 didn't allow File::Map to do what you asked it to do for some reason.
.IP "\(bu" 4
Trying to <function_name> on an unlocked map
.Sp
You tried to \f(CW\*(C`wait_until\*(C'\fR, \f(CW\*(C`notify\*(C'\fR or \f(CW\*(C`broadcast\*(C'\fR on an unlocked variable.
.IP "\(bu" 4
Zero length not allowed for anonymous map
.Sp
A zero length anonymous map is not possible (or in any way useful).
.IP "\(bu" 4
Can't remap a shared mapping
.Sp
An attempt was made to remap a mapping that is shared among different threads, this is not possible.
.IP "\(bu" 4
Window (<start>, <end>) is outside the file
.Sp
The offset and/or length you specified were invalid for this file.
.IP "\(bu" 4
Can't map fake filehandle
.Sp
The filehandle you provided is not real. This may mean it's a scalar string handle or a tied handle.
.IP "\(bu" 4
No such flag <flag_name>
.Sp
The flag given for map_anonymous isn't valid, it should either be \f(CW\*(C`shared\*(C'\fR or \f(CW\*(C`private\*(C'\fR.
.SS "Warnings"
.IX Subsection "Warnings"
.IP "\(bu" 4
Writing directly to a memory mapped file is not recommended
.Sp
Due to the way perl works internally, it's not possible to write a mapping implementation that allows direct assignment yet performs well. As a compromise, File::Map is capable of fixing up the mess if you do it nonetheless, but it will warn you that you're doing something you shouldn't. This warning is only given when \f(CW\*(C`use warnings \*(Aqsubstr\*(Aq\*(C'\fR is in effect.
.IP "\(bu" 4
Truncating new value to size of the memory map
.Sp
This warning is additional to the previous one, warning you that you're losing data. This warning is only given when \f(CW\*(C`use warnings \*(Aqsubstr\*(Aq\*(C'\fR is in effect.
.IP "\(bu" 4
Shouldn't mmap non-binary filehandle
.Sp
You tried to to map a filehandle that has some encoding layer. Encoding layers are not supported by File::Map. This warning is only given when \f(CW\*(C`use warnings \*(Aqlayer\*(Aq\*(C'\fR is in effect. Note that this may become an exception in a future version.
.IP "\(bu" 4
Unknown advice '<advice>'
.Sp
You gave advise an advice it didn't know. This is either a typo or a portability issue. This warning is only given when \f(CW\*(C`use warnings \*(Aqportable\*(Aq\*(C'\fR is in effect.
.IP "\(bu" 4
Syncing a readonly map makes no sense
.Sp
\&\f(CW\*(C`sync\*(C'\fR flushes changes to the map to the filesystem. This obviously is of little use when you can't change the map. This warning is only given when \f(CW\*(C`use warnings \*(Aqio\*(Aq\*(C'\fR is in effect.
.IP "\(bu" 4
Can't overwrite an empty map
.Sp
Overwriting an empty map is rather nonsensical, hence a warning is given when this is tried. This warning is only given when \f(CW\*(C`use warnings \*(Aqsubstr\*(Aq\*(C'\fR is in effect.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
This module depends on perl 5.8, Sub::Exporter::Progressive and PerlIO::Layers. Perl 5.8.8 or higher is recommended because older versions can give spurious warnings.
.PP
In perl versions before 5.11.5 many string functions including \f(CW\*(C`substr\*(C'\fR are limited to 32bit logic <http://rt.perl.org/rt3//Public/Bug/Display.html?id=72784>, even on 64bit architectures. Effectively this means you can't use them on strings bigger than 2GB. If you are working with such large files, it is strongly recommended to upgrade to 5.12.
.PP
In perl versions before 5.17.5, there is an off-by-one bug in Perl's regexp engine, as explained here <http://rt.perl.org/rt3//Public/Bug/Display.html?id=73542>. If the length of the file is an exact multiple of the page size, some regexps can trigger a segmentation fault.
.SH "PITFALLS"
.IX Header "PITFALLS"
.IP "\(bu" 4
This module doesn't do any encoding or newline transformation for you, and will reject any filehandle with such features enabled as mapping it would return a different value than reading it normally. Most importantly this means that on Windows you have to remember to use the \f(CW\*(C`:raw\*(C'\fR open mode or binmode to make your filehandles binary before mapping them, as by default it would do \f(CW\*(C`crlf\*(C'\fR transformation. See PerlIO for more information on how that works.
.IP "\(bu" 4
You can map a \f(CW\*(C`:utf8\*(C'\fR filehandle, but writing to it may be tricky. Hic sunt dracones.
.IP "\(bu" 4
You probably don't want to use \f(CW\*(C`>\*(C'\fR as a mode. This does not give you reading permissions on many architectures, resulting in segmentation faults when trying to read a variable (confusingly, it will work on some others like x86).
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
As any piece of software, bugs are likely to exist here. Bug reports are welcome.
.PP
Please report any bugs or feature requests to \f(CW\*(C`bug\-file\-map at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File\-Map>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.PP
Unicode file mappings are known to be buggy on perl 5.8.7 and lower.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Sys::Mmap, the original Perl mmap module
.IP "\(bu" 4
\&\fBmmap\fR\|(2), your mmap man page
.IP "\(bu" 4
Win32::MMF
.IP "\(bu" 4
CreateFileMapping at \s-1MSDN:\s0 <http://msdn.microsoft.com/en\-us/library/aa366537(\s-1VS.85\s0).aspx>
.SH "AUTHOR"
.IX Header "AUTHOR"
Leon Timmermans <fawaka@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Leon Timmermans.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
