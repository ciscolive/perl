.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::generichash 3"
.TH Crypt::NaCl::Sodium::generichash 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::generichash \- Generic hashing (Blake2b)
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_generichash = Crypt::NaCl::Sodium\->generichash();
\&
\&    # generate secret key
\&    my $key = $crypto_generichash\->keygen();
\&
\&    # list of files for which we are computing the checksums
\&    my @files = ...;
\&
\&    for my $file ( @files ) {
\&        # file name checksum
\&        my $filename_hash = $crypto_generichash\->mac($file, key => $key, bytes => 32 );
\&
\&        # using multi\-part API
\&        my $stream = $crypto_generichash\->init( key => $key, bytes => 64 );
\&
\&        open(my $fh, $file) or die;
\&        while ( sysread($fh, my $buf, 4096) ) {
\&            # add the chunk of data
\&            $stream\->update( $buf );
\&        }
\&        close($fh);
\&
\&        # calculate the final checksum
\&        my $checksum = $stream\->final();
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Compute a fixed-length fingerprint for an arbitrary long message.
\&\f(CW\*(C`crypto_generichash\*(C'\fR supports multi-part \s-1API\s0 and the use of keys of variable length.
.PP
A message will always have the same fingerprint for a given key, but different keys
used to hash the same message are very likely to produce distinct fingerprints.
.PP
If the key is used it should remain secret.
.PP
The \f(CW\*(C`crypto_generichash\*(C'\fR provides better and faster alternative to other hashing
functions like \f(CW\*(C`MD5\*(C'\fR and \f(CW\*(C`SHA\-1/2/3\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "keygen"
.IX Subsection "keygen"
.Vb 1
\&    my $key = $crypto_generichash\->keygen( $keybytes );
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_generichash\fR.
.PP
The value of the \f(CW$keybytes\fR argument can by any value between
\&\*(L"\s-1KEYBYTES_MIN\*(R"\s0 (included) and \*(L"\s-1KEYBYTES_MAX\*(R"\s0 (included).
.PP
The default value of \f(CW$keybytes\fR is \*(L"\s-1KEYBYTES\*(R"\s0.
.PP
The length of the \f(CW$key\fR equals the value of \f(CW$keybytes\fR.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.SS "mac"
.IX Subsection "mac"
.Vb 1
\&    my $mac = $crypto_generichash\->mac( $msg, key => $key, bytes => $bytes );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using (optional) \f(CW$key\fR. The value of optional
\&\f(CW$bytes\fR argument specifies the length of the computed \f(CW$mac\fR.
.PP
The value of the \f(CW$bytes\fR argument can by any value between
\&\*(L"\s-1BYTES_MIN\*(R"\s0 (included) and \*(L"\s-1BYTES_MAX\*(R"\s0 (included).
.PP
The default value of \f(CW$bytes\fR is \*(L"\s-1BYTES\*(R"\s0.
.PP
The length of the \f(CW$mac\fR equals the value of \f(CW$bytes\fR.
.PP
Returns Data::BytesLocker object.
.SH "Multi-part API"
.IX Header "Multi-part API"
Multi-part computation is also supported.
.PP
.Vb 1
\&    my $ctx = $crypto_generichash\->init( key => $key, bytes => $bytes );
\&
\&    $ctx\->update( $msgX );
\&    $ctx\->update( $msgY )\->update( $msgZ, ... );
\&
\&    my $mac = $ctx\->final( bytes => $bytes );
.Ve
.SS "init"
.IX Subsection "init"
.Vb 1
\&    my $ctx = $crypto_generichash\->mac( key => $key, bytes => $bytes );
.Ve
.PP
Creates a context for multi-part computation using (optional) \f(CW$key\fR. The value of optional
\&\f(CW$bytes\fR argument specifies the length of the final hash.
.PP
The value of the \f(CW$bytes\fR argument can by any value between
\&\*(L"\s-1BYTES_MIN\*(R"\s0 (included) and \*(L"\s-1BYTES_MAX\*(R"\s0 (included).
.PP
The default value of \f(CW$bytes\fR is \*(L"\s-1BYTES\*(R"\s0.
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::generichash::stream\*(C'\fR object which encapsulates
the computation state of the algorithm.
.SS "clone"
.IX Subsection "clone"
.Vb 4
\&    while ( <> ) {
\&        $ctx\->update( $_ );
\&        print "Line: $.: ", $ctx\->clone\->final\->to_hex, "\en";
\&    }
.Ve
.PP
Returns a copy of \f(CW$ctx\fR object, that contains the current computation
state.
.SS "update"
.IX Subsection "update"
.Vb 1
\&    $ctx\->update( $msg, ... );
.Ve
.PP
Appends its arguments to the message for which the \s-1MAC\s0 is being calculated.
.PP
Returns the \f(CW$ctx\fR object itself.
.SS "final"
.IX Subsection "final"
.Vb 1
\&    my $mac = $ctx\->final( bytes => $bytes );
.Ve
.PP
Computes the final \s-1MAC\s0 of the input data. The value of optional
\&\f(CW$bytes\fR argument specifies the output length of the final output.
.PP
The value of the \f(CW$bytes\fR argument can by any value between
\&\*(L"\s-1BYTES_MIN\*(R"\s0 (included) and \*(L"\s-1BYTES_MAX\*(R"\s0 (included).
.PP
The default value of \f(CW$bytes\fR equals to the value of \f(CW$bytes\fR of the \*(L"init\*(R"
parameter.
.PP
Returns Data::BytesLocker object.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1KEYBYTES\s0"
.IX Subsection "KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_generichash\->KEYBYTES;
.Ve
.PP
Returns the default length of key.
.SS "\s-1KEYBYTES_MIN\s0"
.IX Subsection "KEYBYTES_MIN"
.Vb 1
\&    my $key_min_length = $crypto_generichash\->KEYBYTES_MIN;
.Ve
.PP
Returns the minimum length of key.
.SS "\s-1KEYBYTES_MAX\s0"
.IX Subsection "KEYBYTES_MAX"
.Vb 1
\&    my $key_max_length = $crypto_generichash\->KEYBYTES_MAX;
.Ve
.PP
Returns the maximum length of key.
.SS "\s-1BYTES\s0"
.IX Subsection "BYTES"
.Vb 1
\&    my $mac_length = $crypto_generichash\->BYTES;
.Ve
.PP
Returns the default length of \s-1MAC.\s0
.SS "\s-1BYTES_MIN\s0"
.IX Subsection "BYTES_MIN"
.Vb 1
\&    my $mac_min_length = $crypto_generichash\->BYTES_MIN;
.Ve
.PP
Returns the minimum length of \s-1MAC.\s0
.SS "\s-1BYTES_MAX\s0"
.IX Subsection "BYTES_MAX"
.Vb 1
\&    my $mac_max_length = $crypto_generichash\->BYTES_MAX;
.Ve
.PP
Returns the maximum length of \s-1MAC.\s0
.SH "SECURITY MODEL"
.IX Header "SECURITY MODEL"
\&\f(CW\*(C`crypto_generichash\*(C'\fR uses \fIBlake2b\fR hash function which is an improved version of
\&\fI\s-1SHA\-3\s0\fR finalist \fI\s-1BLAKE\s0\fR. Like \fI\s-1SHA\-3\s0\fR, \fIBlake2b\fR offers highest security, yet is fast as
\&\fI\s-1MD5\s0\fR on 64\-bit platforms and requires 33% less \s-1RAM\s0 then \fI\s-1SHA\-2\s0\fR or \fI\s-1SHA\-3\s0\fR
on low-end systems. The core algorithm of \fIBlake2b\fR is derived from \fIChaCha\fR stream cipher.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
\&\s-1BLAKE2\s0 \- fast secure hashing <https://blake2.net/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
