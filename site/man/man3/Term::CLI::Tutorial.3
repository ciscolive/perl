.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Term::CLI::Tutorial 3"
.TH Term::CLI::Tutorial 3 "2019-11-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::CLI::Tutorial \- tips, tricks, and examples for Term::CLI
.SH "VERSION"
.IX Header "VERSION"
version 0.051007
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Term::CLI;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This manual shows how to use Term::CLI to build a working \s-1CLI\s0 application
with command-line editing capabilities, command history, command completion,
and more.
.PP
For an introduction in the object class structure, see
Term::CLI::Intro(3p).
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
If you have ever found yourself needing to write a command-line
(shell-like) interface to your program, then Term::CLI may be for you.
.PP
Term::CLI provides a readline-based command line interface, including
history, completion and input verification.
.PP
The most notable features are:
.IP "\(bu" 4
syntax checking, including option parsing
.IP "\(bu" 4
command, filename, and parameter completion
.IP "\(bu" 4
command and parameter abbreviation
.IP "\(bu" 4
command callbacks
.PP
Input syntax is specified by combining Term::CLI::Command and
Term::CLI::Argument objects, together with Getopt::Long\-like
option specifications, and providing callback
functions for command execution.
.PP
In the following sections, we will embark on the journey to building a simple
shell with a few basic commands, but one that looks quite polished.
.PP
The \fItutorial\fR directory in the module's source tree has source code
for all examples (\fIexample_01_basic_repl.pl\fR, \fIexample_02.pl\fR, etc.), that
progressively build the final application.
.SH "THE BSSH CONCEPT"
.IX Header "THE BSSH CONCEPT"
The Basically Simple SHell (\s-1BS\s0 Shell), is a command-line interpreter with a
few simple commands:
.IP "\fBcp\fR \fIsrc-path\fR ... \fIdst-path\fR" 4
.IX Item "cp src-path ... dst-path"
Copy \fIsrc\fR to \fIdst\fR.
.IP "\fBecho\fR [ \fIarg\fR ... ]" 4
.IX Item "echo [ arg ... ]"
Print arguments to \fI\s-1STDOUT\s0\fR and terminate with a newline.
.IP "\fBexit\fR [ \fIcode\fR ]" 4
.IX Item "exit [ code ]"
Exit with code \fIcode\fR (0 if not given).
.IP "\fBls\fR [ \fIfile\fR ... ]" 4
.IX Item "ls [ file ... ]"
See ls(1).
.IP "\fBmake\fR {\fBlove\fR|\fBmoney\fR} {\fBnow|later|never|forever\fR}" 4
.IX Item "make {love|money} {now|later|never|forever}"
A silly command for illustration purposes.
.IP "\fBsleep\fR \fIseconds\fR" 4
.IX Item "sleep seconds"
Sleep for \fIseconds\fR seconds.
.IP "\fBshow\fR {\fBclock\fR|\fBload\fR|\fBterminal\fR}" 4
.IX Item "show {clock|load|terminal}"
Show some system information.
.IP "\fBset\fR \fBverbose\fR \fIbool\fR" 4
.IX Item "set verbose bool"
Set program verbosity.
.IP "\fBset\fR \fBdelimiter\fR \fIbool\fR" 4
.IX Item "set delimiter bool"
Set word delimiter(s).
.IP "\fBdo\fR {\fBsomething\fR|\fBnothing\fR} \fBwhile\fR {\fBworking\fR|\fBsleeping\fR}" 4
.IX Item "do {something|nothing} while {working|sleeping}"
Do something during another activity.
.IP "\fBinterface\fR \fIiface\fR {\fBup\fR|\fBdown\fR}" 4
.IX Item "interface iface {up|down}"
Turn interface \fIiface\fR up or down.
.PP
That's it. Now, let's start building something.
.SH "THE REPL"
.IX Header "THE REPL"
The basic design of an interactive interface follows the well-established \s-1REPL\s0
(Read, Evaluate, Print, Loop) principle:
.PP
.Vb 5
\&    LOOP
\&        input = read_a_line
\&        output = evaluate_line( input )
\&        print_result( output )
\&    END\-LOOP
.Ve
.PP
Term::CLI provides a framework to make this happen:
.PP
.Vb 2
\&    use 5.014_001;
\&    use Term::CLI;
\&
\&    my $term = Term::CLI\->new(
\&        name => \*(Aqbssh\*(Aq,             # A basically simple shell.
\&    );
\&
\&    say "\en[Welcome to BSSH]";
\&    while (defined (my $line = $term\->readline)) {
\&        $term\->execute($line);
\&    }
\&    say "\enexit";
\&    exit 0;
.Ve
.PP
This example is pretty much non-functional, since the Term::CLI object is
not aware of any command syntax yet: everything you type will result in an
error, even empty lines and comments (i.e. lines starting with \f(CW\*(C`#\*(C'\fR as the
first non-blank character).
.PP
.Vb 1
\&    bash$ perl tutorial/example_01_basic_repl.pl
\&
\&    [Welcome to BSSH]
\&
\&    ~>
\&    ERROR: missing command
\&
\&    ~> # This is a comment!
\&    ERROR: unknown command \*(Aq#\*(Aq
\&
\&    ~> exit
\&    ERROR: unknown command \*(Aqexit\*(Aq
\&
\&    ~> ^D
\&    \-\- exit
.Ve
.SS "Ignoring input patterns"
.IX Subsection "Ignoring input patterns"
Let's first make sure that empty lines and comments are ignored. We \fIcould\fR
add a line to the \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 4
\&    while (my $line = $term\->readline) {
\&        next if /^\es*(?:#.*)?$/; # Skip comments and empty lines.
\&        $term\->execute($line);
\&    }
.Ve
.PP
But it's actually nicer to let Term::CLI handle this for us:
.PP
.Vb 4
\&    my $term = Term::CLI\->new(
\&        name => \*(Aqbssh\*(Aq,             # A basically simple shell.
\&        skip => qr/^\es*(?:#.*)?$/,  # Skip comments and empty lines.
\&    );
.Ve
.PP
Now we get:
.PP
.Vb 1
\&    bash$ perl tutorial/example_02_ignore_blank.pl
\&
\&    [Welcome to BSSH]
\&    ~>
\&    ~> # This is a comment!
\&    ~> exit
\&    ERROR: unknown command \*(Aqexit\*(Aq
\&    ~> ^D
\&    \-\- exit
.Ve
.SS "Setting the prompt"
.IX Subsection "Setting the prompt"
The default prompt for Term::CLI is \f(CW\*(C`~>\*(C'\fR. To change this, we can call
the prompt method, or just specify it as an argument to
the constructor:
.PP
.Vb 5
\&    my $term = Term::CLI\->new(
\&        name   => \*(Aqbssh\*(Aq,             # A basically simple shell.
\&        skip   => qr/^\es*(?:#.*)?$/,  # Skip comments and empty lines.
\&        prompt => \*(Aqbssh> \*(Aq,           # A more descriptive prompt.
\&    );
.Ve
.PP
This gives us:
.PP
.Vb 1
\&    bash$ perl tutorial/example_03_setting_prompt.pl
\&
\&    [Welcome to BSSH]
\&    bssh>
\&    bssh> # This is a comment!
\&    bssh> exit
\&    ERROR: unknown command \*(Aqexit\*(Aq
\&    bssh>
\&    \-\- exit
.Ve
.SH "ADDING COMMANDS"
.IX Header "ADDING COMMANDS"
Adding a command to a Term::CLI object is a matter of creating
an array of Term::CLI::Command instances and passing it to the
Term::CLI's \f(CW\*(C`add_command\*(C'\fR method.
.PP
.Vb 5
\&    my $term = Term::CLI\->new(
\&        name     => \*(Aqbssh\*(Aq,             # A basically simple shell.
\&        skip     => qr/^\es*(?:#.*)?$/,  # Skip comments and empty lines.
\&        prompt   => \*(Aqbssh> \*(Aq,           # A more descriptive prompt.
\&    );
\&
\&    $term\->add_command(
\&        Term::CLI::Command\->new( ... ),
\&        ...
\&    );
.Ve
.PP
It is also possible to build the \f(CW\*(C`commands\*(C'\fR list inside the constructor call:
.PP
.Vb 7
\&    my $term = Term::CLI\->new(
\&        ...
\&        commands => [
\&            Term::CLI::Command\->new( ... ),
\&            ...
\&        ]
\&    );
.Ve
.PP
However, the code quickly becomes unwieldy when a large number of
commands and options are added.
.PP
You can also build a list first, and then call \f(CW\*(C`add_command\*(C'\fR:
.PP
.Vb 3
\&    my $term = Term::CLI\->new(
\&        ...
\&    );
\&
\&    my @commands;
\&    push @commands, Term::CLI::Command\->new(
\&        ...
\&    );
\&
\&    ...
\&
\&    $term\->add_command(@commands);
.Ve
.PP
This is the method we'll use for this tutorial, and it coincidentally
comes in handy further down the line.
.PP
So, now that we have the basic mechanism out of the way, let's
add our first command, the highly useful \f(CW\*(C`exit\*(C'\fR.
.ie n .SS "The ""exit"" command (optional argument)"
.el .SS "The \f(CWexit\fP command (optional argument)"
.IX Subsection "The exit command (optional argument)"
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBexit\fR [ \fIcode\fR ]
.PP
This illustrates the use of a single, optional argument. Here's the code:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqexit\*(Aq,
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            execute_exit($cmd\->name, @{$args{arguments}});
\&            return %args;
\&        },
\&        arguments => [
\&            Term::CLI::Argument::Number::Int\->new(  # Integer
\&                name => \*(Aqexcode\*(Aq,
\&                min => 0,             # non\-negative
\&                inclusive => 1,       # "0" is allowed
\&                min_occur => 0,       # occurrence is optional
\&                max_occur => 1,       # no more than once
\&            ),
\&        ],
\&    );
.Ve
.PP
Let's unpack that, shall we?
.PP
The Term::CLI::Command constructor
takes three attributes:
.IP "\fBname =>\fR 'exit'" 4
.IX Item "name => 'exit'"
The name of the command. This is a mandatory attribute.
.IP "\fBcallback => \e&execute_exit\fR" 4
.IX Item "callback => &execute_exit"
The function to call when the command is executed.
.IP "\fBarguments =>\fR [ ... ]" 4
.IX Item "arguments => [ ... ]"
A list of arguments that the command takes.
.PP
\fIThe \f(CI\*(C`callback\*(C'\fI function\fR
.IX Subsection "The callback function"
.PP
The callback function is called when the command is executed.
.PP
.Vb 6
\&    callback => sub {
\&        my ($cmd, %args) = @_;
\&        return %args if $args{status} < 0;
\&        execute_exit($cmd\->name, @{$args{arguments}});
\&        return %args;
\&    },
.Ve
.PP
In this case, we also have to define \f(CW\*(C`execute_exit\*(C'\fR:
.PP
.Vb 6
\&    sub execute_exit {
\&        my ($cmd, $excode) = @_;
\&        $excode //= 0;
\&        say "\-\- $cmd: $excode";
\&        exit $excode;
\&    }
.Ve
.PP
The callback function
(see callback in Term::CLI::Role::CommandSet)
is called with a reference to the command object that owns the callback, along
with a number of (\fIkey\fR, \fIvalue\fR) pairs. It is expected to return a similar
structure (while possibly modifying the \f(CW\*(C`status\*(C'\fR and/or \f(CW\*(C`error\*(C'\fR values).
.PP
Since the callback function is called even in the face of parse errors, it is
important to check the \f(CW\*(C`status\*(C'\fR flag. A negative value indicates a parse
error, so we don't do anything in that case (the Term::CLI default callback
will print the error for us).
.PP
The command arguments are found under the \f(CW\*(C`arguments\*(C'\fR key, as an ArrayRef of
scalars. The exit code is the only (optional) argument, so that is found as
the first element of the list: \f(CW\*(C`$args{arguments}\->[0]\*(C'\fR. If it is not given,
we default to \f(CW0\fR.
.PP
\fIThe \f(CI\*(C`arguments\*(C'\fI list\fR
.IX Subsection "The arguments list"
.PP
The \f(CW\*(C`arguments\*(C'\fR attribute is an ArrayRef made up of Term::CLI::Argument
instances, or more precisely, object classes derived from that. At this
moment, we have a number of pre-defined sub-classes:
Term::CLI::Argument::Bool,
Term::CLI::Argument::Enum,
Term::CLI::Argument::Number::Float.
Term::CLI::Argument::Number::Int,
Term::CLI::Argument::Filename,
Term::CLI::Argument::String.
In our case, we need an optional, non-negative integer, so:
.PP
.Vb 7
\&    Term::CLI::Argument::Number::Int\->new(  # Integer
\&        name => \*(Aqexcode\*(Aq,
\&        min => 0,             # non\-negative
\&        inclusive => 1,       # "0" is allowed
\&        min_occur => 0,       # occurrence is optional
\&        max_occur => 1,       # no more than once
\&    ),
.Ve
.PP
The \f(CW\*(C`inclusive\*(C'\fR and \f(CW\*(C`max_occur\*(C'\fR can be left out in this case, as their
defaults are \f(CW1\fR anyway.
.PP
\fITrying out the \f(CI\*(C`exit\*(C'\fI command\fR
.IX Subsection "Trying out the exit command"
.PP
.Vb 1
\&    bash$ perl tutorial/example_04.pl
\&
\&    [Welcome to BSSH]
\&    bssh> exit ok
\&    ERROR: arg#1, \*(Aqok\*(Aq: not a valid number for excode
\&    bssh> exit 0 1
\&    ERROR: arg#1, excode: too many arguments
\&    bssh> exit 2
\&    \-\- exit: 2
.Ve
.PP
Note that command abbreviation also works, i.e. you can type:
.PP
.Vb 4
\&    e
\&    ex
\&    exi
\&    exit
.Ve
.SH "GETTING HELP"
.IX Header "GETTING HELP"
Before adding more commands to our application, it's perhaps a good
moment to look at the built-in help features of Term::CLI.
.PP
By default, there is no help available in a Term::CLI application:
.PP
.Vb 2
\&    bssh> help
\&    ERROR: unknown command \*(Aqhelp\*(Aq
.Ve
.PP
However, there is a special Term::CLI::Command::Help class (derived
from Term::CLI::Command) that implements a \f(CW\*(C`help\*(C'\fR command, including
command line completion:
.PP
.Vb 1
\&    push @commands, Term::CLI::Command::Help\->new();
.Ve
.PP
If you add this to the application, you'll get:
.PP
.Vb 1
\&    bash$ perl tutorial/example_05_add_help.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help
\&    Commands:
\&        exit [excode]
\&        help [cmd ...]             show help
\&    bssh> help exit
\&    Usage:
\&        exit [excode]
\&    bssh> help h
\&    Usage:
\&        help [\-\-pod] [\-p] [cmd ...]
\&
\&    Description:
\&        Show help for any given command sequence. The "\-\-pod"
\&        option (or "\-p") will cause raw POD to be shown.
.Ve
.PP
Note that we don't have to specify the full command to get help on:
command abbreviation works here as well (\f(CW\*(C`help h\*(C'\fR). Also, if you'd type
\&\f(CW\*(C`help h\*(C'\fR, then hit the \fI\s-1TAB\s0\fR key, it would autocomplete to \f(CW\*(C`help help\*(C'\fR.
.PP
The \f(CW\*(C`\-\-pod\*(C'\fR option is handy if you want to copy the help text into a
manual page:
.PP
.Vb 1
\&    bssh> help \-\-pod help
\&
\&    =head2 Usage:
\&
\&    B<help> [B<\-\-pod>] [B<\-p>] [I<cmd> ...]
\&
\&    =head2 Description:
\&
\&    Show help for any given command sequence.
\&    The C<\-\-pod> option (or C<\-p>) will cause raw POD
\&    to be shown.
.Ve
.SS "Fleshing out help text"
.IX Subsection "Fleshing out help text"
As you may have already seen, the help text for the \f(CW\*(C`exit\*(C'\fR command
is rather sparse (unlike that of the \f(CW\*(C`help\*(C'\fR command itself): it only
shows a \*(L"usage\*(R" line.
.PP
The Term::CLI::Command::Help class is smart enough to construct a
usage line from the given command (including its options, parameters
and sub-commands), but it cannot magically describe what a command
is all about. You'll have to specify that yourself, using the \f(CW\*(C`summary\*(C'\fR
and \f(CW\*(C`description\*(C'\fR attributes in the \f(CW\*(C`exit\*(C'\fR command definition:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqexit\*(Aq,
\&        summary => \*(Aqexit B<bssh>\*(Aq,
\&        description => "Exit B<bssh> with code I<excode>,\en"
\&                    ."or C<0> if no exit code is given.",
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            execute_exit($cmd\->name, @{$args{arguments}});
\&            return %args;
\&        },
\&        arguments => [
\&            Term::CLI::Argument::Number::Int\->new(  # Integer
\&                name => \*(Aqexcode\*(Aq,
\&                min => 0,             # non\-negative
\&                inclusive => 1,       # "0" is allowed
\&                min_occur => 0,       # occurrence is optional
\&                max_occur => 1,       # no more than once
\&            ),
\&        ],
\&    );
.Ve
.PP
The \f(CW\*(C`summary\*(C'\fR text is what is displayed in the command summary, the
\&\f(CW\*(C`description\*(C'\fR text is shown in the full help for the command:
.PP
.Vb 1
\&    bash $perl tutorial/example_06_add_help_text.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help
\&      Commands:
\&        exit [excode]              exit bssh
\&        help [cmd ...]             show help
\&    bssh> help exit
\&      Usage:
\&        exit [excode]
\&
\&      Description:
\&        Exit bssh with code excode, or 0 if no exit code is given.
.Ve
.PP
The help text is in \s-1POD\s0 format, translated for the screen using
Pod::Text::Termcap(3p), and piped through an appropriate pager
(see Term::CLI::Command::Help for more details).
.SH "ADDING MORE COMMANDS"
.IX Header "ADDING MORE COMMANDS"
The following examples will show various types and combination of
arguments:
.IP "\(bu" 4
The \f(CW\*(C`echo\*(C'\fR command takes zero or more arbitrary string arguments
(M6::CLI::Argument::String).
.IP "\(bu" 4
The \f(CW\*(C`make\*(C'\fR command takes two string arguments, each from a set
of pre-defined values.
(M6::CLI::Argument::Enum).
.IP "\(bu" 4
The \f(CW\*(C`ls\*(C'\fR command demonstrates the use of file name arguments
(M6::CLI::Argument::Filename).
.IP "\(bu" 4
The \f(CW\*(C`cp\*(C'\fR command demonstrates how to set up a variable number
of arguments (M6::CLI::Argument::Filename).
.IP "\(bu" 4
The \f(CW\*(C`sleep\*(C'\fR command demonstrates a numerical argument
(M6::CLI::Argument::Int).
.ie n .SS "The ""echo"" command (optional arguments)"
.el .SS "The \f(CWecho\fP command (optional arguments)"
.IX Subsection "The echo command (optional arguments)"
Next up, the \f(CW\*(C`echo\*(C'\fR command.
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBecho\fR [ \fIarg\fR ... ]
.PP
That is, the \f(CW\*(C`echo\*(C'\fR command takes zero or more arbitrary
string arguments.
.PP
The implementation is straightforward:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqecho\*(Aq,
\&        summary => \*(Aqprint arguments to F<stdout>\*(Aq,
\&        description => "The C<echo> command prints its arguments\en"
\&                    .  "to F<stdout>, separated by spaces, and\en"
\&                    .  "terminated by a newline.\en",
\&        arguments => [
\&            Term::CLI::Argument::String\->new( name => \*(Aqarg\*(Aq, occur => 0 ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            say "@{$args{arguments}}";
\&            return %args;
\&        }
\&    );
.Ve
.PP
However, the \f(CW\*(C`echo\*(C'\fR and \f(CW\*(C`exit\*(C'\fR commands both start with the
same prefix (\f(CW\*(C`e\*(C'\fR), so let's see what happens with the abbreviations:
.PP
.Vb 1
\&    bash$ perl tutorial/example_07_echo_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> e hello, world
\&    ERROR: ambiguous command \*(Aqe\*(Aq (matches: echo, exit)
\&    bssh> ec hello, world
\&    hello, world
\&    bssh> ex
\&    \-\- exit: 0
.Ve
.ie n .SS "The ""make"" command (enum arguments)"
.el .SS "The \f(CWmake\fP command (enum arguments)"
.IX Subsection "The make command (enum arguments)"
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBmake\fR {\fBlove\fR|\fBmoney\fR} {\fBnow|later|never|forever\fR}
.PP
Arguments with fixed set of values can be specified with
Term::CLI::Argument::Enum objects:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqmake\*(Aq,
\&        summary => \*(Aqmake I<target> at time I<when>\*(Aq,
\&        description => "Make I<target> at time I<when>.\en"
\&                    .  "Possible values for I<target> are:\en"
\&                    .  "C<love>, C<money>.\en"
\&                    .  "Possible values for I<when> are:\en"
\&                    .  "C<now>, C<never>, C<later>, or C<forever>.",
\&        arguments => [
\&            Term::CLI::Argument::Enum\->new( name => \*(Aqtarget\*(Aq,
\&                value_list => [qw( love money)],
\&            ),
\&            Term::CLI::Argument::Enum\->new( name => \*(Aqwhen\*(Aq,
\&                value_list => [qw( now later never forever )],
\&            ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            my @args = @{$args{arguments}};
\&            say "making $args[0] $args[1]";
\&            return %args;
\&        }
\&    );
.Ve
.PP
The \*(L"enum\*(R" parameters support completion, as well as abbreviations. Thus,
\&\f(CW\*(C`m m l\*(C'\fR will expand to \f(CW\*(C`make money later\*(C'\fR, and \f(CW\*(C`make l n\*(C'\fR will
fail because \f(CW\*(C`n\*(C'\fR is ambiguous:
.PP
.Vb 1
\&    bash$ perl tutorial/example_08_make_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> m m l
\&    making money later
\&    bssh> m l n
\&    ERROR: arg#2, \*(Aqn\*(Aq: ambiguous value (matches: never, now) for \*(Aqwhen\*(Aq
.Ve
.PP
\fICommand and parameter completion\fR
.IX Subsection "Command and parameter completion"
.PP
.Vb 5
\&    m<TAB>          make
\&    m l<TAB>        m love
\&    m l l<TAB>      m l later
\&    m l n<TAB>      m l n
\&    m l n<TAB><TAB> (displays "never" and "now" as completions)
.Ve
.ie n .SS "The ""ls"" command (file name arguments)"
.el .SS "The \f(CWls\fP command (file name arguments)"
.IX Subsection "The ls command (file name arguments)"
The \f(CW\*(C`ls\*(C'\fR command takes zero or more file name arguments.
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBls\fR [ \fIpath\fR ... ]
.PP
The code for this:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqls\*(Aq,
\&        summary => \*(Aqlist file(s)\*(Aq,
\&        description => "List file(s) given by the arguments.\en"
\&                    .  "If no arguments are given, the command\en"
\&                    .  "will list the current directory.",
\&        arguments => [
\&            Term::CLI::Argument::Filename\->new( name => \*(Aqarg\*(Aq, occur => 0 ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            my @args = @{$args{arguments}};
\&            system(\*(Aqls\*(Aq, @args);
\&            $args{status} = $?;
\&            return %args;
\&        }
\&    );
.Ve
.PP
Output should look like:
.PP
.Vb 1
\&    bash$ perl tutorial/example_09_ls_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> ls
\&    blib      lib           MANIFEST     t
\&    Copying   Makefile      MYMETA.json  Term\-CLI\-0.01.tar.gz
\&    cover_db  Makefile.old  MYMETA.yml   TODO
\&    examples  Makefile.PL   pm_to_blib   tutorial
\&    bssh> _
.Ve
.PP
Options are passed directly to the ls(1) command. This is
because we didn't specify any options in the command definition,
so everything is assumed to be an argument, and the
Term::CLI::Argument::Filename class is not particularly picky
about the arguments it gets, juost so long as they are not empty:
.PP
.Vb 3
\&    bssh> ls \-F lib/Term
\&    CLI/  CLI.pm
\&    bssh> _
.Ve
.PP
\fIFile name completion\fR
.IX Subsection "File name completion"
.PP
.Vb 3
\&    ls t<TAB><TAB>          (lists "t/" and "tutorial/" as completions)
\&    ls tu<TAB>              ls tutorial
\&    ls tutorial e<TAB>      ls tutorial examples
.Ve
.ie n .SS "The ""cp"" command (variable number of arguments)"
.el .SS "The \f(CWcp\fP command (variable number of arguments)"
.IX Subsection "The cp command (variable number of arguments)"
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBcp\fR \fIsrc-path\fR ... \fIdst-path\fR
.PP
Ideally, we would like to specify this as:
.PP
.Vb 10
\&    Term::CLI::Command\->new(
\&        name => \*(Aqcp\*(Aq,
\&        arguments => [
\&            Term::CLI::Argument::Filename\->new(
\&                name => \*(Aqsrc\-path\*(Aq,
\&                min_occur => 1,
\&                max_occur => 0 ),
\&            Term::CLI::Argument::Filename\->new(
\&                name => \*(Aqdst\-path\*(Aq,
\&                min_occur => 1,
\&                max_occur => 1 ),
\&        ],
\&        ...
\&    )
.Ve
.PP
Unfortunately, that will not work. Term::CLI::Command can work with
a variable number of arguments, but only if that variable number is at
\&\fIthe end of the list\fR.
.PP
To see why this is the case, it is important to realise that Term::CLI
parses an input line strictly from left to right, without any backtracking
(which proper recursive descent parsers typically do). So, suppose you enter
\&\f(CW\*(C`cp foo bar<TAB>\*(C'\fR. The completion code now has to decide what this \f(CW\*(C`bar\*(C'\fR
is that needs to be completed. Since the first argument to \f(CW\*(C`cp\*(C'\fR can be one or
more file names, this \f(CW\*(C`bar\*(C'\fR can be a \fIsrc-path\fR, but it can also be meant to
be a \fIdst-path\fR. There is no way to tell for certain, so the code will be
\&\*(L"greedy\*(R", in the sense that it will classify all arguments as \fIsrc-path\fR
arguments.
.PP
There's no way around this, except by using options, but that's a separate
topic.
.PP
For now, there's no other way than to specify a single
Term::CLI::Argument::Filename, with a minimum occurrence of 2, and no
maximum. De distinction between \fIsrc-path\fR and \fIdst-path\fR needs to be
made in the callback code.
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqcp\*(Aq,
\&        summary => \*(Aqcopy files\*(Aq,
\&        description => "Copy files. The last argument in the\en"
\&                    .  "list is the destination.\en",
\&        arguments => [
\&            Term::CLI::Argument::Filename\->new( name => \*(Aqpath\*(Aq,
\&                min_occur => 2,
\&                max_occur => 0
\&            ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            my @src = @{$args{arguments}};
\&            my $dst = pop @src;
\&
\&            say "command:     ".$cmd\->name;
\&            say "source:      ".join(\*(Aq, \*(Aq, @src);
\&            say "destination: ".$dst;
\&
\&            return %args;
\&        }
\&    );
.Ve
.PP
Example:
.PP
.Vb 1
\&    bash$ perl tutorial/example_10_cp_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> cp
\&    ERROR: need at least 2 \*(Aqpath\*(Aq arguments
\&    bssh> cp foo bar baz
\&    command:     cp
\&    source:      foo, bar
\&    destination: baz
\&    bssh> cp \-r foo
\&    command:     cp
\&    source:      \-r
\&    destination: foo
\&    bssh> ^D
\&    \-\- exit: 0
.Ve
.PP
Note that this setup does not recognise options, so all options will
be passed as regular arguments.
.ie n .SS "The ""sleep"" command (single integer argument)"
.el .SS "The \f(CWsleep\fP command (single integer argument)"
.IX Subsection "The sleep command (single integer argument)"
From \s-1THE BSSH CONCEPT\s0 section above:
.PP
    \fBsleep\fR \fIseconds\fR
.PP
This is an almost trivial implementation:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqsleep\*(Aq,
\&        summary => \*(Aqsleep for I<time> seconds\*(Aq,
\&        description => "Sleep for I<time> seconds.\en"
\&                    .  "Report the actual time spent sleeping.\en"
\&                    .  "This number can be smaller than I<time>\en"
\&                    .  "in case of an interruption (e.g. INT signal).",
\&        arguments => [
\&            Term::CLI::Argument::Number::Int\->new( name => \*(Aqtime\*(Aq,
\&                min => 1, inclusive => 1
\&            ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&
\&            my $time = $args{arguments}\->[0];
\&
\&            say "\-\- sleep: $time";
\&
\&            my %oldsig = %::SIG; # Save signals;
\&
\&            # Make sure we can interrupt the sleep() call.
\&            $::SIG{INT} = $::SIG{QUIT} = sub {
\&                say STDERR "(interrupted by $_[0])";
\&            };
\&
\&            my $slept = sleep($time);
\&
\&            %::SIG = %oldsig; # Restore signal handlers.
\&
\&            say "\-\- woke up after $slept sec", $slept == 1 ? \*(Aq\*(Aq : \*(Aqs\*(Aq;
\&            return %args;
\&        }
\&    );
.Ve
.PP
The Term::CLI::Argument::Number::Int allows us to set a minimum and maximum
value (and whether or not the boundaries are included in the allowed range).
Our time to sleep should obviously be a positive integer.
.PP
See it in action:
.PP
.Vb 1
\&    bash$ perl tutorial/example_11_sleep_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help sleep
\&      Usage:
\&        sleep time
\&
\&      Description:
\&        Sleep for time seconds. Report the actual time spent sleeping. This number
\&        can be smaller than time in case of an interruption (e.g. INT signal).
\&    bssh> sleep 3
\&    \-\- sleep: 3
\&    \-\- woke up after 3 secs
\&    bssh> sleep 30
\&    \-\- sleep: 30
\&    ^C(interrupted by INT)
\&    \-\- woke up after 5 secs
\&    bssh> ^D
\&    \-\- exit: 0
.Ve
.SH "SUB-COMMANDS"
.IX Header "SUB-COMMANDS"
You may have noticed that so far, we've only added commands with arguments.
But what if we want to implement something like:
.PP
    \fBshow\fR { \fBload\fR|\fBclock\fR|\fBterminal\fR }
.PP
Well, as it turns out, Term::CLI::Command(3p) can handle
that as well: instead of specifying \f(CW\*(C`arguments\*(C'\fR in the constructor, you can
specify \f(CW\*(C`commands\*(C'\fR. Just like for Term::CLI, the \f(CW\*(C`commands\*(C'\fR attribute
takes a reference to an array of Term::CLI::Command objects.
.ie n .SS "The ""show"" command"
.el .SS "The \f(CWshow\fP command"
.IX Subsection "The show command"
The code for the \f(CW\*(C`show\*(C'\fR command looks almost trivial:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqshow\*(Aq,
\&        summary => \*(Aqshow system properties\*(Aq,
\&        description => "Show some system\-related information,\en"
\&                    .  "such as the system clock or load average.",
\&        commands => [
\&            Term::CLI::Command\->new( name => \*(Aqclock\*(Aq,
\&                summary => \*(Aqshow system time\*(Aq,
\&                description => \*(AqShow system time and date.\*(Aq,
\&                callback => sub {
\&                    my ($self, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    say scalar(localtime);
\&                    return %args;
\&                },
\&            ),
\&            Term::CLI::Command\->new( name => \*(Aqload\*(Aq,
\&                summary => \*(Aqshow system load\*(Aq,
\&                description => \*(AqShow system load averages.\*(Aq,
\&                callback => sub {
\&                    my ($self, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    system(\*(Aquptime\*(Aq);
\&                    $args{status} = $?;
\&                    return %args;
\&                },
\&            ),
\&            Term::CLI::Command\->new( name => \*(Aqterminal\*(Aq,
\&                summary => \*(Aqshow terminal information\*(Aq,
\&                description => \*(AqShow terminal information.\*(Aq,
\&                callback => sub {
\&                    my ($self, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    my ($rows, $cols)
\&                        = $self\->root_node\->term\->get_screen_size;
\&                    say "type $ENV{TERM}; rows $rows; columns $cols";
\&                    $args{status} = 0;
\&                    return %args;
\&                },
\&            ),
\&        ],
\&    );
.Ve
.PP
Adding this to our ever-growing \f(CW\*(C`bssh\*(C'\fR code, we get:
.PP
.Vb 1
\&    bash$ perl tutorial/example_12_show_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help show
\&      Usage:
\&        show {clock|load|terminal}
\&
\&      Description:
\&        Show some system\-related information, such as the system clock or load
\&        average.
\&
\&      Sub\-Commands:
\&        show clock               show system time
\&        show load                show system load
\&        show terminal            show terminal information
\&    bssh> show clock
\&    Wed Feb 21 14:21:56 2018
\&    bssh> show load
\&     14:21:59 up 1 day, 15:30,  1 user,  load average: 0.19, 0.33, 0.40
\&    bssh> show terminal
\&    type gnome\-256color; rows 25; columns 80
\&    bssh> ^D
\&    \-\- exit: 0
.Ve
.ie n .SS "The ""set"" command"
.el .SS "The \f(CWset\fP command"
.IX Subsection "The set command"
The specification says:
.PP
    \fBset\fR \fBverbose\fR \fIbool\fR
.PP
    \fBset\fR \fBdelimiters\fR \fIstring\fR
.PP
Code:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqset\*(Aq,
\&        summary => \*(Aqset CLI parameters\*(Aq,
\&        description => \*(AqSet various CLI parameters.\*(Aq,
\&        commands => [
\&            Term::CLI::Command\->new(
\&                name => \*(Aqdelimiters\*(Aq,
\&                summary => \*(Aqset word delimiter(s)\*(Aq,
\&                description =>
\&                    \*(AqSet the word delimiter(s) to I<string>.\*(Aq,
\&                arguments => [
\&                    Term::CLI::Argument::String\->new(name => \*(Aqstring\*(Aq)
\&                ],
\&                callback => sub {
\&                    my ($self, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    my $delimiters = $args{arguments}\->[0];
\&                    $self\->root_node\->word_delimiters($delimiters);
\&                    say "Delimiters set to [$delimiters]";
\&                    return %args;
\&                }
\&            ),
\&            Term::CLI::Command\->new(
\&                name => \*(Aqverbose\*(Aq,
\&                summary => \*(Aqset verbose flag\*(Aq,
\&                description =>
\&                    \*(AqSet the verbose flag for the program.\*(Aq,
\&                arguments => [
\&                    Term::CLI::Argument::Bool\->new(name => \*(Aqbool\*(Aq,
\&                        true_values  => [qw( 1 true on yes ok )],
\&                        false_values => [qw( 1 false off no never )],
\&                    )
\&
\&                ],
\&                callback => sub {
\&                    my ($self, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    my $bool = $args{arguments}\->[0];
\&                    say "Setting verbose to $bool";
\&                    return %args;
\&                }
\&            ),
\&        ],
\&    );
.Ve
.PP
This shows the use of Term::CLI::Argument::Bool (\f(CW\*(C`set verbose\*(C'\fR), and
the use of alternative delimiters (\f(CW\*(C`set delimiters\*(C'\fR).
.PP
Results for \f(CW\*(C`set verbose\*(C'\fR:
.PP
.Vb 1
\&    bash$ perl tutorial/example_13_set_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help set
\&      Usage:
\&        set {delimiters|verbose}
\&    
\&      Description:
\&        Set various CLI parameters.
\&    
\&      Sub\-Commands:
\&        set delimiters string    set word delimiter(s)
\&        set verbose bool         set verbose flag
\&    bssh> set verbose o
\&    ERROR: arg#1, \*(Aqo\*(Aq: ambiguous boolean value (matches [on, ok]
\&    and [off]) for \*(Aqbool\*(Aq
\&    bssh> set verbose t
\&    Setting verbose to 1
.Ve
.PP
Results for \f(CW\*(C`set delimiters\*(C'\fR:
.PP
.Vb 1
\&    bash$ perl tutorial/example_13_set_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> set delim \*(Aq;,\*(Aq
\&    Delimiters set to [;,]
\&    bssh> show clock
\&    ERROR: unknown command \*(Aqshow clock\*(Aq
\&    bssh> show;clock
\&    Wed Mar 14 23:44:49 2018
\&    bssh> make;love,now
\&    making love now
\&    bssh> exit;0
\&    \-\- exit: 0
.Ve
.SS "Combining arguments and sub-commands"
.IX Subsection "Combining arguments and sub-commands"
A Term::CLI::Command object can have both arguments and (sub\-)commands
as well. If this is the case, the parser expects the arguments before the
sub-commands, and there can be no variable number of arguments.
.PP
This technique can be used to specify arguments that are common to
sub-commands (the \f(CW\*(C`interface\*(C'\fR command), or to create syntactic sugar
(the \f(CW\*(C`do\*(C'\fR command).
.ie n .SS "Syntactic sugar: the ""do"" command"
.el .SS "Syntactic sugar: the \f(CWdo\fP command"
.IX Subsection "Syntactic sugar: the do command"
The specification says:
.PP
    \fBdo\fR {\fBsomething\fR|\fBnothing\fR} \fBwhile\fR {\fBworking\fR|\fBsleeping\fR}
.PP
Code:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqdo\*(Aq,
\&        summary => \*(AqDo I<action> while I<activity>\*(Aq,
\&        description => "Do I<action> while I<activity>.\en"
\&                    .  "Possible values for I<action> are:\en"
\&                    .  "C<nothing>, C<something>.\en"
\&                    .  "Possible values for I<activity> are:\en"
\&                    .  "C<sleeping>, C<working>.",
\&        arguments => [
\&            Term::CLI::Argument::Enum\->new( name => \*(Aqaction\*(Aq,
\&                value_list => [qw( something nothing )],
\&            ),
\&        ],
\&        commands => [
\&            Term::CLI::Command\->new(
\&                name => \*(Aqwhile\*(Aq,
\&                arguments => [
\&                    Term::CLI::Argument::Enum\->new( name => \*(Aqactivity\*(Aq,
\&                        value_list => [qw( eating sleeping )],
\&                    ),
\&                ],
\&            ),
\&        ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            return %args if $args{status} < 0;
\&            my @args = @{$args{arguments}};
\&            say "doing $args[0] while $args[1]";
\&            return %args;
\&        }
\&    );
.Ve
.ie n .SS "Common argument(s): the ""interface"" command"
.el .SS "Common argument(s): the \f(CWinterface\fP command"
.IX Subsection "Common argument(s): the interface command"
The specification says:
.PP
    \fBinterface\fR \fIiface\fR {\fBup\fR|\fBdown\fR}
.PP
The \fIiface\fR argument is used by both sub-commands.
.PP
Code:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqinterface\*(Aq,
\&        summary => \*(AqTurn I<iface> up or down\*(Aq,
\&        description => "Turn the I<iface> interface up or down.",
\&        arguments => [
\&            Term::CLI::Argument::String\->new( name => \*(Aqiface\*(Aq )
\&        ],
\&        commands => [
\&            Term::CLI::Command\->new(
\&                name => \*(Aqup\*(Aq,
\&                summary => \*(AqBring I<iface> up\*(Aq,
\&                description => \*(AqBring the I<iface> interface up.\*(Aq,
\&                callback => sub {
\&                    my ($cmd, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    my @args = @{$args{arguments}};
\&                    say "bringing up $args[0]";
\&                    return %args;
\&                }
\&            ),
\&            Term::CLI::Command\->new(
\&                name => \*(Aqdown\*(Aq,
\&                summary => \*(AqShut down I<iface>\*(Aq,
\&                description => \*(AqShut down the I<iface> interface.\*(Aq,
\&                callback => sub {
\&                    my ($cmd, %args) = @_;
\&                    return %args if $args{status} < 0;
\&                    my @args = @{$args{arguments}};
\&                    say "shutting down $args[0]";
\&                    return %args;
\&                }
\&            ),
\&        ],
\&    );
.Ve
.PP
With the above two additions, we have:
.PP
.Vb 1
\&    bash$ perl tutorial/example_14_sub_cmd_and_args.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help
\&      Commands:
\&        cp path1 path2 ...                           copy files
\&        do action while activity                     do action while activity
\&        echo arg ...                                 print arguments to stdout
\&        exit excode                                  exit bssh
\&        help cmd ...                                 show help
\&        interface iface {up|down}                    turn iface up or down
\&        ls arg ...                                   list file(s)
\&        make target when                             make target at time when
\&        set {delimiters|verbose}                     set CLI parameters
\&        show {clock|load}                            show system properties
\&        sleep time                                   sleep for time seconds
\&    bssh> do something wh s
\&    doing something while sleeping
\&    bssh> i eth0 u
\&    bringing up eth0
\&    bssh> i eth0 d
\&    shutting down eth0
\&    bssh> ^D
\&    \-\- exit: 0
.Ve
.ie n .SH "BONUS POINTS: A ""debug"" COMMAND"
.el .SH "BONUS POINTS: A \f(CWdebug\fP COMMAND"
.IX Header "BONUS POINTS: A debug COMMAND"
The fun thing of nesting commands is that we can easily implement this:
.PP
.Vb 1
\&    use Data::Dumper;
\&
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqdebug\*(Aq,
\&        usage => \*(AqB<debug> I<cmd> ...\*(Aq,
\&        summary => \*(Aqdebug commands\*(Aq,
\&        description => "Print some debugging information regarding\en"
\&                    .  "the execution of a command.",
\&        commands => [ @commands ],
\&        callback => sub {
\&            my ($cmd, %args) = @_;
\&            my @args = @{$args{arguments}};
\&            say "# \-\-\- DEBUG \-\-\-";
\&            my $d = Data::Dumper\->new([\e%args], [qw(args)]);
\&            print $d\->Maxdepth(2)\->Indent(1)\->Terse(1)\->Dump;
\&            say "# \-\-\- DEBUG \-\-\-";
\&            return %args;
\&        }
\&    );
.Ve
.PP
Here, we basically added a \f(CW\*(C`debug\*(C'\fR command that takes any other command
structure as a sub-command and, after the sub-command has executed,
will print some status information.
.PP
.Vb 1
\&    bash$ perl tutorial/example_15_debug_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> debug <TAB><TAB>
\&    cp     echo   exit   ls     make   set    show   sleep
\&    bssh> debug echo hi
\&    hi
\&    # \-\-\- DEBUG \-\-\-
\&    {
\&      \*(Aqerror\*(Aq => \*(Aq\*(Aq,
\&      \*(Aqstatus\*(Aq => 0,
\&      \*(Aqarguments\*(Aq => [
\&        \*(Aqhi\*(Aq
\&      ],
\&      \*(Aqcommand_path\*(Aq => [
\&        \*(AqTerm::CLI=HASH(0x55e95ae02e20)\*(Aq,
\&        \*(AqTerm::CLI::Command=HASH(0x55e95b0c3998)\*(Aq,
\&        \*(AqTerm::CLI::Command=HASH(0x55e95b03f780)\*(Aq
\&      ],
\&      \*(Aqoptions\*(Aq => {}
\&    }
\&    # \-\-\- DEBUG \-\-\-
\&    bssh> exit
\&    \-\- exit: 0
.Ve
.PP
Note the addition of the static \f(CW\*(C`usage\*(C'\fR line, because the autogenerated
usage line is too long (it lists every possible sub-command):
.PP
.Vb 1
\&    bash$ perl tutorial/example_15_debug_command.pl
\&
\&    [Welcome to BSSH]
\&    bssh> help
\&      Commands:
\&        cp path1 path2 ...                           copy files
\&        debug cmd ...                                debug commands
\&        [...]
\&    bssh> help debug
\&      Usage:
\&        debug cmd ...
\&    
\&      Description:
\&        Print some debugging information regarding the execution of cmd.
\&    
\&      Sub\-Commands:
\&        debug cp path1 path2 ...                     copy files
\&        debug do action while activity               Do action while activity
\&        debug echo arg ...                           print arguments to stdout
\&        debug exit excode                            exit bssh
\&        debug help cmd ...                           show help
\&        debug interface iface {down|up}              Turn iface up or down
\&        debug ls arg ...                             list file(s)
\&        debug make target when                       make target at time when
\&        debug set {delimiters|verbose}               set CLI parameters
\&        debug show {clock|load}                      show system properties
\&        debug sleep time                             sleep for time seconds
.Ve
.PP
\fICaveat on \f(CI\*(C`parent\*(C'\fI\fR
.IX Subsection "Caveat on parent"
.PP
Note that this construction is not entirely without consequences, though:
adding a
Term::CLI::Command to another
Term::CLI::Command or a
Term::CLI
object (or any object that consumes the Term::CLI::Role::CommandSet role)
will cause the 
Term::CLI::Command object's
\&\f(CW\*(C`parent\*(C'\fR attribute to be set.
.PP
At this moment, the parent attribute is only
used to find the
root_node,
but this may change in the future.
.PP
To ensure the hierarchy still makes sense then, add the \f(CW@commands\fR to the
debug command \fIbefore\fR adding them to the Term::CLI object.
.PP
And, yes, you can in principle do this:
.PP
.Vb 4
\&    my $debug = Term::CLI::Command\->new( name => \*(Aqdebug\*(Aq, ... );
\&    push @commands, $debug;
\&    $debug\->add_command(@commands);
\&    $term\->add_command(@commands);
.Ve
.PP
This would give you a debug command that can debug itself:
\&\f(CW\*(C`debug debug debug ...\*(C'\fR (but \fIwhy\fR would you want that!?).
.SH "ADDING OPTIONS"
.IX Header "ADDING OPTIONS"
You may have noticed that the output of the \f(CW\*(C`debug\*(C'\fR command above showed
an \f(CW\*(C`options\*(C'\fR key that points to a HashRef. This contains valid command
line options from the input. To have the parsing and completion code
recognise command line options, simply pass an \f(CW\*(C`options\*(C'\fR parameter to
the Term::CLI::Command constructor call:
.PP
.Vb 10
\&    push @commands, Term::CLI::Command\->new(
\&        name => \*(Aqshow\*(Aq,
\&        options => [ \*(Aqverbose|v\*(Aq ],
\&        commands => [
\&            Term::CLI::Command\->new( name => \*(Aqclock\*(Aq,
\&                options => [ \*(Aqtimezone|tz|t=s\*(Aq ],
\&                callback => \e&do_show_clock,
\&            ),
\&            Term::CLI::Command\->new( name => \*(Aqload\*(Aq,
\&                callback => \e&do_show_uptime,
\&            ),
\&        ],
\&    );
\&
\&    sub do_show_clock {
\&        my ($self, %args) = @_;
\&        return %args if $args{status} < 0;
\&        my $opt = $args{options};
\&
\&        local($::ENV{TZ});
\&        if ($opt\->{timezone}) {
\&            $::ENV{TZ} = $opt\->{timezone};
\&        }
\&        say scalar(localtime);
\&        return %args;
\&    }
\&
\&    sub do_show_uptime {
\&        my ($self, %args) = @_;
\&        return %args if $args{status} < 0;
\&        system(\*(Aquptime\*(Aq);
\&        $args{status} = $?;
\&        return %args;
\&    }
.Ve
.PP
The value should be an ArrayRef with the allowed options in
Getopt::Long(3p) format. The Term::CLI code will turn
on \f(CW\*(C`bundling\*(C'\fR (allow grouping of single letter options, i.e. \f(CW\*(C`\-a\*(C'\fR
nd \f(CW\*(C`\-b\*(C'\fR can be written as \f(CW\*(C`\-ab\*(C'\fR) and \f(CW\*(C`require_order\*(C'\fR (no mixing of
options and arguments).
.PP
Above, we've added a \f(CW\*(C`\-\-verbose\*(C'\fR option to the \f(CW\*(C`show\*(C'\fR command, and a
specific \f(CW\*(C`\-\-timezone\*(C'\fR option to the \f(CW\*(C`clock\*(C'\fR sub-command.
.PP
The following commands should be allowed now:
.PP
.Vb 1
\&    bash$ perl tutorial/example_16_options.pl
\&    
\&    [Welcome to BSSH]
\&    bssh> help show clock
\&      Usage:
\&        show clock [\-\-timezone=s] [\-\-tz=s] [\-ts]
\&    
\&      Description:
\&        Show system time and date.
\&    bssh> show clock
\&    Wed Feb 21 15:40:46 2018
\&    bssh> show \-\-verbose clock \-\-tz=UTC
\&    Wed Feb 21 14:41:02 2018
\&    bssh> show clock \-t UTC
\&    Wed Feb 21 14:41:05 2018
.Ve
.PP
However, the \f(CW\*(C`\-\-verbose\*(C'\fR option cannot be specified after \f(CW\*(C`clock\*(C'\fR:
.PP
.Vb 2
\&    bssh> show clock \-\-verbose \-\-tz=UTC
\&    ERROR: Unknown option: verbose
.Ve
.PP
Note, though, that the \f(CW\*(C`\-\-verbose\*(C'\fR option after \f(CW\*(C`show\*(C'\fR \fIis\fR recorded
in the \f(CW\*(C`options\*(C'\fR hash when \f(CW\*(C`do_show_clock\*(C'\fR is called:
.PP
.Vb 10
\&    bssh> debug show \-\-verbose clock \-\-tz CET
\&    Tue Feb 21 14:41:45 2018
\&    # \-\-\- DEBUG \-\-\-
\&    {
\&      \*(Aqoptions\*(Aq => {
\&        \*(Aqverbose\*(Aq => 1,
\&        \*(Aqtimezone\*(Aq => \*(AqCET\*(Aq
\&      },
\&      \*(Aqerror\*(Aq => \*(Aq\*(Aq,
\&      \*(Aqarguments\*(Aq => [],
\&      \*(Aqcommand_path\*(Aq => [
\&        \*(AqTerm::CLI=HASH(0x55efdbf10bc8)\*(Aq,
\&        \*(AqTerm::CLI::Command=HASH(0x55efdc040a28)\*(Aq,
\&        \*(AqTerm::CLI::Command=HASH(0x55efdc040fe0)\*(Aq,
\&        \*(AqTerm::CLI::Command=HASH(0x55efdc041070)\*(Aq
\&      ],
\&      \*(Aqstatus\*(Aq => 0
\&    }
\&    # \-\-\- DEBUG \-\-\-
.Ve
.PP
If you want \f(CW\*(C`\-\-verbose\*(C'\fR to be valid after \f(CW\*(C`clock\*(C'\fR, you'll need to
specify it explicitly in its options:
.PP
.Vb 4
\&    Term::CLI::Command\->new( name => \*(Aqclock\*(Aq,
\&        options => [ \*(Aqverbose|v\*(Aq, \*(Aqtimezone|tz|t=s\*(Aq ],
\&        ...
\&    ),
.Ve
.SH "DEALING WITH HISTORY"
.IX Header "DEALING WITH HISTORY"
By default, the Term::CLI objects do not try to read or write
to history files, so you will have to tell the application to do
so explicitly. Fortunately, that's not hard:
.PP
.Vb 1
\&    $cli\->read_history();
\&
\&    while (defined (my $l = $cli\->readline)) {
\&        ...
\&    }
\&
\&    $cli\->write_history()
\&        or warn "cannot write history: ".$cli\->error."\en";
.Ve
.PP
(Note that we don't raise a warning if we cannot read the history
file: you don't want to get a warning if you run the application
for the first time.)
.PP
By default, if the application is named \f(CW\*(C`bssh\*(C'\fR, the history will
be read/written to/from \f(CW\*(C`~/.bssh_history\*(C'\fR, and Term::CLI will
remember 1000 lines of input history.
.PP
See the \s-1HISTORY CONTROL\s0 
section in the Term::CLI documentation for more information
on how to change the defaults.
.SH "COMPARISON WITH OTHER IMPLEMENTATIONS"
.IX Header "COMPARISON WITH OTHER IMPLEMENTATIONS"
Here are some examples of how you might go about it without
Term::CLI. We've only decided to imlement a few of the
simpler commands.
.SS "Naive implementation"
.IX Subsection "Naive implementation"
The \*(L"naive\*(R" implementation uses no fancy modules, just a loop
reading from \fI\s-1STDIN\s0\fR and some explicit \f(CW\*(C`if\*(C'\fR statements matching
the commands:
.PP
.Vb 3
\&    use Modern::Perl;
\&    use Text::ParseWords qw( shellwords );
\&    use Term::ReadLine;
\&
\&    print "bssh> ";
\&    while (<>) {
\&        next if /^\es*(?:#.*)?$/; # Skip comments and empty lines.
\&        evaluate_input($_);
\&    } continue {
\&        print "bssh> ";
\&    }
\&    print "\en";
\&    execute_exit(\*(Aqexit\*(Aq, 0);
\&
\&    sub evaluate_input {
\&        my $cmd_line = shift;
\&        my @cmd_line = shellwords($cmd_line);
\&        if (!@cmd_line) {
\&            say STDERR "cannot parse input (unbalanced quote?)";
\&            return;
\&        }
\&        return execute_cp(@cmd_line)    if $cmd_line[0] eq \*(Aqcp\*(Aq;
\&        return execute_echo(@cmd_line)  if $cmd_line[0] eq \*(Aqecho\*(Aq;
\&        return execute_exit(@cmd_line)  if $cmd_line[0] eq \*(Aqexit\*(Aq;
\&        return execute_ls(@cmd_line)    if $cmd_line[0] eq \*(Aqls\*(Aq;
\&        return execute_make(@cmd_line)  if $cmd_line[0] eq \*(Aqmake\*(Aq;
\&        return execute_sleep(@cmd_line) if $cmd_line[0] eq \*(Aqsleep\*(Aq;
\&        say STDERR "unknown command: \*(Aq$cmd_line[0]\*(Aq";
\&    }
\&
\&    sub execute_cp { ... }
\&    sub execute_ls { ... }
\&    sub execute_echo { ... }
\&    sub execute_exit { ... }
\&    sub execute_sleep { ... }
\&
\&    sub execute_make {
\&        my ($cmd, @args) = @_;
\&        if (@args != 2) {
\&            say STDERR "$cmd: need exactly two arguments";
\&            return;
\&        }
\&        if ($args[0] !~ /^(love|money)$/) {
\&            say STDERR "$cmd: unknown target \*(Aq$args[0]\*(Aq";
\&            return;
\&        }
\&        elsif ($args[1] !~ /^(now|later|never|forever)$/) {
\&            say STDERR "$cmd: unknown period \*(Aq$args[0]\*(Aq";
\&            return;
\&        }
\&        say "making $args[0] $args[1]";
\&    }
.Ve
.PP
(This full script can be found in as \fIexamples/simple_cli.pl\fR in the source
distribution.)
.PP
This performs the basic actions, but does not offer anything else.
.SS "\s-1IMPLEMENTATION WITH TERM::READLINE\s0"
.IX Subsection "IMPLEMENTATION WITH TERM::READLINE"
Replacing the \s-1REPL\s0 above by a Term::ReadLine(3p) construction, we get:
.PP
.Vb 3
\&    use Modern::Perl;
\&    use Text::ParseWords qw( shellwords );
\&    use Term::ReadLine;
\&
\&    my $term = Term::ReadLine\->new(\*(Aqbssh\*(Aq);
\&    while (defined(my $cmd_line = $term\->readline(\*(Aqbssh> \*(Aq))) {
\&        evaluate_input($_);
\&    }
\&    execute_exit(\*(Aqexit\*(Aq, 0);
.Ve
.PP
(This script can be found as \fIexamples/readline_cli.pl\fR in the source
distribution.)
.PP
This adds a few nice features:
.IP "\(bu" 4
Input editing
.IP "\(bu" 4
History
.PP
But lacks some others:
.IP "\(bu" 4
Command line completion
.Sp
By default Term::ReadLine performs
file name completion, so e.g. the \f(CW\*(C`make\*(C'\fR command will show file name completions,
not the valid targets.
.Sp
It's possible to set up custom completion routines, but it's not trivial.
.IP "\(bu" 4
Command and parameter abbreviation
.Sp
You can't write \f(CW\*(C`ex 0\*(C'\fR, or \f(CW\*(C`m l a\*(C'\fR.
.Sp
To support abbreviations, you'd have to add prefix matching in the
\&\f(CW\*(C`evaluate_input\*(C'\fR and various \f(CW\*(C`execute_*\*(C'\fR routines, making sure
to do something sensible with ambiguous prefixes (e.g. throwing an
error). You'd have to do that for every sub\-command/parameter, though.
.IP "\(bu" 4
Built-in help
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Term::CLI::Intro(3p).
.PP
Getopt::Long(3p),
Term::CLI(3p),
Term::CLI::Argument(3p),
Term::CLI::Argument::Bool(3p),
Term::CLI::Argument::Enum(3p),
Term::CLI::Argument::FileName(3p),
Term::CLI::Argument::Number(3p),
Term::CLI::Argument::Number::Float(3p),
Term::CLI::Argument::Number::Int(3p),
Term::CLI::Argument::String(3p),
Term::CLI::Command(3p),
Term::CLI::Role::CommandSet(3p),
Term::ReadLine(3p).
.SH "FILES"
.IX Header "FILES"
The following files in the source distribution illustrate the examples above:
.IP "\fIexamples/simple_cli.pl\fR" 4
.IX Item "examples/simple_cli.pl"
The \*(L"naive\*(R" implementation with a simple read loop.
.IP "\fIexamples/readline_cli.pl\fR" 4
.IX Item "examples/readline_cli.pl"
The simple Term::ReadLine implementation that adds
command line editing,
filename completion,
and command history.
.IP "\fItutorial/term_cli.pl\fR" 4
.IX Item "tutorial/term_cli.pl"
The full-blown Term::CLI implementation with all of the
features of \fItutorial/readline_cli.pl\fR, adding all the goodness.
.IP "\fItutorial/example_01.pl\fR ... \fItutorial/example_16.pl\fR" 4
.IX Item "tutorial/example_01.pl ... tutorial/example_16.pl"
The tutorial code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven Bakker <sbakker@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2018 Steven Bakker
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. See \*(L"perldoc perlartistic.\*(R"
.PP
This software is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
