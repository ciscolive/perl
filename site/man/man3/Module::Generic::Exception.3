.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic::Exception 3"
.TH Module::Generic::Exception 3 "2020-05-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic::Exception \- Generic Module Exception Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&    my $ex = Module::Generic::Exception\->new({
\&        code => 404,
\&        type => $error_type,
\&        file => \*(Aq/home/joe/some/lib/My/Module.pm\*(Aq,
\&        line => 120,
\&        message => \*(AqInvalid property provided\*(Aq,
\&        package => \*(AqMy::Module\*(Aq,
\&        subroutine => \*(Aqcustomer_info\*(Aq,
\&    });
\&
\&    print( "Error stack trace: ", $ex\->stack_trace, "\en" );
\&    # or
\&    $object\->customer_orders || die( "Error in file ", $object\->error\->file, " at line ", $object\->error\->line, "\en" );
\&    # or simply:
\&    $object\->customer_orders || die( "Error: ", $object\->error, "\en" );
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.1.0
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple and straightforward exception class you can use or inherit from. The error object can be stringified or compared.
.PP
When stringified, it provides the error message along with precise information about where the error occurred and a stack trace.
.PP
Module::Generic::Exception objects are created by \*(L"error\*(R" in Module::Generic method.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
It takes either an Module::Generic::Exception object or an hash reference of properties, or a list of arguments that will be concatanated to form the error message. The list of arguments can contain code reference such as reference to sub routines, who will be called and their returned value added to the error message string. For example :
.PP
.Vb 1
\&    my $ex = Module::Generic::Exception\->new( "Invalid property. Value recieved are: ", sub{ Dumper( $hash ) } );
\&
\&    # or
\&
\&    my $ex = Module::Generic::Exception\->new( $other_exception_object_for_reuse );
\&    # This will the I<object> property
\&
\&    # or
\&
\&    my #ex = Module::Generic::Exception\->new({
\&        message => "Invalid property.",
\&        code => 404,
\&        type => \*(Aqcustomer\*(Aq,
\&    })
.Ve
.PP
Possible properties that can be specified are :
.IP "\fIcode\fR" 4
.IX Item "code"
An error code
.IP "\fIfile\fR" 4
.IX Item "file"
The localtion where the error occurred. This is populated using the \*(L"filename\*(R" in Devel::StackTrace
.IP "\fIline\fR" 4
.IX Item "line"
The line number in the file where the error occurred.This is populated using the \*(L"line\*(R" in Devel::StackTrace
.IP "\fImessage\fR" 4
.IX Item "message"
The error message. It can be provided as a list of arguments that will be concatenated, or as the \fImessage\fR property in an hash reference, or copied from another exception object passed as the sole argument.
.IP "\fIobject\fR" 4
.IX Item "object"
When this is set, such as when another Module::Generic::Exception object is provided as unique argument, then the properties \fImessage\fR, \fIcode\fR, \fItype\fR, \fIretry_after\fR are copied from it in the new exception object.
.IP "\fIpackage\fR" 4
.IX Item "package"
The package name where the error occurred.  This is populated using the \*(L"package\*(R" in Devel::StackTrace
.IP "\fIretry_after\fR" 4
.IX Item "retry_after"
An optional value to indicate in seconds how long to wait to retry.
.IP "\fIskip_frames\fR" 4
.IX Item "skip_frames"
This is used as a parameter to Devel::StackTrace upon instantiation to instruct how many it should skip to start creating the stack trace.
.IP "\fIsubroutine\fR" 4
.IX Item "subroutine"
The name of the sub routine from which this was called.  This is populated using the \*(L"subroutine\*(R" in Devel::StackTrace
.IP "\fItype\fR" 4
.IX Item "type"
An optional error type
.PP
It returns the exception object.
.SS "as_string"
.IX Subsection "as_string"
This returns a string representation of the Exception such as :
.PP
.Vb 2
\&    Invalid property within package My::Module at line 120 in file /home/john/lib/My/Module.pm
\&        # then some strack trace here
.Ve
.SS "caught"
.IX Subsection "caught"
.Vb 10
\&    use Nice::Try;
\&    try
\&    {
\&        # An error made with Module::Generic::Exception
\&        die( $object\->error );
\&    }
\&    catch( $e )
\&    {
\&        # If this error is one of ours
\&        if( Module::Generic::Exception\->caught( $e ) )
\&        {
\&            # Do something about it
\&        }
\&    }
.Ve
.PP
But Nice::Try let's you do this:
.PP
.Vb 8
\&    try
\&    {
\&        die( $object\->error );
\&    }
\&    catch( Module::Generic::Exception $e )
\&    {
\&        # Do something about it
\&    }
.Ve
.SS "code"
.IX Subsection "code"
Set or get the error code. It returns the current value.
.SS "file"
.IX Subsection "file"
Set or get the file path where the error originated. It returns the current value.
.SS "line"
.IX Subsection "line"
Set or get the line where the error originated. It returns the current value.
.SS "message"
.IX Subsection "message"
Set or get the error message. It returns the current value.
.PP
It takes a string, or a list of strings which will be concatenated.
.PP
For example :
.PP
.Vb 1
\&    $ex\->messsage( "I found some error:", $some_data );
.Ve
.SS "package"
.IX Subsection "package"
Set or get the class/package name where the error originated. It returns the current value.
.SS "rethrow"
.IX Subsection "rethrow"
This rethrow (i.e. \*(L"die\*(R" in perlfunc) the original error. It must be called with the exception object or else it will return undef.
.PP
This is ok :
.PP
.Vb 1
\&    $ex\->rethrow;
.Ve
.PP
But this is not :
.PP
.Vb 1
\&    Module::Generic::Exception\->rethrow;
.Ve
.SS "retry_after"
.IX Subsection "retry_after"
Set or get the number of seconds to way before to retry whatever cause the error. It returns the current value.
.SS "subroutine"
.IX Subsection "subroutine"
Set or get the subroutine where the error originated. It returns the current value.
.SS "throw"
.IX Subsection "throw"
Provided with a message string, this will create a new Module::Generic::Exception object and call \*(L"die\*(R" in perlfunc with it.
.SS "trace"
.IX Subsection "trace"
Set or get the Devel::StackTrace object used to provide a full stack trace of the error. It returns the current value.
.SS "type"
.IX Subsection "type"
Set or get the error type. It returns the current value.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2000\-2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated
files under the same terms as Perl itself.
