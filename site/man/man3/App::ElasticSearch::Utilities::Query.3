.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "App::ElasticSearch::Utilities::Query 3"
.TH App::ElasticSearch::Utilities::Query 3 "2020-09-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::ElasticSearch::Utilities::Query \- Object representing ES Queries
.SH "VERSION"
.IX Header "VERSION"
version 7.8
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "fields_meta"
.IX Subsection "fields_meta"
A hash reference with the field data from App::ElasticSearch::Utilities::es_index_fields.
.SS "query_stash"
.IX Subsection "query_stash"
Hash reference containing replaceable query elements.  See stash.
.SS "scroll_id"
.IX Subsection "scroll_id"
The scroll id for the last executed query.  You shouldn't mess with this
directly. It's best to use the \fBexecute()\fR and \fBscroll_results()\fR methods.
.SS "must"
.IX Subsection "must"
The must section of a bool query as an array reference.  See: add_bool
Can be set using set_must and is a valid init_arg.
.SS "must_not"
.IX Subsection "must_not"
The must_not section of a bool query as an array reference.  See: add_bool
Can be set using set_must_not and is a valid init_arg.
.SS "should"
.IX Subsection "should"
The should section of a bool query as an array reference.  See: add_bool
Can be set using set_should and is a valid init_arg.
.SS "minimum_should_match"
.IX Subsection "minimum_should_match"
A string defining the minimum number of should conditions to qualify a match.
See <https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query\-dsl\-minimum\-should\-match.html>
.SS "filter"
.IX Subsection "filter"
The filter section of a bool query as an array reference.  See: add_bool
Can be set using set_filter and is a valid init_arg.
.SS "nested"
.IX Subsection "nested"
The nested query, this shortcircuits the rest of the query due to restrictions
on the nested queries.
.SS "nested_path"
.IX Subsection "nested_path"
The path by being nested, only used in nested queries.
.SS "from"
.IX Subsection "from"
Integer representing the offset the query should start returning documents from.  The default is undefined, which
falls back on the Elasticsearch default of 0, or from the beginning.
Can be set with \fBset_from\fR.  Cannot be an init_arg.
.SS "size"
.IX Subsection "size"
The number of documents to return in the query.  The default size is \fB50\fR.
Can be set with \fBset_size\fR.  Cannot be an init_arg.
.SS "fields"
.IX Subsection "fields"
An array reference containing the names of the fields to retrieve with the query.  The default is undefined, which
falls back on the Elasticsearch default of empty, or no fields retrieved.  The \fB_source\fR is still retrieved.
Can be set with \fBset_fields\fR.  Cannot be an init_arg.
.SS "sort"
.IX Subsection "sort"
An array reference of sorting keys/directions.  The default is undefined, which falls back on the Elasticsearch
default of \fBscore:desc\fR.
Can be set with \fBset_sort\fR.  Cannot be an init_arg.
.SS "aggregations"
.IX Subsection "aggregations"
A hash reference of aggergations to perform.  The default is undefined, which means do not perform any aggregations.
Can be set with \fBset_aggregations\fR, which is aliased as \fBset_aggs\fR.  Cannot be an init_arg.
Aliased as \fBaggs\fR.
.SS "scroll"
.IX Subsection "scroll"
An ElasticSearch time constant <https://www.elastic.co/guide/en/elasticsearch/reference/master/common-options.html#time-units>.
The default is undefined, which means scroll will not be set on a query.
Can be set with \fBset_scroll\fR.  Cannot be an init_arg.
See also: set_scan_scroll.
.SS "timeout"
.IX Subsection "timeout"
An ElasticSearch time constant <https://www.elastic.co/guide/en/elasticsearch/reference/master/common-options.html#time-units>.
The default is undefined, which means it will default to the connection timeout.
Can be set with \fBset_timeout\fR.  Cannot be an init_arg.
.SS "terminate_after"
.IX Subsection "terminate_after"
The number of documents to cancel the search after.  This generally shouldn't be used except for
large queries where you are protecting against \s-1OOM\s0 Errors. The \fBsize\fR attribute is more accurate as it's
truncation occurs after the reduce operation, where \fBterminate_after\fR occurs during the map phase of the query.
Can be set with \fBset_terminateafter\fR.  Cannot be an init_arg.
.SS "track_total_hits"
.IX Subsection "track_total_hits"
Should the query attempt to calculate the number of hits the query would match.
Defaults to \f(CW\*(C`true\*(C'\fR.
.SS "track_scores"
.IX Subsection "track_scores"
Set to true to score every hit in the search results, set to false to not
report scores.  Defaults to unset, i.e., use the ElasticSearch default.
.SS "rest_total_hits_as_int"
.IX Subsection "rest_total_hits_as_int"
In ElasticSearch 7.0, the total hits element became a hash reference with more
details.  Since most of the tooling relies on the old behavior, this defaults
to \f(CW\*(C`true\*(C'\fR.
.SS "search_type"
.IX Subsection "search_type"
Choose an execution path for the query.  This is null by default, but you can
set it to a valid `search_type` setting, see:
<https://www.elastic.co/guide/en/elasticsearch/reference/current/search\-request\-body.html#request\-body\-search\-search\-type>
.SH "METHODS"
.IX Header "METHODS"
.SS "as_search( [ 'index1', 'index2' ] )"
.IX Subsection "as_search( [ 'index1', 'index2' ] )"
Returns a list of parameters to pass directly to \f(CW\*(C`es_request()\*(C'\fR.
.ie n .SS "execute( [ $index1, $index2 ] )"
.el .SS "execute( [ \f(CW$index1\fP, \f(CW$index2\fP ] )"
.IX Subsection "execute( [ $index1, $index2 ] )"
Uses `\fBes_request()\fR` to return the result, stores any relevant scroll data.
.SS "\fBscroll_results()\fP"
.IX Subsection "scroll_results()"
If a scroll has been set, this will construct and run the requisite scroll
search, otherwise it returns undef.
.SS "\fBuri_params()\fP"
.IX Subsection "uri_params()"
Retrieves the \s-1URI\s0 parameters for the query as a hash reference.  Undefined parameters
will not be represented in the hash.
.SS "\fBrequest_body()\fP"
.IX Subsection "request_body()"
Builds and returns a hash reference representing the request body for the
Elasticsearch query.  Undefined elements will not be represented in the hash.
.SS "\fBquery()\fP"
.IX Subsection "query()"
Builds and returns a hash reference represnting the bool query section of the
request body.  This function is called by the request_body function but is
useful and distinct enough to expose as it's own method.  Undefined elements of
the query will not be represented in the hash it returns.
.SS "add_aggregations( name => { ...  } )"
.IX Subsection "add_aggregations( name => { ... } )"
Takes one or more key-value pairs.  The key is the name of the aggregation.
The value being the hash reference representation of the aggregation itself.
It will silently replace a previously named aggregation with the most recent
call.
.PP
Calling this function overrides the size element to \fB0\fR and disables scroll.
.PP
Aliased as \fBadd_aggs\fR.
.SS "wrap_aggregations( name => { ... } )"
.IX Subsection "wrap_aggregations( name => { ... } )"
Use this to wrap an aggregation in another aggregation.  For example:
.PP
.Vb 1
\&    $q\->add_aggregations(ip => { terms => { field => src_ip } });
.Ve
.PP
Creates:
.PP
.Vb 9
\&    {
\&        "aggs": {
\&            "ip": {
\&                "terms": {
\&                    "field": "src_ip"
\&                }
\&            }
\&        }
\&    }
.Ve
.PP
Would give you the top \s-1IP\s0 for the whole query set.  To wrap that aggregation to get top IPs per hour, you could:
.PP
.Vb 1
\&    $q\->wrap_aggregations( hourly => { date_histogram => { field => \*(Aqtimestamp\*(Aq, interval => \*(Aq1h\*(Aq } } );
.Ve
.PP
Which translates the query into:
.PP
.Vb 10
\&    {
\&        "aggs": {
\&            "hourly": {
\&                "date_histogram": {
\&                    "field": "timestamp",
\&                    "interval": "1h"
\&                }
\&                "aggs": {
\&                    "ip": {
\&                        "terms": {
\&                            "field": "src_ip"
\&                        }
\&                    }
\&                }
\&            }
\&        }
\&    }
.Ve
.SS "set_scan_scroll($ctxt_life)"
.IX Subsection "set_scan_scroll($ctxt_life)"
This function emulates the old scan scroll feature in early version of Elasticsearch. It takes
an optional  ElasticSearch time constant <https://www.elastic.co/guide/en/elasticsearch/reference/master/common-options.html#time-units>,
but defaults to '1m'.  It is the same as calling:
.PP
.Vb 2
\&    $self\->set_sort( [qw(_doc)] );
\&    $self\->set_scroll( $ctxt_life );
.Ve
.SS "\fBset_match_all()\fP"
.IX Subsection "set_match_all()"
This method clears all filters and query elements to and sets the must to match_all.
It will not reset other parameters like size, sort, and aggregations.
.SS "add_bool( section => conditions .. )"
.IX Subsection "add_bool( section => conditions .. )"
Appends a search condition to a section in the query body.  Valid query body
points are: must, must_not, should, and filter.
.PP
.Vb 1
\&    $q\->add_bool( must => { term => { http_status => 200 } } );
\&
\&    # or
\&
\&    $q\->add_bool(
\&        must => [
\&            { term => { http_method => \*(AqGET\*(Aq } }
\&            { term => { client_ip   => \*(Aq10.10.10.1\*(Aq } }
\&        ]
\&        must_not => { term => { http_status => 400 } },
\&    );
.Ve
.SS "stash( section => condition )"
.IX Subsection "stash( section => condition )"
Allows a replaceable query element to exist in the query body sections: must, must_not,
should, and/or filter.  This is useful for moving through a data-set preserving everthing in a query
except one piece that shifts.  Imagine:
.PP
.Vb 3
\&    my $query = App::ElasticSearch::Utilities::Query\->new();
\&    $query\->add_bool(must => { terms => {src_ip => [qw(1.2.3.4)]} });
\&    $query\->add_bool(must => { range => { attack_score => { gt => 10 }} });
\&
\&    while( 1 ) {
\&        $query\->stash( must => { range => { timestamp => { gt => time() } } } );
\&        my @results = make_es_request( $query\->request_body, $query\->uri_params );
\&
\&        # Long processing
\&    }
.Ve
.PP
This allows re-use of the query object inside of loops like this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Brad Lhotsky <brad@divisionbyzero.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Brad Lhotsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The (three\-clause) BSD License
.Ve
