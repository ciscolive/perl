.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Module::List 3"
.TH Module::List 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::List \- module `directory' listing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Module::List qw(list_modules);
\&
\&    $id_modules = list_modules("Data::ID::", { list_modules => 1});
\&    $prefixes = list_modules("",
\&                    { list_prefixes => 1, recurse => 1 });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module deals with the examination of the namespace of Perl modules.
The contents of the module namespace is split across several physical
directory trees, but this module hides that detail, providing instead
a view of the abstract namespace.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "list_modules(\s-1PREFIX, OPTIONS\s0)" 4
.IX Item "list_modules(PREFIX, OPTIONS)"
This function generates a listing of the contents of part of the module
namespace.  The part of the namespace under the module name prefix \s-1PREFIX\s0
is examined, and information about it returned as specified by \s-1OPTIONS.\s0
.Sp
Module names are handled by this function in standard bareword syntax.
They are always fully-qualified; isolated name components are never used.
A module name prefix is the part of a module name that comes before
a component of the name, and so either ends with \*(L"::\*(R" or is the empty
string.
.Sp
\&\s-1OPTIONS\s0 is a reference to a hash, the elements of which specify what is
to be returned.  The options are:
.RS 4
.IP "list_modules" 4
.IX Item "list_modules"
Truth value, default false.  If true, return names of modules in the relevant
part of the namespace.
.IP "list_prefixes" 4
.IX Item "list_prefixes"
Truth value, default false.  If true, return module name prefixes in the
relevant part of the namespace.  Note that prefixes are returned if the
corresponding directory exists, even if there is nothing in it.
.IP "list_pod" 4
.IX Item "list_pod"
Truth value, default false.  If true, return names of \s-1POD\s0 documentation
files that are in the module namespace.
.IP "trivial_syntax" 4
.IX Item "trivial_syntax"
Truth value, default false.  If false, only valid bareword names are
permitted.  If true, bareword syntax is ignored, and any \*(L"::\*(R"\-separated
name that can be turned into a correct filename by interpreting name
components as filename components is permitted.  This is of no use in
listing actual Perl modules, because the illegal names can't be used in
Perl, but some programs such as \fBperldoc\fR use a \*(L"::\*(R"\-separated name for
the sake of appearance without really using bareword syntax.  The loosened
syntax applies both to the names returned and to the \fI\s-1PREFIX\s0\fR parameter.
.Sp
Precisely, the `trivial syntax' is that each \*(L"::\*(R"\-separated component
cannot be \*(L".\*(R" or \*(L"..\*(R", cannot contain \*(L"::\*(R" or \*(L"/\*(R", and (except for the
final component of a leaf name) cannot end with \*(L":\*(R".  This is precisely
what is required to achieve a unique interconvertible \*(L"::\*(R"\-separated path
syntax on Unix.  This criterion might change in the future on non-Unix
systems, where the filename syntax differs.
.IP "recurse" 4
.IX Item "recurse"
Truth value, default false.  If false, only names at the next level down
from \s-1PREFIX\s0 (having one more component) are returned.  If true, names
at all lower levels are returned.
.IP "use_pod_dir" 4
.IX Item "use_pod_dir"
Truth value, default false.  If false, \s-1POD\s0 documentation files are
expected to be in the same directory that the corresponding module file
would be in.  If true, \s-1POD\s0 files may also be in a subdirectory of that
named "\f(CW\*(C`pod\*(C'\fR\*(L".  (Any \s-1POD\s0 files in such a subdirectory will therefore be
visible under two module names, one treating the \*(R"\f(CW\*(C`pod\*(C'\fR" subdirectory
level as part of the module name.)
.IP "return_path" 4
.IX Item "return_path"
Truth value, default false.  If false, only the existence of requested
items is reported.  If true, the pathnames of the files in which they
exist are reported.
.RE
.RS 4
.Sp
Note that the default behaviour, if an empty options hash is supplied, is
to return nothing.  You \fImust\fR specify what kind of information you want.
.Sp
The function returns a reference to a hash, the keys of which are the
names of interest.  By default, the value associated with each of these
keys is undef.  If additional information about each item was requested,
the value for each item is a reference to a hash, containing some subset
of these items:
.IP "module_path" 4
.IX Item "module_path"
Pathname of the module of this name.  Specifically, this identifies
the file that would be read in order to load the module.  This may be
a \f(CW\*(C`.pmc\*(C'\fR file if one is available.  Absent if there is no module.
.IP "pod_path" 4
.IX Item "pod_path"
Pathname of the \s-1POD\s0 document of this name.  Absent if there is no
discrete \s-1POD\s0 document.  (\s-1POD\s0 in a module file doesn't constitute a
discrete \s-1POD\s0 document.)
.IP "prefix_paths" 4
.IX Item "prefix_paths"
Reference to an array of the pathnames of the directories referenced
by this prefix.  The directories are listed in the order corresponding
to \f(CW@INC\fR.  Absent if this is not a prefix.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Runtime
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004, 2006, 2009, 2011, 2017
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
