.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Term::CLI 3"
.TH Term::CLI 3 "2019-11-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::CLI \- CLI interpreter based on Term::ReadLine
.SH "VERSION"
.IX Header "VERSION"
version 0.051007
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Term::CLI;
\& use Term::CLI::Command;
\& use Term::CLI::Argument::Filename;
\& use Data::Dumper;
\&
\& my $cli = Term::CLI\->new(
\&    name => \*(Aqmyapp\*(Aq,
\&    prompt => \*(Aqmyapp> \*(Aq,
\&    callback => sub {
\&        my ($self, %args) = @_;
\&        print Data::Dumper\->Dump([\e%args], [\*(Aqargs\*(Aq]);
\&        return %args;
\&    },
\&    commands => [
\&        Term::CLI::Command\->new(
\&            name => \*(Aqcopy\*(Aq,
\&            options => [ \*(Aqverbose!\*(Aq ],
\&            arguments => [
\&                Term::CLI::Argument::Filename\->new(name => \*(Aqsrc\*(Aq),
\&                Term::CLI::Argument::Filename\->new(name => \*(Aqdst\*(Aq),
\&            ],
\&            callback => sub {
\&                my ($self, %args) = @_;
\&                print Data::Dumper\->Dump([\e%args], [\*(Aqargs\*(Aq]);
\&                return (%args, status => 0);
\&            }
\&        )
\&    ],
\& );
\&
\& $cli\->read_history;  # Read history from ~/.myapp_history
\& $cli\->write_history; # Write history to ~/.myapp_history
\&
\& $cli\->word_delimiters(\*(Aq;,\*(Aq);
\& # $cli will now recognise things like: \*(Aqcopy;\-\-verbose;a,b\*(Aq
\&
\& $cli\->word_delimiters(" \et\en");
\& # $cli will now recognise things like: \*(Aqcopy \-\-verbose a b\*(Aq
\&
\& while ( my $input = $cli\->readline(skip => qr/^\es*(?:#.*)?$/) ) {
\&    $cli\->execute($input);
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Implement an easy-to-use command line interpreter based on
Term::ReadLine(3p) and Term::ReadLine::Gnu(3p).
.PP
First-time users may want to read Term::CLI::Tutorial(3p)
and Term::CLI::Intro(3p) first, and peruse the example
scripts in the source distribution's \fIexamples\fR and
\&\fItutorial\fR directories.
.SH "CLASS STRUCTURE"
.IX Header "CLASS STRUCTURE"
.SS "Inherits from:"
.IX Subsection "Inherits from:"
Term::CLI::Base(3p).
.SS "Consumes:"
.IX Subsection "Consumes:"
Term::CLI::Role::CommandSet(3p).
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "\fBnew\fR ( \fBattr\fR => \fI\s-1VAL\s0\fR ... )" 4
.IX Xref "new"
.IX Item "new ( attr => VAL ... )"
Create a new \f(CW\*(C`Term::CLI\*(C'\fR object and return a reference to it.
.Sp
Valid attributes:
.RS 4
.IP "\fBcallback\fR => \fICodeRef\fR" 4
.IX Item "callback => CodeRef"
Reference to a subroutine that should be called when the command
is executed, or \f(CW\*(C`undef\*(C'\fR.
.IP "\fBcommands\fR => \fIArrayRef\fR" 4
.IX Item "commands => ArrayRef"
Reference to an array containing Term::CLI::Command object
instances that describe the commands that \f(CW\*(C`Term::CLI\*(C'\fR recognises,
or \f(CW\*(C`undef\*(C'\fR.
.IP "\fBname\fR => \fIStr\fR" 4
.IX Item "name => Str"
The application name. This is used for e.g. the history file
and default command prompt.
.Sp
If not given, defaults to \f(CW$FindBin::Script\fR (see FindBin(3p)).
.IP "\fBprompt\fR => \fIStr\fR" 4
.IX Item "prompt => Str"
Prompt to display when readline is called. Defaults
to the application name with \f(CW\*(C`>\*(C'\fR and a space appended.
.IP "\fBskip\fR => \fIRegEx\fR" 4
.IX Item "skip => RegEx"
Set the object's skip attribute, telling the
readline method to ignore input lines
that match the given \fIRegEx\fR.
A common call value is \f(CW\*(C`qr{^\es+(?:#.*)$}\*(C'\fR to skip
empty lines, lines with only whitespace, and comments.
.IP "\fBhistory_file\fR => \fIStr\fR" 4
.IX Item "history_file => Str"
Specify the file to read/write input history to/from.
The default is \fIname\fR + \f(CW\*(C`_history\*(C'\fR in the user's
\&\fI\s-1HOME\s0\fR directory.
.IP "\fBhistory_lines\fR => \fIStr\fR" 4
.IX Item "history_lines => Str"
Maximum number of lines to keep in the input history.
Default is 1000.
.RE
.RS 4
.RE
.SH "INHERITED METHODS"
.IX Header "INHERITED METHODS"
This class inherits all the attributes and accessors of
Term::CLI::Role::CommandSet(3p) and Term::CLI::Base(3p),
most notably:
.SS "Accessors"
.IX Subsection "Accessors"
.IP "\fBhas_callback\fR" 4
.IX Xref "has_callback"
.IX Item "has_callback"
See
has_callback in Term::CLI::Role::CommandSet.
.IP "\fBhas_commands\fR" 4
.IX Xref "has_commands"
.IX Item "has_commands"
See
has_commands in Term::CLI::Role::CommandSet.
.IP "\fBcommands\fR ( [ \fIArrayRef\fR ] )" 4
.IX Xref "commands"
.IX Item "commands ( [ ArrayRef ] )"
See
commands in Term::CLI::Role::CommandSet.
.Sp
\&\fIArrayRef\fR with \f(CW\*(C`Term::CLI::Command\*(C'\fR object instances.
.IP "\fBcallback\fR ( [ \fICodeRef\fR ] )" 4
.IX Xref "callback"
.IX Item "callback ( [ CodeRef ] )"
See
callback in Term::CLI::Role::CommandSet.
.SS "Others"
.IX Subsection "Others"
.IP "\fBfind_command\fR ( \fIStr\fR )" 4
.IX Xref "find_command"
.IX Item "find_command ( Str )"
See
find_command in Term::CLI::Role::CommandSet.
.IP "\fBfind_matches\fR ( \fIStr\fR )" 4
.IX Xref "find_matches"
.IX Item "find_matches ( Str )"
See
find_matches in Term::CLI::Role::CommandSet.
.SH "METHODS"
.IX Header "METHODS"
.SS "Accessors"
.IX Subsection "Accessors"
.IP "\fBname\fR" 4
.IX Xref "name"
.IX Item "name"
The application name. 
See
name in Term::CLI::Base.
.IP "\fBprompt\fR ( [ \fIStr\fR ] )" 4
.IX Xref "prompt"
.IX Item "prompt ( [ Str ] )"
Get or set the command line prompt to display to the user.
.IP "\fBterm\fR" 4
.IX Xref "term"
.IX Item "term"
Return a reference to the underlying Term::CLI::ReadLine object.
See
term in Term::CLI::Base.
.IP "\fBquote_characters\fR ( [ \fIStr\fR ] )" 4
.IX Xref "quote_characters"
.IX Item "quote_characters ( [ Str ] )"
Get or set the characters that should considered quote characters
for the completion and parsing/execution routines.
.Sp
Default is \f(CW\*(C`\*(Aq"\*(C'\fR, that is a single quote or a double quote.
.Sp
It's possible to change this, but this will interfere with the default
splitting function, so if you do want custom quote characters, you should
also override the split_function.
.IP "\fBsplit_function\fR ( [ \fICodeRef\fR ] )" 4
.IX Item "split_function ( [ CodeRef ] )"
Get or set the function that is used to split a (partial) command
line into words. The default function uses
Text::ParseWords::parse_line.
Note that this implies that it can take into account custom delimiters,
but \fInot custom quote characters\fR.
.Sp
The \fICodeRef\fR is called as:
.Sp
.Vb 1
\&    ( ERROR, [ WORD, ... ] ) = CodeRef\->( CLI_OBJ, TEXT )
.Ve
.Sp
The function should return a list of at least one element, an
\&\fI\s-1ERROR\s0\fR string. Subsequent elements are the words resulting
from the split.
.Sp
\&\fI\s-1ERROR\s0\fR string should be empty (not \f(CW\*(C`undef\*(C'\fR!) if splitting
was successful, otherwise it should contain a relevant error
message.
.IP "\fBword_delimiters\fR ( [ \fIStr\fR ] )" 4
.IX Item "word_delimiters ( [ Str ] )"
Get or set the characters that are considered word delimiters
in the completion and parsing/execution routines.
.Sp
Default is \f(CW\*(C` \et\en\*(C'\fR, that is \fIspace\fR, \fItab\fR, and \fInewline\fR.
.Sp
The first character in the string is also the character that is
appended to a completed word at the command line prompt.
.SS "History Control"
.IX Subsection "History Control"
.IP "\fBhistory_lines\fR ( [ \fIInt\fR ] )" 4
.IX Item "history_lines ( [ Int ] )"
Get or set the maximum number of lines to keep in the history.
Default is 1000.
.IP "\fBhistory_file\fR ( [ \fIStr\fR ] )" 4
.IX Item "history_file ( [ Str ] )"
Set the default file to read from/write to.
.IP "\fBread_history\fR ( [ \fIStr\fR ] )" 4
.IX Item "read_history ( [ Str ] )"
Try to read input history from the \fBhistory_file()\fR.
Returns 1 on success. On failure, it will set the error
field and return \f(CW\*(C`undef\*(C'\fR.
.Sp
If \fIStr\fR is given, it will try to read from that file instead. If that is
successful, the \fBhistory_file()\fR attribute will be set
to \fIStr\fR.
.IP "\fBwrite_history\fR ( [ \fIStr\fR ] )" 4
.IX Item "write_history ( [ Str ] )"
Try to write the input history to the \fBhistory_file()\fR.
Returns 1 on success. On failure, it will set the error field
and return \f(CW\*(C`undef\*(C'\fR.
.Sp
If \fIStr\fR is given, it will try to write to that file instead. If that is
successful, the \fBhistory_file()\fR attribute will be set
to \fIStr\fR.
.SS "Others"
.IX Subsection "Others"
.IP "\fBcomplete_line\fR ( \fI\s-1TEXT\s0\fR, \fI\s-1LINE\s0\fR, \fI\s-1START\s0\fR )" 4
.IX Xref "complete_line"
.IX Item "complete_line ( TEXT, LINE, START )"
Called when the user hits the \fI\s-1TAB\s0\fR key for completion.
.Sp
\&\fI\s-1TEXT\s0\fR is the text to complete, \fI\s-1LINE\s0\fR is the input line so
far, \fI\s-1START\s0\fR is the position in the line where \fI\s-1TEXT\s0\fR starts.
.Sp
The function will split the line in words and delegate the
completion to the first Term::CLI::Command sub-command,
see Term::CLI::Command.
.IP "\fBreadline\fR ( [ \fI\s-1ATTR\s0\fR => \fI\s-1VAL\s0\fR, ... ] )" 4
.IX Xref "readline"
.IX Item "readline ( [ ATTR => VAL, ... ] )"
Read a line from the input connected to term, using
the Term::ReadLine interface.
.Sp
By default, it returns the line read from the input, or
an empty value if end of file has been reached (e.g.
the user hitting \fICtrl-D\fR).
.Sp
The following \fI\s-1ATTR\s0\fR are recognised:
.RS 4
.IP "\fBskip\fR => \fIRegEx\fR" 4
.IX Item "skip => RegEx"
Override the object's skip attribute.
.Sp
Skip lines that match the \fIRegEx\fR parameter. A common
call is:
.Sp
.Vb 1
\&    $text = CLI\->readline( skip => qr{^\es+(?:#.*)$} );
.Ve
.Sp
This will skip empty lines, lines containing whitespace, and
comments.
.IP "\fBprompt\fR => \fIStr\fR" 4
.IX Item "prompt => Str"
Override the prompt given by the prompt method.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 3
\&    # Just read the next input line.
\&    $line = $cli\->readline;
\&    exit if !defined $line;
\&
\&    # Skip empty lines and comments.
\&    $line = $cli\->readline( skip => qr{^\es*(?:#.*)?$} );
\&    exit if !defined $line;
.Ve
.RE
.IP "\fBexecute\fR ( \fIStr\fR )" 4
.IX Xref "execute"
.IX Item "execute ( Str )"
Parse and execute the command line consisting of \fIStr\fR
(see the return value of readline above).
.Sp
The command line is split into words using
the split_function.
If that succeeds, then the resulting list of words is
parsed and executed, otherwise a parse error is generated
(i.e. the object's callback
function is called with a \f(CW\*(C`status\*(C'\fR of \f(CW\*(C`\-1\*(C'\fR and a suitable \f(CW\*(C`error\*(C'\fR
field).
.Sp
For specifying a custom word splitting method, see
split_function.
.Sp
Example:
.Sp
.Vb 3
\&    while (my $line = $cli\->readline(skip => qr/^\es*(?:#.*)?$/)) {
\&        $cli\->execute($line);
\&    }
.Ve
.Sp
The command line is parsed depth-first, and for every
Term::CLI::Command(3p) encountered, that object's
callback function
is executed (see
callback in Term::CLI::Role::Command).
.RS 4
.IP "\(bu" 4
Suppose that the \f(CW\*(C`file\*(C'\fR command has a \f(CW\*(C`show\*(C'\fR sub-command that takes
an optional \f(CW\*(C`\-\-verbose\*(C'\fR option and a single file argument.
.IP "\(bu" 4
Suppose the input is:
.Sp
.Vb 1
\&    file show \-\-verbose foo.txt
.Ve
.IP "\(bu" 4
Then the parse tree looks like this:
.Sp
.Vb 9
\&    (cli\-root)
\&        |
\&        +\-\-> Command \*(Aqfile\*(Aq
\&                |
\&                +\-\-> Command \*(Aqshow\*(Aq
\&                        |
\&                        +\-\-> Option \*(Aq\-\-verbose\*(Aq
\&                        |
\&                        +\-\-> Argument \*(Aqfoo.txt\*(Aq
.Ve
.IP "\(bu" 4
Then the callbacks will be called in the following order:
.RS 4
.IP "1." 4
Callback for 'show'
.IP "2." 4
Callback for 'file'
.IP "3." 4
Callback for \f(CW\*(C`Term::CLI\*(C'\fR object.
.RE
.RS 4
.Sp
The return value from each callback
(a hash in list form) is fed into the next callback function in the
chain. This allows for adding custom data to the return hash that will
be fed back up the parse tree (and eventually to the caller).
.RE
.RE
.RS 4
.RE
.SH "SIGNAL HANDLING"
.IX Header "SIGNAL HANDLING"
The \f(CW\*(C`Term::CLI\*(C'\fR object sets its own signal handlers in the readline
function.
.PP
The signal handlers will ensure the terminal is in a sane state.
.PP
The following signal handlers discard the the current input line, restore
any previous signal handler, and re-throw the signal:
\&\f(CW\*(C`HUP\*(C'\fR, \f(CW\*(C`INT\*(C'\fR, \f(CW\*(C`QUIT\*(C'\fR, \f(CW\*(C`ALRM\*(C'\fR, \f(CW\*(C`TERM\*(C'\fR, \f(CW\*(C`TTIN\*(C'\fR, \f(CW\*(C`TTOU\*(C'\fR, \f(CW\*(C`TSTP\*(C'\fR.
.PP
The \f(CW\*(C`CONT\*(C'\fR and \f(CW\*(C`WINCH\*(C'\fR signals are treated slightly different: they don't
re-throw the signal, but rather just call any previous signal handler. The
\&\f(CW\*(C`WINCH\*(C'\fR signal handler will not discard the input line.
.PP
It also makes sure that after a keyboard suspend (\f(CW\*(C`TSTP\*(C'\fR) and
subsequent continue (\f(CW\*(C`CONT\*(C'\fR), the command prompt is redrawn:
.PP
.Vb 7
\&    bash$ perl tutorial/term_cli.pl
\&    > foo
\&    > ^Z
\&    [1]+  Stopped                 perl tutorial/term_cli.pl
\&    bash$ fg
\&    perl tutorial/term_cli.pl
\&    > _
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
FindBin(3p),
Getopt::Long(3p),
Term::CLI(3p),
Term::CLI::Argument(3p),
Term::CLI::Command(3p),
Term::CLI::Intro(3p),
Term::CLI::Role::CommandSet(3p),
Term::CLI::Tutorial(3p),
Text::ParseWords(3p),
Types::Standard(3p).
.PP
Inspiration for the custom completion came from:
<https://robots.thoughtbot.com/tab\-completion\-in\-gnu\-readline>.
This is an excellent tutorial into the completion mechanics
of the \f(CW\*(C`readline\*(C'\fR library, and, by extension,
Term::ReadLine::Gnu(3p).
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven Bakker <sbakker@cpan.org>, 2018.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2018 Steven Bakker
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. See \*(L"perldoc perlartistic.\*(R"
.PP
This software is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
