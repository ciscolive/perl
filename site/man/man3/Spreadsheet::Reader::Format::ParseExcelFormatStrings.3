.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::Format::ParseExcelFormatStrings 3"
.TH Spreadsheet::Reader::Format::ParseExcelFormatStrings 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::Format::ParseExcelFormatStrings \- Convert Excel format strings to code
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 3
\&        #!/usr/bin/env perl
\&        package MyPackage;
\&        use Moose;
\&
\&        use lib \*(Aq../../../../lib\*(Aq;
\&        extends \*(AqSpreadsheet::Reader::Format::FmtDefault\*(Aq;
\&        with    \*(AqSpreadsheet::Reader::Format::ParseExcelFormatStrings\*(Aq;
\&
\&        package main;
\&
\&        my      $parser                 = MyPackage\->new( epoch_year => 1904 );
\&        my      $conversion     = $parser\->parse_excel_format_string( \*(Aq[$\-409]dddd, mmmm dd, yyyy;@\*(Aq );
\&        print \*(AqFor conversion named: \*(Aq . $conversion\->name . "\en";
\&        for my  $unformatted_value ( \*(Aq7/4/1776 11:00.234 AM\*(Aq, 0.112311 ){
\&                print "Unformatted value: $unformatted_value\en";
\&                print "..coerces to: " . $conversion\->assert_coerce( $unformatted_value ) . "\en";
\&        }
\&
\&        ###########################
\&        # SYNOPSIS Screen Output
\&        # 01: For conversion named: DATESTRING
\&        # 02: Unformatted value: 7/4/1776 11:00.234 AM
\&        # 03: ..coerces to: Thursday, July 04, 1776
\&        # 04: Unformatted value: 0.112311
\&        # 05: ..coerces to: Monday, January 01, 1900
\&        ###########################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the parser that converts Excel custom format strings into code that can be used
to transform values into output matching the form defined by the format string.  The goal
of this code is to support as much as possible the definition of excel custom format strings
 <https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4>.
If you find cases where this parser and the Excel definition or excecution differ please
log a case in github <https://github.com/jandrew/Spreadsheet-XLSX-Reader-LibXML/issues>.
.PP
This parser converts the format strings to Type::Tiny objects that have the appropriate
built in coercions.  Any replacement of this engine for use with
Spreadsheet::Reader::Format \fIand Spreadsheet::Reader::ExcelXML\fR must output objects
that have the methods 'display_name' and 'assert_coerce'.  'display_name' is used by the
overall package to determine the cell type and should return a unique name containing an
indication of the output data type with either '\s-1DATE\s0' or '\s-1NUMBER\s0' in the name.  Otherwise
the cell type is assumed to be text.  Spreadsheet::Reader::ExcelXML uses 'assert_coerce'
as the method to transform the raw value to the formatted value.
.PP
Excel format strings can have up to four parts separated by semi-colons.  The four parts
are positive, zero, negative, and text.  In the Excel application the text section is just
a pass through.  \fIThis is how excel handles dates earlier than 1900sh
\&\fR.  This parser deviates from that for dates.  Since
this parser provides code that parses Excel date numbers into a DateTime object (and
then potentially back to a differently formatted string) it also
attempts to parse strings to DateTime objects if the cell has a date format applied.  All
other types of Excel number conversions still treat strings as a pass through.
.PP
To replace this module just build a Moose::Role that delivers
the method parse_excel_format_string  and
get_defined_conversion. See the documentation
 for the format interface to integrate into
the package.
.SS "Caveat Utilitor"
.IX Subsection "Caveat Utilitor"
The decimal (real number) to fraction conversion implementation here is processing
intensive.  I erred on the side of accuracy over speed.  While I tried my best to
provide equivalent accuracy to the Excel output I was unable to duplicate the results
in all cases.  In those cases this package provides a more precise result than Excel.
If you are experiencing delays when reading fraction formatted values then this package
is a place to investigate.  In order to get the most accurate answer this parser
initially uses the continued fraction <http://en.wikipedia.org/wiki/Continued_fraction>
algorythm to calculate a possible fraction for the pased \f(CW$decimal\fR value with the
setting of 20 max iterations and a maximum denominator width defined by the format
string.  If that does not resolve satisfactorily it then calculates \-all\- over/under
numerators with decreasing denominators from the maximum denominator (based on the
format string) all the way to the denominator of 2 and takes the most accurate result.
There is no early-out available in this computation so if you reach this point for multi
digit denominators things slow down.  (Not that continued fractions are
computationally so cheap.)  However, dual staging the calculation this way yields either
the same result as Excel or a more accurate result while providing a possible early out
in the continued fraction portion.  I was unable to even come close to Excel output
otherwise.  If you have a faster conversion or just want to opt out for specific cells
without replacing this whole parser then use the worksheet method
\&\*(L"set_custom_formats( \f(CW$key\fR => \f(CW$format_object_or_string\fR )\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet.
\&\fIhint: \f(CI$format_object_or_string\fI = '@' will set a pass through.\fR
.SS "requires"
.IX Subsection "requires"
These are method(s) used by this role but not provided by the role.  Any class consuming this
role will not build without first providing this(ese) methods prior to loading this role.
.PP
\fIget_defined_excel_format\fR
.IX Subsection "get_defined_excel_format"
.Sp
.RS 4
\&\fBDefinition:\fR Used to return the standard error string for a defined format position.
.Sp
See \*(L"defined_excel_translations\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.SS "Methods"
.IX Subsection "Methods"
These are the methods provided by this role to whatever class or instance inherits this
role.  For additional ParseExcelFormatStrings options see the Attributes
section.
.PP
\fIparse_excel_format_string( \f(CI$string\fI, \f(CI$name\fI )\fR
.IX Subsection "parse_excel_format_string( $string, $name )"
.Sp
.RS 4
\&\fBDefinition:\fR This is the method to convert Excel format strings
 <https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-83657ca7-9dbe-4ee5-9c89-d8bf836e028e?ui=en-US&rs=en-US&ad=US>
into Type::Tiny objects with built in coercions.  The type coercion objects are then used to
convert unformatted values into formatted
values using the assert_coerce method. Coercions built by this module
allow for the format string to have up to four parts separated by semi-colons.  These four parts
correlate to four different data input ranges.  The four parts are positive, zero, negative, and
text.  If three substrings are sent then the data input is split to (positive and zero), negative,
and text.  If two input types are sent the data input is split between numbers and text.  One input
type is a take all comers type with the exception of dates.  When dates are built by this module it
always adds a possible from-text conversion to process Excel pre\-1900ish dates.  This is because
Excel does not record dates prior to 1900ish as numbers.  All date unformatted values are then
processed into and then potentially back out of DateTime objects.  This
requires \*(L"Chained Coercions\*(R" in Type::Tiny::Manual::Coercions.  The two packages used for conversion
to DateTime objects are DateTime::Format::Flexible and DateTimeX::Format::Excel.
.Sp
\&\fBAccepts:\fR an Excel number format string
 <https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-83657ca7-9dbe-4ee5-9c89-d8bf836e028e?ui=en-US&rs=en-US&ad=US>
and a conversion name stored in the Type::Tiny object.  This package will auto-generate a name if
none is given
.Sp
\&\fBReturns:\fR a Type::Tiny object with type coercions and pre-filters set for each input type
from the formatting string
.RE
.PP
\fIget_defined_conversion( \f(CI$position\fI )\fR
.IX Subsection "get_defined_conversion( $position )"
.Sp
.RS 4
\&\fBDefinition:\fR This is a helper method that combines the call to
\&\*(L"get_defined_excel_format( \f(CW$position\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault and
parse_excel_format_string above in order to get the final result with one call.
.Sp
\&\fBAccepts:\fR an Excel default format position
.Sp
\&\fBReturns:\fR a Type::Tiny object with type coercions and pre-filters set for each input type
from the formatting string
.RE
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to new when creating a class or instance containing this role.   For
modification of these attributes see the listed 'attribute methods'.  For more
information on attributes see Moose::Manual::Attributes.
.PP
\fIworkbook_inst\fR
.IX Subsection "workbook_inst"
.Sp
.RS 4
\&\fBDefinition:\fR This role works better if it has access to two workbook methods
there are defaults built in if the workbook is not connected but the package no
longer responds dynamically when that connection is broken.  This instance is a
way for this role to see those settings.
.Sp
\&\fBRequired:\fR No but it's really nice
.Sp
\&\fBRange:\fR an instance of the Spreadsheet::Reader::ExcelXML class
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_workbook_inst( \f(CB$instance\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR sets the workbook instance
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBdelegated methods\fR Methods provided from the object stored in the attribute
.Sp
.Vb 1
\&        method_name => method_delegated_from_link
.Ve
.Sp
.RS 4
\&\fBset_error( \f(CB$error_string\fB )\fR => \*(L"set_error\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\fBget_epoch_year\fR => \*(L"get_epoch_year\*(R" in Spreadsheet::Reader::ExcelXML
.RE
.RE
.RS 4
.RE
.PP
\fIcache_formats\fR
.IX Subsection "cache_formats"
.Sp
.RS 4
\&\fBDefinition:\fR In order to save re-building the coercion each time they are
requested, the built coercions can be cached with the format string as the key.
This attribute sets whether caching is turned on or not.  In rare cases with
lots of unique formats this would allow a reduction in \s-1RAM\s0 consumtion at the
price of speed.
.Sp
\&\fBRange:\fR Boolean
.Sp
\&\fBDefault:\fR 1 = caching is on
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_cache_behavior\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the state of the attribute
.RE
.RE
.RS 4
.Sp
\&\fBset_cache_behavior( \f(CB$bool\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR sets the value of the attribute to \f(CW$Bool\fR
.Sp
\&\fBRange:\fR Boolean 1 = cache formats, 0 = Don't cache formats
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIdatetime_dates\fR
.IX Subsection "datetime_dates"
.Sp
.RS 4
\&\fBDefinition:\fR It may be that you desire the full DateTime object as output
rather than the finalized datestring when converting unformatted date data to
formatted date data. This attribute sets whether data coersions are built to do
the full conversion or just to a DateTime object in return.
.Sp
\&\fBDefault:\fR 0 = unformatted values are coerced completely to date strings (1 =
stop at DateTime objects)
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute.
.Sp
.RS 4
\&\fBget_date_behavior\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value of the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
.RS 4
\&\fBset_date_behavior( \f(CB$bool\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR sets the attribute value (only new coercions
are affected)
.Sp
\&\fBAccepts:\fR Boolean values
.Sp
\&\fBDelegated to the workbook class:\fR yes
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIeuropean_first\fR
.IX Subsection "european_first"
.Sp
.RS 4
\&\fBDefinition:\fR This is a way to check for DD-MM-YY formatting of
inbound (read from the file) date stringsprior to checking for MM-DD-YY.
Since the package always checks both ways when the number is ambiguous
the goal is to catch data where the substring for \s-1DD\s0 < 13 and assign it
correctly.
.Sp
\&\fBDefault:\fR 0 = MM\-DD\-YY[\s-1YY\s0] is tested first
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_european_first\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value of the attribute
.RE
.RE
.RS 4
.Sp
\&\fBset_european_first( \f(CB$bool\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR sets the value of the attribute
.Sp
\&\fBRange:\fR Boolean 0 = MM-DD-YY is tested first, 1 = DD-MM-YY is tested first
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::Format/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-format/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Attempt to merge _split_decimal_integer and _integer_and_decimal
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
Spreadsheet::Reader::Format
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::ParseExcel \- Excel 2003 and earlier
.Sp
Spreadsheet::XLSX \- 2007+
.Sp
Spreadsheet::ParseXLSX \- 2007+
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
