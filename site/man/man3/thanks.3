.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "thanks 3"
.TH thanks 3 "2013-11-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
thanks \- inline packages easily
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        BEGIN {
\&                package My::Package;
\&                no thanks;
\&                # everything else goes here
\&        };
\&        
\&        use My::Package;  # No error message about missing
\&                          # file "My/Package.pm".
\&                          #
.Ve
.PP
Or:
.PP
.Vb 4
\&        BEGIN {
\&                package My::Package;
\&                # everything else goes here
\&        };
\&        
\&        no thanks qw( My::Package Another::Package Yet::Another::Package );
\&        
\&        use My::Package;  # No error message about missing
\&                          # file "My/Package.pm".
\&                          #
.Ve
.SH "ELEVATOR PITCH"
.IX Header "ELEVATOR PITCH"
Defining multiple Perl packages in the same file can be fraught with
difficulty. \f(CW\*(C`no thanks\*(C'\fR makes it a bit easier. To define a package
just do...
.PP
.Vb 5
\&        BEGIN {
\&                package My::Package;
\&                no thanks;
\&                # everything else goes here
\&        };
.Ve
.PP
Then everything should more or less work exactly if My::Package had
been a package defined in an external file and loaded like:
.PP
.Vb 1
\&        use My::Package ();
.Ve
.PP
(The exception being that the inlined My::Package can see file-scoped
lexicals.)
.PP
Why define multiple packages in the same file? Because often namespacing
concerns and code organisation concerns don't align. For example, you
have many small packages which it is important don't share namespaces,
but you want to be able to edit them all in the same window/tab of your
editor.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module asks Perl politely not to load a module you don't want loading.
It's just a polite request; we're not forcing Perl to do anything it doesn't
want to. And if the module is already loaded, then we won't try to unload
it or anything like that.
.PP
Specifically, Perl's \f(CW\*(C`use Module::Name\*(C'\fR syntax does two things. It reads,
compiles and executes \f(CW\*(C`Module/Name.pm\*(C'\fR, and calls the class method
\&\f(CW\*(C`Module::Name\->import\*(C'\fR. This module is designed to prevent the first
thing happening, not the second thing.
.PP
How does it work? Perl keeps a record of what modules have already been
loaded in the \f(CW%INC\fR global hash, to avoid reloading them. This module
just adds an entry to that hash to trick Perl into thinking that a module
has already been loaded.
.PP
\&\f(CW\*(C`thanks\*(C'\fR is a deliberately light-weight module. It has no dependencies (not
even strict or warnings) and is believed to work in any release of Perl
5. (The installation and testing scripts have more dependencies, but if push
comes to shove, you can manually copy thanks.pm to an appropriate location.)
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """unimport""" 4
.el .IP "\f(CWunimport\fR" 4
.IX Item "unimport"
.Vb 1
\&        no thanks @LIST;
.Ve
.Sp
If \f(CW@LIST\fR is empty, then the caller package is assumed.
.SS "Use Case 1: Multiple Packages in the Same File"
.IX Subsection "Use Case 1: Multiple Packages in the Same File"
Perl's \f(CW\*(C`use\*(C'\fR keyword muddies the distinction between packages (which
are just namespaces) and modules (which are just files). Sometimes you wish
to define two packages (say \f(CW\*(C`My::Package\*(C'\fR and
\&\f(CW\*(C`My::Package::Helper\*(C'\fR) in the same file (say \f(CW\*(C`My/Package.pm\*(C'\fR). If
anybody tries to load \f(CW\*(C`My::Package::Helper\*(C'\fR with \f(CW\*(C`use\*(C'\fR, then they'll
get an error message. If \f(CW\*(C`My/Package.pm\*(C'\fR includes:
.PP
.Vb 1
\&        no thanks \*(AqMy::Package::Helper\*(Aq;
.Ve
.PP
then this will prevent \f(CW\*(C`use My::Package::Helper\*(C'\fR from throwing an error
message, provided \f(CW\*(C`My/Package.pm\*(C'\fR is already loaded.
.SS "Use Case 2: You Really Want to Prevent a Module from Loading"
.IX Subsection "Use Case 2: You Really Want to Prevent a Module from Loading"
It's quite a messy thing to do, but if you really need to silently prevent
a module from being loaded, then \f(CW\*(C`no thanks\*(C'\fR will do the trick. Just
make sure you do it early.
.PP
This is almost always a bad idea.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=thanks>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
again,
Module::Reload,
Class::Unload.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2012\-2013 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
