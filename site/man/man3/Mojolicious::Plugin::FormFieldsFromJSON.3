.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojolicious::Plugin::FormFieldsFromJSON 3"
.TH Mojolicious::Plugin::FormFieldsFromJSON 3 "2019-03-30" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Plugin::FormFieldsFromJSON \- create form fields based on a definition in a JSON file
.SH "VERSION"
.IX Header "VERSION"
version 1.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Mojolicious
\&  $self\->plugin(\*(AqFormFieldsFromJSON\*(Aq);
\&
\&  # Mojolicious::Lite
\&  plugin \*(AqFormFieldsFromJSON\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojolicious::Plugin::FormFieldsFromJSON is a Mojolicious plugin.
.SH "NAME"
Mojolicious::Plugin::FormFieldsFromJSON \- create form fields based on a definition in a JSON file
.SH "VERSION"
.IX Header "VERSION"
version 0.32
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
You can configure some settings for the plugin:
.IP "\(bu" 4
dir
.Sp
The directory where the json files for form field configuration are located
.Sp
.Vb 3
\&  $self\->plugin( \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir => \*(Aq/home/mojo/fields\*(Aq,
\&  });
.Ve
.Sp
You can also pass an arrayreference with directory names. This will help when you
store the \s-1JSON\s0 files where your templates are...
.Sp
.Vb 7
\&  $self\->plugin( \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir => [
\&      \*(Aq/home/mojo/templates/admin/json\*(Aq,
\&      \*(Aq/home/mojo/templates/author/json\*(Aq,
\&      \*(Aq/home/mojo/templates/guest/json\*(Aq,
\&    ]
\&  });
.Ve
.IP "\(bu" 4
template
.Sp
With template you can define a template for the form fields.
.Sp
.Vb 3
\&  $self\->plugin( \*(AqFormFieldsFromJSON\*(Aq => {
\&    template => \*(Aq<label for="<%= $id %>"><%= $label %>:</label><div><%= $field %></div>\*(Aq,
\&  });
.Ve
.Sp
See Templates.
.IP "\(bu" 4
templates
.Sp
With template you can define type specific templates for the form fields.
.Sp
.Vb 5
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    templates => {
\&      text => \*(Aq<%= $label %>: <%= $field %>\*(Aq,
\&    },
\&  };
.Ve
.Sp
See Templates.
.IP "\(bu" 4
global_attributes
.Sp
With \fIglobal_attributes\fR, you can define attributes that should be set for every field 
(except hidden fields)
.Sp
.Vb 5
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    global_attributes => {
\&      class => \*(Aqimportant\-field\*(Aq,
\&    },
\&  };
.Ve
.Sp
So with this configuration
.Sp
.Vb 12
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    },
\&    {
\&        "label" : "Background",
\&        "type" : "text",
\&        "name" : "background"
\&    }
\& ]
.Ve
.Sp
You get
.Sp
.Vb 2
\&     <input class="important\-field" id="name" name="name" type="text" value="" />
\&     <input class="important\-field" id="background" name="background" type="text" value="" />
.Ve
.IP "\(bu" 4
alias
.Sp
Using aliases can help you a lot. Given you want to have several forms where the user can
define a color (e.g. by using \fIbootstrap-colorpicker\fR), you don't want to define the special
templates in each form. Instead you can define those fiels as \fItype\fR \*(L"color\*(R" and use an alias:
.Sp
.Vb 9
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    template  => \*(Aq<%= $label %>: <%= $field %>\*(Aq,
\&    templates => {
\&      color => \*(Aq<%= $label %> (color): <%= $field %>\*(Aq,
\&    },
\&    alias => {
\&      color => \*(Aqtext\*(Aq,
\&    },
\&  };
.Ve
.Sp
The alias defines that \*(L"color\*(R" fields are \*(L"text\*(R" fields.
.Sp
So with this configuration
.Sp
.Vb 12
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    },
\&    {
\&        "label" : "Background",
\&        "type" : "color",
\&        "name" : "background"
\&    }
\& ]
.Ve
.Sp
You get
.Sp
.Vb 2
\&     <label for="name">Name:</label><div><input id="name" name="name" type="text" value="" /></div>
\&     <label for="background">Background (color):</label><div><input id="background" name="background" type="text" value="" /></div>
.Ve
.IP "\(bu" 4
translate_labels
.Sp
If \fItranslate_labels\fR is true, the labels for the templates are translated. You have to provide a
\&\fItranslation_method|Mojolicious::Plugin::FormFieldsFromJSON/Translation_method\fR, too.
.Sp
.Vb 5
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    template           => \*(Aq<%= $label %>: <%= $field %>\*(Aq,
\&    translate_labels   => 1,
\&    translation_method => \e&loc,
\&  };
.Ve
.Sp
For more details see \fITranslation|Mojolicious::Plugin::FormFieldsFromJSON/Translation\fR.
.IP "\(bu" 4
translation_method
.Sp
If \fItranslate_labels\fR is true, the labels for the templates are translated. You have to provide a
\&\fItranslation_method|Mojolicious::Plugin::FormFieldsFromJSON/Translation_method\fR, too.
.Sp
.Vb 5
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    template           => \*(Aq<%= $label %>: <%= $field %>\*(Aq,
\&    translate_labels   => 1,
\&    translation_method => \e&loc,
\&  };
.Ve
.Sp
For more details see \fITranslation|Mojolicious::Plugin::FormFieldsFromJSON/Translation\fR.
.IP "\(bu" 4
types
.Sp
If you have written a plugin that implements a new \*(L"type\*(R" of input field, you can allow this type by passing
\&\fItypes\fR when you load the plugin.
.Sp
.Vb 5
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    types => {
\&        \*(Aqtestfield\*(Aq => 1,
\&    },
\&  };
.Ve
.Sp
Now you can use
.Sp
.Vb 7
\&  [
\&    {
\&      "label" : "Name",
\&      "type" : "testfield",
\&      "name" : "name"
\&    }
\&  ]
.Ve
.Sp
For more details see Additional Types.
.SH "HELPER"
.IX Header "HELPER"
.SS "form_fields"
.IX Subsection "form_fields"
\&\f(CW\*(C`form_fields\*(C'\fR returns a string with all configured fields \*(L"translated\*(R" to \s-1HTML.\s0
.PP
.Vb 1
\&  $controller\->form_fields( \*(Aqformname\*(Aq );
.Ve
.PP
Given this configuration:
.PP
.Vb 12
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    },
\&    {
\&        "label" : "City",
\&        "type" : "text",
\&        "name" : "city"
\&    }
\& ]
.Ve
.PP
You'll get
.PP
.Vb 2
\& <input id="name" name="name" type="text" value="" />
\& <input id="city" name="city" type="text" value="" />
.Ve
.PP
\fIdynamic config\fR
.IX Subsection "dynamic config"
.PP
Instead of a formname, you can pass a config:
.PP
.Vb 9
\&  $controller\->form_fields(
\&    [
\&      {
\&        "label" : "Name",
\&        "type" : "testfield",
\&        "name" : "name"
\&      }
\&    ]
\&  );
.Ve
.PP
This way, you can build your forms dynamically (e.g. based on database entries).
.SS "validate_form_fields"
.IX Subsection "validate_form_fields"
This helper validates the input. It uses the Mojolicious::Validator::Validation and it
validates all fields defined in the configuration file.
.PP
For more details see Validation.
.SS "forms"
.IX Subsection "forms"
This method returns a list of forms. That means the filenames of all .json files
in the configured directory.
.PP
.Vb 1
\&  my @forms = $controller\->forms;
.Ve
.PP
The filenames are returned without the file suffix .json.
.SS "fields"
.IX Subsection "fields"
\&\f(CW\*(C`fields()\*(C'\fR returns a list of fields (label or name).
.PP
.Vb 1
\&  my @fieldnames = $controller\->fields(\*(Aqformname\*(Aq);
.Ve
.PP
If your configuration looks like
.PP
.Vb 11
\& [
\&   {
\&     "label" : "Email",
\&     "name"  : "email",
\&     "type"  : "text"
\&   },
\&   {
\&     "name"  : "password",
\&     "type"  : "password"
\&   }
\& ]
.Ve
.PP
You get
.PP
.Vb 4
\&  (
\&    Email,
\&    password
\&  )
.Ve
.SH "FIELD DEFINITIONS"
.IX Header "FIELD DEFINITIONS"
This plugin supports several form fields:
.IP "\(bu" 4
text
.IP "\(bu" 4
checkbox
.IP "\(bu" 4
radio
.IP "\(bu" 4
select
.IP "\(bu" 4
textarea
.IP "\(bu" 4
password
.IP "\(bu" 4
hidden
.PP
Those fields have the following definition items in common:
.IP "\(bu" 4
name
.Sp
The name of the field. If you do not pass an id for the field in the \fIattributes\fR\-field, the name is also
taken for the field id.
.IP "\(bu" 4
label
.Sp
If a template is used, this value is passed for \f(CW$label\fR. If the translation feature is used, the label
is translated.
.IP "\(bu" 4
type
.Sp
One of the above mentioned types. Please note, that you can add own types.
.IP "\(bu" 4
data
.Sp
For \fItext\fR, \fItextarea\fR, \fIpassword\fR and \fIhidden\fR this is the value for the field. This can be set in various ways:
.RS 4
.IP "1. Data passed in the code like" 4
.IX Item "1. Data passed in the code like"
.Vb 1
\&  $c\->form_fields( \*(Aqform\*(Aq, fieldname => { data => \*(Aqtest\*(Aq } );
.Ve
.IP "2. Data passed via stash" 4
.IX Item "2. Data passed via stash"
.Vb 1
\&  $c\->stash( fieldname => \*(Aqtest\*(Aq );
.Ve
.IP "3. Data in the request" 4
.IX Item "3. Data in the request"
.PD 0
.IP "4. Data defined in the field configuration" 4
.IX Item "4. Data defined in the field configuration"
.IP "5. Data passed via stash \- part two" 4
.IX Item "5. Data passed via stash - part two"
.PD
.Vb 2
\&  $c\->stash( any_name => { fieldname => \*(Aqtest\*(Aq } );
\&  $c\->form_fields( \*(Aqform\*(Aq, from_stash => \*(Aqany_name\*(Aq );
.Ve
.RE
.RS 4
.Sp
For \fIselect\fR, \fIcheckbox\fR and \fIradio\fR fields, \fIdata\fR contains the possible values.
.RE
.IP "\(bu" 4
attributes
.Sp
Attributes of the field like \*(L"class\*(R":
.Sp
.Vb 3
\&  attributes => {
\&    class => \*(Aqbutton\*(Aq
\&  }
.Ve
.Sp
If \fIglobal_attributes\fR are defined, then the values are added, so that
.Sp
.Vb 5
\&  plugin( \*(AqFormFieldsFromJSON\*(Aq => {
\&    global_attributes => {
\&      class => \*(Aqbutton\-danger\*(Aq,
\&    }
\&  });
.Ve
.Sp
and the \fIattributes\fR field as shown, then the field has two classes: \fIbutton\fR and \fIbutton-danger\fR. In the
field the classes mentioned in field config come first.
.Sp
.Vb 1
\&  <button class="button button\-danger" ...>
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following sections should give you an idea what's possible with this plugin
.SS "text"
.IX Subsection "text"
With type \fItext\fR you get a simple text input field.
.PP
\fIA simple text field\fR
.IX Subsection "A simple text field"
.PP
This is the configuration for a simple text field:
.PP
.Vb 7
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    }
\& ]
.Ve
.PP
And the generated form field looks like
.PP
.Vb 1
\& <input id="name" name="name" type="text" value="" />
.Ve
.PP
\fISet \s-1CSS\s0 classes\fR
.IX Subsection "Set CSS classes"
.PP
If you want to set a \s-1CSS\s0 class, you can use the \f(CW\*(C`attributes\*(C'\fR field:
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name",
\&        "attributes" : {
\&            "class" : "W75px"
\&        }
\&    }
\& ]
.Ve
.PP
And the generated form field looks like
.PP
.Vb 1
\& <input class="W75px" id="name" name="name" type="text" value="" />
.Ve
.PP
\fIText field with predefined value\fR
.IX Subsection "Text field with predefined value"
.PP
Sometimes, you want to predefine a value shown in the text field. Then you can
use the \f(CW\*(C`data\*(C'\fR field:
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name",
\&        "data" : "default value"
\&    }
\& ]
.Ve
.PP
This will generate this input field:
.PP
.Vb 1
\&  <input id="name" name="name" type="text" value="default value" />
.Ve
.SS "select"
.IX Subsection "select"
\fISimple: Value = Label\fR
.IX Subsection "Simple: Value = Label"
.PP
When you have a list of values for a select field, you can define
an array reference:
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "language",
\&      "data" : [
\&        "de",
\&        "en"
\&      ]
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 4
\&  <select id="language" name="language">
\&      <option value="de">de</option>
\&      <option value="en">en</option>
\&  </select>
.Ve
.PP
\fIPreselect a value\fR
.IX Subsection "Preselect a value"
.PP
You can define
.PP
.Vb 11
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "language",
\&      "data" : [
\&        "de",
\&        "en"
\&      ],
\&      "selected" : "en"
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 4
\&  <select id="language" name="language">
\&      <option value="de">de</option>
\&      <option value="en" selected="selected">en</option>
\&  </select>
.Ve
.PP
If a key named as the select exists in the stash, those values are preselected
(this overrides the value defined in the .json):
.PP
.Vb 1
\&  $c\->stash( language => \*(Aqen\*(Aq );
.Ve
.PP
and
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "language",
\&      "data" : [
\&        "de",
\&        "en"
\&      ]
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 4
\&  <select id="language" name="language">
\&      <option value="de">de</option>
\&      <option value="en" selected="selected">en</option>
\&  </select>
.Ve
.PP
\fIMultiselect\fR
.IX Subsection "Multiselect"
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "languages",
\&      "data" : [
\&        "de",
\&        "en",
\&        "cn",
\&        "jp"
\&      ],
\&      "multiple" : 1,
\&      "size" : 3
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 6
\&  <select id="languages" name="languages" multiple="multiple" size="3">
\&      <option value="cn">cn</option>
\&      <option value="de">de</option>
\&      <option value="en">en</option>
\&      <option value="jp">jp</option>
\&  </select>
.Ve
.PP
\fIPreselect multiple values\fR
.IX Subsection "Preselect multiple values"
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "languages",
\&      "data" : [
\&        "de",
\&        "en",
\&        "cn",
\&        "jp"
\&      ],
\&      "multiple" : 1,
\&      "selected" : [ "en", "de" ]
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 6
\&  <select id="language" name="language">
\&      <option value="cn">cn</option>
\&      <option value="de" selected="selected">de</option>
\&      <option value="en" selected="selected">en</option>
\&      <option value="jp">jp</option>
\&  </select>
.Ve
.PP
\fIValues != Label\fR
.IX Subsection "Values != Label"
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "language",
\&      "data" : {
\&        "de" : "German",
\&        "en" : "English"
\&      }
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 4
\&  <select id="language" name="language">
\&      <option value="en">English</option>
\&      <option value="de">German</option>
\&  </select>
.Ve
.PP
\fIOption groups\fR
.IX Subsection "Option groups"
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "language",
\&      "data" : {
\&        "EU" : {
\&          "de" : "German",
\&          "en" : "English"
\&        },
\&        "Asia" : {
\&          "cn" : "Chinese",
\&          "jp" : "Japanese"
\&        }
\&      }
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 4
\&  <select id="language" name="language">
\&      <option value="en">English</option>
\&      <option value="de">German</option>
\&  </select>
.Ve
.PP
\fIDisable values\fR
.IX Subsection "Disable values"
.PP
.Vb 10
\&  [
\&    {
\&      "type" : "select",
\&      "name" : "languages",
\&      "data" : [
\&        "de",
\&        "en",
\&        "cn",
\&        "jp"
\&      ],
\&      "multiple" : 1,
\&      "disabled" : [ "en", "de" ]
\&    }
\&  ]
.Ve
.PP
This creates the following select field:
.PP
.Vb 6
\&  <select id="language" name="language">
\&      <option value="cn">cn</option>
\&      <option value="de" disabled="disabled">de</option>
\&      <option value="en" disabled="disabled">en</option>
\&      <option value="jp">jp</option>
\&  </select>
.Ve
.SS "radio"
.IX Subsection "radio"
For radiobuttons, you can use two ways: You can either configure
form fields for each value or you can define a list of values in
the \f(CW\*(C`data\*(C'\fR field. With the first way, you can create radiobuttons
where the template (if any defined) is applied to each radiobutton.
With the second way, the radiobuttons are handled as one single 
field in the template.
.PP
\fIA single radiobutton\fR
.IX Subsection "A single radiobutton"
.PP
Given the configuration
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : "internal"
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo radiobuttons configured separately\fR
.IX Subsection "Two radiobuttons configured separately"
.PP
With the configuration
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : "internal"
\&    },
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : "external"
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo radiobuttons as a group\fR
.IX Subsection "Two radiobuttons as a group"
.PP
And with
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo radiobuttons configured separately \- with template\fR
.IX Subsection "Two radiobuttons configured separately - with template"
.PP
Define template:
.PP
.Vb 4
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir      => \*(Aq./conf\*(Aq,
\&    template => \*(Aq<%= $label %>: <%= $form %>\*(Aq;
\&  };
.Ve
.PP
Config:
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : "internal"
\&    },
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : "external"
\&    }
\& ]
.Ve
.PP
Fields:
.PP
.Vb 1
\&  Name: <input id="type" name="type" type="radio" value="internal" />
\&  
\&  
\&  
\&  Name: <input id="type" name="type" type="radio" value="external" />
.Ve
.PP
\fITwo radiobuttons as a group \- with template\fR
.IX Subsection "Two radiobuttons as a group - with template"
.PP
Same template definition as above, but given this field config:
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
You get this:
.PP
.Vb 2
\&  Name: <input id="type" name="type" type="radio" value="internal" />
\&  <input id="type" name="type" type="radio" value="external" />
.Ve
.PP
\fITwo radiobuttons \- one checked\fR
.IX Subsection "Two radiobuttons - one checked"
.PP
Config:
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "data" : ["internal", "external" ],
\&        "selected" : ["internal"]
\&    }
\& ]
.Ve
.PP
Field:
.PP
.Vb 2
\&  <input checked="checked" id="type" name="type" type="radio" value="internal" />
\&  <input id="type" name="type" type="radio" value="external" />
.Ve
.PP
\fIRadiobuttons with \s-1HTML\s0 after every element\fR
.IX Subsection "Radiobuttons with HTML after every element"
.PP
When you want to add some \s-1HTML\s0 code after every element \- e.g. a \f(CW\*(C`<br />\*(C'\fR \-
you can use \fIafter_element\fR
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "after_element" : "<br />",
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
Fields:
.PP
.Vb 3
\&  <input id="type" name="type" type="radio" value="internal" />
\&  <br /><input id="type" name="type" type="radio" value="external" />
\&  <br />
.Ve
.PP
\fIRadiobuttons with values shown as label\fR
.IX Subsection "Radiobuttons with values shown as label"
.PP
When you want to show the value as a label, you can use \fIshow_value\fR.
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "show_value" : 1,
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
Creates
.PP
.Vb 2
\&  <input id="type" name="type" type="radio" value="internal" /> internal
\&  <input id="type" name="type" type="radio" value="external" /> external
.Ve
.PP
\fIRadiobuttons with translated values for \*(L"sublabels\*(R"\fR
.IX Subsection "Radiobuttons with translated values for sublabels"
.PP
If you want to show the \*(L"sublabels\*(R" and want them to be translated, you can
use \fItranslate_sublabels\fR
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "radio",
\&        "name" : "type",
\&        "show_value" : 1,
\&        "translate_sublabels" : 1,
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
Given this plugin is used this way:
.PP
.Vb 4
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&      dir => File::Spec\->catdir( dirname( _\|_FILE_\|_ ) || \*(Aq.\*(Aq, \*(Aqconf\*(Aq ),
\&      translation_method => \e&loc,
\&  };
\&  
\&  sub loc {
\&      my ($c, $value) = @_;
\&  
\&      my %translation = ( internal => \*(Aqintern\*(Aq, external => \*(Aqextern\*(Aq );
\&      return $translation{$value} // $value;
\&  };
.Ve
.PP
You'll get
.PP
.Vb 2
\&  <input id="type" name="type" type="radio" value="internal" /> intern
\&  <input id="type" name="type" type="radio" value="external" /> extern
.Ve
.SS "checkbox"
.IX Subsection "checkbox"
For checkboxes, you can use two ways: You can either configure
form fields for each value or you can define a list of values in
the \f(CW\*(C`data\*(C'\fR field. With the first way, you can create checkboxes
where the template (if any defined) is applied to each checkbox.
With the second way, the checkboxes are handled as one single 
field in the template.
.PP
\fIA single checkbox\fR
.IX Subsection "A single checkbox"
.PP
Given the configuration
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : "internal"
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo checkboxes configured separately\fR
.IX Subsection "Two checkboxes configured separately"
.PP
With the configuration
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : "internal"
\&    },
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : "external"
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo checkboxes as a group\fR
.IX Subsection "Two checkboxes as a group"
.PP
And with
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
You get
.PP
\fITwo checkboxes configured separately \- with template\fR
.IX Subsection "Two checkboxes configured separately - with template"
.PP
Define template:
.PP
.Vb 4
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir      => \*(Aq./conf\*(Aq,
\&    template => \*(Aq<%= $label %>: <%= $form %>\*(Aq;
\&  };
.Ve
.PP
Config:
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : "internal"
\&    },
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : "external"
\&    }
\& ]
.Ve
.PP
Fields:
.PP
.Vb 1
\&  Name: <input id="type" name="type" type="checkbox" value="internal" />
\&  
\&  
\&  
\&  Name: <input id="type" name="type" type="checkbox" value="external" />
.Ve
.PP
\fITwo checkboxes as a group \- with template\fR
.IX Subsection "Two checkboxes as a group - with template"
.PP
Same template definition as above, but given this field config:
.PP
.Vb 8
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
You get this:
.PP
.Vb 2
\&  Name: <input id="type" name="type" type="checkbox" value="internal" />
\&  <input id="type" name="type" type="checkbox" value="external" />
.Ve
.PP
\fITwo checkboxes \- one checked\fR
.IX Subsection "Two checkboxes - one checked"
.PP
Config:
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "data" : ["internal", "external" ],
\&        "selected" : ["internal"]
\&    }
\& ]
.Ve
.PP
Field:
.PP
.Vb 2
\&  <input checked="checked" id="type" name="type" type="checkbox" value="internal" />
\&  <input id="type" name="type" type="checkbox" value="external" />
.Ve
.PP
\fICheckboxes with \s-1HTML\s0 after every element\fR
.IX Subsection "Checkboxes with HTML after every element"
.PP
When you want to add some \s-1HTML\s0 code after every element \- e.g. a \f(CW\*(C`<br />\*(C'\fR \-
you can use \fIafter_element\fR
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "after_element" : "<br />",
\&        "data" : ["internal", "external", "unknown" ]
\&    }
\& ]
.Ve
.PP
Fields:
.PP
.Vb 4
\&  <input id="type" name="type" type="checkbox" value="internal" />
\&  <br /><input id="type" name="type" type="checkbox" value="external" />
\&  <br /><input id="type" name="type" type="checkbox" value="unknown" />
\&  <br />
.Ve
.PP
\fICheckboxes with values shown as label\fR
.IX Subsection "Checkboxes with values shown as label"
.PP
When you want to show the value as a label, you can use \fIshow_value\fR.
.PP
.Vb 9
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "show_value" : 1,
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
Creates
.PP
.Vb 2
\&  <input id="type" name="type" type="checkbox" value="internal" /> internal
\&  <input id="type" name="type" type="checkbox" value="external" /> external
.Ve
.PP
\fICheckboxes with translated values for \*(L"sublabels\*(R"\fR
.IX Subsection "Checkboxes with translated values for sublabels"
.PP
If you want to show the \*(L"sublabels\*(R" and want them to be translated, you can
use \fItranslate_sublabels\fR
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "checkbox",
\&        "name" : "type",
\&        "show_value" : 1,
\&        "translate_sublabels" : 1,
\&        "data" : ["internal", "external" ]
\&    }
\& ]
.Ve
.PP
Given this plugin is used this way:
.PP
.Vb 4
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&      dir => File::Spec\->catdir( dirname( _\|_FILE_\|_ ) || \*(Aq.\*(Aq, \*(Aqconf\*(Aq ),
\&      translation_method => \e&loc,
\&  };
\&  
\&  sub loc {
\&      my ($c, $value) = @_;
\&  
\&      my %translation = ( internal => \*(Aqintern\*(Aq, external => \*(Aqextern\*(Aq );
\&      return $translation{$value} // $value;
\&  };
.Ve
.PP
You'll get
.PP
.Vb 2
\&  <input id="type" name="type" type="checkbox" value="internal" /> intern
\&  <input id="type" name="type" type="checkbox" value="external" /> extern
.Ve
.SS "textarea"
.IX Subsection "textarea"
This type is very similar to text.
.PP
\fIA simple textarea\fR
.IX Subsection "A simple textarea"
.PP
This is the configuration for a simple text field:
.PP
.Vb 7
\& [
\&    {
\&        "type" : "textarea",
\&        "name" : "message",
\&        "data" : "Current message"
\&    }
\& ]
.Ve
.PP
And the generated form field looks like
.PP
.Vb 1
\&  <textarea id="message" name="message">Current message</textarea>
.Ve
.PP
\fIA textarea with defined number of columns and rows\fR
.IX Subsection "A textarea with defined number of columns and rows"
.PP
This is the configuration for a simple text field:
.PP
.Vb 11
\& [
\&    {
\&        "type" : "textarea",
\&        "name" : "message",
\&        "data" : "Current message",
\&        "attributes" : {
\&            "cols" : 80,
\&            "rows" : 10
\&        }
\&    }
\& ]
.Ve
.PP
And the generated textarea looks like
.PP
.Vb 1
\&  <textarea cols="80" id="message" name="message" rows="10">Current message</textarea>
.Ve
.SS "password"
.IX Subsection "password"
This type is very similar to text.
You can use the very same settings as for text fields, so we show only a simple
example here:
.PP
\fIA simple password field\fR
.IX Subsection "A simple password field"
.PP
This is the configuration for a simple text field:
.PP
.Vb 6
\& [
\&    {
\&        "type" : "password",
\&        "name" : "user_password"
\&    }
\& ]
.Ve
.PP
And the generated form field looks like
.PP
.Vb 1
\& <input id="user_password" name="password" type="password" value="" />
.Ve
.SH "Templates"
.IX Header "Templates"
Especially when you work with frameworks like Bootstrap, you want to 
your form fields to look nice. For that the form fields are within
\&\f(CW\*(C`div\*(C'\fRs or other \s-1HTML\s0 elements.
.PP
To make your life easier, you can define templates. Either a \*(L"global\*(R"
one, a type specific template or a template for one field.
.PP
For hidden fields, no template is applied!
.SS "A global template"
.IX Subsection "A global template"
When you load the plugin this way
.PP
.Vb 3
\&  $self\->plugin( \*(AqFormFieldsFromJSON\*(Aq => {
\&    template => \*(Aq<label for="<%= $id %>"><%= $label %>:</label><div><%= $field %></div>\*(Aq,
\&  });
.Ve
.PP
and have a configuration that looks like
.PP
You get
.PP
.Vb 1
\&  <label for="name">Name:</label><div><input id="name" name="name" type="text" value="" /></div>
\&  
\&   
\&  <label for="password">Password:</label><div><input id="password" name="password" type="text" value="" /></div>
.Ve
.SS "A type specific template"
.IX Subsection "A type specific template"
When you want to use a different template for select fields, you can use a
different template for that kind of fields:
.PP
.Vb 7
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir       => File::Spec\->catdir( dirname( _\|_FILE_\|_ ) || \*(Aq.\*(Aq, \*(Aqconf\*(Aq ),
\&    template  => \*(Aq<label for="<%= $id %>"><%= $label %>:</label><div><%= $field %></div>\*(Aq,
\&    templates => {
\&      select => \*(Aq<%= $label %>: <%= $field %>\*(Aq,
\&    },
\&  };
.Ve
.PP
With a configuration file like
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    }
\&    {
\&        "label" : "Country",
\&        "type" : "select",
\&        "name" : "country",
\&        "data" : [ "au" ]
\&    }
\& ]
.Ve
.PP
You get
.PP
.Vb 1
\&  <label for="name">Name:</label><div><input id="name" name="name" type="text" value="" /></div>
\&  
\&   
\&  Country: <select id="country" name="country"><option value="au">au</option></select>
.Ve
.SS "A field specific template"
.IX Subsection "A field specific template"
When you want to use a different template for a specific field, you can use the
\&\f(CW\*(C`template\*(C'\fR field in the configuration file.
.PP
.Vb 4
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir       => File::Spec\->catdir( dirname( _\|_FILE_\|_ ) || \*(Aq.\*(Aq, \*(Aqconf\*(Aq ),
\&    template  => \*(Aq<label for="<%= $id %>"><%= $label %>:</label><div><%= $field %></div>\*(Aq,
\&  };
.Ve
.PP
With a configuration file like
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "name" : "name"
\&    }
\&    {
\&        "label" : "Country",
\&        "type" : "select",
\&        "name" : "country",
\&        "data" : [ "au" ],
\&        "template" : "<%= $label %>: <%= $field %>"
\&    }
\& ]
.Ve
.PP
You get
.PP
.Vb 1
\&  <label for="name">Name:</label><div><input id="name" name="name" type="text" value="" /></div>
\&  
\&   
\&  Country: <select id="country" name="country"><option value="au">au</option></select>
.Ve
.SS "Template variables"
.IX Subsection "Template variables"
You get three template variables for free:
.IP "\(bu" 4
\&\f(CW$label\fR
.Sp
If a label is defined in the field configuration
.IP "\(bu" 4
\&\f(CW$field\fR
.Sp
The form field (\s-1HTML\s0)
.IP "\(bu" 4
\&\f(CW$id\fR
.Sp
The id for the field. If no id is defined, the name of the field is set.
.SH "Validation"
.IX Header "Validation"
You can define some validation rules in your config file. And when you call \f(CW\*(C`validate_form_fields\*(C'\fR, the
fields defined in the configuration file are validated.
.PP
Mojolicious::Validator::Validation is shipped with some basic validation checks:
.IP "\(bu" 4
in
.IP "\(bu" 4
size
.IP "\(bu" 4
like
.IP "\(bu" 4
equal_to
.PP
There is Mojolicious::Plugin::AdditionalValidationChecks with some more basic checks. And you can also
define your own checks.
.PP
The \fIvalidation\fR field is a hashref where the name of the check is the key
and the parameters for the check can be defined in the value:
.PP
.Vb 3
\&  "validation" : {
\&      "size" : [ 2, 5 ]
\&  },
.Ve
.PP
This will call \f(CW\*(C`\->size(2,5)\*(C'\fR. If you want to pass a single parameter,
you can set a scalar:
.PP
.Vb 3
\&  "validation" : {
\&      "equal_to" : "foo"
\&  },
.Ve
.PP
Validation checks are done in asciibetical order.
.SS "Check a string for its length"
.IX Subsection "Check a string for its length"
This is a simple check for the length of a string
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "validation" : {
\&            "size" : [ 2, 5 ]
\&        },
\&        "name" : "name"
\&    }
\& ]
.Ve
.PP
Then you can call \f(CW\*(C`validate_form_fields\*(C'\fR:
.PP
.Vb 1
\&  my %errors = $c\->validate_form_fields( $config_name );
.Ve
.PP
In the returned hash, you get the fieldnames as keys where a validation check fails.
.SS "A mandatory string"
.IX Subsection "A mandatory string"
If you have mandatory fields, you can define them as required
.PP
.Vb 10
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "validation" : {
\&            "required" : "name"
\&        },
\&        "name" : "name"
\&    }
\& ]
.Ve
.SS "Provide your own error message"
.IX Subsection "Provide your own error message"
With the simple configuration seen above, the \f(CW%error\fR hash contains the value \*(L"1\*(R" for
each invalid field. If you want to get a better error message, you can define a hash
in the validation config
.PP
.Vb 11
\& [
\&    {
\&        "label" : "Name",
\&        "type" : "text",
\&        "validation" : {
\&            "like" : { "args" : [ "es" ], "msg" : "text must contain \*(Aqes\*(Aq" },
\&            "size" : { "args" : [ 2, 5 ], "msg" : "length must be between 2 and 5 chars" }
\&        },
\&        "name" : "name"
\&    }
\& ]
.Ve
.PP
Examples:
.PP
.Vb 5
\&  text   | error
\&  \-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  test   |
\&  t      | text must contain \*(Aqes\*(Aq
\&  tester | length must be between 2 and 5 chars
.Ve
.SH "Translation"
.IX Header "Translation"
Most webapplications nowadays are internationalized, therefor this module
provides some support for translations.
.PP
If \fItranslate_labels\fR is set to a true value, a template is used and
\&\fItranslation_method\fR is given, the labels are translated.
.SS "translation_method"
.IX Subsection "translation_method"
\&\fItranslation_method\fR has to be a reference to a subroutine.
.PP
\fIAn example for translation\fR
.IX Subsection "An example for translation"
.PP
Load and configure the plugin:
.PP
.Vb 6
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    dir                => File::Spec\->catdir( dirname( _\|_FILE_\|_ ) || \*(Aq.\*(Aq, \*(Aqconf\*(Aq ),
\&    template           => \*(Aq<label for="<%= $id %>"><%= $label %>:</label><div><%= $field %></div>\*(Aq,
\&    translate_labels   => 1,
\&    translation_method => \e&loc,
\&  };
.Ve
.PP
The translation method gets two parameters:
.IP "\(bu" 4
the controller object
.IP "\(bu" 4
the label
.PP
.Vb 2
\&  sub loc {
\&      my ($c, $value) = @_;
\&  
\&      my %translation = ( Address => \*(AqAdresse\*(Aq );
\&      return $translation{$value} // $value;
\&  };
.Ve
.PP
This can be a more complex subroutine that makes use of any translation framework.
.PP
Given this field configuration file:
.PP
.Vb 7
\& [
\&    {
\&        "label" : "Address",
\&        "type" : "text",
\&        "name" : "name"
\&    }
\& ]
.Ve
.PP
You'll get
.PP
.Vb 1
\&  <label for="name">Adresse:</label><div><input id="name" name="name" type="text" value="" /></div>
.Ve
.SS "Internationalization"
.IX Subsection "Internationalization"
There is more about internationalization (i18n) than just translation. There are
dates, ranges, order of characters etc. But that can't be covered within this
single module. There are more Mojolicious plugins that provide more features
about i18n:
.IP "\(bu" 4
Mojolicious::Plugin::I18N
.IP "\(bu" 4
Mojolicious::Plugin::TagHelpersI18N
.IP "\(bu" 4
Mojolicious::Plugin::I18NUtils
.IP "\(bu" 4
Mojolicious::Plugin::CountryDropDown
.PP
You can combine these plugins with this plugin. An example is available at
the code repository <http://github.com/reneeb/Mojolicious-Plugin-FormFieldsFromJSON/tree/master/example>.
.SS "New Types"
.IX Subsection "New Types"
The field types supported by this plugin might not enough for you. Then you can create your own plugin
and add new types. For example, dates in \s-1OTRS\s0 <http://otrs.org> are shown as three dropdowns: one for
the day, one for the month and finally one for the year.
.PP
Wouldn't it be nice to define only one field in your config and the rest is \s-1DWIM\s0 (Do what I mean)?
It would.
.PP
So you can write your own Mojolicious plugin where the register subroutine does nothing. And you define
a subroutine called \f(CW\*(C`Mojolicious::Plugin::FormFieldsFromJSON::_date\*(C'\fR where those dropdowns are created.
.PP
Then just do:
.PP
.Vb 6
\&  plugin \*(AqWhateverYouHaveChosen\*(Aq;
\&  plugin \*(AqFormFieldsFromJSON\*(Aq => {
\&    types => {
\&        \*(Aqdate\*(Aq => 1,
\&    },
\&  };
.Ve
.PP
Now you can use
.PP
.Vb 7
\&  [
\&    {
\&      "label" : "Release date",
\&      "type" : "date",
\&      "name" : "release"
\&    }
\&  ]
.Ve
.PP
The subroutine gets these parameters:
.IP "\(bu" 4
The plugin object (Mojolicious::Plugin::FormFieldsFromJSON object)
.Sp
So you can use the methods defined in this plugin, for example to create
dropdowns, textfields, ...
.IP "\(bu" 4
The controller object (Whatever controller called \f(CW\*(C`form_fields\*(C'\fR method)
.Sp
So you can use all the Mojolicious power!
.IP "\(bu" 4
The field config
.Sp
Whatever you defined in you .json config file for that field
.IP "\(bu" 4
A params hash
.Sp
Whatever is passed as parameters to the \f(CW\*(C`form_fields\*(C'\fR method.
.PP
As an example, you can see Mojolicious::Plugin::FormFieldsFromJSON::Date.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicio.us>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Renee Baecker <reneeb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2016 by Renee Baecker.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Renee Baecker <reneeb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2018 by Renee Baecker.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
