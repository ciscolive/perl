.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::ExcelXML::XMLReader 3"
.TH Spreadsheet::Reader::ExcelXML::XMLReader 3 "2017-04-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::ExcelXML::XMLReader \- A minimal pure\-perl xml reader class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&        package MyPackage;
\&        use MooseX::StrictConstructor;
\&        use MooseX::HasDefaults::RO;
\&        # You have to \*(Aquse\*(Aq or build a the Workbook here or the XMLReader won\*(Aqt load
\&        #  \-> because the reader uses a regex to scrap imported methods
\&        use Spreadsheet::Reader::ExcelXML::Workbook;
\&        extends \*(AqSpreadsheet::Reader::ExcelXML::XMLReader\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This documentation is written to explain ways to use this module when writing your own
excel spreadsheet parser.  I suppose the class could be used more generally but that's
not why I wrote it and for now I have no intention of providing a full xml toolbox.
For Excel spreadsheet parsing generally please start at the top level documentation.
Workbooks,
Worksheets, and
Cells.
.PP
This class is meant to be used as the base reading class for specific types of xml
files.  The reader for those specific files will include roles that are useful for
that files content.  When the file first loads it will store some available information
from the header (?) nodes and move to the first file node.  At that point it will
check if any of the consuming roles have a method '_load_unique_bits'  If so it
will call that method for additional meta data collection by that role.
.PP
This class will process the xml file in a just in time fashion holding enough
information to know the level and open nodes not yet closed but nothing else.  The
intent is to use a little \s-1RAM\s0 as possible and process the file in the most
(pure perl) computationaly efficient way possible.  I welcome all suggestions for
improvement.
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to new when creating an instance.  For modification of these attributes
see the listed 'attribute methods'. For general information on attributes see
Moose::Manual::Attributes.  For ways to manage the instance after it is opened
see the Methods.
.PP
\fIfile\fR
.IX Subsection "file"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds the file handle for the file being read.  If
the full file name and path is passed to the attribute the class will coerce that
into an IO::File file handle.
.Sp
\&\fBDefault:\fR no default \- this must be provided to read a file
.Sp
\&\fBRequired:\fR yes
.Sp
\&\fBRange:\fR any unencrypted xml file name and path or IO::File file handle set to
read.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR change the file value in the attribute (this will reboot
the file instance and lock the file)
.RE
.RE
.RS 4
.Sp
\&\fBget_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the file handle of the file even if a file name
was passed
.RE
.RE
.RS 4
.Sp
\&\fBhas_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR this is used to see if the file loaded correctly.
.RE
.RE
.RS 4
.Sp
\&\fBclear_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR this clears (and unlocks) the file handle
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBDelegated Methods\fR
.Sp
.RS 4
close
.Sp
.RS 4
closes the file handle
.RE
.RE
.RS 4
.Sp
seek
.Sp
.RS 4
allows seek commands to be passed to the file handle
.RE
.RE
.RS 4
.Sp
getline
.Sp
.RS 4
returns the next line of the file handle with '<' set as the
input_record_separator ($/) <http://perldoc.perl.org/perlvar.html>
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIworkbook_inst\fR
.IX Subsection "workbook_inst"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds a reference to the top level workbook (parser).
The purpose is to use some of the methods provided there.
.Sp
\&\fBDefault:\fR no default
.Sp
\&\fBRequired:\fR not strictly for this class but the attribute is provided to give
self referential access to general workbook settings and methods for composed
classes that inherit this a base class.
.Sp
\&\fBRange:\fR isa => 'Spreadsheet::Reader::ExcelXML::Workbook'
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_workbook_inst\fR
.Sp
.RS 4
set the attribute with a workbook instance
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBDelegated Methods (required)\fR Methods delegated to this module by the
attribute.  All methods are delegated with the method name unchanged.
Follow the link to review documentation of the provider for each method.
As you can see several are delegated through the Workbook level and
don't originate there.
.Sp
.RS 4
\&\*(L"get_group_return_type\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"counting_from_zero\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"are_spaces_empty\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"has_shared_strings_interface\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"should_skip_hidden\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"spreading_merged_values\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"starts_at_the_edge\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_empty_return_type\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_values_only\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_epoch_year\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_error_inst\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"has_styles_interface\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"boundary_flag_setting\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"is_empty_the_end\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_rel_info\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_sheet_info\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_sheet_names\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"collecting_merge_data\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"collecting_column_formats\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"set_error( \f(CW$error_string\fR )\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"get_defined_conversion( \f(CW$position\fR )\*(R" in Spreadsheet::Reader::Format
.Sp
\&\*(L"set_defined_excel_formats( \f(CW%args\fR )\*(R" in Spreadsheet::Reader::Format
.Sp
\&\*(L"parse_excel_format_string( \f(CW$string\fR, \f(CW$name\fR )\*(R" in Spreadsheet::Reader::Format
.Sp
\&\*(L"change_output_encoding( \f(CW$string\fR )\*(R" in Spreadsheet::Reader::Format
.Sp
\&\*(L"get_shared_string( \f(CW$positive_int\fR|$name )\*(R" in Spreadsheet::Reader::ExcelXML::SharedStrings
.Sp
\&\*(L"get_format( ($position|$name), [$header], [$exclude_header] )\*(R" in Spreadsheet::Reader::ExcelXML::Styles
.RE
.RE
.RS 4
.RE
.PP
\fIxml_version\fR
.IX Subsection "xml_version"
.Sp
.RS 4
\&\fBDefinition:\fR This stores the xml version read from the xml header.  It is read
when the file handle is first set in this sheet.
.Sp
\&\fBDefault:\fR no default \- this is auto read from the header
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR xml versions
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBversion\fR
.Sp
.RS 4
get the stored xml version
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIxml_encoding\fR
.IX Subsection "xml_encoding"
.Sp
.RS 4
\&\fBDefinition:\fR This stores the data encoding of the xml file from the xml header.
It is read when the file handle is first set in this sheet.
.Sp
\&\fBDefault:\fR no default \- this is auto read from the header
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR valid xml file encoding
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBencoding\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_encoding\fR
.Sp
.RS 4
predicate for the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIxml_progid\fR
.IX Subsection "xml_progid"
.Sp
.RS 4
\&\fBDefinition:\fR This is an attribute found in a secondary xml header that
is associated with Excel 2003 xml based files.  The value can be tested
to see if the file was intended to be compliant with that format.
.Sp
\&\fBDefault:\fR no default \- this is auto read from the header
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR a string
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBprogid\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_progid\fR
.Sp
.RS 4
predicate for the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIxml_header\fR
.IX Subsection "xml_header"
.Sp
.RS 4
\&\fBDefinition:\fR This stores the primary xml header string from the xml file.  It
is read when the file handle is first set in this sheet.  I contains both the
verion and the encoding where available and is used when building subsets of
the file as standalone xml.
.Sp
\&\fBDefault:\fR no default \- this is auto read from the header
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR valid xml file header
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_header\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fB_set_xml_header\fR
.Sp
.RS 4
set the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIxml_doctype\fR
.IX Subsection "xml_doctype"
.Sp
.RS 4
\&\fBDefinition:\fR This stores the \s-1DOCTYPE\s0 indicated in the \s-1XML\s0 header !DOCTYPE
.Sp
\&\fBDefault:\fR no default \- this is auto read from the header
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR whatever it finds
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBdoctype\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_doctype\fR
.Sp
.RS 4
predicate for the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIposition_index\fR
.IX Subsection "position_index"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute is available to facilitate other consuming roles and
classes.  Of this attributes methods only the 'clear_location' method is used in this
class during the start_the_file_over method.  It can be used
for tracking positions with the same node name.
.Sp
\&\fBDefault:\fR no default \- this is mostly managed by the role or child class
.Sp
\&\fBRequired:\fR no
.Sp
\&\fBRange:\fR Integer
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBwhere_am_i\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBi_am_here\fR
.Sp
.RS 4
set the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBclear_location\fR
.Sp
.RS 4
clear the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_position\fR
.Sp
.RS 4
set the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIfile_type\fR
.IX Subsection "file_type"
.Sp
.RS 4
\&\fBDefinition:\fR This is a static attribute that shows the file type
.Sp
\&\fBDefault:\fR xml
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_file_type\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIstacking\fR
.IX Subsection "stacking"
.Sp
.RS 4
\&\fBDefinition:\fR a pure perl xml parser will in general be slower than the C equivalent.
To provide some acceleration to arrive at a target destination you can turn of the stack
trace which will include building and storing the trace elements.  This breaks things so
don't do it without a solid understanding of what is happening.  For instance if you turn
this off and then call the method parse_element  The
parse_element method will have to turn the stack trace back on on it's own to build the
element tree.  The issue is that the most recent element at the base of the tree won't be
available to build from.  You will need to manually build it and push it to the stack.  See
the methods initial_node_build and
add_node_to_stack to implement this.
.Sp
\&\fBDefault:\fR 1 = the stack trace is on
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBshould_be_stacking\fR
.Sp
.RS 4
get the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBchange_stack_storage_to( \f(CB$Bool\fB )\fR
.Sp
.RS 4
Turn the stack trace(r) state to \f(CW$Bool\fR (1 = on)
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SS "Methods"
.IX Subsection "Methods"
These are the methods provided by this class.
.PP
\fIstart_the_file_over\fR
.IX Subsection "start_the_file_over"
.Sp
.RS 4
\&\fBDefinition:\fR Clears the position_index, the old stack trace, and kick starts
stack trace tracking again.  It then uses seek(0, 0) to reset the file handle to the
beginning.  Finally, it reads the file until it gets to the first non-xml header node.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIgood_load( \f(CI$state\fI )\fR
.IX Subsection "good_load( $state )"
.Sp
.RS 4
\&\fBDefinition:\fR a setter method to indicated if the file loaded correctly.  This
generally should be set by consuming roles in the load_unique_bits
 phase.
.Sp
\&\fBAccepts:\fR (1|0)
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIloaded_correctly\fR
.IX Subsection "loaded_correctly"
.Sp
.RS 4
\&\fBDefinition:\fR a getter method to understand if the file loaded correctly.
This is generally used by consumers of the instance to see if there was any
trouble during the initial build.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 = good build, 0 = bad_build
.RE
.PP
\fIparse_element( [$depth] )\fR
.IX Subsection "parse_element( [$depth] )"
.Sp
.RS 4
\&\fBDefinition:\fR This will read and store the full node from the current position
down to an optional \f(CW$depth\fR.  When the parse is complete the parser will be
positioned at the beginning of the next node.  The node does not include the
top name but will include attributes.
.Sp
\&\fBAccepts:\fR \f(CW$depth\fR = optional
.Sp
\&\fBReturns:\fR A perl hash reference where all nodes at a level are listed using three
hashref keys; list_keys, list, and attributes.  The 'attributes' key points to a
hash reference containing that nodes attributes.  The 'list_keys' key points to an
array reference with all the node names for each node at the next level down.  The
\&'list' key points to an array reference of nodes or node values matching the position
of the list_keys.  There are two special case exceptions to this.  First, for text
values the node is listed as { raw_text => 'text node content' }.  Second, if the
attributes only include a 'val' key the node stores this under the 'val' key rather
than the 'attributes' key with a sub key 'val'.
.RE
.PP
\fIadvance_element_position( \f(CI$element\fI, [$iterations] )\fR
.IX Subsection "advance_element_position( $element, [$iterations] )"
.Sp
.RS 4
\&\fBDefinition:\fR This will move the xml file reader forward until it finds the identified named
\&\f(CW$element\fR.  If the reader is already at an element of that name it will index forward until it finds
the next \f(CW$element\fR of that name.  If the optional positive \f(CW$iterations\fR integer is passed it will index
to the named \f(CW$element\fR \- \f(CW$iterations\fR times.
.Sp
\&\fBAccepts:\fR \f(CW$element\fR = a case sensitive xml node name found forward of the
current position in the file.  [$iterations] = optional a positive integer
indicating how many times to index forward to the named \f(CW$element\fR.
.Sp
\&\fBReturns:\fR a list of 4 positions ( \f(CW$success\fR, \f(CW$node_name\fR, \f(CW$node_level\fR, \f(CW$return_node_ref\fR )
.Sp
\&\f(CW$success\fR = a boolean value indicating whether the desired goal was met, \f(CW$node_name\fR = the actual node
name for the final position (should match \f(CW$element\fR if \f(CW$success\fR), \f(CW$node_level\fR = the level of the final
named node in the stack( not the sub text node ) \f(CW$return_node_ref\fR = When the stacking
attribute is on this returns the last displaced elements in the stack displaced by the traverse of
the xml tree.  When stacking is off this returns an array ref of values used as the second argument in
initial_node_build.
.RE
.PP
\fInext_sibling\fR
.IX Subsection "next_sibling"
.Sp
.RS 4
\&\fBDefinition:\fR This will move the xml file reader forward until it finds next
node at the same level as the current node within the same supernode.  If this
method finds a higher node prior to finding a node at the same level it will
return failure and stop reading.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a list of 4 positions ( \f(CW$success\fR, \f(CW$node_name\fR, \f(CW$node_level\fR, \f(CW$return_node_ref\fR )
.Sp
\&\f(CW$success\fR = a boolean value indicating whether the desired goal was met, \f(CW$node_name\fR = the actual node
name for the final position (should match \f(CW$element\fR if \f(CW$success\fR), \f(CW$node_level\fR = the level of the final
named node in the stack( not the sub text node ) \f(CW$return_node_ref\fR = When the stacking
attribute is on this returns the last displaced elements in the stack displaced by the traverse of
the xml tree.  When stacking is off this returns an array ref of values used as the second argument in
initial_node_build.
.RE
.PP
\fIskip_siblings\fR
.IX Subsection "skip_siblings"
.Sp
.RS 4
\&\fBDefinition:\fR This will move the xml file reader forward until it finds next
node higher.  It will not stop on end nodes so it will continue to pass all
closed nodes until it comes to the first open or self contained node above
the current node.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a list of 4 positions ( \f(CW$success\fR, \f(CW$node_name\fR, \f(CW$node_level\fR, \f(CW$return_node_ref\fR )
.Sp
\&\f(CW$success\fR = a boolean value indicating whether the desired goal was met, \f(CW$node_name\fR = the actual node
name for the final position (should match \f(CW$element\fR if \f(CW$success\fR), \f(CW$node_level\fR = the level of the final
named node in the stack( not the sub text node ) \f(CW$return_node_ref\fR = When the stacking
attribute is on this returns the last displaced elements in the stack displaced by the traverse of
the xml tree.  When stacking is off this returns an array ref of values used as the second argument in
initial_node_build.
.RE
.PP
\fIcurrent_named_node\fR
.IX Subsection "current_named_node"
.Sp
.RS 4
\&\fBDefinition:\fR when processing xml files in a just in time fashion there
will be some ambiguity surrounding text nodes;
.Sp
.Vb 3
\&        <t>sometext</t>
\&        <s>
\&           <r val="2"/>
.Ve
.Sp
In the 't' node example the content between the '>' character and the '<'
characters are intentional and valuable to the data set.  In the 's' and
\&'r' node example the space between those characters is only intended for
human readability.  This parser will not be able to tell the value of the
content after the 's' node '>' character until the 'r' node is read.  At
that point the 's' node will no longer be the 'current' position.  To
resolve this, all content other than '' between '>' and '<' is treated as
a node until the next node is read.  Because these nodes are ambiguous
the idea of a 'named node' is valuable and knowing what the most recent
named node is can be useful.  This method either returns the last read node
or the second to last node if the last node is a raw text node.  In the
first example it would return the 't' node and in the second example it
would return the 's' node.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a hash ref of information about the node containing the
following keys;
.Sp
.Vb 7
\&        level => counting from 0 at the start of the file and moving up
\&        type => regular = xml named node|#text = node built from the contents between the > and < characters
\&        name => the xml node name (for #text nodes this is \*(Aqraw_text\*(Aq)
\&        closed => (closed|open) depending on the current tag state
\&        initial_string => The string inside the < > quotes prior to parsing
\&        [attributes] => all attributes and values will be stored under the attribute name
\&        [val] => special case storage of one attribute
.Ve
.RE
.PP
\fIsquash_node( \f(CI$node\fI )\fR
.IX Subsection "squash_node( $node )"
.Sp
.RS 4
\&\fBDefinition:\fR This takes a \f(CW$node\fR from the parse_element output
and turns it into a more perl like reference.  It checks the list_keys and if
there are any duplicates it takes the list values and uses them as elements of
an array ref assigned to a hash key called list.  If there are no duplicates
in the list_keys it turns the list_keys into hash keys with the list elements
assigned as values.  It then takes the attributes and mingles them in the hashref
with the prior results.  There are two special cases for a node reorganization.
For nodes with a 'val' in the 'list_keys' then the element in the same position of
the 'list' is returned as the whole ref.  If there is a raw_text node it is returned
as a hashref with one key 'raw_text' with the text itself as the value.  This
is all done recursivly so lower layers are assigned to upper layers using the
rules above.
.Sp
\&\fBAccepts:\fR the output of a parse_element call
.Sp
\&\fBReturns:\fR a perl data structure with the xml organization removed
.RE
.PP
\fIextract_file( \f(CI@node_list\fI )\fR
.IX Subsection "extract_file( @node_list )"
.Sp
.RS 4
\&\fBDefinition:\fR This will build an xml file and load it to a IO::Handle\->new_tmpfile
object.  The xml is built on whole extracted xml strings defined by \f(CW@node_list\fR.
If none of the node list elements is found in the parsed file then the first
listed element from the node list will be used to create an empty self closing
node.
.Sp
\&\fBAccepts:\fR \f(CW@node_list\fR =  Node list items can either be xml node name strings or array refs
composed of two elements, first the node name and second the iterated position. Ex.
.Sp
.Vb 1
\&        @node_list_example = ( \*(Aqr\*(Aq, [ \*(Aqsi\*(Aq, 3 ] );
.Ve
.Sp
In this example the extracted file would contain the first 'r' node and the 3rd
\&'si' node.the output of a parse_element call.  There is the
exception case where you just want the whole file passed.  The out here is to
pass '\s-1ALL_FILE\s0' as the first element of the \f(CW@node_list\fR and a complete copy of
the file_handle in read mode will be passed.
.Sp
\&\fBReturns:\fR a File::Temp file handle loaded with an xml header and the listed
nodes.
.RE
.PP
\fIcurrent_node_parsed\fR
.IX Subsection "current_node_parsed"
.Sp
.RS 4
\&\fBDefinition:\fR When nodes are read they are not completely processed to save
cycles.  If you want a fully processed result from the current node position
including any embedded text then this is the method for you.
.Sp
\&\fBAccepts:\fR Nothing
.Sp
\&\fBReturns:\fR a perl ref equivalent to the squash_node call. This only returns the
fully processed current_named_node and any sub text nodes.
.RE
.PP
\fIclose_the_file\fR
.IX Subsection "close_the_file"
.Sp
.RS 4
\&\fBDefinition:\fR It may be that the file(handle) may not be needed during the whole
workbook parse.  If so you can use this method to close (and clear / release) an
open file handle as appropriate.
.Sp
\&\fBAccepts:\fR Nothing
.Sp
\&\fBReturns:\fR Nothing (the file handle is closed and cleared)
.RE
.PP
\fInot_end_of_file\fR
.IX Subsection "not_end_of_file"
.Sp
.RS 4
\&\fBDefinition:\fR This is a poor mans End Of File test (\s-1EOF\s0).  The reader builds
a node stack to keep track of where it is in the xml parse and when it runs out
of nodes it means you are back at the top of the stack.
.Sp
\&\fBAccepts:\fR Nothing
.Sp
\&\fBReturns:\fR a count of the nodes in the node stack (header nodes are processed
early on and are read and removed as part of startup)
.RE
.PP
\fIinitial_node_build( \f(CI$node_name\fI, \f(CI$attribute_list_ref\fI )\fR
.IX Subsection "initial_node_build( $node_name, $attribute_list_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR Generally this is an internal method and should not be used.  However,
in order to provide a faster forward ability the node stack trace(ing) can be
turned off.  When you want to turn it back on you have to manually build
the top node using this method and store it to the node stack using add_node_to_stack
\&.  This method will build the essentials for adding
to the node stack.  Please not that it will not necessarily get the node level right.
\&\fIIf you need that to be correct then don't turn off the stack trace.\fR  It will not
build raw_text nodes correctly.
.Sp
\&\fBAccepts:\fR
	\f(CW$node_name\fR = a string without spaces for the name of the node,
	\f(CW$attribute_list_ref\fR = This is basically everything else in the xml tag except the name
	split on /\es+/.  Any self closing '/' should be removed prior to the split.
.Sp
\&\fBReturns:\fR a node ref that can be added to the node stack to kickstart stack tracing
.RE
.PP
\fIadd_node_to_stack( \f(CI$node_ref\fI )\fR
.IX Subsection "add_node_to_stack( $node_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR Generally this is an internal method and should not be used.  However,
in order to provide a faster forward ability the node stack trace(ing) can be
turned off.  When you want to turn it back on you have to manually build
the top node and store it to the node stack using this method.  Adding a node after the stack
trace has been turned off will create a discontinuity where the new node is added.  Stack
trace operations above this node will generally fail and stop the script.
.Sp
\&\fBAccepts:\fR \f(CW$node_ref\fR = a top to push on the node stack for traceability
.Sp
\&\fBReturns:\fR nothing
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::ExcelXML/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-excelxml/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Nothing currently
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
Spreadsheet::Reader::ExcelXML \- the package
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::Read \- generic Spreadsheet reader
.Sp
Spreadsheet::ParseExcel \- Excel binary version 2003 and earlier (.xls files)
.Sp
Spreadsheet::XLSX \- Excel version 2007 and later
.Sp
Spreadsheet::ParseXLSX \- Excel version 2007 and later
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
