.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Custom 3"
.TH DBIx::Custom 3 "2020-08-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Custom \- DBI extension to execute insert, update, delete, and select easily
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBIx::Custom;
\&  
\&  # Connect
\&  my $dbi = DBIx::Custom\->connect(
\&    "dbi:mysql:database=dbname",
\&    \*(Aqken\*(Aq,
\&    \*(Aq!LFKD%$&\*(Aq,
\&    {mysql_enable_utf8 => 1}
\&  );
\&  
\&  # Create model
\&  $dbi\->create_model(\*(Aqbook\*(Aq);
\&  
\&  # Insert 
\&  $dbi\->model(\*(Aqbook\*(Aq)\->insert({title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq});
\&  
\&  # Update 
\&  $dbi\->model(\*(Aqbook\*(Aq)\->update({title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq}, where  => {id => 5});
\&  
\&  # Delete
\&  $dbi\->model(\*(Aqbook\*(Aq)\->delete(where => {author => \*(AqKen\*(Aq});
\&  
\&  # Select
\&  my $result = $dbi\->model(\*(Aqbook\*(Aq)\->select([\*(Aqtitle\*(Aq, \*(Aqauthor\*(Aq], where  => {author => \*(AqKen\*(Aq});
\&  
\&  # Select, more complex
\&  #   select book.title as book.title,
\&  #     book.author as book.author,
\&  #     comnapy.name as company.name
\&  #   form book
\&  #     left outer join company on book.company_id = company.id
\&  #   where book.author = ?
\&  #   order by id limit 0, 5
\&  my $result = $dbi\->model(\*(Aqbook\*(Aq)\->select(
\&    [
\&      {book => [qw/title author/]},
\&      {company => [\*(Aqname\*(Aq]}
\&    ],
\&    where  => {\*(Aqbook.author\*(Aq => \*(AqKen\*(Aq},
\&    join => [\*(Aqleft outer join company on book.company_id = company.id\*(Aq],
\&    append => \*(Aqorder by id limit 0, 5\*(Aq
\&  );
\&  
\&  # Get all rows or only one row
\&  my $rows = $result\->all;
\&  my $row = $result\->one;
\&  
\&  # Execute SQL with named place holder
\&  my $result = $dbi\->execute(
\&    "select id from book where author = :author and title like :title",
\&    {author => \*(Aqken\*(Aq, title => \*(Aq%Perl%\*(Aq}
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Custom is \s-1DBI\s0 wrapper module to execute \s-1SQL\s0 easily.
This module have the following features.
.IP "\(bu" 4
Execute \f(CW\*(C`insert\*(C'\fR, \f(CW\*(C`update\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, or \f(CW\*(C`select\*(C'\fR statement easily
.IP "\(bu" 4
Create \f(CW\*(C`where\*(C'\fR clause flexibly
.IP "\(bu" 4
Named place holder support
.IP "\(bu" 4
Model support
.IP "\(bu" 4
Connection manager support
.IP "\(bu" 4
Choice your favorite relational database management system,
\&\f(CW\*(C`MySQL\*(C'\fR, \f(CW\*(C`SQLite\*(C'\fR, \f(CW\*(C`PostgreSQL\*(C'\fR, \f(CW\*(C`Oracle\*(C'\fR,
\&\f(CW\*(C`Microsoft SQL Server\*(C'\fR, \f(CW\*(C`Microsoft Access\*(C'\fR, \f(CW\*(C`DB2\*(C'\fR or anything,
.IP "\(bu" 4
Filtering by data type or column name
.IP "\(bu" 4
Create \f(CW\*(C`order by\*(C'\fR clause flexibly
.SH "WEB SITE"
.IX Header "WEB SITE"
DBIx::Custom \- Perl O/R Mapper <http://dbix-custom.hateblo.jp>
.SH "DOCUMENTS"
.IX Header "DOCUMENTS"
DBIx::Custom Documents <https://github.com/yuki-kimoto/DBIx-Custom/wiki>
.PP
DBIx::Custom \s-1API\s0 reference <http://search.cpan.org/~kimoto/DBIx-Custom/>
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "connector"
.IX Subsection "connector"
.Vb 2
\&  my $connector = $dbi\->connector;
\&  $dbi = $dbi\->connector($connector);
.Ve
.PP
Connection manager object. if \f(CW\*(C`connector\*(C'\fR is set, you can get \f(CW\*(C`dbh\*(C'\fR
through connection manager. Conection manager object must have \f(CW\*(C`dbh\*(C'\fR method.
.PP
This is DBIx::Connector example. Please pass
\&\f(CW\*(C`default_option\*(C'\fR to DBIx::Connector \f(CW\*(C`new\*(C'\fR method.
.PP
.Vb 6
\&  my $connector = DBIx::Connector\->new(
\&    "dbi:mysql:database=$database",
\&    $user,
\&    $password,
\&    DBIx::Custom\->new\->default_option
\&  );
\&  
\&  my $dbi = DBIx::Custom\->connect(connector => $connector);
.Ve
.PP
If \f(CW\*(C`connector\*(C'\fR is set to 1 when connect method is called,
DBIx::Connector is automatically set to \f(CW\*(C`connector\*(C'\fR
.PP
.Vb 2
\&  my $dbi = DBIx::Custom\->connect(
\&    dsn => $dsn, user => $user, password => $password, connector => 1);
\&  
\&  my $connector = $dbi\->connector; # DBIx::Connector
.Ve
.PP
Note that DBIx::Connector must be installed.
.SS "dsn"
.IX Subsection "dsn"
.Vb 2
\&  my $dsn = $dbi\->dsn;
\&  $dbi = $dbi\->dsn("DBI:mysql:database=dbname");
.Ve
.PP
Data source name, used when \f(CW\*(C`connect\*(C'\fR method is executed.
.SS "default_option"
.IX Subsection "default_option"
.Vb 2
\&  my $default_option = $dbi\->default_option;
\&  $dbi = $dbi\->default_option($default_option);
.Ve
.PP
\&\s-1DBI\s0 default option, used when \f(CW\*(C`connect\*(C'\fR method is executed,
default to the following values.
.PP
.Vb 5
\&  {
\&    RaiseError => 1,
\&    PrintError => 0,
\&    AutoCommit => 1,
\&  }
.Ve
.SS "exclude_table"
.IX Subsection "exclude_table"
.Vb 2
\&  my $exclude_table = $dbi\->exclude_table;
\&  $dbi = $dbi\->exclude_table(qr/pg_/);
.Ve
.PP
Excluded table regex.
\&\f(CW\*(C`each_column\*(C'\fR, \f(CW\*(C`each_table\*(C'\fR, \f(CW\*(C`type_rule\*(C'\fR
.SS "filters"
.IX Subsection "filters"
.Vb 2
\&  my $filters = $dbi\->filters;
\&  $dbi = $dbi\->filters(\e%filters);
.Ve
.PP
Filters, registered by \f(CW\*(C`register_filter\*(C'\fR method.
.SS "last_sql"
.IX Subsection "last_sql"
.Vb 2
\&  my $last_sql = $dbi\->last_sql;
\&  $dbi = $dbi\->last_sql($last_sql);
.Ve
.PP
Get last succeeded \s-1SQL\s0 executed by \f(CW\*(C`execute\*(C'\fR method.
.SS "now"
.IX Subsection "now"
.Vb 2
\&  my $now = $dbi\->now;
\&  $dbi = $dbi\->now($now);
.Ve
.PP
Code reference which return current time, default to the following code reference.
.PP
.Vb 6
\&  sub {
\&    my ($sec, $min, $hour, $mday, $mon, $year) = localtime;
\&    $mon++;
\&    $year += 1900;
\&    return sprintf("%04d\-%02d\-%02d %02d:%02d:%02d");
\&  }
.Ve
.PP
This return the time like \f(CW\*(C`2011\-10\-14 05:05:27\*(C'\fR.
.PP
This is used by \f(CW\*(C`insert\*(C'\fR method's \f(CW\*(C`ctime\*(C'\fR option and \f(CW\*(C`mtime\*(C'\fR option,
and \f(CW\*(C`update\*(C'\fR method's \f(CW\*(C`mtime\*(C'\fR option.
.SS "models"
.IX Subsection "models"
.Vb 2
\&  my $models = $dbi\->models;
\&  $dbi = $dbi\->models(\e%models);
.Ve
.PP
Models, included by \f(CW\*(C`include_model\*(C'\fR method.
.SS "mytable_symbol"
.IX Subsection "mytable_symbol"
Symbol to specify own columns in select method column option, default to '_\|_MY_\|_'.
.PP
.Vb 1
\&  $dbi\->table(\*(Aqbook\*(Aq)\->select({_\|_MY_\|_ => \*(Aq*\*(Aq});
.Ve
.SS "option"
.IX Subsection "option"
.Vb 2
\&  my $option = $dbi\->option;
\&  $dbi = $dbi\->option($option);
.Ve
.PP
\&\s-1DBI\s0 option, used when \f(CW\*(C`connect\*(C'\fR method is executed.
Each value in option override the value of \f(CW\*(C`default_option\*(C'\fR.
.SS "password"
.IX Subsection "password"
.Vb 2
\&  my $password = $dbi\->password;
\&  $dbi = $dbi\->password(\*(Aqlkj&le\`@s\*(Aq);
.Ve
.PP
Password, used when \f(CW\*(C`connect\*(C'\fR method is executed.
.SS "quote"
.IX Subsection "quote"
.Vb 2
\&  my quote = $dbi\->quote;
\&  $dbi = $dbi\->quote(\*(Aq"\*(Aq);
.Ve
.PP
Reserved word quote.
Default to double quote '"' except for mysql.
In mysql, default to back quote '`'
.PP
You can set quote pair.
.PP
.Vb 1
\&  $dbi\->quote(\*(Aq[]\*(Aq);
.Ve
.SS "result_class"
.IX Subsection "result_class"
.Vb 2
\&  my $result_class = $dbi\->result_class;
\&  $dbi = $dbi\->result_class(\*(AqDBIx::Custom::Result\*(Aq);
.Ve
.PP
Result class, default to DBIx::Custom::Result.
.SS "safety_character"
.IX Subsection "safety_character"
.Vb 2
\&  my $safety_character = $dbi\->safety_character;
\&  $dbi = $dbi\->safety_character($character);
.Ve
.PP
Regex of safety character for table and column name, default to 'a\-zA\-Z_'.
Note that you don't have to specify like '[a\-zA\-Z_]'.
.SS "separator"
.IX Subsection "separator"
.Vb 2
\&  my $separator = $dbi\->separator;
\&  $dbi = $dbi\->separator(\*(Aq\-\*(Aq);
.Ve
.PP
Separator which join table name and column name.
This have effect to \f(CW\*(C`column\*(C'\fR and \f(CW\*(C`mycolumn\*(C'\fR method,
and \f(CW\*(C`select\*(C'\fR method's column option.
.PP
Default to \f(CW\*(C`.\*(C'\fR.
.SS "user"
.IX Subsection "user"
.Vb 2
\&  my $user = $dbi\->user;
\&  $dbi = $dbi\->user(\*(AqKen\*(Aq);
.Ve
.PP
User name, used when \f(CW\*(C`connect\*(C'\fR method is executed.
.SS "user_column_info"
.IX Subsection "user_column_info"
.Vb 2
\&  my $user_column_info = $dbi\->user_column_info;
\&  $dbi = $dbi\->user_column_info($user_column_info);
.Ve
.PP
You can set the date like the following one.
.PP
.Vb 4
\&  [
\&    {table => \*(Aqbook\*(Aq, column => \*(Aqtitle\*(Aq, info => {...}},
\&    {table => \*(Aqauthor\*(Aq, column => \*(Aqname\*(Aq, info => {...}}
\&  ]
.Ve
.PP
Usually, you set return value of \f(CW\*(C`get_column_info\*(C'\fR.
.PP
.Vb 3
\&  my $user_column_info
\&    = $dbi\->get_column_info(exclude_table => qr/^system/);
\&  $dbi\->user_column_info($user_column_info);
.Ve
.PP
If \f(CW\*(C`user_column_info\*(C'\fR is set, \f(CW\*(C`each_column\*(C'\fR use \f(CW\*(C`user_column_info\*(C'\fR
to find column info. this is very fast.
.SS "user_table_info"
.IX Subsection "user_table_info"
.Vb 2
\&  my $user_table_info = $dbi\->user_table_info;
\&  $dbi = $dbi\->user_table_info($user_table_info);
.Ve
.PP
You can set the following data.
.PP
.Vb 4
\&  [
\&    {table => \*(Aqbook\*(Aq, info => {...}},
\&    {table => \*(Aqauthor\*(Aq, info => {...}}
\&  ]
.Ve
.PP
Usually, you can set return value of \f(CW\*(C`get_table_info\*(C'\fR.
.PP
.Vb 2
\&  my $user_table_info = $dbi\->get_table_info(exclude => qr/^system/);
\&  $dbi\->user_table_info($user_table_info);
.Ve
.PP
If \f(CW\*(C`user_table_info\*(C'\fR is set, \f(CW\*(C`each_table\*(C'\fR use \f(CW\*(C`user_table_info\*(C'\fR
to find table info.
.SH "METHODS"
.IX Header "METHODS"
DBIx::Custom inherits all methods from Object::Simple
and use all methods of \s-1DBI\s0
and implements the following new ones.
.SS "available_datatype"
.IX Subsection "available_datatype"
.Vb 1
\&  print $dbi\->available_datatype;
.Ve
.PP
Get available data types. You can use these data types
in \f(CW\*(C`type rule\*(C'\fR's \f(CW\*(C`from1\*(C'\fR and \f(CW\*(C`from2\*(C'\fR section.
.SS "available_typename"
.IX Subsection "available_typename"
.Vb 1
\&  print $dbi\->available_typename;
.Ve
.PP
Get available type names. You can use these type names in
\&\f(CW\*(C`type_rule\*(C'\fR's \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR section.
.SS "assign_clause"
.IX Subsection "assign_clause"
.Vb 1
\&  my $assign_clause = $dbi\->assign_clause({title => \*(Aqa\*(Aq, age => 2});
.Ve
.PP
Create assign clause
.PP
.Vb 1
\&  title = :title, author = :author
.Ve
.PP
This is used to create update clause.
.PP
.Vb 1
\&  "update book set " . $dbi\->assign_clause({title => \*(Aqa\*(Aq, age => 2});
.Ve
.SS "column"
.IX Subsection "column"
.Vb 1
\&  my $column = $dbi\->column(book => [\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq]);
.Ve
.PP
Create column clause. The following column clause is created.
.PP
.Vb 2
\&  book.author as "book.author",
\&  book.title as "book.title"
.Ve
.PP
You can change separator by \f(CW\*(C`separator\*(C'\fR attribute.
.PP
.Vb 2
\&  # Separator is hyphen
\&  $dbi\->separator(\*(Aq\-\*(Aq);
\&  
\&  book.author as "book\-author",
\&  book.title as "book\-title"
.Ve
.SS "connect"
.IX Subsection "connect"
.Vb 7
\&  # DBI compatible arguments
\&  my $dbi = DBIx::Custom\->connect(
\&    "dbi:mysql:database=dbname",
\&    \*(Aqken\*(Aq,
\&    \*(Aq!LFKD%$&\*(Aq,
\&    {mysql_enable_utf8 => 1}
\&  );
\&  
\&  # pass DBIx::Custom attributes
\&  my $dbi = DBIx::Custom\->connect(
\&    dsn => "dbi:mysql:database=dbname",
\&    user => \*(Aqken\*(Aq,
\&    password => \*(Aq!LFKD%$&\*(Aq,
\&    option => {mysql_enable_utf8 => 1}
\&  );
.Ve
.PP
Connect to the database and create a new DBIx::Custom object.
.PP
DBIx::Custom is a wrapper of \s-1DBI\s0.
\&\f(CW\*(C`AutoCommit\*(C'\fR and \f(CW\*(C`RaiseError\*(C'\fR options are true, 
and \f(CW\*(C`PrintError\*(C'\fR option is false by default.
.SS "create_model"
.IX Subsection "create_model"
.Vb 10
\&  $dbi\->create_model(\*(Aqbook\*(Aq);
\&  $dbi\->create_model(
\&    \*(Aqbook\*(Aq,
\&    join => [
\&      \*(Aqinner join company on book.comparny_id = company.id\*(Aq
\&    ]
\&  );
\&  $dbi\->create_model(
\&    table => \*(Aqbook\*(Aq,
\&    join => [
\&      \*(Aqinner join company on book.comparny_id = company.id\*(Aq
\&    ],
\&  );
.Ve
.PP
Create DBIx::Custom::Model object and initialize model.
Model columns attribute is automatically set.
You can use this model by using \f(CW\*(C`model\*(C'\fR method.
.PP
.Vb 1
\&  $dbi\->model(\*(Aqbook\*(Aq)\->select(...);
.Ve
.PP
You can use model name which different from table name
.PP
.Vb 2
\&  $dbi\->create_model(name => \*(Aqbook1\*(Aq, table => \*(Aqbook\*(Aq);
\&  $dbi\->model(\*(Aqbook1\*(Aq)\->select(...);
\&
\&  $dbi\->create_model(
\&    table => \*(Aqbook\*(Aq,
\&    join => [
\&      \*(Aqinner join company on book.comparny_id = company.id\*(Aq
\&    ],
\&  );
.Ve
.PP
\&\f(CW\*(C`column_name_lc\*(C'\fR option change column names to lower case.
.PP
.Vb 7
\&  $dbi\->create_model(
\&    table => \*(Aqbook\*(Aq,
\&    join => [
\&      \*(Aqinner join company on book.comparny_id = company.id\*(Aq
\&    ],
\&    column_name_lc => 1,
\&  );
.Ve
.SS "dbh"
.IX Subsection "dbh"
.Vb 1
\&  my $dbh = $dbi\->dbh;
.Ve
.PP
Get \s-1DBI\s0 database handle. if \f(CW\*(C`connector\*(C'\fR is set, you can get
database handle through \f(CW\*(C`connector\*(C'\fR object.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $dbi\->delete(table => \*(Aqbook\*(Aq, where => {title => \*(AqPerl\*(Aq});
.Ve
.PP
Execute delete statement.
.PP
The following options are available.
.PP
\&\fB\s-1OPTIONS\s0\fR
.PP
\&\f(CW\*(C`delete\*(C'\fR method use all of \f(CW\*(C`execute\*(C'\fR method's options,
and use the following new ones.
.IP "prefix" 4
.IX Item "prefix"
.Vb 1
\&  prefix => \*(Aqsome\*(Aq
.Ve
.Sp
prefix before table name section.
.Sp
.Vb 1
\&  delete some from book
.Ve
.IP "table" 4
.IX Item "table"
.Vb 1
\&  table => \*(Aqbook\*(Aq
.Ve
.Sp
Table name.
.IP "where" 4
.IX Item "where"
Same as \f(CW\*(C`select\*(C'\fR method's \f(CW\*(C`where\*(C'\fR option.
.SS "delete_all"
.IX Subsection "delete_all"
.Vb 1
\&  $dbi\->delete_all(table => $table);
.Ve
.PP
Execute delete statement for all rows.
Options is same as \f(CW\*(C`delete\*(C'\fR.
.SS "each_column"
.IX Subsection "each_column"
.Vb 3
\&  $dbi\->each_column(
\&    sub {
\&      my ($dbi, $table, $column, $column_info) = @_;
\&      
\&      my $type = $column_info\->{TYPE_NAME};
\&      
\&      if ($type eq \*(AqDATE\*(Aq) {
\&          # ...
\&      }
\&    }
\&  );
.Ve
.PP
Iterate all column informations in database.
Argument is callback which is executed when one column is found.
Callback receive four arguments. \f(CW\*(C`DBIx::Custom object\*(C'\fR, \f(CW\*(C`table name\*(C'\fR,
\&\f(CW\*(C`column name\*(C'\fR, and \f(CW\*(C`column information\*(C'\fR.
.PP
If \f(CW\*(C`user_column_info\*(C'\fR is set, \f(CW\*(C`each_column\*(C'\fR method use \f(CW\*(C`user_column_info\*(C'\fR
information, you can improve the performance of \f(CW\*(C`each_column\*(C'\fR in
the following way.
.PP
.Vb 3
\&  my $column_infos = $dbi\->get_column_info(exclude_table => qr/^system_/);
\&  $dbi\->user_column_info($column_info);
\&  $dbi\->each_column(sub { ... });
.Ve
.SS "each_table"
.IX Subsection "each_table"
.Vb 3
\&  $dbi\->each_table(
\&    sub {
\&      my ($dbi, $table, $table_info) = @_;
\&      
\&      my $table_name = $table_info\->{TABLE_NAME};
\&    }
\&  );
.Ve
.PP
Iterate all table information from in database.
Argument is callback which is executed when one table is found.
Callback receive three arguments, \f(CW\*(C`DBIx::Custom object\*(C'\fR, \f(CW\*(C`table name\*(C'\fR,
\&\f(CW\*(C`table information\*(C'\fR.
.PP
If \f(CW\*(C`user_table_info\*(C'\fR is set, \f(CW\*(C`each_table\*(C'\fR method use \f(CW\*(C`user_table_info\*(C'\fR
information, you can improve the performance of \f(CW\*(C`each_table\*(C'\fR in
the following way.
.PP
.Vb 3
\&  my $table_infos = $dbi\->get_table_info(exclude => qr/^system_/);
\&  $dbi\->user_table_info($table_info);
\&  $dbi\->each_table(sub { ... });
.Ve
.SS "execute"
.IX Subsection "execute"
.Vb 4
\&  my $result = $dbi\->execute(
\&    "select * from book where title = :title and author like :author",
\&    {title => \*(AqPerl\*(Aq, author => \*(Aq%Ken%\*(Aq}
\&  );
\&
\&  my $result = $dbi\->execute(
\&    "select * from book where title = :book.title and author like :book.author",
\&    {\*(Aqbook.title\*(Aq => \*(AqPerl\*(Aq, \*(Aqbook.author\*(Aq => \*(Aq%Ken%\*(Aq}
\&  );
.Ve
.PP
Execute \s-1SQL. SQL\s0 can contain column parameter such as :author and :title.
You can append table name to column name such as :book.title and :book.author.
Second argument is data, embedded into column parameter.
Return value is DBIx::Custom::Result object when select statement is executed,
or the count of affected rows when insert, update, delete statement is executed.
.PP
Named placeholder such as \f(CW\*(C`:title\*(C'\fR is replaced by placeholder \f(CW\*(C`?\*(C'\fR.
.PP
.Vb 2
\&  # Original
\&  select * from book where title = :title and author like :author
\&  
\&  # Replaced
\&  select * from where title = ? and author like ?;
.Ve
.PP
You can specify operator with named placeholder
by \f(CW\*(C`name{operator}\*(C'\fR syntax.
.PP
.Vb 2
\&  # Original
\&  select * from book where :title{=} and :author{like}
\&  
\&  # Replaced
\&  select * from where title = ? and author like ?;
.Ve
.PP
Note that colons in time format such as 12:13:15 is an exception,
it is not parsed as named placeholder.
If you want to use colon generally, you must escape it by \f(CW\*(C`\e\e\*(C'\fR
.PP
.Vb 1
\&  select * from where title = "aa\e\e:bb";
.Ve
.PP
\&\fB\s-1OPTIONS\s0\fR
.PP
The following options are available.
.IP "after_build_sql" 4
.IX Item "after_build_sql"
You can filter sql after the sql is build.
.Sp
.Vb 1
\&  after_build_sql => $code_ref
.Ve
.Sp
The following one is one example.
.Sp
.Vb 7
\&  $dbi\->select(
\&    table => \*(Aqbook\*(Aq,
\&    column => \*(Aqdistinct(name)\*(Aq,
\&    after_build_sql => sub {
\&      "select count(*) from ($_[0]) as t1"
\&    }
\&  );
.Ve
.Sp
The following \s-1SQL\s0 is executed.
.Sp
.Vb 1
\&  select count(*) from (select distinct(name) from book) as t1;
.Ve
.IP "append" 4
.IX Item "append"
.Vb 1
\&  append => \*(Aqorder by name\*(Aq
.Ve
.Sp
Append some statement after \s-1SQL.\s0
.IP "bind_type" 4
.IX Item "bind_type"
Specify database bind data type.
.Sp
.Vb 3
\&  bind_type => {image => DBI::SQL_BLOB}
\&  bind_type => [image => DBI::SQL_BLOB]
\&  bind_type => [[qw/image audio/] => DBI::SQL_BLOB]
.Ve
.Sp
This is used to bind parameter by \f(CW\*(C`bind_param\*(C'\fR of statement handle.
.Sp
.Vb 1
\&  $sth\->bind_param($pos, $value, DBI::SQL_BLOB);
.Ve
.IP "filter" 4
.IX Item "filter"
.Vb 4
\&  filter => {
\&    title  => sub { uc $_[0] }
\&    author => sub { uc $_[0] }
\&  }
\&
\&  # Filter name
\&  filter => {
\&    title  => \*(Aqupper_case\*(Aq,
\&    author => \*(Aqupper_case\*(Aq
\&  }
\&      
\&  # At once
\&  filter => [
\&    [qw/title author/]  => sub { uc $_[0] }
\&  ]
.Ve
.Sp
Filter. You can set subroutine or filter name
registered by \f(CW\*(C`register_filter\*(C'\fR.
This filter is executed before data is saved into database.
and before type rule filter is executed.
.IP "reuse" 4
.IX Item "reuse"
.Vb 1
\&  reuse => $hash_ref
.Ve
.Sp
Reuse statement handle in same \s-1SQL.\s0
.Sp
.Vb 2
\&  my $reuse = {};
\&  $dbi\->execute($sql, $param, reuse => $reuse);
.Ve
.Sp
This will improved performance when you want to execute same sql repeatedly.
.IP "table" 4
.IX Item "table"
.Vb 1
\&  table => \*(Aqauthor\*(Aq
.Ve
.Sp
If you want to omit table name in column name
and enable \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR type filter,
You must set \f(CW\*(C`table\*(C'\fR option.
.Sp
.Vb 2
\&  $dbi\->execute("select * from book where title = :title and author = :author",
\&    {title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq, table => \*(Aqbook\*(Aq);
\&
\&  # Same
\&  $dbi\->execute(
\&    "select * from book where title = :book.title and author = :book.author",
\&    {title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq);
.Ve
.IP "table_alias" 4
.IX Item "table_alias"
.Vb 1
\&  table_alias => {worker => \*(Aquser\*(Aq} # {ALIAS => TABLE}
.Ve
.Sp
Table alias. Key is alias table name, value is real table name, .
If you set \f(CW\*(C`table_alias\*(C'\fR, you can enable \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR type rule
on alias table name.
.IP "type_rule_off" 4
.IX Item "type_rule_off"
.Vb 1
\&  type_rule_off => 1
.Ve
.Sp
Turn \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR type rule off.
.IP "type_rule1_off" 4
.IX Item "type_rule1_off"
.Vb 1
\&  type_rule1_off => 1
.Ve
.Sp
Turn \f(CW\*(C`into1\*(C'\fR type rule off.
.IP "type_rule2_off" 4
.IX Item "type_rule2_off"
.Vb 1
\&  type_rule2_off => 1
.Ve
.Sp
Turn \f(CW\*(C`into2\*(C'\fR type rule off.
.IP "prepare_attr" 4
.IX Item "prepare_attr"
.Vb 1
\&  prepare_attr => {mysql_use_result => 1}
.Ve
.Sp
Statemend handle attributes,
this is \s-1DBI\s0's \f(CW\*(C`prepare\*(C'\fR method second argument.
.SS "get_column_info"
.IX Subsection "get_column_info"
.Vb 1
\&  my $column_infos = $dbi\->get_column_info(exclude_table => qr/^system_/);
.Ve
.PP
get column information except for one which match \f(CW\*(C`exclude_table\*(C'\fR pattern.
.PP
.Vb 4
\&  [
\&    {table => \*(Aqbook\*(Aq, column => \*(Aqtitle\*(Aq, info => {...}},
\&    {table => \*(Aqauthor\*(Aq, column => \*(Aqname\*(Aq info => {...}}
\&  ]
.Ve
.SS "get_table_info"
.IX Subsection "get_table_info"
.Vb 1
\&  my $table_infos = $dbi\->get_table_info(exclude => qr/^system_/);
.Ve
.PP
get table information except for one which match \f(CW\*(C`exclude\*(C'\fR pattern.
.PP
.Vb 4
\&  [
\&    {table => \*(Aqbook\*(Aq, info => {...}},
\&    {table => \*(Aqauthor\*(Aq, info => {...}}
\&  ]
.Ve
.PP
You can set this value to \f(CW\*(C`user_table_info\*(C'\fR.
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  $dbi\->insert({title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq}, table  => \*(Aqbook\*(Aq);
.Ve
.PP
Execute insert statement. First argument is row data. Return value is
affected row count.
.PP
If you want to set constant value to row data, use scalar reference
as parameter value.
.PP
.Vb 1
\&  {date => \e"NOW()"}
.Ve
.PP
You can pass multiple parameters, this is very fast.
.PP
.Vb 7
\&  $dbi\->insert(
\&    [
\&      {title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq},
\&      {title => \*(AqRuby\*(Aq, author => \*(AqTom\*(Aq}
\&    ],
\&    table  => \*(Aqbook\*(Aq
\&  );
.Ve
.PP
In multiple insert, you can't use \f(CW\*(C`id\*(C'\fR option.
and only first parameter is used to create sql.
.PP
\&\fBoptions\fR
.PP
\&\f(CW\*(C`insert\*(C'\fR method use all of \f(CW\*(C`execute\*(C'\fR method's options,
and use the following new ones.
.IP "bulk_insert" 4
.IX Item "bulk_insert"
.Vb 1
\&  bulk_insert => 1
.Ve
.Sp
bulk insert is executed if database support bulk insert and 
multiple parameters is passed to \f(CW\*(C`insert\*(C'\fR.
The \s-1SQL\s0 like the following one is executed.
.Sp
.Vb 1
\&  insert into book (id, title) values (?, ?), (?, ?);
.Ve
.IP "ctime" 4
.IX Item "ctime"
.Vb 1
\&  ctime => \*(Aqcreated_time\*(Aq
.Ve
.Sp
Created time column name. time when row is created is set to the column.
default time format is \*(L"YYYY-mm-dd \s-1HH:MM:SS\*(R",\s0 which can be changed by
\&\f(CW\*(C`now\*(C'\fR attribute.
.IP "prefix" 4
.IX Item "prefix"
.Vb 1
\&  prefix => \*(Aqor replace\*(Aq
.Ve
.Sp
prefix before table name section
.Sp
.Vb 1
\&  insert or replace into book
.Ve
.IP "table" 4
.IX Item "table"
.Vb 1
\&  table => \*(Aqbook\*(Aq
.Ve
.Sp
Table name.
.IP "mtime" 4
.IX Item "mtime"
This option is same as \f(CW\*(C`update\*(C'\fR method \f(CW\*(C`mtime\*(C'\fR option.
.IP "wrap" 4
.IX Item "wrap"
.Vb 1
\&  wrap => {price => sub { "max($_[0])" }}
.Ve
.Sp
placeholder wrapped string.
.Sp
If the following statement
.Sp
.Vb 2
\&  $dbi\->insert({price => 100}, table => \*(Aqbook\*(Aq,
\&    {price => sub { "$_[0] + 5" }});
.Ve
.Sp
is executed, the following \s-1SQL\s0 is executed.
.Sp
.Vb 1
\&  insert into book price values ( ? + 5 );
.Ve
.SS "include_model"
.IX Subsection "include_model"
.Vb 1
\&  $dbi\->include_model(\*(AqMyModel\*(Aq);
.Ve
.PP
Include models from specified namespace,
the following layout is needed to include models.
.PP
.Vb 3
\&  lib / MyModel.pm
\&      / MyModel / book.pm
\&                / company.pm
.Ve
.PP
Name space module, extending DBIx::Custom::Model.
.PP
\&\fBMyModel.pm\fR
.PP
.Vb 2
\&  package MyModel;
\&  use DBIx::Custom::Model \-base;
\&  
\&  1;
.Ve
.PP
Model modules, extending name space module.
.PP
\&\fBMyModel/book.pm\fR
.PP
.Vb 2
\&  package MyModel::book;
\&  use MyModel \-base;
\&  
\&  1;
.Ve
.PP
\&\fBMyModel/company.pm\fR
.PP
.Vb 2
\&  package MyModel::company;
\&  use MyModel \-base;
\&  
\&  1;
.Ve
.PP
MyModel::book and MyModel::company is included by \f(CW\*(C`include_model\*(C'\fR.
.PP
You can get model object by \f(CW\*(C`model\*(C'\fR.
.PP
.Vb 2
\&  my $book_model = $dbi\->model(\*(Aqbook\*(Aq);
\&  my $company_model = $dbi\->model(\*(Aqcompany\*(Aq);
.Ve
.PP
You can include full-qualified table name like \f(CW\*(C`main.book\*(C'\fR
.PP
.Vb 3
\&  lib / MyModel.pm
\&      / MyModel / main / book.pm
\&                       / company.pm
\&
\&  my $main_book = $self\->model(\*(Aqmain.book\*(Aq);
.Ve
.PP
See DBIx::Custom::Model to know model features.
.SS "like_value"
.IX Subsection "like_value"
.Vb 1
\&  my $like_value = $dbi\->like_value
.Ve
.PP
Code reference which return a value for the like value.
.PP
.Vb 1
\&  sub { "%$_[0]%" }
.Ve
.SS "mapper"
.IX Subsection "mapper"
.Vb 1
\&  my $mapper = $dbi\->mapper(param => $param);
.Ve
.PP
Create a new DBIx::Custom::Mapper object.
.SS "merge_param"
.IX Subsection "merge_param"
.Vb 1
\&  my $param = $dbi\->merge_param({key1 => 1}, {key1 => 1, key2 => 2});
.Ve
.PP
Merge parameters. The following new parameter is created.
.PP
.Vb 1
\&  {key1 => [1, 1], key2 => 2}
.Ve
.PP
If same keys contains, the value is converted to array reference.
.SS "model"
.IX Subsection "model"
.Vb 1
\&  my $model = $dbi\->model(\*(Aqbook\*(Aq);
.Ve
.PP
Get a DBIx::Custom::Model object
create by \f(CW\*(C`create_model\*(C'\fR or \f(CW\*(C`include_model\*(C'\fR
.SS "mycolumn"
.IX Subsection "mycolumn"
.Vb 1
\&  my $column = $dbi\->mycolumn(book => [\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq]);
.Ve
.PP
Create column clause for myself. The following column clause is created.
.PP
.Vb 2
\&  book.author as author,
\&  book.title as title
.Ve
.SS "new"
.IX Subsection "new"
.Vb 6
\&  my $dbi = DBIx::Custom\->new(
\&    dsn => "dbi:mysql:database=dbname",
\&    user => \*(Aqken\*(Aq,
\&    password => \*(Aq!LFKD%$&\*(Aq,
\&    option => {mysql_enable_utf8 => 1}
\&  );
.Ve
.PP
Create a new DBIx::Custom object.
.SS "not_exists"
.IX Subsection "not_exists"
.Vb 1
\&  my $not_exists = $dbi\->not_exists;
.Ve
.PP
DBIx::Custom::NotExists object, indicating the column is not exists.
This is used in \f(CW\*(C`param\*(C'\fR of DBIx::Custom::Where .
.SS "order"
.IX Subsection "order"
.Vb 1
\&  my $order = $dbi\->order;
.Ve
.PP
Create a new DBIx::Custom::Order object.
.SS "q"
.IX Subsection "q"
.Vb 1
\&  my $quooted = $dbi\->q("title");
.Ve
.PP
Quote string by value of \f(CW\*(C`quote\*(C'\fR.
.SS "register_filter"
.IX Subsection "register_filter"
.Vb 12
\&  $dbi\->register_filter(
\&    # Time::Piece object to database DATE format
\&    tp_to_date => sub {
\&      my $tp = shift;
\&      return $tp\->strftime(\*(Aq%Y\-%m\-%d\*(Aq);
\&    },
\&    # database DATE format to Time::Piece object
\&    date_to_tp => sub {
\&      my $date = shift;
\&      return Time::Piece\->strptime($date, \*(Aq%Y\-%m\-%d\*(Aq);
\&    }
\&  );
.Ve
.PP
Register filters, used by \f(CW\*(C`filter\*(C'\fR option of many methods.
.SS "select"
.IX Subsection "select"
.Vb 5
\&  my $result = $dbi\->select(
\&    column => [\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq],
\&    table  => \*(Aqbook\*(Aq,
\&    where  => {author => \*(AqKen\*(Aq},
\&  );
.Ve
.PP
Execute select statement.
.PP
You can pass odd number arguments. first argument is \f(CW\*(C`column\*(C'\fR.
.PP
.Vb 1
\&  my $result = $dbi\->select([\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq], table => \*(Aqbook\*(Aq);
.Ve
.PP
\&\fB\s-1OPTIONS\s0\fR
.PP
\&\f(CW\*(C`select\*(C'\fR method use all of \f(CW\*(C`execute\*(C'\fR method's options,
and use the following new ones.
.IP "column" 4
.IX Item "column"
.Vb 2
\&  column => \*(Aqauthor\*(Aq
\&  column => [\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq]
.Ve
.Sp
Column clause.
.Sp
if \f(CW\*(C`column\*(C'\fR is not specified, '*' is set.
.Sp
.Vb 1
\&  column => \*(Aq*\*(Aq
.Ve
.Sp
You can specify hash of array reference.
.Sp
.Vb 4
\&  column => [
\&    {book => [qw/author title/]},
\&    {person => [qw/name age/]}
\&  ]
.Ve
.Sp
This is expanded to the following one by using \f(CW\*(C`colomn\*(C'\fR method.
.Sp
.Vb 4
\&  book.author as "book.author",
\&  book.title as "book.title",
\&  person.name as "person.name",
\&  person.age as "person.age"
.Ve
.Sp
You can specify own column by \f(CW\*(C`_\|_MY_\|_\*(C'\fR.
.Sp
.Vb 3
\&  column => [
\&    {_\|_MY_\|_ => [qw/author title/]},
\&  ]
.Ve
.Sp
This is expanded to the following one by using \f(CW\*(C`mycolomn\*(C'\fR method.
.Sp
.Vb 2
\&  book.author as "author",
\&  book.title as "title",
.Ve
.Sp
\&\f(CW\*(C`_\|_MY_\|_\*(C'\fR can be changed by \f(CW\*(C`mytable_symbol\*(C'\fR attribute.
.IP "param" 4
.IX Item "param"
.Vb 1
\&  param => {\*(Aqtable2.key3\*(Aq => 5}
.Ve
.Sp
Parameter shown before where clause.
.Sp
For example, if you want to contain named placeholder in join clause, 
you can pass parameter by \f(CW\*(C`param\*(C'\fR option.
.Sp
.Vb 2
\&  join  => [\*(Aqinner join (select * from table2 where table2.key3 = :table2.key3)\*(Aq . 
\&            \*(Aq as table2 on table1.key1 = table2.key1\*(Aq]
.Ve
.IP "prefix" 4
.IX Item "prefix"
.Vb 1
\&  prefix => \*(AqSQL_CALC_FOUND_ROWS\*(Aq
.Ve
.Sp
Prefix of column clause
.Sp
.Vb 1
\&  select SQL_CALC_FOUND_ROWS title, author from book;
.Ve
.IP "join" 4
.IX Item "join"
.Vb 4
\&  join => [
\&    \*(Aqleft outer join company on book.company_id = company_id\*(Aq,
\&    \*(Aqleft outer join location on company.location_id = location.id\*(Aq
\&  ]
.Ve
.Sp
Join clause. If column clause or where clause contain table name like \*(L"company.name\*(R",
join clauses needed when \s-1SQL\s0 is created is used automatically.
.Sp
.Vb 9
\&  $dbi\->select(
\&    table => \*(Aqbook\*(Aq,
\&    column => [\*(Aqcompany.location_id as location_id\*(Aq],
\&    where => {\*(Aqcompany.name\*(Aq => \*(AqOrange\*(Aq},
\&    join => [
\&      \*(Aqleft outer join company on book.company_id = company.id\*(Aq,
\&      \*(Aqleft outer join location on company.location_id = location.id\*(Aq
\&    ]
\&  );
.Ve
.Sp
In above select, column and where clause contain \*(L"company\*(R" table,
the following \s-1SQL\s0 is created
.Sp
.Vb 4
\&  select company.location_id as location_id
\&  from book
\&    left outer join company on book.company_id = company.id
\&  where company.name = ?;
.Ve
.Sp
You can specify two table by yourself. This is useful when join parser can't parse
the join clause correctly.
.Sp
.Vb 11
\&  $dbi\->select(
\&    table => \*(Aqbook\*(Aq,
\&    column => [\*(Aqcompany.location_id as location_id\*(Aq],
\&    where => {\*(Aqcompany.name\*(Aq => \*(AqOrange\*(Aq},
\&    join => [
\&      {
\&        clause => \*(Aqleft outer join location on company.location_id = location.id\*(Aq,
\&        table => [\*(Aqcompany\*(Aq, \*(Aqlocation\*(Aq]
\&      }
\&    ]
\&  );
.Ve
.IP "table" 4
.IX Item "table"
.Vb 1
\&  table => \*(Aqbook\*(Aq
.Ve
.Sp
Table name.
.IP "where" 4
.IX Item "where"
.Vb 3
\&  # (1) Hash reference
\&  where => {author => \*(AqKen\*(Aq, \*(Aqtitle\*(Aq => [\*(AqPerl\*(Aq, \*(AqRuby\*(Aq]}
\&  # \-> where author = \*(AqKen\*(Aq and title in (\*(AqPerl\*(Aq, \*(AqRuby\*(Aq)
\&  
\&  # (2) DBIx::Custom::Where object
\&  where => $dbi\->where(
\&    clause => [\*(Aqand\*(Aq, \*(Aq:author{=}\*(Aq, \*(Aq:title{like}\*(Aq],
\&    param  => {author => \*(AqKen\*(Aq, title => \*(Aq%Perl%\*(Aq}
\&  )
\&  # \-> where author = \*(AqKen\*(Aq and title like \*(Aq%Perl%\*(Aq
\&  
\&  # (3) Array reference[where clause, parameters, join(optional)]
\&  where => [
\&    [\*(Aqand\*(Aq, \*(Aq:author{=}\*(Aq, \*(Aq:title{like}\*(Aq],
\&    {author => \*(AqKen\*(Aq, title => \*(Aq%Perl%\*(Aq},
\&    ["left outer join table2 on table1.key1 = table2.key1"]
\&  ]
\&  # \-> where author = \*(AqKen\*(Aq and title like \*(Aq%Perl%\*(Aq
\&  
\&  # (4) Array reference[String, Hash reference]
\&  where => [
\&    \*(Aq:author{=} and :title{like}\*(Aq,
\&    {author => \*(AqKen\*(Aq, title => \*(Aq%Perl%\*(Aq}
\&  ]
\&  #  \-> where author = \*(AqKen\*(Aq and title like \*(Aq%Perl%\*(Aq
\&  
\&  # (5) String
\&  where => \*(Aqtitle is null\*(Aq
\&  #  \-> where title is null
.Ve
.Sp
Where clause.
See also DBIx::Custom::Where to know how to create where clause.
.SS "type_rule"
.IX Subsection "type_rule"
.Vb 10
\&  $dbi\->type_rule(
\&    into1 => {
\&      date => sub { ... },
\&      datetime => sub { ... }
\&    },
\&    into2 => {
\&      date => sub { ... },
\&      datetime => sub { ... }
\&    },
\&    from1 => {
\&      # DATE
\&      9 => sub { ... },
\&      # DATETIME or TIMESTAMP
\&      11 => sub { ... },
\&    }
\&    from2 => {
\&      # DATE
\&      9 => sub { ... },
\&      # DATETIME or TIMESTAMP
\&      11 => sub { ... },
\&    }
\&  );
.Ve
.PP
Filtering rule when data is send into and get from database.
This has a little complex problem.
.PP
In \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR you can specify
type name as same as type name defined
by create table, such as \f(CW\*(C`DATETIME\*(C'\fR or \f(CW\*(C`DATE\*(C'\fR.
.PP
Note that type name and data type don't contain upper case.
If these contain upper case character, you convert it to lower case.
.PP
\&\f(CW\*(C`into2\*(C'\fR is executed after \f(CW\*(C`into1\*(C'\fR.
.PP
Type rule of \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR is enabled on the following
column name.
.IP "1. column name" 4
.IX Item "1. column name"
.Vb 2
\&  issue_date
\&  issue_datetime
.Ve
.Sp
This need \f(CW\*(C`table\*(C'\fR option in each method.
.IP "2. table name and column name, separator is dot" 4
.IX Item "2. table name and column name, separator is dot"
.Vb 2
\&  book.issue_date
\&  book.issue_datetime
.Ve
.PP
You get all type name used in database by \f(CW\*(C`available_typename\*(C'\fR.
.PP
.Vb 1
\&  print $dbi\->available_typename;
.Ve
.PP
In \f(CW\*(C`from1\*(C'\fR and \f(CW\*(C`from2\*(C'\fR you specify data type, not type name.
\&\f(CW\*(C`from2\*(C'\fR is executed after \f(CW\*(C`from1\*(C'\fR.
You get all data type by \f(CW\*(C`available_datatype\*(C'\fR.
.PP
.Vb 1
\&  print $dbi\->available_datatype;
.Ve
.PP
You can also specify multiple types at once.
.PP
.Vb 5
\&  $dbi\->type_rule(
\&    into1 => [
\&      [qw/DATE DATETIME/] => sub { ... },
\&    ],
\&  );
.Ve
.SS "update"
.IX Subsection "update"
.Vb 1
\&  $dbi\->update({title => \*(AqPerl\*(Aq}, table  => \*(Aqbook\*(Aq, where  => {id => 4});
.Ve
.PP
Execute update statement. First argument is update row data.
.PP
If you want to set constant value to row data, use scalar reference
as parameter value.
.PP
.Vb 1
\&  {date => \e"NOW()"}
.Ve
.PP
\&\fB\s-1OPTIONS\s0\fR
.PP
\&\f(CW\*(C`update\*(C'\fR method use all of \f(CW\*(C`execute\*(C'\fR method's options,
and use the following new ones.
.IP "prefix" 4
.IX Item "prefix"
.Vb 1
\&  prefix => \*(Aqor replace\*(Aq
.Ve
.Sp
prefix before table name section
.Sp
.Vb 1
\&  update or replace book
.Ve
.IP "table" 4
.IX Item "table"
.Vb 1
\&  table => \*(Aqbook\*(Aq
.Ve
.Sp
Table name.
.IP "where" 4
.IX Item "where"
Same as \f(CW\*(C`select\*(C'\fR method's \f(CW\*(C`where\*(C'\fR option.
.IP "wrap" 4
.IX Item "wrap"
.Vb 1
\&  wrap => {price => sub { "max($_[0])" }}
.Ve
.Sp
placeholder wrapped string.
.Sp
If the following statement
.Sp
.Vb 2
\&  $dbi\->update({price => 100}, table => \*(Aqbook\*(Aq,
\&    {price => sub { "$_[0] + 5" }});
.Ve
.Sp
is executed, the following \s-1SQL\s0 is executed.
.Sp
.Vb 1
\&  update book set price =  ? + 5;
.Ve
.IP "mtime" 4
.IX Item "mtime"
.Vb 1
\&  mtime => \*(Aqmodified_time\*(Aq
.Ve
.Sp
Modified time column name. time row is updated is set to the column.
default time format is \f(CW\*(C`YYYY\-mm\-dd HH:MM:SS\*(C'\fR, which can be changed by
\&\f(CW\*(C`now\*(C'\fR attribute.
.SS "update_all"
.IX Subsection "update_all"
.Vb 1
\&  $dbi\->update_all({title => \*(AqPerl\*(Aq}, table => \*(Aqbook\*(Aq, );
.Ve
.PP
Execute update statement for all rows.
Options is same as \f(CW\*(C`update\*(C'\fR method.
.IP "option" 4
.IX Item "option"
.Vb 11
\&  option => {
\&    select => {
\&      append => \*(Aq...\*(Aq
\&    },
\&    insert => {
\&      prefix => \*(Aq...\*(Aq
\&    },
\&    update => {
\&      filter => {}
\&    }
\&  }
.Ve
.Sp
If you want to pass option to each method,
you can use \f(CW\*(C`option\*(C'\fR option.
.RS 4
.IP "select_option" 4
.IX Item "select_option"
.Vb 1
\&  select_option => {append => \*(Aqfor update\*(Aq}
.Ve
.Sp
select method option,
select method is used to check the row is already exists.
.RE
.RS 4
.RE
.SS "show_datatype"
.IX Subsection "show_datatype"
.Vb 1
\&  $dbi\->show_datatype($table);
.Ve
.PP
Show data type of the columns of specified table.
.PP
.Vb 3
\&  book
\&  title: 5
\&  issue_date: 91
.Ve
.PP
This data type is used in \f(CW\*(C`type_rule\*(C'\fR's \f(CW\*(C`from1\*(C'\fR and \f(CW\*(C`from2\*(C'\fR.
.SS "show_tables"
.IX Subsection "show_tables"
.Vb 1
\&  $dbi\->show_tables;
.Ve
.PP
Show tables.
.SS "show_typename"
.IX Subsection "show_typename"
.Vb 1
\&  $dbi\->show_typename($table);
.Ve
.PP
Show type name of the columns of specified table.
.PP
.Vb 3
\&  book
\&  title: varchar
\&  issue_date: date
.Ve
.PP
This type name is used in \f(CW\*(C`type_rule\*(C'\fR's \f(CW\*(C`into1\*(C'\fR and \f(CW\*(C`into2\*(C'\fR.
.SS "values_clause"
.IX Subsection "values_clause"
.Vb 1
\&  my $values_clause = $dbi\->values_clause({title => \*(Aqa\*(Aq, age => 2});
.Ve
.PP
Create values clause.
.PP
.Vb 1
\&  (title, author) values (title = :title, age = :age);
.Ve
.PP
You can use this in insert statement.
.PP
.Vb 1
\&  my $insert_sql = "insert into book $values_clause";
.Ve
.SS "where"
.IX Subsection "where"
.Vb 4
\&  my $where = $dbi\->where;
\&  $where\->clause([\*(Aqand\*(Aq, \*(Aqtitle = :title\*(Aq, \*(Aqauthor = :author\*(Aq]);
\&  $where\->param({title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq});
\&  $where\->join([\*(Aqleft join author on book.author = author.id]);
.Ve
.PP
Create a new DBIx::Custom::Where object.
See DBIx::Custom::Where to know how to create where clause.
.SH "ENVIRONMENTAL VARIABLES"
.IX Header "ENVIRONMENTAL VARIABLES"
.SS "\s-1DBIX_CUSTOM_DEBUG\s0"
.IX Subsection "DBIX_CUSTOM_DEBUG"
If environment variable \f(CW\*(C`DBIX_CUSTOM_DEBUG\*(C'\fR is set to true,
executed \s-1SQL\s0 and bind values are printed to \s-1STDERR.\s0
.SS "\s-1DBIX_CUSTOM_DEBUG_ENCODING\s0"
.IX Subsection "DBIX_CUSTOM_DEBUG_ENCODING"
\&\s-1DEBUG\s0 output encoding. Default to \s-1UTF\-8.\s0
.SS "\s-1DBIX_CUSTOM_SUPPRESS_DEPRECATION\s0"
.IX Subsection "DBIX_CUSTOM_SUPPRESS_DEPRECATION"
.Vb 1
\&  $ENV{DBIX_CUSTOM_SUPPRESS_DEPRECATION} = \*(Aq0.25\*(Aq;
.Ve
.PP
Suppress deprecation warnings before specified version.
.SH "DEPRECATED FUNCTIONALITY"
.IX Header "DEPRECATED FUNCTIONALITY"
DBIx::Custom
.PP
.Vb 8
\&  # Methods
\&  DBIx::Custom AUTOLOAD feature # will be removed at 2022/5/1
\&  DBIx::Custom::helper method # will be removed at 2022/5/1
\&  DBIx::Custom::update_or_insert method is DEPRECATED! # will be removed at 2022/5/1
\&  DBIx::Custom::count method # will be removed at 2022/5/1
\&  DBIx::Custom::select,update,delete method\*(Aqs primary_key option is DEPRECATED! # will be removed at 2022/5/1
\&  DBIx::Custom::select,update,delete method\*(Aqs id option is DEPRECATED! # will be removed at 2022/5/1
\&  DBIx::Custom::setup method is DEPRECATED! # will be removed at 2022/5/1
.Ve
.PP
DBIx::Custom::Result
.PP
.Vb 2
\&  # Options
\&  kv method\*(Aqs multi option (from 0.28) # will be removed at 2018/3/1
.Ve
.PP
DBIx::Custom::Model
.PP
.Vb 5
\&  DBIx::Custom::Model AUTOLOAD feature # will be removed at 2022/5/1
\&  DBIx::Custom::Model::helper method is DEPRECATED! # will be removed at 2022/5/1
\&  DBIx::Custom::Model::update_or_insert method is DEPRECATED! # will be removed at 2022/5/1
\&  DBIx::Custom::Model::count method # will be removed at 2022/5/1
\&  DBIx::Custom::Model::primary_key attribute is DEPRECATED! # will be removed at 2022/5/1
.Ve
.SH "BACKWARDS COMPATIBILITY POLICY"
.IX Header "BACKWARDS COMPATIBILITY POLICY"
If a feature is \s-1DEPRECATED,\s0 you can know it by \s-1DEPRECATED\s0 warnings.
\&\s-1DEPRECATED\s0 feature is removed after \f(CW\*(C`five years\*(C'\fR,
but if at least one person use the feature and tell me that thing
I extend one year each time he tell me it.
.PP
\&\s-1DEPRECATION\s0 warnings can be suppressed by \f(CW\*(C`DBIX_CUSTOM_SUPPRESS_DEPRECATION\*(C'\fR
environment variable.
.PP
\&\s-1EXPERIMENTAL\s0 features will be changed or deleted without warnings.
.SH "BUGS"
.IX Header "BUGS"
Please tell me bugs if you find bug.
.PP
\&\f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.PP
<http://github.com/yuki\-kimoto/DBIx\-Custom>
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009\-2019 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2259:" 4
.IX Item "Around line 2259:"
You forgot a '=back' before '=head2'
.IP "Around line 2370:" 4
.IX Item "Around line 2370:"
You forgot a '=back' before '=head2'
.IP "Around line 2845:" 4
.IX Item "Around line 2845:"
You forgot a '=back' before '=head2'
.Sp
You forgot a '=back' before '=head2'
