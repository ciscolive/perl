.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "File::Rsync::Mirror::Recentfile 3"
.TH File::Rsync::Mirror::Recentfile 3 "2020-04-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Rsync::Mirror::Recentfile \- mirroring via rsync made efficient
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Writer (of a single file):
.PP
.Vb 10
\&    use File::Rsync::Mirror::Recentfile;
\&    my $fr = File::Rsync::Mirror::Recentfile\->new
\&      (
\&       interval => q(6h),
\&       filenameroot => "RECENT",
\&       comment => "These \*(AqRECENT\*(Aq files are part of a test of a new CPAN mirroring concept. Please ignore them for now.",
\&       localroot => "/home/ftp/pub/PAUSE/authors/",
\&       aggregator => [qw(1d 1W 1M 1Q 1Y Z)],
\&      );
\&    $rf\->update("/home/ftp/pub/PAUSE/authors/id/A/AN/ANDK/CPAN\-1.92_63.tar.gz","new");
.Ve
.PP
Reader/mirrorer:
.PP
.Vb 10
\&    my $rf = File::Rsync::Mirror::Recentfile\->new
\&      (
\&       filenameroot => "RECENT",
\&       interval => q(6h),
\&       localroot => "/home/ftp/pub/PAUSE/authors",
\&       remote_dir => "",
\&       remote_host => "pause.perl.org",
\&       remote_module => "authors",
\&       rsync_options => {
\&                         compress => 1,
\&                         \*(Aqrsync\-path\*(Aq => \*(Aq/usr/bin/rsync\*(Aq,
\&                         links => 1,
\&                         times => 1,
\&                         \*(Aqomit\-dir\-times\*(Aq => 1,
\&                         checksum => 1,
\&                        },
\&       verbose => 1,
\&      );
\&    $rf\->mirror;
.Ve
.PP
Aggregator (usually the writer):
.PP
.Vb 2
\&    my $rf = File::Rsync::Mirror::Recentfile\->new_from_file ( $file );
\&    $rf\->aggregate;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Lower level than F:R:M:Recent, handles one recentfile. Whereas a tree
is always composed of several recentfiles, controlled by the
F:R:M:Recent object. The Recentfile object has to do the bookkeeping
for a single timeslice.
.SH "EXPORT"
.IX Header "EXPORT"
No exports.
.SH "CONSTRUCTORS / DESTRUCTOR"
.IX Header "CONSTRUCTORS / DESTRUCTOR"
.ie n .SS "my $obj = \s-1CLASS\-\s0>new(%hash)"
.el .SS "my \f(CW$obj\fP = \s-1CLASS\-\s0>new(%hash)"
.IX Subsection "my $obj = CLASS->new(%hash)"
Constructor. On every argument pair the key is a method name and the
value is an argument to that method name.
.PP
If a recentfile for this resource already exists, metadata that are
not defined by the constructor will be fetched from there as soon as
it is being read by \fBrecent_events()\fR.
.ie n .SS "my $obj = \s-1CLASS\-\s0>new_from_file($file)"
.el .SS "my \f(CW$obj\fP = \s-1CLASS\-\s0>new_from_file($file)"
.IX Subsection "my $obj = CLASS->new_from_file($file)"
Constructor. \f(CW$file\fR is a \fIrecentfile\fR.
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
A simple unlock.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.IP "aggregator" 4
.IX Item "aggregator"
A list of interval specs that tell the aggregator which \fIrecentfile\fRs
are to be produced.
.IP "canonize" 4
.IX Item "canonize"
The name of a method to canonize the path before rsyncing. Only
supported value is \f(CW\*(C`naive_path_normalize\*(C'\fR. Defaults to that.
.IP "comment" 4
.IX Item "comment"
A comment about this tree and setup.
.IP "dirtymark" 4
.IX Item "dirtymark"
A timestamp. The dirtymark is updated whenever an out of band change
on the origin server is performed that violates the protocol. Say,
they add or remove files in the middle somewhere. Slaves must react
with a devaluation of their \f(CW\*(C`done\*(C'\fR structure which then leads to a
full re-sync of all files. Implementation note: dirtymark may increase
or decrease.
.IP "filenameroot" 4
.IX Item "filenameroot"
The (prefix of the) filename we use for this \fIrecentfile\fR. Defaults to
\&\f(CW\*(C`RECENT\*(C'\fR. The string must not contain a directory separator.
.IP "have_mirrored" 4
.IX Item "have_mirrored"
Timestamp remembering when we mirrored this recentfile the last time.
Only relevant for slaves.
.IP "ignore_link_stat_errors" 4
.IX Item "ignore_link_stat_errors"
If set to true, rsync errors are ignored that complain about link stat
errors. These seem to happen only when there are files missing at the
origin. In race conditions this can always happen, so it defaults to
true.
.IP "is_slave" 4
.IX Item "is_slave"
If set to true, this object will fetch a new recentfile from remote
when the timespan between the last mirror (see have_mirrored) and now
is too large (see \f(CW\*(C`ttl\*(C'\fR).
.IP "keep_delete_objects_forever" 4
.IX Item "keep_delete_objects_forever"
The default for delete events is that they are passed through the
collection of recentfile objects until they reach the Z file. There
they get dropped so that the associated file object ceases to exist at
all. By setting \f(CW\*(C`keep_delete_objects_forever\*(C'\fR the delete objects are
kept forever. This makes the Z file larger but has the advantage that
slaves that have interrupted mirroring for a long time still can clean
up their copy.
.IP "locktimeout" 4
.IX Item "locktimeout"
After how many seconds shall we die if we cannot lock a \fIrecentfile\fR?
Defaults to 600 seconds.
.IP "loopinterval" 4
.IX Item "loopinterval"
When mirror_loop is called, this accessor can specify how much time
every loop shall at least take. If the work of a loop is done before
that time has gone, sleeps for the rest of the time. Defaults to
arbitrary 42 seconds.
.IP "max_files_per_connection" 4
.IX Item "max_files_per_connection"
Maximum number of files that are transferred on a single rsync call.
Setting it higher means higher performance at the price of holding
connections longer and potentially disturbing other users in the pool.
Defaults to the arbitrary value 42.
.IP "max_rsync_errors" 4
.IX Item "max_rsync_errors"
When rsync operations encounter that many errors without any resetting
success in between, then we die. Defaults to unlimited. A value of
\&\-1 means we run forever ignoring all rsync errors.
.IP "minmax" 4
.IX Item "minmax"
Hashref remembering when we read the recent_events from this file the
last time and what the timespan was.
.IP "protocol" 4
.IX Item "protocol"
When the \s-1RECENT\s0 file format changes, we increment the protocol. We try
to support older protocols in later releases.
.IP "remote_host" 4
.IX Item "remote_host"
The host we are mirroring from. Leave empty for the local filesystem.
.IP "remote_module" 4
.IX Item "remote_module"
Rsync servers have so called modules to separate directory trees from
each other. Put here the name of the module under which we are
mirroring. Leave empty for local filesystem.
.IP "rsync_options" 4
.IX Item "rsync_options"
Things like compress, links, times or checksums. Passed in to the
File::Rsync object used to run the mirror.
.IP "serializer_suffix" 4
.IX Item "serializer_suffix"
Mostly untested accessor. The only well tested format for
\&\fIrecentfile\fRs at the moment is \s-1YAML.\s0 It is used with YAML::Syck via
Data::Serializer. But in principle other formats are supported as
well. See section \s-1SERIALIZERS\s0 below.
.IP "sleep_per_connection" 4
.IX Item "sleep_per_connection"
Sleep that many seconds (floating point \s-1OK\s0) after every chunk of rsyncing
has finished. Defaults to arbitrary 0.42.
.IP "tempdir" 4
.IX Item "tempdir"
Directory to write temporary files to. Must allow rename operations
into the tree which usually means it must live on the same partition
as the target directory. Defaults to \f(CW\*(C`$self\->localroot\*(C'\fR.
.IP "ttl" 4
.IX Item "ttl"
Time to live. Number of seconds after which this recentfile must be
fetched again from the origin server. Only relevant for slaves.
Defaults to arbitrary 24.2 seconds.
.IP "verbose" 4
.IX Item "verbose"
Boolean to turn on a bit verbosity.
.IP "verboselog" 4
.IX Item "verboselog"
Path to the logfile to write verbose progress information to. This is
a primitive stop gap solution to get simple verbose logging working.
Switching to Log4perl or similar is probably the way to go.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "(void) $obj\->aggregate( %options )"
.el .SS "(void) \f(CW$obj\fP\->aggregate( \f(CW%options\fP )"
.IX Subsection "(void) $obj->aggregate( %options )"
Takes all intervals that are collected in the accessor called
aggregator. Sorts them by actual length of the interval.
Removes those that are shorter than our own interval. Then merges this
object into the next larger object. The merging continues upwards
as long as the next \fIrecentfile\fR is old enough to warrant a merge.
.PP
If a merge is warranted is decided according to the interval of the
previous interval so that larger files are not so often updated as
smaller ones. If \f(CW$options\fR{force} is true, all files get updated.
.PP
Here is an example to illustrate the behaviour. Given aggregators
.PP
.Vb 1
\&  1h 1d 1W 1M 1Q 1Y Z
.Ve
.PP
then
.PP
.Vb 6
\&  1h updates 1d on every call to aggregate()
\&  1d updates 1W earliest after 1h
\&  1W updates 1M earliest after 1d
\&  1M updates 1Q earliest after 1W
\&  1Q updates 1Y earliest after 1M
\&  1Y updates  Z earliest after 1Q
.Ve
.PP
Note that all but the smallest recentfile get updated at an arbitrary
rate and as such are quite useless on their own.
.ie n .SS "$hashref = $obj\->delayed_operations"
.el .SS "\f(CW$hashref\fP = \f(CW$obj\fP\->delayed_operations"
.IX Subsection "$hashref = $obj->delayed_operations"
A hash of hashes containing unlink and rmdir operations which had to
wait until the recentfile got unhidden in order to not confuse
downstream mirrors (in case we have some).
.ie n .SS "$done = $obj\->done"
.el .SS "\f(CW$done\fP = \f(CW$obj\fP\->done"
.IX Subsection "$done = $obj->done"
\&\f(CW$done\fR is a reference to a File::Rsync::Mirror::Recentfile::Done
object that keeps track of rsync activities. Only needed and used when
we are a mirroring slave.
.ie n .SS "$tempfilename = $obj\->get_remote_recentfile_as_tempfile ()"
.el .SS "\f(CW$tempfilename\fP = \f(CW$obj\fP\->get_remote_recentfile_as_tempfile ()"
.IX Subsection "$tempfilename = $obj->get_remote_recentfile_as_tempfile ()"
Stores the remote \fIrecentfile\fR locally as a tempfile. The caller is
responsible to remove the file after use.
.PP
Note: if you're intending to act as an rsync server for other slaves,
then you must prefer this method to fetch that file with
\&\fBget_remotefile()\fR. Otherwise downstream mirrors would expect you to
already have mirrored all the files that are in the \fIrecentfile\fR
before you have them mirrored.
.ie n .SS "$localpath = $obj\->get_remotefile ( $relative_path )"
.el .SS "\f(CW$localpath\fP = \f(CW$obj\fP\->get_remotefile ( \f(CW$relative_path\fP )"
.IX Subsection "$localpath = $obj->get_remotefile ( $relative_path )"
Rsyncs one single remote file to local filesystem.
.PP
Note: no locking is done on this file. Any number of processes may
mirror this object.
.PP
Note \s-1II:\s0 do not use for recentfiles. If you are a cascading
slave/server combination, it would confuse other slaves. They would
expect the contents of these recentfiles to be available. Use
\&\fBget_remote_recentfile_as_tempfile()\fR instead.
.ie n .SS "$obj\->interval ( $interval_spec )"
.el .SS "\f(CW$obj\fP\->interval ( \f(CW$interval_spec\fP )"
.IX Subsection "$obj->interval ( $interval_spec )"
Get/set accessor. \f(CW$interval_spec\fR is a string and described below in
the section \s-1INTERVAL SPEC.\s0
.ie n .SS "$secs = $obj\->interval_secs ( $interval_spec )"
.el .SS "\f(CW$secs\fP = \f(CW$obj\fP\->interval_secs ( \f(CW$interval_spec\fP )"
.IX Subsection "$secs = $obj->interval_secs ( $interval_spec )"
\&\f(CW$interval_spec\fR is described below in the section \s-1INTERVAL SPEC.\s0 If
empty defaults to the inherent interval for this object.
.ie n .SS "$obj\->localroot ( $localroot )"
.el .SS "\f(CW$obj\fP\->localroot ( \f(CW$localroot\fP )"
.IX Subsection "$obj->localroot ( $localroot )"
Get/set accessor. The local root of the tree. Guaranteed without
trailing slash.
.ie n .SS "$ret = $obj\->local_path($path_found_in_recentfile)"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->local_path($path_found_in_recentfile)"
.IX Subsection "$ret = $obj->local_path($path_found_in_recentfile)"
Combines the path to our local mirror and the path of an object found
in this \fIrecentfile\fR. In other words: the target of a mirror operation.
.PP
Implementation note: We split on slashes and then use
File::Spec::catfile to adjust to the local operating system.
.ie n .SS "(void) $obj\->lock"
.el .SS "(void) \f(CW$obj\fP\->lock"
.IX Subsection "(void) $obj->lock"
Locking is implemented with an \f(CW\*(C`mkdir\*(C'\fR on a locking directory
(\f(CW\*(C`.lock\*(C'\fR appended to \f(CW$rfile\fR).
.ie n .SS "(void) $obj\->merge ($other)"
.el .SS "(void) \f(CW$obj\fP\->merge ($other)"
.IX Subsection "(void) $obj->merge ($other)"
Bulk update of this object with another one. It's used to merge a
smaller and younger \f(CW$other\fR object into the current one. If this file
is a \f(CW\*(C`Z\*(C'\fR file, then we normally do not merge in objects of type
\&\f(CW\*(C`delete\*(C'\fR; this can be overridden by setting
keep_delete_objects_forever. But if we encounter an object of type
delete we delete the corresponding \f(CW\*(C`new\*(C'\fR object if we have it.
.PP
If there is nothing to be merged, nothing is done.
.SS "merged"
.IX Subsection "merged"
Hashref denoting when this recentfile has been merged into some other
at which epoch.
.ie n .SS "$hashref = $obj\->meta_data"
.el .SS "\f(CW$hashref\fP = \f(CW$obj\fP\->meta_data"
.IX Subsection "$hashref = $obj->meta_data"
Returns the hashref of metadata that the server has to add to the
\&\fIrecentfile\fR.
.ie n .SS "$success = $obj\->mirror ( %options )"
.el .SS "\f(CW$success\fP = \f(CW$obj\fP\->mirror ( \f(CW%options\fP )"
.IX Subsection "$success = $obj->mirror ( %options )"
Mirrors the files in this \fIrecentfile\fR as reported by
\&\f(CW\*(C`recent_events\*(C'\fR. Options named \f(CW\*(C`after\*(C'\fR, \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`max\*(C'\fR are passed
through to the \f(CW\*(C`recent_events\*(C'\fR call. The boolean option \f(CW\*(C`piecemeal\*(C'\fR,
if true, causes \f(CW\*(C`mirror\*(C'\fR to only rsync \f(CW\*(C`max_files_per_connection\*(C'\fR
and keep track of the rsynced files so that future calls will rsync
different files until all files are brought to sync.
.ie n .SS "$success = $obj\->mirror_path ( $arrref | $path )"
.el .SS "\f(CW$success\fP = \f(CW$obj\fP\->mirror_path ( \f(CW$arrref\fP | \f(CW$path\fP )"
.IX Subsection "$success = $obj->mirror_path ( $arrref | $path )"
If the argument is a scalar it is treated as a path. The remote path
is mirrored into the local copy. \f(CW$path\fR is the path found in the
\&\fIrecentfile\fR, i.e. it is relative to the root directory of the
mirror.
.PP
If the argument is an array reference then all elements are treated as
a path below the current tree and all are rsynced with a single
command (and a single connection).
.ie n .SS "$path = $obj\->naive_path_normalize ($path)"
.el .SS "\f(CW$path\fP = \f(CW$obj\fP\->naive_path_normalize ($path)"
.IX Subsection "$path = $obj->naive_path_normalize ($path)"
Takes an absolute unix style path as argument and canonicalizes it to
a shorter path if possible, removing things like double slashes or
\&\f(CW\*(C`/./\*(C'\fR and removes references to \f(CW\*(C`../\*(C'\fR directories to get a shorter
unambiguos path. This is used to make the code easier that determines
if a file passed to \f(CW\*(C`upgrade()\*(C'\fR is indeed below our \f(CW\*(C`localroot\*(C'\fR.
.ie n .SS "$ret = $obj\->read_recent_1 ( $data )"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->read_recent_1 ( \f(CW$data\fP )"
.IX Subsection "$ret = $obj->read_recent_1 ( $data )"
Delegate of \f(CW\*(C`recent_events()\*(C'\fR on protocol 1
.ie n .SS "$array_ref = $obj\->recent_events ( %options )"
.el .SS "\f(CW$array_ref\fP = \f(CW$obj\fP\->recent_events ( \f(CW%options\fP )"
.IX Subsection "$array_ref = $obj->recent_events ( %options )"
Note: the code relies on the resource being written atomically. We
cannot lock because we may have no write access. If the caller has
write access (eg. \fBaggregate()\fR or \fBupdate()\fR), it has to care for any
necessary locking and it \s-1MUST\s0 write atomically.
.PP
If \f(CW$options{after}\fR is specified, only file events after this
timestamp are returned.
.PP
If \f(CW$options{before}\fR is specified, only file events before this
timestamp are returned.
.PP
If \f(CW$options{max}\fR is specified only a maximum of this many most
recent events is returned.
.PP
If \f(CW$options{\*(Aqskip\-deletes\*(Aq}\fR is specified, no files-to-be-deleted
will be returned.
.PP
If \f(CW$options{contains}\fR is specified the value must be a hash
reference containing a query. The query may contain the keys \f(CW\*(C`epoch\*(C'\fR,
\&\f(CW\*(C`path\*(C'\fR, and \f(CW\*(C`type\*(C'\fR. Each represents a condition that must be met. If
there is more than one such key, the conditions are ANDed.
.PP
If \f(CW$options{info}\fR is specified, it must be a hashref. This hashref
will be filled with metadata about the unfiltered recent_events of
this object, in key \f(CW\*(C`first\*(C'\fR there is the first item, in key \f(CW\*(C`last\*(C'\fR
is the last.
.ie n .SS "$ret = $obj\->rfilename"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->rfilename"
.IX Subsection "$ret = $obj->rfilename"
Just the basename of our \fIrecentfile\fR, composed from \f(CW\*(C`filenameroot\*(C'\fR,
a dash, \f(CW\*(C`interval\*(C'\fR, and \f(CW\*(C`serializer_suffix\*(C'\fR. E.g. \f(CW\*(C`RECENT\-6h.yaml\*(C'\fR
.ie n .SS "$str = $self\->remote_dir"
.el .SS "\f(CW$str\fP = \f(CW$self\fP\->remote_dir"
.IX Subsection "$str = $self->remote_dir"
The directory we are mirroring from.
.ie n .SS "$str = $obj\->remoteroot"
.el .SS "\f(CW$str\fP = \f(CW$obj\fP\->remoteroot"
.IX Subsection "$str = $obj->remoteroot"
.ie n .SS "(void) $obj\->remoteroot ( $set )"
.el .SS "(void) \f(CW$obj\fP\->remoteroot ( \f(CW$set\fP )"
.IX Subsection "(void) $obj->remoteroot ( $set )"
Get/Set the composed prefix needed when rsyncing from a remote module.
If remote_host, remote_module, and remote_dir are set, it is composed
from these.
.ie n .SS "(void) $obj\->split_rfilename ( $recentfilename )"
.el .SS "(void) \f(CW$obj\fP\->split_rfilename ( \f(CW$recentfilename\fP )"
.IX Subsection "(void) $obj->split_rfilename ( $recentfilename )"
Inverse method to \f(CW\*(C`rfilename\*(C'\fR. \f(CW$recentfilename\fR is a plain filename
of the pattern
.PP
.Vb 1
\&    $filenameroot\-$interval$serializer_suffix
.Ve
.PP
e.g.
.PP
.Vb 1
\&    RECENT\-1M.yaml
.Ve
.PP
This filename is split into its parts and the parts are fed to the
object itself.
.ie n .SS "my $rfile = $obj\->rfile"
.el .SS "my \f(CW$rfile\fP = \f(CW$obj\fP\->rfile"
.IX Subsection "my $rfile = $obj->rfile"
Returns the full path of the \fIrecentfile\fR
.ie n .SS "$rsync_obj = $obj\->rsync"
.el .SS "\f(CW$rsync_obj\fP = \f(CW$obj\fP\->rsync"
.IX Subsection "$rsync_obj = $obj->rsync"
The File::Rsync object that this object uses for communicating with an
upstream server.
.ie n .SS "(void) $obj\->register_rsync_error(@err)"
.el .SS "(void) \f(CW$obj\fP\->register_rsync_error(@err)"
.IX Subsection "(void) $obj->register_rsync_error(@err)"
.ie n .SS "(void) $obj\->\fBun_register_rsync_error()\fP"
.el .SS "(void) \f(CW$obj\fP\->\fBun_register_rsync_error()\fP"
.IX Subsection "(void) $obj->un_register_rsync_error()"
Register_rsync_error is called whenever the File::Rsync object fails
on an exec (say, connection doesn't succeed). It issues a warning and
sleeps for an increasing amount of time. Un_register_rsync_error
resets the error count. See also accessor \f(CW\*(C`max_rsync_errors\*(C'\fR.
.ie n .SS "$clone = $obj\->_sparse_clone"
.el .SS "\f(CW$clone\fP = \f(CW$obj\fP\->_sparse_clone"
.IX Subsection "$clone = $obj->_sparse_clone"
Clones just as much from itself that it does not hurt. Experimental
method.
.PP
Note: what fits better: sparse or shallow? Other suggestions?
.ie n .SS "$boolean = \s-1OBJ\-\s0>ttl_reached ()"
.el .SS "\f(CW$boolean\fP = \s-1OBJ\-\s0>ttl_reached ()"
.IX Subsection "$boolean = OBJ->ttl_reached ()"
.ie n .SS "(void) $obj\->\fBunlock()\fP"
.el .SS "(void) \f(CW$obj\fP\->\fBunlock()\fP"
.IX Subsection "(void) $obj->unlock()"
Unlocking is implemented with an \f(CW\*(C`rmdir\*(C'\fR on a locking directory
(\f(CW\*(C`.lock\*(C'\fR appended to \f(CW$rfile\fR).
.SS "unseed"
.IX Subsection "unseed"
Sets this recentfile in the state of not 'seeded'.
.ie n .SS "$ret = $obj\->update ($path, $type)"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->update ($path, \f(CW$type\fP)"
.IX Subsection "$ret = $obj->update ($path, $type)"
.ie n .SS "$ret = $obj\->update ($path, ""new"", $dirty_epoch)"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->update ($path, ``new'', \f(CW$dirty_epoch\fP)"
.IX Subsection "$ret = $obj->update ($path, new, $dirty_epoch)"
.ie n .SS "$ret = $obj\->update ()"
.el .SS "\f(CW$ret\fP = \f(CW$obj\fP\->update ()"
.IX Subsection "$ret = $obj->update ()"
Enter one file into the local \fIrecentfile\fR. \f(CW$path\fR is the (usually
absolute) path. If the path is outside \fIour\fR tree, then it is
ignored.
.PP
\&\f(CW$type\fR is one of \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`delete\*(C'\fR.
.PP
Events of type \f(CW\*(C`new\*(C'\fR may set \f(CW$dirty_epoch\fR. \f(CW$dirty_epoch\fR is normally
not used and the epoch is calculated by the \fBupdate()\fR routine itself
based on current time. But if there is the demand to insert a
not-so-current file into the dataset, then the caller sets
\&\f(CW$dirty_epoch\fR. This causes the epoch of the registered event to become
\&\f(CW$dirty_epoch\fR or \*(-- if the exact value given is already taken \*(-- a tiny
bit more. As compensation the dirtymark of the whole dataset is set to
now or the current epoch, whichever is higher. Note: setting the
dirty_epoch to the future is prohibited as it's very unlikely to be
intended: it definitely might wreak havoc with the index files.
.PP
The new file event is unshifted (or, if dirty_epoch is set, inserted
at the place it belongs to, according to the rule to have a sequence
of strictly decreasing timestamps) to the array of recent_events and
the array is shortened to the length of the timespan allowed. This is
usually the timespan specified by the interval of this recentfile but
as long as this recentfile has not been merged to another one, the
timespan may grow without bounds.
.PP
The third form runs an update without inserting a new file. This may
be desired to truncate a recentfile.
.ie n .SS "$obj\->batch_update($batch)"
.el .SS "\f(CW$obj\fP\->batch_update($batch)"
.IX Subsection "$obj->batch_update($batch)"
Like update but for many files. \f(CW$batch\fR is an arrayref containing
hashrefs with the structure
.PP
.Vb 5
\&  {
\&    path => $path,
\&    type => $type,
\&    epoch => $epoch,
\&  }
.Ve
.SS "seed"
.IX Subsection "seed"
Sets this recentfile in the state of 'seeded' which means it has to
re-evaluate its uptodateness.
.SS "seeded"
.IX Subsection "seeded"
Tells if the recentfile is in the state 'seeded'.
.SS "uptodate"
.IX Subsection "uptodate"
True if this object has mirrored the complete interval covered by the
current recentfile.
.ie n .SS "$obj\->write_recent ($recent_files_arrayref)"
.el .SS "\f(CW$obj\fP\->write_recent ($recent_files_arrayref)"
.IX Subsection "$obj->write_recent ($recent_files_arrayref)"
Writes a \fIrecentfile\fR based on the current reflection of the current
state of the tree limited by the current interval.
.ie n .SS "$obj\->write_0 ($recent_files_arrayref)"
.el .SS "\f(CW$obj\fP\->write_0 ($recent_files_arrayref)"
.IX Subsection "$obj->write_0 ($recent_files_arrayref)"
Delegate of \f(CW\*(C`write_recent()\*(C'\fR on protocol 0
.ie n .SS "$obj\->write_1 ($recent_files_arrayref)"
.el .SS "\f(CW$obj\fP\->write_1 ($recent_files_arrayref)"
.IX Subsection "$obj->write_1 ($recent_files_arrayref)"
Delegate of \f(CW\*(C`write_recent()\*(C'\fR on protocol 1
.SH "SERIALIZERS"
.IX Header "SERIALIZERS"
The following suffixes are supported and trigger the use of these
serializers:
.ie n .IP """.yaml"" => ""YAML::Syck""" 4
.el .IP "\f(CW``.yaml'' => ``YAML::Syck''\fR" 4
.IX Item """.yaml"" => ""YAML::Syck"""
.PD 0
.ie n .IP """.json"" => ""JSON""" 4
.el .IP "\f(CW``.json'' => ``JSON''\fR" 4
.IX Item """.json"" => ""JSON"""
.ie n .IP """.sto""  => ""Storable""" 4
.el .IP "\f(CW``.sto''  => ``Storable''\fR" 4
.IX Item """.sto"" => ""Storable"""
.ie n .IP """.dd""   => ""Data::Dumper""" 4
.el .IP "\f(CW``.dd''   => ``Data::Dumper''\fR" 4
.IX Item """.dd"" => ""Data::Dumper"""
.PD
.SH "INTERVAL SPEC"
.IX Header "INTERVAL SPEC"
An interval spec is a primitive way to express time spans. Normally it
is composed from an integer and a letter.
.PP
As a special case, a string that consists only of the single letter
\&\f(CW\*(C`Z\*(C'\fR, stands for \s-1MAX_INT\s0 seconds.
.PP
The following letters express the specified number of seconds:
.ie n .IP """s => 1""" 4
.el .IP "\f(CWs => 1\fR" 4
.IX Item "s => 1"
.PD 0
.ie n .IP """m => 60""" 4
.el .IP "\f(CWm => 60\fR" 4
.IX Item "m => 60"
.ie n .IP """h => 60*60""" 4
.el .IP "\f(CWh => 60*60\fR" 4
.IX Item "h => 60*60"
.ie n .IP """d => 60*60*24""" 4
.el .IP "\f(CWd => 60*60*24\fR" 4
.IX Item "d => 60*60*24"
.ie n .IP """W => 60*60*24*7""" 4
.el .IP "\f(CWW => 60*60*24*7\fR" 4
.IX Item "W => 60*60*24*7"
.ie n .IP """M => 60*60*24*30""" 4
.el .IP "\f(CWM => 60*60*24*30\fR" 4
.IX Item "M => 60*60*24*30"
.ie n .IP """Q => 60*60*24*90""" 4
.el .IP "\f(CWQ => 60*60*24*90\fR" 4
.IX Item "Q => 60*60*24*90"
.ie n .IP """Y => 60*60*24*365.25""" 4
.el .IP "\f(CWY => 60*60*24*365.25\fR" 4
.IX Item "Y => 60*60*24*365.25"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Rsync::Mirror::Recent,
File::Rsync::Mirror::Recentfile::Done,
File::Rsync::Mirror::Recentfile::FakeBigFloat
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests through the web interface
at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File\-Rsync\-Mirror\-Recentfile>.
I will be notified, and then you'll automatically be notified of
progress on your bug as I make changes.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Memory hungry: it seems all memory is allocated during the initial
rsync where a list of all files is maintained in memory.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc File::Rsync::Mirror::Recentfile
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File\-Rsync\-Mirror\-Recentfile>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/File\-Rsync\-Mirror\-Recentfile>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/File\-Rsync\-Mirror\-Recentfile>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/File\-Rsync\-Mirror\-Recentfile>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to \s-1RJBS\s0 for module-starter.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andreas König
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008,2009 Andreas König.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
