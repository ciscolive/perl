.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::State 3"
.TH Workflow::State 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::State \- Information about an individual state in a workflow
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.14 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& # This is an internal object...
\& <workflow...>
\&   <state name="Start">
\&     <action ... resulting_state="Progress" />
\&   </state>
\&      ...
\&   <state name="Progress" description="I am in progress">
\&     <action ... >
\&        <resulting_state return="0" state="Needs Affirmation" />
\&        <resulting_state return="1" state="Approved" />
\&        <resulting_state return="*" state="Needs More Info" />
\&     </action>
\&   </state>
\&      ...
\&   <state name="Approved" autorun="yes">
\&     <action ... resulting_state="Completed" />
\&      ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Each Workflow::State object represents a state in a workflow. Each
state can report its name, description and all available
actions. Given the name of an action it can also report what
conditions are attached to the action and what state will result from
the action (the 'resulting state').
.SS "Resulting State"
.IX Subsection "Resulting State"
The resulting state is action-dependent. For instance, in the
following example you can perform two actions from the state 'Ticket
Created' \*(-- 'add comment' and 'edit issue':
.PP
.Vb 6
\&  <state name="Ticket Created">
\&     <action name="add comment"
\&             resulting_state="NOCHANGE" />
\&     <action name="edit issue"
\&             resulting_state="Ticket In Progress" />
\&   </state>
.Ve
.PP
If you execute 'add comment' the new state of the workflow will be the
same ('\s-1NOCHANGE\s0' is a special state). But if you execute 'edit issue'
the new state will be 'Ticket In Progress'.
.PP
You can also have multiple return states for a single action. The one
chosen by the workflow system will depend on what the action
returns. For instance we might have something like:
.PP
.Vb 7
\&  <state name="create user">
\&     <action name="create">
\&         <resulting_state return="admin"    state="Assign as Admin" />
\&         <resulting_state return="helpdesk" state="Assign as Helpdesk" />
\&         <resulting_state return="*"        state="Assign as Luser" />
\&     </action>
\&   </state>
.Ve
.PP
So if we execute 'create' the workflow will be in one of three states:
\&'Assign as Admin' if the return value of the 'create' action is
\&'admin', 'Assign as Helpdesk' if the return is 'helpdesk', and 'Assign
as Luser' if the return is anything else.
.SS "Autorun State"
.IX Subsection "Autorun State"
You can also indicate that the state should be automatically executed
when the workflow enters it using the 'autorun' property. Note the
slight change in terminology \*(-- typically we talk about executing an
action, not a state. But we can use both here because an automatically
run state requires that one and only one action is available for
running. That doesn't mean a state contains only one action. It just
means that only one action is available when the state is entered. For
example, you might have two actions with mutually exclusive conditions
within the autorun state.
.PP
If no action or more than one action is available at the time the
workflow enters an autorun state, Workflow will throw an error. There
are some conditions where this might not be what you want. For example
when you have a state which contains an action that depends on some
condition. If it is true, you might be happy to move on to the next
state, but if it is not, you are fine to come back and try again later
if the action is available. This behaviour can be achived by setting the
\&'may_stop' property to yes, which will cause Workflow to just quietly
stop automatic execution if it does not have a single action to execute.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
\fIget_conditions( \f(CI$action_name\fI )\fR
.IX Subsection "get_conditions( $action_name )"
.PP
Returns a list of Workflow::Condition objects for action
\&\f(CW$action_name\fR. Throws exception if object does not contain
\&\f(CW$action_name\fR at all.
.PP
\fIcontains_action( \f(CI$action_name\fI )\fR
.IX Subsection "contains_action( $action_name )"
.PP
Returns true if this state contains action \f(CW$action_name\fR, false if
not.
.PP
\fIis_action_available( \f(CI$workflow\fI, \f(CI$action_name\fI )\fR
.IX Subsection "is_action_available( $workflow, $action_name )"
.PP
Returns true if \f(CW$action_name\fR is contained within this state \fBand\fR
it matches any conditions attached to it, using the data in the
context of the \f(CW$workflow\fR to do the checks.
.PP
\fIevaluate_action( \f(CI$workflow\fI, \f(CI$action_name\fI )\fR
.IX Subsection "evaluate_action( $workflow, $action_name )"
.PP
Throws exception if action \f(CW$action_name\fR is either not contained in
this state or if it does not pass any of the attached conditions,
using the data in the context of \f(CW$workflow\fR to do the checks.
.PP
\fI\f(BIget_all_action_names()\fI\fR
.IX Subsection "get_all_action_names()"
.PP
Returns list of all action names available in this state.
.PP
\fIget_available_action_names( \f(CI$workflow\fI, \f(CI$group\fI )\fR
.IX Subsection "get_available_action_names( $workflow, $group )"
.PP
Returns all actions names that are available given the data in
\&\f(CW$workflow\fR. Each action name returned will return true from
\&\fB\fBis_action_available()\fB\fR.
\&\f(CW$group\fR is optional parameter. If it is set, additional check for group
membership will be performed.
.PP
\fIget_next_state( \f(CI$action_name\fI, [ \f(CI$action_return\fI ] )\fR
.IX Subsection "get_next_state( $action_name, [ $action_return ] )"
.PP
Returns the state(s) that will result if action \f(CW$action_name\fR
is executed. If you've specified multiple return states in the
configuration then you need to specify the \f(CW$action_return\fR,
otherwise we return a hash with action return values as the keys and
the action names as the values.
.PP
\fIget_autorun_action_name( \f(CI$workflow\fI )\fR
.IX Subsection "get_autorun_action_name( $workflow )"
.PP
Retrieve the action name to be autorun for this state. If the state
does not have the 'autorun' property enabled this throws an
exception. It also throws an exception if there are multiple actions
available or if there are no actions available.
.PP
Returns name of action to be used for autorunning the state.
.PP
\fIclear_condition_cache ( )\fR
.IX Subsection "clear_condition_cache ( )"
.PP
Empties the condition result cache for a given state.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
All property methods act as a getter and setter. For example:
.PP
.Vb 2
\& my $state_name = $state\->state;
\& $state\->state( \*(Aqsome name\*(Aq );
.Ve
.PP
\&\fBstate\fR
.PP
Name of this state (required).
.PP
\&\fBdescription\fR
.PP
Description of this state (optional).
.PP
\fIautorun\fR
.IX Subsection "autorun"
.PP
Returns true if the state should be automatically run, false if
not. To set to true the property value should be 'yes', 'true' or 1.
.PP
\fImay_stop\fR
.IX Subsection "may_stop"
.PP
Returns true if the state may stop automatic execution silently, false
if not. To set to true the property value should be 'yes', 'true' or 1.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
\fIinit( \f(CI$config\fI )\fR
.IX Subsection "init( $config )"
.PP
Assigns 'state', 'description', 'autorun' and 'may_stop' properties from
\&\f(CW$config\fR. Also assigns configuration for all actions in the state,
performing some sanity checks like ensuring every action has a
\&'resulting_state' key.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Workflow
.PP
Workflow::Condition
.PP
Workflow::Factory
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2007 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonas B. Nielsen (jonasbn) <jonasbn@cpan.org> is the current maintainer.
.PP
Chris Winters <chris@cwinters.com>
