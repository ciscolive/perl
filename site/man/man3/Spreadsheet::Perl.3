.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Perl 3"
.TH Perl 3 "2011-05-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Perl \- Pure Perl implementation of a spreadsheet engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Spreadsheet::Perl;
\&  use Spreadsheet::Perl::Arithmetic ;
\&
\&  my $ss = tie my %ss, "Spreadsheet::Perl"
\&
\&  $ss\->SetNames("TEST_RANGE" => \*(AqA5:B8\*(Aq) ;
\&  $ss{TEST_RANGE} = \*(Aq7\*(Aq ;
\&  
\&  DefineSpreadsheetFunction(\*(AqAddOne\*(Aq, \e&AddOne) ;
\&  
\&  $ss{A3} = PerlFormula(\*(Aq$ss\->AddOne("A5") + $ss{A5}\*(Aq) ;
\&  print "A3 formula => " . $ss\->GetFormulaText(\*(AqA3\*(Aq) . "\en" ;
\&  print "A3 = $ss{A3}\en" ;
\&
\&  $ss{\*(AqABC1:ABD5\*(Aq} = \*(Aq10\*(Aq ;
\&
\&  $ss{A4} = PerlFormula(\*(Aq$ss\->Sum("A5:B8", "ABC1:ABD5")\*(Aq) ;
\&  print "A4 = $ss{A4}\en" ;
\&  
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Spreadsheet::Perl is a pure Perl implementation of a spreadsheet engine.
.PP
Spreadsheet::Perl functionality:
.IP "\(bu" 2
set and get values from cells or ranges
.IP "\(bu" 2
handle cell private data
.IP "\(bu" 2
has fetch/store callback
.IP "\(bu" 2
has cell attributes access
.IP "\(bu" 2
has cell/range fillers (auto-fill functionality)
.IP "\(bu" 2
set formulas (pure perl and common format)
.IP "\(bu" 2
compute the dependencies between cells
.IP "\(bu" 2
formulas can fetch data from multiple spreadsheets and the dependencies still work
.IP "\(bu" 2
checks for circular dependencies
.IP "\(bu" 2
debugging triggers
.IP "\(bu" 2
has a simple architecture for expansion
.IP "\(bu" 2
has a simple architecture for debugging (and some flags are already implemented)
.IP "\(bu" 2
can read its data from a file
.IP "\(bu" 2
supports cell naming
.IP "\(bu" 2
cell and range locking
.IP "\(bu" 2
input validators
.IP "\(bu" 2
cell formats (pod, \s-1HTML, ...\s0)
.IP "\(bu" 2
can define spreadsheet functions from the scripts using it or via a new module of your own
.IP "\(bu" 2
\&\fBRecalculate()\fR / \s-1AUTOCALC\s0
.IP "\(bu" 2
value caching to speed up formulas and 'volatile' cells
.IP "\(bu" 2
cell address offsetting functions
.IP "\(bu" 2
Automatic formula offsetting
.IP "\(bu" 2
Insertion of rows and columns (doesn't support interspreadsheet formulas)
.IP "\(bu" 2
Relative and fixed cell addresses
.IP "\(bu" 2
slice access
.IP "\(bu" 2
Perl scalar mapping to a cell
.IP "\(bu" 2
some debugging tool (dump, dump table, dump to \s-1HTML,\s0 formula stack trace, ...)
.PP
Lots of examples in the 'examples' directory.
.SH "DRIVING FORCE"
.IX Header "DRIVING FORCE"
.SS "Why"
.IX Subsection "Why"
I found no spreadsheet modules on \s-1CPAN.\s0
.PP
I you have an application that takes some input and does calculation on them, chances
are that implementing it through a spreadsheet will make it more maintainable and easier to develop.
Here are the reasons (\s-1IMO\s0) why:
.IP "\(bu" 2
Spreadsheet programming (\s-1SP\s0) is data oriented and this is what programming should be.
.IP "\(bu" 2
\&\s-1SP\s0 is encapsulating. The processing is \*(L"hidden\*(R"behind the cell value in form of formulas.
.IP "\(bu" 2
\&\s-1SP\s0 is encapsulating \s-1II.\s0 The data dependencies are automatically computed by the spreadsheet, relieving 
you from keeping things in synch
.IP "\(bu" 2
\&\s-1SP\s0 is 2 dimensional (or 3 or 4), specially if you have a \s-1GUI\s0 Â for it.
.IP "\(bu" 2
If you have a \s-1GUI, SP\s0 is visual programming and visual debugging as the 
spreadsheet is the input and the dump of the data. The possibility to to 
show a multi-dimensional dependency is great as is the fact that you don't 
need to look around for where things are defined (this is more about 
visual programming but still fit spreadsheets as they are often \s-1GUI\s0 based)
.IP "\(bu" 2
\&\s-1SP\s0 allows for user customization
.SS "How"
.IX Subsection "How"
I want \fBSpreadsheets::Perl\fR to:
.IP "\(bu" 2
Be very Perlish
.IP "\(bu" 2
Be easy to expand
.IP "\(bu" 2
Be easy to use for Perl programmers
.SH "CREATING A SPREADSHEET"
.IX Header "CREATING A SPREADSHEET"
Spreadsheet perl is implemented as a tie. Remember that you can use hash slices (I 'll give some examples). The
spreadsheet functions are accessed through the tied object.
.SS "Simple creation"
.IX Subsection "Simple creation"
.Vb 2
\&  use Spreadsheet::Perl ;
\&  my $ss = tie my %ss, "Spreadsheet::Perl" ;
.Ve
.SS "Setting up data"
.IX Subsection "Setting up data"
\fISetting the cell data\fR
.IX Subsection "Setting the cell data"
.PP
.Vb 8
\&  use Spreadsheet::Perl ;
\&  tie my %ss, "Spreadsheet::Perl"
\&                , CELLS =>
\&                                {
\&                                  A1 =>
\&                                                {
\&                                                VALUE => \*(Aqhi\*(Aq
\&                                                }
\&                                        
\&                                , A2 =>
\&                                                {
\&                                                VALUE => \*(Aqthere\*(Aq
\&                                                #~ or
\&                                                #~ PERL_FORMULA => [undef, \*(Aq$ss{A1}\*(Aq]
\&                                                }
\&                                } ;
.Ve
.PP
\fISetting the cell data, simple way\fR
.IX Subsection "Setting the cell data, simple way"
.PP
.Vb 3
\&  use Spreadsheet::Perl ;
\&  tie my %ss, "Spreadsheet::Perl"
\&  @ss{\*(AqA1\*(Aq, \*(AqB1:C2\*(Aq, \*(AqA8\*(Aq} = (\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq);
.Ve
.PP
\fISetting the spreadsheet attributes\fR
.IX Subsection "Setting the spreadsheet attributes"
.PP
.Vb 4
\&  use Spreadsheet::Perl ;
\&  tie my %ss, "Spreadsheet::Perl"
\&                  , NAME => \*(AqTEST\*(Aq
\&                  , DEBUG => { PRINT_FORMULA => 1} ;
.Ve
.SS "reading, cell only,  data from a file"
.IX Subsection "reading, cell only, data from a file"
.Vb 2
\&  <\- start of ss_setup.pl \->
\&  # how to compute the data
\&  
\&  sub OneMillion
\&  {
\&  return(1_000_000) ;
\&  }
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # the spreadsheet data
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  A1 => 120, 
\&  A2 => sub{1},
\&  A3 => PerlFormula(\*(Aq$ss\->Sum("A1:A2")\*(Aq),
\&  
\&  B1 => 3,
\&  
\&  c2 => "hi there",
\&  
\&  D1 => OneMillion()
\&  
\&  <\- end of ss_setup.pl \->
\&
\&  use Spreadsheet::Perl ;
\&  tie my %ss, "Spreadsheet::Perl", NAME => \*(AqTEST\*(Aq ;
\&  %ss = do "ss_setup.pl" or confess "Couldn\*(Aqt read setup file \*(Aqss_setup.pl\*(Aq" ;
.Ve
.SS "insertion and deletion of rows and columns"
.IX Subsection "insertion and deletion of rows and columns"
Right now, \s-1SS::P\s0 will \fB\s-1ONLY\s0\fR properly handle insertion/deletion
within a single spreadsheet. That is, if you have multiply linked
spreadsheets, do not use insertion/deletion. This is \fBnot\fR automatically checked!
.PP
This is a temporary limitation and it will be removed.
.PP
If you use a spreadsheet that does not reference another spreadsheet, using
insertion/deletion will update Perl formulas and dependencies just fine.
.SS "dumping a spreadsheet"
.IX Subsection "dumping a spreadsheet"
Use the Dump function (see \fIDebugging\fR):
.PP
.Vb 3
\&  my $ss = tied %ss ;
\&  ...
\&  print $ss\->Dump() ;
.Ve
.PP
Generates:
.PP
.Vb 2
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Spreadsheet::Perl=HASH(0x825540c) \*(AqTEST\*(Aq [3550 bytes]
\&  
\&  Cells:
\&  |\- A1
\&  |  \`\- VALUE = 120
\&  |\- A2
\&  |  \`\- VALUE = CODE(0x82554d8)
\&  |\- A3
\&  |  |\- ANCHOR = A3
\&  |  |\- FETCH_SUB = CODE(0x825702c)
\&  |  |\- FETCH_SUB_ARGS
\&  |  |\- PERL_FORMULA = Object of type \*(AqSpreadsheet::Perl::PerlFormula\*(Aq
\&  |  |  |\- 0 = CODE(0x923752c)
\&  |  |  \`\- 1 = $ss\->Sum("A1:A2")
\&  |  |\- GENERATED_FORMULA = $ss\->Sum("A1:A2")
\&  |  \`\- NEED_UPDATE = 1
\&  |\- B1
\&  |  \`\- VALUE = 3
\&  |\- C2
\&  |  \`\- VALUE = hi there
\&  \`\- D1
\&     \`\- VALUE = 1000000
\&  
\&  Spreadsheet::Perl=HASH(0x825540c) \*(AqTEST\*(Aq dump end
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SS "reading and writing  a spreadsheet from a file"
.IX Subsection "reading and writing a spreadsheet from a file"
Version 0.06 has, prototype, functionality to read and write spreadsheets. Serializing of common format formulas are also supported.
.PP
.Vb 1
\&  use Spreadsheet::Perl ;
\&  
\&  my $ss = tie my %ss, "Spreadsheet::Perl" ;
\&
\&  $ss\->Read(\*(Aqss_data.pl\*(Aq) ;
\&
\&  print $ss\->DumpTable() ;
\&  
\&  $ss\->Write(\*(Aqgenerated_ss_data.pl\*(Aq) ;
\&
\&  undef $ss ;
\&  untie %ss ;
\&  
\&  $ss = tie %ss, "Spreadsheet::Perl" ;
\&  $ss\->Read(\*(Aqgenerated_ss_data.pl\*(Aq) ;
\&  
\&  print $ss\->DumpTable() ;
.Ve
.PP
You can find a small example in \fIexamples/read_write.\fR. See also: \*(L"Function definition\*(R" bellow.
.SS "Dumping a table"
.IX Subsection "Dumping a table"
HÃ¥kon NessjÃ¸en (author of Text::ASCIITable) was nice enough to contribute a module to dump 
the spreadsheet in table form.
.PP
The functionality can be access through two, equivalent, function names: \fIDumpTable\fR (an alias) and \fIGenerateASCIITable\fR.
The functions take the following arguments:
.IP "1\- a list of ranges within an array reference or 'undef' for the whole spreadsheet" 2
.IX Item "1- a list of ranges within an array reference or 'undef' for the whole spreadsheet"
.PD 0
.IP "2\- a boolean, when set, the spreadsheet attributes are also displayed" 2
.IX Item "2- a boolean, when set, the spreadsheet attributes are also displayed"
.IP "3\- options passed to Text::ASCIITable" 2
.IX Item "3- options passed to Text::ASCIITable"
.IP "4\- arguments passed to Text::ASCIITable::draw" 2
.IX Item "4- arguments passed to Text::ASCIITable::draw"
.PD
.PP
Most of the time you'll call \fIDumpTable\fR without argument or with the first argument set.
.PP
.Vb 1
\&  print $ss\->DumpTable() ;
\&  
\&  generates :
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | @  | A   | B   | C   | D   | E   | F   | G   | H   |
\&  |====================================================|
\&  | 1  | A1  | B1  | C1  | D1  | E1  | F1  | G1  | H1  |
\&  |\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-|
\&  | 2  | A2  | B2  | C2  | D2  | E2  | F2  | G2  | H2  |
\&  |\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-|
\&  | 3  | A3  | B3  | C3  | D3  | E3  | F3  | G3  | H3  |
\&  |\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-|
\&  ...
\&  ...
\&  |\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-|
\&  | 10 | A10 | B10 | C10 | D10 | E10 | F10 | G10 | H10 |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  
\&  print $ss\->DumpTable([\*(AqB4:C5\*(Aq, \*(AqA2:B6\*(Aq, \*(AqNAMED_RANGE\*(Aq]) ;
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | @ | B  | C  |
\&  |=============|
\&  | 4 | B4 | C4 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-|
\&  | 5 | B5 | C5 |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | @ | A  | B  |
\&  |=============|
\&  | 2 | A2 | B2 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-|
\&  | 3 | A3 | B3 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-|
\&  | 4 | A4 | B4 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-|
\&  | 5 | A5 | B5 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-|
\&  | 6 | A6 | B6 |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | @ | A  | B  | C  | D  | E  | F  | G  | H  | I | J | K |
\&  |=======================================================|
\&  | 4 | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4 |   |   |   |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-+\-\-\-+\-\-\-|
\&  | 5 | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5 |   |   |   |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  
\&  print $ss\->DumpTable
\&                (
\&                  undef
\&                , undef 
\&                , {
\&                    alignHeadRow => \*(Aqcenter\*(Aq,
\&                  , headingText  => \*(AqSome Title\*(Aq
\&                  }
\&                ) ;
\&
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  |                      Some Title                      |
\&  |======================================================|
\&  | @ |                     A                    | B | C |
\&  |======================================================|
\&  | 1 | datadatadatadatadatadatadatadatadatadata | B | B |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 2 | datadatadatadatadatadatadatadatadatadata | B | B |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 3 | datadatadatadatadatadatadatadatadatadata |   |   |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 4 | datadatadatadatadatadatadatadatadatadata |   |   |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 5 | datadatadatadatadatadatadatadatadatadata |   |   |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 6 |                                          |   |   |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 7 |                                          |   |   |
\&  |\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-+\-\-\-|
\&  | 8 | C                                        |   |   |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
It is possible to give a page width. if the page width is not set, the screen width is used.
If there is no screen width available (redirecting to a file for example) \fB78\fR is used as a width.
.PP
.Vb 1
\&  print $ss\->DumpTable([\*(AqA4:O5\*(Aq], undef, {pageWidth => 40}) ;
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | @ | A  | B  | C  | D  | E  | F  | G  | H  |
\&  |============================================
\&  | 4 | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4 |
\&  |\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+
\&  | 5 | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5 |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  \*(AqTEST\*(Aq 1/4.
\&  
\&  .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  | @ | I | J | K | L | M | N | O |
\&  |================================
\&  | 4 |   |   |   |   |   |   |   |
\&  |\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-|
\&  | 5 |   |   |   |   |   |   |   |
\&  \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  \*(AqTEST\*(Aq 2/4.
\&
\&  ...
.Ve
.PP
You can set the 'noPageCount' option if you don't want the page count.
.PP
Note:
If \f(CW$ss\fR\->{\s-1DEBUG\s0}{\s-1PRINT_DEPENDENT_LIST\s0} is set, the cells depending
on a specific cell are listed in the inline information ( a reverse
dependency list)
.PP
To make sure the dependent list is up to date before display,
\&\fBRecalculate()\fR is called before dumping the spreadsheet.
.PP
See \fBText::ASCIITable\fR.
.SH "CELL and RANGE: ADDRESSING, NAMING"
.IX Header "CELL and RANGE: ADDRESSING, NAMING"
Cells are index  with a scheme I call baseAA (please let me know if it has a better name).
A cell address is a combination of letters and a figure, ex: 'A1', '\s-1BB45\s0', '\s-1ABDE15\s0'.
.PP
BaseAA figures match /[A\-Z]{1,4}/. see \fBSpreadsheet::ConvertAA\fR. There is no limit on the numeric figure.
Spreadsheet::Perl is implemented as a hash thus allowing for sparse spreadsheets.
.SS "Address format"
.IX Subsection "Address format"
Addresses are composed of:
.IP "\(bu" 2
an optional spreadsheet name and '!'. ex: '\s-1TEST\s0!'
.IP "\(bu" 2
a baseAA1 figure. ex 'A1'
.IP "\(bu" 2
a ':' followed by a baseAA1 figure for ranges. ex: ':A5'
.PP
The following are valid addresses: A1 \s-1TEST\s0!A1 A1:BB5 \s-1TEST\s0!A5:CE43
.PP
For a range, the order of the baseAA figures is important!
.PP
.Vb 1
\&  $ss{\*(AqA1:D5\*(Aq} = 7; is equivalent to $ss{\*(AqD5:A1\*(Aq} = 7;
.Ve
.PP
but
.PP
.Vb 1
\&  $ss{\*(AqA1:D5\*(Aq} = PerlFormula(\*(Aq$ss{H10}\*(Aq); is NOT equivalent to $ss{\*(AqD5:A1\*(Aq} = PerlFormula(\*(Aq$ss{H10}\*(Aq);
.Ve
.PP
because formulas are regenerated for each cell. Spreadsheet::Perl goes from the first baseAA figure
to the second one by iterating the row, then the column.
.PP
It is also possible to index cells with numerals only: \f(CW$ss\fR{\*(L"1,7\*(R"}. Remember that A is 1 and there are
no zeros.
.SS "Names"
.IX Subsection "Names"
It is possible to give a name to a cell or to a range:
.PP
.Vb 2
\&  my $ss = tie my %ss, "Spreadsheet::Perl" ;
\&  @ss{\*(AqA1\*(Aq, \*(AqA2\*(Aq} = (\*(Aqcell A1\*(Aq, \*(Aqcell A2\*(Aq) ;
\&  
\&  $ss\->SetCellName("FIRST", "A1") ;
\&  print  $ss{FIRST} . \*(Aq \*(Aq . $ss{A2} . "\en" ;
\&  
\&  $ss\->SetRangeName("FIRST_RANGE", "A1:A2") ;
\&  print  "First range: @{$ss{FIRST_RANGE}}\en" ;
.Ve
.PP
Names must be upper case.
.PP
Note that, for the moment, column/row insertion and deletion do not
work with cell/range names. Or, more exactely, \s-1SS:P\s0 can not change cell
addresses in named range. \s-1IE:\s0 after insertion of a row, formula \*(L"$ss{B4}\*(R" may become \*(L"$ss{C4}\*(R". if cell B4 had the name \*(L"\s-1MYCELL\*(R", SS:P\s0 could not modify the formula \*(L"$ss{\s-1MYCELL\s0}\*(R". In future version, we may choose between replacing \s-1MYCELL\s0 with a cell address automatically or invalidate all the cells containing a named address that is influenced by a column/row insertion/deletion.
.SH "LABELING ROW AND COLUMN HEADERS"
.IX Header "LABELING ROW AND COLUMN HEADERS"
.Vb 4
\&        $ss{A0} = \*(Aqcolumn A\*(Aq ;
\&        $ss{B0} = \*(Aqcolumn B\*(Aq ;
\&        $ss{@1} = \*(Aqrow 1\*(Aq ;
\&        $ss{@2} = \*(Aqrow 2\*(Aq ;
.Ve
.PP
The subs \fBlabel_column\fR and \fBlabel_row\fR can also be used.
.PP
.Vb 3
\&        $ss\->label_column(\*(AqA\*(Aq => "First column") ;
\&        $ss\->label_row(1 => \*(Aqrow 1\*(Aq) ;
\&        $ss\->label_row(2 => \*(Aqrow 2\*(Aq) ;
.Ve
.SH "OTHER SPREADSHEET"
.IX Header "OTHER SPREADSHEET"
To use inter-spreadsheet formulas, you need to make the spreadsheet aware of the other spreadsheets by
calling the \fIAddSpreadsheet\fR function.
.PP
.Vb 2
\&  tie my %romeo, "Spreadsheet::Perl", NAME => \*(AqROMEO\*(Aq ;
\&  my $romeo = tied %romeo ;
\&
\&  tie my %juliette, "Spreadsheet::Perl", NAME => \*(AqJULIETTE\*(Aq ;
\&  my $juliette = tied %juliette ;
\&
\&  $romeo\->AddSpreadsheet(\*(AqJULIETTE\*(Aq, $juliette) ;
\&  $juliette\->AddSpreadsheet(\*(AqROMEO\*(Aq, $romeo) ;
\&  
\&  $romeo{\*(AqB1:B5\*(Aq} = 10 ;
\&  
\&  $juliette{A4} = 5 ;
\&  $juliette{A5} = PerlFormula(\*(Aq$ss\->Sum("JULIETTE!A4") + $ss\->Sum("ROMEO!B1:B2")\*(Aq) ;
.Ve
.SH "SPREADSHEET Functions"
.IX Header "SPREADSHEET Functions"
.SS "Locking"
.IX Subsection "Locking"
Locking the spreadsheet:
.PP
.Vb 3
\&  tie my %ss, "Spreadsheet::Perl", LOCKED => 1 ;
\&  $ss\->Lock() ;
\&  $ss\->Lock(1) ;
.Ve
.PP
Unlocking the spreadsheet:
.PP
.Vb 1
\&  $ss\->Lock(0) ;
.Ve
.SS "Locking a Range"
.IX Subsection "Locking a Range"
Locking a range:
.PP
.Vb 2
\&  LockRange(\*(AqA1:B6\*(Aq) ;
\&  LockRange(\*(AqA1:B6\*(Aq, 1) ;
.Ve
.PP
Unlocking a range:
.PP
.Vb 1
\&  LockRange(\*(AqA1:B6\*(Aq, 0) ;
.Ve
.SS "Cache"
.IX Subsection "Cache"
Spreadsheet::Perl caches the result of the formulas and recalculates cell values only when needed.
.SS "Calculation control"
.IX Subsection "Calculation control"
Spreadsheet::Perl computes the value of a cell (see \fBCache\fR above) when the cell is accessed.
If a cell A1 depends on cell A2 and cell A2 is modified, the value of cell A1 is not updated until it is 
accessed. If you want to update all the cell (in need of being updated) use:
.PP
.Vb 1
\&  $ss\->Recalculate() ;
.Ve
.PP
This comes handy if you want to flush the result to a database linked to the spreadsheet
.PP
It is possible to force the recalculation of the spreadsheet every time a cell with dependent is set:
.PP
.Vb 3
\&  tie my %ss, "Spreadsheet::Perl", AUTOCALC => 1 ;
\&  $ss\->SetAutocalc() ;
\&  $ss\->SetAutocalc(1) ;
.Ve
.PP
Turning off auto recalculation:
.PP
.Vb 1
\&  $ss\->SetAutocalc(0) ;
.Ve
.PP
\&\s-1AUTOCALC\s0 is set to 0 by default.
.SS "Function definition"
.IX Subsection "Function definition"
Spreadsheet::Perl comes with a single formula function defined (Sum).
.PP
Spreadsheet::Perl uses perl arithmetics so all the functions available in perl are available to you. You can define 
your own functions.
.PP
.Vb 4
\&  sub AddOne
\&  {
\&  my $ss = shift ;
\&  my $address = shift ;
\&  
\&  return($ss\->Get($address) + 1) ;
\&  }
\&  
\&  DefineSpreadsheetFunction(\*(AqAddOne\*(Aq, \e&AddOne) ;
\&
\&  $ss{A3} = PerlFormula(\*(Aq$ss\->AddOne("A1") + $ss{A2}\*(Aq) ;
.Ve
.PP
Sub AddOne is now available in all your spreadsheets.
.PP
DefineSpreadsheetFunction takes the following parameters:
.IP "1 \- A function name" 2
.IX Item "1 - A function name"
.PD 0
.IP "2 \- A sub reference or undef if item 3 is defined" 2
.IX Item "2 - A sub reference or undef if item 3 is defined"
.IP "3 \- A text representation for the function (for file serialization)" 2
.IX Item "3 - A text representation for the function (for file serialization)"
.IP "2 \- A module name (for file serialization)" 2
.IX Item "2 - A module name (for file serialization)"
.PD
.PP
The sub will be passed a reference to the spreadsheet object as first argument. The other argument are those you
pass to the function in your formula.
.PP
\fIFunction collections\fR
.IX Subsection "Function collections"
.PP
If you implement more than a few formula functions, you may want to move those functions into a perl module.
\&\*(L"use\*(R" Spreadsheet::Perl in your module and register your functions through \fBDefineSpreadsheetFunction\fR.
.PP
.Vb 1
\&  package MyPackageName ;
\&  
\&  sub DoSomething{}
\&  
\&  AddSpreadsheetFunction(\*(AqDoSomething\*(Aq, \e&DoSomething, undef, _\|_PACKAGE_\|_) ;
.Ve
.PP
Later in a script:
.PP
.Vb 2
\&  use Spreadsheet::Perl ;
\&  use MyPackageName ;
\&  
\&  # DoSomething is now available within formulas
\&  $ss{A1} = PF(\*(Aq$ss\->DoSomething(\*(AqA2:A3\*(Aq, \*(Aqarg2\*(Aq, \*(Aqarg3\*(Aq)\*(Aq) ;
\&  ...
\&  $ss\->Write(\*(Aqsomefile.pl\*(Aq) ; # serializes the formula and "MyPackageName" module name in the file.
.Ve
.PP
The saved file will now \*(L"use\*(R" MyPackageName automaticaly when you read the file.
.PP
\&\fBPlease contribute your functions to Spreadsheet::Perl\fR.
.SS "Misc spreadsheet functions"
.IX Subsection "Misc spreadsheet functions"
.IP "\(bu" 2
SetName, sets the name of the spreadsheet object
.IP "\(bu" 2
GetName, returns the name of the spreadsheet object
.IP "\(bu" 2
GetCellList, returns the list of the defined cells
.IP "\(bu" 2
GetLastIndexes, returns the last column and the last row used
.IP "\(bu" 2
GetCellsToUpdate, returns the list of the cells needing update
.SH "SETTING AND READING CELLS"
.IX Header "SETTING AND READING CELLS"
Cells have one value and attributes. Cells values are perl scalars, anything you can assign to a perl scalar can be assigned
to a cell value (see bellow for the one exception). Attributes have different format and are handled by the spreadsheet.
.SS "Setting a value"
.IX Subsection "Setting a value"
Anything that can be assigned to a perl variable can be assigned to a cell with the exception of object rooted in
\&\*(L"Spreadsheet::Perl\*(R" which are reserved and carry a special meaning.
.PP
.Vb 6
\&  $ss{A1} = 458_627 ;
\&  $ss{A1} = undef ;
\&  $ss{A1} = \*(Aq\*(Aq ;
\&  $ss{A1} = function_call() ; # assign the value returned from the call
\&  $ss{A1} = \e&Function ;
\&  $ss{A1} = \e@_ ;
\&  
\&  $ss{A1} = $object_within_spreadsheet_perl_hierarchy ; # this is valid but may (and will) carry a special meaning.
\&
\&  $ss\->Set(\*(AqA1\*(Aq, "some value\*(Aq) ; # OO style
.Ve
.SS "locking"
.IX Subsection "locking"
Cell locking is done through the \fILockRange\fR function:
.PP
.Vb 1
\&  $ss\->LockRange(\*(AqA1\*(Aq) ;
.Ve
.PP
Finding out the lock state of a cell:
.PP
.Vb 1
\&  $cell_is_locked = $ss\->IsCellLocked(\*(AqA1\*(Aq) ;
.Ve
.SS "Formulas"
.IX Subsection "Formulas"
\fIcell dependencies\fR
.IX Subsection "cell dependencies"
.PP
Cell dependencies are automatically handled by Spreadsheet::Perl. If a dependency is changed,
the formula will be re-evaluated next time the cell, containing the formula, is accessed.
.PP
\fIcircular dependencies\fR
.IX Subsection "circular dependencies"
.PP
If circular dependencies between cells exist, Spreadsheet::Perl will generate a dump of the cycle as well
as a perl stack dump to help you debug your formulas. The following formulas:
.PP
.Vb 3
\&  $ss{\*(AqA1:A5\*(Aq} = PerlFormula(\*(Aq$ss{"A2"}\*(Aq) ; #automatic address offsetting
\&  $ss{A6} = PerlFormula(\*(Aq$ss{A1}\*(Aq) ;
\&  print "$ss{A1}\en" ;
.Ve
.PP
generate:
.PP
.Vb 11
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Spreadsheet::Perl=HASH(0x813d234) \*(AqTEST\*(Aq Dependent stack:
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  TEST!A1 : $ss\->Get("A2")[main] cyclic_error.pl:18
\&  TEST!A2 : $ss\->Get("A3")[main] cyclic_error.pl:18
\&  TEST!A3 : $ss\->Get("A4")[main] cyclic_error.pl:18
\&  TEST!A4 : $ss\->Get("A5")[main] cyclic_error.pl:18
\&  TEST!A5 : $ss\->Get("A6")[main] cyclic_error.pl:18
\&  TEST!A6 : $ss\->Get("A1")[main] cyclic_error.pl:19
\&  TEST!A1 : $ss\->Get("A2")[main] cyclic_error.pl:18
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  
\&  At cell \*(AqTEST!A6\*(Aq formula: $ss\->Get("A1") defined at \*(Aqmain cyclic_error.pl 19\*(Aq:
\&        Found cyclic dependencies! at /usr/local/lib/perl5/site_perl/5.8.0/Spreadsheet/Perl.pm line 242.
\&  #ERROR
.Ve
.PP
\fIsetting a formula\fR
.IX Subsection "setting a formula"
.PP
Formulas can be written in different formats. The native format is perl code. There seems
to be a consensus about what standard format the formulas should use, I call that format \*(L"common format\*(R".
.PP
Native format
.IX Subsection "Native format"
.PP
\&\fBPerlFormula\fR and \fB\s-1PF\s0\fR take a string as argument. The string must be a valid Perl code.
.PP
\&\fBPerlFormula\fR can be used as a member function and define multiple formulas in one call
.PP
.Vb 6
\&  $ss\->PerlFormula
\&        (
\&          \*(AqB1\*(Aq    => \*(Aq$ss{A1} + $ss{A2}\*(Aq
\&        , \*(AqB2\*(Aq    => \*(Aq$ss{A4} + $ss{A3}\*(Aq
\&        , \*(AqB3:B5\*(Aq => \*(Aq$ss{A4} + $ss{A3}\*(Aq
\&        ) ;
.Ve
.PP
or it can used to set a cell or a cell range formula.
.PP
.Vb 1
\&  $ss{\*(AqA1:A5\*(Aq} = PerlFormula(\*(Aq$ss{"A2"}\*(Aq) ;
\&
\&  $ss{\*(AqA1\*(Aq} = PerlFormula(\*(AqANY VALID PERL CODE\*(Aq) ;
.Ve
.PP
When used with a cell or a cell range, extra user data can be passed
.PP
.Vb 1
\&  $ss{\*(AqA1\*(Aq} = PF(\*(AqPERL CODE\*(Aq, \e$user_data, $more_user_date, 42, "something") ;
.Ve
.PP
The formulas can also be part of the Spreadsheet dump
.PP
.Vb 2
\&  $ss\->{DEBUG}{INLINE_INFORMATION}++ ; # show the formulas in the table dump
\&  print $ss\->DumpTable() ;:
.Ve
.PP
The following variables are available in the formula:
.IP "\(bu" 2
\&\f(CW$ss\fR, a spreadsheet object reference
.IP "\(bu" 2
\&\f(CW%ss\fR, a hash tied to the spreadsheet object
.IP "\(bu" 2
\&\f(CW$cell\fR, the address of the cell for which the formula is evaluated
.IP "\(bu" 2
\&\f(CW@formula_arguments\fR, extra user data passed to \s-1\fBPF\s0()\fR in cell mode
.PP
If a range is assigned a formula, the cell addresses within the formulas are automatically offseted, fixed
address element can be protected by square brackets.
.PP
.Vb 2
\&  # formula 1
\&  $ss{\*(AqC1:C2\*(Aq} = PerlFormula(\*(Aq$ss\->Sum("A1:A2")\*(Aq) ;
\&  
\&  Formula definition (anchor\*(AqC1:C2\*(Aq @ cell \*(AqC1\*(Aq): $ss\->Sum("A1:A2")
\&  generated formula => $ss\->Sum("A1:A2")
\&  
\&  Formula definition (anchor\*(AqC1:C2\*(Aq @ cell \*(AqC2\*(Aq): $ss\->Sum("A1:A2")
\&  generated formula  => $ss\->Sum("A2:A3")
\&  
\&  # formula 2
\&  $ss{\*(AqD1:E2\*(Aq} = PerlFormula(\*(Aq$ss\->Sum("[A]1:A[3]")\*(Aq) ;
\&  
\&  Formula definition (anchor\*(AqD1:E2\*(Aq @ cell \*(AqD1\*(Aq): $ss\->Sum("[A]1:A[3]")
\&  generated formula => $ss\->Sum("A1:A3")
\&  
\&  Formula definition (anchor\*(AqD1:E2\*(Aq @ cell \*(AqD2\*(Aq): $ss\->Sum("[A]1:A[3]")
\&  generated formula => $ss\->Sum("A2:A3")
\&  
\&  Formula definition (anchor\*(AqD1:E2\*(Aq @ cell \*(AqE1\*(Aq): $ss\->Sum("[A]1:A[3]")
\&  generated formula => $ss\->Sum("A1:B3")
\&  
\&  Formula definition (anchor\*(AqD1:E2\*(Aq @ cell \*(AqE2\*(Aq): $ss\->Sum("[A]1:A[3]")
\&  generated formula => $ss\->Sum("A2:B3")
.Ve
.PP
common format
.IX Subsection "common format"
.PP
This is the format accepted by excel and gnumeric. I will _not_ implement that format because:
.PP
.Vb 1
\&  =SUM(IF(A2:A20=A2,IF(B2:B20=38,1,0)))
.Ve
.PP
is about the ugliest a formula language can get. Is all this user friendly syntax only because
someone thought it was too difficult to present a mutiline editor to the end user?
.PP
If Someone feels that the common format (or any other language) is more \*(L"appropriate\*(R" than Perl and 
contributes a translator, I'll be happy to add it to the distribution.
.PP
Steffen MÃ¼ller (author of Math::Symbolic) was nice enough to contribute a translator for the 0.07 release. This doesn't make 
Spreadsheet::Perl compatible with Gnumeric but goes a long way towards that goal.
.PP
.Vb 8
\&  $ss\->Formula
\&        (
\&          B1      => \*(Aqcos(A1 + A2)\*(Aq
\&        , B2      => \*(AqA4 + A3\*(Aq
\&        , \*(AqB3:B5\*(Aq => \*(Aqlog(A4) + A3\*(Aq
\&        , \*(AqB6:b7\*(Aq => \*(AqSum(A4:A5) + Sum(A3)\*(Aq
\&        , B8      => \*(Aqlog(Sum(A4:A5)) + log(A3)\*(Aq
\&        ) ;
.Ve
.PP
Examples of translation:
.PP
.Vb 1
\&  SSHEET!A1:BB15 => $ss{\*(AqSSHEET!A1:BB15\*(Aq}
\&
\&  SSHEET!A1 => $ss{\*(AqSSHEET!A1\*(Aq}
\&
\&  2*Sum(SSHEET!A1:AD4)+log(A5) => ((2 * $ss\->Sum(\*(AqSSHEET!A1:AD4\*(Aq)) + log($ss{\*(AqA5\*(Aq}))
\&
\&  Function(Sum(SSHEET!A1:B1)^cos(Sum(SSHEET!NAMEDRANGE))) =>
\&  $ss\->Function(($ss\->Sum(\*(AqSSHEET!A1:B1\*(Aq) ** cos($ss\->Sum(\*(AqSSHEET!NAMEDRANGE\*(Aq))))
.Ve
.PP
Note that some functions are translated as class functions ('Sum' in the example above) and other as global functions
('log' in the example above). Spreadsheet::Perl doesn't define any global functions (this will certainly change when I 
have time to go through this). The funtions bellow let manipulate the global functions. Spreadsheet::Perl will re-compile the
translator as needed.
.IP "\(bu" 2
SetBuiltin. Sets the list of the declared functions.
.Sp
.Vb 1
\&  SetBuiltin qw( atan ) ; # only \*(Aqatan\*(Aq is available now
.Ve
.IP "\(bu" 2
AddBuiltin, adds one or more functions to the global functions declarations.
.Sp
.Vb 1
\&  AddBuiltin qw( log sin cos ) ;
.Ve
.IP "\(bu" 2
GetBuiltin, Returns the list of the declared functions.
.Sp
.Vb 1
\&  my @declared_builtin = GetBuiltin() ;
.Ve
.PP
Common format formulas come at a cost. To translate the formula, Parse::Recdescent must be loaded 
(that times at 0.25s on my 700 MHz box), the grammar must be compiled and the formulas translated.
This can amout to seconds when compared to pure perl formulas. Nevertheless, this is very good to experiment 
with. If needed, the parser can be tinkered with or re-written in C. Once the formulas are translated, you get
the same speed as the perl format formulas.
.PP
\fIRangeValues\fR
.IX Subsection "RangeValues"
.PP
There are different way to assign values to a range.
.PP
.Vb 3
\&  $ss{\*(AqA1:A5\*(Aq} = 5 ; # all the cells within the range have "5" as value.
\&  @ss{\*(AqA1\*(Aq, \*(AqA2\*(Aq, \*(AqA3\*(Aq, \*(AqA4\*(Aq, \*(AqA5\*(Aq} = (10 .. 15) ; # perl slice notation 
\&  $ss{\*(AqA1:A5\*(Aq} = RangeValues(10 .. 15) ;
\&  
\&  $ss{\*(AqA1:A5\*(Aq} = RangeValuesSub(\emy_sub, $argument_1, $argument_2) ;
.Ve
.PP
\fIRangeValuesSub\fR
.IX Subsection "RangeValuesSub"
.PP
\&\fBRangeValuesSub\fR is passed the following arguments:
.IP "1 \- a sub reference" 2
.IX Item "1 - a sub reference"
.PD 0
.IP "2 \- an optional list of arguments" 2
.IX Item "2 - an optional list of arguments"
.PD
.PP
The sub is called, multiple times, to fill the cell of ranges. It is passed these arguments:
.IP "1 \- a reference to the spreadsheet" 2
.IX Item "1 - a reference to the spreadsheet"
.PD 0
.IP "2 \- an anchor (the first cell of the range)" 2
.IX Item "2 - an anchor (the first cell of the range)"
.IP "3 \- the address of the cell to generate a value for" 2
.IX Item "3 - the address of the cell to generate a value for"
.IP "4 \- the optional list of arguments passed to RangeValuesSub" 2
.IX Item "4 - the optional list of arguments passed to RangeValuesSub"
.PD
.PP
\&\fIRangeValuesSub\fR can be used when the values are to be generated dynamically or could be used to create
\&'Auto\-fill' functionality.
.SS "Setting formats"
.IX Subsection "Setting formats"
the cell formats are hold within a hash, you can set as many different formats as you wish. Your format can be
a complex perl structure, \fBSpreadsheet::Perl\fR only handle the first level of the hash:
.PP
.Vb 3
\&  $ss{A1} = Format(ANSI => {HEADER => "blink"}) ;
\&  $ss{A1} = Format(ANSI => {HEADER => "red_on_black"}) ; # override previous
\&  $ss{A1} = Format(POD => {FOOTER => "B<>"}) ; # add this format to cell A1
.Ve
.PP
The format data must be passed as a perl hash reference.
.SS "Setting Validators"
.IX Subsection "Setting Validators"
a Validator is defined in this way:
.PP
.Vb 1
\&  $ss{\*(AqA1:A2\*(Aq} = Validator(\*(Aqonly letters\*(Aq, \e&OnlyLetters) ;
.Ve
.PP
\&\fIValidator\fR, removes all previously set validators and sets the validator passed as argument.
\&\fIValidator\fR takes these arguments:
.IP "1 \- a name" 2
.IX Item "1 - a name"
.PD 0
.IP "2 \- a sub reference" 2
.IX Item "2 - a sub reference"
.IP "3 \- an optional list of arguments" 2
.IX Item "3 - an optional list of arguments"
.PD
.PP
A cell can have multiple validators. use \fIValidatorAdd\fR to append new validators.
.PP
Validators are passed the following arguments:
.IP "1 \- a reference to the spreadsheet" 2
.IX Item "1 - a reference to the spreadsheet"
.PD 0
.IP "2 \- the address of the cell to be set" 2
.IX Item "2 - the address of the cell to be set"
.IP "3 \- a reference to the cell to be set" 2
.IX Item "3 - a reference to the cell to be set"
.IP "4 \- the optional list of arguments passed to \fIValidator[Add]\fR" 2
.IX Item "4 - the optional list of arguments passed to Validator[Add]"
.PD
.PP
The value is set if all the cell validators return true. \fBSpreadsheet::Perl\fR is silent, your validator has to
give the user feedback.
.SS "Setting User data"
.IX Subsection "Setting User data"
You can store private data into the cell. It is out of limits for \fBSpreadsheet::Perl\fR. the user data is stored in a hash.
.PP
.Vb 1
\&  $ss{A1} = UserData(NAME => \*(Aqprivate data\*(Aq, ARRAY => [\*(Aqhi\*(Aq]) ;
.Ve
.SS "Setting fetch and store callbacks"
.IX Subsection "Setting fetch and store callbacks"
You can map your own set of Fetch and Store data from/in  a cell. You will be working with the spreadsheet internals.
.PP
\fIFetch callback\fR
.IX Subsection "Fetch callback"
.PP
I recommend that you don't use this system to compute values depending on other cells; the dependency mechanism
will still work but it is better to use formula so it will still work when row/columns deleting/inserting is
implemented. This mechanism is still very useful when you need to access a value that changes between cell 
access and is not depending on other cells. The description field is displayed when generating a table and 
\&\f(CW$ss\fR\->{\s-1DEBUG\s0}{\s-1INLINE_INFORMATION\s0} is set, that can be of a great help when debugging your spreadsheet.
.PP
.Vb 1
\&  $ss{A1} = FetchFunction(\*(Aqsome description\*(Aq, \e&MySub) ;
.Ve
.PP
\&\fBFetchFunction\fR takes these arguments
.IP "1 \- a description string" 2
.IX Item "1 - a description string"
.PD 0
.IP "2 \- a sub reference" 2
.IX Item "2 - a sub reference"
.IP "3 \- an optional list of arguments" 2
.IX Item "3 - an optional list of arguments"
.PD
.PP
The following arguments are passed to the fetch callback
.IP "1 \- a reference to the spreadsheet" 2
.IX Item "1 - a reference to the spreadsheet"
.PD 0
.IP "2 \- the address of the cell" 2
.IX Item "2 - the address of the cell"
.IP "3 \- the optional list of arguments passed to FetchFunction" 2
.IX Item "3 - the optional list of arguments passed to FetchFunction"
.PD
.PP
Caching (volatile cells)
.IX Subsection "Caching (volatile cells)"
.PP
\&\fBSpreadsheet::Perl\fR caches cell values (and updates them when a dependency has changed). If you want a cell to return a 
different value every time it is accessed (when using \s-1AUTOCALC\s0 = 0 and Recalculate for example), you need to turn caching
off for that cell.
.PP
.Vb 1
\&  ${A1} = NoCache() ;
.Ve
.PP
\fIStore callback\fR
.IX Subsection "Store callback"
.PP
You can also attach a 'store' sub to a cell. whenever the cell is assigned a value, your sub will be called.
.PP
.Vb 1
\&  $ss{\*(AqA1:A5\*(Aq} = StoreFunction(\*(Aqdescription\*(Aq, \e&StorePlus, 5) ;
.Ve
.PP
\&\fBStoreFunction\fR takes the following arguments:
.IP "1 \- a description string" 2
.IX Item "1 - a description string"
.PD 0
.IP "2 \- a sub reference" 2
.IX Item "2 - a sub reference"
.IP "3 \- an optional list of arguments to be passed when the callback is, well, called." 2
.IX Item "3 - an optional list of arguments to be passed when the callback is, well, called."
.PD
.PP
The callback is called with these arguments
.IP "1 \- a spreadsheet object reference" 2
.IX Item "1 - a spreadsheet object reference"
.PD 0
.IP "2 \- the address of the cell to set" 2
.IX Item "2 - the address of the cell to set"
.IP "3 \- the value to store" 2
.IX Item "3 - the value to store"
.IP "4 \- the, optional, arguments passed to StoreFunction" 2
.IX Item "4 - the, optional, arguments passed to StoreFunction"
.PD
.PP
Your store callback must store the data directly in the spreadsheet data structure without calling the Store/Set functions.
You can find a typical implementation in the examples.
.PP
\fIDelete callback\fR
.IX Subsection "Delete callback"
.PP
You can also attach a 'delete' sub to a cell. Your sub will be called when the cell is deleted.
.PP
.Vb 1
\&  $ss{\*(AqA1:A5\*(Aq} = DeleteFunction(\*(Aqdescription\*(Aq, \e&DeleteCallback, 1, 2, 3) ;
.Ve
.PP
\&\fBStoreFunction\fR takes the following arguments:
.IP "1 \- a description string" 2
.IX Item "1 - a description string"
.PD 0
.IP "2 \- a sub reference" 2
.IX Item "2 - a sub reference"
.IP "3 \- an optional list of arguments to be passed when the callback is, well, called." 2
.IX Item "3 - an optional list of arguments to be passed when the callback is, well, called."
.PD
.PP
The callback is called with these arguments
.IP "1 \- a spreadsheet object reference" 2
.IX Item "1 - a spreadsheet object reference"
.PD 0
.IP "2 \- the address of the cell to set" 2
.IX Item "2 - the address of the cell to set"
.IP "3 \- the, optional, arguments passed to StoreFunction" 2
.IX Item "3 - the, optional, arguments passed to StoreFunction"
.PD
.SS "Perl scalar mapping"
.IX Subsection "Perl scalar mapping"
Few problems fit the two dimensional mapping spreadsheets use. For a given project, you may already have data structure 
that you want to perform calculation on (thought spreadsheet). Mapping from the domain structure and back is time consuming,
error prone and borring. Even if that process cannot be eliminated, \fBSpreadsheet::Perl\fR can do half the job. Here is a simple example:
.PP
.Vb 1
\&  my $variable = 25 ;
\&  
\&  $ss{A1} = Ref(\*(Aqdescription\*(Aq, \e$variable) ;
\&  $ss{A2} = PerlFormula(\*(Aq$ss{A1}\*(Aq) ;
\&  
\&  print "$ss{A1} $ss{A2}\en" ; # fetch the data from the scalar variable
\&  
\&  $ss{A1} = 52 ; # set the scalar
\&    
\&  print "\e$variable = $variable\en" ;
.Ve
.PP
\&\fBRef\fR can be called as attribute creator (as above) or as a spreadsheet member (as bellow).
.PP
.Vb 7
\&  $ss\->Ref
\&        (
\&        \*(Aqdescription\*(Aq,
\&        \*(AqA1\*(Aq      => \e($struct\->{something}), 
\&        \*(AqA2\*(Aq      => \e$variable,
\&        \*(AqA3:A5\*(Aq => \e$variable
\&        ) ;
.Ve
.PP
\&\f(CW$ss\fR\->get_reference_description('A1') or \f(CW$ss\fR\->\s-1REF_INFO\s0('A1') can be used to retrieve the description field of cell, eg, A1.
.PP
A more complex example (based on examples/ref2.pl) which also show the usage of debug flags
.PP
.Vb 2
\&        use strict ;
\&        use warnings ;
\&
\&        use Data::TreeDumper ;
\&        use Spreadsheet::Perl ;
\&
\&        my $ss = tie my %ss, "Spreadsheet::Perl", NAME => \*(AqTEST\*(Aq ;
\&
\&        # set some debugging flags so we can see what is happening in the spreadsheet
\&
\&        # show when a value is fetched from one of the following cells
\&        # we could also have used "$ss\->{DEBUG}{FETCH}++; " but it doesn\*(Aqt show the details of the fetch operation
\&        $ss\->{DEBUG}{FETCH_TRIGGER}{A1}++ ;
\&        $ss\->{DEBUG}{FETCH_TRIGGER}{A2}++ ;
\&        $ss\->{DEBUG}{FETCH_TRIGGER}{A3}++ ;
\&
\&        # show which formulas are applied
\&        $ss\->{DEBUG}{FETCH_SUB}++ ;
\&        
\&
\&        # show when something is stored in a cell, tht can be a value, a formula, ...
\&        $ss\->{DEBUG}{STORE}++;
\&
\&        # show when dependencies are marked for recalculation
\&        $ss\->{DEBUG}{MARK_ALL_DEPENDENT}++ ;
\&         
\&        # plain perl variables
\&        my $variable = 25 ;
\&        my $variable_2 = 30 ;
\&        my $struct = {result => \*(Aqhello world\*(Aq} ;
\&
\&        # make cells refer to perl scalars. Note that this is a two way relationship
\&        $ss\->Ref
\&                (
\&                \*(AqRef and formulas\*(Aq,
\&                \*(AqA1\*(Aq => \e$variable,
\&                \*(AqA2\*(Aq => \e$variable_2,
\&                \*(AqA3\*(Aq => \e$struct\->{result},
\&                ) ;
\&
\&        # set formulas over the perl scalars.
\&        
\&        $ss\->PerlFormula
\&                (
\&                \*(AqA2\*(Aq => \*(Aq$ss{A1} * 2\*(Aq,  
\&                \*(AqA3\*(Aq => \*(Aq$ss{A2} * 2\*(Aq,  
\&                ) ;
\&
\&        # fetch the values, running the formulas as necessary
\&        print "$ss{A1} $ss{A2} $ss{A3}\en" ;
\&
\&        # fetch the values, running the formulas as necessary, here some results will be cached
\&        print "$ss{A1} $ss{A2} $ss{A3}\en" ;
\&
\&        # show the values of the perl scalars
\&        print DumpTree 
\&                {
\&                \*(Aq$variable\*(Aq => $variable,
\&                \*(Aq$variable_2\*(Aq => $variable_2,
\&                \*(Aq$struct\*(Aq=> $struct,
\&                }, \*(Aqscalars:\*(Aq ;
\&
\&        # set a cell and the perl scalar underneath 
\&        $ss{A1} = 10 ;
\&
\&        # fetch the values, running the formulas as necessary
\&        print "$ss{A1} $ss{A2} $ss{A3}\en" ;
\&
\&        # show the values of the perl scalars
\&        print DumpTree 
\&                {
\&                \*(Aq$variable\*(Aq => $variable,
\&                \*(Aq$variable_2\*(Aq => $variable_2,
\&                \*(Aq$struct\*(Aq=> $struct,
\&                }, \*(Aqscalars:\*(Aq ;
.Ve
.PP
The output is the following (comments are added as an explanation):
.PP
.Vb 4
\&        # make cells refer to perl scalars. (arguments are passed in a hash thus the order)
\&        Storing To \*(AqA3\*(Aq
\&        Storing To \*(AqA1\*(Aq
\&        Storing To \*(AqA2\*(Aq
\&        
\&        # set formulas over the perl scalars.
\&        Storing To \*(AqA3\*(Aq
\&        Storing To \*(AqA2\*(Aq
\&        
\&        # fetch the values, running the formulas as necessary
\&        # this is the result of the first: print "$ss{A1} $ss{A2} $ss{A3}\en" ;
\&        
\&        # A1, the value comes from the scalar
\&        Fetching cell \*(AqA1\*(Aq.
\&          => Fetching cell \*(AqA1\*(Aq value from scalar reference.
\&          
\&        # A2, the value comes from the formula
\&        Fetching cell \*(AqA2\*(Aq.
\&          => Cell \*(AqA2\*(Aq value from scalar reference shadowed by formula.
\&          
\&        # run the formula, note that the formula is also displayed in the dump
\&        Running Sub @ \*(AqTEST!A2\*(Aq formula: $ss{A1} * 2
\&        # fetch the A1 cell refered to in the formula
\&        Fetching cell \*(AqA1\*(Aq.
\&          => Fetching cell \*(AqA1\*(Aq value from scalar reference.
\&          
\&        # A3, identic to A2  
\&        Fetching cell \*(AqA3\*(Aq.
\&          => Cell \*(AqA3\*(Aq value from scalar reference shadowed by formula.
\&        Running Sub @ \*(AqTEST!A3\*(Aq formula: $ss{A2} * 2
\&        Fetching cell \*(AqA2\*(Aq.
\&        
\&        # the result of the first print
\&        25 50 100
\&        
\&        
\&        # fetch the values, running the formulas as necessary, here some results are cached
\&        # this is the result of the second: print "$ss{A1} $ss{A2} $ss{A3}\en" ;"
\&        
\&        # fetched from the perl scalar
\&        Fetching cell \*(AqA1\*(Aq.
\&          => Fetching cell \*(AqA1\*(Aq value from scalar reference.
\&          
\&        # A2 and A3 are fetched from the spreadsheet, since they are cached,
\&        # there is no need to run the formulas again
\&        Fetching cell \*(AqA2\*(Aq.
\&        Fetching cell \*(AqA3\*(Aq.
\&        
\&        # the result of the second print
\&        25 50 100
\&        
\&        # show the values of the perl scalars
\&        scalars:
\&        +\- $struct  [H1]
\&        |  +\- result = 100  [S2]
\&        +\- $variable = 25  [S3]
\&        +\- $variable_2 = 50  [S4]
\&        
\&        # set a cell and the perl scalar underneath 
\&        # the cells that have dependencies on A1 are marked for recalculation
\&        Storing To \*(AqA1\*(Aq
\&           \*(AqA2\*(Aq needs update
\&              \*(AqA3\*(Aq needs update
\&              
\&              
\&        # fetch the values, running the formulas as necessary      
\&        Fetching cell \*(AqA1\*(Aq.
\&          => Fetching cell \*(AqA1\*(Aq value from scalar reference.
\&        Fetching cell \*(AqA2\*(Aq.
\&        Running Sub @ \*(AqTEST!A2\*(Aq formula: $ss{A1} * 2
\&        Fetching cell \*(AqA1\*(Aq.
\&          => Fetching cell \*(AqA1\*(Aq value from scalar reference.
\&        Fetching cell \*(AqA3\*(Aq.
\&        Running Sub @ \*(AqTEST!A3\*(Aq formula: $ss{A2} * 2
\&        Fetching cell \*(AqA2\*(Aq.
\&        10 20 40
\&        
\&        # show the values of the perl scalars
\&        scalars:
\&        +\- $struct  [H1]
\&        |  +\- result = 40  [S2]
\&        +\- $variable = 10  [S3]
\&        +\- $variable_2 = 20  [S4]
.Ve
.PP
Note that \fBRef\fR accepts reference to scalars only.
.PP
\fIRemoving the mapping\fR
.IX Subsection "Removing the mapping"
.PP
Simply delete the cell:
.PP
.Vb 1
\&  delete ${A1} ;
.Ve
.SS "Store on fetch"
.IX Subsection "Store on fetch"
You can direct Spreadsheet::Perl to call the 'store callback' of a cell everytime the cell is fetched. What is this good for?
Here is an example:
.PP
.Vb 1
\&  $ss{A3} = PF(\*(Aq$ss{A1} + $ss{A2}\*(Aq) ;
\&  
\&  $ss{A3} = StoreOnFetch() ; # set the store on fetch attribute for this cell
\&  
\&  $ss{A3} = StoreFunction(\*(Aqformula to db\*(Aq, \e&MyStoreCallback) ;
\&  
\&  $ss{\*(AqA1:A2\*(Aq} = 10 ;
\&  $ss\->Recalculate() ;
.Ve
.PP
This lets you calculate the value of a cell through a formula and store that value wherever you wish to. For example a database,
a perl scalar or even mail the value.
.SS "Reading values"
.IX Subsection "Reading values"
Use the normal perl assignment:
.PP
.Vb 1
\&  my $value = $ss{A1} ;
.Ve
.PP
You can read multiple values using slices:
.PP
my ($value1, \f(CW$value2\fR) = \f(CW@ss\fR{'A1', 'A2'} ;
.PP
\fIReading range values\fR
.IX Subsection "Reading range values"
.PP
I you want to read all the values contained in a range, use the following syntax:
.PP
.Vb 1
\&  my $values = $ss{\*(AqA1:A10\*(Aq} ;
.Ve
.PP
An array reference is returned. It contains the values ordered by rows first then by columns.
.PP
\fICopying cell values from a spreadsheet to another spreadsheet or to another hash\fR
.IX Subsection "Copying cell values from a spreadsheet to another spreadsheet or to another hash"
.PP
Use Perl hash slices:
.PP
.Vb 2
\&  tie my %spreadsheet, "Spreadsheet::Perl" ;
\&  my $spreadsheet = tied %$spreadsheet ;
\&  
\&  my @cells = qw(A1 B6 C4) ;
\&  
\&  @spreadsheet{@cells} = qw( first second third ) ;
\&  
\&  my %copy_hash ;
\&  @copy_hash{@cells} =  @spreadsheet{@cells} ;
\&  
\&  print DumpTree(\e%copy_hash, \*(AqCopyHash:\*(Aq) ;
.Ve
.SS "Reading attributes"
.IX Subsection "Reading attributes"
Cell attributes are handled internally by \fBSpreadsheet::Perl\fR, some of those attributes need to be synchronized or influence
the way \fBSpreadsheet::Perl\fR handles the cell. You still get the attributes through an extended address. This is easier 
explained with an example:
.PP
.Vb 2
\&  $ss{A1} = UserData(FIRST => 1, SECOND => 2) ; # stored in a hash
\&  $user_data_hash = $ss{A1.USER_DATA} ;
.Ve
.PP
The attributes you can use are:
.IP "\(bu" 2
\&\s-1FORMAT\s0
.IP "\(bu" 2
\&\s-1USER_DATA\s0
.SH "OUTPUT"
.IX Header "OUTPUT"
.SS "\s-1HTML\s0"
.IX Subsection "HTML"
As of version 0.04, there is a simple way to generate \s-1HTML\s0 tables. It uses the \fBData::Table\fR module. This is an 
interim solution and it is limited but it might just do what you want.
.PP
.Vb 3
\&  ...
\&  print $ss\->GenerateHtml() ;
\&  $ss\->GenerateHtmlToFile(\*(Aqoutput_file_name.html\*(Aq) ;
.Ve
.PP
See \*(L"Dumping a table\*(R".
.SH "DEBUGGING"
.IX Header "DEBUGGING"
.SS "Dump"
.IX Subsection "Dump"
The \fIDump\fR function, err, dumps the spreadsheet. It takes the following arguments:
.IP "\(bu" 2
an address list withing an array reference or undef. ex: ['A1', 'B5:B8']
.IP "\(bu" 2
a boolean. When set, the spreadsheet attributes are displayed
.IP "\(bu" 2
an optional hash reference passed as overrides to \fBData::TreeDumper\fR
.Sp
It returns a string containing the dump.
.SS "Debug handle"
.IX Subsection "Debug handle"
All debug output is done through the handle set in \f(CW$ss\fR{\s-1DEBUG\s0}{\s-1ERROR_HANDLE\s0}. It is set to \s-1STDERR\s0 but could 
be set to a file or other logging facilities.
.PP
The handle can be used from withing formulas if necessary:
.PP
.Vb 6
\&  $ss{A9} = PerlFormula
\&                (\*(Aq
\&                my $dh = $ss\->{DEBUG}{ERROR_HANDLE} ;
\&                print $dh "Doing something\en" ;
\&                $ss\->Sum("A1:A7", "A8") ;
\&                \*(Aq) ;
.Ve
.SS "Debug flags"
.IX Subsection "Debug flags"
\fI\f(CI$ss\fI\->{\s-1DEBUG\s0}\fR
.IX Subsection "$ss->{DEBUG}"
.PP
I don't removes the flags I create while developing \fBSpreadsheet::Perl\fR if I think it can be useful to the user (that's me at least).
The following flags exist:
.PP
.Vb 3
\&  $ss\->{DEBUG}{SUB}++ ; # show whenever a value has to be calculated
\&  $ss\->{DEBUG}{FETCHED}++ ; # counts how many times the cell is fetched
\&  $ss\->{DEBUG}{STORED}++ ; # counts how many times the cell is stored
\&  
\&  $ss\->{DEBUG}{PRINT_FORMULA}++ ; # show the info about formula generation
\&  $ss\->{DEBUG}{PRINT_FORMULA_EVAL_STATUS}++ ; # show the info about formula execution
\&  $ss\->{DEBUG}{INLINE_INFORMATION}++ ; # inline cell information in the table dump
\&  $ss\->{DEBUG}{PRINT_ORIGINAL_FORMULA}++ ; # inline original formula in the table dump
\&  $ss\->{DEBUG}{PRINT_FORMULA_ERROR}++ ; # inline the error generated by the formula evaluation
\&  $ss\->{DEBUG}{PRINT_DEPENDENT_LIST}++ # inline the list of dependents in the table dump
\&  $ss\->{DEBUG}{PRINT_CYCLIC_DEPENDENCY})++ # inline dependency cyles in the table dump
\&
\&  $ss\->{DEBUG}{DEFINED_AT}++ ; # show where the cell has been defined
\&  $ss\->{DEBUG}{ADDRESS_LIST}++ ; # shows the generated address lists
\&  $ss\->{DEBUG}{FETCH_FROM_OTHER}++ ; # show when an inter spreadsheet value is fetched
\&  $ss\->{DEBUG}{DEPENDENT_STACK_ALL}++ ; # show the dependent stack every time a value is fetched
\&  $ss\->{DEBUG}{DEPENDENT_STACK}{A1}++ ; # show the dependent stack every time the cell is fetched
\&  $ss\->{DEBUG}{DEPENDENT}++ ; # store information about dependent and show them in dump
\&  $ss\->{DEBUG}{MARK_ALL_DEPENDENT}++; # shows when any dependent cell is marked as needing an update
\&  $ss\->{DEBUG}{MARK_DEPENDENT}{$cell_name} # shows when dependent cell \*(Aq$cell_name\*(Aq is marked as needing an update 
\&  $ss\->{DEBUG}{VALIDATOR}++ ; # display calls to all validators in spreadsheet
\&  
\&  $ss\->{DEBUG}{FETCH}++ ; # shows when a cell value is fetched
\&  $self\->{DEBUG}{FETCH_VALUE}++ ; # shows which value is fetched
\&
\&  $ss\->{DEBUG}{STORE}++ ; # shows when a cell value is stored
\&  $ss\->{DEBUG}{RECORD_STORE_ALL}++ # keep all call stacks for all the STORE
\&  $ss\->{DEBUG}{RECORD_STORE}{A1}++ # keep all call stacks for A1
\&  # RECORD_STORE_ALL and RECORD_STORE are memory hoags! And generate gigantic dumps but are great debugging help
\&  # RECORD_STORE does not have to be set through out your application, it canbe set and unset as you wish
\&  # remember that you can pass addresses and ranges to Dump().
\&  # print $ss\->Dump([\*(AqA1\*(Aq, \*(AqB0\*(Aq]) ;#
\&  
\&  $iss\->{DEBUG}{FETCH_TRIGGER}{\*(AqA1\*(Aq}++ ; # displays a message when \*(AqA1\*(Aq is fetched
\&  $ss\->{DEBUG}{FETCH_TRIGGER}{\*(AqA1\*(Aq} = sub {my ($ss, $address) = @_} ; # calls the sub when \*(AqA1\*(Aq is fetched
\&  $ss\->{DEBUG}{FETCH_TRIGGER_HANDLER} = sub {my ($ss, $address) = @_} ; # calls sub when any trigger is fetched and no specific sub exists
\&  $ss\->{DEBUG}{STORE_TRIGGER}{\*(AqA1\*(Aq}++ ; # displays a message when \*(AqA1\*(Aq is stored
\&  $ss\->{DEBUG}{STORE_TRIGGER}{\*(AqA1\*(Aq} = sub {my ($ss, $address) = @_} ; # calls the sub when \*(AqA1\*(Aq is stored
\&  $ss\->{DEBUG}{STORE_TRIGGER_HANDLER} = sub {my ($ss, $address, $value) = @_} ; # calls sub when any trigger is stored and no specific sub exists
.Ve
.PP
more will be added when the need arises.
.PP
\fI\f(CI$ss\fI\->{\s-1DEBUG_MODULE\s0}\fR
.IX Subsection "$ss->{DEBUG_MODULE}"
.PP
This flag 'family' is reserved for modules that are not part of the distribution. The 'Arithmetic.pm' module
(which is a part of the distribution at version 0.04 will be made available as a separate package) includes these lines:
.PP
.Vb 4
\&  if(exists $ss\->{DEBUG_MODULE}{ARITHMETIC_SUM})
\&          {
\&          print $ss\->{DEBUG}{ERROR_HANDLE} "Sum: $current_address => $cell_value\en" ;
\&          }
.Ve
.SH "TODO"
.IX Header "TODO"
There is still a lot to do (the basics are there) and I have the feeling I will not get the time needed.
If someone is willing to help or take over, I'll be glad to step aside.
.PP
Here are some of the things that I find missing, this doesn't mean all are good ideas:
.IP "\(bu" 2
more tests, automatic tests. Test on Win32 platform.
.IP "\(bu" 2
perl debugger support
.IP "\(bu" 2
Row/column/spreadsheet default values.
.IP "\(bu" 2
R1C1 Referencing
.IP "\(bu" 2
database interface (a handful of functions at most)
.IP "\(bu" 2
Arithmetic functions (only Sum is implemented), statistic functions
.IP "\(bu" 2
printing, exporting
.IP "\(bu" 2
importing from other spreadsheets
.IP "\(bu" 2
Gnumeric/Excel formula syntax (common format is done)
.IP "\(bu" 2
complex stuff
.RS 2
.IP "\(bu" 4
Sorting
.RE
.RS 2
.RE
.IP "\(bu" 2
a complete \s-1GUI\s0 (Prima example exists)
.IP "\(bu" 2
a nice logo :\-)
.PP
Lots is available on \s-1CPAN,\s0 just some glue is needed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Khemir Nadim ibn Hamouda. <nadim@khemir.net>
.PP
.Vb 4
\&  Copyright (c) 2004 Nadim Ibn Hamouda el Khemir. All rights
\&  reserved.  This program is free software; you can redis\-
\&  tribute it and/or modify it under the same terms as Perl
\&  itself.
.Ve
.PP
If you find any value in this module or want to influence it's development, mail me!  All hints, tips, flames and wishes
are welcome at <nadim@khemir.net>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Spreadsheet::Engine
.PP
I, of course prefere my implementation that, \s-1IMHO,\s0 does much more; but Spreadsheet::Engine provides a lot of functions like
\&\s-1SQRT, TODAY, TRIM, ...\s0 Since Spreadsheet::Perl allows you to use perl as a cell formula language, there is little need for that.
.PP
If you need to load spreadsheet with \*(L"common format\*(R" formulas, Spreadsheet::Engine may be a goog alternative. Stealing all those
to add them to Spreadsheet::Perl has crossed my mind and it's not much work. Either send me a patch or ask and I may add them.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
\&\fBSpreadsheet::ConvertAA\fR.
.PP
\&\fBData::TreeDumper\fR.
.PP
\&\fBText::ASCIITable\fR.
.PP
Some examples need these:
.PP
\&\fBPrima\fR.
.PP
\&\fBData::Table\fR.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1203:" 4
.IX Item "Around line 1203:"
Non-ASCII character seen before =encoding in 'Â for'. Assuming \s-1CP1252\s0
.IP "Around line 1838:" 4
.IX Item "Around line 1838:"
Unknown directive: =head5
.IP "Around line 1854:" 4
.IX Item "Around line 1854:"
Unknown directive: =head5
