.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Util::Chinese 3"
.TH Text::Util::Chinese 3 "2020-06-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Util::Chinese \- A collection of subroutines for processing Chinese Text
.SH "DESCRIPTIONS"
.IX Header "DESCRIPTIONS"
The subroutines provided by this module are for processing Chinese text.
Conventionally, all input strings are assumed to be wide-characters.  No
`decode_utf8` or `utf8::decode` were done in this module. Users of this module
should deal with input-decoding first before passing values to these
subroutines.
.PP
Given the fact that corpus files are usually large, it may be a good idea to
avoid slurping the entire input stream. Conventionally, subroutines in this
modules accept \*(L"input iterator\*(R" as its way to receive a small piece of corpus
at a time. The \*(L"input iterator\*(R" is a CodeRef that returns a string every time
it is called, or undef if there are nothing more to be processed. Here's a
trivial example to open a file as an input iterator:
.PP
.Vb 9
\&    sub open_as_iterator {
\&        my ($path) = @_
\&        open my $fh, \*(Aq<\*(Aq, $path;
\&        return sub {
\&            my $line = <$fh>;
\&            return undef unless defined($line);
\&            return decode_utf8($line);
\&        }
\&    }
\&
\&    my $input_iter = open_as_iterator("/data/corpus.txt");
.Ve
.PP
This \f(CW$input_iter\fR can be then passed as arguments to different subroutines.
.PP
Although in the rest of this document, `Iter` is used as a Type
notation for iterators. It is the same as a \s-1CODE\s0 reference.
.SH "EXPORTED SUBROUTINES"
.IX Header "EXPORTED SUBROUTINES"
.ie n .IP "word_iterator( $input_iter ) #=> Iter" 4
.el .IP "word_iterator( \f(CW$input_iter\fR ) #=> Iter" 4
.IX Item "word_iterator( $input_iter ) #=> Iter"
This extracts words from Chinese text. A word in Chinese text is a token
with N charaters. These N characters is often used together in the input and
therefore should be a meaningful unit.
.Sp
The input parameter is a iterator \*(-- a subroutine that must return a string of
Chinese text each time it is invoked. Or, when the input is exhausted, it must
return undef. For example:
.Sp
.Vb 6
\&    open my $fh, \*(Aq<\*(Aq, \*(Aqbook.txt\*(Aq;
\&    my $word_iter = word_iterator(
\&        sub {
\&            my $x = <$fh>;
\&            return decode_utf8 $x;
\&        });
.Ve
.Sp
The type of return value is Iter (\s-1CODE\s0 ref).
.ie n .IP "extract_words( $input_iter ) #=> ArrayRef[Str]" 4
.el .IP "extract_words( \f(CW$input_iter\fR ) #=> ArrayRef[Str]" 4
.IX Item "extract_words( $input_iter ) #=> ArrayRef[Str]"
This does the same thing as \f(CW\*(C`word_iterator\*(C'\fR, but retruns the exhausted list instead of iterator.
.Sp
For example:
.Sp
.Vb 6
\&    open my $fh, \*(Aq<\*(Aq, \*(Aqbook.txt\*(Aq;
\&    my $words = extract_words(
\&        sub {
\&            my $x = <$fh>;
\&            return decode_utf8 $x;
\&        });
.Ve
.Sp
The type of return value is ArrayRef[Str].
.Sp
It is likely that this subroutine returns an empty ArrayRef with no contents.
It is only useful when the volume of input is a leats a few thousands of
characters. The more, the better.
.ie n .IP "presuf_iterator( $input_iter, $opts) #=> Iter" 4
.el .IP "presuf_iterator( \f(CW$input_iter\fR, \f(CW$opts\fR) #=> Iter" 4
.IX Item "presuf_iterator( $input_iter, $opts) #=> Iter"
This subroutine extract meaningful tokens that are prefix or suffix of
input.
.Sp
The 2nd argument \f(CW$opts\fR is a HashRef with parameters \f(CW\*(C`threshold\*(C'\fR
and \f(CW\*(C`lengths\*(C'\fR. \f(CW\*(C`threshold\*(C'\fR should be an Int, \f(CW\*(C`lengths\*(C'\fR should be an
ArrayRef[Int] and that constraints the lengths of prefixes and
suffixes to be extracted.
.Sp
The default value for \f(CW\*(C`threshold\*(C'\fR is 9, while the default value for \f(CW\*(C`lengths\*(C'\fR is \f(CW\*(C`[2,3]\*(C'\fR
.ie n .IP "extract_presuf( $input_iter, $opts ) #=> ArrayRef[Str]" 4
.el .IP "extract_presuf( \f(CW$input_iter\fR, \f(CW$opts\fR ) #=> ArrayRef[Str]" 4
.IX Item "extract_presuf( $input_iter, $opts ) #=> ArrayRef[Str]"
Similar to \f(CW\*(C`presuf_iterator\*(C'\fR, but returns a ArrayRef[Str] instead.
.ie n .IP "sentence_iterator( $input_iter ) #=> Iter" 4
.el .IP "sentence_iterator( \f(CW$input_iter\fR ) #=> Iter" 4
.IX Item "sentence_iterator( $input_iter ) #=> Iter"
This subroutine split input into sentences. It takes an text iterator,
and returns another one.
.ie n .IP "phrase_iterator( $input_iter ) #=> Iter" 4
.el .IP "phrase_iterator( \f(CW$input_iter\fR ) #=> Iter" 4
.IX Item "phrase_iterator( $input_iter ) #=> Iter"
This subroutine split input into smallelr phrases. It takes an text iterator,
and returns another one.
.ie n .IP "tokenize_by_script( $text ) #=> Array[ Str ]" 4
.el .IP "tokenize_by_script( \f(CW$text\fR ) #=> Array[ Str ]" 4
.IX Item "tokenize_by_script( $text ) #=> Array[ Str ]"
This subroutine split text into tokens, where each token is the same writing script.
.ie n .IP "looks_like_simplified_chinese( $text ) #=> Bool" 4
.el .IP "looks_like_simplified_chinese( \f(CW$text\fR ) #=> Bool" 4
.IX Item "looks_like_simplified_chinese( $text ) #=> Bool"
This subroutine does a naive test on the input \f(CW$text\fR and returns true if \f(CW$text\fR looks like it is written in Simplified Chinese.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kang-min Liu <gugod@gugod.org>
.SH "LICENSE"
.IX Header "LICENSE"
Unlicense <https://unlicense.org/>
