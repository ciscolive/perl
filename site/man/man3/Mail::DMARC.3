.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DMARC 3"
.TH Mail::DMARC 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Status Badges"
.IX Header "Status Badges"
.SH "NAME"
Mail::DMARC \- Perl implementation of DMARC
.SH "VERSION"
.IX Header "VERSION"
version 1.20200214
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1DMARC:\s0 Domain-based Message Authentication, Reporting and Conformance
.PP
.Vb 3
\&  my $dmarc = Mail::DMARC::PurePerl\->new(
\&    ... # see the documentation for the "new" method for required args
\&  );
\&
\&  my $result = $dmarc\->validate();
\&
\&  if ( $result\->result eq \*(Aqpass\*(Aq ) {
\&     ...continue normal processing...
\&     return;
\&  };
\&
\&  # any result that did not pass is a fail. Now for disposition
\&
\&  if ( $result\->evalated\->disposition eq \*(Aqreject\*(Aq ) {
\&     ...treat the sender to a 550 ...
\&  };
\&  if ( $result\->evalated\->disposition eq \*(Aqquarantine\*(Aq ) {
\&     ...assign a bunch of spam points...
\&  };
\&  if ( $result\->evalated\->disposition eq \*(Aqnone\*(Aq ) {
\&     ...continue normal processing...
\&  };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a suite of tools for implementing \s-1DMARC.\s0 It adheres to the 2013 \s-1DMARC\s0 draft, intending to implement every \s-1MUST\s0 and every \s-1SHOULD.\s0
.PP
This module can be used by...
.IP "\(bu" 4
MTAs and filtering tools like SpamAssassin to validate that incoming messages are aligned with the purported sender's policy.
.IP "\(bu" 4
email senders, to receive \s-1DMARC\s0 reports from other mail servers and display them via \s-1CLI\s0 and web interfaces.
.IP "\(bu" 4
\&\s-1MTA\s0 operators to send \s-1DMARC\s0 reports to \s-1DMARC\s0 author domains.
.PP
When a message arrives via \s-1SMTP,\s0 the \s-1MTA\s0 or filtering application can pass in a small amount of metadata about the connection (envelope details, \s-1SPF\s0 and \s-1DKIM\s0 results) to Mail::DMARC. When the \fBvalidate\fR method is called, Mail::DMARC will determine if:
.PP
.Vb 5
\& a. the header_from domain exists
\& b. the header_from domain publishes a DMARC policy
\& c. if a policy is published...
\& d. does the message conform to the published policy?
\& e. did the policy request reporting? If so, save details.
.Ve
.PP
The validation results are returned as a Mail::DMARC::Result object. If the author domain requested a report, it was saved to the Report Store. The Store class includes a \s-1SQL\s0 implementation that is tested with SQLite, MySQL and PostgreSQL.
.PP
There is more information available in the \f(CW$result\fR object. See Mail::DMARC::Result for complete details.
.PP
Reports are viewed with the dmarc_view_reports program or with a web browser and the dmarc_httpd program.
.PP
Aggregate reports are sent to their requestors with the dmarc_send_reports program.
.PP
For aggregate reports that you have been sent, the dmarc_receive program will parse the email messages (from \s-1IMAP,\s0 Mbox, or files) and save the report results into the Report Store.
.PP
The report store can use the same database to store reports you have received as well as reports you will send. There are several ways to identify the difference, including:
.IP "\(bu" 4
received reports will have a null value for report_policy_published.rua
.IP "\(bu" 4
outgoing reports will have null values for report.uuid and report_record.count
.SH "CLASSES"
.IX Header "CLASSES"
Mail::DMARC \- the perl interface for \s-1DMARC\s0
.PP
Mail::DMARC::Policy \- a \s-1DMARC\s0 policy
.PP
Mail::DMARC::PurePerl \- Pure Perl implementation of \s-1DMARC\s0
.PP
Mail::DMARC::Result \- the results of applying policy
.PP
Mail::DMARC::Report \- Reporting: the R in \s-1DMARC\s0
.Sp
.RS 2
Mail::DMARC::Report::Send \- send reports via \s-1SMTP & HTTP\s0
.Sp
Mail::DMARC::Report::Receive \- receive and store reports from email, \s-1HTTP\s0
.Sp
Mail::DMARC::Report::Store \- a persistent data store for aggregate reports
.Sp
Mail::DMARC::Report::View \- \s-1CLI\s0 and \s-1CGI\s0 methods for viewing reports
.RE
.PP
Mail::DMARC::libopendmarc <http://search.cpan.org/~shari/Mail-DMARC-opendmarc> \- an \s-1XS\s0 implementation using libopendmarc
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Create a \s-1DMARC\s0 object.
.PP
.Vb 1
\&    my $dmarc = Mail::DMARC::PurePerl\->new;
.Ve
.PP
Populate it.
.PP
.Vb 10
\&    $dmarc\->source_ip(\*(Aq192.0.1.1\*(Aq);
\&    $dmarc\->envelope_to(\*(Aqrecipient.example.com\*(Aq);
\&    $dmarc\->envelope_from(\*(Aqsender.example.com\*(Aq);
\&    $dmarc\->header_from(\*(Aqsender.example.com\*(Aq);
\&    $dmarc\->dkim( $dkim_verifier );
\&    $dmarc\->spf([
\&        {   domain => \*(Aqexample.com\*(Aq,
\&            scope  => \*(Aqmfrom\*(Aq,
\&            result => \*(Aqpass\*(Aq,
\&        },
\&        {
\&            scope  => \*(Aqhelo\*(Aq,
\&            domain => \*(Aqmta.example.com\*(Aq,
\&            result => \*(Aqfail\*(Aq,
\&        },
\&    ]);
.Ve
.PP
Run the request:
.PP
.Vb 1
\&    my $result = $dmarc\->validate();
.Ve
.PP
Alternatively, pass in all the required parameters in one shot:
.PP
.Vb 9
\&    my $dmarc = Mail::DMARC::PurePerl\->new(
\&            source_ip     => \*(Aq192.0.1.1\*(Aq,
\&            envelope_to   => \*(Aqexample.com\*(Aq,
\&            envelope_from => \*(Aqcars4you.info\*(Aq,
\&            header_from   => \*(Aqyahoo.com\*(Aq,
\&            dkim          => $dkim_results,  # same format
\&            spf           => $spf_results,   # as previous example
\&            );
\&    my $result = $dmarc\->validate();
.Ve
.SS "source_ip"
.IX Subsection "source_ip"
The remote \s-1IP\s0 that attempted sending the message. \s-1DMARC\s0 only uses this data for reporting to domains that request \s-1DMARC\s0 reports.
.SS "envelope_to"
.IX Subsection "envelope_to"
The domain portion of the \s-1RFC5321\s0.RcptTo, (aka, the envelope recipient), and the bold portion in the following example:
.Sp
.RS 8
\&\s-1RCPT\s0 TO:&lt;user@\fBexample.com\fR>
.RE
.SS "envelope_from"
.IX Subsection "envelope_from"
The domain portion of the \s-1RFC5321\s0.MailFrom, (aka, the envelope sender). That is the the bold portion in the following example:
.Sp
.RS 8
\&\s-1MAIL\s0 FROM:&lt;user@\fBexample.com\fR>
.RE
.SS "header_from"
.IX Subsection "header_from"
The domain portion of the \s-1RFC5322\s0.From, aka, the From message header.
.Sp
.RS 8
From: Ultimate Vacation &lt;sweepstakes@\fBexample.com\fR>
.RE
.PP
You can instead pass in the entire From: header with header_from_raw.
.SS "header_from_raw"
.IX Subsection "header_from_raw"
Retrieve the header_from domain by parsing it from a raw From field/header. The domain portion is extracted by get_dom_from_header, which is fast, generally effective, but also rather crude. It has limits, so read the description.
.SS "dkim"
.IX Subsection "dkim"
If Mail::DKIM::Verifier was used to validate the message, just pass in the Mail::DKIM::Verifier object that processed the message:
.PP
.Vb 1
\&    $dmarc\->dkim( $dkim_verifier );
.Ve
.PP
Otherwise, pass in an array reference. Each member of the \s-1DKIM\s0 array results represents a \s-1DKIM\s0 signature in the message and consists of the 4 keys shown in this example:
.PP
.Vb 11
\&    $dmarc\->dkim( [
\&            {
\&                domain      => \*(Aqexample.com\*(Aq,
\&                selector    => \*(Aqapr2013\*(Aq,
\&                result      => \*(Aqfail\*(Aq,
\&                human_result=> \*(Aqfail (body has been altered)\*(Aq,
\&            },
\&            {
\&                # 2nd signature, if present
\&            },
\&        ] );
.Ve
.PP
The dkim results can also be build iteratively by passing in key value pairs or hash references for each signature in the message:
.PP
.Vb 3
\&    $dmarc\->dkim( domain => \*(Aqsig1.com\*(Aq, result => \*(Aqfail\*(Aq );
\&    $dmarc\->dkim( domain => \*(Aqsig2.com\*(Aq, result => \*(Aqpass\*(Aq );
\&    $dmarc\->dkim( { domain => \*(Aqexample.com\*(Aq, result => \*(Aqneutral\*(Aq } );
.Ve
.PP
Each hash or hashref is appended to the dkim array.
.PP
Finally, you can pass a coderef which won't be called until the dkim method is used to read the dkim results.  It must return an array reference as described above.
.PP
The dkim result is an array reference.
.PP
\fIdomain\fR
.IX Subsection "domain"
.PP
The d= parameter in the \s-1DKIM\s0 signature
.PP
\fIselector\fR
.IX Subsection "selector"
.PP
The s= parameter in the \s-1DKIM\s0 signature
.PP
\fIresult\fR
.IX Subsection "result"
.PP
The validation results of this signature. One of: none, pass, fail, policy, neutral, temperror, or permerror
.PP
\fIhuman result\fR
.IX Subsection "human result"
.PP
Additional information about the \s-1DKIM\s0 result. This is comparable to Mail::DKIM::Verifier\->result_detail.
.SS "spf"
.IX Subsection "spf"
The spf method works exactly the same as dkim. It accepts named arguments, a hashref, an arrayref, or a coderef:
.PP
.Vb 5
\&    $dmarc\->spf(
\&        domain => \*(Aqexample.com\*(Aq,
\&        scope  => \*(Aqmfrom\*(Aq,
\&        result => \*(Aqpass\*(Aq,
\&    );
.Ve
.PP
The \s-1SPF\s0 domain and result are required for \s-1DMARC\s0 validation and the scope is used for reporting.
.PP
\fIdomain\fR
.IX Subsection "domain"
.PP
The \s-1SPF\s0 checked domain
.PP
\fIscope\fR
.IX Subsection "scope"
.PP
The scope of the checked domain: mfrom, helo
.PP
\fIresult\fR
.IX Subsection "result"
.PP
The \s-1SPF\s0 result code: none, neutral, pass, fail, softfail, temperror, or permerror.
.SH "DESIGN & GOALS"
.IX Header "DESIGN & GOALS"
.SS "Correct"
.IX Subsection "Correct"
The \s-1DMARC\s0 spec is lengthy and evolving, making correctness a moving target. In cases where correctness is ambiguous, options are generally provided.
.SS "Easy to use"
.IX Subsection "Easy to use"
Providing an implementation of \s-1DMARC\s0 that \s-1SMTP\s0 utilities can utilize will aid \s-1DMARC\s0 adoption.
.PP
The list of dependencies appears long because of reporting. If this module is used without reporting, the number of dependencies not included with perl is about 5. See the [Prereq] versus [Prereq / Recommends] sections in dist.ini.
.SS "Maintainable"
.IX Subsection "Maintainable"
Since \s-1DMARC\s0 is evolving, this implementation aims to be straight forward and easy to alter and extend. The programming style is primarily \s-1OO,\s0 which carries a small performance penalty but dividends in maintainability.
.PP
When multiple options are available, such as when sending reports via \s-1SMTP\s0 or \s-1HTTP,\s0 calls should be made to the parent Send class to broker the request. When storing reports, calls are made to the Store class which dispatches to the \s-1SQL\s0 class. The idea is that if someone desired a data store other than those provided by perl's \s-1DBI\s0 class, they could easily implement their own. If you do, please fork it on GitHub and share.
.SS "Fast"
.IX Subsection "Fast"
If you deploy this in an environment where performance is insufficient, please profile the app and submit a report and preferably, patches.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DMARC on GitHub <https://github.com/msimerson/mail-dmarc>
.PP
2015\-03 \s-1RFC 7489\s0 <https://tools.ietf.org/html/rfc7489>
.PP
\&\s-1DMARC\s0 Best Current Practices <http://tools.ietf.org/html/draft-crocker-dmarc-bcp-03>
.SH "HISTORY"
.IX Header "HISTORY"
The daddy of this perl module was a \s-1DMARC\s0 module for the qpsmtpd \s-1MTA\s0 <https://github.com/smtpd/qpsmtpd/blob/master/plugins/dmarc>.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Matt Simerson <msimerson@cpan.org>
.IP "\(bu" 4
Davide Migliavacca <shari@cpan.org>
.IP "\(bu" 4
Marc Bradshaw <marc@marcbradshaw.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Benny Pedersen <me@junc.eu>
.IP "\(bu" 4
Jean Paul Galea <jeanpaul@yubico.com>
.IP "\(bu" 4
Marisa Clardy <marisa@clardy.eu>
.IP "\(bu" 4
Priyadi Iman Nurcahyo <priyadi@priyadi.net>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Matt Simerson.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
