.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SNMP::Info::Layer3::BayRS 3"
.TH SNMP::Info::Layer3::BayRS 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SNMP::Info::Layer3::BayRS \- SNMP Interface to Avaya/Nortel routers running
BayRS.
.SH "AUTHOR"
.IX Header "AUTHOR"
Eric Miller
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& # Let SNMP::Info determine the correct subclass for you.
\& my $bayrs = new SNMP::Info(
\&                          AutoSpecify => 1,
\&                          Debug       => 1,
\&                          DestHost    => \*(Aqmyswitch\*(Aq,
\&                          Community   => \*(Aqpublic\*(Aq,
\&                          Version     => 2
\&                        )
\&    or die "Can\*(Aqt connect to DestHost.\en";
\&
\& my $class      = $bayrs\->class();
\& print "SNMP::Info determined this device to fall under subclass : $class\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Abstraction subclass for routers running Avaya/Nortel BayRS.
.SS "Inherited Classes"
.IX Subsection "Inherited Classes"
.IP "SNMP::Info::Layer3" 4
.IX Item "SNMP::Info::Layer3"
.SS "Required MIBs"
.IX Subsection "Required MIBs"
.PD 0
.IP "\fIWellfleet-HARDWARE-MIB\fR" 4
.IX Item "Wellfleet-HARDWARE-MIB"
.IP "\fIWellfleet-MODULE-MIB\fR" 4
.IX Item "Wellfleet-MODULE-MIB"
.IP "\fIWellfleet-OSPF-MIB\fR" 4
.IX Item "Wellfleet-OSPF-MIB"
.IP "\fIWellfleet\-DOT1QTAG\-CONFIG\-MIB\fR" 4
.IX Item "Wellfleet-DOT1QTAG-CONFIG-MIB"
.IP "\fIWellfleet-CSMACD-MIB\fR" 4
.IX Item "Wellfleet-CSMACD-MIB"
.PD
.SS "Inherited MIBs"
.IX Subsection "Inherited MIBs"
See \*(L"Required MIBs\*(R" in SNMP::Info::Layer3 for its own \s-1MIB\s0 requirements.
.SH "GLOBALS"
.IX Header "GLOBALS"
These are methods that return scalar value from \s-1SNMP\s0
.ie n .IP "$bayrs\->\fBmodel()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBmodel()\fR" 4
.IX Item "$bayrs->model()"
Returns the model of the BayRS router.  Will translate between the \s-1MIB\s0 model
and the common model with this map :
.Sp
.Vb 10
\&    C<%MODEL_MAP = (
\&        \*(Aqacefn\*(Aq     => \*(AqFN\*(Aq,
\&        \*(Aqaceln\*(Aq     => \*(AqLN\*(Aq,
\&        \*(Aqacecn\*(Aq     => \*(AqCN\*(Aq,
\&        \*(Aqafn\*(Aq       => \*(AqAFN\*(Aq,
\&        \*(Aqin\*(Aq        => \*(AqIN\*(Aq,
\&        \*(Aqan\*(Aq        => \*(AqAN\*(Aq,
\&        \*(Aqarn\*(Aq       => \*(AqARN\*(Aq,
\&        \*(Aqsys5000\*(Aq   => \*(Aq5000\*(Aq,
\&        \*(Aqfreln\*(Aq     => \*(AqBLN\*(Aq,
\&        \*(Aqfrecn\*(Aq     => \*(AqBCN\*(Aq,
\&        \*(Aqfrerbln\*(Aq   => \*(AqBLN\-2\*(Aq,
\&        \*(Aqasn\*(Aq       => \*(AqASN\*(Aq,
\&        \*(Aqasnzcable\*(Aq => \*(AqASN\-Z\*(Aq,
\&        \*(Aqasnbcable\*(Aq => \*(AqASN\-B\*(Aq,
\&        );>
.Ve
.ie n .IP "$bayrs\->\fBvendor()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBvendor()\fR" 4
.IX Item "$bayrs->vendor()"
Returns 'avaya'
.ie n .IP "$bayrs\->\fBos()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBos()\fR" 4
.IX Item "$bayrs->os()"
Returns 'bayrs'
.ie n .IP "$bayrs\->\fBos_ver()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBos_ver()\fR" 4
.IX Item "$bayrs->os_ver()"
Returns the software version extracted from \f(CW\*(C`sysDescr\*(C'\fR
.ie n .IP "$bayrs\->\fBserial()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBserial()\fR" 4
.IX Item "$bayrs->serial()"
Returns (\f(CW\*(C`wfHwBpSerialNumber\*(C'\fR) after conversion to \s-1ASCII\s0 decimal
.ie n .IP "$bayrs\->\fBroot_ip()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBroot_ip()\fR" 4
.IX Item "$bayrs->root_ip()"
Returns the primary \s-1IP\s0 used to communicate with the router.
.Sp
Returns the first found:  \s-1CLIP\s0 (CircuitLess \s-1IP\s0), (\f(CW\*(C`wfOspfRouterId\*(C'\fR), or
undefined.
.SS "Globals imported from SNMP::Info::Layer3"
.IX Subsection "Globals imported from SNMP::Info::Layer3"
See documentation in \*(L"\s-1GLOBALS\*(R"\s0 in SNMP::Info::Layer3 for details.
.SH "TABLE METHODS"
.IX Header "TABLE METHODS"
These are methods that return tables of information in the form of a reference
to a hash.
.PP
Note:  These methods do not support partial table fetches, a partial can be
passed but the entire table will be returned.
.SS "Overrides"
.IX Subsection "Overrides"
.ie n .IP "$bayrs\->\fBinterfaces()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBinterfaces()\fR" 4
.IX Item "$bayrs->interfaces()"
Returns reference to the map between \s-1IID\s0 and physical Port.
.Sp
The physical port name is stripped to letter and numbers to signify
port type and slot port (S11) if the default platform naming was
maintained.  Otherwise the port is the interface description.
.ie n .IP "$bayrs\->\fBi_name()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBi_name()\fR" 4
.IX Item "$bayrs->i_name()"
Returns (\f(CW\*(C`ifDescr\*(C'\fR) along with \s-1VLAN\s0 name (\f(CW\*(C`wfDot1qTagCfgVlanName\*(C'\fR) for \s-1VLAN\s0
interfaces.
.ie n .IP "$bayrs\->\fBi_duplex()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBi_duplex()\fR" 4
.IX Item "$bayrs->i_duplex()"
Returns reference to hash.  Maps port operational duplexes to IIDs for
Ethernet interfaces.
.ie n .IP "$bayrs\->\fBi_duplex_admin()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBi_duplex_admin()\fR" 4
.IX Item "$bayrs->i_duplex_admin()"
Returns reference to hash.  Maps port admin duplexes to IIDs for Ethernet
interfaces.
.ie n .IP "$bayrs\->\fBi_vlan()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBi_vlan()\fR" 4
.IX Item "$bayrs->i_vlan()"
Returns reference to hash.  Maps port \s-1VLAN ID\s0 to IIDs.
.ie n .IP "$bayrs\->\fBi_pvid()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBi_pvid()\fR" 4
.IX Item "$bayrs->i_pvid()"
Returns reference to hash.  Maps port \s-1VLAN ID\s0 to IIDs.
.SS "Pseudo \fIENTITY-MIB\fP information"
.IX Subsection "Pseudo ENTITY-MIB information"
These methods emulate \fIENTITY-MIB\fR Physical Table methods using
\&\fIWellfleet-HARDWARE-MIB\fR and \fIWellfleet-MODULE-MIB\fR.
.ie n .IP "$bayrs\->\fBe_index()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_index()\fR" 4
.IX Item "$bayrs->e_index()"
Returns reference to hash.  Key and Value: Integer. The index is created by
combining the slot, module, and position into a five or six digit integer.
Slot can be either one or two digits while the module and position are each
two digits padded with leading zero if required.
.ie n .IP "$bayrs\->\fBe_class()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_class()\fR" 4
.IX Item "$bayrs->e_class()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: General hardware type.  This
class only returns container and module types.
.ie n .IP "$bayrs\->\fBe_descr()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_descr()\fR" 4
.IX Item "$bayrs->e_descr()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Human friendly name.
.ie n .IP "$bayrs\->\fBe_name()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_name()\fR" 4
.IX Item "$bayrs->e_name()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Human friendly name.
.ie n .IP "$bayrs\->\fBe_hwver()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_hwver()\fR" 4
.IX Item "$bayrs->e_hwver()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Hardware version.
.ie n .IP "$bayrs\->\fBe_vendor()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_vendor()\fR" 4
.IX Item "$bayrs->e_vendor()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: avaya.
.ie n .IP "$bayrs\->\fBe_serial()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_serial()\fR" 4
.IX Item "$bayrs->e_serial()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Serial number.
.ie n .IP "$bayrs\->\fBe_pos()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_pos()\fR" 4
.IX Item "$bayrs->e_pos()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: The relative position among all
entities sharing the same parent.
.ie n .IP "$bayrs\->\fBe_type()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_type()\fR" 4
.IX Item "$bayrs->e_type()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Type of component/sub\-component
as defined in \fIWellfleet-HARDWARE-MIB\fR for processors and link modules or
\&\fIWellfleet-MODULE-MIB\fR for hardware modules.
.ie n .IP "$bayrs\->\fBe_fwver()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_fwver()\fR" 4
.IX Item "$bayrs->e_fwver()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Firmware revision.  Only
available on processors.
.ie n .IP "$bayrs\->\fBe_swver()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_swver()\fR" 4
.IX Item "$bayrs->e_swver()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: Software revision.  Only
available on processors.
.ie n .IP "$bayrs\->\fBe_parent()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBe_parent()\fR" 4
.IX Item "$bayrs->e_parent()"
Returns reference to hash.  Key: \s-1IID,\s0 Value: The value of \fBe_index()\fR for the
entity which 'contains' this entity.  A value of zero indicates	this entity
is not contained in any other entity.
.SS "Table Methods imported from SNMP::Info::Layer3"
.IX Subsection "Table Methods imported from SNMP::Info::Layer3"
See documentation in \*(L"\s-1TABLE METHODS\*(R"\s0 in SNMP::Info::Layer3 for details.
.SH "Data Munging Callback Subroutines"
.IX Header "Data Munging Callback Subroutines"
.ie n .IP "$bayrs\->\fBmunge_hw_rev()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBmunge_hw_rev()\fR" 4
.IX Item "$bayrs->munge_hw_rev()"
Converts octets to a decimal major.minor string.
.ie n .IP "$bayrs\->\fBmunge_wf_serial()\fR" 4
.el .IP "\f(CW$bayrs\fR\->\fBmunge_wf_serial()\fR" 4
.IX Item "$bayrs->munge_wf_serial()"
Coverts octets to a decimal string.
