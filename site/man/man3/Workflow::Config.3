.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Config 3"
.TH Workflow::Config 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Config \- Parse configuration files for the workflow components
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.12 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Reference multiple files
\&
\& my $parser = Workflow::Config\->new( \*(Aqxml\*(Aq );
\& my @config = $parser\->parse(
\&     \*(Aqaction\*(Aq, \*(Aqworkflow_action.xml\*(Aq, \*(Aqother_actions.xml\*(Aq
\& );
\&
\& # Read in one of the file contents from somewhere else
\& my $xml_contents = read_contents_from_db( \*(Aqother_actions.xml\*(Aq );
\& my @config = $parser\->parse(
\&     \*(Aqaction\*(Aq, \*(Aqworkflow_action.xml\*(Aq, \e$xml_contents
\& );
\&_
\& # Reference multiple files of mixed types
\&
\& my @action_config = Workflow::Config\->parse_all_files(
\&     \*(Aqaction\*(Aq, \*(Aqmy_actions.xml\*(Aq, \*(Aqyour_actions.perl\*(Aq
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read in configurations for the various workflow components. Currently
the class understands \s-1XML\s0 (preferred) and serialized Perl data
structures as valid configuration file formats. (I tried to use \s-1INI\s0
files but there was too much deeply nested information. Sorry.)
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
\fIparse_all_files( \f(CI$workflow_config_type\fI, \f(CI@files\fI )\fR
.IX Subsection "parse_all_files( $workflow_config_type, @files )"
.PP
Runs through each file in \f(CW@files\fR and processes it according to the valid
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Creating Your Own Parser"
.IX Subsection "Creating Your Own Parser"
If you want to store your configuration in a different format you can
create your own parser. All you need to do is:
.IP "1." 4
subclass Workflow::Config
.IP "2." 4
implement the required methods (listed below)
.IP "3." 4
register your parser with Workflow::Config.
.PP
For instance, if you wanted to use \s-1YAML\s0 for configuration files you
would do something like:
.PP
.Vb 2
\& # just a convention, you can use any namespace you want
\& package Workflow::Config::YAML;
\&
\& use strict;
\&
\& # Requirement 1: Subclass Workflow::Config
\& use base qw( Workflow::Config );
\&
\& # Requirement 2: Implement required methods
\& sub parse { ... }
.Ve
.PP
The third requirement is registration, which just tells
Workflow::Config which parser to use for a particular type. To do
this you have two options.
.PP
\&\fBRegistration option one\fR
.PP
Register yourself in your own class, adding the following call
anywhere the end:
.PP
.Vb 2
\& # Option 1: Register ourselves by name
\& Workflow::Config\->register_factory_type( yaml => \*(AqWorkflow::Config::YAML\*(Aq );
.Ve
.PP
Now you just need to include the configuration class in your workflow
invocation script:
.PP
.Vb 3
\& use strict;
\& use Workflow::Factory qw( FACTORY );
\& use Workflow::Config::YAML; # <\-\- brings in the registration
.Ve
.PP
\&\fBRegistration option two\fR
.PP
You can also just explicitly add the registration from your workflow
invocation script:
.PP
.Vb 3
\& use strict;
\& use Workflow::Factory qw( FACTORY );
\& use Workflow::Config;
\&
\& # Option 2: explicitly register your configuration parser
\& Workflow::Config\->register_factory_type( yaml => \*(AqWorkflow::Config::YAML\*(Aq );
.Ve
.PP
Whichever one you choose you can now parse (in this example) \s-1YAML\s0
files alongside the built-in parsers for \s-1XML\s0 and Perl files:
.PP
.Vb 7
\& FACTORY\->add_config_from_file(
\&     workflow  => \*(Aqworkflow.yaml\*(Aq,
\&     action    => [ \*(Aqmy_actions.yaml\*(Aq, \*(Aqother_actions.xml\*(Aq ],
\&     validator => \*(Aqvalidators.yaml\*(Aq,
\&     condition => [ \*(Aqmy_conditions.yaml\*(Aq, \*(Aqother_conditions.xml\*(Aq ]
\&     persister => \*(Aqpersister.perl\*(Aq,
\& );
.Ve
.SS "Inherited Methods"
.IX Subsection "Inherited Methods"
\fInew( \f(CI$parser_type\fI )\fR
.IX Subsection "new( $parser_type )"
.PP
Instantiates an object of the correct type \*(-- see Class::Factory
for how this is implemented:
.PP
.Vb 2
\& # Parser of type \*(AqWorkflow::Config::XML\*(Aq
\& my $xml_parser  = Workflow::Config\->new( \*(Aqxml\*(Aq );
\&
\& # Parser of type \*(AqWorkflow::Config::Perl
\& my $perl_parser = Workflow::Config\->new( \*(Aqperl\*(Aq );
.Ve
.PP
\fIis_valid_config_type( \f(CI$config_type\fI )\fR
.IX Subsection "is_valid_config_type( $config_type )"
.PP
Returns true if \f(CW$config_type\fR is a valid configuration type, false
if not. Valid configuration types are: 'action', 'condition',
\&'validator', 'workflow'.
.PP
\fI\f(BIget_valid_config_types()\fI\fR
.IX Subsection "get_valid_config_types()"
.PP
Returns list of strings representing the valid configuration types.
.PP
\fIget_config_type_tag( \f(CI$class\fI, \f(CI$type\fI )\fR
.IX Subsection "get_config_type_tag( $class, $type )"
.PP
Returns string representing a valid configuration type, looking up the type
parameter in a lookuptable defined in Workflow::Config class.
.SS "Required Object Methods"
.IX Subsection "Required Object Methods"
\fIparse( \f(CI$workflow_config_type\fI, \f(CI@items\fI )\fR
.IX Subsection "parse( $workflow_config_type, @items )"
.PP
Parse each item in \f(CW@items\fR to a hash reference based on the
configuration type \f(CW$config_type\fR which must pass the
\&\f(CW\*(C`is_valid_config_type()\*(C'\fR test. An 'item' is either a filename or a
scalar reference with the contents of a file. (You can mix and match
as seen in the \s-1SYNOPSIS\s0.)
.PP
Should throw an exception if:
.IP "\(bu" 4
You pass an invalid workflow configuration type. Valid workflow
configuration types are registered in Workflow::Config and are
available from \f(CW\*(C`get_valid_config_types()\*(C'\fR; you can check whether a
particular type is valid with \f(CW\*(C`is_valid_config_type()\*(C'\fR. (See above
for descriptions.)
.IP "\(bu" 4
You pass in a file that cannot be read or parsed because of
permissions, malformed \s-1XML,\s0 incorrect Perl data structure, etc. It
does \fBnot\fR do a validation check (e.g., to ensure that every 'action'
within a workflow state has a 'resulting_state' key).
.PP
Returns: one hash reference for each member of \f(CW@items\fR
.SH "CONFIGURATION INFORMATION"
.IX Header "CONFIGURATION INFORMATION"
This gives you an idea of the configuration information in the various
workflow pieces:
.SS "workflow"
.IX Subsection "workflow"
.Vb 10
\&   workflow
\&      type          $
\&      description   $
\&      persister     $
\&      initial_state $
\&      observer    \e@
\&          sub           $
\&          class         $
\&      state       \e@
\&          name          $
\&          description   $
\&          action        \e@
\&              name            $
\&              resulting_state $
\&              condition       \e@
\&                  name              $
.Ve
.IP "\(bu" 4
the 'type' and 'description' keys are at the top level
.IP "\(bu" 4
the 'extra_data' key holds an array of zero or more hashrefs with
\&'table', 'field', 'class' and 'context' keys
.IP "\(bu" 4
\&'initial_state' key holds a string declaring the name of the initial state.
by default, this value is '\s-1INIITAL\s0'.
.IP "\(bu" 4
\&'state' key holds array of one or more 'state' declarations; one of
them must be '\s-1INITIAL\s0' (or the value of initial_state, if it's defined)
.IP "\(bu" 4
each 'state' declaration holds 'description' and 'name' keys and
multiple 'action' declarations
.IP "\(bu" 4
each 'action' declaration holds 'name' and 'resulting_state' keys and
may hold a 'condition' key with one or more named conditions
.SS "condition"
.IX Subsection "condition"
.Vb 1
\& conditions:
\&
\&     condition \e@
\&        name  $
\&        class $
\&        param \e@
\&            name  $
\&            value $
.Ve
.IP "\(bu" 4
array of one or more hashrefs with 'name' and 'class' keys
.SS "validator"
.IX Subsection "validator"
.Vb 1
\& validators:
\&
\&     validator \e@
\&        name  $
\&        class $
\&        param \e@
\&            name  $
\&            value $
.Ve
.IP "\(bu" 4
array of one or more hashrefs with 'name' and 'class' keys, plus
possibly one or more 'param' hashrefs each with 'name' and 'value'
keys
.SS "action"
.IX Subsection "action"
.Vb 1
\& actions:
\&
\&    action \e@
\&       name  $
\&       field \e@
\&          name         $
\&          is_required  yes|no
\&          type         $
\&          source_list  \e@ of $
\&          source_class $
\&          param        \e@
\&              name  $
\&              value $
\&       validator \e@
\&           name $
\&           arg  \e@
\&               value $
.Ve
.IP "\(bu" 4
array of one or more action hashrefs with 'name', 'class' and
\&'description' keys
.IP "\(bu" 4
each 'action' may have zero or more values used to fill it; each value
has a 'name', 'description' and 'necessity' ('required' or 'optional')
.IP "\(bu" 4
each 'action' may have any number of 'param' hashrefs, each with
\&'name' and 'value'
.IP "\(bu" 4
each 'action' may have any number of 'validator' hashrefs, each with a
\&'name' key and array of 'arg' declarations
.SS "persister"
.IX Subsection "persister"
.Vb 1
\& persister:
\&
\&   extra_table   $
\&   extra_field   $
\&   extra_class   $
\&   extra_context $
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2004 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
