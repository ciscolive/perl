.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::BNF 3"
.TH Marpa::R2::BNF 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Marpa::R2::BNF \- \s-1BNF\s0 Interface (obsoleted)
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&    use Marpa::R2;
\&
\&    my $grammar = Marpa::R2::Grammar\->new(
\&        {   
\&            actions        => \*(AqMy_Actions\*(Aq,
\&            default_action => \*(Aqdo_first_arg\*(Aq,
\&            source          => \e(<<\*(AqEND_OF_SOURCE\*(Aq),
\&    :start ::= Script
\&    Script ::= Expression+ separator => <op comma> action => do_script
\&    Expression ::=
\&        Number
\&        | (<op lparen>) Expression (<op rparen>) action => do_parens assoc => group
\&       || Expression (<op pow>) Expression action => do_pow assoc => right
\&       || Expression (<op times>) Expression action => do_multiply
\&        | Expression (<op divide>) Expression action => do_divide
\&       || Expression (<op add>) Expression action => do_add
\&        | Expression (<op subtract>) Expression action => do_subtract
\&    END_OF_SOURCE
\&        }
\&    );
.Ve
.SH "Overview"
.IX Header "Overview"
This page is the reference for the Marpa's \*(L"\s-1BNF\s0 interface\*(R",
also called its \*(L"Stuifzand interface\*(R".
Use of the Stuifzand interface is now discouraged,
in favor of the \s-1SLIF\s0
interface.
Almost all of the functionality of
the Stuifzand interface can be duplicated
in the \s-1SLIF\s0 interface by switching immediately
to external scanning,
and never switching back to internal scanning.
To switch immediately to external scanning in the \s-1SLIF,\s0
specify a length of zero for its initial
\&\f(CW\*(C`read()\*(C'\fR.
For more details, see the
document for the \s-1SLIF\s0
itself.
.SH "The source string"
.IX Header "The source string"
Stuifzand interface  source strings are specified using the 
the \f(CW\*(C`source\*(C'\fR named argument of Marpa::R2's grammars.
\&\s-1BNF\s0 source strings perform the functions of
the
\&\f(CW\*(C`rules\*(C'\fR
and the
\&\f(CW\*(C`start\*(C'\fR
named arguments of Marpa grammars.
When
the \f(CW\*(C`source\*(C'\fR named argument is used to specify a grammar,
the \f(CW\*(C`rules\*(C'\fR and \f(CW\*(C`start\*(C'\fR named arguments should not be used,
and vice versa.
The syntax for the Stuifzand interface's source string is the
same as
the syntax for the \s-1SLIF
DSL\s0,
except that features and syntax not relevant to the Stuifzand
interface are not supported.
.PP
Everything related to L0 grammars is unsupported.
L0 grammars do not exist in the Stuifzand interface.
Lexemes, character classes and quoted strings all implicitly
require a L0 grammar to exist
and therefore, they also are not supported.
.PP
Since the Stuifzand interface does not implement internal
scanning,
everything to do with internal scanning is unsupported.
\&\s-1SLIF\s0 parse events are the most visible of these features.
.PP
In most cases,
when features have introduced after the \s-1SLIF\s0 replaced
the Stuifzand interface
as Marpa's primary interface,
those features have been retro-ported
if they make sense in the Stuifzand context.
However, this will necessarily always be the case in
the future.
.PP
Here is a list of some of the unsupported \s-1SLIF DSL\s0 features,
.IP "\(bu" 4
Character classes
.Sp
These implicitly use the L0 grammar.
.IP "\(bu" 4
Quoted strings
.Sp
These implicitly use the L0 grammar.
.IP "\(bu" 4
Discard rules
.Sp
\&\f(CW\*(C`:discard\*(C'\fR rules control the behavior of the L0 grammar.
.IP "\(bu" 4
The lexeme and lexeme default statements
.Sp
The \f(CW\*(C`:lexeme\*(C'\fR pseudo-rule and
the lexeme default statement define the behavior of
lexemes.
Lexemes in the \s-1SLIF\s0 sense
do not exist in the Stuifzand interface.
.IP "\(bu" 4
L0 rules
.Sp
Rules with the tilde declarator ("\f(CW\*(C`~\*(C'\fR") defined L0 rules.
.IP "\(bu" 4
Event declarations
.Sp
Parse events exist to trigger returns from the \s-1SLIF\s0 internal scanning
methods.
.IP "\(bu" 4
The pause adverb
.Sp
The pause adverb exists
to trigger returns from the \s-1SLIF\s0 internal scanning
methods.
.IP "\(bu" 4
The priority adverb
.Sp
The priority adverb defines lexeme priorities.
Lexemes in the \s-1SLIF\s0 sense
do not exist in the Stuifzand interface.
.IP "\(bu" 4
Actions specified as array descriptors
.Sp
Actions specified as array descriptors, for example,
.Sp
.Vb 1
\&    action => [start,length,value]
.Ve
.Sp
exist primarily to support lexeme semantics.
They can also specify rule semantics,
but their functionality has not been retro-ported
to the Stuifzand interface,
and probably never will be.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
