.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Walk::Clone 3"
.TH Data::Walk::Clone 3 "2016-08-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Walk::Clone \- deep data cloning with boundaries
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&        #!perl
\&        use Moose::Util qw( with_traits );
\&        use lib \*(Aq../lib\*(Aq;
\&        use Data::Walk::Extracted;
\&        use Data::Walk::Clone;
\&        use MooseX::ShortCut::BuildInstance qw( build_instance );
\&
\&        my  $dr_nisar_ahmad_wani = build_instance( 
\&                        package => \*(AqClone::Camels\*(Aq,
\&                        superclasses =>[\*(AqData::Walk::Extracted\*(Aq],
\&                        roles =>[ \*(AqData::Walk::Clone\*(Aq ],
\&                        skip_node_tests =>[  [ \*(AqHASH\*(Aq, \*(AqLowerKey2\*(Aq, \*(AqALL\*(Aq,   \*(AqALL\*(Aq ] ],
\&                );
\&        my  $donor_ref = {
\&                Someotherkey    => \*(Aqvalue\*(Aq,
\&                Parsing         =>{
\&                        HashRef =>{
\&                                LOGGER =>{
\&                                        run => \*(AqINFO\*(Aq,
\&                                },
\&                        },
\&                },
\&                Helping =>[
\&                        \*(AqSomelevel\*(Aq,
\&                        {
\&                                MyKey =>{
\&                                        MiddleKey =>{
\&                                                LowerKey1 => \*(Aqlvalue1\*(Aq,
\&                                                LowerKey2 => {
\&                                                        BottomKey1 => \*(Aqbvalue1\*(Aq,
\&                                                        BottomKey2 => \*(Aqbvalue2\*(Aq,
\&                                                },
\&                                        },
\&                                },
\&                        },
\&                ],
\&        };
\&        my      $injaz_ref = $dr_nisar_ahmad_wani\->deep_clone(
\&                        donor_ref => $donor_ref,
\&                );
\&        if(
\&                $injaz_ref\->{Helping}\->[1]\->{MyKey}\->{MiddleKey}\->{LowerKey2} eq
\&                $donor_ref\->{Helping}\->[1]\->{MyKey}\->{MiddleKey}\->{LowerKey2}           ){
\&                print "The data is not cloned at the skip point\en";
\&        }
\&                
\&        if( 
\&                $injaz_ref\->{Helping}\->[1]\->{MyKey}\->{MiddleKey} ne
\&                $donor_ref\->{Helping}\->[1]\->{MyKey}\->{MiddleKey}                ){
\&                print "The data is cloned above the skip point\en";
\&        }
\&
\&        #####################################################################################
\&        #     Output of SYNOPSIS
\&        # 01 The data is not cloned at the skip point
\&        # 02 The data is cloned above the skip point
\&        #####################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose::Role contains methods for implementing the method deep_clone
 using Data::Walk::Extracted.  This method is 
used to deep clone (clone many/all) levels of a data ref.  Deep cloning is accomplished by 
sending a 'donor_ref' that has data nodes that you want copied into a different memory 
location.  In general Data::Walk::Extracted already deep clones any output as part of its 
data walking so the primary value of this role is to manage deep cloning boundaries. It may 
be that some portion of the data should maintain common memory references to the original 
memory references and so all of the Data::Walk::Extracted skip methods will be recognized 
and supported.  Meaning that if a node is skipped the data reference will be copied directly 
rather than cloned.  The deep clone boundaries are managed using the skip attributes
 <https://metacpan.org/module/Data::Walk::Extracted#skipped_nodes> in Data::Walk::Extracted.
.SS "\s-1USE\s0"
.IX Subsection "USE"
This is a Moose::Role specifically designed to be used with Data::Walk::Extracted
 <https://metacpan.org/module/Data::Walk::Extracted#Extending-Data::Walk::Extracted>.
It can be combined at run time with Moose::Util or MooseX::ShortCut::BuildInstance.
.SH "Attributes"
.IX Header "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes
see Methods.  The \->new function will either accept fat comma lists or a
complete hash ref that has the possible attributes as the top keys.  Additionally
some attributes that have all the following methods; get_$attribute, set_$attribute,
has_$attribute, and clear_$attribute, can be passed to deep_clone
 and will be adjusted for just the run of that
method call.  These are called 'one shot' attributes.  The class and each role (where
applicable) in this package have a list of 'supported one shot attributes'.
.SS "should_clone"
.IX Subsection "should_clone"
.RS 4
\&\fBDefinition:\fR There are times when the cloning needs to be turned off.  This
is the switch.  If this is set to 0 then deep_clone just passes the doner ref back.
.Sp
\&\fBDefault\fR undefined = everything is cloned
.Sp
\&\fBRange\fR Boolean values (0|1)
.RE
.SS "(see also)"
.IX Subsection "(see also)"
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted#Attributes>
Attributes
.SH "Methods"
.IX Header "Methods"
.ie n .SS "deep_clone( $arg_ref|%args|$data_ref )"
.el .SS "deep_clone( \f(CW$arg_ref\fP|%args|$data_ref )"
.IX Subsection "deep_clone( $arg_ref|%args|$data_ref )"
.RS 4
\&\fBDefinition:\fR This takes a 'donor_ref' and deep clones it.
.Sp
\&\fBAccepts:\fR either a single data reference or named arguments
in a fat comma list or hashref
.Sp
.RS 4
\&\fBHash option\fR \- if data comes in a fat comma list or as a hash ref
and the keys include a 'donor_ref' key then the list is processed as such.
.Sp
.RS 4
\&\fBdonor_ref\fR \- this is the data reference that should be deep cloned \- required
.Sp
\&\fB[attribute name]\fR \- attribute names are accepted with temporary attribute
settings.  These settings are temporarily set for a single \*(L"deep_clone\*(R" call and
then the original attribute values are restored.  For this to work the the attribute
must meet the necessary criteria.
.RE
.RE
.RS 4
.Sp
\&\fBsingle data reference option\fR \- if only one data_ref is sent and it fails
the test;
.Sp
.Vb 1
\&        exists $data_ref\->{donor_ref}
.Ve
.Sp
then the program will attempt to name it as donor_ref => \f(CW$data_ref\fR and then clone
the whole thing.
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR The deep cloned data reference
.RE
.SS "get_should_clone"
.IX Subsection "get_should_clone"
.RS 4
\&\fBDefinition:\fR This will get the current value of the attribute
should_clone
.Sp
\&\fBAccepts:\fR  nothing
.Sp
\&\fBReturns:\fR a boolean value
.RE
.ie n .SS "set_should_clone( $Bool )"
.el .SS "set_should_clone( \f(CW$Bool\fP )"
.IX Subsection "set_should_clone( $Bool )"
.RS 4
\&\fBDefinition:\fR This will set the attribute should_clone
.Sp
\&\fBAccepts:\fR a boolean value
.Sp
\&\fBReturns:\fR nothing
.RE
.SS "has_should_clone"
.IX Subsection "has_should_clone"
.RS 4
\&\fBDefinition:\fR This will return true if the attribute should_clone
is active
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a boolean value
.RE
.SS "clear_should_clone"
.IX Subsection "clear_should_clone"
.RS 4
\&\fBDefinition:\fR This will set the attribute should_clone
to one ( 1 ).  \fIThe name is awkward to accomodate one shot attribute changes.\fR
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.SH "Caveat utilitor"
.IX Header "Caveat utilitor"
.SS "Supported Node types"
.IX Subsection "Supported Node types"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
.PD
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Data\-Walk\-Extracted/issues <https://github.com/jandrew/Data-Walk-Extracted/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Support cloning through class instance nodes (can should you even do this?)
.Sp
\&\fB2.\fR Support cloning through CodeRef nodes
.Sp
\&\fB3.\fR Support cloning through \s-1REF\s0 nodes
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund.
.SH "Dependencies"
.IX Header "Dependencies"
.RS 4
version \- 0.77
.Sp
utf8
.Sp
MooseX::Types
.Sp
Moose::Role
.Sp
.RS 4
\&\fBrequires\fR
.IP "_process_the_data" 4
.IX Item "_process_the_data"
.PD 0
.IP "_dispatch_method" 4
.IX Item "_dispatch_method"
.IP "_get_had_secondary" 4
.IX Item "_get_had_secondary"
.RE
.RS 4
.PD
.Sp
Data::Walk::Extracted
.Sp
Data::Walk::Extracted::Dispatch
.RE
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Clone \- clone
.Sp
Log::Shiras::Unhide \- Can use to unhide '###InternalExtracteDClonE' tags
.Sp
Log::Shiras::TapWarn \- to manage the output of exposed '###InternalExtracteDClonE' lines
.Sp
Data::Dumper \- used in the '###InternalExtracteDGrafT' lines
.RE
