.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spritz 3"
.TH Spritz 3 "2017-03-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Spritz \- Spritz stream cipher/hash/MAC/AEAD/CSPRNG family
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Crypt::Spritz;
\&
\& # see the commented examples in their respective classes,
\& # but basically
\&
\& my $cipher = new Crypt::Spritz::Cipher::XOR $key, $iv;
\& $ciphertext = $cipher\->crypt ($cleartext);
\&
\& my $cipher = new Crypt::Spritz::Cipher $key, $iv;
\& $ciphertext  = $cipher\->encrypt ($cleartext);
\& # $cleartext = $cipher\->decrypt ($ciphertext);
\&
\& my $hasher = new Crypt::Spritz::Hash;
\& $hasher\->add ($data);
\& $digest = $hasher\->finish;
\&
\& my $hasher = new Crypt::Spritz::MAC $key;
\& $hasher\->add ($data);
\& $mac = $hasher\->finish;
\&
\& my $prng = new Crypt::Spritz::PRNG $entropy;
\& $prng\->add ($additional_entropy);
\& $keydata = $prng\->get (32);
\&
\& my $aead = new Crypt::Spritz::AEAD::XOR $key;
\& $aead\->nonce ($counter);
\& $aead\->associated_data ($header);
\& $ciphertext = $aead\->crypt ($cleartext);
\& $mac = $aead\->mac;
\&
\& my $aead = new Crypt::Spritz::AEAD $key;
\& $aead\->nonce ($counter);
\& $aead\->associated_data ($header);
\& $ciphertext  = $aead\->encrypt ($cleartext);
\& # $cleartext = $aead\->decrypt ($ciphertext);
\& $mac = $aead\->mac;
.Ve
.SH "WARNING"
.IX Header "WARNING"
The best known result (early 2017) against Spritz is a distinguisher
attack on 2**44 outputs with multiple keys/IVs, and on 2**60 outputs with
a single key (see doi:10.1007/978\-3\-662\-52993\-5_4 for details). These are
realistic attacks, so Spritz needs to be considered broken, although for
low data applications it should still be useful.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the Spritz spongelike function (with N=256), the
spiritual successor of \s-1RC4\s0 developed by Ron Rivest and Jacob Schuldt.
.PP
Its strength is extreme versatility (you get a stream cipher, a hash, a
\&\s-1MAC,\s0 a \s-1DRBG/CSPRNG,\s0 an authenticated encryption block/stream cipher and
more) and extremely simple and small code (encryption and authentication
can be had in 1KB of compiled code on amd64, which isn't an issue for most
uses in Perl, but is useful in embedded situations, or e.g. when doing
crypto using javascript in a browser and communicating with Perl).
.PP
Its weakness is its relatively slow speed (encryption is a few times
slower than \s-1RC4\s0 or \s-1AES,\s0 hashing many times slower than \s-1SHA\-3,\s0 although
this might be reversed on an 8\-bit\-cpu) and the fact that it is totally
unproven in the field (as of this writing, the cipher was just a few
months old), so it can't be called production-ready.
.PP
All the usual caveats regarding stream ciphers apply \- never repeat your
key, never repeat your nonce and so on \- you should have some basic
understanding of cryptography before using this cipher in your own
designs.
.PP
The Spritz base class is not meant for end users. To make usage simpler
and safer, a number of convenience classes are provided for typical
end-user tasks:
.PP
.Vb 7
\&   random number generation \- Crypt::Spritz::PRNG
\&   hashing                  \- Crypt::Spritz::Hash
\&   message authentication   \- Crypt::Spritz::MAC
\&   encryption               \- Crypt::Spritz::Cipher::XOR
\&   encryption               \- Crypt::Spritz::Cipher
\&   authenticated encryption \- Crypt::Spritz::AEAD::XOR
\&   authenticated encryption \- Crypt::Spritz::AEAD
.Ve
.SS "\s-1THE\s0 Crypt::Spritz \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz CLASS"
This class implements most of the Spritz primitives. To use it effectively
you should understand them, for example, by reading the Spritz
paper <http://people.csail.mit.edu/rivest/pubs/RS14.pdf>, especially
pp. 5\-6.
.PP
The Spritz primitive corresponding to the Perl method is given as
comment.
.ie n .IP "$spritz = new Crypt::Spritz   # InitializeState" 4
.el .IP "\f(CW$spritz\fR = new Crypt::Spritz   # InitializeState" 4
.IX Item "$spritz = new Crypt::Spritz # InitializeState"
Creates and returns a new, initialised Spritz state.
.ie n .IP "$spritz\->init                 # InitializeState" 4
.el .IP "\f(CW$spritz\fR\->init                 # InitializeState" 4
.IX Item "$spritz->init # InitializeState"
Initialises the Spritz state again, throwing away the previous state.
.ie n .IP "$another_spritz = $spritz\->clone" 4
.el .IP "\f(CW$another_spritz\fR = \f(CW$spritz\fR\->clone" 4
.IX Item "$another_spritz = $spritz->clone"
Make an exact copy of the spritz state. This method can be called on all
of the objects in this module, but is documented separately to give some
cool usage examples.
.ie n .IP "$spritz\->update               # Update" 4
.el .IP "\f(CW$spritz\fR\->update               # Update" 4
.IX Item "$spritz->update # Update"
.PD 0
.ie n .IP "$spritz\->whip ($r)            # Whip" 4
.el .IP "\f(CW$spritz\fR\->whip ($r)            # Whip" 4
.IX Item "$spritz->whip ($r) # Whip"
.ie n .IP "$spritz\->crush                # Crush" 4
.el .IP "\f(CW$spritz\fR\->crush                # Crush" 4
.IX Item "$spritz->crush # Crush"
.ie n .IP "$spritz\->shuffle              # Shuffle" 4
.el .IP "\f(CW$spritz\fR\->shuffle              # Shuffle" 4
.IX Item "$spritz->shuffle # Shuffle"
.ie n .IP "$spritz\->output               # Output" 4
.el .IP "\f(CW$spritz\fR\->output               # Output" 4
.IX Item "$spritz->output # Output"
.PD
Calls the Spritz primitive ovf the same name \- these are not normally
called manually.
.ie n .IP "$spritz\->absorb ($I)          # Absorb" 4
.el .IP "\f(CW$spritz\fR\->absorb ($I)          # Absorb" 4
.IX Item "$spritz->absorb ($I) # Absorb"
Absorbs the given data into the state (usually used for key material,
nonces, IVs messages to be hashed and so on).
.ie n .IP "$spritz\->absorb_stop          # AbsorbStop" 4
.el .IP "\f(CW$spritz\fR\->absorb_stop          # AbsorbStop" 4
.IX Item "$spritz->absorb_stop # AbsorbStop"
Absorbs a special stop symbol \- this is usually used as delimiter between
multiple strings to be absorbed, to thwart extension attacks.
.ie n .IP "$spritz\->absorb_and_stop ($I)" 4
.el .IP "\f(CW$spritz\fR\->absorb_and_stop ($I)" 4
.IX Item "$spritz->absorb_and_stop ($I)"
This is a convenience function that simply calls \f(CW\*(C`absorb\*(C'\fR followed by
\&\f(CW\*(C`absorb_stop\*(C'\fR.
.ie n .IP "$octet = $spritz\->drip        # Drip" 4
.el .IP "\f(CW$octet\fR = \f(CW$spritz\fR\->drip        # Drip" 4
.IX Item "$octet = $spritz->drip # Drip"
Squeezes out a single byte from the state.
.ie n .IP "$octets = $spritz\->squeeze ($len) # Squeeze" 4
.el .IP "\f(CW$octets\fR = \f(CW$spritz\fR\->squeeze ($len) # Squeeze" 4
.IX Item "$octets = $spritz->squeeze ($len) # Squeeze"
Squeezes out the requested number of bytes from the state \- this is usually
.SS "\s-1THE\s0 Crypt::Spritz::PRNG \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::PRNG CLASS"
This class implements a Pseudorandom Number Generatore (\fB\s-1PRNG\s0\fR),
sometimes also called a Deterministic Random Bit Generator (\fB\s-1DRBG\s0\fR). In
fact, it is even cryptographically secure, making it a \fB\s-1CSPRNG\s0\fR.
.PP
Typical usage as a random number generator involves creating a \s-1PRNG\s0
object with a seed of your choice, and then fetching randomness via
\&\f(CW\*(C`get\*(C'\fR:
.PP
.Vb 2
\&   # create a PRNG object, use a seed string of your choice
\&   my $prng = new Crypt::Spritz::PRNG $seed;
\&
\&   # now call get as many times as you wish to get binary randomness
\&   my $some_randomness = $prng\->get (17);
\&   my moree_randomness = $prng\->get (5000);
\&   ...
.Ve
.PP
Typical usage as a cryptographically secure random number generator is to
feed in some secret entropy (32 octets/256 bits are commonly considered
enough), for example from \f(CW\*(C`/dev/random\*(C'\fR or \f(CW\*(C`/dev/urandom\*(C'\fR, and then
generate some key material.
.PP
.Vb 2
\&   # create a PRNG object
\&   my $prng = new Crypt::Spritz::PRNG;
\&
\&   # seed some entropy (either via \->add or in the constructor)
\&   $prng\->add ($some_secret_highly_entropic_string);
\&
\&   # now call get as many times as you wish to get
\&   # hard to guess binary randomness
\&   my $key1 = $prng\->get (32);
\&   my $key2 = $prng\->get (16);
\&   ...
\&
\&   # for long running programs, it is advisable to
\&   # reseed the PRNG from time to time with new entropy
\&   $prng\->add ($some_more_entropy);
.Ve
.ie n .IP "$prng = new Crypt::Spritz::PRNG [$seed]" 4
.el .IP "\f(CW$prng\fR = new Crypt::Spritz::PRNG [$seed]" 4
.IX Item "$prng = new Crypt::Spritz::PRNG [$seed]"
Creates a new random number generator object. If \f(CW$seed\fR is given, then
the \f(CW$seed\fR is added to the internal state as if by a call to \f(CW\*(C`add\*(C'\fR.
.ie n .IP "$prng\->add ($entropy)" 4
.el .IP "\f(CW$prng\fR\->add ($entropy)" 4
.IX Item "$prng->add ($entropy)"
Adds entropy to the internal state, thereby hopefully making it harder
to guess. Good sources for entropy are irregular hardware events, or
randomness provided by \f(CW\*(C`/dev/urandom\*(C'\fR or \f(CW\*(C`/dev/random\*(C'\fR.
.Sp
The design of the Spritz \s-1PRNG\s0 should make it strong against attacks where
the attacker controls all the entropy, so it should be safe to add entropy
from untrusted sources \- more is better than less if you need a \s-1CSPRNG.\s0
.Sp
For use as \s-1PRNG,\s0 of course, this matters very little.
.ie n .IP "$octets = $prng\->get ($length)" 4
.el .IP "\f(CW$octets\fR = \f(CW$prng\fR\->get ($length)" 4
.IX Item "$octets = $prng->get ($length)"
Generates and returns \f(CW$length\fR random octets as a string.
.SS "\s-1THE\s0 Crypt::Spritz::Hash \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::Hash CLASS"
This implements the Spritz digest/hash algorithm. It works very similar to
other digest modules on \s-1CPAN,\s0 such as Digest::SHA3.
.PP
Typical use for hashing:
.PP
.Vb 2
\&   # create hasher object
\&   my $hasher = new Crypt::Spritz::Hash;
\&
\&   # now feed data to be hashed into $hasher
\&   # in as few or many calls as required
\&   $hasher\->add ("Some data");
\&   $hasher\->add ("Some more");
\&
\&   # extract the hash \- the object is not usable afterwards
\&   my $digest = $hasher\->finish (32);
.Ve
.ie n .IP "$hasher = new Crypt::Spritz::Hash" 4
.el .IP "\f(CW$hasher\fR = new Crypt::Spritz::Hash" 4
.IX Item "$hasher = new Crypt::Spritz::Hash"
Creates a new hasher object.
.ie n .IP "$hasher\->add ($data)" 4
.el .IP "\f(CW$hasher\fR\->add ($data)" 4
.IX Item "$hasher->add ($data)"
Adds data to be hashed into the hasher state. It doesn't matter whether
you pass your data in in one go or split it up, the hash will be the same.
.ie n .IP "$digest = $hasher\->finish ($length)" 4
.el .IP "\f(CW$digest\fR = \f(CW$hasher\fR\->finish ($length)" 4
.IX Item "$digest = $hasher->finish ($length)"
Calculates a hash digest of the given length and return it. The object
cannot sensibly be used for further hashing afterwards.
.Sp
Typical digest lengths are 16 and 32, corresponding to 128 and 256 bit
digests, respectively.
.ie n .IP "$another_hasher = $hasher\->clone" 4
.el .IP "\f(CW$another_hasher\fR = \f(CW$hasher\fR\->clone" 4
.IX Item "$another_hasher = $hasher->clone"
Make an exact copy of the hasher state. This can be useful to generate
incremental hashes, for example.
.Sp
Example: generate a hash for the data already fed into the hasher, by keeping
the original hasher for further \f(CW\*(C`add\*(C'\fR calls and calling \f(CW\*(C`finish\*(C'\fR on a \f(CW\*(C`clone\*(C'\fR.
.Sp
.Vb 1
\&   my $intermediate_hash = $hasher\->clone\->finish;
.Ve
.Sp
Example: hash 64KiB of data, and generate a hash after every kilobyte that
is over the full data.
.Sp
.Vb 1
\&   my $hasher = new Crypt::Spritz::Hash;
\&
\&   for (0..63) {
\&      my $kib = "x" x 1024; # whatever data
\&
\&      $hasher\->add ($kib);
\&
\&      my $intermediate_hash = $hasher\->clone\->finish;
\&      ...
\&   }
.Ve
.Sp
These kind of intermediate hashes are sometimes used in communications
protocols to protect the integrity of the data incrementally, e.g. to
detect errors early, while still having a complete hash at the end of a
transfer.
.SS "\s-1THE\s0 Crypt::Spritz::MAC \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::MAC CLASS"
This implements the Spritz Message Authentication Code algorithm. It works
very similar to other digest modules on \s-1CPAN,\s0 such as Digest::SHA3, but
implements an authenticated digest (like Digest::HMAC).
.PP
\&\fIAuthenticated\fR means that, unlike Crypt::Spritz::Hash, where
everybody can verify and recreate the hash value for some data, with a
\&\s-1MAC,\s0 knowledge of the (hopefully) secret key is required both to create
and to verify the digest.
.PP
Typical use for hashing is almost the same as with Crypt::Spritz::MAC,
except a key (typically 16 or 32 octets) is provided to the constructor:
.PP
.Vb 2
\&   # create hasher object
\&   my $hasher = new Crypt::Spritz::Mac $key;
\&
\&   # now feed data to be hashed into $hasher
\&   # in as few or many calls as required
\&   $hasher\->add ("Some data");
\&   $hasher\->add ("Some more");
\&
\&   # extract the mac \- the object is not usable afterwards
\&   my $mac = $hasher\->finish (32);
.Ve
.ie n .IP "$hasher = new Crypt::Spritz::MAC $key" 4
.el .IP "\f(CW$hasher\fR = new Crypt::Spritz::MAC \f(CW$key\fR" 4
.IX Item "$hasher = new Crypt::Spritz::MAC $key"
Creates a new hasher object. The \f(CW$key\fR can be of any length, but 16 and
32 (128 and 256 bit) are customary.
.ie n .IP "$hasher\->add ($data)" 4
.el .IP "\f(CW$hasher\fR\->add ($data)" 4
.IX Item "$hasher->add ($data)"
Adds data to be hashed into the hasher state. It doesn't matter whether
you pass your data in in one go or split it up, the hash will be the same.
.ie n .IP "$mac = $hasher\->finish ($length)" 4
.el .IP "\f(CW$mac\fR = \f(CW$hasher\fR\->finish ($length)" 4
.IX Item "$mac = $hasher->finish ($length)"
Calculates a message code of the given length and return it. The object
cannot sensibly be used for further hashing afterwards.
.Sp
Typical digest lengths are 16 and 32, corresponding to 128 and 256 bit
digests, respectively.
.ie n .IP "$another_hasher = $hasher\->clone" 4
.el .IP "\f(CW$another_hasher\fR = \f(CW$hasher\fR\->clone" 4
.IX Item "$another_hasher = $hasher->clone"
Make an exact copy of the hasher state. This can be useful to
generate incremental macs, for example.
.Sp
See the description for the \f(CW\*(C`Crypt::Spritz::Hash::clone\*(C'\fR method for some
examples.
.SS "\s-1THE\s0 Crypt::Spritz::Cipher::XOR \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::Cipher::XOR CLASS"
This class implements stream encryption/decryption. It doesn't implement
the standard Spritz encryption but the \s-1XOR\s0 variant (called \fBspritz-xor\fR
in the paper).
.PP
The \s-1XOR\s0 variant should be as secure as the standard variant, but
doesn't have separate encryption and decryaption functions, which saves
codesize. \s-1IT\s0 is not compatible with standard Spritz encryption, however \-
drop me a note if you want that implemented as well.
.PP
Typical use for encryption \fIand\fR decryption (code is identical for
decryption, you simply pass the encrypted data to \f(CW\*(C`crypt\*(C'\fR):
.PP
.Vb 6
\&   # create a cipher \- $salt can be a random string you send
\&   # with your message, in clear, a counter (best), or empty if
\&   # you only want to encrypt one message with the given key.
\&   # 16 or 32 octets are typical sizes for the key, for the salt,
\&   # use whatever you need to give a unique salt for every
\&   # message you encrypt with the same key.
\&
\&   my $cipher = Crypt::Spritz::Cipher::XOR $key, $salt;
\&
\&   # encrypt a message in one or more calls to crypt
\&
\&   my $encrypted;
\&
\&   $encrypted .= $cipher\->crypt ("This is");
\&   $encrypted .= $cipher\->crypt ("all very");
\&   $encrypted .= $cipher\->crypt ("secret");
\&
\&   # that\*(Aqs all
.Ve
.ie n .IP "$cipher = new Crypt::Spritz::Cipher::XOR $key[, $iv]" 4
.el .IP "\f(CW$cipher\fR = new Crypt::Spritz::Cipher::XOR \f(CW$key\fR[, \f(CW$iv\fR]" 4
.IX Item "$cipher = new Crypt::Spritz::Cipher::XOR $key[, $iv]"
Creates a new cipher object usable for encryption and decryption. The
\&\f(CW$key\fR must be provided, the initial vector \f(CW$IV\fR is optional.
.Sp
Both \f(CW$key\fR and \f(CW$IV\fR can be of any length. Typical lengths for the
\&\f(CW$key\fR are 16 (128 bit) or 32 (256 bit), while the \f(CW$IV\fR simply needs to
be long enough to distinguish repeated uses of tghe same key.
.ie n .IP "$encrypted = $cipher\->crypt ($cleartext)" 4
.el .IP "\f(CW$encrypted\fR = \f(CW$cipher\fR\->crypt ($cleartext)" 4
.IX Item "$encrypted = $cipher->crypt ($cleartext)"
.PD 0
.ie n .IP "$cleartext = $cipher\->crypt ($encrypted)" 4
.el .IP "\f(CW$cleartext\fR = \f(CW$cipher\fR\->crypt ($encrypted)" 4
.IX Item "$cleartext = $cipher->crypt ($encrypted)"
.PD
Encrypt or decrypt a piece of a message. This can be called as many times
as you want, and the message can be split into as few or many pieces as
required without affecting the results.
.ie n .IP "$cipher\->crypt_inplace ($cleartext_or_ciphertext)" 4
.el .IP "\f(CW$cipher\fR\->crypt_inplace ($cleartext_or_ciphertext)" 4
.IX Item "$cipher->crypt_inplace ($cleartext_or_ciphertext)"
Same as \f(CW\*(C`crypt\*(C'\fR, except it \fImodifies the argument in-place\fR.
.ie n .IP "$another_cipher = $cipher\->clone" 4
.el .IP "\f(CW$another_cipher\fR = \f(CW$cipher\fR\->clone" 4
.IX Item "$another_cipher = $cipher->clone"
Make an exact copy of the cipher state. This can be useful to cache states
for reuse later, for example, to avoid expensive key setups.
.Sp
While there might be use cases for this feature, it makes a lot more sense
for \f(CW\*(C`Crypt::Spritz::AEAD\*(C'\fR and \f(CW\*(C`Crypt::Spritz::AEAD::XOR\*(C'\fR, as they allow
you to specify the IV/nonce separately.
.ie n .IP "$constant_32 = $cipher\->keysize" 4
.el .IP "\f(CW$constant_32\fR = \f(CW$cipher\fR\->keysize" 4
.IX Item "$constant_32 = $cipher->keysize"
.PD 0
.ie n .IP "$constant_64 = $cipher\->blocksize" 4
.el .IP "\f(CW$constant_64\fR = \f(CW$cipher\fR\->blocksize" 4
.IX Item "$constant_64 = $cipher->blocksize"
.PD
These methods are provided for Crypt::CBC compatibility and simply
return \f(CW32\fR and \f(CW64\fR, respectively.
.Sp
Note that it is pointless to use Spritz with Crypt::CBC, as Spritz is
not a block cipher and already provides an appropriate mode.
.SS "\s-1THE\s0 Crypt::Spritz::Cipher \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::Cipher CLASS"
This class is pretty much the same as the \f(CW\*(C`Crypt::Spritz::Cipher::XOR\*(C'\fR
class, with two differences: first, it implements the \*(L"standard\*(R" Spritz
encryption algorithm, and second, while this variant is easier to analyze
mathematically, there is little else to recommend it for, as it is slower,
and requires lots of code duplication code.
.PP
So unless you need to be compatible with another implementation that does
not offer the \s-1XOR\s0 variant, stick to \f(CW\*(C`Crypt::Spritz::Cipher::XOR\*(C'\fR.
.PP
All the methods from \f(CW\*(C`Crypt::Spritz::Cipher::XOR\*(C'\fR are available, except
\&\f(CW\*(C`crypt\*(C'\fR, which has been replaced by separate \f(CW\*(C`encrypt\*(C'\fR and \f(CW\*(C`decrypt\*(C'\fR
methods:
.ie n .IP "$encrypted = $cipher\->encrypt ($cleartext)" 4
.el .IP "\f(CW$encrypted\fR = \f(CW$cipher\fR\->encrypt ($cleartext)" 4
.IX Item "$encrypted = $cipher->encrypt ($cleartext)"
.PD 0
.ie n .IP "$cleartext = $cipher\->decrypt ($encrypted)" 4
.el .IP "\f(CW$cleartext\fR = \f(CW$cipher\fR\->decrypt ($encrypted)" 4
.IX Item "$cleartext = $cipher->decrypt ($encrypted)"
.PD
Really the same as \f(CW\*(C`Crypt::Spritz::Cipher::XOR\*(C'\fR, except you need separate
calls and code for encryption and decryption.
.SS "\s-1THE\s0 Crypt::Spritz::AEAD::XOR \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::AEAD::XOR CLASS"
This is the most complicated class \- it combines encryption and
message authentication into a single \*(L"authenticated encryption
mode\*(R". It is similar to using both Crypt::Spritz::Cipher::XOR and
Crypt::Spritz::MAC, but makes it harder to make mistakes in combining
them.
.PP
You can additionally provide cleartext data that will not be encrypted or
decrypted, but that is nevertheless authenticated using the \s-1MAC,\s0 which
is why this mode is called \fI\s-1AEAD\s0\fR, \fIAuthenticated Encryption with
Associated Data\fR. Associated data is usually used to any header data that
is in cleartext, but should nevertheless be authenticated.
.PP
This implementation implements the \s-1XOR\s0 variant. Just as with
Crypt::Spritz::Cipher::XOR, this means it is not compatible with
the standard mode, but uses less code and doesn't distinguish between
encryption and decryption.
.PP
Typical usage is as follows:
.PP
.Vb 4
\&   # create a new aead object
\&   # you use one object per message
\&   # key length customarily is 16 or 32
\&   my $aead = new Crypt::Spritz::AEAD::XOR $key;
\&
\&   # now you must feed the nonce. if you do not need a nonce,
\&   # you can provide the empty string, but you have to call it
\&   # after creating the object, before calling associated_data.
\&   # the nonce must be different for each usage of the $key.
\&   # a counter of some kind is good enough.
\&   # reusing a nonce with the same key completely
\&   # destroys security!
\&   $aead\->nonce ($counter);
\&
\&   # then you must feed any associated data you have. if you
\&   # do not have associated cleartext data, you can provide the empty
\&   # string, but you have to call it after nonce and before crypt.
\&   $aead\->associated_data ($header);
\&
\&   # next, you call crypt one or more times with your data
\&   # to be encrypted (opr decrypted).
\&   # all except the last call must use a length that is a
\&   # multiple of 64.
\&   # the last block can have any length.
\&   my $encrypted;
\&
\&   $encrypted .= $aead\->crypt ("1" x 64);
\&   $encrypted .= $aead\->crypt ("2" x 64);
\&   $encrypted .= $aead\->crypt ("3456");
\&
\&   # finally you can calculate the MAC for all of the above
\&   my $mac = $aead\->finish;
.Ve
.ie n .IP "$aead = new Crypt::Spritz::AEAD::XOR $key" 4
.el .IP "\f(CW$aead\fR = new Crypt::Spritz::AEAD::XOR \f(CW$key\fR" 4
.IX Item "$aead = new Crypt::Spritz::AEAD::XOR $key"
Creates a new cipher object usable for encryption and decryption.
.Sp
The \f(CW$key\fR can be of any length. Typical lengths for the \f(CW$key\fR are 16
(128 bit) or 32 (256 bit).
.Sp
After creation, you have to call \f(CW\*(C`nonce\*(C'\fR next.
.ie n .IP "$aead\->nonce ($nonce)" 4
.el .IP "\f(CW$aead\fR\->nonce ($nonce)" 4
.IX Item "$aead->nonce ($nonce)"
Provide the nonce value (nonce means \*(L"value used once\*(R"), a value the is
unique between all uses with the same key. This method \fImust\fR be called
\&\fIafter\fR \f(CW\*(C`new\*(C'\fR and \fIbefore\fR \f(CW\*(C`associated_data\*(C'\fR.
.Sp
If you only ever use a given key once, you can provide an empty nonce \-
but you still have to call the method.
.Sp
Common strategies to provide a nonce are to implement a persistent counter
or to generate a random string of sufficient length to guarantee that it
differs each time.
.Sp
The problem with counters is that you might get confused and forget
increments, and thus reuse the same sequence number. The problem with
random strings i that your random number generator might be hosed and
generate the same randomness multiple times (randomness can be very hard
to get especially on embedded devices).
.ie n .IP "$aead\->associated_data ($data)" 4
.el .IP "\f(CW$aead\fR\->associated_data ($data)" 4
.IX Item "$aead->associated_data ($data)"
Provide the associated data (cleartext data to be authenticated but not
encrypted). This method \fImust\fR be called \fIafter\fR \f(CW\*(C`nonce\*(C'\fR and \fIbefore\fR
\&\f(CW\*(C`crypt\*(C'\fR.
.Sp
If you don't have any associated data, you can provide an empty string \-
but you still have to call the method.
.Sp
Associated data is typically header data \- data anybody is allowed to
see in cleartext, but that should nevertheless be protected with an
authentication code. Typically such data is used to identify where to
forward a message to, how to find the key to decrypt the message or in
general how to interpret the encrypted part of a message.
.ie n .IP "$encrypted = $cipher\->crypt ($cleartext)" 4
.el .IP "\f(CW$encrypted\fR = \f(CW$cipher\fR\->crypt ($cleartext)" 4
.IX Item "$encrypted = $cipher->crypt ($cleartext)"
.PD 0
.ie n .IP "$cleartext = $cipher\->crypt ($encrypted)" 4
.el .IP "\f(CW$cleartext\fR = \f(CW$cipher\fR\->crypt ($encrypted)" 4
.IX Item "$cleartext = $cipher->crypt ($encrypted)"
.PD
Encrypt or decrypt a piece of a message. This can be called as many times
as you want, and the message can be split into as few or many pieces as
required without affecting the results, with one exception: All except the
last call to \f(CW\*(C`crypt\*(C'\fR needs to pass in a multiple of \f(CW64\fR octets. The
last call to \f(CW\*(C`crypt\*(C'\fR does not have this limitation.
.ie n .IP "$cipher\->crypt_inplace ($cleartext_or_ciphertext)" 4
.el .IP "\f(CW$cipher\fR\->crypt_inplace ($cleartext_or_ciphertext)" 4
.IX Item "$cipher->crypt_inplace ($cleartext_or_ciphertext)"
Same as \f(CW\*(C`crypt\*(C'\fR, except it \fImodifies the argument in-place\fR.
.ie n .IP "$another_cipher = $cipher\->clone" 4
.el .IP "\f(CW$another_cipher\fR = \f(CW$cipher\fR\->clone" 4
.IX Item "$another_cipher = $cipher->clone"
Make an exact copy of the cipher state. This can be useful to cache states
for reuse later, for example, to avoid expensive key setups.
.Sp
Example: set up a cipher state with a key, then clone and use it to
encrypt messages with different nonces.
.Sp
.Vb 1
\&   my $cipher = new Crypt::Spritz::AEAD::XOR $key;
\&
\&   my $message_counter;
\&
\&   for my $message ("a", "b", "c") {
\&      my $clone = $cipher\->clone;
\&      $clone\->nonce (pack "N", ++$message_counter);
\&      $clone\->associated_data ("");
\&      my $encrypted = $clone\->crypt ($message);
\&      ...
\&   }
.Ve
.SS "\s-1THE\s0 Crypt::Spritz::AEAD \s-1CLASS\s0"
.IX Subsection "THE Crypt::Spritz::AEAD CLASS"
This class is pretty much the same as the \f(CW\*(C`Crypt::Spritz::AEAD::XOR\*(C'\fR
class, with two differences: first, it implements the \*(L"standard\*(R" Spritz
encryption algorithm, and second, while this variant is easier to analyze
mathematically, there is little else to recommend it for, as it is slower,
and requires lots of code duplication code.
.PP
So unless you need to be compatible with another implementation that does
not offer the \s-1XOR\s0 variant, stick to \f(CW\*(C`Crypt::Spritz::AEAD::XOR\*(C'\fR.
.PP
All the methods from \f(CW\*(C`Crypt::Spritz::AEAD::XOR\*(C'\fR are available, except
\&\f(CW\*(C`crypt\*(C'\fR, which has been replaced by separate \f(CW\*(C`encrypt\*(C'\fR and \f(CW\*(C`decrypt\*(C'\fR
methods:
.ie n .IP "$encrypted = $cipher\->encrypt ($cleartext)" 4
.el .IP "\f(CW$encrypted\fR = \f(CW$cipher\fR\->encrypt ($cleartext)" 4
.IX Item "$encrypted = $cipher->encrypt ($cleartext)"
.PD 0
.ie n .IP "$cleartext = $cipher\->decrypt ($encrypted)" 4
.el .IP "\f(CW$cleartext\fR = \f(CW$cipher\fR\->decrypt ($encrypted)" 4
.IX Item "$cleartext = $cipher->decrypt ($encrypted)"
.PD
Really the same as \f(CW\*(C`Crypt::Spritz::AEAD::XOR\*(C'\fR, except you need separate
calls and code for encryption and decryption, but you have the same
limitations on usage.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
At the time of this writing, Spritz has not been through a lot of
cryptanalysis \- it might get broken tomorrow. That's true for any crypto
algo, but the probability is quite a bit higher with Spritz. Having said
that, Spritz is almost certainly safer than \s-1RC4\s0 at this time.
.PP
Nevertheless, I wouldn't protect something very expensive with it. I also
would be careful about timing attacks.
.PP
Regarding key lengths \- as has been pointed out, traditional symmetric key
lengths (128 bit, 256 bit) work fine. Longer keys will be overkill, but
you can expect keys up to about a kilobit to be effective. Longer keys are
safe to use, they will simply be a waste of time.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
As a cipher/prng, Spritz is reasonably fast (about 100MB/s on 2014 era
hardware, for comparison, \s-1AES\s0 will be more like 200MB/s).
.PP
For key setup, ivs, hashing, nonces and so on, Spritz is very slow (about
5MB/s on 2014 era hardware, which does \s-1SHA\-256\s0 at about 200MB/s).
.SH "SUPPORT FOR THE PERL MULTICORE SPECIFICATION"
.IX Header "SUPPORT FOR THE PERL MULTICORE SPECIFICATION"
This module supports the perl multicore specification
(<http://perlmulticore.schmorp.de/>) for all encryption/decryption
(non-aead > 4000 octets, aead > 400 octets), hashing/absorbing (> 400
octets) and squeezing/prng (> 4000 octets) functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://people.csail.mit.edu/rivest/pubs/RS14.pdf>.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
I also cannot give any guarantees for security, Spritz is a very new
cryptographic algorithm, and when this module was written, almost
completely unproven.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://software.schmorp.de/pkg/Crypt\-Spritz
.Ve
