.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "String::Tokenizer 3"
.TH String::Tokenizer 3 "2016-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Tokenizer \- A simple string tokenizer.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use String::Tokenizer;
\&
\&  # create the tokenizer and tokenize input
\&  my $tokenizer = String::Tokenizer\->new("((5+5) * 10)", \*(Aq+*()\*(Aq);
\&
\&  # create tokenizer
\&  my $tokenizer = String::Tokenizer\->new();
\&  # ... then tokenize the string
\&  $tokenizer\->tokenize("((5 + 5) \- 10)", \*(Aq()\*(Aq);
\&
\&  # will print \*(Aq(, (, 5, +, 5, ), \-, 10, )\*(Aq
\&  print join ", " => $tokenizer\->getTokens();
\&
\&  # create tokenizer which retains whitespace
\&  my $st = String::Tokenizer\->new(
\&                \*(Aqthis is a test with,    (significant) whitespace\*(Aq,
\&                \*(Aq,()\*(Aq,
\&                String::Tokenizer\->RETAIN_WHITESPACE
\&                );
\&
\&  # this will print:
\&  # \*(Aqthis\*(Aq, \*(Aq \*(Aq, \*(Aqis\*(Aq, \*(Aq \*(Aq, \*(Aqa\*(Aq, \*(Aq \*(Aq, \*(Aqtest\*(Aq, \*(Aq \*(Aq, \*(Aqwith\*(Aq, \*(Aq    \*(Aq, \*(Aq(\*(Aq, \*(Aqsignificant\*(Aq, \*(Aq)\*(Aq, \*(Aq \*(Aq, \*(Aqwhitespace\*(Aq
\&  print "\*(Aq" . (join "\*(Aq, \*(Aq" => $tokenizer\->getTokens()) . "\*(Aq";
\&
\&  # get a token iterator
\&  my $i = $tokenizer\->iterator();
\&  while ($i\->hasNextToken()) {
\&      my $next = $i\->nextToken();
\&      # peek ahead at the next token
\&      my $look_ahead = $i\->lookAheadToken();
\&      # ...
\&      # skip the next 2 tokens
\&      $i\->skipTokens(2);
\&      # ...
\&      # then backtrack 1 token
\&      my $previous = $i\->prevToken();
\&      # ...
\&      # get the current token
\&      my $current = $i\->currentToken();
\&      # ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A simple string tokenizer which takes a string and splits it on whitespace. It also optionally takes a string of characters to use as delimiters, and returns them with the token set as well. This allows for splitting the string in many different ways.
.PP
This is a very basic tokenizer, so more complex needs should be either addressed with a custom written tokenizer or post-processing of the output generated by this module. Basically, this will not fill everyone's needs, but it spans a gap between simple \f(CW\*(C`split / /, $string\*(C'\fR and the other options that involve much larger and complex modules.
.PP
Also note that this is not a lexical analyser. Many people confuse tokenization with lexical analysis. A tokenizer merely splits its input into specific chunks, a lexical analyzer classifies those chunks. Sometimes these two steps are combined, but not here.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew ($string, \f(CB$delimiters\fB, \f(CB$handle_whitespace\fB)\fR" 4
.IX Item "new ($string, $delimiters, $handle_whitespace)"
If you do not supply any parameters, nothing happens, the instance is just created. But if you do supply parameters, they are passed on to the \f(CW\*(C`tokenize\*(C'\fR method and that method is run. For information about those arguments, see \f(CW\*(C`tokenize\*(C'\fR below.
.IP "\fBsetDelimiter ($delimiter)\fR" 4
.IX Item "setDelimiter ($delimiter)"
This can be used to set the delimiter string, this is used by \f(CW\*(C`tokenize\*(C'\fR.
.IP "\fBhandleWhitespace ($value)\fR" 4
.IX Item "handleWhitespace ($value)"
This can be used to set the whitespace handling. It accepts one of the two constant values \f(CW\*(C`RETAIN_WHITESPACE\*(C'\fR or \f(CW\*(C`IGNORE_WHITESPACE\*(C'\fR.
.IP "\fBtokenize ($string, \f(CB$delimiters\fB, \f(CB$handle_whitespace\fB)\fR" 4
.IX Item "tokenize ($string, $delimiters, $handle_whitespace)"
Takes a \f(CW$string\fR to tokenize, and optionally a set of \f(CW$delimiter\fR characters to facilitate the tokenization and the type of whitespace handling with \f(CW$handle_whitespace\fR. The \f(CW$string\fR parameter and the \f(CW$handle_whitespace\fR parameter are pretty obvious, the \f(CW$delimiter\fR parameter is not as transparent. \f(CW$delimiter\fR is a string of characters, these characters are then separated into individual characters and are used to split the \f(CW$string\fR with. So given this string:
.Sp
.Vb 1
\&  (5 + (100 * (20 \- 35)) + 4)
.Ve
.Sp
The \f(CW\*(C`tokenize\*(C'\fR method without a \f(CW$delimiter\fR parameter would return the following comma separated list of tokens:
.Sp
.Vb 1
\&  \*(Aq(5\*(Aq, \*(Aq+\*(Aq, \*(Aq(100\*(Aq, \*(Aq*\*(Aq, \*(Aq(20\*(Aq, \*(Aq\-\*(Aq, \*(Aq35))\*(Aq, \*(Aq+\*(Aq, \*(Aq4)\*(Aq
.Ve
.Sp
However, if you were to pass the following set of delimiters \f(CW\*(C`(, )\*(C'\fR to \f(CW\*(C`tokenize\*(C'\fR, you would get the following comma separated list of tokens:
.Sp
.Vb 1
\&  \*(Aq(\*(Aq, \*(Aq5\*(Aq, \*(Aq+\*(Aq, \*(Aq(\*(Aq, \*(Aq100\*(Aq, \*(Aq*\*(Aq, \*(Aq(\*(Aq, \*(Aq20\*(Aq, \*(Aq\-\*(Aq, \*(Aq35\*(Aq, \*(Aq)\*(Aq, \*(Aq)\*(Aq, \*(Aq+\*(Aq, \*(Aq4\*(Aq, \*(Aq)\*(Aq
.Ve
.Sp
We now can differentiate the parens from the numbers, and no globbing occurs. If you wanted to allow for optionally leaving out the whitespace in the expression, like this:
.Sp
.Vb 1
\&  (5+(100*(20\-35))+4)
.Ve
.Sp
as some languages do. Then you would give this delimiter \f(CW\*(C`+*\-()\*(C'\fR to arrive at the same result.
.Sp
If you decide that whitespace is significant in your string, then you need to specify that like this:
.Sp
.Vb 5
\&  my $st = String::Tokenizer\->new(
\&                \*(Aqthis is a test with,    (significant) whitespace\*(Aq,
\&                \*(Aq,()\*(Aq,
\&                String::Tokenizer\->RETAIN_WHITESPACE
\&                );
.Ve
.Sp
A call to \f(CW\*(C`getTokens\*(C'\fR on this instance would result in the following token set.
.Sp
.Vb 1
\& \*(Aqthis\*(Aq, \*(Aq \*(Aq, \*(Aqis\*(Aq, \*(Aq \*(Aq, \*(Aqa\*(Aq, \*(Aq \*(Aq, \*(Aqtest\*(Aq, \*(Aq \*(Aq, \*(Aqwith\*(Aq, \*(Aq       \*(Aq, \*(Aq(\*(Aq, \*(Aqsignificant\*(Aq, \*(Aq)\*(Aq, \*(Aq \*(Aq, \*(Aqwhitespace\*(Aq
.Ve
.Sp
All running whitespace is grouped together into a single token, we make no attempt to split it into its individual parts.
.IP "\fBgetTokens\fR" 4
.IX Item "getTokens"
Simply returns the array of tokens. It returns an array-ref in scalar context.
.IP "\fBiterator\fR" 4
.IX Item "iterator"
Returns a \fBString::Tokenizer::Iterator\fR instance, see below for more details.
.SH "INNER CLASS"
.IX Header "INNER CLASS"
A \fBString::Tokenizer::Iterator\fR instance is returned from the \fBString::Tokenizer\fR's \f(CW\*(C`iterator\*(C'\fR method and serves as yet another means of iterating through an array of tokens. The simplest way would be to call \f(CW\*(C`getTokens\*(C'\fR and just manipulate the array yourself, or push the array into another object. However, iterating through a set of tokens tends to get messy when done manually. So here I have provided the \fBString::Tokenizer::Iterator\fR to address those common token processing idioms. It is basically a bi-directional iterator which can look ahead, skip and be reset to the beginning.
.PP
\&\fB\s-1NOTE:\s0\fR
\&\fBString::Tokenizer::Iterator\fR is an inner class, which means that only \fBString::Tokenizer\fR objects can create an instance of it. That said, if \fBString::Tokenizer::Iterator\fR's \f(CW\*(C`new\*(C'\fR method is called from outside of the \fBString::Tokenizer\fR package, an exception is thrown.
.IP "\fBnew ($tokens_array_ref)\fR" 4
.IX Item "new ($tokens_array_ref)"
This accepts an array reference of tokens and sets up the iterator. This method can only be called from within the \fBString::Tokenizer\fR package, otherwise an exception will be thrown.
.IP "\fBreset\fR" 4
.IX Item "reset"
This will reset the internal counter,
bringing it back to the beginning of the token list.
.IP "\fBhasNextToken\fR" 4
.IX Item "hasNextToken"
This will return true (1) if there are more tokens to be iterated over,
and false (0) otherwise.
.IP "\fBhasPrevToken\fR" 4
.IX Item "hasPrevToken"
This will return true (1) if the beginning of the token list has been reached, and false (0) otherwise.
.IP "\fBnextToken\fR" 4
.IX Item "nextToken"
This dispenses the next available token, and move the internal counter ahead by one.
.IP "\fBprevToken\fR" 4
.IX Item "prevToken"
This dispenses the previous token, and moves the internal counter back by one.
.IP "\fBcurrentToken\fR" 4
.IX Item "currentToken"
This returns the current token, which will match the last token retrieved by \f(CW\*(C`nextToken\*(C'\fR.
.IP "\fBlookAheadToken\fR" 4
.IX Item "lookAheadToken"
This peeks ahead one token to the next one in the list. This item will match the next item dispensed with \f(CW\*(C`nextToken\*(C'\fR. This is a non-destructive look ahead, meaning it does not alter the position of the internal counter.
.IP "\fBskipToken\fR" 4
.IX Item "skipToken"
This will jump the internal counter ahead by 1.
.IP "\fBskipTokens ($number_to_skip)\fR" 4
.IX Item "skipTokens ($number_to_skip)"
This will jump the internal counter ahead by \f(CW$number_to_skip\fR.
.IP "\fBskipTokenIfWhitespace\fR" 4
.IX Item "skipTokenIfWhitespace"
This will skip the next token if it is whitespace.
.IP "\fBskipTokensUntil ($token_to_match)\fR" 4
.IX Item "skipTokensUntil ($token_to_match)"
Given a string as a \f(CW$token_to_match\fR, this will skip all tokens until it matches that string. If the \f(CW$token_to_match\fR is never matched, then the iterator will return the internal pointer to its initial state.
.IP "\fBcollectTokensUntil ($token_to_match)\fR" 4
.IX Item "collectTokensUntil ($token_to_match)"
Given a string as a \f(CW$token_to_match\fR, this will collect all tokens until it matches that string, at which point the collected tokens will be returned. If the \f(CW$token_to_match\fR is never matched, then the iterator will return the internal pointer to its initial state and no tokens will be returned.
.SH "TO DO"
.IX Header "TO DO"
.IP "\fIInline token expansion\fR" 4
.IX Item "Inline token expansion"
The Java StringTokenizer class allows for a token to be tokenized further, therefore breaking it up more and including the results into the current token stream. I have never used this feature in this class, but I can see where it might be a useful one. This may be in the next release if it works out.
.Sp
Possibly compliment this expansion with compression as well, so for instance double quoted strings could be compressed into a single token.
.IP "\fIToken Bookmarks\fR" 4
.IX Item "Token Bookmarks"
Allow for the creation of \*(L"token bookmarks\*(R". Meaning we could tag a specific token with a label, that index could be returned to from any point in the token stream. We could mix this with a memory stack as well, so that we would have an ordering to the bookmarks as well.
.SH "BUGS"
.IX Header "BUGS"
None that I am aware of. Of course, if you find a bug, let me know, and I will be sure to fix it.
.SH "CODE COVERAGE"
.IX Header "CODE COVERAGE"
I use \fBDevel::Cover\fR to test the code coverage of my tests, below is the \fBDevel::Cover\fR report on this module's test suite.
.PP
.Vb 7
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& File                       stmt branch   cond    sub    pod   time  total
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& String/Tokenizer.pm       100.0  100.0   64.3  100.0  100.0  100.0   97.6
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& Total                     100.0  100.0   64.3  100.0  100.0  100.0   97.6
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The interface and workings of this module are based largely on the StringTokenizer class from the Java standard library.
.PP
Below is a short list of other modules that might be considered similar to this one. If this module does not suit your needs, you might look at one of these.
.IP "String::Tokeniser" 4
.IX Item "String::Tokeniser"
Along with being a tokenizer,
it also provides a means of moving through the resulting tokens,
allowing for skipping of tokens and such.
It was last updated in 2011.
.IP "Parse::Tokens" 4
.IX Item "Parse::Tokens"
This one hasn't been touched since 2001,
although it did get up to version 0.27.
It looks to lean over more towards the parser side than a basic tokenizer.
.IP "Text::Tokenizer" 4
.IX Item "Text::Tokenizer"
This is both a lexical analyzer and a tokenizer.
It also uses \s-1XS,\s0 where String::Tokenizer is pure perl.
This is something maybe to look into if you were to need a more beefy solution
than String::Tokenizer provides.
.SH "THANKS"
.IX Header "THANKS"
.IP "Thanks to Stephan Tobias for finding bugs and suggestions on whitespace handling." 4
.IX Item "Thanks to Stephan Tobias for finding bugs and suggestions on whitespace handling."
.SH "AUTHOR"
.IX Header "AUTHOR"
stevan little, <stevan@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004\-2016 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
