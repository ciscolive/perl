.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::Observable 3"
.TH Class::Observable 3 "2004-10-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Observable \- Allow other classes and objects to respond to events in yours
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Define an observable class
\& 
\&  package My::Object;
\& 
\&  use base qw( Class::Observable );
\& 
\&  # Tell all classes/objects observing this object that a state\-change
\&  # has occurred
\& 
\&  sub create {
\&     my ( $self ) = @_;
\&     eval { $self\->_perform_create() };
\&     if ( $@ ) {
\&         My::Exception\->throw( "Error saving: $@" );
\&     }
\&     $self\->notify_observers();
\&  }
\& 
\&  # Same thing, except make the type of change explicit and pass
\&  # arguments.
\& 
\&  sub edit {
\&     my ( $self ) = @_;
\&     my %old_values = $self\->extract_values;
\&     eval { $self\->_perform_edit() };
\&     if ( $@ ) {
\&         My::Exception\->throw( "Error saving: $@" );
\&     }
\&     $self\->notify_observers( \*(Aqedit\*(Aq, old_values => \e%old_values );
\&  }
\& 
\&  # Define an observer
\& 
\&  package My::Observer;
\& 
\&  sub update {
\&     my ( $class, $object, $action ) = @_;
\&     unless ( $action ) {
\&         warn "Cannot operation on [", $object\->id, "] without action";
\&         return;
\&     }
\&     $class\->_on_save( $object )   if ( $action eq \*(Aqsave\*(Aq );
\&     $class\->_on_update( $object ) if ( $action eq \*(Aqupdate\*(Aq );
\&  }
\& 
\&  # Register the observer class with all instances of the observable
\&  # class
\& 
\&  My::Object\->add_observer( \*(AqMy::Observer\*(Aq );
\& 
\&  # Register the observer class with a single instance of the
\&  # observable class
\& 
\&  my $object = My::Object\->new( \*(Aqfoo\*(Aq );
\&  $object\->add_observer( \*(AqMy::Observer\*(Aq );
\& 
\&  # Register an observer object the same way
\& 
\&  my $observer = My::Observer\->new( \*(Aqbar\*(Aq );
\&  My::Object\->add_observer( $observer );
\&  my $object = My::Object\->new( \*(Aqfoo\*(Aq );
\&  $object\->add_observer( $observer );
\& 
\&  # Register an observer using a subroutine
\& 
\&  sub catch_observation { ... }
\& 
\&  My::Object\->add_observer( \e&catch_observation );
\&  my $object = My::Object\->new( \*(Aqfoo\*(Aq );
\&  $object\->add_observer( \e&catch_observation );
\& 
\&  # Define the observable class as a parent and allow the observers to
\&  # be used by the child
\& 
\&  package My::Parent;
\& 
\&  use strict;
\&  use base qw( Class::Observable );
\& 
\&  sub prepare_for_bed {
\&      my ( $self ) = @_;
\&      $self\->notify_observers( \*(Aqprepare_for_bed\*(Aq );
\&  }
\& 
\&  sub brush_teeth {
\&      my ( $self ) = @_;
\&      $self\->_brush_teeth( time => 45 );
\&      $self\->_floss_teeth( time => 30 );
\&      $self\->_gargle( time => 30 );
\&  }
\& 
\&  sub wash_face { ... }
\& 
\& 
\&  package My::Child;
\& 
\&  use strict;
\&  use base qw( My::Parent );
\& 
\&  sub brush_teeth {
\&      my ( $self ) = @_;
\&      $self\->_wet_toothbrush();
\&  }
\& 
\&  sub wash_face { return }
\& 
\&  # Create a class\-based observer
\& 
\&  package My::ParentRules;
\& 
\&  sub update {
\&      my ( $item, $action ) = @_;
\&      if ( $action eq \*(Aqprepare_for_bed\*(Aq ) {
\&          $item\->brush_teeth;
\&          $item\->wash_face;
\&      }
\&  }
\& 
\&  My::Parent\->add_observer( _\|_PACKAGE_\|_ );
\& 
\&  $parent\->prepare_for_bed # brush, floss, gargle, and wash face
\&  $child\->prepare_for_bed  # pretend to brush, pretend to wash face
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you have ever used Java, you may have run across the
\&\f(CW\*(C`java.util.Observable\*(C'\fR class and the \f(CW\*(C`java.util.Observer\*(C'\fR
interface. With them you can decouple an object from the one or more
objects that wish to be notified whenever particular events occur.
.PP
These events occur based on a contract with the observed item. They
may occur at the beginning, in the middle or end of a method. In
addition, the object \fBknows\fR that it is being observed. It just does
not know how many or what types of objects are doing the observing. It
can therefore control when the messages get sent to the obsevers.
.PP
The behavior of the observers is up to you. However, be aware that we
do not do any error handling from calls to the observers. If an
observer throws a \f(CW\*(C`die\*(C'\fR, it will bubble up to the observed item and
require handling there. So be careful.
.PP
Throughout this documentation we refer to an 'observed item' or
\&'observable item'. This ambiguity refers to the fact that both a class
and an object can be observed. The behavior when notifying observers
is identical. The only difference comes in which observers are
notified. (See \*(L"Observable Classes and Objects\*(R" for more
information.)
.SS "Observable Classes and Objects"
.IX Subsection "Observable Classes and Objects"
The observable item does not need to implement any extra methods or
variables. Whenever it wants to let observers know about a
state-change or occurrence in the object, it just needs to call
\&\f(CW\*(C`notify_observers()\*(C'\fR.
.PP
As noted above, whether the observed item is a class or object does
not matter \*(-- the behavior is the same. The difference comes in
determining which observers are to be notified:
.IP "\(bu" 4
If the observed item is a class, all objects instantiated from that
class will use these observers. In addition, all subclasses and
objects instantiated from the subclasses will use these observers.
.IP "\(bu" 4
If the observed item is an object, only that particular object will
use its observers. Once it falls out of scope then the observers will
no longer be available. (See \*(L"Observable Objects and \s-1DESTROY\*(R"\s0 below.)
.PP
Whichever you chose, your documentation should make clear which type
of observed item observers can expect.
.PP
So given the following example:
.PP
.Vb 5
\& BEGIN {
\&     package Foo;
\&     use base qw( Class::Observable );
\&     sub new { return bless( {}, $_[0] ) }
\&     sub yodel { $_[0]\->notify_observers }
\& 
\&     package Baz;
\&     use base qw( Foo );
\&     sub yell { $_[0]\->notify_observers }
\& }
\& 
\& sub observer_a { print "Observation A from [$_[0]]\en" }
\& sub observer_b { print "Observation B from [$_[0]]\en" }
\& sub observer_c { print "Observation C from [$_[0]]\en" }
\& 
\& Foo\->add_observer( \e&observer_a );
\& Baz\->add_observer( \e&observer_b );
\& 
\& my $foo = Foo\->new;
\& print "Yodeling...\en";
\& $foo\->yodel;
\& 
\& my $baz_a = Baz\->new;
\& print "Yelling A...\en";
\& $baz_a\->yell;
\& 
\& my $baz_b = Baz\->new;
\& $baz_b\->add_observer( \e&observer_c );
\& print "Yelling B...\en";
\& $baz_b\->yell;
.Ve
.PP
You would see something like
.PP
.Vb 9
\& Yodeling...
\& Observation A from [Foo=HASH(0x80f7acc)]
\& Yelling A...
\& Observation B from [Baz=HASH(0x815c2b4)]
\& Observation A from [Baz=HASH(0x815c2b4)]
\& Yelling B...
\& Observation C from [Baz=HASH(0x815c344)]
\& Observation B from [Baz=HASH(0x815c344)]
\& Observation A from [Baz=HASH(0x815c344)]
.Ve
.PP
And since \f(CW\*(C`Bar\*(C'\fR is a child of \f(CW\*(C`Foo\*(C'\fR and each has one class-level
observer, running either:
.PP
.Vb 2
\& my @observers = Baz\->get_observers();
\& my @observers = $baz_a\->get_observers();
.Ve
.PP
would return a two-item list. The first item would be the
\&\f(CW\*(C`observer_b\*(C'\fR code reference, the second the \f(CW\*(C`observer_a\*(C'\fR code
reference. Running:
.PP
.Vb 1
\& my @observers = $baz_b\->get_observers();
.Ve
.PP
would return a three-item list, including the observer for that
specific object (\f(CW\*(C`observer_c\*(C'\fR coderef) as well as from its class
(Baz) and the parent (Foo) of its class.
.SS "Observers"
.IX Subsection "Observers"
There are three types of observers: classes, objects, and
subroutines. All three respond to events when \f(CW\*(C`notify_observers()\*(C'\fR is
called from an observable item. The differences among the three are
are:
.IP "\(bu" 4
A class or object observer must implement a method \f(CW\*(C`update()\*(C'\fR which
is called when a state-change occurs. The name of the subroutine
observer is irrelevant.
.IP "\(bu" 4
A class or object observer must take at least two arguments: itself
and the observed item. The subroutine observer is obligated to take
only one argument, the observed item.
.Sp
Both types of observers may also take an action name and a hashref of
parameters as optional arguments. Whether these are used depends on
the observed item.
.IP "\(bu" 4
Object observers can maintain state between responding to
observations.
.PP
Examples:
.PP
\&\fBSubroutine observer\fR:
.PP
.Vb 6
\& sub respond {
\&     my ( $item, $action, $params ) = @_;
\&     return unless ( $action eq \*(Aqupdate\*(Aq );
\&     # ...
\& }
\& $observable\->add_observer( \e&respond );
.Ve
.PP
\&\fBClass observer\fR:
.PP
.Vb 1
\& package My::ObserverC;
\& 
\& sub update {
\&     my ( $class, $item, $action, $params ) = @_;
\&     return unless ( $action eq \*(Aqupdate\*(Aq );
\&     # ...
\& }
.Ve
.PP
\&\fBObject observer\fR:
.PP
.Vb 1
\& package My::ObserverO;
\& 
\& sub new {
\&     my ( $class, $type ) = @_;
\&     return bless ( { type => $type }, $class );
\& }
\& 
\& sub update {
\&     my ( $self, $item, $action, $params ) = @_;
\&     return unless ( $action eq $self\->{type} );
\&     # ...
\& }
.Ve
.SS "Observable Objects and \s-1DESTROY\s0"
.IX Subsection "Observable Objects and DESTROY"
Previous versions of this module had a problem with maintaining
references to observable objects/coderefs. As a result they'd never be
destroyed. As of 1.04 we're using weak references with \f(CW\*(C`weaken\*(C'\fR in
Scalar::Util so this shouldn't be a problem any longer.
.SH "METHODS"
.IX Header "METHODS"
.SS "Observed Item Methods"
.IX Subsection "Observed Item Methods"
\&\fBnotify_observers( [ \f(CB$action\fB, \f(CB@params\fB ] )\fR
.PP
Called from the observed item, this method sends a message to all
observers that a state-change has occurred. The observed item can
optionally include additional information about the type of change
that has occurred and any additional parameters \f(CW@params\fR which get
passed along to each observer. The observed item should indicate in
its \s-1API\s0 what information will be passed along to the observers in
\&\f(CW$action\fR and \f(CW@params\fR.
.PP
Returns: Nothing
.PP
Example:
.PP
.Vb 10
\& sub remove {
\&     my ( $self ) = @_;
\&     eval { $self\->_remove_item_from_datastore };
\&     if ( $@ ) {
\&         $self\->notify_observers( \*(Aqremove\-fail\*(Aq, error_message => $@ );
\&     }
\&     else {
\&         $self\->notify_observers( \*(Aqremove\*(Aq );
\&     }
\& }
.Ve
.PP
\&\fBadd_observer( \f(CB@observers\fB )\fR
.PP
Adds the one or more observers (\f(CW@observer\fR) to the observed
item. Each observer can be a class name, object or subroutine \*(-- see
\&\*(L"Types of Observers\*(R".
.PP
Returns: The number of observers now observing the item.
.PP
Example:
.PP
.Vb 4
\& # Add a salary check (as a subroutine observer) for a particular
\& # person
\& my $person = Person\->fetch( 3843857 );
\& $person\->add_observer( \e&salary_check );
\& 
\& # Add a salary check (as a class observer) for all people
\& Person\->add_observer( \*(AqValidate::Salary\*(Aq );
\& 
\& # Add a salary check (as an object observer) for all people
\& my $salary_policy = Company::Policy::Salary\->new( \*(Aqpretax\*(Aq );
\& Person\->add_observer( $salary_policy );
.Ve
.PP
\&\fBdelete_observer( \f(CB@observers\fB )\fR
.PP
Removes the one or more observers (\f(CW@observer\fR) from the observed
item. Each observer can be a class name, object or subroutine \*(-- see
\&\*(L"Types of Observers\*(R".
.PP
Note that this only deletes each observer from the observed item
itself. It does not remove observer from any parent
classes. Therefore, if an observer is not registered directly with the
observed item nothing will be removed.
.PP
Returns: The number of observers now observing the item.
.PP
Examples:
.PP
.Vb 2
\& # Remove a class observer from an object
\& $person\->delete_observer( \*(AqLech::Ogler\*(Aq );
\& 
\& # Remove an object observer from a class
\& Person\->delete_observer( $salary_policy );
.Ve
.PP
\&\fB\fBdelete_all_observers()\fB\fR
.PP
Removes all observers from the observed item.
.PP
Note that this only deletes observers registered directly with the
observed item. It does not clear out observers from any parent
classes.
.PP
\&\fB\s-1WARNING\s0\fR: This method was renamed from \f(CW\*(C`delete_observers\*(C'\fR. The
\&\f(CW\*(C`delete_observers\*(C'\fR call still works but is deprecated and will
eventually be removed.
.PP
Returns: The number of observers removed.
.PP
Example:
.PP
.Vb 1
\& Person\->delete_all_observers();
.Ve
.PP
\&\fB\fBget_observers()\fB\fR
.PP
Returns all observers for an observed item, as well as the observers
for its class and parents as applicable. See \*(L"Observable Classes and
Objects\*(R" for more information.
.PP
Returns: list of observers.
.PP
Example:
.PP
.Vb 8
\& my @observers = Person\->get_observers;
\& foreach my $o ( @observers ) {
\&     print "Observer is a: ";
\&     print "Class"      unless ( ref $o );
\&     print "Subroutine" if ( ref $o eq \*(AqCODE\*(Aq );
\&     print "Object"     if ( ref $o and ref $o ne \*(AqCODE\*(Aq );
\&     print "\en";
\& }
.Ve
.PP
\&\fBcopy_observers( \f(CB$copy_to_observable\fB )\fR
.PP
Copies all observers from one observed item to another. We get all
observers from the source, including the observers of parents. (Behind
the scenes we just use \f(CW\*(C`get_observers()\*(C'\fR, so read that for what we
copy.)
.PP
We make no effort to ensure we don't copy an observer that's already
watching the object we're copying to. If this happens you will appear
to get duplicate observations. (But it shouldn't happen often, if
ever.)
.PP
Returns: number of observers copied
.PP
Example:
.PP
.Vb 2
\& # Copy all observers of the \*(AqPerson\*(Aq class to also observe the
\& # \*(AqAddress\*(Aq class
\& 
\& Person\->copy_observers( Address );
\& 
\& # Copy all observers of a $person to also observe a particular
\& # $address
\& 
\& $person\->copy_observers( $address )
.Ve
.PP
\&\fB\fBcount_observers()\fB\fR
.PP
Counts the number of observers for an observed item, including ones
inherited from its class and/or parent classes. See \*(L"Observable
Classes and Objects\*(R" for more information.
.SS "Debugging Methods"
.IX Subsection "Debugging Methods"
Note that the debugging messages will try to get information about the
observed item if called from an object. If you have an \f(CW\*(C`id()\*(C'\fR method
in the object its value will be used in the message, otherwise it will
be described as \*(L"an instance of class Foo\*(R".
.PP
\&\fB\s-1SET_DEBUG\s0( \f(CB$bool\fB )\fR
.PP
Turn debugging on or off. If set the built-in implementation of
\&\f(CW\*(C`observer_log()\*(C'\fR will issue a warn at appropriate times during the
process.
.PP
\&\fBobserver_log( \f(CB@message\fB )\fR
.PP
Issues a \f(CW\*(C`warn\*(C'\fR if \f(CW\*(C`SET_DEBUG\*(C'\fR hsa been called with a true
value. This gets called multiple times during the registration and
notification process.
.PP
To catch the \f(CW\*(C`warn\*(C'\fR calls just override this method.
.PP
\&\fBobserver_error( \f(CB@message\fB )\fR
.PP
Issues a \f(CW\*(C`die\*(C'\fR if we catch an exception when notifying observers. To
catch the \f(CW\*(C`die\*(C'\fR and do something else with it just override this
method.
.SH "RESOURCES"
.IX Header "RESOURCES"
APIs for \f(CW\*(C`java.util.Observable\*(C'\fR and \f(CW\*(C`java.util.Observer\*(C'\fR. (Docs
below are included with \s-1JDK 1.4\s0 but have been consistent for some
time.)
.PP
<http://java.sun.com/j2se/1.4/docs/api/java/util/Observable.html>
.PP
<http://java.sun.com/j2se/1.4/docs/api/java/util/Observer.html>
.PP
\&\*(L"Observer and Observable\*(R", Todd Sundsted,
<http://www.javaworld.com/javaworld/jw\-10\-1996/jw\-10\-howto_p.html>
.PP
\&\*(L"Java Tip 29: How to decouple the Observer/Observable object model\*(R", Albert Lopez,
<http://www.javaworld.com/javatips/jw\-javatip29_p.html>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::ISA
.PP
Class::Trigger
.PP
Aspect
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Winters <chris@cwinters.com>
