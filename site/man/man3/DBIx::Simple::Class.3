.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Simple::Class 3"
.TH DBIx::Simple::Class 3 "2014-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Simple::Class \- Advanced object construction for DBIx::Simple!
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Simple::Class is a database table/row abstraction. At the same
time it is not just a fancy representation of a table row like
DBIx::Simple::Result::RowObject. Using this module will make your
code more organized, clean and reliable
(separation of concerns + input-validation).
You will even get some more performance over plain DBIx::Simple
while keeping its' sexy features when you need them. Last but not
least, this module has no other non-CORE Perl 5.10.1 dependencies besides
DBIx::Simple and \s-1DBI\s0. See below for details.
.PP
To easily generate entire classes and save them on disk for later usage
and customization please use DBIx::Simple::Class::Schema which comes
with this distribution.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  #1. In your class representing a description of a row in a database table or view
\&  package My::Model::AdminUser;
\&  #You can extend your own common base class that extends DBIx::Simple::Class
\&  use base qw(My::Model);#My::Model is your base class.
\&
\&  #table name used in generated SQL
\&  sub TABLE { \*(Aqusers\*(Aq }  #or: use constant TABLE =>\*(Aqusers\*(Aq;
\&  
\&  sub COLUMNS {[qw(id group_id login_name login_password first_name last_name)]}
\&
\&  #used to validate params to auto\-generated field\-setters/getters 
\&  sub CHECKS{{
\&    id => { allow => qr/^\ed+$/x },
\&    group_id => { allow => qr/^1$/x, default=>1 },#admin group_id
\&    login_name => {required => 1, allow => qr/^\ep{IsAlnum}{4,12}$/x},
\&    first_name =>{required => 1, allow => \e&avery_complex_check},
\&    last_name =>{ allow => sub {
\&        #less complex inline check that modifies the input value
\&        #see Params::Check::allow and Params::Check::check
\&      }
\&    }
\&    #...
\&  }}
\&  
\&  #select only rows (instantiate objects) that meet a requirement
\&  sub WHERE { group_id=> 1} 
\&  
\&  1;#end of My::Model::AdminUser
\&
\&  #2. In a start\-up script or subroutine instantiate DBIx::Simple once
\&  DBIx::Simple::Class\->dbix( DBIx::Simple\->connect(...) );
\&
\&  #3. ...and use it everywhere in your application 
\&  use My::Model::AdminUser;
\&  my $user = $dbix\->select(
\&    My::Model::AdminUser\->TABLE, \*(Aq*\*(Aq, {login_name => \*(Aqfred\*(Aq}
\&  )\->object(\*(AqMy::Model::AdminUser\*(Aq)
\&  
\&  #or better (if SQL::Abstract is installed)
\&  my $user = My::Model::AdminUser\->select(login_name => \*(Aqfred\*(Aq); #this is cleaner
\&  
\&  #or simply get the admin\-user with id=2 
\&  My::Model::AdminUser\->find(2);
\&  
\&  #then...
\&  $user\->first_name(\*(AqFred\*(Aq)\->last_name(\*(AqFlintstone\*(Aq); #chainable setters
\&  $user\->save; #update row
\&  
\&  #add new
\&  my $user = My::Model::AdminUser\->new(
\&    login_name => \*(Aqпетър\*(Aq,
\&    first_name => \*(AqПетър\*(Aq,
\&    last_name =>\*(AqПавлов\*(Aq
\&  );
\&  $user\->save();#insert new user
\&  print "new user has id:".$user\->id;
\&  
\&  #select many users
\&  my $class = \*(AqMy::Model::AdminUser\*(Aq;
\&  my @admins = $dbix\->select(
\&    $class\->TABLE,
\&    $class\->COLUMNS,
\&    $class\->WHERE
\&  )\->objects($class);
\&  #or
\&  my @admins = $dbix\->query(
\&    $VERY_COMPLEX_SQL, @bind_variables
\&  )\->objects($class);
.Ve
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1TABLE\s0"
.IX Subsection "TABLE"
You \fBmust\fR define it in your subclass. This is the table where 
your object will store its data. Must return a string \- the table name. 
It is used  internally in \*(L"select\*(R" \*(L"update\*(R" and \*(L"insert\*(R" when saving object data.
And with little imagination you could put here some complex \s-1SQL\s0 or 
an already prepared view:
.PP
.Vb 1
\&  (SELECT * FROM users WHERE column1=\*(Aqsomething\*(Aq column2=\*(Aqother\*(Aq)
.Ve
.PP
Of course rows from such \*(L"table\*(R" can not be updated without overriding \*(L"update\*(R".
.PP
.Vb 3
\&  sub TABLE { \*(Aqusers\*(Aq }
\&  #using DBIx::Simple select() or query()
\&  dbix\->select($class\->TABLE, $class\->COLUMNS, {%{$class\->WHERE}, %$where})\->object($class);
.Ve
.SS "\s-1WHERE\s0"
.IX Subsection "WHERE"
A \s-1HASHREF\s0 suitable for passing to \*(L"select\*(R" in DBIx::Simple. 
It is also used  internally in \*(L"select\*(R" and \*(L"update\*(R". 
Values can be only simple scalars (which may be valid \s-1SQL\s0).
.PP
Default \f(CW\*(C`WHERE\*(C'\fR clause for your class. Empty "\f(CW\*(C`{}\*(C'\fR" by default.
This constant is optional.
.PP
.Vb 6
\&  package My::PublishedNote;
\&  sub WHERE { {data_type => \*(Aqnote\*(Aq,published=>1 } };
\&  #...
\&  use My::PublishedNote;
\&  #somewhere in your application
\&  my $note = My::PublishedNote\->select(id=>12345);
.Ve
.SS "\s-1COLUMNS\s0"
.IX Subsection "COLUMNS"
You \fBmust\fR define it in your subclass. 
It must return an \s-1ARRAYREF\s0 with table columns to which the data is written.
It is used  in \*(L"select\*(R" in DBIx::Simple when retrieving a row from the database 
and when saving object data. This list is also used to generate specific 
getters and setters for each data-field.
.PP
.Vb 3
\&  sub COLUMNS { [qw(id cid user_id tstamp sessiondata)] };
\&  # in select()
\&  dbix\->select($class\->TABLE, $class\->COLUMNS, {%{$class\->WHERE}, %$where})\->object($class);
.Ve
.PP
In case you have table columns that collide with some of the methods defined in this class like \*(L"data\*(R",
\&\*(L"save\*(R" etc., you can define aliases that will be used as method names. 
See \*(L"\s-1ALIASES\*(R"\s0.
.SS "\s-1CHECKS\s0"
.IX Subsection "CHECKS"
You \fBmust\fR define this subroutine/constant in your class and put in it your
\&\f(CW$_CHECKS\fR. 
\&\f(CW$_CHECKS\fR is a \s-1HASHREF\s0 that must conform to the syntax supported by \*(L"Template\*(R" in Params::Check.
.PP
.Vb 1
\&  sub CHECKS{$_CHECKS}
.Ve
.SS "\s-1PRIMARY_KEY\s0"
.IX Subsection "PRIMARY_KEY"
The column that will be used to uniquely recognise your object from others 
in the same table. Default: 'id'.
.PP
.Vb 3
\&    use constant PRIMARY_KEY => \*(Aqproduct_id\*(Aq;
\&    #or simply
\&    sub PRIMARY_KEY {\*(Aqproduct_id\*(Aq}
.Ve
.SS "\s-1ALIASES\s0"
.IX Subsection "ALIASES"
In case you have table columns that collide with some of the package methods like \*(L"data\*(R",
\&\*(L"save\*(R" etc., you can define aliases that will be used as method names.
.PP
You are free to define your own getters/setter for fields. They will not be overridden. 
All they need to do is to check the validity of the input and put the changed value in 
\&\f(CW\*(C`$self\->{data}\*(C'\fR.
.PP
.Vb 3
\&  #in you class
\&  package My::Collision;
\&  use base qw(DBIx::Simple::Class);
\&
\&  use constant TABLE   => \*(Aqcollision\*(Aq;
\&  use constant COLUMNS => [qw(id data)];
\&  use constant WHERE   => {};
\&  use constant ALIASES => {data => \*(Aqcolumn_data\*(Aq};
\&
\&  #CHECKS are on columns
\&  use constant CHECKS => {
\&    id   => {allow   => qr/^\ed+$/x},
\&    data => {default => \*(Aq\*(Aq,}           #that\*(Aqs ok
\&  };
\&  1;
\&  #usage
\&  my $coll = My::Collision\->new(data => \*(Aqsome text\*(Aq);
\&  #or
\&  my $coll = My::Collision\->query(\*(Aqselect * from collision where id=1\*(Aq);
\&  $coll\->column_data(\*(Aqchanged\*(Aq)\->save;
\&  #or
\&  $coll\->data(data=>\*(Aqchanged\*(Aq)\->save;
\&  #...
\&  $coll\->column_data; #returns \*(Aqchanged\*(Aq
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "dbix"
.IX Subsection "dbix"
This is a class attribute, shared among all subclasses of DBIx::Simple::Class. 
This is an DBIx::Simple instance and (as you guessed) provides direct access
to the current DBIx::Simple instance (with SQL::Abstract support eventually :)).
.PP
Copy/paste/override this method in your base classes
if you need more instances/connections per application.
This is already done for you if you used DBIx::Simple::Class::Schema to generate
your schema and table classes.
.PP
.Vb 2
\&  My\->dbix( DBIx::Simple\->connect($bar_dsn) );
\&  Your\->dbix( DBIx::Simple\->connect($foo_dsn) );
\&  
\&  #later in My::Note
\&  $self\->dbix\->query(...); #$bar_dsn instance
\&  #or
\&  _\|_PACKAGE_\|_\->dbix\->query(...); #$bar_dsn instance
\&  
\&  #in Your::Note...
\&  $self\->dbix\->query(...); #$foo_dsn instance
.Ve
.SS "dbh"
.IX Subsection "dbh"
Shortcut for \f(CW\*(C`$self\->dbix\->dbh\*(C'\fR.
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Flag to enable/disable debug warnings and prepared \s-1SQL\s0 dumps. 
 Influences all DBIx::Simple::Class subclasses.
.PP
.Vb 5
\&  DBIx::Simple::Class\->DEBUG(1);
\&  My::Note\->find(2)\->title(\*(AqBetter Title\*(Aq)\->save;
\&  # see in the log what methods are generated for your columns
\&  #and what SQL is thrown to the database.
\&  DBIx::Simple::Class\->DEBUG(0);#enough
.Ve
.SS "\s-1QUOTE_IDENTIFIERS\s0"
.IX Subsection "QUOTE_IDENTIFIERS"
Class attribute. If set to a true value your columns and table names will 
be quoted upon first instantiation of your subclass. When you call
 \f(CW\*(C`$self\->TABLE\*(C'\fR it will return a quoted table-name using 
 \*(L"quote_identifier\*(R" in \s-1DBI\s0. Same will happen with \*(L"\s-1COLUMNS\*(R"\s0 and \*(L"\s-1WHERE\*(R"\s0.
 This is needed when you have tables and columns with invalid identifier names.
.PP
.Vb 5
\&  package MyGoups;
\&  use base \*(AqDBIx::Simple::Class\*(Aq;  
\&  sub TABLE {\*(Aqmy groups\*(Aq}#problem \- invalid identifier name
\&  sub COLUMNS {[\*(Aqid\*(Aq,\*(Aqgroup\*(Aq]}#problem \- collides with \*(Aqgroup by\*(Aq
\&  _\|_PACKAGE_\|_\->QUOTE_IDENTIFIERS(1);#no problem now
\&  
\&  #just works
\&  MyGoups\->find(2)\->group(\*(Aqname_second\*(Aq)\->update;
.Ve
.SS "is_base_class"
.IX Subsection "is_base_class"
Class attribute.
Returns true if the class on which is called is a direct child of
DBIx::Simple::Class.
.PP
Using this method we decide to \*(L"\s-1BUILD\*(R"\s0 or not build a class before
instanciating it. We also use it to call \*(L"query\*(R" in DBIx::Simple
instead of \*(L"query\*(R" in DBIx::Simple::Class when appropriate.
See \*(L"query\*(R" in DBIx::Simple::Class.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Constructor.  
Accessors listed in \s-1COLUMNS\s0 are generated on first object construction. 
On any subsequent call field-accessors are not generated. 
Accepts named parameters or a \s-1HASHREF\s0 containing named parameters.
Sets the passed parameters as fields (if they exist) as column names.
.PP
.Vb 4
\&  my $user = My::User\->new(
\&    login_name => \*(Aqfred\*(Aq,
\&    first_name => \*(AqFred\*(Aq,
\&    last_name =>\*(AqFlintstone\*(Aq);
\&  
\&  my $user = My::User\->new({
\&    login_name => \*(Aqfred\*(Aq,
\&    first_name => \*(AqFred\*(Aq,
\&    last_name =>\*(AqFlintstone\*(Aq
\&  });#HASHREF accepted too
.Ve
.SS "new_from_dbix_simple"
.IX Subsection "new_from_dbix_simple"
A constructor called in \*(L"object\*(R" in DBIx::Simple and 
\&\*(L"objects\*(R" in DBIx::Simple. Basically makes the same as \f(CW\*(C`new()\*(C'\fR without 
checking the validity of the field values since they come from the 
database and should be valid. 
You will never ever need to call this directly but this example is provided 
to show how the DBIx::Simple::Class interacts with DBIx::Simple. 
See \*(L"Advanced_object_construction\*(R" in DBIx::Simple.
.PP
.Vb 1
\&  my $class = \*(AqMy::Model::AdminUser\*(Aq;
\&  
\&  #  ARRAY (context aware)
\&  my @admins = $dbix\->select(
\&    $class\->TABLE,
\&    $class\->COLUMNS,
\&    $class\->WHERE
\&  )\->objects($class);
\&  
\&  #  ARRAYREF (context aware)
\&  my $admins = $dbix\->select(
\&    $class\->TABLE,
\&    $class\->COLUMNS,
\&    $class\->WHERE
\&  )\->objects($class);
\&  
\&  #one row
\&  my $admin = $class\->select(id=>123});#see below
\&  
\&  My::User\->query(\*(AqSELECT * FROM users WHERE id=?\*(Aq,22)\->login_name;
\&
\&  #The above is about 3 times faster than this below
\&  $dbix\->query(\*(AqSELECT * FROM users WHERE id=?\*(Aq,2)
\&            \->object(\*(Aq:RowObject\*(Aq)\->login_name;
.Ve
.SS "\s-1BUILD\s0"
.IX Subsection "BUILD"
Class method. 
This is your real class builder. It is called in constructors only once before bless.
 It creates your accessors. Quotes identifiers if needed. You can inject your logic here 
 if you override this method. In your \f(CW\*(C`BUILD\*(C'\fR do not forget to call 
\&\f(CW\*(C`$class\->SUPER::BUILD\*(C'\fR. Take a look at the source of this class to make 
sure what exactly you need to do. You can also call this method at the end
of your class definition. It will not be called again.
.PP
.Vb 4
\&  package User;
\&  # your declarations here
\&  _\|_PACKAGE_\|_\->BUILD();
\&  1;
.Ve
.SS "query"
.IX Subsection "query"
Context aware constructor. Very convenient to use with named queries. 
Accepts exactly the same arguments as \*(L"query\*(R" in DBIx::Simple.
Depending on context fetches and returns an instance or \fIfetches and returns a list\fR 
of instances of your class on success.
Returns \f(CW\*(C`undef\*(C'\fR otherwise.
.PP
.Vb 3
\&  my $user = My::User\->query(
\&    \*(AqSELECT \*(Aq . join (\*(Aq,\*(Aq,My::User\->COLUMNS)
\&    . \*(Aq FROM \*(Aq . My::User\->TABLE.\*(Aq WHERE id=? and disabled=?\*(Aq, 12345, 0);
\&  
\&  #or
\&  my $sql = My::User\->SQL(\*(AqA_COMPLEX_SELECT\*(Aq). \*(Aq AND id=?\*(Aq
\&  my $user = My::User\->query($sql,12345)
\&  
\&  #or...
\&  my $sql = \*(AqSELECT * FROM users WHERE country_id=?\*(Aq;
\&  #same as $dbix\->query($sql,\*(Aqfr\*(Aq)\->objects(\*(AqMy::User\*(Aq);
\&  my @french_users = My::User\->query($sql,\*(Aqfr\*(Aq);
\&
\&  #same as $dbix\->query($sql,\*(Aqfr\*(Aq)\->object(\*(AqMy::User\*(Aq);
\&  my $french_user = My::User\->query($sql,\*(Aqfr\*(Aq);
.Ve
.PP
If used by your base class this method does not create a new instance.
In this case it is the same as calling \*(L"query\*(R" in DBIx::Simple.
See examples in the distribution directory.
.PP
.Vb 9
\&  use My;#your base class
\&  My\->query(qq|
\&      CREATE TABLE IF NOT EXISTS groups(
\&        id INTEGER PRIMARY KEY AUTOINCREMENT,
\&        group_name VARCHAR(12),
\&        "foo\-bar" VARCHAR(13),
\&        data TEXT
\&        )
\&  |);
.Ve
.SS "select"
.IX Subsection "select"
Context aware constructor. Does the same as
\&\f(CW\*(C`$dbix\->select($table,$columns,$where)\->object($class)\*(C'\fR. 
Note that SQL::Abstract \fBmust be installed\fR. This is the only method 
that requires it. Have in mind that our \*(L"query\*(R" is faster than this 
and you can use named queries via \*(L"\s-1SQL\*(R"\s0.
.PP
Instantiates an object or list of objects depending on context. 
Executes an \s-1SQL\s0 query based on the parameters. 
These parameters are used to construct the \f(CW\*(C`WHERE\*(C'\fR clause for the \s-1SQL\s0 \f(CW\*(C`SELECT\*(C'\fR 
statement. Prepends the class \*(L"\s-1WHERE\*(R"\s0 clause defined by you to the parameters. 
If a row is found, puts it in \*(L"data\*(R".
.PP
.Vb 2
\&    # Build your WHERE using an SQL::Abstract structure:
\&    my $user = MYDLjE::M::User\->select(id => $user_id);
.Ve
.SS "create"
.IX Subsection "create"
.Vb 4
\&  my $note = MyNote\->create(
\&      title=>\*(AqMy Title\*(Aq,
\&      description =>\*(AqThis is a great story.\*(Aq
\&    );
.Ve
.PP
Inserts a new record and returns the new object.
.SS "select_by_pk"
.IX Subsection "select_by_pk"
Constructor. 
Retrieves  a row from the \*(L"\s-1TABLE\*(R"\s0 by \*(L"\s-1PRIMARY_KEY\*(R"\s0. 
Returns an instance of your class. 
If the underlying database query was not succesfull \*(L"data\*(R" will return undef.
.PP
.Vb 5
\&    my $user = My::User\->select_by_pk(1234);
\&    unless($user\->data){
\&      $user\->data(name=>\*(AqFred Flintstone\*(Aq, username=>\*(Aqfred\*(Aq );
\&      my $id = $user\->insert();
\&    }
.Ve
.SS "find"
.IX Subsection "find"
An alias for \*(L"select_by_pk\*(R".
.PP
.Vb 1
\&    my $user = My::User\->find(1234);
.Ve
.SS "data"
.IX Subsection "data"
Common getter/setter for all \*(L"\s-1COLUMNS\*(R"\s0. 
Uses internally the specific field getter/setter for each field.
Returns a \s-1HASHREF\s0 \- name/value pairs of the fields.
.PP
.Vb 4
\&  $self\->data(title=>\*(AqMy Title\*(Aq, description =>\*(AqThis is a great story.\*(Aq);
\&  my $hash = $self\->data;
\&  #or
\&  $self\->data($self\->dbix\->select(TABLE, COLUMNS, $where)\->hash);
.Ve
.SS "save"
.IX Subsection "save"
Intelligent saver. If the object is fresh 
( not instantiated via \*(L"new_from_dbix_simple\*(R" and \*(L"select\*(R") prepares and 
executes an \f(CW\*(C`INSERT\*(C'\fR statement, otherwise preforms an \f(CW\*(C`UPDATE\*(C'\fR. 
\&\*(L"\s-1TABLE\*(R"\s0 and \*(L"\s-1COLUMNS\*(R"\s0 are used to construct the \s-1SQL.\s0 
Optionally accepts a \s-1HASH\s0 or \s-1HASHREF\s0 with column/values pairs.
\&\*(L"data\*(R" is stored as a row in \*(L"\s-1TABLE\*(R"\s0.
Returns the value of the internally performed operation. See below.
.PP
.Vb 9
\&  my $note = MyNote\->new(title=>\*(AqMy Title\*(Aq, description =>\*(AqThis is a great story.\*(Aq);
\&  #do something more...
\&  my $id = $note\->save; #insert
\&  #later..
\&  my $ok = $note\->title(\*(AqYour Title\*(Aq)\->save;#update
\&  $note\->save(description=>$note\->description.\*(Aq.. I forgot something\*(Aq);
\&  #add new record from a web\-form
\&  MyNote\->new\->save($validated_form_data);
\&  MyNote\->new($validated_form_data)\->save();
.Ve
.SS "insert"
.IX Subsection "insert"
Used internally in \*(L"save\*(R". Can be used when you are sure your object is 
not present in the table. Returns the value of the object's \*(L"\s-1PRIMARY_KEY\*(R"\s0
on success. See \*(L"last_insert_id\*(R" in DBIx::Simple.
.PP
.Vb 6
\&    my $note = MyNote\->new(
\&      title=>\*(AqMy Title\*(Aq,
\&      description =>\*(AqThis is a great story.\*(Aq
\&    );
\&    #do something more...
\&    my $last_insert_id = $note\->insert;
.Ve
.SS "update"
.IX Subsection "update"
Used internally in \*(L"save\*(R". Can be used when you are sure your object is 
retrieved from the table. Returns true on success.
.PP
.Vb 6
\&  use My::Model::AdminUser;
\&  my $user = $dbix\->query(
\&    \*(AqSELECT * FROM users WHERE login_name=?\*(Aq, \*(Aqfred\*(Aq
\&  )\->object(\*(AqMy::Model::AdminUser\*(Aq)
\&  $user\->first_name(\*(AqFred\*(Aq)\->last_name(\*(AqFlintstone\*(Aq);
\&  $user\->update;
.Ve
.SS "delete"
.IX Subsection "delete"
There is no \f(CW\*(C`delete\*(C'\fR method. This is on purpose. 
You may have different notions of \f(CW\*(C`delete()\*(C'\fR.
.PP
For each of your subclasses or in one base class for your project that 
inherits from DBIx::Simple::Class you can define your \f(CW\*(C`delete()\*(C'\fR method. 
It's easy.
.PP
.Vb 2
\&  package My::Model
\&  use base qw(DBIx::Simple::Class);
\&  
\&  sub delete {
\&    my $self = shift;
\&    my $pk = $self\->PRIMARY_KEY;
\&    $self\->dbix\->query(\*(AqDELETE FROM \*(Aq.$self\->TABLE." WHERE $pk=?", $self\->$pk);
\&  }
\&  #...
\&  
\&  package My::Model::User
\&  use base qw(My::Model);
\&  sub WHERE { deleted => 0 }
\&  #...
\&  #a different deleting
\&  sub delete {
\&    $_[0]\->deleted(1)\->update;#set deleted column to 1
\&  }
\&  1;
\&  
\&  #explicit suicide
\&  $user\->dbix\->query(\*(AqDELETE FROM users WHERE id=?\*(Aq,$user\->id);
\&  #resurrect
\&  $user\->insert;
.Ve
.SS "\s-1SQL\s0"
.IX Subsection "SQL"
A getter/setter for custom \s-1SQL\s0 code (named queries).
.PP
Class method. 
You can add key/value pairs in your class and then use them in your application.
The values can be simple strings or subroutine references.
There are already some pre-made entries in DBIx::Simple::Class that you can 
use as example implementations. Look at the source for details.
The subroutine references are executed/evaluated only once and their output is 
cached for performance.
.PP
.Vb 3
\&  package My::SiteUser;
\&  use base qw(My::User);#a subclass of DBIx::Simple::Class or My
\&  sub WHERE { {disabled => 0, group_id => 2} }
\&  
\&  #these could be very complex and retrieved from a file where you keep them!
\&  _\|_PACKAGE_\|_\->SQL(
\&    GUEST => \*(AqSELECT * FROM users WHERE login_name = \e\*(Aqguest\e\*(Aq\*(Aq,
\&    DISABLED => sub{
\&        \*(AqSELECT * FROM\*(Aq._\|_PACKAGE_\|_\->TABLE.\*(Aq WHERE disabled=?\*(Aq;
\&    }
\&    LAST_N_REGISTERED => _\|_PACKAGE_\|_\->SQL(\*(AqSELECT\*(Aq)
\&        .\*(Aq order by id desc LIMIT ?, ?\*(Aq
\&  );
\&
\&  1;
\&  # in your application
\&  $SU =\*(AqMy::SiteUser\*(Aq;
\&  my $guest = $SU\->query($SU\->SQL(\*(AqGUEST\*(Aq));
\&  my @members = $SU\->query($SU\->SQL(\*(AqSELECT\*(Aq));#allll ;)
\&  my @disabled = $SU\->query($SU\->SQL(\*(AqDISABLED\*(Aq), 1);
\&  my @enabled = $SU\->query($SU\->SQL(\*(AqDISABLED\*(Aq), 0);
.Ve
.SS "\s-1SQL_LIMIT\s0"
.IX Subsection "SQL_LIMIT"
Produces and returns a \s-1LIMIT\s0 clause \s-1SQL\s0 piece.
Currently only MySQL, PostgreSQL and SQLite are supported but writing 
your own should be fairly easy. See SQL::Abstract::Limit.
.PP
.Vb 5
\&  # LIMIT 2
\&  my $two_users = $dbix\->query(
\&    $CLASS\->SQL(\*(AqSELECT\*(Aq). \*(AqAND group_id=? ORDER BY id ASC \*(Aq.$CLASS\->SQL_LIMIT(2),
\&    $group\->id
\&  )\->objects($CLASS);
\&  
\&  # LIMIT 2 OFFSET 2
\& my $second_two_users = $dbix\->query(
\&    $CLASS\->SQL(\*(AqSELECT\*(Aq). \*(AqAND group_id=? ORDER BY id ASC \*(Aq.$CLASS\->SQL_LIMIT(2,2), 
\&    $group\->id
\&  )\->objects($CLASS);
\&
\&  # LIMIT 2 OFFSET 4
\& my $third_two_users = $dbix\->query(
\&    $CLASS\->SQL(\*(AqSELECT\*(Aq). \*(AqAND group_id=? ORDER BY id ASC \*(Aq.$CLASS\->SQL_LIMIT(2,4), 
\&    $group\->id
\&  )\->objects($CLASS);
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Please look at the test file \f(CW\*(C`t/01\-dbix\-simple\-class.t\*(C'\fR of the distribution 
for a wealth of examples.
.SH "AUTHOR"
.IX Header "AUTHOR"
Красимир Беров, \f(CW\*(C`<berov at cpan.org>\*(C'\fR
.SH "CREDITS"
.IX Header "CREDITS"
Jos Boumans for Params::Check
.PP
Juerd Waalboer for DBIx::Simple
.PP
Nate Wiger  and all contributors for SQL::Abstract
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
DBIx::Simple, \s-1DBI\s0, DBD::SQLite (for running tests only)
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to 
<https://github.com/kberov/DBIx\*(--Simple\-\-Class/issues>. 
I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBIx::Simple::Class
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
The project wiki
.Sp
<https://github.com/kberov/DBIx\*(--Simple\-\-Class/wiki>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBIx\-Simple\-Class>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBIx\-Simple\-Class>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBIx\-Simple\-Class/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Simple, Params::Check and \s-1DBI\s0 are used directly and we depend on them.
 SQL::Abstract is nice to have but not mandatory.
The modules below are used to cherry-pick ideas and re-implement some of them
in this package.
.PP
DBIx::Simple::Result::RowObject, DBIx::Simple::OO,
Ima::DBI, DBIx::Class, Data::ObjectDriver,Class::DBI, 
Class::DBI::Lite
<https://github.com/kberov/MYDLjE>
.PP
To easily generate entire classes and save them on disk for later usage
and customization please use DBIx::Simple::Class::Schema which comes
with this distribution.
.PP
To use the functionalities provided by this distribution
in a Mojolicious application try Mojolicious::Plugin::DSC.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 \- 2013 Красимир Беров (Krasimir Berov).
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
.PP
See http://www.opensource.org/licenses/artistic\-license\-2.0 for more information.
