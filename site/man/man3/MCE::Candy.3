.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MCE::Candy 3"
.TH MCE::Candy 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MCE::Candy \- Sugar methods and output iterators
.SH "VERSION"
.IX Header "VERSION"
This document describes MCE::Candy version 1.874
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a collection of sugar methods and helpful output iterators
for preserving output order.
.ie n .SH """FOR"" SUGAR METHODS"
.el .SH "``FOR'' SUGAR METHODS"
.IX Header "FOR SUGAR METHODS"
The sugar methods described below were created prior to the 1.5 release which
added \s-1MCE\s0 Models. This module is loaded automatically upon calling a \*(L"for\*(R"
method.
.ie n .SS "$mce\->forchunk ( $input_data [, { options } ], sub { ... } )"
.el .SS "\f(CW$mce\fP\->forchunk ( \f(CW$input_data\fP [, { options } ], sub { ... } )"
.IX Subsection "$mce->forchunk ( $input_data [, { options } ], sub { ... } )"
Forchunk, foreach, and forseq are sugar methods in \s-1MCE.\s0 Workers are
spawned automatically, the code block is executed in parallel, and shutdown
is called. Do not call these methods if workers must persist afterwards.
.PP
Specifying options is optional. Valid options are the same as for the
process method.
.PP
.Vb 1
\& ## Declare a MCE instance.
\&
\& my $mce = MCE\->new(
\&    max_workers => $max_workers,
\&    chunk_size  => 20
\& );
\&
\& ## Arguments inside the code block are the same as passed to user_func.
\&
\& $mce\->forchunk(\e@input_array, sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    foreach ( @{ $chunk_ref } ) {
\&       MCE\->print("$chunk_id: $_\en");
\&    }
\& });
\&
\& ## Input hash, current API available since 1.828.
\&
\& $mce\->forchunk(\e%input_hash, sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    for my $key ( keys %{ $chunk_ref } ) {
\&       MCE\->print("$chunk_id: [ $key ] ", $chunk_ref\->{$key}, "\en");
\&    }
\& });
\&
\& ## Passing chunk_size as an option.
\&
\& $mce\->forchunk(\e@input_array, { chunk_size => 30 }, sub { ... });
\& $mce\->forchunk(\e%input_hash, { chunk_size => 30 }, sub { ... });
.Ve
.ie n .SS "$mce\->foreach ( $input_data [, { options } ], sub { ... } )"
.el .SS "\f(CW$mce\fP\->foreach ( \f(CW$input_data\fP [, { options } ], sub { ... } )"
.IX Subsection "$mce->foreach ( $input_data [, { options } ], sub { ... } )"
Foreach implies chunk_size => 1 and cannot be overwritten. Thus, looping is
not necessary inside the block. Unlike forchunk above, a hash reference as
input data isn't allowed.
.PP
.Vb 3
\& my $mce = MCE\->new(
\&    max_workers => $max_workers
\& );
\&
\& $mce\->foreach(\e@input_data, sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my $row = $chunk_ref\->[0];
\&    MCE\->print("$chunk_id: $row\en");
\& });
.Ve
.ie n .SS "$mce\->forseq ( $sequence_spec [, { options } ], sub { ... } )"
.el .SS "\f(CW$mce\fP\->forseq ( \f(CW$sequence_spec\fP [, { options } ], sub { ... } )"
.IX Subsection "$mce->forseq ( $sequence_spec [, { options } ], sub { ... } )"
Sequence may be defined using an array or hash reference.
.PP
.Vb 3
\& my $mce = MCE\->new(
\&    max_workers => 3
\& );
\&
\& $mce\->forseq([ 20, 40 ], sub {
\&    my ($mce, $n, $chunk_id) = @_;
\&    my $result = \`ping 192.168.1.${n}\`;
\&    ...
\& });
\&
\& $mce\->forseq({ begin => 15, end => 10, step => \-1 }, sub {
\&    my ($mce, $n, $chunk_id) = @_;
\&    print $n, " from ", MCE\->wid, "\en";
\& });
.Ve
.PP
The \f(CW$n_seq\fR variable points to an array_ref of sequences. Chunk size defaults
to 1 when not specified.
.PP
.Vb 7
\& $mce\->forseq([ 20, 80 ], { chunk_size => 10 }, sub {
\&    my ($mce, $n_seq, $chunk_id) = @_;
\&    for my $n ( @{ $n_seq } ) {
\&       my $result = \`ping 192.168.1.${n}\`;
\&       ...
\&    }
\& });
.Ve
.SH "OUTPUT ITERATORS WITH INPUT"
.IX Header "OUTPUT ITERATORS WITH INPUT"
This module includes 2 output iterators which are useful for preserving output
order while gathering data. These cover the 2 general use cases. The chunk_id
value must be the first argument to gather. Gather must also not be called
more than once inside the block.
.SS "gather => MCE::Candy::out_iter_array( \e@array )"
.IX Subsection "gather => MCE::Candy::out_iter_array( @array )"
The example utilizes the Core \s-1API\s0 with chunking disabled. Basically, setting
chunk_size to 1.
.PP
.Vb 2
\& use MCE;
\& use MCE::Candy;
\&
\& my @results;
\&
\& my $mce = MCE\->new(
\&    chunk_size => 1, max_workers => 4,
\&    gather => MCE::Candy::out_iter_array(\e@results),
\&    user_func => sub {
\&       my ($mce, $chunk_ref, $chunk_id) = @_;
\&       $mce\->gather($chunk_id, $chunk_ref\->[0] * 2);
\&    }
\& );
\&
\& $mce\->process([ 100 .. 109 ]);
\&
\& print "@results", "\en";
\&
\& \-\- Output
\&
\& 200 202 204 206 208 210 212 214 216 218
.Ve
.PP
Chunking may be desired for thousands or more items. In other words, wanting
to reduce the overhead placed on \s-1IPC.\s0
.PP
.Vb 2
\& use MCE;
\& use MCE::Candy;
\&
\& my @results;
\&
\& my $mce = MCE\->new(
\&    chunk_size => 100, max_workers => 4,
\&    gather => MCE::Candy::out_iter_array(\e@results),
\&    user_func => sub {
\&       my ($mce, $chunk_ref, $chunk_id) = @_;
\&       my @output;
\&       foreach my $item (@{ $chunk_ref }) {
\&          push @output, $item * 2;
\&       }
\&       $mce\->gather($chunk_id, @output);
\&    }
\& );
\&
\& $mce\->process([ 100_000 .. 200_000 \- 1 ]);
\&
\& print scalar @results, "\en";
\&
\& \-\- Output
\&
\& 100000
.Ve
.ie n .SS "gather => MCE::Candy::out_iter_fh( $fh )"
.el .SS "gather => MCE::Candy::out_iter_fh( \f(CW$fh\fP )"
.IX Subsection "gather => MCE::Candy::out_iter_fh( $fh )"
Let's change things a bit and use MCE::Flow for the next 2 examples. Chunking
is not desired for the first example.
.PP
.Vb 2
\& use MCE::Flow;
\& use MCE::Candy;
\&
\& open my $fh, \*(Aq>\*(Aq, \*(Aq/tmp/foo.txt\*(Aq;
\&
\& mce_flow {
\&    chunk_size => 1, max_workers => 4,
\&    gather => MCE::Candy::out_iter_fh($fh)
\& },
\& sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    $mce\->gather($chunk_id, $chunk_ref\->[0] * 2, "\en");
\&
\& }, (100 .. 109);
\&
\& close $fh;
\&
\& \-\- Output sent to \*(Aq/tmp/foo.txt\*(Aq
\&
\& 200
\& 202
\& 204
\& 206
\& 208
\& 210
\& 212
\& 214
\& 216
\& 218
.Ve
.ie n .SS "gather => MCE::Candy::out_iter_fh( $io )"
.el .SS "gather => MCE::Candy::out_iter_fh( \f(CW$io\fP )"
.IX Subsection "gather => MCE::Candy::out_iter_fh( $io )"
Same thing, an \f(CW\*(C`IO::*\*(C'\fR object that can \f(CW\*(C`print\*(C'\fR is supported since \s-1MCE 1.845.\s0
.PP
.Vb 3
\& use IO::All;
\& use MCE::Flow;
\& use MCE::Candy;
\&
\& my $io = io(\*(Aq/tmp/foo.txt\*(Aq);  # i.e. $io\->can(\*(Aqprint\*(Aq)
\&
\& mce_flow {
\&    chunk_size => 1, max_workers => 4,
\&    gather => MCE::Candy::out_iter_fh($io)
\& },
\& sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    $mce\->gather($chunk_id, $chunk_ref\->[0] * 2, "\en");
\&
\& }, (100 .. 109);
\&
\& $io\->close;
\&
\& \-\- Output sent to \*(Aq/tmp/foo.txt\*(Aq
\&
\& 200
\& 202
\& 204
\& 206
\& 208
\& 210
\& 212
\& 214
\& 216
\& 218
.Ve
.PP
Chunking is desired for the next example due to processing many thousands.
.PP
.Vb 2
\& use MCE::Flow;
\& use MCE::Candy;
\&
\& open my $fh, \*(Aq>\*(Aq, \*(Aq/tmp/foo.txt\*(Aq;
\&
\& mce_flow {
\&    chunk_size => 100, max_workers => 4,
\&    gather => MCE::Candy::out_iter_fh( $fh )
\& },
\& sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my @output;
\&    foreach my $item (@{ $chunk_ref }) {
\&       push @output, ($item * 2) . "\en";
\&    }
\&    $mce\->gather($chunk_id, @output);
\&
\& }, (100_000 .. 200_000 \- 1);
\&
\& close $fh;
\&
\& print \-s \*(Aq/tmp/foo.txt\*(Aq, "\en";
\&
\& \-\- Output
\&
\& 700000
.Ve
.SH "OUTPUT ITERATORS WITHOUT INPUT"
.IX Header "OUTPUT ITERATORS WITHOUT INPUT"
Input data is not a requirement for using the output iterators included in this
module. The 'chunk_id' value is set uniquely and the same as 'wid' when not
processing input data.
.SS "gather => MCE::Candy::out_iter_array( \e@array )"
.IX Subsection "gather => MCE::Candy::out_iter_array( @array )"
.Vb 2
\& use MCE::Flow;
\& use MCE::Candy;
\&
\& my @results;
\&
\& mce_flow {
\&    max_workers => \*(Aqauto\*(Aq, ## Note that \*(Aqauto\*(Aq is never greater than 8
\&    gather => MCE::Candy::out_iter_array(\e@results)
\& },
\& sub {
\&    my ($mce) = @_;        ## This line is not necessary
\&                           ## Calling via module okay; e.g: MCE\->method
\&    ## Do work
\&    ## Sending a complex data structure is allowed
\&
\&    ## Output will become orderly by iterator
\&    $mce\->gather( $mce\->chunk_id, {
\&       wid => $mce\->wid, result => $mce\->wid * 2
\&    });
\& };
\&
\& foreach my $href (@results) {
\&    print $href\->{wid} .": ". $href\->{result} ."\en";
\& }
\&
\& \-\- Output
\&
\& 1: 2
\& 2: 4
\& 3: 6
\& 4: 8
\& 5: 10
\& 6: 12
\& 7: 14
\& 8: 16
.Ve
.ie n .SS "gather => MCE::Candy::out_iter_fh( $fh )"
.el .SS "gather => MCE::Candy::out_iter_fh( \f(CW$fh\fP )"
.IX Subsection "gather => MCE::Candy::out_iter_fh( $fh )"
.Vb 2
\& use MCE::Flow;
\& use MCE::Candy;
\&
\& open my $fh, \*(Aq>\*(Aq, \*(Aq/tmp/out.txt\*(Aq;
\&
\& mce_flow {
\&    max_workers => \*(Aqauto\*(Aq, ## See get_ncpu in <MCE::Util|MCE::Util> 
\&    gather => MCE::Candy::out_iter_fh($fh)
\& },
\& sub {
\&    my $output = "# Worker ID: " . MCE\->wid . "\en";
\&
\&    ## Append results to $output string
\&    $output .= (MCE\->wid * 2) . "\en\en";
\&
\&    ## Output will become orderly by iterator
\&    MCE\->gather( MCE\->wid, $output );
\& };
\&
\& close $fh;
\&
\& \-\- Output
\&
\& # Worker ID: 1
\& 2
\&
\& # Worker ID: 2
\& 4
\&
\& # Worker ID: 3
\& 6
\&
\& # Worker ID: 4
\& 8
\&
\& # Worker ID: 5
\& 10
\&
\& # Worker ID: 6
\& 12
\&
\& # Worker ID: 7
\& 14
\&
\& # Worker ID: 8
\& 16
.Ve
.SH "INDEX"
.IX Header "INDEX"
\&\s-1MCE\s0, MCE::Core
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario E. Roy, <marioeroy AT gmail DOT com>
