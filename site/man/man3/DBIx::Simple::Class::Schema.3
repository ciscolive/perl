.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Simple::Class::Schema 3"
.TH DBIx::Simple::Class::Schema 3 "2014-08-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Simple::Class::Schema \- Create and use classes representing tables from a database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  #Somewhere in a utility script or startup() of your application.
\&  DBIx::Simple::Class::Schema\->dbix(DBIx::Simple\->connect(...));
\&  my $perl_code = DBIx::Simple::Class::Schema\->load_schema(
\&    namespace =>\*(AqMy::Model\*(Aq,
\&    table => \*(Aq%\*(Aq,              #all tables from the current database
\&    type  => "\*(AqTABLE\*(Aq,\*(AqVIEW\*(Aq", # make classes for tables and views
\&  );
\&
\&  #Now eval() to use your classes.
\&  eval $perl_code || Carp::croak($@);
\&
\&
\&  #Or load and save it for more customisations and later usage.
\&  DBIx::Simple::Class::Schema\->load_schema(
\&    namespace =>\*(AqMy::Model\*(Aq,
\&    table => \*(Aq%\*(Aq,              #all tables from the current database
\&    type  => "\*(AqTABLE\*(Aq,\*(AqVIEW\*(Aq", # make classes for tables and views
\&  );
\&  DBIx::Simple::Class::Schema\->dump_schema_at(
\&    lib_root => "$ENV{PERL_LOCAL_LIB_ROOT}/lib"
\&    overwrite =>1 #overwrite existing files
\&  ) || Carp::croak \*(AqSomething went wrong! See above...\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Simple::Class::Schema automates the creation of classes from
database tables. You can use it when you want to prototype quickly
your application. It is also very convenient as an initial generator and dumper of
your classes representing your database tables.
.SH "METHODS"
.IX Header "METHODS"
.SS "load_schema"
.IX Subsection "load_schema"
Class method.
.PP
.Vb 7
\&  Params:
\&    namespace \- String. The class name for your base class,
\&      default: \*(AqDSCS::\*(Aq.(join \*(Aq\*(Aq, map { ucfirst lc } split /_/, $database)
\&    table \- SQL string for a LIKE clause,
\&      default: \*(Aq%\*(Aq
\&    type \- SQL String for an IN clause.
\&      default: "\*(AqTABLE\*(Aq,\*(AqVIEW\*(Aq"
.Ve
.PP
Extracts tables' information from the current connection and generates
Perl classes representing those tables or/and views.
If called in list context returns an array with perl code for each package.
The first package is the base class. The base class is generated only the argument \f(CW\*(C`table\*(C'\fR is '%' or empty.
If called in scalar context returns all the generated code as a string.
.PP
The generated classes are saved internally and are available for use by
\&\*(L"dump_schema_at\*(R".
This makes it very convenient for quickly prototyping applications
by just modifying tables in your database.
.PP
.Vb 5
\&  my $perl_code = DBIx::Simple::Class::Schema\->load_schema();
\&  #concatenaded code as one string
\&  eval $perl_code || Carp::croak($@);
\&  #...
\&  my $user = Dbname::User\->find(2345);
\&  
\&  #or My::Schema, My::Schema::Table1, My::Schema::Table2,...
\&  my @perl_code = DBIx::Simple::Class::Schema\->load_schema();
\&  
\&  #or just prepare code before dumping it to disk.
\&  DBIx::Simple::Class::Schema\->load_schema();
.Ve
.SS "dump_schema_at"
.IX Subsection "dump_schema_at"
Class method.
.PP
.Vb 5
\&  Params:
\&    lib_root: String \- Where classes will be dumped.
\&      default: $INC[0]
\&    overwrite: boolean \-1/0 Should it overwrite existing classes with the same name?
\&      default: 0
.Ve
.PP
Uses the generated code by \*(L"load_schema\*(R" and saves each class on the disk.
Does several checks:
.IP "\(bu" 4
Checks if a file with the name of your base class exists and exits
if the flag \f(CW\*(C`overwrite\*(C'\fR is not set.
.IP "\(bu" 4
The base class is dumped to disk only if the argument \f(CW\*(C`table\*(C'\fR is '%' or empty.
It was not generated in \*(L"load_schema\*(R". 
In other words base/schema class is generated when no specific table class is 
required to be generated. This is convinient if you want to generate only specific table-classes and use them on-the-fly without dumping them to disk.
.IP "\(bu" 4
Checks if there is a module with the same name as your base class installed
and warns if there is such module. This is done to avoid namespace collisions.
.IP "\(bu" 4
Checks if the files can be written to disk and exit immediately if there is a problem.
.PP
For every check above issues a warning so you, the developer, can decide what to do.
Returns true on success.
.SH "SUPPORTED DATABASE DRIVERS"
.IX Header "SUPPORTED DATABASE DRIVERS"
DBIx::Simple::Class::Schema strives to be \s-1DBD\s0 agnostic and
uses only functionality specified by \s-1DBI\s0.
This means that if a driver implements the methods specifyed in \s-1DBI\s0 it is supported.
However currently only tests for DBD::SQLite and DBD::mysql are written.
Feel free to contribute with tests for your prefered driver.
The following methods are used to retreive information form the database:
.IP "\(bu" 4
\&\*(L"table_info\*(R" in \s-1DBI\s0
.IP "\(bu" 4
\&\*(L"column_info\*(R" in \s-1DBI\s0
.IP "\(bu" 4
\&\*(L"primary_key_info\*(R" in \s-1DBI\s0
.SH "SUPPORTED SQL TYPES"
.IX Header "SUPPORTED SQL TYPES"
Currently some minimal \*(L"\s-1CHECKS\*(R"\s0 in DBIx::Simple::Class are automatically generated for TYPE_NAMEs
matching \f(CW\*(C`/INT/i\*(C'\fR,\f(CW\*(C`/FLOAT|DOUBLE|DECIMAL/i\*(C'\fR, \f(CW\*(C`/CHAR|TEXT|CLOB/i\*(C'\fR.
You are supposed to write your own business-specific checks.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Simple::Class, DBIx::Simple, DBIx::Class::Schema::Loader,
Mojolicious::Plugin::DSC
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012\-2013 Красимир Беров (Krasimir Berov).
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
.PP
See http://www.opensource.org/licenses/artistic\-license\-2.0 for more information.
