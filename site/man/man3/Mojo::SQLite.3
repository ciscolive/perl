.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mojo::SQLite 3"
.TH Mojo::SQLite 3 "2020-07-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::SQLite \- A tiny Mojolicious wrapper for SQLite
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::SQLite;
\&
\&  # Select the library version
\&  my $sql = Mojo::SQLite\->new(\*(Aqsqlite:test.db\*(Aq);
\&  say $sql\->db\->query(\*(Aqselect sqlite_version() as version\*(Aq)\->hash\->{version};
\&
\&  # Use migrations to create a table
\&  $sql\->migrations\->name(\*(Aqmy_names_app\*(Aq)\->from_string(<<EOF)\->migrate;
\&  \-\- 1 up
\&  create table names (id integer primary key autoincrement, name text);
\&  \-\- 1 down
\&  drop table names;
\&  EOF
\&
\&  # Use migrations to drop and recreate the table
\&  $sql\->migrations\->migrate(0)\->migrate;
\&
\&  # Get a database handle from the cache for multiple queries
\&  my $db = $sql\->db;
\&
\&  # Use SQL::Abstract to generate simple CRUD queries for you
\&  $db\->insert(\*(Aqnames\*(Aq, {name => \*(AqIsabel\*(Aq});
\&  my $id = $db\->select(\*(Aqnames\*(Aq, [\*(Aqid\*(Aq], {name => \*(AqIsabel\*(Aq})\->hash\->{id};
\&  $db\->update(\*(Aqnames\*(Aq, {name => \*(AqBel\*(Aq}, {id => $id});
\&  $db\->delete(\*(Aqnames\*(Aq, {name => \*(AqBel\*(Aq});
\&
\&  # Insert a few rows in a transaction with SQL and placeholders
\&  eval {
\&    my $tx = $db\->begin;
\&    $db\->query(\*(Aqinsert into names (name) values (?)\*(Aq, \*(AqSara\*(Aq);
\&    $db\->query(\*(Aqinsert into names (name) values (?)\*(Aq, \*(AqStefan\*(Aq);
\&    $tx\->commit;
\&  };
\&  say $@ if $@;
\&
\&  # Insert another row with SQL::Abstract and return the generated id
\&  say $db\->insert(\*(Aqnames\*(Aq, {name => \*(AqDaniel\*(Aq})\->last_insert_id;
\&  
\&  # JSON roundtrip
\&  say $db\->query(\*(Aqselect ? as foo\*(Aq, {json => {bar => \*(Aqbaz\*(Aq}})
\&    \->expand(json => \*(Aqfoo\*(Aq)\->hash\->{foo}{bar};
\&
\&  # Select one row at a time
\&  my $results = $db\->query(\*(Aqselect * from names\*(Aq);
\&  while (my $next = $results\->hash) {
\&    say $next\->{name};
\&  }
\&
\&  # Select all rows with SQL::Abstract
\&  say $_\->{name} for $db\->select(\*(Aqnames\*(Aq)\->hashes\->each;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::SQLite is a tiny wrapper around DBD::SQLite that makes
SQLite <https://www.sqlite.org/> a lot of fun to use with the
Mojolicious <https://mojolico.us> real-time web framework. Use all
\&\s-1SQL\s0 features <http://sqlite.org/lang.html> SQLite has to offer, generate \s-1CRUD\s0
queries from data structures, and manage your database schema with migrations.
.SH "BASICS"
.IX Header "BASICS"
Database and statement handles are cached automatically, so they can be reused
transparently to increase performance. And you can handle connection timeouts
gracefully by holding on to them only for short amounts of time.
.PP
.Vb 2
\&  use Mojolicious::Lite;
\&  use Mojo::SQLite;
\&
\&  helper sqlite => sub { state $sql = Mojo::SQLite\->new(\*(Aqsqlite:test.db\*(Aq) };
\&
\&  get \*(Aq/\*(Aq => sub {
\&    my $c  = shift;
\&    my $db = $c\->sqlite\->db;
\&    $c\->render(json => $db\->query(q{select datetime(\*(Aqnow\*(Aq,\*(Aqlocaltime\*(Aq) as now})\->hash);
\&  };
\&
\&  app\->start;
.Ve
.PP
In this example application, we create a \f(CW\*(C`sqlite\*(C'\fR helper to store a
Mojo::SQLite object. Our action calls that helper and uses the method
\&\*(L"db\*(R" in Mojo::SQLite to dequeue a Mojo::SQLite::Database object from the
connection pool. Then we use the method \*(L"query\*(R" in Mojo::SQLite::Database to
execute an \s-1SQL\s0 <http://www.postgresql.org/docs/current/static/sql.html>
statement, which returns a Mojo::SQLite::Results object. And finally we call
the method \*(L"hash\*(R" in Mojo::SQLite::Results to retrieve the first row as a hash
reference.
.PP
All I/O and queries are performed synchronously. However, the \*(L"Write-Ahead Log\*(R"
journal is enabled for all connections, allowing multiple processes to read and
write concurrently to the same database file (but only one can write at a
time). You can prevent this mode from being enabled by passing the option
\&\f(CW\*(C`no_wal\*(C'\fR, but note that this is incompatible with SQLite databases that have
already had \s-1WAL\s0 mode enabled. See <http://sqlite.org/wal.html> and
\&\*(L"journal_mode\*(R" in DBD::SQLite for more information.
.PP
.Vb 4
\&  # Performed concurrently
\&  my $pid = fork || die $!;
\&  say $sql\->db\->query(q{select datetime(\*(Aqnow\*(Aq,\*(Aqlocaltime\*(Aq) as time})\->hash\->{time};
\&  exit unless $pid;
.Ve
.PP
The double-quoted string literal misfeature
 <https://sqlite.org/quirks.html#double_quoted_string_literals_are_accepted> is
disabled for all connections since Mojo::SQLite 3.003; use single quotes for
string literals and double quotes for identifiers, as is normally recommended.
.PP
All cached database handles will be reset automatically if a new process has
been forked, this allows multiple processes to share the same Mojo::SQLite
object safely.
.PP
Any database errors will throw an exception as \f(CW\*(C`RaiseError\*(C'\fR is automatically
enabled, so use \f(CW\*(C`eval\*(C'\fR or Try::Tiny to catch them. This makes transactions
with \*(L"begin\*(R" in Mojo::SQLite::Database easy.
.PP
While passing a file path of \f(CW\*(C`:memory:\*(C'\fR (or a custom \*(L"dsn\*(R" with
\&\f(CW\*(C`mode=memory\*(C'\fR) will create a temporary database, in-memory databases cannot be
shared between connections, so subsequent calls to \*(L"db\*(R" may return
connections to completely different databases. For a temporary database that
can be shared between connections and processes, pass a file path of \f(CW\*(C`:temp:\*(C'\fR
to store the database in a temporary directory (this is the default), or
consider constructing a temporary directory yourself with File::Temp if you
need to reuse the filename. A temporary directory allows SQLite to create
additional temporary files <https://www.sqlite.org/tempfiles.html> safely.
.PP
.Vb 6
\&  use File::Spec::Functions \*(Aqcatfile\*(Aq;
\&  use File::Temp;
\&  use Mojo::SQLite;
\&  my $tempdir = File::Temp\->newdir; # Deleted when object goes out of scope
\&  my $tempfile = catfile $tempdir, \*(Aqtest.db\*(Aq;
\&  my $sql = Mojo::SQLite\->new\->from_filename($tempfile);
.Ve
.PP
SQL::Abstract::Pg can provide additional features to the SQL::Abstract
query methods in Mojo::SQLite::Database. The \f(CW\*(C`on_conflict\*(C'\fR and \f(CW\*(C`for\*(C'\fR
features are not applicable to SQLite queries.
.PP
.Vb 6
\&  use SQL::Abstract::Pg;
\&  my $sql = Mojo::SQLite\->new(abstract => SQL::Abstract::Pg\->new(name_sep => \*(Aq.\*(Aq, quote_char => \*(Aq"\*(Aq));
\&  $sql\->db\->select([\*(Aqsome_table\*(Aq, [\*(Aqother_table\*(Aq, foo_id => \*(Aqid\*(Aq]],
\&    [\*(Aqfoo\*(Aq, [bar => \*(Aqbaz\*(Aq], \eq{datetime(\*(Aqnow\*(Aq) as dt}],
\&    {foo => \*(Aqvalue\*(Aq},
\&    {order_by => \*(Aqfoo\*(Aq, limit => 10, offset => 5, group_by => [\*(Aqfoo\*(Aq], having => {baz => \*(Aqvalue\*(Aq}});
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This distribution also contains a well-structured example
blog application <https://github.com/Grinnz/Mojo-SQLite/tree/master/examples/blog>
you can use for inspiration. This application shows how to apply the \s-1MVC\s0 design
pattern in practice.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::SQLite inherits all events from Mojo::EventEmitter and can emit the
following new ones.
.SS "connection"
.IX Subsection "connection"
.Vb 4
\&  $sql\->on(connection => sub {
\&    my ($sql, $dbh) = @_;
\&    $dbh\->do(\*(Aqpragma journal_size_limit=1000000\*(Aq);
\&  });
.Ve
.PP
Emitted when a new database connection has been established.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::SQLite implements the following attributes.
.SS "abstract"
.IX Subsection "abstract"
.Vb 2
\&  my $abstract = $sql\->abstract;
\&  $sql         = $sql\->abstract(SQL::Abstract\->new);
.Ve
.PP
SQL::Abstract object used to generate \s-1CRUD\s0 queries for
Mojo::SQLite::Database, defaults to setting \f(CW\*(C`name_sep\*(C'\fR to \f(CW\*(C`.\*(C'\fR and
\&\f(CW\*(C`quote_char\*(C'\fR to \f(CW\*(C`"\*(C'\fR. SQL::Abstract::Pg may be used to provide additional
features.
.PP
.Vb 2
\&  # Generate WHERE clause and bind values
\&  my($stmt, @bind) = $sql\->abstract\->where({foo => \*(Aqbar\*(Aq, baz => \*(Aqyada\*(Aq});
.Ve
.SS "auto_migrate"
.IX Subsection "auto_migrate"
.Vb 2
\&  my $bool = $sql\->auto_migrate;
\&  $sql     = $sql\->auto_migrate($bool);
.Ve
.PP
Automatically migrate to the latest database schema with \*(L"migrations\*(R", as
soon as \*(L"db\*(R" has been called for the first time.
.SS "database_class"
.IX Subsection "database_class"
.Vb 2
\&  my $class = $sql\->database_class;
\&  $sql      = $sql\->database_class(\*(AqMyApp::Database\*(Aq);
.Ve
.PP
Class to be used by \*(L"db\*(R", defaults to Mojo::SQLite::Database. Note that
this class needs to have already been loaded before \*(L"db\*(R" is called.
.SS "dsn"
.IX Subsection "dsn"
.Vb 2
\&  my $dsn = $sql\->dsn;
\&  $sql    = $sql\->dsn(\*(Aqdbi:SQLite:uri=file:foo.db\*(Aq);
.Ve
.PP
Data source name, defaults to \f(CW\*(C`dbi:SQLite:dbname=\*(C'\fR followed by a path to a
temporary file.
.SS "max_connections"
.IX Subsection "max_connections"
.Vb 2
\&  my $max = $sql\->max_connections;
\&  $sql    = $sql\->max_connections(3);
.Ve
.PP
Maximum number of idle database handles to cache for future use, defaults to
\&\f(CW1\fR.
.SS "migrations"
.IX Subsection "migrations"
.Vb 2
\&  my $migrations = $sql\->migrations;
\&  $sql           = $sql\->migrations(Mojo::SQLite::Migrations\->new);
.Ve
.PP
Mojo::SQLite::Migrations object you can use to change your database schema
more easily.
.PP
.Vb 2
\&  # Load migrations from file and migrate to latest version
\&  $sql\->migrations\->from_file(\*(Aq/home/dbook/migrations.sql\*(Aq)\->migrate;
.Ve
.SS "options"
.IX Subsection "options"
.Vb 2
\&  my $options = $sql\->options;
\&  $sql        = $sql\->options({AutoCommit => 1, RaiseError => 1});
.Ve
.PP
Options for database handles, defaults to activating \f(CW\*(C`sqlite_unicode\*(C'\fR,
\&\f(CW\*(C`AutoCommit\*(C'\fR, \f(CW\*(C`AutoInactiveDestroy\*(C'\fR as well as \f(CW\*(C`RaiseError\*(C'\fR and deactivating
\&\f(CW\*(C`PrintError\*(C'\fR. Note that \f(CW\*(C`AutoCommit\*(C'\fR and \f(CW\*(C`RaiseError\*(C'\fR are considered
mandatory, so deactivating them would be very dangerous. See
\&\*(L"\s-1ATTRIBUTES COMMON TO ALL HANDLES\*(R"\s0 in \s-1DBI\s0 and
\&\*(L"\s-1DRIVER PRIVATE ATTRIBUTES\*(R"\s0 in DBD::SQLite for more information on available
options.
.SS "parent"
.IX Subsection "parent"
.Vb 2
\&  my $parent = $sql\->parent;
\&  $sql       = $sql\->parent(Mojo::SQLite\->new);
.Ve
.PP
Another Mojo::SQLite object to use for connection management, instead of
establishing and caching our own database connections.
.SH "METHODS"
.IX Header "METHODS"
Mojo::SQLite inherits all methods from Mojo::EventEmitter and implements
the following new ones.
.SS "new"
.IX Subsection "new"
.Vb 4
\&  my $sql = Mojo::SQLite\->new;
\&  my $sql = Mojo::SQLite\->new(\*(Aqfile:test.db);
\&  my $sql = Mojo::SQLite\->new(\*(Aqsqlite:test.db\*(Aq);
\&  my $sql = Mojo::SQLite\->new(Mojo::SQLite\->new);
.Ve
.PP
Construct a new Mojo::SQLite object and parse connection string with
\&\*(L"from_string\*(R" if necessary.
.PP
.Vb 3
\&  # Customize configuration further
\&  my $sql = Mojo::SQLite\->new\->dsn(\*(Aqdbi:SQLite:dbname=test.db\*(Aq);
\&  my $sql = Mojo::SQLite\->new\->dsn(\*(Aqdbi:SQLite:uri=file:test.db?mode=memory\*(Aq);
\&
\&  # Pass filename directly
\&  my $sql = Mojo::SQLite\->new\->from_filename($filename);
.Ve
.SS "db"
.IX Subsection "db"
.Vb 1
\&  my $db = $sql\->db;
.Ve
.PP
Get a database object based on \*(L"database_class\*(R" (which is usually
Mojo::SQLite::Database) for a cached or newly established database
connection. The DBD::SQLite database handle will be automatically cached
again when that object is destroyed, so you can handle problems like connection
timeouts gracefully by holding on to it only for short amounts of time.
.PP
.Vb 3
\&  # Add up all the money
\&  say $sql\->db\->select(\*(Aqaccounts\*(Aq)
\&    \->hashes\->reduce(sub { $a\->{money} + $b\->{money} });
.Ve
.SS "from_filename"
.IX Subsection "from_filename"
.Vb 1
\&  $sql = $sql\->from_filename(\*(AqC:\e\eDocuments and Settings\e\efoo & bar.db\*(Aq, $options);
.Ve
.PP
Parse database filename directly. Unlike \*(L"from_string\*(R", the filename is
parsed as a local filename and not a \s-1URL. A\s0 hashref of \*(L"options\*(R" may be
passed as the second argument.
.PP
.Vb 2
\&  # Absolute filename
\&  $sql\->from_filename(\*(Aq/home/fred/data.db\*(Aq);
\&
\&  # Relative to current directory
\&  $sql\->from_filename(\*(Aqdata.db\*(Aq);
\&
\&  # Temporary file database (default)
\&  $sql\->from_filename(\*(Aq:temp:\*(Aq);
\&
\&  # In\-memory temporary database (single connection only)
\&  my $db = $sql\->from_filename(\*(Aq:memory:\*(Aq)\->db;
\&
\&  # Additional options
\&  $sql\->from_filename($filename, { PrintError => 1 });
\&  
\&  # Readonly connection without WAL mode
\&  $sql\->from_filename($filename, { ReadOnly => 1, no_wal => 1 });
.Ve
.SS "from_string"
.IX Subsection "from_string"
.Vb 5
\&  $sql = $sql\->from_string(\*(Aqtest.db\*(Aq);
\&  $sql = $sql\->from_string(\*(Aqfile:test.db\*(Aq);
\&  $sql = $sql\->from_string(\*(Aqfile:///C:/foo/bar.db\*(Aq);
\&  $sql = $sql\->from_string(\*(Aqsqlite:C:%5Cfoo%5Cbar.db\*(Aq);
\&  $sql = $sql\->from_string(Mojo::SQLite\->new);
.Ve
.PP
Parse configuration from connection string or use another Mojo::SQLite
object as \*(L"parent\*(R". Connection strings are parsed as URLs, so you should
construct them using a module like Mojo::URL, URI::file, or URI::db.
For portability on non-Unix-like systems, either construct the \s-1URL\s0 with the
\&\f(CW\*(C`sqlite\*(C'\fR scheme, or use \*(L"new\*(R" in URI::file to construct a \s-1URL\s0 with the \f(CW\*(C`file\*(C'\fR
scheme. A \s-1URL\s0 with no scheme will be parsed as a \f(CW\*(C`file\*(C'\fR \s-1URL,\s0 and \f(CW\*(C`file\*(C'\fR URLs
are parsed according to the current operating system. If specified, the
hostname must be \f(CW\*(C`localhost\*(C'\fR. If the \s-1URL\s0 has a query string, it will be parsed
and applied to \*(L"options\*(R".
.PP
.Vb 10
\&  # Absolute filename
\&  $sql\->from_string(\*(Aqsqlite:////home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aqsqlite://localhost//home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aqsqlite:/home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aqfile:///home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aqfile://localhost/home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aqfile:/home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aq///home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aq//localhost/home/fred/data.db\*(Aq);
\&  $sql\->from_string(\*(Aq/home/fred/data.db\*(Aq);
\&
\&  # Relative to current directory
\&  $sql\->from_string(\*(Aqsqlite:data.db\*(Aq);
\&  $sql\->from_string(\*(Aqfile:data.db\*(Aq);
\&  $sql\->from_string(\*(Aqdata.db\*(Aq);
\&
\&  # Connection string must be a valid URL
\&  $sql\->from_string(Mojo::URL\->new\->scheme(\*(Aqsqlite\*(Aq)\->path($filename));
\&  $sql\->from_string(URI::db\->new\->Mojo::Base::tap(engine => \*(Aqsqlite\*(Aq)\->Mojo::Base::tap(dbname => $filename));
\&  $sql\->from_string(URI::file\->new($filename));
\&
\&  # Temporary file database (default)
\&  $sql\->from_string(\*(Aq:temp:\*(Aq);
\&
\&  # In\-memory temporary database (single connection only)
\&  my $db = $sql\->from_string(\*(Aq:memory:\*(Aq)\->db;
\&
\&  # Additional options
\&  $sql\->from_string(\*(Aqdata.db?PrintError=1&sqlite_allow_multiple_statements=1\*(Aq);
\&  $sql\->from_string(Mojo::URL\->new\->scheme(\*(Aqsqlite\*(Aq)\->path($filename)\->query(sqlite_see_if_its_a_number => 1));
\&  $sql\->from_string(URI::file\->new($filename)\->Mojo::Base::tap(query_form => {PrintError => 1}));
\&
\&  # Readonly connection without WAL mode
\&  $sql\->from_string(\*(Aqdata.db?ReadOnly=1&no_wal=1\*(Aq);
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`DBI_TRACE\*(C'\fR environment variable to get some advanced
diagnostics information printed by \s-1DBI\s0.
.PP
.Vb 3
\&  DBI_TRACE=1
\&  DBI_TRACE=15
\&  DBI_TRACE=SQL
.Ve
.SH "REFERENCE"
.IX Header "REFERENCE"
This is the class hierarchy of the Mojo::SQLite distribution.
.IP "\(bu" 2
Mojo::SQLite
.IP "\(bu" 2
Mojo::SQLite::Database
.IP "\(bu" 2
Mojo::SQLite::Migrations
.IP "\(bu" 2
Mojo::SQLite::Results
.IP "\(bu" 2
Mojo::SQLite::Transaction
.SH "BUGS"
.IX Header "BUGS"
Report any issues on the public bugtracker.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dan Book, \f(CW\*(C`dbook@cpan.org\*(C'\fR
.SH "CREDITS"
.IX Header "CREDITS"
Sebastian Riedel, author of Mojo::Pg, which this distribution is based on.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2015, Dan Book.
.PP
This library is free software; you may redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojo::Pg, DBD::SQLite
