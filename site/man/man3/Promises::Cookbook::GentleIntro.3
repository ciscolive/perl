.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises::Cookbook::GentleIntro 3"
.TH Promises::Cookbook::GentleIntro 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises::Cookbook::GentleIntro \- All you need to know about Promises
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "All you need to know about Promises"
.IX Header "All you need to know about Promises"
If you have ever done any async programming, you will be familiar with
\&\*(L"callback hell\*(R", where one callback calls another, calls another, calls
another... Promises give us back a top-to-bottom coding style, making async
code easier to manage and understand. It looks like synchronous code, but
execution is asynchronous.
.PP
The Promises module is event loop agnostic \- it can be used with any event
loop. Backends exist for AnyEvent (and thus all the event loops supported
by AnyEvent) and Mojo::IOLoop.  But more of this later in
\&\*(L"Integration with event loops\*(R".
.PP
There are two moving parts:
.IP "Deferred objects" 4
.IX Item "Deferred objects"
Deferred objects provide the interface to a specific async request.  They
execute some asynchronous action and return a promise.
.IP "Promise objects" 4
.IX Item "Promise objects"
A promise is like a placeholder for a future result.  The promise will either
be \fIresolved\fR in case of success, or \fIrejected\fR in case of failure. Promises
can be chained together, and each step in the chain is executed sequentially.
.PP
The easiest way to understand how Deferred and Promise objects work is by
example.
.SS "Deferred objects"
.IX Subsection "Deferred objects"
A deferred object is used to signal the success or failure of some async
action which can be implemented in the async library of your choice.  For
instance:
.PP
.Vb 3
\&    use Promises qw(deferred);
\&    use AnyEvent::HTTP qw(http_get);
\&    use JSON qw(decode_json);
\&
\&    sub fetch_it {
\&        my ($uri) = @_;
\&        my $deferred = deferred;
\&        http_get $uri => sub {
\&            my ($body, $headers) = @_;
\&            $headers\->{Status} == 200
\&                ? $deferred\->resolve( decode_json($body) )
\&                : $deferred\->reject( $headers\->{Reason} )
\&        };
\&        $deferred\->promise;
\&    }
.Ve
.PP
The above code makes an asynchronous \f(CW\*(C`http_get\*(C'\fR request to the specified
\&\f(CW$uri\fR. The result of the request at the time the subroutine returns is like
SchrÃ¶dinger's cat: both dead and alive.  In the future it may succeed or it
may fail.
.PP
This sub creates a Promises::Deferred object using \f(CW\*(C`deferred\*(C'\fR, which is either:
.IP "\(bu" 4
resolved on success, in which case it returns the request \f(CW\*(C`body\*(C'\fR, or
.IP "\(bu" 4
rejected on failure, in which case it returns the reason for failure.
.PP
As a final step, the deferred object returns a Promises::Promise object
which represents the future result.
.PP
That's all there is to know about Promises::Deferred.
.SS "Promise objects"
.IX Subsection "Promise objects"
Promises are a lot like \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`catch\*(C'\fR/\f(CW\*(C`finally\*(C'\fR blocks except that they can
be chained together. The most important part of a promise is the \f(CW\*(C`then()\*(C'\fR
method:
.PP
.Vb 4
\&    $promise\->then(
\&        sub { success! },
\&        sub { failure }
\&    );
.Ve
.PP
The \f(CW\*(C`then()\*(C'\fR method takes two arguments: a success callback and a failure
callback.  But the important part is that it returns a \fBnew\fR promise, which
is the thing that allows promises to be chained together.
.PP
The simple genius of promises (and I can say that because I didn't invent them)
will not be immediately obvious, but bear with me. Promises are very simple,
as long as you understand the execution flow:
.PP
\fIResolving or rejecting a Promise\fR
.IX Subsection "Resolving or rejecting a Promise"
.PP
.Vb 1
\&    use Promises qw(deferred);
\&
\&    my $deferred = deferred;
\&    $deferred\->promise\->then(
\&        sub { say "OK! We received: ".shift(@_)},       # on resolve
\&        sub { say "Bah! We failed with: ". shift(@_)}   # on reject
\&    );
.Ve
.PP
What this code does depends on what happens to the \f(CW$deferred\fR object:
.PP
.Vb 2
\&    $deferred\->resolve(\*(AqYay!\*(Aq);
\&    # prints: "OK! We received: Yay!"
\&
\&    $deferred\->reject(\*(AqPooh!\*(Aq);
\&    # prints "Bah! We failed with: Pooh!"
.Ve
.PP
A Deferred object can only be resolved or rejected once.  Once it is resolved
or rejected, it informs all its promises of the outcome.
.PP
\fIChaining resolve callbacks\fR
.IX Subsection "Chaining resolve callbacks"
.PP
As mentioned earlier, the \f(CW\*(C`then()\*(C'\fR method returns a new promise which will be
resolved or rejected in turn. Each \f(CW\*(C`resolve\*(C'\fR callback will receive the return
value of the previous \f(CW\*(C`resolve\*(C'\fR callback:
.PP
.Vb 3
\&    deferred
\&    \->resolve(\*(Aqred\*(Aq,\*(Aqgreen\*(Aq)
\&    \->promise
\&
\&    \->then(sub {
\&        # @_ contains (\*(Aqred\*(Aq,\*(Aqgreen\*(Aq)
\&        return (\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq);
\&    })
\&
\&    \->then(sub {
\&        # @_ contains (\*(Aqfoo,bar\*(Aq);
\&        return 10;
\&    })
\&
\&    \->then( sub {
\&        # @_ contains (10)
\&    });
.Ve
.PP
All of these example callbacks have just returned a simple value (or values),
so execution has moved from one callback to the next.
.PP
\fIChaining reject callbacks\fR
.IX Subsection "Chaining reject callbacks"
.PP
Note that in the above example, in each call to \f(CW\*(C`then()\*(C'\fR we specified only a
\&\fIresolved\fR callback, not a \fIrejected\fR callback.  If a promise is resolved or
rejected, the action gets passed down the chain until it finds a resolved or
rejected handler.  This means that errors can be handled in the appropriate
place in the chain:
.PP
.Vb 1
\&    my $deferred = deferred;
\&
\&    $deferred\->promise
\&    \->then(
\&        sub {
\&            my $count = shift();
\&            say "Count: $count";
\&            return $count+1;
\&        }
\&    )
\&    \->then(
\&        sub {
\&            my $count = shift();
\&            say "Count: $count";
\&            return $count+1;
\&        }
\&    )\->then(
\&        sub {
\&            my $count = shift();
\&            say "Final count: $count";
\&            return $count+1;
\&        },
\&        sub {
\&            my $reason = shift;
\&            warn "Failed to count: $reason"
\&        }
\&    );
.Ve
.PP
If the \f(CW$deferred\fR object is resolved, it will call each resolved callback in
turn:
.PP
.Vb 5
\&    $deferred\->resolve(5);
\&    # prints:
\&    #   Count: 5
\&    #   Count: 6
\&    #   Final count: 7
.Ve
.PP
If the \f(CW$deferred\fR object is rejected, however, it will skip all of the steps
in the chain until it hits the first rejected callback:
.PP
.Vb 3
\&    $deferred\->reject(\*(AqPoor example\*(Aq);
\&    # warns:
\&    #    "Failed to count: Poor example"
.Ve
.PP
\&\fBImportant\fR: Event loops do not like fatal exceptions! For this reason the
\&\fIresolved\fR and \fIrejected\fR callbacks are run in \f(CW\*(C`eval\*(C'\fR blocks. Exceptions
thrown in either type of callback are passed down the chain to the next
\&\fIrejected\fR handler.  If there are no more \fIrejected\fR handlers, then the
error is silently swallowed.
.PP
\fIThrowing and handling exceptions\fR
.IX Subsection "Throwing and handling exceptions"
.PP
While you can signal success or failure by calling \f(CW\*(C`resolve()\*(C'\fR or \f(CW\*(C`reject()\*(C'\fR
on the \f(CW$deferred\fR object, you can also signal success or failure in each
step of the promises chain.
.IP "\(bu" 4
\&\fIResolved\fR callbacks are like \f(CW\*(C`try\*(C'\fR blocks: they can either execute some
code successfully or throw an exception.
.IP "\(bu" 4
\&\fIRejected\fR callbacks are like \f(CW\*(C`catch\*(C'\fR blocks: they can either handle the
exception or rethrow it.
.PP
.Vb 1
\&    $deferred = deferred;
\&
\&    $deferred\->promise
\&    \->then(
\&        sub {
\&            my $count = shift;
\&            die "Count too high!" if $count > 100;
\&            return $count
\&        }
\&    )\->then(
\&        sub {
\&            say "The count is OK. Continuing";
\&            return @_
\&        },
\&        sub {
\&            my $error = shift;
\&            warn "We have a problem: $error";
\&            die $error;
\&        }
\&    )\->then(
\&        undef,  # no resolved handler
\&        sub { return 1; }
\&    )\-> then(
\&        sub {
\&            my $count = shift;
\&            say "Got count: $count";
\&        }
\&    )
.Ve
.PP
There are a few ways this code can execute. We can resolve the \f(CW$deferred\fR
object with a reasonable count:
.PP
.Vb 4
\&    $deferred\->resolve(5);
\&    # prints:
\&    #   The count is OK. Continuing
\&    #   Got count: 5
\&
\&    $defer
.Ve
.PP
If we reject the \f(CW$deferred\fR object, the first \fIrejected\fR handler is called.
It warns, then rethrows the exception with \f(CW\*(C`die\*(C'\fR which calls the next
\&\fIrejected\fR handler.  This handler resolves the exception (that is, it doesn't
call \f(CW\*(C`die\*(C'\fR) and returns a value which gets passed to the next \fIresolved\fR
handler:
.PP
.Vb 5
\&    $deferred\->reject(\*(AqFor example purposes\*(Aq)
\&    # warns:
\&    #    We have a problem: For example purposes
\&    # prints:
\&    #    Got count: 1
.Ve
.PP
Finally, if we resolve the \f(CW$deferred\fR object with a too large count, the
first \fIresolved\fR handler throws an exception, which calls the next
\&\fIrejected\fR handler:
.PP
.Vb 5
\&    $deferred\->resolve(1000);
\&    # warns:
\&    #    We have a problem: Count too high!
\&    # prints:
\&    #    Got count: 1
.Ve
.PP
\fI\f(CI\*(C`catch()\*(C'\fI\fR
.IX Subsection "catch()"
.PP
In the above example, we called \f(CW\*(C`then()\*(C'\fR with \f(CW\*(C`undef\*(C'\fR instead of a
\&\fIresolved\fR callback. This could be rewritten to look a bit cleaner using the
\&\f(CW\*(C`catch()\*(C'\fR method, which takes just a \fIrejected\fR callback.
.PP
.Vb 3
\&    # these two lines are equivalent:
\&    $promise\->then( undef, sub { rejected cb} )
\&    $promise\->catch( sub { rejected cb } )
.Ve
.PP
\fI\f(CI\*(C`finally()\*(C'\fI\fR
.IX Subsection "finally()"
.PP
Any \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`catch\*(C'\fR implementation has a \f(CW\*(C`finally\*(C'\fR block, which can be used
to clean up resources regardless of whether the code in the \f(CW\*(C`try\*(C'\fR block
succeeded or failed. Promises offer this functionality too.
.PP
The \f(CW\*(C`finally()\*(C'\fR method accepts a single callback which is called regardless
of whether the previous step was resolved or rejected. The return value
(or any exception thrown in the callback) are thrown away, and the chain
continues as if it were not there:
.PP
.Vb 10
\&    $deferred = deferred;
\&    $deferred\->promise
\&    \->then(
\&        sub {
\&            my $count = shift;
\&            if ($count > 10) { die "Count too high"}
\&            return $count
\&        }
\&    )\->finally(
\&        sub { say "Finally got: ".shift(@_) }
\&    )\->then(
\&        sub { say "OK: ". shift(@_)   },
\&        sub { say "Bah!: ". shift(@_) }
\&    );
.Ve
.PP
If we resolve the \f(CW$deferred\fR object with a good count, we see:
.PP
.Vb 4
\&    $d\->resolve(5);
\&    # prints:
\&    #   Finally got: 5
\&    #   OK: 5
.Ve
.PP
With a high count we get:
.PP
.Vb 4
\&    $d\->resolve(20);
\&    # prints:
\&    #   Finally got: Count to high
\&    #   Bah: 20
.Ve
.PP
\fIChaining async callbacks\fR
.IX Subsection "Chaining async callbacks"
.PP
This is where the magic starts: each \fIresolved\fR/\fIrejected\fR handler can not
only return a value (or values), it can also \fBreturn a new Promise\fR. Remember
that a Promise represents a future value, which means that execution of the
chain will stop until the new Promise has been either resolved or rejected!
.PP
For instance, we could write the following code using the \f(CW\*(C`fetch_it()\*(C'\fR sub
(see  \*(L"Deferred objects\*(R") which returns a promise:
.PP
.Vb 10
\&    fetch_it(\*(Aqhttp://domain.com/user/123\*(Aq)
\&    \->then(
\&        sub {
\&            my $user = shift;
\&            say "User name: ".$user\->{name};
\&            say "Fetching total comments";
\&            return fetch_id($user\->{total_comments_url});
\&        }
\&    )\->then(
\&        sub {
\&            my $total = shift;
\&            say "User has left $total comments"
\&        }
\&    )
\&    \->catch(
\&        sub {
\&            warn @_
\&        }
\&    );
.Ve
.PP
This code sends an asynchronous request to get the page for user \f(CW123\fR and
returns a promise. Once the promise is resolved, it sends an asynchronous
request to get the total comments for that user and again returns a promise.
Once the second promise is resolved, it prints out the total number of
comments. If either promise were to be rejected, it would skip down the chain
looking for the first \fIrejected\fR handler and execute that.
.PP
This is organised to look like synchronous code.  Each step is executed
sequentially, it is easy to read and easy to understand, but it works
asynchronously.  While we are waiting for a response from \f(CW\*(C`domain.com\*(C'\fR
(while our promise remains unfulfilled), the event loop can happily continue
running code elsewhere in the application.
.PP
In fact, it's not just Promises::Promise objects that can be returned, it
can be any object that is ``thenable'' (ie it has a \f(CW\*(C`then()\*(C'\fR method). So
if you want to integrate your Promises code with a library which is using
Future objects, you should be able to do it.
.PP
\fIRunning async requests in parallel\fR
.IX Subsection "Running async requests in parallel"
.PP
Sometimes order doesn't matter: perhaps we want to retrieve several web pages
at the same time.  For that we can use the \f(CW\*(C`collect\*(C'\fR helper:
.PP
.Vb 1
\&    use Promises qw(collect);
\&
\&    collect(
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq),
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq),
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq),
\&    )\->then(
\&        sub {
\&            my ($product, $suggestions, $reviews) = @_;
\&            # do something with these values
\&        },
\&        sub { warn @_ }
\&    );
.Ve
.PP
\&\f(CW\*(C`collect()\*(C'\fR accepts a list of promises and returns a new promise (which we'll
call \f(CW$p\fR for clarification purposes.  When all of its promises have been
resolved, it resolves \f(CW$p\fR with the values returned by every promise, in the
same order as they were passed in to \f(CW\*(C`collect()\*(C'\fR.
.PP
\&\fBNote:\fR Each promise can return multiple values, so \f(CW$product\fR,
\&\f(CW$suggestions\fR and \f(CW$reviews\fR in the example above will all be array refs.
.PP
If any of the passed in promises is rejected, then \f(CW$p\fR will also be rejected
with the reason for the failure.  \f(CW$p\fR can only be rejected once, so we wil
only find out about the first failure.
.SS "Integration with event loops"
.IX Subsection "Integration with event loops"
In order to run asynchronous code, you need to run some event loop.  That can
be as simple as using \*(L"\s-1CONDITION VARIABLES\*(R"\s0 in AnyEvent to run the event loop
just until a particular condition is met:
.PP
.Vb 1
\&    use AnyEvent;
\&
\&    my $cv = AnyEvent\->condvar;
\&    collect(
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq),
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq),
\&        fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq),
\&    )\->then(
\&        sub {
\&            my ($product, $suggestions, $reviews) = @_;
\&            $cv\->send({
\&                product     => $product\->[0],
\&                suggestions => $suggestions\->[0],
\&                reviews     => $reviews\->[0],
\&            })
\&        },
\&        sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&    );
\&
\&    # wait for $cv\->send or $cv\->croak
\&    my $results = $cv\->recv;
.Ve
.PP
More usually though, a whole application is intended to be asynchronous, in
which case the event loop just runs continuously. Normally you would only need
to use \f(CW$cv\fR's or the equivalent at the point where your application uses a
specific async library, as explained in \*(L"Deferred objects\*(R". The rest of your
code can deal purely with Promises.
.PP
\fIEvent loop specific backends\fR
.IX Subsection "Event loop specific backends"
.PP
The \fIresolved\fR and \fIrejected\fR callbacks should be run by the event loop,
rather than having one callback call the next, which calls the next etc.
.PP
In other words, if a promise is resolved, it doesn't call the \fIresolved\fR
callback directly. Instead it adds it to the event loop's queue, then returns
immediately. The next time the event loop checks its queue, it'll find the
callback in the queue and will call it.
.PP
By default, Promises is event loop agnostic, which means that it doesn't
know which event loop to use and so each callback ends up calling the next,
etc.  If you're writing Promises\-based modules for \s-1CPAN,\s0 then your code
should also be event loop agnostic, in which case you want to use Promises
like this:
.PP
.Vb 1
\&    use Promises qw(deferred collect);
.Ve
.PP
However, if you are an end user, then you should specify which event loop
you are using at the start of your application:
.PP
.Vb 1
\&    use Promises backend => [\*(AqAnyEvent\*(Aq]; # or "EV" or "Mojo"
.Ve
.PP
You only need to specify the backend once \- any code in the application
which uses Promises will automatically use the specified backend.
.ie n .SS "Recursing safely with with ""done()"""
.el .SS "Recursing safely with with \f(CWdone()\fP"
.IX Subsection "Recursing safely with with done()"
One of the cool things about working with promises is that the return value
gets passed down the chain as if the code were synchronous. However that is
not always what we want.
.PP
Imagine that we want to process every line in a file, which could be millions
of lines. We don't care about the results from each line, all we care about is
whether the whole file was processed successfully, or whether something
failed.
.PP
In sync code we'd write something like this:
.PP
.Vb 7
\&    sub process_file {
\&        my $fh = shift;
\&        while (my $line = <$fh>) {
\&            process_line($line)
\&                || die "Failed"
\&        }
\&    }
.Ve
.PP
Now imagine that \f(CW\*(C`process_line()\*(C'\fR runs asynchronously and returns a promise.
By the time it returns, it probably hasn't executed anything yet.  We can't go
ahead and read the next line of the file otherwise we could generate a billion
promises before any of them has had time to execute.
.PP
Instead, we need to wait for \f(CW\*(C`process_line()\*(C'\fR to complete and only then move
on to reading the next line.  We could do this as follows:
.PP
.Vb 1
\&    # WARNING: EXAMPLE OF INCORRECT CODE #
\&
\&    use Promises qw(deferred);
\&
\&    sub process_file {
\&        my $fh        = shift;
\&        my $deferred  = deferred;
\&        my $processor = sub {
\&            my $line = <$fh>;
\&            unless (defined $line) {
\&                # we\*(Aqre done
\&                return $deferred\->resolve;
\&            }
\&            process_line($line)\->then(
\&
\&                # on success, call $processor again
\&                _\|_SUB_\|_,
\&
\&                # on failure:
\&                sub {
\&                    return $deferred\->reject("Failed")
\&                }
\&            )
\&        }
\&
\&        # start the loop
\&        $processor\->();
\&
\&        return $deferred\->promise
\&    }
.Ve
.PP
This code has two stack problems. The first is that, every time we process a
line, we recurse into the current \f(CW\*(C`_\|_SUB_\|_\*(C'\fR \fBfrom\fR the current sub.  This
problem is solved by specifying one of the \*(L"Event loop specific backends\*(R" somewhere
in our application, which we discussed above.
.PP
The second problem is that every time we recurse into the current
\&\f(CW\*(C`_\|_SUB_\|_\*(C'\fR we're waiting for the return value. Other languages use the
Tail Call optimization <http://en.wikipedia.org/wiki/Tail_call> to
keep the return stack flat, but we don't have this option.
.PP
Instead, we have the \f(CW\*(C`done()\*(C'\fR method which, like \f(CW\*(C`then()\*(C'\fR, accepts a \fIresolved\fR callback
and a \fIrejected\fR callback. But it differs from \f(CW\*(C`then()\*(C'\fR in two ways:
.IP "\(bu" 4
It doesn't return a promise, which means that the chain ends with the \f(CW\*(C`done()\*(C'\fR step.
.IP "\(bu" 4
Callbacks are not run in an \f(CW\*(C`eval\*(C'\fR block, so calling \f(CW\*(C`die()\*(C'\fR will throw a
fatal exception. (Most event loops, however will catch the exception, warn,
and continue running.)
.PP
The code can be rewritten using \f(CW\*(C`done()\*(C'\fR instead of \f(CW\*(C`then()\*(C'\fR and an event
loop specific backend, and it will happily process millions of lines without
memory leaks or stack oveflows:
.PP
.Vb 1
\&    use Promises backend => [\*(AqEV\*(Aq], \*(Aqdeferred\*(Aq;
\&
\&    sub process_file {
\&        my $fh        = shift;
\&        my $deferred  = deferred;
\&        my $processor = sub {
\&            my $line = <$fh>;
\&            unless (defined $line) {
\&                # we\*(Aqre done
\&                return $deferred\->resolve;
\&            }
\&            #### USE done() TO END THE CHAIN ####
\&            process_line($line)\->done(
\&
\&                # on success, call $processor again
\&                _\|_SUB_\|_,
\&
\&                # on failure:
\&                sub {
\&                    return $deferred\->reject("Failed")
\&                }
\&            )
\&        }
\&
\&        # start the loop
\&        $processor\->();
\&
\&        return $deferred\->promise
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
