.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::DBus::Test::MockConnection 3"
.TH Net::DBus::Test::MockConnection 3 "2019-02-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DBus::Test::MockConnection \- Fake a connection to the bus unit testing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::DBus;
\&
\&  my $bus = Net::DBus\->test
\&
\&  # Register a service, and the objec to be tested
\&  use MyObject
\&  my $service = $bus\->export_service("org.example.MyService");
\&  my $object = MyObject\->new($service);
\&
\&
\&  # Acquire the service & do tests
\&  my $remote_service = $bus\->get_service(\*(Aqorg.example.MyService\*(Aq);
\&  my $remote_object = $service\->get_object("/org/example/MyObjct");
\&
\&  # This traverses the mock connection, eventually
\&  # invoking \*(AqtestSomething\*(Aq on the $object above.
\&  $remote_object\->testSomething()
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object provides a fake implementation of the Net::DBus::Binding::Connection
enabling a pure 'in\-memory' message bus to be mocked up. This is intended to
facilitate creation of unit tests for services which would otherwise need to
call out to other object on a live message bus. It is used as a companion to
the Net::DBus::Test::MockObject module which is how fake objects are to be
provided on the fake bus.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $con = Net::DBus::Test::MockConnection\->\fBnew()\fR" 4
.el .IP "my \f(CW$con\fR = Net::DBus::Test::MockConnection\->\fBnew()\fR" 4
.IX Item "my $con = Net::DBus::Test::MockConnection->new()"
Create a new mock connection object instance. It is not usually
necessary to create instances of this object directly, instead
the \f(CW\*(C`test\*(C'\fR method on the Net::DBus object can be used to
get a handle to a test bus.
.ie n .IP "$con\->send($message)" 4
.el .IP "\f(CW$con\fR\->send($message)" 4
.IX Item "$con->send($message)"
Send a message over the mock connection. If the message is
a method call, it will be dispatched straight to any corresponding
mock object registered. If the message is an error or method return
it will be made available as a return value for the \f(CW\*(C`send_with_reply_and_block\*(C'\fR
method. If the message is a signal it will be queued up for processing
by the \f(CW\*(C`dispatch\*(C'\fR method.
.ie n .IP "$bus\->request_name($service_name)" 4
.el .IP "\f(CW$bus\fR\->request_name($service_name)" 4
.IX Item "$bus->request_name($service_name)"
Pretend to send a request to the bus registering the well known
name specified in the \f(CW$service_name\fR parameter. In reality
this is just a no-op giving the impression that the name was
successfully registered.
.ie n .IP "my $reply = $con\->send_with_reply_and_block($msg)" 4
.el .IP "my \f(CW$reply\fR = \f(CW$con\fR\->send_with_reply_and_block($msg)" 4
.IX Item "my $reply = $con->send_with_reply_and_block($msg)"
Send a message over the mock connection and wait for a
reply. The \f(CW$msg\fR should be an instance of \f(CW\*(C`Net::DBus::Binding::Message::MethodCall\*(C'\fR
and the return \f(CW$reply\fR will be an instance of \f(CW\*(C`Net::DBus::Binding::Message::MethodReturn\*(C'\fR.
It is also possible that an error will be thrown, with
the thrown error being blessed into the \f(CW\*(C`Net::DBus::Error\*(C'\fR
class.
.ie n .IP "$con\->dispatch;" 4
.el .IP "\f(CW$con\fR\->dispatch;" 4
.IX Item "$con->dispatch;"
Dispatches any pending messages in the incoming queue
to their message handlers. This method should be called
by test suites whenever they anticipate that there are
pending signals to be dealt with.
.ie n .IP "$con\->add_filter($coderef);" 4
.el .IP "\f(CW$con\fR\->add_filter($coderef);" 4
.IX Item "$con->add_filter($coderef);"
Adds a filter to the connection which will be invoked whenever a
message is received. The \f(CW$coderef\fR should be a reference to a
subroutine, which returns a true value if the message should be
filtered out, or a false value if the normal message dispatch
should be performed.
.ie n .IP "$bus\->add_match($rule)" 4
.el .IP "\f(CW$bus\fR\->add_match($rule)" 4
.IX Item "$bus->add_match($rule)"
Register a signal match rule with the bus controller, allowing
matching broadcast signals to routed to this client. In reality
this is just a no-op giving the impression that the match was
successfully registered.
.ie n .IP "$bus\->remove_match($rule)" 4
.el .IP "\f(CW$bus\fR\->remove_match($rule)" 4
.IX Item "$bus->remove_match($rule)"
Unregister a signal match rule with the bus controller, preventing
further broadcast signals being routed to this client. In reality
this is just a no-op giving the impression that the match was
successfully unregistered.
.ie n .IP "$con\->register_object_path($path, \e&handler)" 4
.el .IP "\f(CW$con\fR\->register_object_path($path, \e&handler)" 4
.IX Item "$con->register_object_path($path, &handler)"
Registers a handler for messages whose path matches
that specified in the \f(CW$path\fR parameter. The supplied
code reference will be invoked with two parameters, the
connection object on which the message was received,
and the message to be processed (an instance of the
\&\f(CW\*(C`Net::DBus::Binding::Message\*(C'\fR class).
.ie n .IP "$con\->register_fallback($path, \e&handler)" 4
.el .IP "\f(CW$con\fR\->register_fallback($path, \e&handler)" 4
.IX Item "$con->register_fallback($path, &handler)"
Registers a handler for messages whose path starts with
the prefix specified in the \f(CW$path\fR parameter. The supplied
code reference will be invoked with two parameters, the
connection object on which the message was received,
and the message to be processed (an instance of the
\&\f(CW\*(C`Net::DBus::Binding::Message\*(C'\fR class).
.ie n .IP "$con\->unregister_object_path($path)" 4
.el .IP "\f(CW$con\fR\->unregister_object_path($path)" 4
.IX Item "$con->unregister_object_path($path)"
Unregisters the handler associated with the object path \f(CW$path\fR. The
handler would previously have been registered with the \f(CW\*(C`register_object_path\*(C'\fR
or \f(CW\*(C`register_fallback\*(C'\fR methods.
.ie n .IP "my $msg = $con\->make_error_message($replyto, $name, $description)" 4
.el .IP "my \f(CW$msg\fR = \f(CW$con\fR\->make_error_message($replyto, \f(CW$name\fR, \f(CW$description\fR)" 4
.IX Item "my $msg = $con->make_error_message($replyto, $name, $description)"
Creates a new message, representing an error which occurred during
the handling of the method call object passed in as the \f(CW$replyto\fR
parameter. The \f(CW$name\fR parameter is the formal name of the error
condition, while the \f(CW$description\fR is a short piece of text giving
more specific information on the error.
.ie n .IP "my $call = $con\->make_method_call_message( $service_name, $object_path, $interface, $method_name);" 4
.el .IP "my \f(CW$call\fR = \f(CW$con\fR\->make_method_call_message( \f(CW$service_name\fR, \f(CW$object_path\fR, \f(CW$interface\fR, \f(CW$method_name\fR);" 4
.IX Item "my $call = $con->make_method_call_message( $service_name, $object_path, $interface, $method_name);"
Create a message representing a call on the object located at
the path \f(CW$object_path\fR within the client owning the well-known
name given by \f(CW$service_name\fR. The method to be invoked has
the name \f(CW$method_name\fR within the interface specified by the
\&\f(CW$interface\fR parameter.
.ie n .IP "my $msg = $con\->make_method_return_message($replyto)" 4
.el .IP "my \f(CW$msg\fR = \f(CW$con\fR\->make_method_return_message($replyto)" 4
.IX Item "my $msg = $con->make_method_return_message($replyto)"
Create a message representing a reply to the method call message passed in
the \f(CW$replyto\fR parameter.
.ie n .IP "my $msg = $con\->make_signal_message($object_path, $interface, $signal_name);" 4
.el .IP "my \f(CW$msg\fR = \f(CW$con\fR\->make_signal_message($object_path, \f(CW$interface\fR, \f(CW$signal_name\fR);" 4
.IX Item "my $msg = $con->make_signal_message($object_path, $interface, $signal_name);"
Creates a new message, representing a signal [to be] emitted by
the object located under the path given by the \f(CW$object_path\fR
parameter. The name of the signal is given by the \f(CW$signal_name\fR
parameter, and is scoped to the interface given by the
\&\f(CW$interface\fR parameter.
.SH "BUGS"
.IX Header "BUGS"
It doesn't completely replicate the \s-1API\s0 of Net::DBus::Binding::Connection,
merely enough to make the high level bindings work in a test scenario.
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel P. Berrange
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005\-2009 Daniel P. Berrange
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus, Net::DBus::Test::MockObject, Net::DBus::Binding::Connection,
<http://www.mockobjects.com/Faq.html>
