.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "mem 3"
.TH mem 3 "2017-10-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.RS 4
•ḟmem \- use modules in "mem"ory (already declared in same file)
.RE
.SH "VERSION"
.IX Header "VERSION"
Version \*(L"0.4.7\*(R"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use mem;
\&  use mem(@COMPILE_TIME_DEFINES=qw(a b c));
.Ve
.PP
\&\fB\f(CB\*(C`mem\*(C'\fB\fR is a \fIsyntactic-sugar\fR \f(CW\*(C`pragma\*(C'\fR that allows \f(CW\*(C`use\*(C'\fR\-ing a \f(CW\*(C`package\*(C'\fR as it is previously defined, \fBin the same file\fR. This allows easy declaration of specialized, typed data structures (like \fIC\fR \f(CW\*(C`struct\*(C'\fR definitions) that increase code legibility and concept clarity.  In a similar usage, the constants pragma allows defining low-overhead, runtime constants.
.PP
Allowing \f(CW\*(C`use\*(C'\fR of packages in the same file allows calling code to access classes in a clean, object oriented manner, allowing for identical code to
exist either in the same file, or in a separate file without making code
changes or requiring use of non-portable, language specific features to
accomplish the same thing.
.PP
In the 2nd form, it can allow in-lined \s-1BEGIN\s0's for single line
assignments.  While one could use it as a replacement for multiple
lines, an actual \s-1BEGIN\s0 block can often look as much or more tidy.
.PP
In many cases, these compile time assignments are essential to take full
advantage of perl's strengths.  For example, without compile time assignment
of '@EXPORT', you can't use perl's function prototypes.  Due the overhead and difficulty in getting them right, new perl programmers are dissuaded from
using such featues.
.PP
When used to force assignments into the early parsing stages of perl, Using dynamically allocated, pre-initialized and type-checked data structures become
possible.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Following, is a sample program, showing two uses of  \f(CW\*(C`mem\*(C'\fR .  This first example allows declaring a run-time keyword '\s-1ARRAY\s0', that can check to see
if it's argument is an \s-1ARRAY\s0 reference, \fBand\fR provide a runtime
literal,  \f(CW\*(C`ARRAY\*(C'\fR , that can be used without quotes.
.PP
.Vb 1
\&  use strict; use warnings;
\&
\&  { package Ar_Type;
\&      #
\&      use mem;                                    #1st usage 
\&      our (@EXPORT);
\&      sub ARRAY (;*) {
\&          my $p = $_[0]; my $t="ARRAY";
\&          return @_ ? (ref $p && (1+index($p, $t))) : $t;
\&      }
\&      #
\&      use mem( @EXPORT=qw(ARRAY) );               #2nd usage 
\&      
\&                        use Xporter;
\&  }
\&
\&  package main;
\&  use Ar_Type;
\&  use P;
\&
\&  my @a=(1,2,3);
\&  my ($ed, $light);
\&      (@$ed, @$light) = (@a, @a);  #ed & light point to copies of @a
\&  bless $ed, "bee";
\&
\&  P "\e@a = ref of array" if ARRAY \e@a;
\&  P "ref of \e$ed is \e"%s\e".", ref $ed;
\&  P "ed still points to underlying type, \*(Aqarray\*(Aq" if ARRAY $ed;
\&  P "Is ref \e$light, an ARRAY?: %s", (ref $light eq ARRAY) ? \*(Aqyes\*(Aq:\*(Aqno\*(Aq;
\&  P "Does \e"ref \e$ed\e" eq ARRAY?: %s", (ref $ed eq ARRAY) ? \*(Aqyes\*(Aq:\*(Aqno\*(Aq;
\&  P "%s", "#  (Because \e"ref \e$ed\e" is really a bless \e"ed\e" bee)"
.Ve
.IP "\(bu" 4
Now, to show what happens using  \f(CW\*(C`mem\*(C'\fR, and the errors that occur if you
do not.  First, the correct output:
.Sp
.Vb 6
\&  @a = ref of array
\&  ref of $ed is "bee".
\&  ed still points to underlying type, \*(Aqarray\*(Aq
\&  Is ref $light, an ARRAY?: yes
\&  Does ref $ed eq ARRAY?: no
\&  #  (Because ref "ed" is really a bless"ed" bee)
.Ve
.IP "\(bu" 4
Second, \fB\f(BIwithout\fB\fR the first "\f(CW\*(C` use mem \*(C'\fR", presuming the line was commented out:
.Sp
.Vb 4
\&  Can\*(Aqt locate Ar_Type.pm in @INC (@INC contains: 
\&    /usr/lib/perl5/5.18.2 ...   /usr/lib/perl5/site_perl .) 
\&    at /tmp/ex line 18.
\&  BEGIN failed\-\-compilation aborted at /tmp/ex line 18.
.Ve
.Sp
This is due to \f(CW\*(C`package AR_Type\*(C'\fR, the package already declared
and in \fI\f(CI\*(C`mem\*(C'\fIory\fR>, being \fIignored\fR by Perl's \f(CW\*(C`use\*(C'\fR statement
because some \fIPerl-specific\fR, \fI\*(L"internal flag\*(R"\fR is not set for
\&\f(CW\*(C`package Ar_Type\*(C'\fR.  The first \f(CW\*(C`use mem\*(C'\fR causes this flag, normally
set with the path of the of a \f(CW\*(C`use\*(C'\fRd file, to be set with the
containing file path and an added comment, containing the line number.
.Sp
This tells perl to use the definition of the package that is already
in \f(CW\*(C`mem\*(C'\fRory.
.RS 4
.Sp
.RS 4
\&\fIand\fR
.RE
.RE
.RS 4
.RE
.IP "\(bu" 4
Third, instead of dropping the 1st "\f(CW\*(C` use mem \*(C'\fR", you drop (or comment out) the 2nd usage in the above example, you get:
.Sp
.Vb 8
\&  Bareword "ARRAY" not allowed while "strict subs" 
\&    in use at /tmp/ex line 27.
\&  syntax error at /tmp/ex line 27, near "ARRAY \e"
\&  Bareword "ARRAY" not allowed while "strict subs" 
\&    in use at /tmp/ex line 30.
\&  Bareword "ARRAY" not allowed while "strict subs" 
\&    in use at /tmp/ex line 31.
\&  Execution of /tmp/ex aborted due to compilation errors.
.Ve
.Sp
This happens because when \f(CW\*(C`use Xporter\*(C'\fR is called, the 
contents of \f(CW@EXPORT\fR is not known.  Even with the assignment
to \f(CW@EXPORT\fR, the "\f(CW\*(C`@EXPORT=qw(ARRAY)\*(C'\fR" being right above
the \f(CW\*(C`use Exporter\*(C'\fR statement.  Similarly to the first error, above,
Perl doesn't use the value of \f(CW@EXPORT\fR just above it.  Having
\&\f(CW\*(C` use mem \*(C'\fR in the second position forces Perl to put the assignment
to \f(CW@EXPORT\fR in \f(CW\*(C` mem \*(C'\fRory, so that when \f(CW\*(C` use Exporter \*(C'\fR is called, 
it can pick up the name of \f(CW\*(C`ARRAY\*(C'\fR as already being \*(L"exported\*(R" and
\&\fBdefined\fR.
.Sp
Without \f(CW\*(C`use mem\*(C'\fR putting the value of \f(CW@EXPORT\fR in \f(CW\*(C`mem\*(C'\fRory, 
\&\f(CW\*(C`ARRAY\*(C'\fR isn't defined, an you get the errors shown above.
.SS "Summary"
.IX Subsection "Summary"
The first usage allows '\f(CW\*(C`main\*(C'\fR' to find \f(CW\*(C`package Ar_Type\*(C'\fR, \fIalready in 
\&\f(CI\*(C`mem\*(C'\fIory\fR.
.PP
The second usage forces the definition of '\f(CW\*(C`ARRAY\*(C'\fR' into \f(CW\*(C`mem\*(C'\fRory so
they can be exported by an exporter function.
.PP
In \fBboth\fR cases, \f(CW\*(C`mem\*(C'\fR allows your already\-in\-\f(CW\*(C`mem\*(C'\fRory code to 
be used.  Thsi allows simplified programming and usage without knowledge
of or references to Perl's internal-flags or internal run phases.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Xporter for more help with exporting features from your modules, or
the older Exporter for the cadillac of exporting that will do everything you want (and a bit more). See P for more details about 
the generic print operator that is actually \fBuser friendly\fR, and see Types::Core for a more complete treatment of the \s-1CORE\s0 Types (with helpers for other perl data types besides  \f(CW\*(C`ARRAY\*(C'\fR's.
