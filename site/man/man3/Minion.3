.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Minion 3"
.TH Minion 3 "2020-10-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Minion \- Job queue
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Minion;
\&
\&  # Connect to backend
\&  my $minion = Minion\->new(Pg => \*(Aqpostgresql://postgres@/test\*(Aq);
\&
\&  # Add tasks
\&  $minion\->add_task(something_slow => sub {
\&    my ($job, @args) = @_;
\&    sleep 5;
\&    say \*(AqThis is a background worker process.\*(Aq;
\&  });
\&
\&  # Enqueue jobs
\&  $minion\->enqueue(something_slow => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]);
\&  $minion\->enqueue(something_slow => [1, 2, 3] => {priority => 5});
\&
\&  # Perform jobs for testing
\&  $minion\->enqueue(something_slow => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]);
\&  $minion\->perform_jobs;
\&
\&  # Start a worker to perform up to 12 jobs concurrently
\&  my $worker = $minion\->worker;
\&  $worker\->status\->{jobs} = 12;
\&  $worker\->run;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Minion is a high performance job queue for the Perl programming language, with support for multiple named queues,
priorities, delayed jobs, job dependencies, job progress, job results, retries with backoff, rate limiting, unique
jobs, expiring jobs, statistics, distributed workers, parallel processing, autoscaling, remote control,
Mojolicious <https://mojolicious.org> admin ui, resource leak protection and multiple backends (such as
PostgreSQL <https://www.postgresql.org>).
.PP
Job queues allow you to process time and/or computationally intensive tasks in background processes, outside of the
request/response lifecycle of web applications. Among those tasks you'll commonly find image resizing, spam filtering,
\&\s-1HTTP\s0 downloads, building tarballs, warming caches and basically everything else you can imagine that's not super fast.
.SH "BASICS"
.IX Header "BASICS"
You can use Minion as a standalone job queue or integrate it into Mojolicious applications with the plugin
Mojolicious::Plugin::Minion.
.PP
.Vb 1
\&  use Mojolicious::Lite;
\&
\&  plugin Minion => {Pg => \*(Aqpostgresql://sri:s3cret@localhost/test\*(Aq};
\&
\&  # Slow task
\&  app\->minion\->add_task(poke_mojo => sub {
\&    my $job = shift;
\&    $job\->app\->ua\->get(\*(Aqmojolicious.org\*(Aq);
\&    $job\->app\->log\->debug(\*(AqWe have poked mojolicious.org for a visitor\*(Aq);
\&  });
\&
\&  # Perform job in a background worker process
\&  get \*(Aq/\*(Aq => sub {
\&    my $c = shift;
\&    $c\->minion\->enqueue(\*(Aqpoke_mojo\*(Aq);
\&    $c\->render(text => \*(AqWe will poke mojolicious.org for you soon.\*(Aq);
\&  };
\&
\&  app\->start;
.Ve
.PP
Background worker processes are usually started with the command Minion::Command::minion::worker, which becomes
automatically available when an application loads Mojolicious::Plugin::Minion.
.PP
.Vb 1
\&  $ ./myapp.pl minion worker
.Ve
.PP
The worker process will fork a new process for every job that is being processed. This allows for resources such as
memory to be returned to the operating system once a job is finished. Perl fork is very fast, so don't worry about the
overhead.
.PP
.Vb 4
\&  Minion::Worker
\&  |\- Minion::Job [1]
\&  |\- Minion::Job [2]
\&  +\- ...
.Ve
.PP
By default up to four jobs will be processed in parallel, but that can be changed with configuration options or on
demand with signals.
.PP
.Vb 1
\&  $ ./myapp.pl minion worker \-j 12
.Ve
.PP
Jobs can be managed right from the command line with Minion::Command::minion::job.
.PP
.Vb 1
\&  $ ./myapp.pl minion job
.Ve
.PP
You can also add an admin ui to your application by loading the plugin Mojolicious::Plugin::Minion::Admin. Just make
sure to secure access before making your application publically accessible.
.PP
.Vb 2
\&  # Make admin ui available under "/minion"
\&  plugin \*(AqMinion::Admin\*(Aq;
.Ve
.PP
To manage background worker processes with systemd, you can use a unit configuration file like this.
.PP
.Vb 3
\&  [Unit]
\&  Description=My Mojolicious application workers
\&  After=postgresql.service
\&
\&  [Service]
\&  Type=simple
\&  ExecStart=/home/sri/myapp/myapp.pl minion worker \-m production
\&  KillMode=process
\&
\&  [Install]
\&  WantedBy=multi\-user.target
.Ve
.PP
Every job can fail or succeed, but not get lost, the system is eventually consistent and will preserve job results for
as long as you like, depending on \*(L"remove_after\*(R". While individual workers can fail in the middle of processing a
job, the system will detect this and ensure that no job is left in an uncertain state, depending on
\&\*(L"missing_after\*(R".
.SH "GROWING"
.IX Header "GROWING"
And as your application grows, you can move tasks into application specific plugins.
.PP
.Vb 2
\&  package MyApp::Task::PokeMojo;
\&  use Mojo::Base \*(AqMojolicious::Plugin\*(Aq;
\&
\&  sub register {
\&    my ($self, $app) = @_;
\&    $app\->minion\->add_task(poke_mojo => sub {
\&      my $job = shift;
\&      $job\->app\->ua\->get(\*(Aqmojolicious.org\*(Aq);
\&      $job\->app\->log\->debug(\*(AqWe have poked mojolicious.org for a visitor\*(Aq);
\&    });
\&  }
\&
\&  1;
.Ve
.PP
Which are loaded like any other plugin from your application.
.PP
.Vb 2
\&  # Mojolicious
\&  $app\->plugin(\*(AqMyApp::Task::PokeMojo\*(Aq);
\&
\&  # Mojolicious::Lite
\&  plugin \*(AqMyApp::Task::PokeMojo\*(Aq;
.Ve
.SH "TASK CLASSES"
.IX Header "TASK CLASSES"
For even more flexibility you can also move tasks into dedicated classes. Allowing the use of Perl features such as
inheritance and roles. But be aware that support for task classes is still \fB\s-1EXPERIMENTAL\s0\fR and might change without
warning!
.PP
.Vb 2
\&  package MyApp::Task::PokeMojo;
\&  use Mojo::Base \*(AqMinion::Job\*(Aq;
\&
\&  sub run {
\&    my $self = shift;
\&    $self\->app\->ua\->get(\*(Aqmojolicious.org\*(Aq);
\&    $self\->app\->log\->debug(\*(AqWe have poked mojolicious.org for a visitor\*(Aq);
\&  }
\&
\&  1;
.Ve
.PP
Task classes are registered just like any other task with \*(L"add_task\*(R" and you can even register the same class with
multiple names.
.PP
.Vb 1
\&  $minion\->add_task(poke_mojo => \*(AqMyApp::Task::PokeMojo\*(Aq);
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This distribution also contains a great example application you can use for inspiration. The link
checker <https://github.com/mojolicious/minion/tree/master/examples/linkcheck> will show you how to integrate background
jobs into well-structured Mojolicious applications.
.SH "EVENTS"
.IX Header "EVENTS"
Minion inherits all events from Mojo::EventEmitter and can emit the following new ones.
.SS "enqueue"
.IX Subsection "enqueue"
.Vb 4
\&  $minion\->on(enqueue => sub {
\&    my ($minion, $id) = @_;
\&    ...
\&  });
.Ve
.PP
Emitted after a job has been enqueued, in the process that enqueued it.
.PP
.Vb 4
\&  $minion\->on(enqueue => sub {
\&    my ($minion, $id) = @_;
\&    say "Job $id has been enqueued.";
\&  });
.Ve
.SS "worker"
.IX Subsection "worker"
.Vb 4
\&  $minion\->on(worker => sub {
\&    my ($minion, $worker) = @_;
\&    ...
\&  });
.Ve
.PP
Emitted in the worker process after it has been created.
.PP
.Vb 4
\&  $minion\->on(worker => sub {
\&    my ($minion, $worker) = @_;
\&    say "Worker $$ started.";
\&  });
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Minion implements the following attributes.
.SS "app"
.IX Subsection "app"
.Vb 2
\&  my $app = $minion\->app;
\&  $minion = $minion\->app(MyApp\->new);
.Ve
.PP
Application for job queue, defaults to a Mojo::HelloWorld object. Note that this attribute is weakened.
.SS "backend"
.IX Subsection "backend"
.Vb 2
\&  my $backend = $minion\->backend;
\&  $minion     = $minion\->backend(Minion::Backend::Pg\->new);
.Ve
.PP
Backend, usually a Minion::Backend::Pg object.
.SS "backoff"
.IX Subsection "backoff"
.Vb 2
\&  my $cb  = $minion\->backoff;
\&  $minion = $minion\->backoff(sub {...});
.Ve
.PP
A callback used to calculate the delay for automatically retried jobs, defaults to \f(CW\*(C`(retries ** 4) + 15\*(C'\fR (15, 16, 31,
96, 271, 640...), which means that roughly \f(CW25\fR attempts can be made in \f(CW21\fR days.
.PP
.Vb 4
\&  $minion\->backoff(sub {
\&    my $retries = shift;
\&    return ($retries ** 4) + 15 + int(rand 30);
\&  });
.Ve
.SS "missing_after"
.IX Subsection "missing_after"
.Vb 2
\&  my $after = $minion\->missing_after;
\&  $minion   = $minion\->missing_after(172800);
.Ve
.PP
Amount of time in seconds after which workers without a heartbeat will be considered missing and removed from the
registry by \*(L"repair\*(R", defaults to \f(CW1800\fR (30 minutes).
.SS "remove_after"
.IX Subsection "remove_after"
.Vb 2
\&  my $after = $minion\->remove_after;
\&  $minion   = $minion\->remove_after(86400);
.Ve
.PP
Amount of time in seconds after which jobs that have reached the state \f(CW\*(C`finished\*(C'\fR and have no unresolved dependencies
will be removed automatically by \*(L"repair\*(R", defaults to \f(CW172800\fR (2 days). It is not recommended to set this value
below 2 days.
.SS "stuck_after"
.IX Subsection "stuck_after"
.Vb 2
\&  my $after = $minion\->stuck_after;
\&  $minion   = $minion\->stuck_after(86400);
.Ve
.PP
Amount of time in seconds after which jobs that have not been processed will be considered stuck by \*(L"repair\*(R" and
transition to the \f(CW\*(C`failed\*(C'\fR state, defaults to \f(CW172800\fR (2 days).
.SS "tasks"
.IX Subsection "tasks"
.Vb 2
\&  my $tasks = $minion\->tasks;
\&  $minion   = $minion\->tasks({foo => sub {...}});
.Ve
.PP
Registered tasks.
.SH "METHODS"
.IX Header "METHODS"
Minion inherits all methods from Mojo::EventEmitter and implements the following new ones.
.SS "add_task"
.IX Subsection "add_task"
.Vb 2
\&  $minion = $minion\->add_task(foo => sub {...});
\&  $minion = $minion\->add_task(foo => \*(AqMyApp::Task::Foo\*(Aq);
.Ve
.PP
Register a task, which can be a closure or a custom Minion::Job subclass. Note that support for custom task classes
is \fB\s-1EXPERIMENTAL\s0\fR and might change without warning!
.PP
.Vb 7
\&  # Job with result
\&  $minion\->add_task(add => sub {
\&    my ($job, $first, $second) = @_;
\&    $job\->finish($first + $second);
\&  });
\&  my $id = $minion\->enqueue(add => [1, 1]);
\&  my $result = $minion\->job($id)\->info\->{result};
.Ve
.SS "broadcast"
.IX Subsection "broadcast"
.Vb 3
\&  my $bool = $minion\->broadcast(\*(Aqsome_command\*(Aq);
\&  my $bool = $minion\->broadcast(\*(Aqsome_command\*(Aq, [@args]);
\&  my $bool = $minion\->broadcast(\*(Aqsome_command\*(Aq, [@args], [$id1, $id2, $id3]);
.Ve
.PP
Broadcast remote control command to one or more workers.
.PP
.Vb 2
\&  # Broadcast "stop" command to all workers to kill job 10025
\&  $minion\->broadcast(\*(Aqstop\*(Aq, [10025]);
\&
\&  # Broadcast "kill" command to all workers to interrupt job 10026
\&  $minion\->broadcast(\*(Aqkill\*(Aq, [\*(AqINT\*(Aq, 10026]);
\&
\&  # Broadcast "jobs" command to pause worker 23
\&  $minion\->broadcast(\*(Aqjobs\*(Aq, [0], [23]);
.Ve
.SS "class_for_task"
.IX Subsection "class_for_task"
.Vb 1
\&  my $class = $minion\->class_for_task(\*(Aqfoo\*(Aq);
.Ve
.PP
Return job class for task. Note that this method is \fB\s-1EXPERIMENTAL\s0\fR and might change without warning!
.SS "enqueue"
.IX Subsection "enqueue"
.Vb 3
\&  my $id = $minion\->enqueue(\*(Aqfoo\*(Aq);
\&  my $id = $minion\->enqueue(foo => [@args]);
\&  my $id = $minion\->enqueue(foo => [@args] => {priority => 1});
.Ve
.PP
Enqueue a new job with \f(CW\*(C`inactive\*(C'\fR state. Arguments get serialized by the \*(L"backend\*(R" (often with Mojo::JSON), so
you shouldn't send objects and be careful with binary data, nested data structures with hash and array references are
fine though.
.PP
These options are currently available:
.IP "attempts" 2
.IX Item "attempts"
.Vb 1
\&  attempts => 25
.Ve
.Sp
Number of times performing this job will be attempted, with a delay based on \*(L"backoff\*(R" after the first attempt,
defaults to \f(CW1\fR.
.IP "delay" 2
.IX Item "delay"
.Vb 1
\&  delay => 10
.Ve
.Sp
Delay job for this many seconds (from now), defaults to \f(CW0\fR.
.IP "expire" 2
.IX Item "expire"
.Vb 1
\&  expire => 300
.Ve
.Sp
Job is valid for this many seconds (from now) before it expires. Note that this option is \fB\s-1EXPERIMENTAL\s0\fR and might
change without warning!
.IP "lax" 2
.IX Item "lax"
.Vb 1
\&  lax => 1
.Ve
.Sp
Existing jobs this job depends on may also have transitioned to the \f(CW\*(C`failed\*(C'\fR state to allow for it to be processed,
defaults to \f(CW\*(C`false\*(C'\fR. Note that this option is \fB\s-1EXPERIMENTAL\s0\fR and might change without warning!
.IP "notes" 2
.IX Item "notes"
.Vb 1
\&  notes => {foo => \*(Aqbar\*(Aq, baz => [1, 2, 3]}
.Ve
.Sp
Hash reference with arbitrary metadata for this job that gets serialized by the \*(L"backend\*(R" (often with
Mojo::JSON), so you shouldn't send objects and be careful with binary data, nested data structures with hash and
array references are fine though.
.IP "parents" 2
.IX Item "parents"
.Vb 1
\&  parents => [$id1, $id2, $id3]
.Ve
.Sp
One or more existing jobs this job depends on, and that need to have transitioned to the state \f(CW\*(C`finished\*(C'\fR before it
can be processed.
.IP "priority" 2
.IX Item "priority"
.Vb 1
\&  priority => 5
.Ve
.Sp
Job priority, defaults to \f(CW0\fR. Jobs with a higher priority get performed first.
.IP "queue" 2
.IX Item "queue"
.Vb 1
\&  queue => \*(Aqimportant\*(Aq
.Ve
.Sp
Queue to put job in, defaults to \f(CW\*(C`default\*(C'\fR.
.SS "foreground"
.IX Subsection "foreground"
.Vb 1
\&  my $bool = $minion\->foreground($id);
.Ve
.PP
Retry job in \f(CW\*(C`minion_foreground\*(C'\fR queue, then perform it right away with a temporary worker in this process, very
useful for debugging.
.SS "guard"
.IX Subsection "guard"
.Vb 2
\&  my $guard = $minion\->guard(\*(Aqfoo\*(Aq, 3600);
\&  my $guard = $minion\->guard(\*(Aqfoo\*(Aq, 3600, {limit => 20});
.Ve
.PP
Same as \*(L"lock\*(R", but returns a scope guard object that automatically releases the lock as soon as the object is
destroyed, or \f(CW\*(C`undef\*(C'\fR if aquiring the lock failed.
.PP
.Vb 7
\&  # Only one job should run at a time (unique job)
\&  $minion\->add_task(do_unique_stuff => sub {
\&    my ($job, @args) = @_;
\&    return $job\->finish(\*(AqPrevious job is still active\*(Aq)
\&      unless my $guard = $minion\->guard(\*(Aqfragile_backend_service\*(Aq, 7200);
\&    ...
\&  });
\&
\&  # Only five jobs should run at a time and we try again later if necessary
\&  $minion\->add_task(do_concurrent_stuff => sub {
\&    my ($job, @args) = @_;
\&    return $job\->retry({delay => 30})
\&      unless my $guard = $minion\->guard(\*(Aqsome_web_service\*(Aq, 60, {limit => 5});
\&    ...
\&  });
.Ve
.SS "history"
.IX Subsection "history"
.Vb 1
\&  my $history = $minion\->history;
.Ve
.PP
Get history information for job queue.
.PP
These fields are currently available:
.IP "daily" 2
.IX Item "daily"
.Vb 1
\&  daily => [{epoch => 12345, finished_jobs => 95, failed_jobs => 2}, ...]
.Ve
.Sp
Hourly counts for processed jobs from the past day.
.SS "is_locked"
.IX Subsection "is_locked"
.Vb 1
\&  my $bool = $minion\->is_locked(\*(Aqfoo\*(Aq);
.Ve
.PP
Check if a lock with that name is currently active.
.SS "job"
.IX Subsection "job"
.Vb 1
\&  my $job = $minion\->job($id);
.Ve
.PP
Get Minion::Job object without making any changes to the actual job or return \f(CW\*(C`undef\*(C'\fR if job does not exist.
.PP
.Vb 2
\&  # Check job state
\&  my $state = $minion\->job($id)\->info\->{state};
\&
\&  # Get job metadata
\&  my $progress = $minion\->$job($id)\->info\->{notes}{progress};
\&
\&  # Get job result
\&  my $result = $minion\->job($id)\->info\->{result};
.Ve
.SS "jobs"
.IX Subsection "jobs"
.Vb 2
\&  my $jobs = $minion\->jobs;
\&  my $jobs = $minion\->jobs({states => [\*(Aqinactive\*(Aq]});
.Ve
.PP
Return Minion::Iterator object to safely iterate through job information.
.PP
.Vb 5
\&  # Iterate through jobs for two tasks
\&  my $jobs = $minion\->jobs({tasks => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]});
\&  while (my $info = $jobs\->next) {
\&    say "$info\->{id}: $info\->{state}";
\&  }
\&
\&  # Remove all failed jobs from a named queue
\&  my $jobs = $minion\->jobs({states => [\*(Aqfailed\*(Aq], queues => [\*(Aqunimportant\*(Aq]});
\&  while (my $info = $jobs\->next) {
\&    $minion\->job($info\->{id})\->remove;
\&  }
\&
\&  # Count failed jobs for a task
\&  say $minion\->jobs({states => [\*(Aqfailed\*(Aq], tasks => [\*(Aqfoo\*(Aq]})\->total;
.Ve
.PP
These options are currently available:
.IP "ids" 2
.IX Item "ids"
.Vb 1
\&  ids => [\*(Aq23\*(Aq, \*(Aq24\*(Aq]
.Ve
.Sp
List only jobs with these ids.
.IP "notes" 2
.IX Item "notes"
.Vb 1
\&  notes => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]
.Ve
.Sp
List only jobs with one of these notes.
.IP "queues" 2
.IX Item "queues"
.Vb 1
\&  queues => [\*(Aqimportant\*(Aq, \*(Aqunimportant\*(Aq]
.Ve
.Sp
List only jobs in these queues.
.IP "states" 2
.IX Item "states"
.Vb 1
\&  states => [\*(Aqinactive\*(Aq, \*(Aqactive\*(Aq]
.Ve
.Sp
List only jobs in these states.
.IP "tasks" 2
.IX Item "tasks"
.Vb 1
\&  tasks => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]
.Ve
.Sp
List only jobs for these tasks.
.PP
These fields are currently available:
.IP "args" 2
.IX Item "args"
.Vb 1
\&  args => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]
.Ve
.Sp
Job arguments.
.IP "attempts" 2
.IX Item "attempts"
.Vb 1
\&  attempts => 25
.Ve
.Sp
Number of times performing this job will be attempted.
.IP "children" 2
.IX Item "children"
.Vb 1
\&  children => [\*(Aq10026\*(Aq, \*(Aq10027\*(Aq, \*(Aq10028\*(Aq]
.Ve
.Sp
Jobs depending on this job.
.IP "created" 2
.IX Item "created"
.Vb 1
\&  created => 784111777
.Ve
.Sp
Epoch time job was created.
.IP "delayed" 2
.IX Item "delayed"
.Vb 1
\&  delayed => 784111777
.Ve
.Sp
Epoch time job was delayed to.
.IP "expires" 2
.IX Item "expires"
.Vb 1
\&  expires => 784111777
.Ve
.Sp
Epoch time job is valid until before it expires.
.IP "finished" 2
.IX Item "finished"
.Vb 1
\&  finished => 784111777
.Ve
.Sp
Epoch time job was finished.
.IP "id" 2
.IX Item "id"
.Vb 1
\&  id => 10025
.Ve
.Sp
Job id.
.IP "lax" 2
.IX Item "lax"
.Vb 1
\&  lax => 0
.Ve
.Sp
Existing jobs this job depends on may also have failed to allow for it to be processed.
.IP "notes" 2
.IX Item "notes"
.Vb 1
\&  notes => {foo => \*(Aqbar\*(Aq, baz => [1, 2, 3]}
.Ve
.Sp
Hash reference with arbitrary metadata for this job.
.IP "parents" 2
.IX Item "parents"
.Vb 1
\&  parents => [\*(Aq10023\*(Aq, \*(Aq10024\*(Aq, \*(Aq10025\*(Aq]
.Ve
.Sp
Jobs this job depends on.
.IP "priority" 2
.IX Item "priority"
.Vb 1
\&  priority => 3
.Ve
.Sp
Job priority.
.IP "queue" 2
.IX Item "queue"
.Vb 1
\&  queue => \*(Aqimportant\*(Aq
.Ve
.Sp
Queue name.
.IP "result" 2
.IX Item "result"
.Vb 1
\&  result => \*(AqAll went well!\*(Aq
.Ve
.Sp
Job result.
.IP "retried" 2
.IX Item "retried"
.Vb 1
\&  retried => 784111777
.Ve
.Sp
Epoch time job has been retried.
.IP "retries" 2
.IX Item "retries"
.Vb 1
\&  retries => 3
.Ve
.Sp
Number of times job has been retried.
.IP "started" 2
.IX Item "started"
.Vb 1
\&  started => 784111777
.Ve
.Sp
Epoch time job was started.
.IP "state" 2
.IX Item "state"
.Vb 1
\&  state => \*(Aqinactive\*(Aq
.Ve
.Sp
Current job state, usually \f(CW\*(C`active\*(C'\fR, \f(CW\*(C`failed\*(C'\fR, \f(CW\*(C`finished\*(C'\fR or \f(CW\*(C`inactive\*(C'\fR.
.IP "task" 2
.IX Item "task"
.Vb 1
\&  task => \*(Aqfoo\*(Aq
.Ve
.Sp
Task name.
.IP "time" 2
.IX Item "time"
.Vb 1
\&  time => 78411177
.Ve
.Sp
Server time.
.IP "worker" 2
.IX Item "worker"
.Vb 1
\&  worker => \*(Aq154\*(Aq
.Ve
.Sp
Id of worker that is processing the job.
.SS "lock"
.IX Subsection "lock"
.Vb 2
\&  my $bool = $minion\->lock(\*(Aqfoo\*(Aq, 3600);
\&  my $bool = $minion\->lock(\*(Aqfoo\*(Aq, 3600, {limit => 20});
.Ve
.PP
Try to acquire a named lock that will expire automatically after the given amount of time in seconds. You can release
the lock manually with \*(L"unlock\*(R" to limit concurrency, or let it expire for rate limiting. For convenience you can
also use \*(L"guard\*(R" to release the lock automatically, even if the job failed.
.PP
.Vb 8
\&  # Only one job should run at a time (unique job)
\&  $minion\->add_task(do_unique_stuff => sub {
\&    my ($job, @args) = @_;
\&    return $job\->finish(\*(AqPrevious job is still active\*(Aq)
\&      unless $minion\->lock(\*(Aqfragile_backend_service\*(Aq, 7200);
\&    ...
\&    $minion\->unlock(\*(Aqfragile_backend_service\*(Aq);
\&  });
\&
\&  # Only five jobs should run at a time and we wait for our turn
\&  $minion\->add_task(do_concurrent_stuff => sub {
\&    my ($job, @args) = @_;
\&    sleep 1 until $minion\->lock(\*(Aqsome_web_service\*(Aq, 60, {limit => 5});
\&    ...
\&    $minion\->unlock(\*(Aqsome_web_service\*(Aq);
\&  });
\&
\&  # Only a hundred jobs should run per hour and we try again later if necessary
\&  $minion\->add_task(do_rate_limited_stuff => sub {
\&    my ($job, @args) = @_;
\&    return $job\->retry({delay => 3600})
\&      unless $minion\->lock(\*(Aqanother_web_service\*(Aq, 3600, {limit => 100});
\&    ...
\&  });
.Ve
.PP
An expiration time of \f(CW0\fR can be used to check if a named lock could have been acquired without creating one.
.PP
.Vb 2
\&  # Check if the lock "foo" could have been acquired
\&  say \*(AqLock could have been acquired\*(Aq unless $minion\->lock(\*(Aqfoo\*(Aq, 0);
.Ve
.PP
Or to simply check if a named lock already exists you can also use \*(L"is_locked\*(R".
.PP
These options are currently available:
.IP "limit" 2
.IX Item "limit"
.Vb 1
\&  limit => 20
.Ve
.Sp
Number of shared locks with the same name that can be active at the same time, defaults to \f(CW1\fR.
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $minion = Minion\->new(Pg => \*(Aqpostgresql://postgres@/test\*(Aq);
\&  my $minion = Minion\->new(Pg => Mojo::Pg\->new);
.Ve
.PP
Construct a new Minion object.
.SS "perform_jobs"
.IX Subsection "perform_jobs"
.Vb 2
\&  $minion\->perform_jobs;
\&  $minion\->perform_jobs({queues => [\*(Aqimportant\*(Aq]});
.Ve
.PP
Perform all jobs with a temporary worker, very useful for testing.
.PP
.Vb 4
\&  # Longer version
\&  my $worker = $minion\->worker;
\&  while (my $job = $worker\->register\->dequeue(0)) { $job\->perform }
\&  $worker\->unregister;
.Ve
.PP
These options are currently available:
.IP "queues" 2
.IX Item "queues"
.Vb 1
\&  queues => [\*(Aqimportant\*(Aq]
.Ve
.Sp
One or more queues to dequeue jobs from, defaults to \f(CW\*(C`default\*(C'\fR.
.SS "repair"
.IX Subsection "repair"
.Vb 1
\&  $minion = $minion\->repair;
.Ve
.PP
Repair worker registry and job queue if necessary.
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&  $minion = $minion\->reset({all => 1});
.Ve
.PP
Reset job queue.
.PP
These options are currently available:
.IP "all" 2
.IX Item "all"
.Vb 1
\&  all => 1
.Ve
.Sp
Reset everything.
.IP "locks" 2
.IX Item "locks"
.Vb 1
\&  locks => 1
.Ve
.Sp
Reset only locks.
.SS "result_p"
.IX Subsection "result_p"
.Vb 2
\&  my $promise = $minion\->result_p($id);
\&  my $promise = $minion\->result_p($id, {interval => 5});
.Ve
.PP
Return a Mojo::Promise object for the result of a job. The state \f(CW\*(C`finished\*(C'\fR will result in the promise being
\&\f(CW\*(C`fullfilled\*(C'\fR, and the state \f(CW\*(C`failed\*(C'\fR in the promise being \f(CW\*(C`rejected\*(C'\fR. This operation can be cancelled by resolving
the promise manually at any time.
.PP
.Vb 10
\&  # Enqueue job and receive the result at some point in the future
\&  my $id = $minion\->enqueue(\*(Aqfoo\*(Aq);
\&  $minion\->result_p($id)\->then(sub {
\&    my $info   = shift;
\&    my $result = ref $info ? $info\->{result} : \*(AqJob already removed\*(Aq;
\&    say "Finished: $result";
\&  })\->catch(sub {
\&    my $info = shift;
\&    say "Failed: $info\->{result}";
\&  })\->wait;
.Ve
.PP
These options are currently available:
.IP "interval" 2
.IX Item "interval"
.Vb 1
\&  interval => 5
.Ve
.Sp
Polling interval in seconds for checking if the state of the job has changed, defaults to \f(CW3\fR.
.SS "stats"
.IX Subsection "stats"
.Vb 1
\&  my $stats = $minion\->stats;
.Ve
.PP
Get statistics for the job queue.
.PP
.Vb 2
\&  # Check idle workers
\&  my $idle = $minion\->stats\->{inactive_workers};
.Ve
.PP
These fields are currently available:
.IP "active_jobs" 2
.IX Item "active_jobs"
.Vb 1
\&  active_jobs => 100
.Ve
.Sp
Number of jobs in \f(CW\*(C`active\*(C'\fR state.
.IP "active_locks" 2
.IX Item "active_locks"
.Vb 1
\&  active_locks => 100
.Ve
.Sp
Number of active named locks.
.IP "active_workers" 2
.IX Item "active_workers"
.Vb 1
\&  active_workers => 100
.Ve
.Sp
Number of workers that are currently processing a job.
.IP "delayed_jobs" 2
.IX Item "delayed_jobs"
.Vb 1
\&  delayed_jobs => 100
.Ve
.Sp
Number of jobs in \f(CW\*(C`inactive\*(C'\fR state that are scheduled to run at specific time in the future or have unresolved
dependencies.
.IP "enqueued_jobs" 2
.IX Item "enqueued_jobs"
.Vb 1
\&  enqueued_jobs => 100000
.Ve
.Sp
Rough estimate of how many jobs have ever been enqueued.
.IP "failed_jobs" 2
.IX Item "failed_jobs"
.Vb 1
\&  failed_jobs => 100
.Ve
.Sp
Number of jobs in \f(CW\*(C`failed\*(C'\fR state.
.IP "finished_jobs" 2
.IX Item "finished_jobs"
.Vb 1
\&  finished_jobs => 100
.Ve
.Sp
Number of jobs in \f(CW\*(C`finished\*(C'\fR state.
.IP "inactive_jobs" 2
.IX Item "inactive_jobs"
.Vb 1
\&  inactive_jobs => 100
.Ve
.Sp
Number of jobs in \f(CW\*(C`inactive\*(C'\fR state.
.IP "inactive_workers" 2
.IX Item "inactive_workers"
.Vb 1
\&  inactive_workers => 100
.Ve
.Sp
Number of workers that are currently not processing a job.
.IP "uptime" 2
.IX Item "uptime"
.Vb 1
\&  uptime => 1000
.Ve
.Sp
Uptime in seconds.
.SS "unlock"
.IX Subsection "unlock"
.Vb 1
\&  my $bool = $minion\->unlock(\*(Aqfoo\*(Aq);
.Ve
.PP
Release a named lock that has been previously acquired with \*(L"lock\*(R".
.SS "worker"
.IX Subsection "worker"
.Vb 1
\&  my $worker = $minion\->worker;
.Ve
.PP
Build Minion::Worker object. Note that this method should only be used to implement custom workers.
.PP
.Vb 5
\&  # Use the standard worker with all its features
\&  my $worker = $minion\->worker;
\&  $worker\->status\->{jobs} = 12;
\&  $worker\->status\->{queues} = [\*(Aqimportant\*(Aq];
\&  $worker\->run;
\&
\&  # Perform one job manually in a separate process
\&  my $worker = $minion\->repair\->worker\->register;
\&  my $job    = $worker\->dequeue(5);
\&  $job\->perform;
\&  $worker\->unregister;
\&
\&  # Perform one job manually in this process
\&  my $worker = $minion\->repair\->worker\->register;
\&  my $job    = $worker\->dequeue(5);
\&  if (my $err = $job\->execute) { $job\->fail($err) }
\&  else                         { $job\->finish }
\&  $worker\->unregister;
\&
\&  # Build a custom worker performing multiple jobs at the same time
\&  my %jobs;
\&  my $worker = $minion\->repair\->worker\->register;
\&  do {
\&    for my $id (keys %jobs) {
\&      delete $jobs{$id} if $jobs{$id}\->is_finished;
\&    }
\&    if (keys %jobs >= 4) { sleep 5 }
\&    else {
\&      my $job = $worker\->dequeue(5);
\&      $jobs{$job\->id} = $job\->start if $job;
\&    }
\&  } while keys %jobs;
\&  $worker\->unregister;
.Ve
.SS "workers"
.IX Subsection "workers"
.Vb 2
\&  my $workers = $minion\->workers;
\&  my $workers = $minion\->workers({ids => [2, 3]});
.Ve
.PP
Return Minion::Iterator object to safely iterate through worker information.
.PP
.Vb 5
\&  # Iterate through workers
\&  my $workers = $minion\->workers;
\&  while (my $info = $workers\->next) {
\&    say "$info\->{id}: $info\->{host}";
\&  }
.Ve
.PP
These options are currently available:
.IP "ids" 2
.IX Item "ids"
.Vb 1
\&  ids => [\*(Aq23\*(Aq, \*(Aq24\*(Aq]
.Ve
.Sp
List only workers with these ids.
.PP
These fields are currently available:
.IP "id" 2
.IX Item "id"
.Vb 1
\&  id => 22
.Ve
.Sp
Worker id.
.IP "host" 2
.IX Item "host"
.Vb 1
\&  host => \*(Aqlocalhost\*(Aq
.Ve
.Sp
Worker host.
.IP "jobs" 2
.IX Item "jobs"
.Vb 1
\&  jobs => [\*(Aq10023\*(Aq, \*(Aq10024\*(Aq, \*(Aq10025\*(Aq, \*(Aq10029\*(Aq]
.Ve
.Sp
Ids of jobs the worker is currently processing.
.IP "notified" 2
.IX Item "notified"
.Vb 1
\&  notified => 784111777
.Ve
.Sp
Epoch time worker sent the last heartbeat.
.IP "pid" 2
.IX Item "pid"
.Vb 1
\&  pid => 12345
.Ve
.Sp
Process id of worker.
.IP "started" 2
.IX Item "started"
.Vb 1
\&  started => 784111777
.Ve
.Sp
Epoch time worker was started.
.IP "status" 2
.IX Item "status"
.Vb 1
\&  status => {queues => [\*(Aqdefault\*(Aq, \*(Aqimportant\*(Aq]}
.Ve
.Sp
Hash reference with whatever status information the worker would like to share.
.SH "API"
.IX Header "API"
This is the class hierarchy of the Minion distribution.
.IP "\(bu" 2
Minion
.IP "\(bu" 2
Minion::Backend
.RS 2
.IP "\(bu" 2
Minion::Backend::Pg
.RE
.RS 2
.RE
.IP "\(bu" 2
Minion::Command::minion
.IP "\(bu" 2
Minion::Command::minion::job
.IP "\(bu" 2
Minion::Command::minion::worker
.IP "\(bu" 2
Minion::Iterator
.IP "\(bu" 2
Minion::Job
.IP "\(bu" 2
Minion::Worker
.IP "\(bu" 2
Mojolicious::Plugin::Minion
.IP "\(bu" 2
Mojolicious::Plugin::Minion::Admin
.SH "BUNDLED FILES"
.IX Header "BUNDLED FILES"
The Minion distribution includes a few files with different licenses that have been bundled for internal use.
.SS "Minion Artwork"
.IX Subsection "Minion Artwork"
.Vb 1
\&  Copyright (C) 2017, Sebastian Riedel.
.Ve
.PP
Licensed under the CC-SA License, Version 4.0 <http://creativecommons.org/licenses/by\-sa/4.0>.
.SS "Bootstrap"
.IX Subsection "Bootstrap"
.Vb 1
\&  Copyright (C) 2011\-2018 The Bootstrap Authors.
.Ve
.PP
Licensed under the \s-1MIT\s0 License, <http://creativecommons.org/licenses/MIT>.
.SS "D3.js"
.IX Subsection "D3.js"
.Vb 1
\&  Copyright (C) 2010\-2016, Michael Bostock.
.Ve
.PP
Licensed under the 3\-Clause \s-1BSD\s0 License, <https://opensource.org/licenses/BSD\-3\-Clause>.
.SS "epoch.js"
.IX Subsection "epoch.js"
.Vb 1
\&  Copyright (C) 2014 Fastly, Inc.
.Ve
.PP
Licensed under the \s-1MIT\s0 License, <http://creativecommons.org/licenses/MIT>.
.SS "Font Awesome"
.IX Subsection "Font Awesome"
.Vb 1
\&  Copyright (C) Dave Gandy.
.Ve
.PP
Licensed under the \s-1MIT\s0 License, <http://creativecommons.org/licenses/MIT>, and the \s-1SIL OFL 1.1,\s0
<http://scripts.sil.org/OFL>.
.SS "moment.js"
.IX Subsection "moment.js"
.Vb 1
\&  Copyright (C) JS Foundation and other contributors.
.Ve
.PP
Licensed under the \s-1MIT\s0 License, <http://creativecommons.org/licenses/MIT>.
.SS "popper.js"
.IX Subsection "popper.js"
.Vb 1
\&  Copyright (C) Federico Zivolo 2017.
.Ve
.PP
Licensed under the \s-1MIT\s0 License, <http://creativecommons.org/licenses/MIT>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sebastian Riedel, \f(CW\*(C`sri@cpan.org\*(C'\fR.
.SH "CREDITS"
.IX Header "CREDITS"
In alphabetical order:
.Sp
.RS 2
Andrey Khozov
.Sp
Andrii Nikitin
.Sp
Brian Medley
.Sp
Franz Skale
.Sp
Hubert \*(L"depesz\*(R" Lubaczewski
.Sp
Joel Berger
.Sp
Paul Williams
.Sp
Stefan Adams
.RE
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2014\-2020, Sebastian Riedel and others.
.PP
This program is free software, you can redistribute it and/or modify it under the terms of the Artistic License version
2.0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<https://github.com/mojolicious/minion>, <https://minion.pm>, Mojolicious::Guides, <https://mojolicious.org>.
