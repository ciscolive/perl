.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Shiras::Report::MetaMessage 3"
.TH Log::Shiras::Report::MetaMessage 3 "2016-10-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Shiras::Report::MetaMessage \- Add data to messages for reports
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&        use MooseX::ShortCut::BuildInstance qw( build_class );
\&        use Log::Shiras::Report;
\&        use Log::Shiras::Report::MetaMessage;
\&        use Data::Dumper;
\&        my      $message_class = build_class(
\&                        package => \*(AqTest\*(Aq,
\&                        add_roles_in_sequence => [
\&                                \*(AqLog::Shiras::Report\*(Aq,
\&                                \*(AqLog::Shiras::Report::MetaMessage\*(Aq,
\&                        ],
\&                        add_methods =>{
\&                                add_line => sub{ 
\&                                        my( $self, $message ) = @_;
\&                                        print Dumper( $message\->{message} );
\&                                        return 1;
\&                                },
\&                        }
\&                );
\&        my      $message_instance = $message_class\->new( 
\&                        prepend =>[qw( lets go )],
\&                        postpend =>[qw( store package )],
\&                ); 
\&        $message_instance\->add_line({ message =>[qw( to the )], package => \*(Aqhere\*(Aq, });
\&        
\&        #######################################################################################
\&        # Synopsis output to this point
\&        # 01: $VAR1 = [
\&        # 02:           \*(Aqlets\*(Aq,
\&        # 03:           \*(Aqgo\*(Aq,
\&        # 04:           \*(Aqto\*(Aq,
\&        # 05:           \*(Aqthe\*(Aq,
\&        # 06:           \*(Aqstore\*(Aq,
\&        # 07:           \*(Aqhere\*(Aq
\&        # 08:         ];
\&        #######################################################################################
\&        
\&        $message_instance\->set_post_sub(
\&                sub{
\&                        my $message = $_[0];
\&                        my $new_ref;
\&                        for my $element ( @{$message\->{message}} ){
\&                                push @$new_ref, uc( $element );
\&                        }
\&                        $message\->{message} = $new_ref;
\&                }
\&        );
\&        $message_instance\->add_line({ message =>[qw( from the )], package => \*(Aqhere\*(Aq, });
\&        
\&        #######################################################################################
\&        # Synopsis output addition to this point
\&        # 01: $VAR1 = [
\&        # 02:           \*(AqLETS\*(Aq,
\&        # 03:           \*(AqGO\*(Aq,
\&        # 04:           \*(AqFROM\*(Aq,
\&        # 05:           \*(AqTHE\*(Aq,
\&        # 06:           \*(AqSTORE\*(Aq,
\&        # 07:           \*(AqHERE\*(Aq
\&        # 08:         ];
\&        #######################################################################################
\&        
\&        $message_instance = $message_class\->new(
\&                hashpend => {
\&                        locate_jenny => sub{
\&                                my $message = $_[0];
\&                                my $answer;
\&                                for my $person ( keys %{$message\->{message}\->[0]} ){
\&                                        if( $person eq \*(AqJenny\*(Aq ){
\&                                                $answer = "$person lives in: $message\->{message}\->[0]\->{$person}" ;
\&                                                last;
\&                                        }
\&                                }
\&                                return $answer;
\&                        }
\&                },
\&        );
\&        $message_instance\->add_line({ message =>[{ 
\&                Frank => \*(AqSan Fransisco\*(Aq,
\&                Donna => \*(AqCarbondale\*(Aq,
\&                Jenny => \*(AqPortland\*(Aq }], });
\&        
\&        #######################################################################################
\&        # Synopsis output addition to this point
\&        # 01: $VAR1 = [
\&        # 02:           {
\&        # 03:             \*(Aqlocate_jenny\*(Aq => \*(AqJenny lives in: Portland\*(Aq,
\&        # 04:             \*(AqDonna\*(Aq => \*(AqCarbondale\*(Aq,
\&        # 05:             \*(AqJenny\*(Aq => \*(AqPortland\*(Aq,
\&        # 06:             \*(AqFrank\*(Aq => \*(AqSan Fransisco\*(Aq
\&        # 07:           }
\&        # 08:         ];
\&        #######################################################################################
\&        
\&        $message_instance\->set_pre_sub(
\&                sub{
\&                        my $message = $_[0];
\&                        my $lookup = {
\&                                        \*(AqSan Fransisco\*(Aq => \*(AqCA\*(Aq,
\&                                        \*(AqCarbondale\*(Aq => \*(AqIL\*(Aq,
\&                                        \*(AqPortland\*(Aq => \*(AqOR\*(Aq,
\&                                };
\&                        for my $element ( keys %{$message\->{message}\->[0]} ){
\&                                $message\->{message}\->[0]\->{$element} .=
\&                                        \*(Aq, \*(Aq . $lookup\->{$message\->{message}\->[0]\->{$element}};
\&                        }
\&                } 
\&        );
\&        $message_instance\->add_line({ message =>[{
\&                Frank => \*(AqSan Fransisco\*(Aq,
\&                Donna => \*(AqCarbondale\*(Aq,
\&                Jenny => \*(AqPortland\*(Aq }], });
\&        
\&        #######################################################################################
\&        # Synopsis output addition to this point
\&        # 01: $VAR1 = [
\&        # 02:           {
\&        # 03:             \*(Aqlocate_jenny\*(Aq => \*(AqJenny lives in: Portland, OR\*(Aq,
\&        # 04:             \*(AqDonna\*(Aq => \*(AqCarbondale, IL\*(Aq,
\&        # 05:             \*(AqJenny\*(Aq => \*(AqPortland, OR\*(Aq,
\&        # 06:             \*(AqFrank\*(Aq => \*(AqSan Fransisco, CA\*(Aq
\&        # 07:           }
\&        # 08:         ];
\&        #######################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is Moose role that can be used by Log::Shiras::Report to massage the message prior 
to 'add_line' being implemented in the report.  It uses the hook built in the to Report 
role for the method 'manage_message'.
.PP
There are five ways to affect the passed message ref.  Each way is set up as an attribute
 of the class.  Details of how each is implemented is explained in the 
Attributes section.
.SS "Warning"
.IX Subsection "Warning"
\&'hashpend' and 'prepend' \- 'postpend' can conflict since 'hashpend' acts on the first 
message element as if it were a hashref and the next two act as if the message is a list.  
A good rule of thumb is to not use both sets together unless you really know what is going 
on.
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes 
after the instance is created see the attribute methods.
.PP
\fIpre_sub\fR
.IX Subsection "pre_sub"
.Sp
.RS 4
\&\fBDefinition:\fR This is a place to store a perl closure that will be passed the full
\&\f(CW$message_ref\fR including meta data.  The results of the closure are not used so any 
desired change should be done to the \f(CW$message_ref\fR itself since it is persistent.  The 
action takes place before all the other attributes are implemented so the changes will 
\&\s-1NOT\s0 be available to process.  See the example in the \s-1SYNOPSIS.\s0
.Sp
\&\fBDefault:\fR None
.Sp
\&\fBRequired:\fR No
.Sp
\&\fBRange:\fR it must pass the is_CodeRef test
.Sp
\&\fBattribute methods\fR
.Sp
.RS 4
\&\fBclear_pre_sub\fR
.Sp
.RS 4
\&\fBDescription\fR removes the stored attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_pre_sub\fR
.Sp
.RS 4
\&\fBDescription\fR predicate for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBget_pre_sub\fR
.Sp
.RS 4
\&\fBDescription\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBset_pre_sub( \f(CB$closure\fB )\fR
.Sp
.RS 4
\&\fBDescription\fR sets the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIhashpend\fR
.IX Subsection "hashpend"
.Sp
.RS 4
\&\fBDefinition:\fR This will update the position %{$message_ref\->{message}\->[0]}.  If 
that position is not a hash ref then. It will kill the process with Carp \- 
confess.  After it passes that test it will perform the following assuming the 
attribute is retrieved as \f(CW$hashpend_ref\fR and the entire message is passed as 
\&\f(CW$message_ref\fR;
.Sp
.Vb 8
\&        for my $element ( keys %$hashpend_ref ){
\&                $message_ref\->{message}\->[0]\->{$element} =
\&                        is_CodeRef( $hashpend_ref\->{$element} ) ? 
\&                                $hashpend_ref\->{$element}\->( $message_ref ) : 
\&                        exists $message_ref\->{$hashpend_ref\->{$element}} ? 
\&                                $message_ref\->{$hashpend_ref\->{$element}} :
\&                                $hashpend_ref\->{$element} ;
\&        }
.Ve
.Sp
This means that if the value of the \f(CW$element\fR is a closure then it will use the results 
of that and add that to the message sub-hashref.  Otherwise it will attempt to pull 
the equivalent key from the \f(CW$message\fR meta-data and add it to the message sub-hashref or 
if all else fails just load the key value pair as it stands to the message sub-hashref.
.Sp
\&\fBDefault:\fR None
.Sp
\&\fBRequired:\fR No
.Sp
\&\fBRange:\fR it must be a hashref
.Sp
\&\fBattribute methods\fR
.Sp
.RS 4
\&\fBclear_hashpend\fR
.Sp
.RS 4
\&\fBDescription\fR removes the stored attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_hashpend\fR
.Sp
.RS 4
\&\fBDescription\fR predicate for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBget_all_hashpend\fR
.Sp
.RS 4
\&\fBDescription\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBadd_to_hashpend( \f(CB$key\fB =\fR \f(CW$value\fR|$closure )>
.Sp
.RS 4
\&\fBDescription\fR this adds to the attribute and can accept more than one \f(CW$key\fR => \f(CW$value\fR pair
.RE
.RE
.RS 4
.Sp
\&\fBremove_from_hashpend( \f(CB$key\fB )\fR
.Sp
.RS 4
\&\fBDescription\fR removes the \f(CW$key\fR => \f(CW$value\fR pair associated with the passed \f(CW$key\fR from the 
hashpend.  This can accept more than one key at a time.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIprepend\fR
.IX Subsection "prepend"
.Sp
.RS 4
\&\fBDefinition:\fR This will push elements to the beginning of the list 
@{$message_ref\->{message}}.  The elements are pushed in the reverse order that they are 
stored in this attribute meaning that they will wind up in the stored order in the message 
ref.  The action assumes that 
the attribute is retrieved as \f(CW$prepend_ref\fR and the entire message is passed as 
\&\f(CW$message_ref\fR;
.Sp
.Vb 5
\&        for my $element ( reverse @$prepend_ref ){
\&                unshift @{$message_ref\->{message}}, (
\&                        exists $message_ref\->{$element} ? $message_ref\->{$element} :
\&                        $element );
\&        }
.Ve
.Sp
Unlike the hashpend attribute it will not handle CodeRefs.
.Sp
\&\fBDefault:\fR None
.Sp
\&\fBRequired:\fR No
.Sp
\&\fBRange:\fR it must be an arrayref
.Sp
\&\fBattribute methods\fR
.Sp
.RS 4
\&\fBclear_prepend\fR
.Sp
.RS 4
\&\fBDescription\fR removes the stored attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_prepend\fR
.Sp
.RS 4
\&\fBDescription\fR predicate for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBget_all_prepend\fR
.Sp
.RS 4
\&\fBDescription\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBadd_to_prepend( \f(CB$element\fB )\fR
.Sp
.RS 4
\&\fBDescription\fR this adds to the end of the attribute and can accept more than one \f(CW$element\fR
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIpostpend\fR
.IX Subsection "postpend"
.Sp
.RS 4
\&\fBDefinition:\fR This will push elements to the end of the list @{$message_ref\->{message}}.  
The elements are pushed in the order that they are stored in this attribute.  The action 
below assumes that the attribute is retrieved as \f(CW$postpend_ref\fR and the entire message is 
passed as \f(CW$message_ref\fR;
.Sp
.Vb 5
\&        for my $element ( reverse @$postpend_ref ){
\&                push @{$message_ref\->{message}}, (
\&                        exists $message_ref\->{$element} ? $message_ref\->{$element} :
\&                        $element );
\&        }
.Ve
.Sp
Unlike the hashpend attribute it will not handle CodeRefs.
.Sp
\&\fBDefault:\fR None
.Sp
\&\fBRequired:\fR No
.Sp
\&\fBRange:\fR it must be an arrayref
.Sp
\&\fBattribute methods\fR
.Sp
.RS 4
\&\fBclear_postpend\fR
.Sp
.RS 4
\&\fBDescription\fR removes the stored attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_postpend\fR
.Sp
.RS 4
\&\fBDescription\fR predicate for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBget_all_postpend\fR
.Sp
.RS 4
\&\fBDescription\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBadd_to_postpend( \f(CB$element\fB )\fR
.Sp
.RS 4
\&\fBDescription\fR this adds to the end of the attribute and can accept more than one \f(CW$element\fR
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIpost_sub\fR
.IX Subsection "post_sub"
.Sp
.RS 4
\&\fBDefinition:\fR This is a place to store a perl closure that will be passed the full
\&\f(CW$message_ref\fR including meta data.  The results of the closure are not used so any 
desired change should be done to the \f(CW$message_ref\fR itself since it is persistent.  The 
action takes place after all the other attributes are implemented so the changes will 
be available to process.  See the example in the \s-1SYNOPSIS.\s0
.Sp
\&\fBDefault:\fR None
.Sp
\&\fBRequired:\fR No
.Sp
\&\fBRange:\fR it must pass the is_CodeRef test
.Sp
\&\fBattribute methods\fR
.Sp
.RS 4
\&\fBclear_post_sub\fR
.Sp
.RS 4
\&\fBDescription\fR removes the stored attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_post_sub\fR
.Sp
.RS 4
\&\fBDescription\fR predicate for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBget_post_sub\fR
.Sp
.RS 4
\&\fBDescription\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBset_post_sub( \f(CB$closure\fB )\fR
.Sp
.RS 4
\&\fBDescription\fR sets the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SS "Methods"
.IX Subsection "Methods"
\fImanage_message( \f(CI$message_ref\fI )\fR
.IX Subsection "manage_message( $message_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This is a possible method called by Log::Shiras::Report with the 
intent of implementing the attributes on each message passed to a 
\&\*(L"reports\*(R" in Log::Shiras::Switchboard.  Actions taken on that message vary from attribute 
to attribute and the specifics are explained in each.  The attributes are implemented in 
this order.
.Sp
.Vb 1
\&        pre_sub \-> hashpend \-> prepend \-> postpend \-> post_sub
.Ve
.Sp
\&\fBReturns:\fR the (updated) \f(CW$message_ref\fR
.RE
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.IP "\fB\f(CB$ENV\fB{hide_warn}\fR" 4
.IX Item "$ENV{hide_warn}"
The module will warn when debug lines are 'Unhide'n.  In the case where the you 
don't want these notifications set this environmental variable to true.
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
Log\-Shiras/issues <https://github.com/jandrew/Log-Shiras/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Nothing currently
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
perl 5.010
.Sp
utf8
.Sp
version
.Sp
Moose::Role
.Sp
MooseX::Types::Moose
.Sp
Carp \- confess
.RE
