.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::BytesLocker 3"
.TH Data::BytesLocker 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::BytesLocker \- Guarded storage for sensitive data
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw(:utils);
\&
\&    # lock by default
\&    $Data::BytesLocker::DEFAULT_LOCKED = 1;
\&
\&    # some sensitive data read from external sources, eg. database
\&    my $password = ...;
\&
\&    my $password_locker = Data::BytesLocker\->new($password, wipe => 1);
\&
\&    # $password now is overwritten with null bytes
\&    $password =~ /^\e0+$/ or die;
\&
\&    # as requested locker is locked
\&    $password_locker\->is_locked or die;
\&
\&    # dies with: "Unlock BytesLocker object before accessing the data"
\&    print "password: ", $password_locker\->bytes, "\en";
\&
\&    # unlock the data
\&    $password_locker\->unlock;
\&
\&    # as requested locker is unlocked
\&    $password_locker\->is_locked and die;
\&
\&    # prints the password using overloaded stringification
\&    print "password: $password_locker\en";
\&
\&    # Crypt::NaCl::Sodium functions and methods return binary data locked in Data::BytesLocker objects
\&    my $random_password = random_bytes( 32 );
\&
\&    # we wanted locked by default
\&    $random_password\->unlock;
\&
\&    # helper function to convert into hexadecimal string
\&    print "random password: ", $random_password\->to_hex, "\en";
\&
\&    # clone the data into new object
\&    my $copy = $password_locker\->clone;
\&
\&    # nonce increment
\&    my $next_nonce = $nonce\->increment;
\&
\&    # add number
\&    my $next_nonce = $nonce\->add( $step );
\&
\&    # check if the data contains zero bits only
\&    $next_nonce\->is_zero and print "back to square zero\en";
\&
\&    # always lock the data once done using it
\&    $password_locker\->lock;
\&    $random_password\->lock;
\&
\&    # wipe out the memory and destroy the object
\&    undef $password_locker;
\&    undef $random_password;
\&    undef $copy;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Heartbleed was a serious vulnerability in OpenSSL. The ability to read
past the end of a buffer is a serious bug, but what
made it even worse is the fact that secret data could be
disclosed by doing so.
.PP
In order to mitigate the impact of similar bugs, \f(CW\*(C`Data::BytesLocker\*(C'\fR provides
heap allocation functions for storing sensitive data.
.PP
These are not general-purpose allocation functions. In particular, they
are slower than regular scalars, and they
require 3 or 4 extra pages of virtual memory (usually between 12\-16kb extra
memory will be used).
.PP
The stored data is placed at the end of a page boundary,
immediately followed by a guard page. As a result, accessing
memory past the end of the region will immediately terminate the
application.
.PP
A canary is also placed right before the stored data.
Modification of this canary are detected when trying to free
the allocated region, and also cause the
application to immediately terminate.
.PP
An additional guard page is placed before this canary. In a
Heartbleed-like scenario, this guard page is likely to be read
before the actual data, and this access will cause the application
to terminate instead of leaking sensitive data.
.PP
The allocated region is filled with \f(CW0xd0\fR bytes in order
to help catch bugs due to initialized data.
.PP
On operating systems supporting \f(CW\*(C`MAP_NOCORE\*(C'\fR or \f(CW\*(C`MADV_DONTDUMP\*(C'\fR,
the memory allocated this way will also not be part of core dumps and can help
avoid the data being swapped to disk.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $locker = Data::BytesLocker\->new($data, wipe => 1 );
.Ve
.PP
Returns object that stores the input \f(CW$data\fR in a protected memory location.
.PP
If the optional parameter \f(CW\*(C`wipe\*(C'\fR is given and is true, then the input \f(CW$data\fR
variable will be overwritten with null bytes.
.PP
Returned \f(CW$locker\fR object will contain the data that cannot be modified and if
the object is locked it cannot be accessed as well.
.PP
\&\f(CW\*(C`Data::BytesLocker\*(C'\fR object when used in string context return the protected
data.  See \*(L"\s-1OVERLOADED OPERATIONS\*(R"\s0 for more details.
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&    my $cloned = $locker\->clone;
.Ve
.PP
Returns new data object which will contain the copied data from \f(CW$locker\fR.
.SS "lock"
.IX Subsection "lock"
.Vb 1
\&    $locker\->lock();
.Ve
.PP
When called makes the data stored inaccessible. It cannot be read or written,
but the data are preserved.
.SS "unlock"
.IX Subsection "unlock"
.Vb 1
\&    $locker\->unlock();
.Ve
.PP
When called makes the data stored accessible for read access only.
.SS "is_locked"
.IX Subsection "is_locked"
.Vb 3
\&    if ( $locker\->is_locked ) {
\&        $locker\->unlock;
\&    }
.Ve
.PP
Returns true if the \f(CW$locker\fR object is locked, false otherwise.
.SS "length"
.IX Subsection "length"
.Vb 1
\&    my $data_length = $locker\->length();
.Ve
.PP
Returns the length of protected bytes.
.SS "to_hex"
.IX Subsection "to_hex"
.Vb 1
\&    my $hexencoded = $locker\->to_hex();
.Ve
.PP
Returns the protected data converted into a hexadecimal string.
.PP
\&\fB\s-1NOTE:\s0\fR the \f(CW$locker\fR object must be unlocked.
.PP
Returns regular scalar.
.SS "bytes"
.IX Subsection "bytes"
.Vb 1
\&    my $bytes = $locker\->bytes();
.Ve
.PP
Returns the protected data as regular scalar.
.PP
\&\fB\s-1NOTE:\s0\fR the \f(CW$locker\fR object must be unlocked.
.SS "is_zero"
.IX Subsection "is_zero"
.Vb 3
\&    if ( $locker\->is_zero ) {
\&        print "data contains zero bits only\en";
\&    }
.Ve
.PP
Returns true if the \f(CW$locker\fR object contains zero bits only.
Runs in constant-time for objects of the same length.
.SS "memcmp"
.IX Subsection "memcmp"
.Vb 1
\&    $locker\->memcmp($bytes, $length ) or die "\e$locker ne \e$bytes for length: $length";
.Ve
.PP
Compares strings in constant-time. Returns true if they match, false otherwise.
.PP
The argument \f(CW$length\fR is optional if length of \f(CW$bytes\fR is equal to the
length of the data stored in \f(CW$locker\fR. Otherwise it is required and cannot
be greater then the length of the shorter of compared variables.
.SS "compare"
.IX Subsection "compare"
.Vb 1
\&    $nonce\->compare( $number, $length ) == \-1 and print "\e$nonce < \e$number for length: $length";
.Ve
.PP
A constant-time version of \*(L"memcmp\*(R", useful to compare nonces and counters
in little-endian format, that plays well with \*(L"increment\*(R".
.PP
Returns \f(CW\*(C`\-1\*(C'\fR if \f(CW$nonce\fR is lower then \f(CW$number\fR, \f(CW0\fR if \f(CW$nonce\fR and
\&\f(CW$number\fR are identical, or \f(CW1\fR if \f(CW$nonce\fR is greater then \f(CW$number\fR.
Both \f(CW$nonce\fR and \f(CW$number\fR are assumed to be numbers encoded in little-endian format.
.PP
The argument \f(CW$length\fR is optional if variables are of the same length. Otherwise it is
required and cannot be greater then the length of the shorter of compared variables.
.SS "increment"
.IX Subsection "increment"
.Vb 1
\&    my $next_nonce = $nonce\->increment();
.Ve
.PP
Increments an arbitrary long unsigned number. Method runs in constant-time
for a given length of locked data and considers it to be encoded in
little-endian format.
.PP
This method is meant to be used to increment nonces and counters.
.PP
Returns the incremented object.
.SS "add"
.IX Subsection "add"
.Vb 1
\&    my $next_nonce = $nonce\->add($number, $length);
.Ve
.PP
Method computes \f(CW\*(C`($nonce + $number) mod 2 ^ (8 * $length)\*(C'\fR in constant time for
a given length and returns the result of that computation.
Both \f(CW$nonce\fR and \f(CW$number\fR are assumed to be numbers encoded in little-endian format.
.PP
The argument \f(CW$length\fR is optional if variables are of the same length. Otherwise it is
required and cannot be greater then the length of the shorter of compared variables.
.PP
This method is meant to be used to increment nonces and counters using specified
step.
.SH "OVERLOADED OPERATIONS"
.IX Header "OVERLOADED OPERATIONS"
Only operations listed below are supported.
.SS "stringification"
.IX Subsection "stringification"
.Vb 1
\&    print "Password: $locker\en";
.Ve
.PP
Returns the protected data as regular scalar.
.SS "stringwise equality"
.IX Subsection "stringwise equality"
.Vb 3
\&    if ( $locker eq $expected ) {
\&        print "matches\en";
\&    }
\&
\&    if ( $locker ne $expected ) {
\&        print "does not match\en";
\&    }
.Ve
.PP
The \f(CW\*(C`eq\*(C'\fR and \f(CW\*(C`ne\*(C'\fR operations are overloaded and allow to compare the
\&\f(CW$locker\fR object with variable of equal length.
.SS "boolean context"
.IX Subsection "boolean context"
.Vb 3
\&    if ( $locker ) {
\&        print "locker has some non\-zero length data\en";
\&    }
\&
\&    if ( ! $locker ) {
\&        print "locker has some zero length data\en";
\&    }
.Ve
.PP
The \f(CW\*(C`bool\*(C'\fR and \f(CW\*(C`!\*(C'\fR operations are overloaded and allow to check if the
\&\f(CW$locker\fR object contains the data at least one byte long.
.SS "concatenation"
.IX Subsection "concatenation"
.Vb 1
\&    my $kv = "password:". $locker;
.Ve
.PP
The concatenation operator \f(CW\*(C`.\*(C'\fR is overloaded and allows to create a new
\&\f(CW\*(C`Data::BytesLocker\*(C'\fR object that is a result of joining the data together.
.SS "repetition"
.IX Subsection "repetition"
.Vb 1
\&    my $tripled_data = $locker x 3;
.Ve
.PP
The repetition operator \f(CW\*(C`x\*(C'\fR is overloaded and allow to create a new
\&\f(CW\*(C`Data::BytesLocker\*(C'\fR object that is a result of repeating the protected data
specified number of times.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Crypt::NaCl::Sodium
.IP "\(bu" 4
Securing memory allocations <http://doc.libsodium.org/helpers/memory_management.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
