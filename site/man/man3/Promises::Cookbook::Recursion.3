.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises::Cookbook::Recursion 3"
.TH Promises::Cookbook::Recursion 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises::Cookbook::Recursion \- Examples of recursive asynchronous operations
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MyClass;
\&
\&    use Promises backend => [\*(AqAE\*(Aq], \*(Aqdeferred\*(Aq;
\&
\&    sub new                 {...}
\&    sub process             {...}
\&    sub is_finished         {...}
\&    sub fetch_next_from_db  {...} # returns a promise
\&
\&    sub fetch_all {
\&        my $self     = shift;
\&        my $deferred = deferred;
\&
\&        $self\->_fetch_loop($deferred);
\&        return $deferred\->promise;
\&    }
\&
\&    sub _fetch_loop {
\&        my ($self,$deferred) = @_;
\&        if ( $self\->is_finished ) {
\&            $deferred\->resolve;
\&            return
\&        }
\&        $self\->fetch_next_from_db
\&             \->then( sub { $self\->process(@_) })
\&             \->done(
\&                sub { $self\->_fetch_loop($deferred) }
\&                sub { $deferred\->reject(@_) }
\&             );
\&    }
\&
\&    package main;
\&
\&    my $cv  = AnyEvent\->condvar;
\&    my $obj = MyClass\->new(...);
\&    $obj\->fetch_all\->then(
\&        sub { $cv\->send(@_)          },
\&        sub { $cv\->croak(\*(AqERROR\*(Aq,@_) }
\&    );
\&
\&    $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
While \f(CW\*(C`collect()\*(C'\fR allows you to wait for multiple promises which
are executing in parallel, sometimes you need to execute each step
in order, by using promises recursively. For instance:
.IP "1." 4
Fetch next page of results
.IP "2." 4
Process page of results
.IP "3." 4
If there are no more results, return success
.IP "4." 4
Otherwise, goto step 1
.PP
However, recursion can result in very deep stacks and out of memory
conditions.  There are two important steps for dealing with recursion
effectively.
.PP
The first is to use one of the event-loop backends:
.PP
.Vb 1
\&    use Promises backend => [\*(AqAE\*(Aq], \*(Aqdeferred\*(Aq;
.Ve
.PP
While the default Promises::Deferred implementation calls the
\&\f(CW\*(C`then()\*(C'\fR callbacks synchronously, the event-loop backends call
the callbacks asynchronously in the context of the event loop.
.PP
However, each \f(CW\*(C`promise\*(C'\fR passes its return value on to the next
\&\f(CW\*(C`promise\*(C'\fR etc, so you still end up using a lot of memory with
recursion. We can avoid this by breaking the chain.
.PP
In our example, all we care about is whether all the steps in our
process completed successfully or not.  Each execution of steps 1 to
4 is independent. Step 1 does not need to receive the return value
from step 4.
.PP
We can break the chain by using \f(CW\*(C`done()\*(C'\fR instead of \f(CW\*(C`then()\*(C'\fR.
While \f(CW\*(C`then()\*(C'\fR returns a new \f(CW\*(C`promise\*(C'\fR to continue the chain,
\&\f(CW\*(C`done()\*(C'\fR will execute either the success callback or the
error callback and return an empty list, breaking the chain and
rolling back the stack.
.PP
To work through the code in the \*(L"\s-1SYNOPSIS\*(R"\s0:
.PP
.Vb 3
\&    sub fetch_all {
\&        my $self     = shift;
\&        my $deferred = deferred;
\&
\&        $self\->_fetch_loop($deferred);
\&        return $deferred\->promise;
\&    }
.Ve
.PP
The \f(CW$deferred\fR variable (and the promise that we return to the caller)
will either be resolved once all results have been fetched and
processed by the \f(CW\*(C`_fetch_loop()\*(C'\fR, or rejected if an error occurs at
any stage of execution.
.PP
.Vb 2
\&    sub _fetch_loop {
\&        my ($self,$deferred) = @_;
\&
\&        if ( $self\->is_finished ) {
\&            $deferred\->resolve;
\&            return;
\&        }
.Ve
.PP
If \f(CW\*(C`is_finished\*(C'\fR returns a true value (eg there are no more results to fetch),
then we can resolve our promise, indicating success, and exit the loop.
.PP
.Vb 7
\&        $self\->fetch_next_from_db
\&             \->then( sub { $self\->process(@_) })
\&             \->done(
\&                sub { $self\->_fetch_loop($deferred) }
\&                sub { $deferred\->reject(@_) }
\&             );
\&    }
.Ve
.PP
Otherwise we fetch the next page of results aynchronously from the \s-1DB\s0 and
process them. If either of these steps (fetching or processing) fails,
then we signal failure by rejecting our deferred promise and exiting the loop.
If there is no failure, we recurse back into our loop by calling
\&\f(CW\*(C`_fetch_loop()\*(C'\fR again.
.PP
However,this recursion happens asynchronously. What this code actually does
is to schedule the call to \f(CW\*(C`_fetch_loop()\*(C'\fR in the next tick of the event
loop. And because we used \f(CW\*(C`done()\*(C'\fR instead of \f(CW\*(C`then()\*(C'\fR, we don't
wait around for the return result but instead return immediately,
exiting the current execution, discarding the return results and
rolling back the stack.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
