.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "GD 3"
.TH GD 3 "2020-09-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::IO::GD \- Interface to the GD image library.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $pdl = sequence(byte, 30, 30);
\& write_png($pdl, load_lut($lutfile), "test.png");
\&
\& write_true_png(sequence(100, 100, 3), "test_true.png");
\&
\& my $image = read_png("test.png");
\&
\& my $image = read_true_png("test_true_read.png");
\& write_true_png($image, "test_true_read.out.png");
\&
\& my $lut = read_png_lut("test.png");
\&
\& $pdl = sequence(byte, 30, 30);
\& write_png_ex($pdl, load_lut($lutfile), "test_nocomp.png", 0);
\& write_png_ex($pdl, load_lut($lutfile), "test_bestcomp1.png", 9);
\& write_png_best($pdl, load_lut($lutfile), "test_bestcomp2.png");
\&
\& $pdl = sequence(100, 100, 3);
\& write_true_png_ex($pdl, "test_true_nocomp.png", 0);
\& write_true_png_ex($pdl, "test_true_bestcomp1.png", 9);
\& write_true_png_best($pdl, "test_true_bestcomp2.png");
\&
\& recompress_png_best("test_recomp_best.png");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the \*(L"General Interface\*(R" for the \s-1PDL::IO::GD\s0 library, and is actually several
years old at this point (read: stable). If you're feeling frisky, try the new \s-1OO\s0 
interface described below.
.PP
The general version just provides several image \s-1IO\s0 utility functions you can use with
piddle variables. It's deceptively useful, however.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "write_png"
.IX Subsection "write_png"
.Vb 1
\&  Signature: (byte img(x,y); byte lut(i,j); char* filename)
.Ve
.PP
Writes a 2\-d \s-1PDL\s0 variable out to a \s-1PNG\s0 file, using the supplied color look-up-table piddle
(hereafter referred to as a \s-1LUT\s0).
.PP
The \s-1LUT\s0 contains a line for each value 0\-255 with a corresponding R, G, and B value.
.PP
write_png does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "write_png_ex"
.IX Subsection "write_png_ex"
.Vb 1
\&  Signature: (img(x,y); lut(i,j); char* filename; int level)
.Ve
.PP
Same as \fBwrite_png()\fR, except you can specify the compression level (0\-9) as the last argument.
.PP
write_png_ex does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "write_true_png"
.IX Subsection "write_true_png"
.Vb 1
\&  Signature: (img(x,y,z); char* filename)
.Ve
.PP
Writes an (x, y, z(3)) \s-1PDL\s0 variable out to a \s-1PNG\s0 file, using a true color format.
.PP
This means a larger file on disk, but can contain more than 256 colors.
.PP
write_true_png does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "write_true_png_ex"
.IX Subsection "write_true_png_ex"
.Vb 1
\&  Signature: (img(x,y,z); char* filename; int level)
.Ve
.PP
Same as \fBwrite_true_png()\fR, except you can specify the compression level (0\-9) as the last argument.
.PP
write_true_png_ex does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "write_png_best"
.IX Subsection "write_png_best"
Like \fBwrite_png()\fR, but it assumes the best \s-1PNG\s0 compression (9).
.PP
.Vb 1
\&  write_png_best( $img(piddle), $lut(piddle), $filename )
.Ve
.SS "write_true_png_best"
.IX Subsection "write_true_png_best"
Like \fBwrite_true_png()\fR, but it assumes the best \s-1PNG\s0 compression (9).
.PP
.Vb 1
\&  write_true_png_best( $img(piddle), $filename )
.Ve
.ie n .SS "load_lut( $filename )"
.el .SS "load_lut( \f(CW$filename\fP )"
.IX Subsection "load_lut( $filename )"
Loads a color look up table from an \s-1ASCII\s0 file. returns a piddle
.ie n .SS "read_png( $filename )"
.el .SS "read_png( \f(CW$filename\fP )"
.IX Subsection "read_png( $filename )"
Reads a (palette) \s-1PNG\s0 image into a (new) \s-1PDL\s0 variable.
.ie n .SS "read_png_true( $filename )"
.el .SS "read_png_true( \f(CW$filename\fP )"
.IX Subsection "read_png_true( $filename )"
Reads a true color \s-1PNG\s0 image into a (new) \s-1PDL\s0 variable.
.ie n .SS "read_png_lut( $filename )"
.el .SS "read_png_lut( \f(CW$filename\fP )"
.IX Subsection "read_png_lut( $filename )"
Reads a color \s-1LUT\s0 from an already-existing palette \s-1PNG\s0 file.
.SH "OO INTERFACE"
.IX Header "OO INTERFACE"
Object Oriented interface to the \s-1GD\s0 image library.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& # Open an existing file:
\& # 
\& my $gd = PDL::IO::GD\->new( { filename => "test.png" } );
\& 
\& # Query the x and y sizes:
\& my $x = $gd\->SX();
\& my $y = $gd\->SY();
\&
\& # Grab the PDL of the data:
\& my $pdl = $gd\->to_pdl();
\&
\& # Kill this thing:
\& $gd\->DESTROY();
\&
\& # Create a new object:
\& # 
\& my $im = PDL::IO::GD\->new( { x => 300, y => 300 } );
\&
\& # Allocate some colors:
\& #
\& my $black = $im\->ColorAllocate( 0, 0, 0 );
\& my $red = $im\->ColorAllocate( 255, 0, 0 );
\& my $green = $im\->ColorAllocate( 0, 255, 0 );
\& my $blue = $im\->ColorAllocate( 0, 0, 255 );
\&
\& # Draw a rectangle:
\& $im\->Rectangle( 10, 10, 290, 290, $red );
\&
\& # Add some text:
\& $im\->String( gdFontGetLarge(), 20, 20, "Test Large Font!", $green );
\&
\& # Write the output file:
\& $im\->write_Png( "test2.png" );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Object-Oriented interface from \s-1PDL\s0 to the \s-1GD\s0 image library.
.PP
See <http://www.boutell.com/gd/> for more information on the \s-1GD\s0 library and how it works.
.SS "\s-1IMPLEMENTATION NOTES\s0"
.IX Subsection "IMPLEMENTATION NOTES"
Surprisingly enough, this interface has nothing to do with the other Perl\->\s-1GD\s0 interface module, 
aka '\s-1GD\s0' (as in 'use \s-1GD\s0;'). This is done from scratch over the years.
.PP
Requires at least version 2.0.22 of the \s-1GD\s0 library, but it's only been thoroughly tested with
gd\-2.0.33, so it would be best to use that. The 2.0.22 requirement has to do with a change in
\&\s-1GD\s0's font handling functions, so if you don't use those, then don't worry about it.
.PP
I should also add, the statement about \*(L"thoroughly tested\*(R" above is mostly a joke. This \s-1OO\s0 
interface is very young, and it has \fIbarely\fR been tested at all, so if something 
breaks, email me and I'll get it fixed \s-1ASAP\s0 (for me).
.PP
Functions that manipulate and query the image objects generally have a 'gdImage' prefix on the
function names (ex: \fBgdImageString()\fR). I've created aliases here for all of those member 
functions so you don't have to keep typing 'gdImage' in your code, but the long version are in 
there as well.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Creates a new \s-1PDL::IO::GD\s0 object.
.PP
Accepts a hash describing how to create the object. Accepts a single hash ( with
curly braces ), an inline hash (the same, but without the braces) or a single
string interpreted as a filename. Thus the following are all equivalent:
.PP
.Vb 3
\& PDL::IO::GD\->new( {filename => \*(Aqimage.png\*(Aq} );
\& PDL::IO::GD\->new( filename => \*(Aqimage.png\*(Aq );
\& PDL::IO::GD\->new( \*(Aqimage.png\*(Aq );
.Ve
.PP
If the hash has:
.PP
.Vb 2
\& pdl => $pdl_var (lut => $lut_piddle)
\&    Then a new GD is created from that PDL variable.
\&
\& filename => $file
\&    Then a new GD is created from the image file.
\&    
\& x => $num, y => $num
\&    Then a new GD is created as a palette image, with size x, y
\&    
\& x => $num, y => $num, true_color => 1
\&    Then a new GD is created as a true color image, with size x, y
\&
\& data => $scalar (type => $typename)
\&    Then a new GD is created from the file data stored in $scalar. 
\&    If no type is given, then it will try to guess the type of the data, but 
\&        this will not work for WBMP and gd image types. For those types, you 
\&        _must_ specify the type of the data, or the operation will fail.
\&    Valid types are: \*(Aqjpg\*(Aq, \*(Aqpng\*(Aq, \*(Aqgif\*(Aq, \*(Aqgd\*(Aq, \*(Aqgd2\*(Aq, \*(Aqwbmp\*(Aq.
.Ve
.PP
Example:
.PP
.Vb 1
\& my $gd = PDL::IO::GD\->new({ pdl => $pdl_var });
\&    
\& my $gd = PDL::IO::GD\->new({ pdl => $pdl_var, lut => $lut_piddle });
\& 
\& my $gd = PDL::IO::GD\->new({ filename => "image.png" });
\& 
\& my $gd = PDL::IO::GD\->new({ x => 100, y => 100 });
\& 
\& my $gd = PDL::IO::GD\->new({ x => 100, y => 100, true_color => 1 });
\& 
\& my $gd = PDL::IO::GD\->new({ data => $imageData });
\& 
\& my $gd = PDL::IO::GD\->new({ data => $imageData, type => \*(Aqwbmp\*(Aq });
.Ve
.SS "to_pdl"
.IX Subsection "to_pdl"
When you're done playing with your GDImage and want a piddle back, use this function to return one.
.ie n .SS "apply_lut( $lut(piddle) )"
.el .SS "apply_lut( \f(CW$lu\fPt(piddle) )"
.IX Subsection "apply_lut( $lut(piddle) )"
Does a \f(CW$im\fR\->\fBColorAllocate()\fR for and entire \s-1LUT\s0 piddle at once.
.PP
The \s-1LUT\s0 piddle format is the same as for the general interface above.
.SS "\s-1WARNING:\s0"
.IX Subsection "WARNING:"
All of the docs below this point are auto-generated (not to mention the actual code), 
so read with a grain of salt, and \fBalways\fR check the main \s-1GD\s0 documentation about how 
that function works and what it does.
.SS "write_Png"
.IX Subsection "write_Png"
\&\f(CW$image\fR\->write_Png( \f(CW$filename\fR )
.SS "write_PngEx"
.IX Subsection "write_PngEx"
\&\f(CW$image\fR\->write_PngEx( \f(CW$filename\fR, \f(CW$level\fR )
.SS "write_WBMP"
.IX Subsection "write_WBMP"
\&\f(CW$image\fR\->write_WBMP( \f(CW$fg\fR, \f(CW$filename\fR )
.SS "write_Jpeg"
.IX Subsection "write_Jpeg"
\&\f(CW$image\fR\->write_Jpeg( \f(CW$filename\fR, \f(CW$quality\fR )
.SS "write_Gd"
.IX Subsection "write_Gd"
\&\f(CW$image\fR\->write_Gd( \f(CW$filename\fR )
.SS "write_Gd2"
.IX Subsection "write_Gd2"
\&\f(CW$image\fR\->write_Gd2( \f(CW$filename\fR, \f(CW$cs\fR, \f(CW$fmt\fR )
.SS "write_Gif"
.IX Subsection "write_Gif"
\&\f(CW$image\fR\->write_Gif( \f(CW$filename\fR )
.SS "get_Png_data"
.IX Subsection "get_Png_data"
\&\f(CW$image\fR\->get_Png_data(  )
.SS "get_PngEx_data"
.IX Subsection "get_PngEx_data"
\&\f(CW$image\fR\->get_PngEx_data( \f(CW$level\fR )
.SS "get_WBMP_data"
.IX Subsection "get_WBMP_data"
\&\f(CW$image\fR\->get_WBMP_data( \f(CW$fg\fR )
.SS "get_Jpeg_data"
.IX Subsection "get_Jpeg_data"
\&\f(CW$image\fR\->get_Jpeg_data( \f(CW$quality\fR )
.SS "get_Gd_data"
.IX Subsection "get_Gd_data"
\&\f(CW$image\fR\->get_Gd_data(  )
.SS "get_Gd2_data"
.IX Subsection "get_Gd2_data"
\&\f(CW$image\fR\->get_Gd2_data( \f(CW$cs\fR, \f(CW$fmt\fR )
.SS "SetPixel"
.IX Subsection "SetPixel"
\&\f(CW$image\fR\->SetPixel( \f(CW$x\fR, \f(CW$y\fR, \f(CW$color\fR )
.PP
Alias for gdImageSetPixel.
.SS "gdImageSetPixel"
.IX Subsection "gdImageSetPixel"
\&\f(CW$image\fR\->gdImageSetPixel( \f(CW$x\fR, \f(CW$y\fR, \f(CW$color\fR )
.SS "GetPixel"
.IX Subsection "GetPixel"
\&\f(CW$image\fR\->GetPixel( \f(CW$x\fR, \f(CW$y\fR )
.PP
Alias for gdImageGetPixel.
.SS "gdImageGetPixel"
.IX Subsection "gdImageGetPixel"
\&\f(CW$image\fR\->gdImageGetPixel( \f(CW$x\fR, \f(CW$y\fR )
.SS "AABlend"
.IX Subsection "AABlend"
\&\f(CW$image\fR\->AABlend(  )
.PP
Alias for gdImageAABlend.
.SS "gdImageAABlend"
.IX Subsection "gdImageAABlend"
\&\f(CW$image\fR\->gdImageAABlend(  )
.SS "Line"
.IX Subsection "Line"
\&\f(CW$image\fR\->Line( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.PP
Alias for gdImageLine.
.SS "gdImageLine"
.IX Subsection "gdImageLine"
\&\f(CW$image\fR\->gdImageLine( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.SS "DashedLine"
.IX Subsection "DashedLine"
\&\f(CW$image\fR\->DashedLine( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.PP
Alias for gdImageDashedLine.
.SS "gdImageDashedLine"
.IX Subsection "gdImageDashedLine"
\&\f(CW$image\fR\->gdImageDashedLine( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.SS "Rectangle"
.IX Subsection "Rectangle"
\&\f(CW$image\fR\->Rectangle( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.PP
Alias for gdImageRectangle.
.SS "gdImageRectangle"
.IX Subsection "gdImageRectangle"
\&\f(CW$image\fR\->gdImageRectangle( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.SS "FilledRectangle"
.IX Subsection "FilledRectangle"
\&\f(CW$image\fR\->FilledRectangle( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.PP
Alias for gdImageFilledRectangle.
.SS "gdImageFilledRectangle"
.IX Subsection "gdImageFilledRectangle"
\&\f(CW$image\fR\->gdImageFilledRectangle( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$color\fR )
.SS "SetClip"
.IX Subsection "SetClip"
\&\f(CW$image\fR\->SetClip( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR )
.PP
Alias for gdImageSetClip.
.SS "gdImageSetClip"
.IX Subsection "gdImageSetClip"
\&\f(CW$image\fR\->gdImageSetClip( \f(CW$x1\fR, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR )
.SS "GetClip"
.IX Subsection "GetClip"
\&\f(CW$image\fR\->GetClip( \f(CW$x1P\fR, \f(CW$y1P\fR, \f(CW$x2P\fR, \f(CW$y2P\fR )
.PP
Alias for gdImageGetClip.
.SS "gdImageGetClip"
.IX Subsection "gdImageGetClip"
\&\f(CW$image\fR\->gdImageGetClip( \f(CW$x1P\fR, \f(CW$y1P\fR, \f(CW$x2P\fR, \f(CW$y2P\fR )
.SS "BoundsSafe"
.IX Subsection "BoundsSafe"
\&\f(CW$image\fR\->BoundsSafe( \f(CW$x\fR, \f(CW$y\fR )
.PP
Alias for gdImageBoundsSafe.
.SS "gdImageBoundsSafe"
.IX Subsection "gdImageBoundsSafe"
\&\f(CW$image\fR\->gdImageBoundsSafe( \f(CW$x\fR, \f(CW$y\fR )
.SS "Char"
.IX Subsection "Char"
\&\f(CW$image\fR\->Char( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$c\fR, \f(CW$color\fR )
.PP
Alias for gdImageChar.
.SS "gdImageChar"
.IX Subsection "gdImageChar"
\&\f(CW$image\fR\->gdImageChar( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$c\fR, \f(CW$color\fR )
.SS "CharUp"
.IX Subsection "CharUp"
\&\f(CW$image\fR\->CharUp( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$c\fR, \f(CW$color\fR )
.PP
Alias for gdImageCharUp.
.SS "gdImageCharUp"
.IX Subsection "gdImageCharUp"
\&\f(CW$image\fR\->gdImageCharUp( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$c\fR, \f(CW$color\fR )
.SS "String"
.IX Subsection "String"
\&\f(CW$image\fR\->String( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.PP
Alias for gdImageString.
.SS "gdImageString"
.IX Subsection "gdImageString"
\&\f(CW$image\fR\->gdImageString( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.SS "StringUp"
.IX Subsection "StringUp"
\&\f(CW$image\fR\->StringUp( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.PP
Alias for gdImageStringUp.
.SS "gdImageStringUp"
.IX Subsection "gdImageStringUp"
\&\f(CW$image\fR\->gdImageStringUp( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.SS "String16"
.IX Subsection "String16"
\&\f(CW$image\fR\->String16( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.PP
Alias for gdImageString16.
.SS "gdImageString16"
.IX Subsection "gdImageString16"
\&\f(CW$image\fR\->gdImageString16( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.SS "StringUp16"
.IX Subsection "StringUp16"
\&\f(CW$image\fR\->StringUp16( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.PP
Alias for gdImageStringUp16.
.SS "gdImageStringUp16"
.IX Subsection "gdImageStringUp16"
\&\f(CW$image\fR\->gdImageStringUp16( \f(CW$f\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$s\fR, \f(CW$color\fR )
.SS "Polygon"
.IX Subsection "Polygon"
\&\f(CW$image\fR\->Polygon( \f(CW$p\fR, \f(CW$n\fR, \f(CW$c\fR )
.PP
Alias for gdImagePolygon.
.SS "gdImagePolygon"
.IX Subsection "gdImagePolygon"
\&\f(CW$image\fR\->gdImagePolygon( \f(CW$p\fR, \f(CW$n\fR, \f(CW$c\fR )
.SS "FilledPolygon"
.IX Subsection "FilledPolygon"
\&\f(CW$image\fR\->FilledPolygon( \f(CW$p\fR, \f(CW$n\fR, \f(CW$c\fR )
.PP
Alias for gdImageFilledPolygon.
.SS "gdImageFilledPolygon"
.IX Subsection "gdImageFilledPolygon"
\&\f(CW$image\fR\->gdImageFilledPolygon( \f(CW$p\fR, \f(CW$n\fR, \f(CW$c\fR )
.SS "ColorAllocate"
.IX Subsection "ColorAllocate"
\&\f(CW$image\fR\->ColorAllocate( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.PP
Alias for gdImageColorAllocate.
.SS "gdImageColorAllocate"
.IX Subsection "gdImageColorAllocate"
\&\f(CW$image\fR\->gdImageColorAllocate( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.SS "ColorAllocateAlpha"
.IX Subsection "ColorAllocateAlpha"
\&\f(CW$image\fR\->ColorAllocateAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.PP
Alias for gdImageColorAllocateAlpha.
.SS "gdImageColorAllocateAlpha"
.IX Subsection "gdImageColorAllocateAlpha"
\&\f(CW$image\fR\->gdImageColorAllocateAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.SS "ColorClosest"
.IX Subsection "ColorClosest"
\&\f(CW$image\fR\->ColorClosest( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.PP
Alias for gdImageColorClosest.
.SS "gdImageColorClosest"
.IX Subsection "gdImageColorClosest"
\&\f(CW$image\fR\->gdImageColorClosest( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.SS "ColorClosestAlpha"
.IX Subsection "ColorClosestAlpha"
\&\f(CW$image\fR\->ColorClosestAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.PP
Alias for gdImageColorClosestAlpha.
.SS "gdImageColorClosestAlpha"
.IX Subsection "gdImageColorClosestAlpha"
\&\f(CW$image\fR\->gdImageColorClosestAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.SS "ColorClosestHWB"
.IX Subsection "ColorClosestHWB"
\&\f(CW$image\fR\->ColorClosestHWB( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.PP
Alias for gdImageColorClosestHWB.
.SS "gdImageColorClosestHWB"
.IX Subsection "gdImageColorClosestHWB"
\&\f(CW$image\fR\->gdImageColorClosestHWB( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.SS "ColorExact"
.IX Subsection "ColorExact"
\&\f(CW$image\fR\->ColorExact( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.PP
Alias for gdImageColorExact.
.SS "gdImageColorExact"
.IX Subsection "gdImageColorExact"
\&\f(CW$image\fR\->gdImageColorExact( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.SS "ColorExactAlpha"
.IX Subsection "ColorExactAlpha"
\&\f(CW$image\fR\->ColorExactAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.PP
Alias for gdImageColorExactAlpha.
.SS "gdImageColorExactAlpha"
.IX Subsection "gdImageColorExactAlpha"
\&\f(CW$image\fR\->gdImageColorExactAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.SS "ColorResolve"
.IX Subsection "ColorResolve"
\&\f(CW$image\fR\->ColorResolve( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.PP
Alias for gdImageColorResolve.
.SS "gdImageColorResolve"
.IX Subsection "gdImageColorResolve"
\&\f(CW$image\fR\->gdImageColorResolve( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR )
.SS "ColorResolveAlpha"
.IX Subsection "ColorResolveAlpha"
\&\f(CW$image\fR\->ColorResolveAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.PP
Alias for gdImageColorResolveAlpha.
.SS "gdImageColorResolveAlpha"
.IX Subsection "gdImageColorResolveAlpha"
\&\f(CW$image\fR\->gdImageColorResolveAlpha( \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR )
.SS "ColorDeallocate"
.IX Subsection "ColorDeallocate"
\&\f(CW$image\fR\->ColorDeallocate( \f(CW$color\fR )
.PP
Alias for gdImageColorDeallocate.
.SS "gdImageColorDeallocate"
.IX Subsection "gdImageColorDeallocate"
\&\f(CW$image\fR\->gdImageColorDeallocate( \f(CW$color\fR )
.SS "TrueColorToPalette"
.IX Subsection "TrueColorToPalette"
\&\f(CW$image\fR\->TrueColorToPalette( \f(CW$ditherFlag\fR, \f(CW$colorsWanted\fR )
.PP
Alias for gdImageTrueColorToPalette.
.SS "gdImageTrueColorToPalette"
.IX Subsection "gdImageTrueColorToPalette"
\&\f(CW$image\fR\->gdImageTrueColorToPalette( \f(CW$ditherFlag\fR, \f(CW$colorsWanted\fR )
.SS "ColorTransparent"
.IX Subsection "ColorTransparent"
\&\f(CW$image\fR\->ColorTransparent( \f(CW$color\fR )
.PP
Alias for gdImageColorTransparent.
.SS "gdImageColorTransparent"
.IX Subsection "gdImageColorTransparent"
\&\f(CW$image\fR\->gdImageColorTransparent( \f(CW$color\fR )
.SS "FilledArc"
.IX Subsection "FilledArc"
\&\f(CW$image\fR\->FilledArc( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$s\fR, \f(CW$e\fR, \f(CW$color\fR, \f(CW$style\fR )
.PP
Alias for gdImageFilledArc.
.SS "gdImageFilledArc"
.IX Subsection "gdImageFilledArc"
\&\f(CW$image\fR\->gdImageFilledArc( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$s\fR, \f(CW$e\fR, \f(CW$color\fR, \f(CW$style\fR )
.SS "Arc"
.IX Subsection "Arc"
\&\f(CW$image\fR\->Arc( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$s\fR, \f(CW$e\fR, \f(CW$color\fR )
.PP
Alias for gdImageArc.
.SS "gdImageArc"
.IX Subsection "gdImageArc"
\&\f(CW$image\fR\->gdImageArc( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$s\fR, \f(CW$e\fR, \f(CW$color\fR )
.SS "FilledEllipse"
.IX Subsection "FilledEllipse"
\&\f(CW$image\fR\->FilledEllipse( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$color\fR )
.PP
Alias for gdImageFilledEllipse.
.SS "gdImageFilledEllipse"
.IX Subsection "gdImageFilledEllipse"
\&\f(CW$image\fR\->gdImageFilledEllipse( \f(CW$cx\fR, \f(CW$cy\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$color\fR )
.SS "FillToBorder"
.IX Subsection "FillToBorder"
\&\f(CW$image\fR\->FillToBorder( \f(CW$x\fR, \f(CW$y\fR, \f(CW$border\fR, \f(CW$color\fR )
.PP
Alias for gdImageFillToBorder.
.SS "gdImageFillToBorder"
.IX Subsection "gdImageFillToBorder"
\&\f(CW$image\fR\->gdImageFillToBorder( \f(CW$x\fR, \f(CW$y\fR, \f(CW$border\fR, \f(CW$color\fR )
.SS "Fill"
.IX Subsection "Fill"
\&\f(CW$image\fR\->Fill( \f(CW$x\fR, \f(CW$y\fR, \f(CW$color\fR )
.PP
Alias for gdImageFill.
.SS "gdImageFill"
.IX Subsection "gdImageFill"
\&\f(CW$image\fR\->gdImageFill( \f(CW$x\fR, \f(CW$y\fR, \f(CW$color\fR )
.SS "CopyRotated"
.IX Subsection "CopyRotated"
\&\f(CW$image\fR\->CopyRotated( \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$srcWidth\fR, \f(CW$srcHeight\fR, \f(CW$angle\fR )
.PP
Alias for gdImageCopyRotated.
.SS "gdImageCopyRotated"
.IX Subsection "gdImageCopyRotated"
\&\f(CW$image\fR\->gdImageCopyRotated( \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$srcWidth\fR, \f(CW$srcHeight\fR, \f(CW$angle\fR )
.SS "SetBrush"
.IX Subsection "SetBrush"
\&\f(CW$image\fR\->SetBrush(  )
.PP
Alias for gdImageSetBrush.
.SS "gdImageSetBrush"
.IX Subsection "gdImageSetBrush"
\&\f(CW$image\fR\->gdImageSetBrush(  )
.SS "SetTile"
.IX Subsection "SetTile"
\&\f(CW$image\fR\->SetTile(  )
.PP
Alias for gdImageSetTile.
.SS "gdImageSetTile"
.IX Subsection "gdImageSetTile"
\&\f(CW$image\fR\->gdImageSetTile(  )
.SS "SetAntiAliased"
.IX Subsection "SetAntiAliased"
\&\f(CW$image\fR\->SetAntiAliased( \f(CW$c\fR )
.PP
Alias for gdImageSetAntiAliased.
.SS "gdImageSetAntiAliased"
.IX Subsection "gdImageSetAntiAliased"
\&\f(CW$image\fR\->gdImageSetAntiAliased( \f(CW$c\fR )
.SS "SetAntiAliasedDontBlend"
.IX Subsection "SetAntiAliasedDontBlend"
\&\f(CW$image\fR\->SetAntiAliasedDontBlend( \f(CW$c\fR, \f(CW$dont_blend\fR )
.PP
Alias for gdImageSetAntiAliasedDontBlend.
.SS "gdImageSetAntiAliasedDontBlend"
.IX Subsection "gdImageSetAntiAliasedDontBlend"
\&\f(CW$image\fR\->gdImageSetAntiAliasedDontBlend( \f(CW$c\fR, \f(CW$dont_blend\fR )
.SS "SetStyle"
.IX Subsection "SetStyle"
\&\f(CW$image\fR\->SetStyle( \f(CW$style\fR, \f(CW$noOfPixels\fR )
.PP
Alias for gdImageSetStyle.
.SS "gdImageSetStyle"
.IX Subsection "gdImageSetStyle"
\&\f(CW$image\fR\->gdImageSetStyle( \f(CW$style\fR, \f(CW$noOfPixels\fR )
.SS "SetThickness"
.IX Subsection "SetThickness"
\&\f(CW$image\fR\->SetThickness( \f(CW$thickness\fR )
.PP
Alias for gdImageSetThickness.
.SS "gdImageSetThickness"
.IX Subsection "gdImageSetThickness"
\&\f(CW$image\fR\->gdImageSetThickness( \f(CW$thickness\fR )
.SS "Interlace"
.IX Subsection "Interlace"
\&\f(CW$image\fR\->Interlace( \f(CW$interlaceArg\fR )
.PP
Alias for gdImageInterlace.
.SS "gdImageInterlace"
.IX Subsection "gdImageInterlace"
\&\f(CW$image\fR\->gdImageInterlace( \f(CW$interlaceArg\fR )
.SS "AlphaBlending"
.IX Subsection "AlphaBlending"
\&\f(CW$image\fR\->AlphaBlending( \f(CW$alphaBlendingArg\fR )
.PP
Alias for gdImageAlphaBlending.
.SS "gdImageAlphaBlending"
.IX Subsection "gdImageAlphaBlending"
\&\f(CW$image\fR\->gdImageAlphaBlending( \f(CW$alphaBlendingArg\fR )
.SS "SaveAlpha"
.IX Subsection "SaveAlpha"
\&\f(CW$image\fR\->SaveAlpha( \f(CW$saveAlphaArg\fR )
.PP
Alias for gdImageSaveAlpha.
.SS "gdImageSaveAlpha"
.IX Subsection "gdImageSaveAlpha"
\&\f(CW$image\fR\->gdImageSaveAlpha( \f(CW$saveAlphaArg\fR )
.SS "TrueColor"
.IX Subsection "TrueColor"
\&\f(CW$image\fR\->TrueColor(  )
.PP
Alias for gdImageTrueColor.
.SS "gdImageTrueColor"
.IX Subsection "gdImageTrueColor"
\&\f(CW$image\fR\->gdImageTrueColor(  )
.SS "ColorsTotal"
.IX Subsection "ColorsTotal"
\&\f(CW$image\fR\->ColorsTotal(  )
.PP
Alias for gdImageColorsTotal.
.SS "gdImageColorsTotal"
.IX Subsection "gdImageColorsTotal"
\&\f(CW$image\fR\->gdImageColorsTotal(  )
.SS "Red"
.IX Subsection "Red"
\&\f(CW$image\fR\->Red( \f(CW$c\fR )
.PP
Alias for gdImageRed.
.SS "gdImageRed"
.IX Subsection "gdImageRed"
\&\f(CW$image\fR\->gdImageRed( \f(CW$c\fR )
.SS "Green"
.IX Subsection "Green"
\&\f(CW$image\fR\->Green( \f(CW$c\fR )
.PP
Alias for gdImageGreen.
.SS "gdImageGreen"
.IX Subsection "gdImageGreen"
\&\f(CW$image\fR\->gdImageGreen( \f(CW$c\fR )
.SS "Blue"
.IX Subsection "Blue"
\&\f(CW$image\fR\->Blue( \f(CW$c\fR )
.PP
Alias for gdImageBlue.
.SS "gdImageBlue"
.IX Subsection "gdImageBlue"
\&\f(CW$image\fR\->gdImageBlue( \f(CW$c\fR )
.SS "Alpha"
.IX Subsection "Alpha"
\&\f(CW$image\fR\->Alpha( \f(CW$c\fR )
.PP
Alias for gdImageAlpha.
.SS "gdImageAlpha"
.IX Subsection "gdImageAlpha"
\&\f(CW$image\fR\->gdImageAlpha( \f(CW$c\fR )
.SS "GetTransparent"
.IX Subsection "GetTransparent"
\&\f(CW$image\fR\->GetTransparent(  )
.PP
Alias for gdImageGetTransparent.
.SS "gdImageGetTransparent"
.IX Subsection "gdImageGetTransparent"
\&\f(CW$image\fR\->gdImageGetTransparent(  )
.SS "GetInterlaced"
.IX Subsection "GetInterlaced"
\&\f(CW$image\fR\->GetInterlaced(  )
.PP
Alias for gdImageGetInterlaced.
.SS "gdImageGetInterlaced"
.IX Subsection "gdImageGetInterlaced"
\&\f(CW$image\fR\->gdImageGetInterlaced(  )
.SS "\s-1SX\s0"
.IX Subsection "SX"
\&\f(CW$image\fR\->\s-1SX\s0(  )
.PP
Alias for gdImageSX.
.SS "gdImageSX"
.IX Subsection "gdImageSX"
\&\f(CW$image\fR\->gdImageSX(  )
.SS "\s-1SY\s0"
.IX Subsection "SY"
\&\f(CW$image\fR\->\s-1SY\s0(  )
.PP
Alias for gdImageSY.
.SS "gdImageSY"
.IX Subsection "gdImageSY"
\&\f(CW$image\fR\->gdImageSY(  )
.SS "ColorAllocates"
.IX Subsection "ColorAllocates"
\&\f(CW$image\fR\->ColorAllocates( $r(pdl), $g(pdl), $b(pdl) )
.PP
Alias for gdImageColorAllocates.
.SS "gdImageColorAllocates"
.IX Subsection "gdImageColorAllocates"
\&\f(CW$image\fR\->gdImageColorAllocates( $r(pdl), $g(pdl), $b(pdl) )
.SS "ColorAllocateAlphas"
.IX Subsection "ColorAllocateAlphas"
\&\f(CW$image\fR\->ColorAllocateAlphas( $r(pdl), $g(pdl), $b(pdl), $a(pdl) )
.PP
Alias for gdImageColorAllocateAlphas.
.SS "gdImageColorAllocateAlphas"
.IX Subsection "gdImageColorAllocateAlphas"
\&\f(CW$image\fR\->gdImageColorAllocateAlphas( $r(pdl), $g(pdl), $b(pdl), $a(pdl) )
.SS "SetPixels"
.IX Subsection "SetPixels"
\&\f(CW$image\fR\->SetPixels( $x(pdl), $y(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageSetPixels.
.SS "gdImageSetPixels"
.IX Subsection "gdImageSetPixels"
\&\f(CW$image\fR\->gdImageSetPixels( $x(pdl), $y(pdl), \f(CW$colo\fRr(pdl) )
.SS "Lines"
.IX Subsection "Lines"
\&\f(CW$image\fR\->Lines( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageLines.
.SS "gdImageLines"
.IX Subsection "gdImageLines"
\&\f(CW$image\fR\->gdImageLines( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.SS "DashedLines"
.IX Subsection "DashedLines"
\&\f(CW$image\fR\->DashedLines( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageDashedLines.
.SS "gdImageDashedLines"
.IX Subsection "gdImageDashedLines"
\&\f(CW$image\fR\->gdImageDashedLines( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.SS "Rectangles"
.IX Subsection "Rectangles"
\&\f(CW$image\fR\->Rectangles( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageRectangles.
.SS "gdImageRectangles"
.IX Subsection "gdImageRectangles"
\&\f(CW$image\fR\->gdImageRectangles( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.SS "FilledRectangles"
.IX Subsection "FilledRectangles"
\&\f(CW$image\fR\->FilledRectangles( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageFilledRectangles.
.SS "gdImageFilledRectangles"
.IX Subsection "gdImageFilledRectangles"
\&\f(CW$image\fR\->gdImageFilledRectangles( \f(CW$x\fR1(pdl), \f(CW$y\fR1(pdl), \f(CW$x\fR2(pdl), \f(CW$y\fR2(pdl), \f(CW$colo\fRr(pdl) )
.SS "FilledArcs"
.IX Subsection "FilledArcs"
\&\f(CW$image\fR\->FilledArcs( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), $s(pdl), $e(pdl), \f(CW$colo\fRr(pdl), \f(CW$styl\fRe(pdl) )
.PP
Alias for gdImageFilledArcs.
.SS "gdImageFilledArcs"
.IX Subsection "gdImageFilledArcs"
\&\f(CW$image\fR\->gdImageFilledArcs( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), $s(pdl), $e(pdl), \f(CW$colo\fRr(pdl), \f(CW$styl\fRe(pdl) )
.SS "Arcs"
.IX Subsection "Arcs"
\&\f(CW$image\fR\->Arcs( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), $s(pdl), $e(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageArcs.
.SS "gdImageArcs"
.IX Subsection "gdImageArcs"
\&\f(CW$image\fR\->gdImageArcs( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), $s(pdl), $e(pdl), \f(CW$colo\fRr(pdl) )
.SS "FilledEllipses"
.IX Subsection "FilledEllipses"
\&\f(CW$image\fR\->FilledEllipses( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), \f(CW$colo\fRr(pdl) )
.PP
Alias for gdImageFilledEllipses.
.SS "gdImageFilledEllipses"
.IX Subsection "gdImageFilledEllipses"
\&\f(CW$image\fR\->gdImageFilledEllipses( \f(CW$c\fRx(pdl), \f(CW$c\fRy(pdl), $w(pdl), $h(pdl), \f(CW$colo\fRr(pdl) )
.SH "CLASS FUNCTIONS"
.IX Header "CLASS FUNCTIONS"
.SS "gdImageCopy"
.IX Subsection "gdImageCopy"
gdImageCopy ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0), \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$w\fR, \f(CW$h\fR )
.SS "gdImageCopyMerge"
.IX Subsection "gdImageCopyMerge"
gdImageCopyMerge ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0), \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$pct\fR )
.SS "gdImageCopyMergeGray"
.IX Subsection "gdImageCopyMergeGray"
gdImageCopyMergeGray ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0), \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$w\fR, \f(CW$h\fR, \f(CW$pct\fR )
.SS "gdImageCopyResized"
.IX Subsection "gdImageCopyResized"
gdImageCopyResized ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0), \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$dstW\fR, \f(CW$dstH\fR, \f(CW$srcW\fR, \f(CW$srcH\fR )
.SS "gdImageCopyResampled"
.IX Subsection "gdImageCopyResampled"
gdImageCopyResampled ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0), \f(CW$dstX\fR, \f(CW$dstY\fR, \f(CW$srcX\fR, \f(CW$srcY\fR, \f(CW$dstW\fR, \f(CW$dstH\fR, \f(CW$srcW\fR, \f(CW$srcH\fR )
.SS "gdImageCompare"
.IX Subsection "gdImageCompare"
gdImageCompare ( \f(CW$im\fR1(\s-1PDL::IO::GD\s0), \f(CW$im\fR2(\s-1PDL::IO::GD\s0) )
.SS "gdImagePaletteCopy"
.IX Subsection "gdImagePaletteCopy"
gdImagePaletteCopy ( \f(CW$ds\fRt(\s-1PDL::IO::GD\s0), \f(CW$sr\fRc(\s-1PDL::IO::GD\s0) )
.SS "StringTTF"
.IX Subsection "StringTTF"
\&\f(CW$image\fR\->StringTTF( \f(CW$brect\fR, \f(CW$fg\fR, \f(CW$fontlist\fR, \f(CW$ptsize\fR, \f(CW$angle\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$string\fR )
.PP
Alias for gdImageStringTTF.
.SS "gdImageStringTTF"
.IX Subsection "gdImageStringTTF"
\&\f(CW$image\fR\->gdImageStringTTF( \f(CW$brect\fR, \f(CW$fg\fR, \f(CW$fontlist\fR, \f(CW$ptsize\fR, \f(CW$angle\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$string\fR )
.SS "StringFT"
.IX Subsection "StringFT"
\&\f(CW$image\fR\->StringFT( \f(CW$brect\fR, \f(CW$fg\fR, \f(CW$fontlist\fR, \f(CW$ptsize\fR, \f(CW$angle\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$string\fR )
.PP
Alias for gdImageStringFT.
.SS "gdImageStringFT"
.IX Subsection "gdImageStringFT"
\&\f(CW$image\fR\->gdImageStringFT( \f(CW$brect\fR, \f(CW$fg\fR, \f(CW$fontlist\fR, \f(CW$ptsize\fR, \f(CW$angle\fR, \f(CW$x\fR, \f(CW$y\fR, \f(CW$string\fR )
.SH "AUTHOR"
.IX Header "AUTHOR"
Judd Taylor, Orbital Systems, Ltd.
judd dot t at orbitalsystems dot com
