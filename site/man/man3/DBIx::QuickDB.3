.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::QuickDB 3"
.TH DBIx::QuickDB 3 "2020-08-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::QuickDB \- Quickly start a db server.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library makes it easy to spin up a temporary database server for any
supported driver. PostgreSQL and MySQL are the initially supported drivers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
These are nearly identical, creating databases that can be retrieved by name
globally. The difference is that the first will build them at compile-time and
will provide constants for accessing them. The second will build them at
run-time and you have to store them in variables.
.SS "\s-1DB CONSTANTS\s0"
.IX Subsection "DB CONSTANTS"
.Vb 2
\&    use DBIx::QuickDB MYSQL_DB => {driver => \*(AqMySQL\*(Aq};
\&    use DBIx::QuickDB PSQL_DB  => {driver => \*(AqPostgreSQL\*(Aq};
\&
\&    my $m_dbh = MYSQL_DB\->connect;
\&    my $p_dbh = PSQL_DB\->connect;
\&
\&    ...
.Ve
.SS "\s-1DB ON THE FLY\s0"
.IX Subsection "DB ON THE FLY"
.Vb 1
\&    use DBIx::QuickDB;
\&
\&    my $msql = DBIx::QuickDB\->build_db(mysql_db => {driver => \*(AqMySQL\*(Aq});
\&    my $psql = DBIx::QuickDB\->build_db(mysql_db => {driver => \*(AqPostgreSQL\*(Aq});
\&
\&    my $m_dbh = $msql\->connect;
\&    my $p_dbh = $psql\->connect;
\&
\&    ...
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$db = DBIx::QuickDB\->\fBbuild_db()\fR;" 4
.el .IP "\f(CW$db\fR = DBIx::QuickDB\->\fBbuild_db()\fR;" 4
.IX Item "$db = DBIx::QuickDB->build_db();"
.PD 0
.ie n .IP "$db = DBIx::QuickDB\->build_db($name);" 4
.el .IP "\f(CW$db\fR = DBIx::QuickDB\->build_db($name);" 4
.IX Item "$db = DBIx::QuickDB->build_db($name);"
.ie n .IP "$db = DBIx::QuickDB\->build_db(\e%spec);" 4
.el .IP "\f(CW$db\fR = DBIx::QuickDB\->build_db(\e%spec);" 4
.IX Item "$db = DBIx::QuickDB->build_db(%spec);"
.ie n .IP "$db = DBIx::QuickDB\->build_db($name => \e%spec);" 4
.el .IP "\f(CW$db\fR = DBIx::QuickDB\->build_db($name => \e%spec);" 4
.IX Item "$db = DBIx::QuickDB->build_db($name => %spec);"
.PD
If a \f(CW$name\fR is provided then the database will be named. If the named
database has already been created it will be returned ignoring any other
arguments. If the named db does not yet exist it will be created.
.Sp
If a \f(CW%spec\fR hashref is provided it will be used to construct the database.
See \*(L"\s-1SPEC HASH\*(R"\s0 for what is supported in \f(CW%spec\fR.
.ie n .IP "($bool, $fqd, $why ) = DBIx::QuickDB\->check_driver($driver => \e%spec);" 4
.el .IP "($bool, \f(CW$fqd\fR, \f(CW$why\fR ) = DBIx::QuickDB\->check_driver($driver => \e%spec);" 4
.IX Item "($bool, $fqd, $why ) = DBIx::QuickDB->check_driver($driver => %spec);"
The first argument must be a driver name. The name may be shorthand \s-1IE\s0
\&\f(CW"PostgreSQL"\fR or it can be a fully qualified module name like
\&\f(CW"DBIx::QuickDB::Driver::PostgreSQL"\fR.
.Sp
The second argument is option, but when present must be a spec hash. See
\&\*(L"\s-1SPEC HASH\*(R"\s0 for what is supported in \f(CW%spec\fR.
.Sp
This method returns a sequence of 3 values:
.RS 4
.ie n .IP "$bool" 4
.el .IP "\f(CW$bool\fR" 4
.IX Item "$bool"
True if the driver is viable for the specifications. False if the driver cannot
be used.
.ie n .IP "$fqd" 4
.el .IP "\f(CW$fqd\fR" 4
.IX Item "$fqd"
The full package name for the driver.
.ie n .IP "$why" 4
.el .IP "\f(CW$why\fR" 4
.IX Item "$why"
If \f(CW$bool\fR is false then this will have an explanation for why the driver is
not viable.
.RE
.RS 4
.RE
.SH "SPEC HASH"
.IX Header "SPEC HASH"
Here is an overview of all options allowed:
.PP
.Vb 11
\&    my %spec = (
\&        autostart => BOOL,
\&        autostop  => BOOL,
\&        bootstrap => BOOL,
\&        cleanup   => BOOL,
\&        dir       => PATH,
\&        driver    => DRIVER_NAME,
\&        drivers   => ARRAYREF,
\&        load_sql  => FILE_OR_HASH,
\&        nocache   => BOOL,
\&    );
.Ve
.IP "autostart => \s-1BOOL\s0" 4
.IX Item "autostart => BOOL"
Defaults to true. When true the \s-1DB\s0 server will be started automatically. If
this is false then you will need to call \f(CW\*(C`$DB\->start\*(C'\fR yourself.
.IP "autostop  => \s-1BOOL\s0" 4
.IX Item "autostop => BOOL"
Defaults to be the same as the \f(CW\*(Aqautostart\*(Aq\fR key.
.Sp
When true, the server will automatically be stopped when the program ends.
.IP "bootstrap => \s-1BOOL\s0" 4
.IX Item "bootstrap => BOOL"
This defaults to true unless the \f(CW\*(Aqdir\*(Aq\fR key is also provided, in which case
it will default to false.
.Sp
When true this will cause the database to be bootstrapped into existance in the
specified (or generated) directory (\s-1IE\s0 the \f(CW\*(Aqdir\*(Aq\fR key).
.IP "cleanup => \s-1BOOL\s0" 4
.IX Item "cleanup => BOOL"
This defaults to true unless the \f(CW\*(Aqdir\*(Aq\fR key is also provided, in which case
it will default to false.
.Sp
When true the databse directory will be completely deleted when the program is
finished. \fB\s-1DO NOT USE THIS ON ANY IMPORTANT DATABASES\s0\fR.
.IP "dir => \s-1PATH\s0" 4
.IX Item "dir => PATH"
Use this key to point at an existing database directory. If not provided a
tempdir will be generated.
.IP "driver => \s-1DRIVER_NAME\s0" 4
.IX Item "driver => DRIVER_NAME"
This key lets you specify a driver to use. This must be a string, and can
either be the shorthand name \s-1IE\s0 'PostgreSQL', or the full name \s-1IE\s0
\&'DBIx::QuickDB::Driver::PostgreSQL'.
.Sp
If this key is present then no other drivers will be tried or used.
.Sp
If this key is missing then the \f(CW\*(Aqdrivers\*(Aq\fR key will be used. If both keys are
empty than any installed driver may be used.
.IP "drivers => \s-1ARRAYREF\s0" 4
.IX Item "drivers => ARRAYREF"
If you are only a little picky about driver choice then you can use this to
list several drivers that are acceptible, the first one that works will be
used.
.Sp
This key is ignored if the \f(CW\*(Aqdriver\*(Aq\fR key is specified. If both keys are empty
than any installed driver may be used.
.IP "load_sql => \s-1FILE_OR_HASH\s0" 4
.IX Item "load_sql => FILE_OR_HASH"
This can be a path to an \s-1SQL\s0 file to load, an arrayref of several files to
load, or a structure with driver specific files to load.
.Sp
.Vb 1
\&    load_sql => \*(Aq/path/to/my/schema.sql\*(Aq
\&
\&    load_sql => [\*(Aqschema1.sql\*(Aq, \*(Aqschema2.sql\*(Aq]
\&
\&    load_sql => {
\&        PostgreSQL => \*(Aqpath/to/postgre.sql\*(Aq,
\&        MySQL      => \*(Aqpath/to/my.sql\*(Aq,
\&        SQLite     => [\*(Aqsqlite1.sql\*(Aq, \*(Aqsqlite2.sql\*(Aq],
\&    }
.Ve
.IP "nocache => \s-1BOOL\s0" 4
.IX Item "nocache => BOOL"
Defaults to false. When set to true the database will not be available globally
by the name passed into \f(CW\*(C`build_db()\*(C'\fR.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for DBIx-QuickDB can be found at
\&\fIhttps://github.com/exodist/DBIx\-QuickDB/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
