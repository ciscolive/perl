.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "GraphViz2::Parse::Regexp 3"
.TH GraphViz2::Parse::Regexp 3 "2020-10-21" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GraphViz2::Parse::Regexp \- Visualize a Perl regular expression as a graph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use GraphViz2::Parse::Regexp;
\&    # no objects \- quicker
\&    my $gd = GraphViz2::Parse::Regexp::to_graph(\*(Aq(([abcd0\-9])|(foo))\*(Aq);
\&
\&    # populate a GraphViz2 object with a Graph::Directed of a regexp
\&    my $gv = GraphViz2\->from_graph(GraphViz2::Parse::Regexp::graphvizify($gd));
\&
\&    # OO interface, using lazy\-built attributes
\&    my $gvre = GraphViz2::Parse::Regexp\->new(regexp => $regexp);
\&    my $gd = $gvre\->as_graph; # Graph::Directed object
\&    # or supply a suitable Graph::Directed object
\&    my $gvre = GraphViz2::Parse::Regexp\->new(as_graph => $gd);
\&    # then get the GraphViz2 object
\&    my $gv = $gvre\->graph;
\&
\&    # DEPRECATED ways to get $gvre with populated $gv
\&    my $gvre = GraphViz2::Parse::Regexp\->new;
\&    $gvre\->create(regexp => \*(Aq(([abcd0\-9])|(foo))\*(Aq);
\&    my $gv = $gvre\->graph;
\&    # or give it a pre\-set\-up GraphViz2 object
\&    my $gv = GraphViz2\->new(...);
\&    my $gvre = GraphViz2::Parse::Regexp\->new(graph => $gv);
\&    # call \->create as above
\&
\&    # produce a visualisation
\&    my $format = shift || \*(Aqsvg\*(Aq;
\&    my $output_file = shift || "output.$format";
\&    $gv\->run(format => $format, output_file => $output_file);
.Ve
.PP
See \fIt/gen.parse.regexp.t\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Takes a Perl regular expression and converts it into a Graph::Directed
object, or directly into a GraphViz2 object.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This is the recommended interface.
.SS "to_graph"
.IX Subsection "to_graph"
.Vb 1
\&    my $gd = GraphViz2::Parse::Regexp::to_graph(\*(Aq(([abcd0\-9])|(foo))\*(Aq);
.Ve
.PP
Given a Perl regular expression, returns a Graph::Directed object
describing the finite state machine for it.
.SS "graphvizify"
.IX Subsection "graphvizify"
.Vb 1
\&    my $gv = GraphViz2\->from_graph(GraphViz2::Parse::Regexp::graphvizify($gd));
.Ve
.PP
Mutates the given graph object to add to it the \f(CW\*(C`graphviz\*(C'\fR attributes
visualisation \*(L"hints\*(R" that will make the \*(L"from_graph\*(R" in GraphViz2 method
visualise this regular expression in the most meaningful way, including
labels and groupings.
.PP
It is idempotent as it simply sets the \f(CW\*(C`graphviz\*(C'\fR attribute of the
relevant graph entities.
.PP
Returns the graph object for convenience.
.SH "METHODS"
.IX Header "METHODS"
This is a Moo class, but with a recommended functional interface.
.SS "Constructor attributes"
.IX Subsection "Constructor attributes"
\fIregexp\fR
.IX Subsection "regexp"
.PP
The regular expression to use.
.PP
This key is optional. You need to provide it by the time you access
either the \*(L"as_graph\*(R" or \*(L"graph\*(R".
.PP
\fIas_graph\fR
.IX Subsection "as_graph"
.PP
The Graph::Directed object to use. If not given, will be lazily built
on access, from the \*(L"regexp\*(R".
.PP
\fIgraph\fR
.IX Subsection "graph"
.PP
The GraphViz2 object to use. This allows you to configure it as desired.
.PP
This key is optional. If provided, the \f(CW\*(C`create\*(C'\fR method will populate it.
If not, it will have these defaults, lazy-built and populated from the
\&\*(L"as_graph\*(R".
.PP
.Vb 6
\&    my $gv = GraphViz2\->new(
\&            edge   => {color => \*(Aqgrey\*(Aq},
\&            global => {directed => 1},
\&            graph  => {rankdir => \*(AqTB\*(Aq},
\&            node   => {color => \*(Aqblue\*(Aq, shape => \*(Aqoval\*(Aq},
\&    );
.Ve
.ie n .SS "create(regexp => $regexp)"
.el .SS "create(regexp => \f(CW$regexp\fP)"
.IX Subsection "create(regexp => $regexp)"
\&\s-1DEPRECATED.\s0 Mutates the object to set the \f(CW\*(C`regexp\*(C'\fR attribute, then
accesses the \f(CW\*(C`as_graph\*(C'\fR attribute (possibly lazy-building it), then
\&\f(CW\*(C`graphvizify\*(C'\fRs its \f(CW\*(C`as_graph\*(C'\fR attribute with that information, then
\&\f(CW\*(C`from_graph\*(C'\fRs its \f(CW\*(C`graph\*(C'\fR.
.PP
Returns \f(CW$self\fR for method chaining.
.SH "THANKS"
.IX Header "THANKS"
Many thanks are due to the people who chose to make Graphviz <http://www.graphviz.org/> Open Source.
.PP
And thanks to Leon Brocard <http://search.cpan.org/~lbrocard/>, who wrote GraphViz, and kindly gave me co-maint of the module.
.SH "AUTHOR"
.IX Header "AUTHOR"
GraphViz2 was written by Ron Savage \fI<ron@savage.net.au>\fR in 2011.
.PP
Home page: <http://savage.net.au/index.html>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Australian copyright (c) 2011, Ron Savage.
.PP
All Programs of mine are '\s-1OSI\s0 Certified Open Source Software';
you can redistribute them and/or modify them under the terms of
The Perl License, a copy of which is available at:
http://dev.perl.org/licenses/
