.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser::MGC::Tutorial 3"
.TH Parser::MGC::Tutorial 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parser::MGC::Tutorial
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
Parser::MGC is an abstract base class that provides useful features to
assist writing a parser.
.PP
A parser written using this module will be a subclass of \f(CW\*(C`Parser::MGC\*(C'\fR, which
provides a \f(CW\*(C`parse\*(C'\fR method. For example, the following trivial parser accepts
only input content matching the given regexp.
.PP
.Vb 2
\& package ExampleParser;
\& use base qw( Parser::MGC );
\&
\& sub parse
\& {
\&    my $self = shift;
\&
\&    $self\->expect( qr/hello world/i );
\&
\&    return 1;
\& }
.Ve
.PP
A program using this parser constructs an instance of it, and uses this
instance to parse content. Content is passed either as string value to the
\&\f(CW\*(C`from_string\*(C'\fR method, or from a named file or filehandle to the \f(CW\*(C`from_file\*(C'\fR
method.
.PP
.Vb 2
\& use feature qw( say );
\& use ExampleParser;
\&
\& my $parser = ExampleParser\->new;
\&
\& say $parser\->from_string( "Hello World" );
.Ve
.PP
When run, this program outputs the return value of the \f(CW\*(C`from_string\*(C'\fR method,
which itself is the value returned by the \f(CW\*(C`parse\*(C'\fR method.
.PP
.Vb 2
\& $ perl tut01.pl
\& 1
.Ve
.PP
Content can also be provided by \f(CW\*(C`from_file\*(C'\fR instead:
.PP
.Vb 2
\& use feature qw( say );
\& use ExampleParser;
\&
\& my $parser = ExampleParser\->new;
\&
\& say $parser\->from_file( \e*STDIN );
.Ve
.SS "Returning Values"
.IX Subsection "Returning Values"
Of course, a parser that simply returns 1 to say it matches may not be all
that useful. Almost always when a parser is being used to match some input, it
is because some values or structure are needed from this input, which should
be returned to the caller.
.PP
The \f(CW\*(C`expect\*(C'\fR method attempts to match the next part of the input string with
the given regexp, and returns the matching substring. A subsequent \f(CW\*(C`expect\*(C'\fR
call will continue parsing where the previous one finished. \f(CW\*(C`Parser::MGC\*(C'\fR
will automatically skip over whitespace between these calls, so most grammars
that are whitespace-insensitive should not need to worry about this
explicitly.
.PP
By using two \f(CW\*(C`expect\*(C'\fR calls, a parser can first examine that some given
literal is present, and then return a matched substring from the input.
.PP
.Vb 3
\& sub parse
\& {
\&    my $self = shift;
\&
\&    $self\->expect( qr/hello/i );
\&    my $name = $self\->expect( qr/\ew+/ );
\&
\&    return $name;
\& }
.Ve
.PP

.PP
.Vb 1
\& say $parser\->from_string( "Hello World" );
.Ve
.PP

.PP
.Vb 2
\& $ perl tut02.pl
\& World
.Ve
.PP
Token methods make this easier by providing convenient shortcuts to
commonly-used matching patterns.
.PP
.Vb 3
\& sub parse
\& {
\&    my $self = shift;
\&
\&    $self\->expect( qr/hello/i );
\&    return $self\->token_ident;
\& }
.Ve
.PP
If instead we pass in a value that does not match the regexp, an exception is
thrown, including details of how the parse failed.
.PP
.Vb 1
\& say $parser\->from_string( "Hello, world!" );
.Ve
.PP

.PP
.Vb 4
\& $ perl tut03.pl
\& Expected (?i\-xsm:hello world) on line 1 at:
\& Hello, world!
\& ^
.Ve
.PP
A typical use of a parser is to form an Abstract Syntax Tree (\s-1AST\s0) from a
given input. In this case it is likely that the return value from the parse
method will be some object the application can use to inspect the syntax.
.PP
.Vb 3
\& sub parse
\& {
\&    my $self = shift;
\&
\&    my $num = $self\->token_number;
\&    return MyGrammar::Expression::Number\->new( $num );
\& }
.Ve
.SS "Indicating Failure"
.IX Subsection "Indicating Failure"
While the basic methods such as \f(CW\*(C`expect\*(C'\fR and the varions token methods will
indicate a failure automatically, there may be cases in the grammar that more
logic is required by the parser. If this logic wishes to indicate a failure in
the input and cause back-tracking to occur, it can use the \f(CW\*(C`fail\*(C'\fR method.
.PP
.Vb 3
\& sub parse
\& {
\&    my $self = shift;
\&
\&    my $num = $self\->token_number;
\&    $num >= 0 or $self\->fail( "Expected a non\-negative number" );
\&
\&    return $num;
\& }
.Ve
.SH "STRUCTURE"
.IX Header "STRUCTURE"
So far we've managed to parse simple patterns that could have been specified
with a simple regular expression. Any parser for a nontrivial grammar will
need other abilities as well; it will need to be able to choose from a list of
alternatives, to be able to repeat patterns, and to form nested scopes to
match other content within.
.PP
\&\f(CW\*(C`Parser::MGC\*(C'\fR provides a set of methods that take one or more \f(CW\*(C`CODE\*(C'\fR
references that perform some parsing step, and form a higher-level
construction out of them. These can be used to build more complex parsers out
of simple ones. It is this recursive structure that gives \f(CW\*(C`Parser::MGC\*(C'\fR its
main power over simple one-shot regexp matching.
.PP
Any nontrivial grammar is likely to be formed from multiple named rules. It is
natural therefore to split the parser for such a grammar into methods whose
names reflect the structure of the grammar to be parsed. Each of the
structure-forming methods which takes \f(CW\*(C`CODE\*(C'\fR references invokes each by
passing in the parser object itself as the first argument. This makes it
simple to invoke sub-rules by passing references to method subs themselves,
because the parser object will already be passed as the invocant.
.PP
The following examples will build together into a parser for a simple C\-like
expression language.
.SS "Optional Rules"
.IX Subsection "Optional Rules"
The simplest of the structure-forming methods, \f(CW\*(C`maybe\*(C'\fR, attempts to run the
parser step it is given and if it succeeds, returns the value returned by that
step. If it fails by throwing an exception, then the \f(CW\*(C`maybe\*(C'\fR call simply
returns \f(CW\*(C`undef\*(C'\fR and resets the current parse position back to where it was
before it started. This allows writing a grammar that includes an optional
element, similar to the \f(CW\*(C`?\*(C'\fR quantifier in a regular expression.
.PP
.Vb 3
\& sub parse_type
\& {
\&    my $self = shift;
\&
\&    my $storage = $self\->maybe( sub {
\&       $self\->token_kw(qw( static auto typedef ));
\&    } );
\&
\&    return MyGrammar::Type\->new( $self\->parse_ident, $storage );
\& }
.Ve
.SS "Repeated Rules"
.IX Subsection "Repeated Rules"
The next structure-forming method, \f(CW\*(C`sequence_of\*(C'\fR, attempts to run the parser
step it is given multiple times until it fails, and returns an \f(CW\*(C`ARRAY\*(C'\fR
reference collecting up all the return values from each iteration that
succeeded. By itself, \f(CW\*(C`sequence_of\*(C'\fR can never fail; if the body never matches
then it just yields an empty array and consumes nothing from the input. This
allows writing a grammar that includes a repeating element, similar to the
\&\f(CW\*(C`*\*(C'\fR quantifier in a regular expression.
.PP
.Vb 3
\& sub parse_statements
\& {
\&    my $self = shift;
\&
\&    my $statements = $self\->sequence_of( sub {
\&       $self\->parse_statement;
\&    } );
\&
\&    return MyGrammar::Statements\->new( $statements );
\& }
.Ve
.PP
Often it is the case that the grammar requires at least one item to be
present, and should not accept an empty parse of zero elements. This can be
achieved in code by testing the size of the returned array, and using the
\&\f(CW\*(C`fail\*(C'\fR method. This could be considered similar to the \f(CW\*(C`+\*(C'\fR quantifier in a
regular expression.
.PP
.Vb 3
\& sub parse_statements
\& {
\&    my $self = shift;
\&
\&    my $statements = $self\->sequence_of( sub {
\&       $self\->parse_statement;
\&    } );
\&
\&    @$statements > 0 or $self\->fail( "Expected at least one statement" );
\&
\&    return MyGrammar::Statements\->new( $statements );
\& }
.Ve
.PP
Another case that often happens it that the grammar requires some simple
separation pattern between each parsed item, such as a comma. The \f(CW\*(C`list_of\*(C'\fR
method helps here because it automatically handles those separating patterns
between the items, returning a reference to an array containing only the
actual parsed items without the separators.
.PP
.Vb 3
\& sub parse_expression_list
\& {
\&    my $self = shift;
\&
\&    my $exprs = $self\->list_of( ",", sub {
\&       $self\->parse_expression;
\&    } );
\&
\&    return MyGrammar::ExpressionList\->new( $exprs );
\& }
.Ve
.SS "Alternate Rules"
.IX Subsection "Alternate Rules"
To handle a choice of multiple different alternatives in the grammar, the
\&\f(CW\*(C`any_of\*(C'\fR method takes an ordered list of parser steps, and attempts to invoke
each in turn. It yields as its result the result of the first one of these
that didn't fail. This allows writing a grammar that allows a choice of
multiple different rules at some point, similar to the \f(CW\*(C`|\*(C'\fR alternation in a
regular expression.
.PP
.Vb 3
\& sub parse_statement
\& {
\&    my $self = shift;
\&
\&    $self\->any_of(
\&       sub { $self\->parse_declaration },
\&       sub { $self\->parse_expression; $self\->expect( \*(Aq;\*(Aq ); },
\&       sub { $self\->parse_block_statement },
\&    );
\& }
.Ve
.SS "Scoping Rules"
.IX Subsection "Scoping Rules"
The final structure-forming method has no direct analogy to a regular
expression, though usually similar structures can be found. To handle the case
where some nested structure has to be handled between opening and closing
markers, the \f(CW\*(C`scope_of\*(C'\fR method can be used. It takes three arguments, being
the opening marker, a parser step to handle the contents of the body, and the
closing marker. It expects to find each of these in sequence, and returns the
value that the inner parsing step returned.
.PP
However, what makes it more intersting is that during execution of the inner
parsing step, the basic token functions all take into account the closing
marker. No token function will return a result if the stream now looks like
the scope closing marker. Instead, they'll all fail claiming to be at the end
of the scope. This makes it much simpler to parse, for example, lists of
values surrounded by braces.
.PP
.Vb 3
\& sub parse_array_initialiser
\& {
\&    my $self = shift;
\&
\&    $self\->scope_of( "{", sub { $self\->parse_expression_list }, "}" );
\& }
.Ve
.PP
During execution of the inner call to \f(CW\*(C`parse_expression_list\*(C'\fR, any occurance
in the stream of the \f(CW\*(C`}\*(C'\fR marker will appear to be the end of the stream,
causing the inner call to stop at hopefully the right place (barring other
syntax errors), and terminating correctly.
