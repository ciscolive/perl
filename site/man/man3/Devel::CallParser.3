.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::CallParser 3"
.TH Devel::CallParser 3 "2020-07-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::CallParser \- custom parsing attached to subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        # to generate header prior to XS compilation
\&
\&        perl \-MDevel::CallParser=callparser0_h \e
\&                \-e \*(Aqprint callparser0_h\*(Aq > callparser0.h
\&        perl \-MDevel::CallParser=callparser1_h \e
\&                \-e \*(Aqprint callparser1_h\*(Aq > callparser1.h
\&
\&        # in Perl part of module
\&
\&        use Devel::CallParser;
\&
\&        /* in XS */
\&
\&        #include "callparser0.h"
\&
\&        cv_get_call_parser(cv, &psfun, &psobj);
\&        static OP *my_psfun(pTHX_ GV *namegv, SV *psobj, U32 *flagsp);
\&        cv_set_call_parser(cv, my_psfun, psobj);
\&
\&        #include "callparser1.h"
\&
\&        cv_get_call_parser(cv, &psfun, &psobj);
\&        static OP *my_psfun(pTHX_ GV *namegv, SV *psobj, U32 *flagsp);
\&        cv_set_call_parser(cv, my_psfun, psobj);
\&
\&        args = parse_args_parenthesised(&flags);
\&        args = parse_args_nullary(&flags);
\&        args = parse_args_unary(&flags);
\&        args = parse_args_list(&flags);
\&        args = parse_args_block_list(&flags);
\&        args = parse_args_proto(namegv, protosv, &flags);
\&        args = parse_args_proto_or_list(namegv, protosv, &flags);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a C \s-1API,\s0 for \s-1XS\s0 modules, concerned with custom
parsing.  It is centred around the function \f(CW\*(C`cv_set_call_parser\*(C'\fR, which
allows \s-1XS\s0 code to attach a magical annotation to a Perl subroutine,
resulting in resolvable calls to that subroutine having their arguments
parsed by arbitrary C code.  (This is a more conveniently structured
facility than the core's \f(CW\*(C`PL_keyword_plugin\*(C'\fR \s-1API.\s0)  This module makes
\&\f(CW\*(C`cv_set_call_parser\*(C'\fR and several supporting functions available.
.PP
This module provides the implementation of the functions at runtime.
It also, at compile time, supplies the C header file and link
library which provide access to the functions.  In normal use,
\&\*(L"callparser0_h\*(R"/\*(L"callparser1_h\*(R" and \*(L"callparser_linkable\*(R" should
be called at build time (not authoring time) for the module that wishes
to use the C functions.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.IP "callparser0_h" 4
.IX Item "callparser0_h"
Content of a C header file, intended to be named "\f(CW\*(C`callparser0.h\*(C'\fR".
It is to be included in \s-1XS\s0 code, and \f(CW\*(C`perl.h\*(C'\fR must be included first.
When the \s-1XS\s0 module is loaded at runtime, the \f(CW\*(C`Devel::CallParser\*(C'\fR
module must be loaded first.  This will result in a limited form of
the C functions \f(CW\*(C`cv_get_call_parser\*(C'\fR and \f(CW\*(C`cv_set_call_parser\*(C'\fR being
available to the \s-1XS\s0 code.
.Sp
The \f(CW\*(C`cv_get_call_parser\*(C'\fR and \f(CW\*(C`cv_set_call_parser\*(C'\fR functions supplied
by this header are mostly as described below.  However, for subroutines
that have default argument parsing behaviour, \f(CW\*(C`cv_get_call_parser\*(C'\fR
will return null pointers for the parsing function and its \s-1SV\s0 argument,
rather than pointing to a real function that implements default parsing.
Correspondingly, \f(CW\*(C`cv_set_call_parser\*(C'\fR will accept such a pair of
null pointers to restore default argument parsing for a subroutine.
The advantage of these modified semantics is that this much of the
functionality is available on Perl versions where it is not possible
to implement standard argument parsing as a distinct function.  This is
the case on all Perl versions prior to 5.13.8.
.Sp
This header is only available on Perl versions 5.11.2 and higher.
.IP "callparser1_h" 4
.IX Item "callparser1_h"
Content of a C header file, intended to be named "\f(CW\*(C`callparser1.h\*(C'\fR".
It is to be included in \s-1XS\s0 code, and \f(CW\*(C`perl.h\*(C'\fR must be
included first.  When the \s-1XS\s0 module is loaded at runtime, the
\&\f(CW\*(C`Devel::CallParser\*(C'\fR module must be loaded first.  This will result
in the C functions \f(CW\*(C`cv_get_call_parser\*(C'\fR, \f(CW\*(C`cv_set_call_parser\*(C'\fR,
\&\f(CW\*(C`parse_args_parenthesised\*(C'\fR, \f(CW\*(C`parse_args_nullary\*(C'\fR, \f(CW\*(C`parse_args_unary\*(C'\fR,
\&\f(CW\*(C`parse_args_list\*(C'\fR, \f(CW\*(C`parse_args_block_list\*(C'\fR, \f(CW\*(C`parse_args_proto\*(C'\fR, and
\&\f(CW\*(C`parse_args_proto_or_list\*(C'\fR, as defined below, being available to the
\&\s-1XS\s0 code.
.Sp
This header is only available on Perl versions 5.13.8 and higher.
.IP "callparser_linkable" 4
.IX Item "callparser_linkable"
List of names of files that must be used as additional objects when
linking an \s-1XS\s0 module that uses the C functions supplied by this module.
This list will be empty on many platforms.
.SH "C FUNCTIONS"
.IX Header "C FUNCTIONS"
.IP "cv_get_call_parser" 4
.IX Item "cv_get_call_parser"
Retrieves the function that will be used to parse the arguments for a
call to \fIcv\fR.  Specifically, the function is used for a subroutine call,
not marked with \f(CW\*(C`&\*(C'\fR, where the callee can be identified at compile time
as \fIcv\fR.
.Sp
The C\-level function pointer is returned in \fI*psfun_p\fR, and an \s-1SV\s0
argument for it is returned in \fI*psobj_p\fR.  The function is intended
to be called in this manner:
.Sp
.Vb 1
\&    argsop = (*psfun_p)(aTHX_ namegv, (*psobj_p), &flags);
.Ve
.Sp
This call is to be made when the parser has just scanned and accepted
a bareword and determined that it begins the syntax of a call to \fIcv\fR.
\&\fInamegv\fR is a \s-1GV\s0 supplying the name that should be used by the parsing
function to refer to the callee if it needs to emit any diagnostics,
and \fIflags\fR is a \f(CW\*(C`U32\*(C'\fR that the parsing function can write to as an
additional output.  It is permitted to apply the parsing function in
non-standard situations, such as to a call to a different subroutine.
.Sp
The parsing function's main output is an op tree describing a list of
argument expressions.  This may be null for an empty list.  The argument
expressions will be combined with the expression that identified \fIcv\fR and
used to build an \f(CW\*(C`entersub\*(C'\fR op describing a complete subroutine call.
The parsing function may also set flag bits in \fIflags\fR for special
effects.  The bit \f(CW\*(C`CALLPARSER_PARENS\*(C'\fR indicates that the argument
list was fully parenthesised, which makes a difference only in obscure
situations.  The bit \f(CW\*(C`CALLPARSER_STATEMENT\*(C'\fR indicates that what was
parsed was syntactically not an expression but a statement.
.Sp
By default, the parsing function is
Perl_parse_args_proto_or_list, and the
\&\s-1SV\s0 parameter is \fIcv\fR itself.  This implements standard subroutine
argument parsing.  It can be changed, for a particular subroutine,
by \*(L"cv_set_call_parser\*(R".
.Sp
.Vb 2
\&        void cv_get_call_parser(CV *cv, Perl_call_parser *psfun_p,
\&                SV **psobj_p)
.Ve
.IP "cv_set_call_parser" 4
.IX Item "cv_set_call_parser"
Sets the function that will be used to parse the arguments for a call
to \fIcv\fR.  Specifically, the function is used for a subroutine call,
not marked with \f(CW\*(C`&\*(C'\fR, where the callee can be identified at compile time
as \fIcv\fR.
.Sp
The C\-level function pointer is supplied in \fIpsfun\fR, and an \s-1SV\s0 argument
for it is supplied in \fIpsobj\fR.  The function is intended to be called
in this manner:
.Sp
.Vb 1
\&    argsop = (*psfun_p)(aTHX_ namegv, (*psobj_p), &flags);
.Ve
.Sp
This call is to be made when the parser has just scanned and accepted
a bareword and determined that it begins the syntax of a call to \fIcv\fR.
\&\fInamegv\fR is a \s-1GV\s0 supplying the name that should be used by the parsing
function to refer to the callee if it needs to emit any diagnostics,
and \fIflags\fR is a \f(CW\*(C`U32\*(C'\fR that the parsing function can write to as an
additional output.  It is permitted to apply the parsing function in
non-standard situations, such as to a call to a different subroutine.
.Sp
The parsing function's main output is an op tree describing a list of
argument expressions.  This may be null for an empty list.  The argument
expressions will be combined with the expression that identified \fIcv\fR and
used to build an \f(CW\*(C`entersub\*(C'\fR op describing a complete subroutine call.
The parsing function may also set flag bits in \fIflags\fR for special
effects.  The bit \f(CW\*(C`CALLPARSER_PARENS\*(C'\fR indicates that the argument
list was fully parenthesised, which makes a difference only in obscure
situations.  The bit \f(CW\*(C`CALLPARSER_STATEMENT\*(C'\fR indicates that what was
parsed was syntactically not an expression but a statement.
.Sp
The current setting for a particular \s-1CV\s0 can be retrieved by
\&\*(L"cv_get_call_parser\*(R".
.Sp
.Vb 2
\&        void cv_set_call_parser(CV *cv, Perl_call_parser psfun,
\&                SV *psobj)
.Ve
.IP "parse_args_parenthesised" 4
.IX Item "parse_args_parenthesised"
Parse a parenthesised argument list for a subroutine call.  The argument
list consists of an optional expression enclosed in parentheses.
This is the syntax that is used for any subroutine call where the first
thing following the subroutine name is an open parenthesis.  It is used
regardless of the subroutine's prototype.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR, to indicate that the argument
list was fully parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_parenthesised(U32 *flags_p)
.Ve
.IP "parse_args_nullary" 4
.IX Item "parse_args_nullary"
Parse an argument list for a call to a subroutine that is syntactically
a nullary function.  The argument list is either parenthesised or
completely absent.  This is the syntax that is used for a call to a
subroutine with a \f(CW\*(C`()\*(C'\fR prototype.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_nullary(U32 *flags_p)
.Ve
.IP "parse_args_unary" 4
.IX Item "parse_args_unary"
Parse an argument list for a call to a subroutine that is syntactically
a unary function.  The argument list is either parenthesised, absent,
or consists of an unparenthesised arithmetic expression.  This is the
syntax that is used for a call to a subroutine with prototype \f(CW\*(C`($)\*(C'\fR,
\&\f(CW\*(C`(;$)\*(C'\fR, or certain similar prototypes.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_unary(U32 *flags_p)
.Ve
.IP "parse_args_list" 4
.IX Item "parse_args_list"
Parse an argument list for a call to a subroutine that is syntactically
a list function.  The argument list is either parenthesised, absent, or
consists of an unparenthesised list expression.  This is the syntax that
is used for a call to a subroutine with any prototype that does not have
special handling (such as \f(CW\*(C`(@)\*(C'\fR or \f(CW\*(C`($$)\*(C'\fR) or with no prototype at all.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_list(U32 *flags_p)
.Ve
.IP "parse_args_block_list" 4
.IX Item "parse_args_block_list"
Parse an argument list for a call to a subroutine that is syntactically
a block-and-list function.  The argument list is either parenthesised,
absent, an unparenthesised list expression, or consists of a code block
followed by an optionl list expression.  Where the first thing seen
is an open brace, it is always interpreted as a code block.  This is
the syntax that is used for a call to a subroutine with any prototype
beginning with \f(CW\*(C`&\*(C'\fR, such as \f(CW\*(C`(&@)\*(C'\fR or \f(CW\*(C`(&$)\*(C'\fR.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_block_list(U32 *flags_p)
.Ve
.IP "parse_args_proto" 4
.IX Item "parse_args_proto"
Parse a subroutine argument list based on a subroutine prototype.
The syntax used for the argument list will be that implemented by
\&\*(L"parse_args_nullary\*(R", \*(L"parse_args_unary\*(R", \*(L"parse_args_list\*(R", or
\&\*(L"parse_args_block_list\*(R", depending on the prototype.  This is the
standard treatment used on a subroutine call, not marked with \f(CW\*(C`&\*(C'\fR,
where the callee can be identified at compile time and has a prototype.
.Sp
\&\fIprotosv\fR supplies the subroutine prototype to be applied to the call.
It may be a normal defined scalar, of which the string value will be used.
Alternatively, for convenience, it may be a subroutine object (a \f(CW\*(C`CV*\*(C'\fR
that has been cast to \f(CW\*(C`SV*\*(C'\fR) which has a prototype.
.Sp
The \fInamegv\fR parameter would be used to refer to the callee if required
in any error message, but currently no message does so.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 1
\&        OP *parse_args_proto(GV *namegv, SV *protosv, U32 *flags_p)
.Ve
.IP "parse_args_proto_or_list" 4
.IX Item "parse_args_proto_or_list"
Parse a subroutine argument list either based on a subroutine prototype or
using default list-function syntax.  The syntax used for the argument list
will be that implemented by \*(L"parse_args_nullary\*(R", \*(L"parse_args_unary\*(R",
\&\*(L"parse_args_list\*(R", or \*(L"parse_args_block_list\*(R", depending on the
prototype.  This is the standard treatment used on a subroutine call,
not marked with \f(CW\*(C`&\*(C'\fR, where the callee can be identified at compile time.
.Sp
\&\fIprotosv\fR supplies the subroutine prototype to be applied to the call, or
indicates that there is no prototype.  It may be a normal scalar, in which
case if it is defined then the string value will be used as a prototype,
and if it is undefined then there is no prototype.  Alternatively, for
convenience, it may be a subroutine object (a \f(CW\*(C`CV*\*(C'\fR that has been cast
to \f(CW\*(C`SV*\*(C'\fR), of which the prototype will be used if it has one.
.Sp
The \fInamegv\fR parameter would be used to refer to the callee if required
in any error message, but currently no message does so.
.Sp
The op tree representing the argument list is returned.  The bit
\&\f(CW\*(C`CALLPARSER_PARENS\*(C'\fR is set in \fI*flags_p\fR if the argument list was
parenthesised.
.Sp
.Vb 2
\&        OP *parse_args_proto_or_list(GV *namegv, SV *protosv,
\&                U32 *flags_p)
.Ve
.SH "BUGS"
.IX Header "BUGS"
Due to reliance on Perl core features to do anything interesting, only
a very limited form of custom parsing is possible prior to Perl 5.13.8,
and none at all prior to Perl 5.11.2.
.PP
The way this module determines which parsing code to use for a subroutine
conflicts with the expectations of some particularly tricky modules that
use nasty hacks to perform custom parsing without proper support from the
Perl core.  In particular, this module is incompatible with versions of
Devel::Declare prior to 0.006004 and versions of Data::Alias prior
to 1.13.  An arrangement has been reached that allows later versions of
those modules to coexist with this module.
.PP
Custom parsing code is only invoked if the subroutine to which it is
attached is invoked using an unqualified name.  For example, the name
\&\f(CW\*(C`foo\*(C'\fR works, but the name \f(CW\*(C`main::foo\*(C'\fR will not, despite referring
to the same subroutine.  This is an unavoidable limitation imposed by
the core's interim facility for custom parser plugins.  This should
be resolved if the \s-1API\s0 provided by this module, or something similar,
migrates into the core in a future version of Perl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::CallChecker
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2011, 2013 Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
