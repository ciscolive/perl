.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Validate::CSV 3"
.TH Data::Validate::CSV 3 "2019-12-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Validate::CSV \- read and validate CSV
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\s-1CSV\s0 Schema (\s-1JSON\s0):
.PP
.Vb 10
\&  {
\&    "@context": "http://www.w3.org/ns/csvw",
\&    "url": "countries.csv",
\&    "tableSchema": {
\&      "columns": [{
\&        "name": "country",
\&        "datatype": { "base": "string", "length": 2 }
\&      },{
\&        "name": "country group",
\&        "datatype": "string"
\&      },{
\&        "name": "name (en)",
\&        "datatype": "string"
\&      },{
\&        "name": "name (fr)",
\&        "datatype": "string"
\&      },{
\&        "name": "name (de)",
\&        "datatype": "string"
\&      },{
\&        "name": "latitude",
\&        "datatype": { "base": "number", "maximum": 90, "minimum": \-90 }
\&      },{
\&        "name": "longitude",
\&        "datatype": { "base": "number", "maximum": 180, "minimum": \-180 }
\&      }]
\&    }
\&  }
.Ve
.PP
\&\s-1CSV\s0 Data:
.PP
.Vb 3
\&  "at","eu","Austria","Autriche","Ã–sterreich","47.6965545","13.34598005"
\&  "be","eu","Belgium","Belgique","Belgien","50.501045","4.47667405"
\&  "bg","eu","Bulgaria","Bulgarie","Bulgarien","42.72567375","25.4823218"
.Ve
.PP
Perl:
.PP
.Vb 2
\&  use Path::Tiny qw(path);
\&  use Data::Validate::CSV;
\&  
\&  my $table = Data::Validate::CSV::Table\->new(
\&    schema     => path(\*(Aqcountries.csv\-metadata.json\*(Aq),
\&    input      => path(\*(Aqcountries.csv\*(Aq),
\&    has_header => !!0,
\&  );
\&  
\&  while (my $row = $table\->get_row) {
\&    for my $e (@{$row\->errors}) {
\&      warn $e;
\&    }
\&    printf(
\&      "%s is at latitude %f, longitude %f.\en",
\&      $row\->get("name (en)")\->value,
\&      $row\->get("latitude")\->value,
\&      $row\->get("longitude")\->value,
\&    );
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There's not really a lot of documentation right now.
.PP
Mostly there's three interfaces you need to know about: tables, rows,
and cells. (There are also columns, schemas, and notes, but for most
day-to-day usage, those can be considered internal implementation
details.)
.SS "Table interface"
.IX Subsection "Table interface"
The table is constructed with the following attributes:
.ie n .IP """schema""" 4
.el .IP "\f(CWschema\fR" 4
.IX Item "schema"
A schema for the table. Can be a hashref, a \s-1JSON\s0 string, a scalar ref to
a \s-1JSON\s0 string, or a Path::Tiny path to a file containing the schema.
.ie n .IP """input""" 4
.el .IP "\f(CWinput\fR" 4
.IX Item "input"
The \s-1CSV\s0 data for the table. Can be a filehandle, a scalar ref to a string
of data, or a Path::Tiny path to a file.
.ie n .IP """has_header""" 4
.el .IP "\f(CWhas_header\fR" 4
.IX Item "has_header"
A boolean indicating whether the \s-1CSV\s0 contains a header row. This will be
used to supply any column names missing from the schema, and will be 
skipped from being returned by \f(CW\*(C`get_row\*(C'\fR.
.ie n .IP """reader""" 4
.el .IP "\f(CWreader\fR" 4
.IX Item "reader"
A coderef which, if given a filehandle, will return a parsed line of \s-1CSV.\s0
The default is basically something like:
.Sp
.Vb 1
\&  sub { Text::CSV_XS\->new\->getline($_[0]) }
.Ve
.Sp
That's probably sufficient for most cases, but you may need to supply your
own reader for handling tab-delimited files.
.ie n .IP """skip_rows""" 4
.el .IP "\f(CWskip_rows\fR" 4
.IX Item "skip_rows"
An integer, number of additional rows to skip \fIbefore\fR the header.
Some \s-1CSV\s0 files contain a title or credit line. Defaults to 0.
.ie n .IP """skip_rows_after_header""" 4
.el .IP "\f(CWskip_rows_after_header\fR" 4
.IX Item "skip_rows_after_header"
An integer, number of additional rows to skip \fIafter\fR the header.
Defaults to 0.
.PP
The table provides the following methods:
.ie n .IP """get_row""" 4
.el .IP "\f(CWget_row\fR" 4
.IX Item "get_row"
Returns a row object for the next row of the table.
.ie n .IP """all_rows""" 4
.el .IP "\f(CWall_rows\fR" 4
.IX Item "all_rows"
Gets all the rows as a list.
.ie n .IP """row_count""" 4
.el .IP "\f(CWrow_count\fR" 4
.IX Item "row_count"
The number of non-skipped, non-header lines read so far.
.SS "Row interface"
.IX Subsection "Row interface"
The rows returned by \f(CW\*(C`get_row\*(C'\fR and \f(CW\*(C`all_rows\*(C'\fR are blessed objects.
They provide the following methods:
.ie n .IP """raw_values""" 4
.el .IP "\f(CWraw_values\fR" 4
.IX Item "raw_values"
The values returned by Text::CSV_XS without any further processing.
.ie n .IP """values""" 4
.el .IP "\f(CWvalues\fR" 4
.IX Item "values"
The values returned by Text::CSV_XS, processed by datatype. Date and
time datatypes will be reformatted from any CLDR-based format to \s-1ISO 8601.\s0
Booleans using non-standard representations will be changed to \*(L"1\*(R" and \*(L"0\*(R".
Fields that have a separator defined will be split into an arrayref.
Numbers given as percentages will be divided by 100. And so forth.
.ie n .IP """cells""" 4
.el .IP "\f(CWcells\fR" 4
.IX Item "cells"
Returns the same values as \f(CW\*(C`values\*(C'\fR but wrapped in cell objects. The
following are equivalent:
.Sp
.Vb 3
\&  $row\->values\->[0];
\&  $row\->cells\->[0]\->value;
\&  $row\->[0];  # $row overloads @{}
.Ve
.Sp
Why fetch a cell instead of directly fetching the value? The cell object
offers a few other useful methods.
.ie n .IP """get($name)""" 4
.el .IP "\f(CWget($name)\fR" 4
.IX Item "get($name)"
Gets a single cell from the row by its name. Names are defined in the
schema, or the header row if missing from the schema.
.Sp
.Vb 1
\&  $row\->get("country")\->value;
.Ve
.ie n .IP """row_number""" 4
.el .IP "\f(CWrow_number\fR" 4
.IX Item "row_number"
The row number for this row in the table. Rows are numbered starting at
1. Headers and skipped rows are not counted.
.ie n .IP """key_string""" 4
.el .IP "\f(CWkey_string\fR" 4
.IX Item "key_string"
For tables that has a primary key, this returns a string formed by joining
together the primary key columns. It ought to be a unique identifier for this
row within the table, and if it is not, this will be raised as an error.
.ie n .IP """errors""" 4
.el .IP "\f(CWerrors\fR" 4
.IX Item "errors"
An arrayref of strings of errors associated with this row. This includes
data validation problems.
.SS "Cell interface"
.IX Subsection "Cell interface"
It is possible to bypass using the cell interface and access cell values
directly from the rows, but if accessing cells, these are the methods they
provide:
.ie n .IP """raw_value""" 4
.el .IP "\f(CWraw_value\fR" 4
.IX Item "raw_value"
The value returned by Text::CSV_XS without any further processing.
.ie n .IP """value""" 4
.el .IP "\f(CWvalue\fR" 4
.IX Item "value"
The value returned by Text::CSV_XS, processed by datatype.
.ie n .IP """inflated_value""" 4
.el .IP "\f(CWinflated_value\fR" 4
.IX Item "inflated_value"
Like \f(CW\*(C`value\*(C'\fR but inflates some values to blessed objects. Date and time
related datatypes will be returned as DateTime, DateTime::Incomplete,
or DateTime::Duration objects. Booleans will be returned as
JSON::PP::Boolean objects.
.ie n .IP """row_number""" 4
.el .IP "\f(CWrow_number\fR" 4
.IX Item "row_number"
The row number for the cell's parent row in the table. Rows are numbered
starting at 1. Headers and skipped rows are not counted.
.ie n .IP """col_number""" 4
.el .IP "\f(CWcol_number\fR" 4
.IX Item "col_number"
The column number of this cell within the parent row. Columns are numbered
starting at 1.
.ie n .IP """datatype""" 4
.el .IP "\f(CWdatatype\fR" 4
.IX Item "datatype"
The datatype for this cell as a hashref.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Data\-Validate\-CSV>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<https://www.w3.org/TR/2016/NOTE\-tabular\-data\-primer\-20160225/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2019 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
