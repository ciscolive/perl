.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Tidy 3"
.TH Pod::Tidy 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Tidy \- a reformatting Pod Processor
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Pod::Tidy qw( tidy_files tidy_filehandle );
\&
\&    my $processed = Pod::Tidy::tidy_files(
\&        files       => \e@list,
\&        ignore      => [qr/foo/, qr/bar/],
\&        recursive   => $recursive,
\&        verbose     => $verbose,
\&        inplace     => $inplace,
\&        nobackup    => $nobackup,
\&        columns     => $columns,
\&    );
\&
\&    Pod::Tidy::tidy_filehandle($input);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the \fIheavy lifting\fR needed by the \f(CW\*(C`podtidy\*(C'\fR utility
although the \s-1API\s0 should be general enough that it can be used directly.
.SH "USAGE"
.IX Header "USAGE"
.SS "Import Parameters"
.IX Subsection "Import Parameters"
This module accepts no arguments to it's \f(CW\*(C`import\*(C'\fR method and exports no
\&\fIsymbols\fR.
.SS "Exportable Subroutines"
.IX Subsection "Exportable Subroutines"
.IP "\(bu" 4
tidy_files( ... )
.Sp
Accepts a mandatory hash.
.Sp
.Vb 9
\&    my $processed = Pod::Tidy::tidy_files(
\&        files       => \e@list,
\&        ignore      => [qr/foo/, qr/bar/],
\&        recursive   => $recursive,
\&        verbose     => $verbose,
\&        inplace     => $inplace,
\&        nobackup    => $nobackup,
\&        columns     => $columns,
\&    );
.Ve
.RS 4
.IP "\(bu" 4
files
.Sp
An array ref to a list of files and/or directories.
.IP "\(bu" 4
ignore
.Sp
An array ref to regex objects that are used to reject files and/or directories.
Each pattern is tried for a match against (in order) the absolute file path,
the relative file path (canonical), and the basename.  In the case of
directories, the \*(L"basename\*(R" is considered to be the right most path component.
For example, the \*(L"basename\*(R" of \f(CW\*(C`/foo/bar/baz/\*(C'\fR would be to be \f(CW\*(C`baz\*(C'\fR.
.Sp
This key is optional.
.IP "\(bu" 4
recursive
.Sp
Accepts \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR, or \f(CW1\fR.  If set to \f(CW1\fR any directories provided to
the \f(CW\*(C`files\*(C'\fR key will be recursively expanded.  Defaults to \f(CW\*(C`undef\*(C'\fR
.Sp
This key is optional.
.IP "\(bu" 4
verbose
.Sp
Accepts \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR, or \f(CW1\fR.  \f(CW1\fR enables verbose warnings. Defaults to
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
This key is optional.
.IP "\(bu" 4
inplace
.Sp
Accepts \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR, or \f(CW1\fR.  \f(CW1\fR enables \fIin place\fR reformatting of
files.  Updated files will be backed up unless the \f(CW\*(C`nobackup\*(C'\fR key is set.  The
\&\f(CW\*(C`mtime\*(C'\fR of the file is guarenteed not to be changed unless formating changes
did occur.  Defaults to \f(CW\*(C`undef\*(C'\fR.
.Sp
This key is optional.
.IP "\(bu" 4
nobackup
.Sp
Accepts \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR, or \f(CW1\fR.  If set to \f(CW1\fR files being reformatted in
place will not be backed up.  Defaults to \f(CW\*(C`undef\*(C'\fR.
.Sp
This key is optional.
.IP "\(bu" 4
columns
.Sp
Accepts any number. Sets the line width of the reformatted pod. 
Defaults to \f(CW76\fR (Text::Wrap's default).
.Sp
This key is optional.
.RE
.RS 4
.Sp
Before processing a file it is checked for:
.IP "\(bu" 4
correct access permissions
.IP "\(bu" 4
containing Pod
.IP "\(bu" 4
legal Pod syntax
.RE
.RS 4
.Sp
Any file failing to meet those criteria will \fInot\fR be processed.
.Sp
Returns a count of processed files or \f(CW\*(C`undef\*(C'\fR if no files could be processed.
.RE
.IP "\(bu" 4
tidy_filehandle($input)
.Sp
Accepts an open filehandle.  Data from the filehandle is processed as it is
read so this subroutine can be used to filter large amounts of data.  Because
of this behavior the input can not be checked in advance to verify a) That it's
actually Pod and b) that the Pod document uses only valid Pod syntax.  Output
is set to \f(CW\*(C`STDOUT\*(C'\fR.  Returns nothing.
.SS "Internal Subroutines"
.IX Subsection "Internal Subroutines"
These subroutines are not exportable.
.IP "\(bu" 4
backup_file
.IP "\(bu" 4
base
.IP "\(bu" 4
build_pod_queue
.IP "\(bu" 4
process_pod_queue
.IP "\(bu" 4
valid_pod_syntax
.SH "DEVELOPER NOTES"
.IX Header "DEVELOPER NOTES"
.SS "Efficiency concerns"
.IX Subsection "Efficiency concerns"
The \f(CW\*(C`tidy_files()\*(C'\fR subroutine does a number of highly inefficient things. Each
file is opened and closed at least 3 different times as it is passed through a
number of different modules to see if it meets the processing criteria.  This
shouldn't be a major performance issue with an modern \s-1OS\s0's \s-1VM\s0 subsystem but it
still leaves much to be desired.  When doing \f(CW\*(C`inplace\*(C'\fR file reformatting a
complete copy of the original file and the updated file and held in memory for
comparison.  Thus you are limited to reformatting Pod documents \f(CW\*(C` < (
available_system_memory / 2 )\*(C'\fR.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
.SS "Pod files not identified"
.IX Subsection "Pod files not identified"
Due to a bug in the version of \*(L"contains_pod\*(R" in Pod::Find bundled with
Pod::Parser 1.33, Pod containing files will not be detected if the only
\&\f(CW\*(C`=[foo]N\*(C'\fR directive is on the first line of the file.  For example:
.PP
.Vb 1
\&    =head1 foo
\&    
\&    foobarbaz
\&
\&    =cut
.Ve
.PP
Would not be detected unless there was a newline before \f(CW\*(C`=head1 foo\*(C'\fR.  See
\&\s-1CPAN\s0 bug #14871 for a patch to correct Pod::Find.  This should be fixed in
version 1.34 of Pod::Parser
.SS "Mangled verbatim blocks"
.IX Subsection "Mangled verbatim blocks"
Unfortunately, the \f(CW\*(C`perldoc\*(C'\fR utility doesn't follow perlpodspec for what it
considers a verbatim block.  As far as \f(CW\*(C`perldoc\*(C'\fR is concerned, any line that
begins with whitespace is in a verbatim block.  While the Pod spec requires
that all blocks are separated by a blank line.
.PP
Consider this example:
.PP
.Vb 1
\&    =head1 What Would Brian Boitano Do?
\&
\&    What would Brian Boitano do
\&    If he was here right now?
\&    He\*(Aqd make a plan and he\*(Aqd follow through
\&    That\*(Aqs what Brian Boitano\*(Aqd do
\&        When Brian Boitano was in the olympics
\&        Skating for the gold
\&        He\*(Aqd do sound cows and a triple relux
\&        wearin a blindfold
\&
\&    =cut
.Ve
.PP
\&\f(CW\*(C`perldoc\*(C'\fR incorrectly considers the second paragraph to be indented and would
display it as one might be expecting.  However, \f(CW\*(C`podtidy\*(C'\fR would turn it into
this:
.PP
.Vb 1
\&    =head1 What Would Brian Boitano Do?
\&
\&    What would Brian Boitano do If he was here right now?  He\*(Aqd make a plan and
\&    he\*(Aqd follow through That\*(Aqs what Brian Boitano\*(Aqd do     When Brian Boitano was
\&    in the olympics     Skating for the gold     He\*(Aqd do sound cows and a triple
\&    relux     wearin a blindfold
\&
\&    =cut
.Ve
.PP
If a single blank line is added between the two paragraphs as required by
perlpodspec, the original document would look like this:
.PP
.Vb 1
\&    =head1 What Would Brian Boitano Do?
\&
\&    What would Brian Boitano do
\&    If he was here right now?
\&    He\*(Aqd make a plan and he\*(Aqd follow through
\&    That\*(Aqs what Brian Boitano\*(Aqd do
\&
\&        When Brian Boitano was in the olympics
\&        Skating for the gold
\&        He\*(Aqd do sound cows and a triple relux
\&        wearin a blindfold
\&
\&    =cut
.Ve
.PP
Then the result from \f(CW\*(C`podtidy\*(C'\fR would be nice and... well... \fItidy\fR.
.PP
.Vb 1
\&    =head1 What Would Brian Boitano Do?
\&
\&    What would Brian Boitano do If he was here right now? He\*(Aqd make a plan and he\*(Aqd
\&    follow through That\*(Aqs what Brian Boitano\*(Aqd do
\&
\&        When Brian Boitano was in the olympics
\&        Skating for the gold
\&        He\*(Aqd do sound cows and a triple relux
\&        wearin a blindfold
\&
\&    =cut
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
Larry Denneau \f(CW\*(C`denneau@ifa.hawaii.edu\*(C'\fR reported test failures caused by
Module::Build stripping the execute bit from \fIscripts/podtidy\fR.
.PP
Grant McLean \f(CW\*(C`grant@mclean.net.nz\*(C'\fR caught a grammatical error in the
documentation.
.PP
Michael Cartmell \f(CW\*(C`Michael.Cartmell@thomson.com\*(C'\fR provided some grammatical
corrections and a patch to fix \f(CW\*(C`Pod::Tidy::build_pod_queue()\*(C'\fR tests on Win32,
reporting test failures on Win32 caused by differing newline encodings, and
reporting \s-1CPANPLUS\s0 playing badly with Module::Build's \f(CW\*(C`build_requires\*(C'\fR.
.PP
Hanno Hecker <vetinari@ankh\-morp.org> provided a patch to allow the column
width to specified in both the Pod::Tidy library and \f(CW\*(C`podtidy\*(C'\fR utility.
.SH "SUPPORT"
.IX Header "SUPPORT"
Please contact the author directly via e\-mail.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joshua Hoblitt \f(CW\*(C`jhoblitt@cpan.org\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005  Joshua Hoblitt. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as Perl
itself.
.PP
The full text of the licenses can be found in the \fI\s-1LICENSE\s0\fR file included with
this module, or in perlartistic and perlgpl Pods as supplied with Perl
5.8.1 and later.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
podtidy, Pod::Wrap::Pretty, podwrap, Pod::Wrap, Perl::Tidy
