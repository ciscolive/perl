.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector::Proxy::Net::LDAP 3"
.TH Connector::Proxy::Net::LDAP 3 "2020-06-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Connector::Proxy::Net::LDAP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for all \s-1LDAP\s0 Proxy modules. It does not offer any
external functionality but bundles common configuration options.
.SH "USAGE"
.IX Header "USAGE"
.SS "minimal setup"
.IX Subsection "minimal setup"
.Vb 5
\&    my $conn = Connector::Proxy::Net::LDAP\->new({
\&       LOCATION  => \*(Aqldap://localhost:389\*(Aq,
\&       base      => \*(Aqdc=example,dc=org\*(Aq,
\&       filter  => \*(Aq(cn=[% ARGS.0 %])\*(Aq,
\&    });
\&
\&    $conn\->get(\*(AqJohn Doe\*(Aq);
.Ve
.PP
Above code will run a query of \f(CW\*(C`cn=test@example.org against the server\*(C'\fR
using an anonymous bind.
.SS "using bind credentials"
.IX Subsection "using bind credentials"
.Vb 8
\&    my $conn = Connector::Proxy::Net::LDAP\->new( {
\&        LOCATION  => \*(Aqldap://localhost:389\*(Aq,
\&        base      => \*(Aqdc=example,dc=org\*(Aq,
\&        filter  => \*(Aq(cn=[% ARGS.0 %])\*(Aq,
\&        binddn    => \*(Aqcn=admin,dc=openxpki,dc=org\*(Aq,
\&        password  => \*(Aqadmin\*(Aq,
\&        attrs => [\*(Aqusercertificate;binary\*(Aq,\*(Aqusercertificate\*(Aq],
\&    });
.Ve
.PP
Uses bind credentials and queries for entries having (at least) one of the
mentioned attributes.
.SS "setting values"
.IX Subsection "setting values"
You can control how existing attributes in the node are treated setting the
\&\fIaction\fR parameter in the connectors base configuration.
.PP
.Vb 4
\&    connector:
\&        LOCATION:...
\&        ....
\&        action: replace
.Ve
.IP "replace" 4
.IX Item "replace"
This is the default (the action parameter may be omitted). The passed value is
set as the only value in the attribute. Any values (even if there are more
than one) are removed. If undef is passed, the whole attribute is removed
from the node.
.IP "append" 4
.IX Item "append"
The given value is appended to exisiting attributes. If undef is passed, the request is ignored.
.IP "delete" 4
.IX Item "delete"
The given value is deleted from the attribute entry. If there are more items in the attribute,
the remaining values are left untouched. If the value is not present or undef is passed,
the request is ignored.
.SS "autocreation of missing nodes"
.IX Subsection "autocreation of missing nodes"
If you want the connector to autocreate missing nodes (on a set operation),
you need to provide the ldap properties for each rdn item.
.PP
.Vb 6
\&    schema:
\&        cn:
\&            objectclass: inetOrgPerson pkiUser
\&            values:
\&                sn: copy:self
\&                ou: IT Department
.Ve
.PP
You can specify multiple objectclass entries seperated by space or as list.
.PP
The objects attribute matching the \s-1RDN\s0 component is always set, you can
use the special word \f(CW\*(C`copy:self\*(C'\fR to copy the attribute value within the
object. The values section is optional.
.PP
If schema for \fI\s-1CN\s0\fR is given and the filter does not find a result, the
node name is constructed from using the first path argument as \s-1CN\s0 and the
base dn of the connector as path. All defined attribute values that have
been passed are also added to the object on creation. Auto-Creation is not
applied if action is set to delete.
.PP
For creating the actual leaf node, there are additional options by adding
the node \fIcreate\fR to the configuration.
.PP
\fIset another component class for the node\fR
.IX Subsection "set another component class for the node"
.PP
.Vb 2
\&    create:
\&        rdnkey: emailAddress
.Ve
.PP
Will use the given class name with the first argument as value plus the
base dn to build the node \s-1DN.\s0 The old syntax with rdnkey + value pattern
(which was broken anyway) is no longer supported, use the full rdn template
as given below if required.
.PP
\fIset another path to the node\fR
.IX Subsection "set another path to the node"
.PP
.Vb 2
\&    create:
\&        basedn: ou=Webservers,ou=Servers,dc=company,dc=org
.Ve
.PP
\fIuse templating to generate the local component\fR
.IX Subsection "use templating to generate the local component"
.PP
The given base dn will be prefixed with the component assigned to the
leaf, e.g. cn=www.example.org,ou=Webservers,ou=Servers,dc=company,dc=org
.PP
\fIuse templating to generate the local component\fR
.IX Subsection "use templating to generate the local component"
.PP
.Vb 2
\&    create:
\&        rdn: emailAddress=[% ARGS.0 %]
.Ve
.PP
Same result as the first example, the path arguments are all in \s-1ARGS,\s0
additional data (depends on the subclass implementation) are made
available in the \s-1DATA\s0 key.
.PP
Multivalued RDNs can be constructed using a list:
.PP
.Vb 4
\&    create:
\&        rdn:
\&         \- emailAddress=[% ARGS.0 %]
\&         \- CN=[% ARGS.1 %]
.Ve
.PP
\fIuse temlating for full \s-1DN\s0\fR
.IX Subsection "use temlating for full DN"
.PP
.Vb 2
\&    create:
\&        dn: emailAddress=[% ARGS.0 %],ou=People,dc=company,dc=org
.Ve
.PP
Same as setting basedn and rdn, components of the path are created if
there is a matching schema definition. Limitation: this module does not
support different value patterns for the same class name.
.SS "Full example using Connector::Multi"
.IX Subsection "Full example using Connector::Multi"
.Vb 2
\&    [ca1]
\&    myrepo@ = connector:connectors.ldap
\&
\&    [connectors]
\&
\&    [connectors.ldap]
\&    class = Connector::Proxy::Net::LDAP
\&    LOCATION = ldap://ldaphost:389
\&    base     = dc=openxpki,dc=org
\&    filter   = (cn=[% ARGS.0 %])
\&    attrs    = userCertificate;binary
\&    binddn   = cn=admin,dc=openxpki,dc=org
\&    password = admin
\&    action = replace
\&
\&    [connectors.ldap.create]
\&    basedn: ou=Webservers,ou=Server CA3,dc=openxpki,dc=org
\&    rdnkey: cn
\&    value: [% ARGS.0 %]
\&
\&    [connectors.ldap.schema.cn]
\&    objectclass: inetOrgPerson
\&
\&    [connectors.ldap.schema.cn.values]
\&    sn: copy:self
\&
\&    [connectors.ldap.schema.ou]
\&    objectclass: organizationalUnit
.Ve
.SH "internal methods"
.IX Header "internal methods"
.SS "_getByDN"
.IX Subsection "_getByDN"
Search a node by \s-1DN.\s0
.PP
.Vb 1
\&    $self\->_getByDN( \*(Aqcn=John Doe,ou=people,dc=openxpki,dc=org\*(Aq );
.Ve
.PP
Returns the ldap entry object or undef if not found. Pass \f(CW\*(C`{create =\*(C'\fR 1}> and
configure your connector to auto create a new node if none is found.
.SS "_createPathItem"
.IX Subsection "_createPathItem"
Used internally by _getByDN to create new nodes.
.SS "_triggerAutoCreate"
.IX Subsection "_triggerAutoCreate"
Used internally to assemble the \s-1DN\s0 for a missing node.
Returns the ldap entry or undef if autocreation is not possible.
.SS "_splitDN"
.IX Subsection "_splitDN"
Very simple approch to split a \s-1DN\s0 path into its components.
Please \fBdo not\fR use quoting of path components, as this is
not supported. RDNs must be split by a Comma, Comma inside a value
must be escaped using a backslash character. Multivalued RDNs are not supported.
.SS "_run_search"
.IX Subsection "_run_search"
This is a wrapper for
.PP
.Vb 1
\&  my $mesg = $ldap\->search( $self\->_build_search_options( $args, $param ) );
.Ve
.PP
that will take care of stale/lost connections to the server. The result
object is returned by the method, the ldap object is taken from the class.
