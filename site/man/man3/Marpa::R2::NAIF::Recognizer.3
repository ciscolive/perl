.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::NAIF::Recognizer 3"
.TH Marpa::R2::NAIF::Recognizer 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::NAIF::Recognizer \- NAIF recognizers
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 6
\&    my $recce = Marpa::R2::Recognizer\->new( { grammar => $grammar } );
\&    $recce\->read( \*(AqNumber\*(Aq, 42 );
\&    $recce\->read(\*(AqMultiply\*(Aq);
\&    $recce\->read( \*(AqNumber\*(Aq, 1 );
\&    $recce\->read(\*(AqAdd\*(Aq);
\&    $recce\->read( \*(AqNumber\*(Aq, 7 );
.Ve
.SH "Description"
.IX Header "Description"
This document describes recognizers for Marpa's
named argument interface (\s-1NAIF\s0).
If you are a beginner,
or are not sure which interface you are interested in,
or do not know what the \s-1NAIF\s0 interfaces is,
you probably are looking for
the document on recognizers for the \s-1SLIF\s0
interface.
.PP
To create a recognizer object, use the \f(CW\*(C`new\*(C'\fR method.
.PP
To read input, use the \f(CW\*(C`read\*(C'\fR method.
.PP
To evaluate a parse tree, based on the input, use the \f(CW\*(C`value\*(C'\fR method.
.SS "Token streams"
.IX Subsection "Token streams"
By default, Marpa uses the token-stream model of input.
The token-stream model is standard \*(-- so standard the most documents about
parsing do not bother to describe it.
In the token-stream model, each read adds a token at the current location,
then advances the current location by one.
The location before any input is numbered 0
and if \fIN\fR tokens are parsed,
they fill the locations from 1 to \fIN\fR.
.PP
This document will describe only the token-stream model of input.
Marpa allows other models of the input, but their use
requires special method calls,
which are described in the
document on alternative input models.
.SH "Constructor"
.IX Header "Constructor"
.SS "\fBnew()\fP"
.IX Subsection "new()"
.Vb 1
\&    my $recce = Marpa::R2::Recognizer\->new( { grammar => $grammar } );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR method creates a recognizer object.
The \f(CW\*(C`new\*(C'\fR method either returns a new recognizer object or throws an exception.
.PP
The arguments to the \f(CW\*(C`new\*(C'\fR method
are references to hashes of named
arguments.
In each key/value pair of these hashes, the key is the argument name,
and the hash value is the value of the argument.
The named arguments are described below.
.SH "Accessors"
.IX Header "Accessors"
.SS "\fBcheck_terminal()\fP"
.IX Subsection "check_terminal()"
.Vb 1
\&    my $is_symbol_a_terminal = $recce\->check_terminal(\*(AqDocument\*(Aq);
.Ve
.PP
Returns a Perl true when its argument is the name of a terminal symbol.
Otherwise, returns a Perl false.
Not often needed.
.SS "\fBevents()\fP"
.IX Subsection "events()"
.Vb 3
\&    my @expected_symbols =
\&        map { $_\->[1]; }
\&        grep { $_\->[0] eq \*(AqSYMBOL_EXPECTED\*(Aq } @{ $recce\->events() };
.Ve
.PP
Returns a reference to an array of the events
from the last \*(L"\fBread()\fR\*(R" method call.
Each element of the array is a subarray or 1 or 2 elements.
The first element of the subarray is the name of an event type,
as described in \*(L"Recognizer events\*(R".
The second element is the event value of the event,
where that is applicable.
For more detail, see
\&\*(L"Recognizer events\*(R".
.SS "\fBexhausted()\fP"
.IX Subsection "exhausted()"
.Vb 1
\&        $recce\->exhausted() and die \*(AqRecognizer exhausted\*(Aq;
.Ve
.PP
The \f(CW\*(C`exhausted\*(C'\fR method returns a Perl true if parsing
in a recognizer is exhausted, and a Perl false
otherwise.
Parsing is exhausted when the recognizer will not accept
any further input.
By default, a recognizer event occurs if parsing
is exhausted.
An attempt to read input into an exhausted parser
causes an exception to be thrown.
The recognizer event and the exception are all that
many applications require,
but this method allows the recognizer's exhaustion
status to be discovered directly.
.SS "\fBlatest_earley_set()\fP"
.IX Subsection "latest_earley_set()"
.Vb 1
\&    my $latest_earley_set = $recce\->latest_earley_set();
.Ve
.PP
Return the location of the latest (in other words,
the most recent)
Earley set.
In the places where it is most often needed,
the latest Earley set is the default,
and there is usually no need to request
the explicit value
of the latest Earley set.
.SS "\fBprogress()\fP"
.IX Subsection "progress()"
Given the location (Earley set \s-1ID\s0) as its argument,
returns an array that describes the parse progress
at that location.
Details on progress reports can be found in
their own document.
.SS "\fBterminals_expected()\fP"
.IX Subsection "terminals_expected()"
.Vb 1
\&    my $terminals_expected = $recce\->terminals_expected();
.Ve
.PP
Returns a reference to a list of strings,
where the strings are the
names of the terminals
acceptable at the current location.
In the default input model, the presence of a terminal
in this list means that terminal will be acceptable
in the next \f(CW\*(C`read\*(C'\fR method call.
This is highly useful for Ruby Slippers parsing.
.SH "Mutators"
.IX Header "Mutators"
.SS "\fBexpected_symbol_event_set()\fP"
.IX Subsection "expected_symbol_event_set()"
.Vb 1
\&    $recce\->expected_symbol_event_set( \*(Aqendmark\*(Aq, 1 );
.Ve
.PP
Marpa can generate a recognizer event when 
a symbol is expected at the current earleme.
This method takes a symbol name as its first argument,
and turns the expected-symbol event for that
symbol on or off,
according to whether its second argument is 1 or 0.
Always succeeds or throws an exception.
.PP
Events can occur at location 0 \*(-- when the recognizer is first created.
However, the event setting of \f(CW\*(C`expected_symbol_event_set()\*(C'\fR
cannot have an effect until after the first token is read \*(--
after location 0.
In cases where this is an issue,
the \*(L"event_if_expected\*(R" named argument of the
\&\*(L"\fBnew()\fR\*(R" method can be used to set an expected-symbol event.
.SS "\fBread()\fP"
.IX Subsection "read()"
.Vb 5
\&    $recce\->read( \*(AqNumber\*(Aq, 42 );
\&    $recce\->read(\*(AqMultiply\*(Aq);
\&    $recce\->read( \*(AqNumber\*(Aq, 1 );
\&    $recce\->read(\*(AqAdd\*(Aq);
\&    $recce\->read( \*(AqNumber\*(Aq, 7 );
.Ve
.PP
The \f(CW\*(C`read\*(C'\fR method reads one token at the current parse location.
It then advances the current location by 1.
.PP
\&\f(CW\*(C`read\*(C'\fR takes two arguments: a \fBtoken name\fR and a \fBtoken value\fR.
The token name is required.
It must be the name of a valid terminal symbol.
The token value is optional.
It defaults to a Perl \f(CW\*(C`undef\*(C'\fR.
For details about terminal symbols,
see \*(L"Terminal symbols\*(R" in Marpa::R2::NAIF::Grammar.
.PP
The parser may accept or reject the token.
If the parser accepted the token,
the \f(CW\*(C`read\*(C'\fR method returns
the number of recognizer events that occurred during the
\&\f(CW\*(C`read\*(C'\fR.
For more about events, see
\&\*(L"Recognizer events\*(R".
.PP
Marpa may reject a token because it is not one of those
acceptable at the current location.
When this happens, \f(CW\*(C`read\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
A rejected token need not end parsing \*(--
it is perfectly possible to retry the \f(CW\*(C`read\*(C'\fR call
with another token.
This is, in fact, an important technique in Ruby
Slippers parsing.
For details,
see the section on Ruby Slippers
parsing.
.PP
For other failures,
including an attempt to \f(CW\*(C`read\*(C'\fR a token
into an exhausted parser,
Marpa throws an exception.
.SS "\fBset()\fP"
.IX Subsection "set()"
.Vb 1
\&    $recce\->set( { max_parses => 10, } );
.Ve
.PP
The \f(CW\*(C`set\*(C'\fR method's arguments are references to hashes of named
arguments.
The \f(CW\*(C`set\*(C'\fR method
can be used to set or change named arguments after the recognizer
has been created.
Details of the named arguments are below.
.SS "\fBvalue()\fP"
.IX Subsection "value()"
.Vb 2
\&    my $value_ref = $recce\->value;
\&    my $value = $value_ref ? ${$value_ref} : \*(AqNo Parse\*(Aq;
.Ve
.PP
Because Marpa parses ambiguous grammars, every parse
is a series of zero or more parse trees.
There are zero parse trees if there was no valid parse
of the input according to the grammar.
.PP
The \f(CW\*(C`value\*(C'\fR method call evaluates the next parse tree
in the parse series,
and returns a reference to the parse result for that parse tree.
If there are no more parse trees,
the \f(CW\*(C`value\*(C'\fR method returns \f(CW\*(C`undef\*(C'\fR.
.SS "\fBreset_evaluation()\fP"
.IX Subsection "reset_evaluation()"
.Vb 2
\&        $recce\->reset_evaluation();
\&        $recce\->set( { end => $loc, max_parses => 999, } );
.Ve
.PP
The \f(CW\*(C`reset_evaluation()\*(C'\fR method ends a parse series,
and starts another.
It can be used to \*(L"restart\*(R" the parse series.
Restarting the parse series with
the \f(CW\*(C`reset_evaluation()\*(C'\fR method
allows the
application to specify new
values for
the \f(CW\*(C`closures\*(C'\fR,
\&\f(CW\*(C`end\*(C'\fR
and \f(CW\*(C`ranking_method\*(C'\fR named arguments.
Once a parse series is underway,
these values cannot be changed.
.PP
The most common use for
\&\f(CW\*(C`reset_evaluation()\*(C'\fR method
is to parse
a single input stream
at different end points.
This can also be done by creating a new recognizer
and re-reading the input
from the beginning,
but it is much more efficient to
evaluate a single recognizer run
several times,
using different parse end locations.
After the parse is restarted using
the \f(CW\*(C`reset_evaluation()\*(C'\fR method,
the recognizer's \f(CW\*(C`set()\*(C'\fR
method
and its \f(CW\*(C`end\*(C'\fR named argument
can be used to change the
parse end location.
.SH "Trace accessors"
.IX Header "Trace accessors"
.SS "\fBshow_progress()\fP"
.IX Subsection "show_progress()"
.Vb 2
\&    print $recce\->show_progress()
\&        or die "print failed: $ERRNO";
.Ve
.PP
Returns a string describing the progress of the parse.
With no arguments,
the string contains reports for
the current location.
With a single integer argument \fIN\fR,
the string contains reports for location \fIN\fR.
With two numeric arguments, \fIN\fR and \fIM\fR, the arguments are interpreted
as a range of locations and the returned string contains
reports for all locations in the range.
(\*(L"Location\*(R" as referred to in this section,
and elsewhere
in this document,
is what is also called the Earley set \s-1ID.\s0)
.PP
If an argument is negative,
\&\fI\-N\fR,
it indicates
the \fIN\fRth location counting backward
from the furthest location of the parse.
For example, if 42 was the furthest location,
\&\-1 would be location 42 and \-2 would be location 41.
For example, the method call
\&\f(CW\*(C`$recce\->show_progress(\-3, \-1)\*(C'\fR
returns reports for the last three locations of the parse.
The method call \f(CW\*(C`$recce\->show_progress(0, \-1)\*(C'\fR
will print progress reports for the entire parse.
.PP
\&\f(CW\*(C`show_progress\*(C'\fR is
Marpa's most powerful tool for
debugging application grammars.
It can also be used to track the
progress of a parse or
to investigate how a parse works.
A much fuller description,
with an example,
is in
the document on debugging Marpa
grammars.
.SH "Named arguments"
.IX Header "Named arguments"
The recognizer's named arguments are
accepted by its
\&\f(CW\*(C`new\*(C'\fR and \f(CW\*(C`set\*(C'\fR methods.
.SS "closures"
.IX Subsection "closures"
The value of \f(CW\*(C`closures\*(C'\fR named argument
must be
a reference to a hash.
In each key/value pair of this hash,
the key must be an action name.
The hash value
must be a \s-1CODE\s0 ref.
The \f(CW\*(C`closures\*(C'\fR named argument
is not allowed once evaluation has begun.
.PP
When an action name is a key in
the
\&\f(CW\*(C`closures\*(C'\fR named argument,
the usual action resolution mechanism of the semantics
is bypassed.
One common use of
the \f(CW\*(C`closures\*(C'\fR named argument is to
allow anonymous
subroutines to be semantic actions.
For more details, see the document on
semantics.
.SS "end"
.IX Subsection "end"
The \f(CW\*(C`end\*(C'\fR named argument
specifies the parse end location.
The default is for the parse to end where the input did,
so that the parse returned is of the entire input.
The \f(CW\*(C`end\*(C'\fR named argument is not allowed
once evaluation has begun.
\&\*(L"Location\*(R" as referred to here and elsewhere
in this document is what is also called
an Earley set \s-1ID.\s0
.SS "event_if_expected"
.IX Subsection "event_if_expected"
The value of the 
\&\f(CW\*(C`event_if_expected\*(C'\fR named argument
must be a reference to an array
of symbol names.
Expected-symbol events will be turned on for those symbol
names.
Expected-symbol events may be turned off (or back on)
using the \*(L"\fBexpected_symbol_event_set()\fR\*(R" method.
The advantage of the \f(CW\*(C`event_if_expected\*(C'\fR named argument
is that it takes effect as soon as the recognizer is created,
while events set
using the \*(L"\fBexpected_symbol_event_set()\fR\*(R" method
cannot occur until after the first token is read.
.SS "grammar"
.IX Subsection "grammar"
The \f(CW\*(C`new\*(C'\fR method is required to have
a \f(CW\*(C`grammar\*(C'\fR named argument.  Its
value must be
a precomputed Marpa grammar object.
The \f(CW\*(C`grammar\*(C'\fR named argument is not allowed anywhere else.
.SS "max_parses"
.IX Subsection "max_parses"
If non-zero, causes a fatal error when that number
of parse results is exceeded.
\&\f(CW\*(C`max_parses\*(C'\fR is useful to
limit \s-1CPU\s0 usage and output length when testing
and debugging.
Stable and production applications may
prefer to count the number of parses,
and take a less Draconian response when the
count is exceeded.
.PP
The value must be an integer.
If it is zero, there will be no
limit on the number of parse results returned.
The default is for
there to be no limit.
.SS "ranking_method"
.IX Subsection "ranking_method"
The value must be a string:
one of "\f(CW\*(C`none\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`rule\*(C'\fR\*(L",
or \*(R"\f(CW\*(C`high_rule_only\*(C'\fR\*(L".
When the value is \*(R"\f(CW\*(C`none\*(C'\fR", Marpa returns the parse results
in arbitrary order.
This is the default.
The \f(CW\*(C`ranking_method\*(C'\fR named argument is not allowed
once evaluation has begun.
.PP
The "\f(CW\*(C`rule\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`high_rule_only\*(C'\fR" ranking methods
allows the user
to control the order
in which parse results are returned by
the \f(CW\*(C`value\*(C'\fR method,
and to exclude some parse results from the parse series.
For details, see the document
on parse order.
.SS "too_many_earley_items"
.IX Subsection "too_many_earley_items"
The \f(CW\*(C`too_many_earley_items\*(C'\fR argument is optional.
If specified, it sets the \fBEarley item warning threshold\fR.
If an Earley set becomes larger than the
Earley item warning threshold,
a recognizer event is generated,
and
a warning is printed to the trace file handle.
.PP
Marpa parses from any \s-1BNF,\s0
and can handle grammars and inputs which produce large
Earley sets.
But parsing that involves large Earley sets can be slow.
Large Earley sets
are something most applications can,
and will wish to, avoid.
.PP
By default, Marpa calculates
an Earley item warning threshold
based on the size of the
grammar.
The default threshold will never be less than 100.
If the Earley item warning threshold is set to 0,
no recognizer event is generated,
and
warnings about large Earley sets are turned off.
.SS "trace_actions"
.IX Subsection "trace_actions"
The
\&\f(CW\*(C`trace_actions\*(C'\fR named argument
is a boolean.
If the boolean value is true, Marpa prints tracing information
as it resolves action names to
Perl closures.
A boolean value of false turns tracing off, which is the default.
Traces are written to the trace file handle.
.SS "trace_file_handle"
.IX Subsection "trace_file_handle"
The value is a file handle.
Traces and warning messages
go to the trace file handle.
By default the trace file handle is inherited
from the grammar used to create the recognizer.
.SS "trace_terminals"
.IX Subsection "trace_terminals"
Very handy in debugging, and often useful
even when the problem is not in the lexing.
The value is a trace level.
When the trace level is 0,
tracing of terminals is off.
This is the default.
.PP
At a trace level of 1 or higher,
Marpa produces a trace message
for each terminal as it is accepted or rejected
by the recognizer.
At a trace level of 2 or higher,
the trace messages include, for
every location, a list of the
terminals expected.
In practical grammars, output from
trace level 2 can be voluminous.
.SS "trace_values"
.IX Subsection "trace_values"
The \f(CW\*(C`trace_values\*(C'\fR named argument
is a numeric trace level.
If the numeric trace level is 1, Marpa
prints tracing information
as values are computed in the evaluation stack.
A trace level of 0 turns value tracing off,
which is the default.
Traces are written to the trace file handle.
.SS "warnings"
.IX Subsection "warnings"
The value is a boolean.
Warnings are written to the trace file handle.
By default, the recognizer's warnings are on.
Usually, an application will want to leave them on.
.SH "Recognizer events"
.IX Header "Recognizer events"
The recognizer's \f(CW\*(C`read()\*(C'\fR method can generate events.
To access events, use the recognizer's \*(L"\fBevents()\fR\*(R" method.
.PP
The \f(CW\*(C`EARLEY_ITEM_THRESHOLD\*(C'\fR and
The \f(CW\*(C`EXHAUSTED\*(C'\fR events are enabled by default.
Events optionally have an \*(L"event value\*(R",
as specified in the description of each event.
The following events are possible.
.SS "\s-1EARLEY_ITEM_THRESHOLD\s0"
.IX Subsection "EARLEY_ITEM_THRESHOLD"
The Earley item threshold was exceeded.
For more about the 
Earley item warning threshold,
see \*(L"too_many_earley_items\*(R".
No event value is defined for this event.
This event is enabled by default.
.SS "\s-1EXHAUSTED\s0"
.IX Subsection "EXHAUSTED"
\&\*(L"Exhaustion\*(R"
means that the next \f(CW\*(C`read\*(C'\fR call must fail,
because there is no token that will be acceptable to it.
More details on \*(L"exhaustion\*(R" are in a
section below.
No event value is defined for this event.
This event is enabled by default.
.SS "\s-1SYMBOL_EXPECTED\s0"
.IX Subsection "SYMBOL_EXPECTED"
A \*(L"symbol expected\*(R" event means that a symbol is expected
at that point.
The event value of this event is the symbol
whose expectation caused the event.
This event is disabled by default.
For details, see \*(L"\fBexpected_symbol_event_set()\fR\*(R".
.SH "Parse exhaustion"
.IX Header "Parse exhaustion"
A parse is \fBexhausted\fR when it will accept no more input.
An \fBexhausted\fR parse is not necessarily a failed parse.
Grammars are often written so that once they \*(L"find what
they are looking for\*(R", no further input is acceptable.
Grammars of that kind become exhausted when they succeed.
.PP
By default,
a recognizer event occurs whenever the parse is
exhausted.
An application can also check for exhaustion
explicitly, using the recognizer's
\&\f(CW\*(C`exhausted\*(C'\fR method.
.SH "Ruby Slippers parsing"
.IX Header "Ruby Slippers parsing"
.Vb 1
\&    $recce = Marpa::R2::Recognizer\->new( { grammar => $grammar } );
\&
\&    my @tokens = (
\&        [ \*(AqNumber\*(Aq, 42 ],
\&        [\*(AqMultiply\*(Aq], [ \*(AqNumber\*(Aq, 1 ],
\&        [\*(AqAdd\*(Aq],      [ \*(AqNumber\*(Aq, 7 ],
\&    );
\&
\&    TOKEN: for ( my $token_ix = 0; $token_ix <= $#tokens; $token_ix++ ) {
\&        defined $recce\->read( @{ $tokens[$token_ix] } )
\&            or fix_things( $recce, $token_ix, \e@tokens )
\&            or die q{Don\*(Aqt know how to fix things};
\&    }
.Ve
.PP
Marpa is able to tell the application
which symbols are acceptable as tokens at the next location
in the parse.
The \f(CW\*(C`terminals_expected\*(C'\fR method
returns the list of tokens that \fBwill\fR be accepted by
the next \f(CW\*(C`read\*(C'\fR.
The application can use this information to change the
input \*(L"on the fly\*(R"
so that it is acceptable to the parser.
.PP
An application can also take a \*(L"try it and see\*(R"
approach.
If an application is not sure whether a token is
acceptable or not, the application can
try to read the dubious token using
the \f(CW\*(C`read\*(C'\fR method.
If the token is rejected,
the \f(CW\*(C`read\*(C'\fR method call will return a
Perl \f(CW\*(C`undef\*(C'\fR.
At that point,
the application can retry the \f(CW\*(C`read\*(C'\fR with a different token.
.SS "An example"
.IX Subsection "An example"
Marpa's \s-1HTML\s0 parser, Marpa::HTML, is
an example of how Ruby Slippers parsing can help
with a non-trivial, real-life application.
When a token is rejected in Marpa::HTML, it changes
the input to match
the parser's expectations by
.IP "\(bu" 4
Modifying existing tokens, and
.IP "\(bu" 4
Creating new tokens.
.PP
The second technique, the creation of
new \*(L"virtual\*(R" tokens,
is used
by Marpa::HTML
to deal with omitted start and end tags.
The actual \s-1HTML\s0 grammar that
Marpa::HTML uses takes
an oversimplified view of the \s-1HTML\s0 \*(--
it assumes,
even when the \s-1HTML\s0 standards do not require it,
that start and end tags are always present.
For most \s-1HTML\s0 files of interest,
this assumption will be
contrary to fact.
.PP
Ruby Slippers parsing is used to make the grammar's
over-simplistic view of the world come true for it.
Whenever a token is rejected,
Marpa::HTML looks at the expected tokens list.
If it sees that a start or end tag is expected,
Marpa::HTML creates a token for it \*(--
a completely new \*(L"virtual\*(R" token that gives the parser exactly what it expects.
Marpa::HTML then resumes input at the point in the original input stream
where it left off.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
