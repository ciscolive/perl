.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tie::Simple 3"
.TH Tie::Simple 3 "2015-11-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Simple \- Variable ties made easier: much, much, much easier...
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Tie::Simple;
\&
\&  tie $scalar, \*(AqTie::Simple\*(Aq, $data,
\&      FETCH     => sub { ... },
\&      STORE     => sub { ... };
\&
\&  tie @array, \*(AqTie::Simple\*(Aq, $data,
\&      FETCH     => sub { ... },
\&      STORE     => sub { ... },
\&      FETCHSIZE => sub { ... },
\&      STORESIZE => sub { ... },
\&      EXTEND    => sub { ... },
\&      EXISTS    => sub { ... },
\&      DELETE    => sub { ... },
\&      CLEAR     => sub { ... },
\&      PUSH      => sub { ... },
\&      POP       => sub { ... },
\&      SHIFT     => sub { ... },
\&      UNSHIFT   => sub { ... },
\&      SPLICE    => sub { ... };
\&
\&  tie %hash, \*(AqTie::Simple\*(Aq, $data,
\&      FETCH     => sub { ... },
\&      STORE     => sub { ... },
\&      DELETE    => sub { ... },
\&      CLEAR     => sub { ... },
\&      EXISTS    => sub { ... },
\&      FIRSTKEY  => sub { ... },
\&      NEXTKEY   => sub { ... };
\&
\&  tie *HANDLE, \*(AqTie::Simple\*(Aq, $data,
\&      WRITE     => sub { ... },
\&      PRINT     => sub { ... },
\&      PRINTF    => sub { ... },
\&      READ      => sub { ... },
\&      READLINE  => sub { ... },
\&      GETC      => sub { ... },
\&      CLOSE     => sub { ... };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module adds the ability to quickly create new types of tie objects without
creating a complete class. It does so in such a way as to try and make the
programmers life easier when it comes to single-use ties that I find myself
wanting to use from time-to-time.
.PP
The \f(CW\*(C`Tie::Simple\*(C'\fR package is actually a front-end to other classes which
really do all the work once tied, but this package does the dwimming to
automatically figure out what you're trying to do.
.PP
I've tried to make this as intuitive as possible and dependent on other bits of
Perl where I can to minimize the need for documentation and to make this extra,
extra spiffy.
.SH "SIMPLE TYING"
.IX Header "SIMPLE TYING"
To setup your quick tie, simply start with the typical tie statement on the
variable you're tying. You should always tie to the \f(CW\*(C`Tie::Simple\*(C'\fR package and
not directly to the other packages included with this module as those are only
present as helpers (even though they are really the tie classes).
.PP
The type of tie depends upon the type of the first argument given to tie. This
should be rather obvious from the \*(L"\s-1SYNOPSIS\*(R"\s0 above. Therefore, the arguments
are:
.IP "1." 4
The variable to be tied.
.IP "2." 4
The string \f(CW\*(AqTie::Simple\*(Aq\fR.
.IP "3." 4
A scalar value (hereafter called the \*(L"local data\*(R").
.IP "4." 4
A list of name/CODE pairs.
.PP
At this point, you'll need to have some understanding of tying before you can
continue. I suggest looking through perltie.
.PP
As you will note in the perltie documentation, every tie package defines
functions whose first argument is called \f(CW\*(C`this\*(C'\fR. The third argument,
local data, will take the place of \f(CW\*(C`this\*(C'\fR in all the subroutine calls you
define in the name/CODE pair list. Each name should be the name of the function
that would be defined for the appropriate tie-type if you were to do a
full-blown package definition. The subroutine matched to that name will take
the exact arguments specified in the perltie documentation, but instead of
\&\f(CW\*(C`this\*(C'\fR it will be given the local data scalar value you set (which could even
be \f(CW\*(C`undef\*(C'\fR if you don't need it).
.SH "TIES CAN BE SIMPLER STILL"
.IX Header "TIES CAN BE SIMPLER STILL"
The synopsis above shows the typical subroutines you could define. (I left out
the \f(CW\*(C`UNTIE\*(C'\fR and \f(CW\*(C`DESTROY\*(C'\fR methods, but you may define these if you need them,
but be sure to read the perltie documentation on possible caveats.) However,
the \*(L"\s-1SYNOPSIS\*(R"\s0 is way more complete then you probably need to be in most
cases. This is because \f(CW\*(C`Tie::Simple\*(C'\fR does it's best to make use of some of
the handy Perl built-ins which help with creating tie packages.
.SS "\s-1SCALARS\s0"
.IX Subsection "SCALARS"
If you are creating a scalar tie, then you can assume all the benefits of being
a Tie::Scalar.
.SS "\s-1ARRAYS\s0"
.IX Subsection "ARRAYS"
If you are creating an array tie, then you may assume all the benefits of being
a Tie::Array.
.SS "\s-1HASHES\s0"
.IX Subsection "HASHES"
If you are creating a hash tie, then you may assume all the benefits of being a
Tie::Hash.
.SS "\s-1HANDLES\s0"
.IX Subsection "HANDLES"
If you are creating a handle tie, then you may assume all the benefits of being
a Tie::Handle.
.SH "TO DO"
.IX Header "TO DO"
It sure would be nice if you could declare custom \f(CW@ISA\fR lists, wouldn't it?
I'd like to add such a feature, but coming up with some custom \f(CW\*(C`SUPER::\*(C'\fR
dispatch code or generating new \*(L"anonymous\*(R" packages are the only ways I can
think to do it. I don't really have time to add such a feature just now.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perltie, Tie::Scalar, Tie::Array, Tie::Hash, Tie::Handle
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Sterling Hanenkamp <hanenkamp@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Qubling Software \s-1LLC.\s0
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
