.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Imager::Matrix2d 3"
.TH Imager::Matrix2d 3 "2020-06-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Imager::Matrix2d \- simple wrapper for matrix construction
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Imager::Matrix2d;
\&  $m1 = Imager::Matrix2d\->identity;
\&  $m2 = Imager::Matrix2d\->rotate(radians=>$angle, x=>$cx, y=>$cy);
\&  $m3 = Imager::Matrix2d\->translate(x=>$dx, y=>$dy);
\&  $m4 = Imager::Matrix2d\->shear(x=>$sx, y=>$sy);
\&  $m5 = Imager::Matrix2d\->reflect(axis=>$axis);
\&  $m6 = Imager::Matrix2d\->scale(x=>$xratio, y=>$yratio);
\&  $m8 = Imager::Matric2d\->matrix($v11, $v12, $v13,
\&                                 $v21, $v22, $v23,
\&                                 $v31, $v32, $v33);
\&  $m6 = $m1 * $m2;
\&  $m7 = $m1 + $m2;
\&  use Imager::Matrix2d qw(:handy);
\&  # various m2d_* functions imported 
\&  # where m2d_(.*) calls Imager::Matrix2d\->$1()
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides a simple wrapper around a reference to an array of
9 coefficients, treated as a matrix:
.PP
.Vb 3
\& [ 0, 1, 2,
\&   3, 4, 5,
\&   6, 7, 8 ]
.Ve
.PP
Most of the methods in this class are constructors.  The others are
overloaded operators.
.PP
Note that since Imager represents images with y increasing from top to
bottom, rotation angles are clockwise, rather than counter-clockwise.
.IP "\fBidentity()\fR" 4
.IX Item "identity()"
Returns the identity matrix.
.IP "rotate(radians=>$angle)" 4
.IX Item "rotate(radians=>$angle)"
.PD 0
.IP "rotate(degrees=>$angle)" 4
.IX Item "rotate(degrees=>$angle)"
.PD
Creates a matrix that rotates around the origin, or around the point
(x,y) if the 'x' and 'y' parameters are provided.
.IP "translate(x=>$dx, y=>$dy)" 4
.IX Item "translate(x=>$dx, y=>$dy)"
.PD 0
.IP "translate(x=>$dx)" 4
.IX Item "translate(x=>$dx)"
.IP "translate(y=>$dy)" 4
.IX Item "translate(y=>$dy)"
.PD
Translates by the specify amounts.
.IP "shear(x=>$sx, y=>$sy)" 4
.IX Item "shear(x=>$sx, y=>$sy)"
.PD 0
.IP "shear(x=>$sx)" 4
.IX Item "shear(x=>$sx)"
.IP "shear(y=>$sy)" 4
.IX Item "shear(y=>$sy)"
.PD
Shear by the given amounts.
.IP "reflect(axis=>$axis)" 4
.IX Item "reflect(axis=>$axis)"
Reflect around the given axis, either 'x' or 'y'.
.IP "reflect(radians=>$angle)" 4
.IX Item "reflect(radians=>$angle)"
.PD 0
.IP "reflect(degrees=>$angle)" 4
.IX Item "reflect(degrees=>$angle)"
.PD
Reflect around a line drawn at the given angle from the origin.
.IP "scale(x=>$xratio, y=>$yratio)" 4
.IX Item "scale(x=>$xratio, y=>$yratio)"
Scales at the given ratios.
.Sp
You can also specify a center for the scaling with the \f(CW\*(C`cx\*(C'\fR and \f(CW\*(C`cy\*(C'\fR
parameters.
.ie n .IP "matrix($v11, $v12, $v13, $v21, $v22, $v23, $v31, $v32, $v33)" 4
.el .IP "matrix($v11, \f(CW$v12\fR, \f(CW$v13\fR, \f(CW$v21\fR, \f(CW$v22\fR, \f(CW$v23\fR, \f(CW$v31\fR, \f(CW$v32\fR, \f(CW$v33\fR)" 4
.IX Item "matrix($v11, $v12, $v13, $v21, $v22, $v23, $v31, $v32, $v33)"
Create a matrix with custom coefficients.
.ie n .IP "transform($x, $y)" 4
.el .IP "transform($x, \f(CW$y\fR)" 4
.IX Item "transform($x, $y)"
Transform a point the same way matrix_transform does.
.IP "compose(matrix...)" 4
.IX Item "compose(matrix...)"
Compose several matrices together for use in transformation.
.Sp
For example, for three matrices:
.Sp
.Vb 1
\&  my $out = Imager::Matrix2d\->compose($m1, $m2, $m3);
.Ve
.Sp
is equivalent to:
.Sp
.Vb 1
\&  my $out = $m3 * $m2 * $m1;
.Ve
.Sp
Returns the identity matrix if no parameters are supplied.
.Sp
May return the supplied matrix if only one matrix is supplied.
.IP "\fB_mult()\fR" 4
.IX Item "_mult()"
Implements the overloaded '*' operator.  Internal use.
.Sp
Currently both the left and right-hand sides of the operator must be
an Imager::Matrix2d.
.Sp
When composing a matrix for transformation you should multiply the
matrices in the reverse order of the transformations:
.Sp
.Vb 3
\&  my $shear = Imager::Matrix2d\->shear(x => 0.1);
\&  my $rotate = Imager::Matrix2d\->rotate(degrees => 45);
\&  my $shear_then_rotate = $rotate * $shear;
.Ve
.Sp
or use the compose method:
.Sp
.Vb 1
\&  my $shear_then_rotate = Imager::Matrix2d\->compose($shear, $rotate);
.Ve
.IP "\fB_add()\fR" 4
.IX Item "_add()"
Implements the overloaded binary '+' operator.
.Sp
Currently both the left and right sides of the operator must be
Imager::Matrix2d objects.
.IP "\fB_string()\fR" 4
.IX Item "_string()"
Implements the overloaded stringification operator.
.Sp
This returns a string containing 3 lines of text with no terminating
newline.
.Sp
I tried to make it fairly nicely formatted.  You might disagree :)
.IP "_eq" 4
.IX Item "_eq"
Implement the overloaded equality operator.
.Sp
Provided for older perls that don't handle magic auto generation of eq
from "".
.PP
The following functions are shortcuts to the various constructors.
.PP
These are not methods.
.PP
You can import these methods with:
.PP
.Vb 1
\&  use Imager::Matrix2d \*(Aq:handy\*(Aq;
.Ve
.IP "m2d_identity" 4
.IX Item "m2d_identity"
.PD 0
.IP "\fBm2d_rotate()\fR" 4
.IX Item "m2d_rotate()"
.IP "\fBm2d_translate()\fR" 4
.IX Item "m2d_translate()"
.IP "\fBm2d_shear()\fR" 4
.IX Item "m2d_shear()"
.IP "\fBm2d_reflect()\fR" 4
.IX Item "m2d_reflect()"
.IP "\fBm2d_scale()\fR" 4
.IX Item "m2d_scale()"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tony@develop\-help.com>
.SH "BUGS"
.IX Header "BUGS"
Needs a way to invert a matrix.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBImager\fR\|(3), \fBImager::Font\fR\|(3)
.PP
http://imager.perl.org/
