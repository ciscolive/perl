.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object::Cli 3"
.TH Data::Object::Cli 3 "2020-05-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object::Cli \- Simple CLIs
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Command-line Interface Abstraction for Perl 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Command;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub main {
\&    my ($self) = @_;
\&
\&    return $self\->help;
\&  }
\&
\&  my $command = run Command;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides an abstract base class for defining command-line
interface classes, which can be run as scripts or passed as objects in a more
complex system.
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Data::Object::Types
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
This package has the following attributes:
.SS "args"
.IX Subsection "args"
.Vb 1
\&  args(ArgsObject)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(ArgsObject)\*(C'\fR values, and is optional.
.SS "data"
.IX Subsection "data"
.Vb 1
\&  data(DataObject)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(DataObject)\*(C'\fR values, and is optional.
.SS "opts"
.IX Subsection "opts"
.Vb 1
\&  opts(OptsObject)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(OptsObject)\*(C'\fR values, and is optional.
.SS "vars"
.IX Subsection "vars"
.Vb 1
\&  vars(VarsObject)
.Ve
.PP
This attribute is read-only, accepts \f(CW\*(C`(VarsObject)\*(C'\fR values, and is optional.
.SH "METHODS"
.IX Header "METHODS"
This package implements the following methods:
.SS "auto"
.IX Subsection "auto"
.Vb 1
\&  auto(Any %args) : HashRef
.Ve
.PP
The auto method is expected to be overridden by the subclass and should return
a hashref where the keys represent a subcommand at \f(CW$ARGV[0]\fR and the value
represents the subroutine to be dispatched to using the \f(CW\*(C`handle\*(C'\fR method. To
enable this functionality, the command name be declare a \*(L"command\*(R" token.
.IP "auto example #1" 4
.IX Item "auto example #1"
.Vb 1
\&  package Todo;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  our $name = \*(Aqtodo <{command}>\*(Aq;
\&
\&  sub auto {
\&    {
\&      init => \*(Aq_handle_init\*(Aq
\&    }
\&  }
\&
\&  sub _handle_init {
\&    1234567890
\&  }
\&
\&  my $todo = run Todo;
.Ve
.SS "exit"
.IX Subsection "exit"
.Vb 1
\&  exit(Int $code, Maybe[Str] $name, Any %args) : Any
.Ve
.PP
The exit method exits the program using the exit code provided. The exit code
defaults to \f(CW0\fR. Optionally, you can call a handler before exiting by
providing a method name with arguments. The handler will be called using the
\&\f(CW\*(C`handle\*(C'\fR method so the arguments should be key/value pairs.
.IP "exit example #1" 4
.IX Item "exit example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $command\->exit(0);
\&
\&  # $command\->exit($code, $method_name, %args);
\&  # $command\->exit($code, $method_name);
\&  # $command\->exit($code);
.Ve
.IP "exit example #2" 4
.IX Item "exit example #2"
.Vb 1
\&  # given: synopsis
\&
\&  $command\->exit(1);
\&
\&  # $command\->exit($code, $method_name, %args);
\&  # $command\->exit($code, $method_name);
\&  # $command\->exit($code);
.Ve
.SS "fail"
.IX Subsection "fail"
.Vb 1
\&  fail(Maybe[Str] $name, Any %args) : Any
.Ve
.PP
The fail method exits the program with a \f(CW1\fR exit code. Optionally, you can
call a handler before exiting by providing a method name with arguments. The
handler will be called using the \f(CW\*(C`handle\*(C'\fR method so the arguments should be
key/value pairs.
.IP "fail example #1" 4
.IX Item "fail example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $command\->fail;
\&
\&  # $command\->fail($method_name, %args);
\&  # $command\->fail($method_name);
.Ve
.SS "handle"
.IX Subsection "handle"
.Vb 1
\&  handle(Str $name, Any %args) : Any
.Ve
.PP
The handle method dispatches to the method whose name is provided as the first
argument. The forwarded method will receive arguments as key/value pairs. This
method injects the \f(CW\*(C`args\*(C'\fR, \f(CW\*(C`data\*(C'\fR, \f(CW\*(C`vars\*(C'\fR, and \f(CW\*(C`opts\*(C'\fR attributes as
arguments for convenience of use in the forwarded method. Any additional
arguments should be passed as key/value pairs.
.IP "handle example #1" 4
.IX Item "handle example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $command\->handle(\*(Aqmain\*(Aq);
\&
\&  # $command\->handle($method_name, %args);
\&  # $command\->handle($method_name);
.Ve
.SS "help"
.IX Subsection "help"
.Vb 1
\&  help() : Str
.Ve
.PP
The help method returns the help text documented in \s-1POD\s0 if available.
.IP "help example #1" 4
.IX Item "help example #1"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  my $todolist = run Todolist;
\&
\&  # $todolist\->help
.Ve
.IP "help example #2" 4
.IX Item "help example #2"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  our $name = \*(Aqtodolist\*(Aq;
\&
\&  my $todolist = run Todolist;
\&
\&  # $todolist\->help
.Ve
.IP "help example #3" 4
.IX Item "help example #3"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub name {
\&    \*(Aqtodolist\*(Aq
\&  }
\&
\&  my $todolist = run Todolist;
\&
\&  # $todolist\->help
.Ve
.IP "help example #4" 4
.IX Item "help example #4"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  our $name = \*(Aqtodolist\*(Aq;
\&  our $info = \*(Aqmanage your todo list\*(Aq;
\&
\&  my $todolist = run Todolist;
\&
\&  # $todolist\->help
.Ve
.IP "help example #5" 4
.IX Item "help example #5"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub name {
\&    \*(Aqtodolist\*(Aq
\&  }
\&
\&  sub info {
\&    \*(Aqmanage your todo list\*(Aq
\&  }
\&
\&  my $todolist = run Todolist;
\&
\&  # $todolist\->help
.Ve
.IP "help example #6" 4
.IX Item "help example #6"
.Vb 1
\&  package Todolist::Command::Show;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub name {
\&    \*(Aqtodolist show [<{priority}>]\*(Aq
\&  }
\&
\&  sub info {
\&    \*(Aqshow your todo list tasks by priority levels\*(Aq
\&  }
\&
\&  my $command = run Todolist::Command::Show;
\&
\&  # $command\->help
.Ve
.SS "main"
.IX Subsection "main"
.Vb 1
\&  main(Any %args) : Any
.Ve
.PP
The main method is the \*(L"main method\*(R" and entrypoint into the program. It's
called automatically by the \f(CW\*(C`run\*(C'\fR method if your package is configured as
recommended. This method accepts arguments as key/value pairs, and if called
by \f(CW\*(C`run\*(C'\fR will receive the \f(CW\*(C`args\*(C'\fR, \f(CW\*(C`data\*(C'\fR, \f(CW\*(C`opts\*(C'\fR, and \f(CW\*(C`vars\*(C'\fR objects.
.IP "main example #1" 4
.IX Item "main example #1"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub main {
\&    my ($self, %args) = @_;
\&
\&    return {%args} # no args
\&  }
\&
\&  my $todolist = run Todolist;
\&
\&  $todolist\->main;
.Ve
.IP "main example #2" 4
.IX Item "main example #2"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  sub main {
\&    my ($self, %args) = @_;
\&
\&    # has $args{args}
\&    # has $args{data}
\&    # has $args{opts}
\&    # has $args{vars}
\&
\&    return {%args}
\&  }
\&
\&  # $args{args} = $self\->args; # isa <Data::Object::Args>
\&  # represents @ARGV
\&
\&  # $args{data} = $self\->data; # isa <Data::Object::Data>
\&  # represents _\|_DATA_\|_
\&
\&  # $args{opts} = $self\->opts; # isa <Data::Object::Opts>
\&  # represents Getopt::Long
\&
\&  # $args{vars} = $self\->vars; # isa <Data::Object::Vars>
\&  # represents %ENV
\&
\&  my $todolist = run Todolist;
\&
\&  $todolist\->handle(\*(Aqmain\*(Aq); # called automatically by run
.Ve
.SS "okay"
.IX Subsection "okay"
.Vb 1
\&  okay(Maybe[Str] $name, Any %args) : Any
.Ve
.PP
The okay method exits the program with a \f(CW0\fR exit code. Optionally, you can
call a handler before exiting by providing a method name with arguments. The
handler will be called using the \f(CW\*(C`handle\*(C'\fR method so the arguments should be
key/value pairs.
.IP "okay example #1" 4
.IX Item "okay example #1"
.Vb 1
\&  # given: synopsis
\&
\&  $command\->okay;
\&
\&  # $command\->okay($method_name, %args);
\&  # $command\->okay($method_name);
.Ve
.SS "run"
.IX Subsection "run"
.Vb 1
\&  run() : Object
.Ve
.PP
The run method is designed to bootstrap the program. It detects whether the
package is being invoked as a script or class and behaves accordingly. It will
be called automatically when the package is looaded if your package is
configured as recommended. This method will, if invoked as a script, call the
main method passing the \f(CW\*(C`args\*(C'\fR, \f(CW\*(C`data\*(C'\fR, \f(CW\*(C`opts\*(C'\fR, and \f(CW\*(C`vars\*(C'\fR objects.
.IP "run example #1" 4
.IX Item "run example #1"
.Vb 1
\&  package Todolist;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  run Todolist;
.Ve
.SS "spec"
.IX Subsection "spec"
.Vb 1
\&  spec() : HashRef[HashRef]
.Ve
.PP
The spec method returns a hashref of flag definitions used to configure
Getopt::Long. These options are accessible as methods on the
Data::Object::Opts object through the \f(CW\*(C`opts\*(C'\fR attribute. Each flag
definition can optionally declare \f(CW\*(C`args\*(C'\fR, \f(CW\*(C`flag\*(C'\fR, and \f(CW\*(C`type\*(C'\fR values as
follows. The \f(CW\*(C`args\*(C'\fR property denotes that multiple flags are permitted and its
value can be any valid Getopt::Long \fIrepeat\fR specifier. The \f(CW\*(C`type\*(C'\fR
property denotes the type of data allowed and defaults to type \fIflag\fR.
Allowed values are \f(CW\*(C`string\*(C'\fR, \f(CW\*(C`integer\*(C'\fR, \f(CW\*(C`number\*(C'\fR, \f(CW\*(C`float\*(C'\fR, or \f(CW\*(C`flag\*(C'\fR. The
\&\f(CW\*(C`flag\*(C'\fR property denotes the flag aliases and should be a pipe-delimited
string, e.g. \f(CW\*(C`userid|id|u\*(C'\fR, if multiple aliases are used.
.IP "spec example #1" 4
.IX Item "spec example #1"
.Vb 1
\&  package Todolist::Task;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  our $name = \*(Aqtodotask {id}\*(Aq;
\&
\&  # id accessible as $self\->args\->id; alias of $ARGV[0]
\&
\&  sub spec {
\&    {
\&      #
\&      # represented in Getopt::Long as
\&      # title|t=s
\&      #
\&      # title is accessible as $self\->opts\->title
\&      #
\&      title => {
\&        type => \*(Aqstring\*(Aq,
\&        flag => \*(Aqt\*(Aq
\&      },
\&      #
\&      # represented in Getopt::Long as
\&      # content=s
\&      #
\&      # content is accessible as $self\->opts\->content
\&      #
\&      content => {
\&        type => \*(Aqstring\*(Aq,
\&      },
\&      #
\&      # represented in Getopt::Long as
\&      # attach|a=s@
\&      #
\&      # attach is accessible as $self\->opts\->attach
\&      #
\&      attach => {
\&        flag => \*(Aqa\*(Aq,
\&        args => \*(Aq@\*(Aq # allow multiple options
\&      },
\&      #
\&      # represented in Getopt::Long as
\&      # publish|p
\&      #
\&      # publish is accessible as $self\->opts\->publish
\&      #
\&      publish => {
\&        flag => \*(Aqp\*(Aq,
\&        type => \*(Aqflag\*(Aq
\&      },
\&      #
\&      # represented in Getopt::Long as
\&      # unpublish|u
\&      #
\&      # unpublish is accessible as $self\->opts\->unpublish
\&      #
\&      unpublish => {
\&        flag => \*(Aqu\*(Aq
\&        # defaults to type: flag
\&      }
\&    }
\&  }
\&
\&  my $todotask = run Todolist::Task;
\&
\&  # $todotask\->spec
.Ve
.SS "subs"
.IX Subsection "subs"
.Vb 1
\&  subs(Any %args) : HashRef
.Ve
.PP
The subs method works in tandem with the \*(L"auto\*(R" method and is expected to be
overridden by the subclass and should return a hashref where the keys represent
a subcommand at \f(CW$ARGV[0]\fR and the value represents the description of the
corresponding action (i.e. \fIcommand\fR).
.IP "subs example #1" 4
.IX Item "subs example #1"
.Vb 1
\&  package Todo::Admin;
\&
\&  use parent \*(AqData::Object::Cli\*(Aq;
\&
\&  our $name = \*(Aqtodo <action>\*(Aq;
\&
\&  sub auto {
\&    {
\&      add_user => \*(Aq_handle_add_user\*(Aq,
\&      del_user => \*(Aq_handle_del_user\*(Aq
\&    }
\&  }
\&
\&  sub subs {
\&    {
\&      add_user => \*(AqAdd a new user to the system\*(Aq,
\&      del_user => \*(AqRemove a user to the system\*(Aq
\&    }
\&  }
\&
\&  my $admin = run Todo::Admin;
\&
\&  _\|_DATA_\|_
\&
\&  Usage: {name}
\&
\&  Commands:
\&
\&  {commands}
\&
\&  Options:
\&
\&  {options}
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object-cli/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object-cli/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object-cli>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object-cli/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object-cli/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object-cli/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object-cli/issues>
