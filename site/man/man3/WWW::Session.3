.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::Session 3"
.TH WWW::Session 3 "2014-12-10" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::Session \- Generic session management engine for web applications
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Generic session management engine for web applications with multiple backends, 
object serialization and data validation
.SH "VERSION"
.IX Header "VERSION"
Version 0.12
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module allows you to easily create sessions , store data in them and later
retrieve that information, using multiple storage backends
.PP
Example:
.PP
.Vb 1
\&    use WWW::Session;
\&    
\&    #set up the storage backends                 
\&    WWW::Session\->add_storage( \*(AqFile\*(Aq, {path => \*(Aq/tmp/sessions\*(Aq} );
\&    WWW::Session\->add_storage( \*(AqMemcached\*(Aq, {servers => [\*(Aq127.0.0.1:11211\*(Aq]} );
\&    
\&    #Set up the serialization engine (defaults to JSON)
\&    WWW::Session\->serialization_engine(\*(AqJSON\*(Aq);
\&    
\&    #Set up the default expiration time (in seconds or \-1 for never)
\&    WWW::Session\->default_expiration_time(3600);
\&
\&    #Turn on autosave
\&    WWW::Session\->autosave(1);
\&    
\&    #and than ...
\&    
\&    #Create a new session
\&    my $session = WWW::Session\->new($sid,$hash_ref);
\&    ...
\&    $session\->sid(); #returns $sid
\&    $session\->data(); #returns $hash_ref
\&
\&    #set the user
\&    $session\->user($user);
\&    #retrieve the user
\&    my $user = $session\->user();
\&
\&    #returns undef if it doesn\*(Aqt exist or it\*(Aqs expired
\&    my $session = WWW::Session\->find($sid); 
\&    
\&    #returns the existing session if it exists, creates a new session if it doesn\*(Aqt
\&    my $session = WWW::Session\->find_or_create($sid);
.Ve
.PP
Using the session :
.IP "\(bu" 4
Settings values
.Sp
There are two ways you can save a value on the session :
.Sp
.Vb 1
\&    $session\->set(\*(Aquser\*(Aq,$user);
\&    
\&    or 
\&    
\&    $session\->user($user);
.Ve
.Sp
If the requested field (\*(L"user\*(R" in the example above) already exists it will be 
assigned the new value, if it doesn't it will be added.
.Sp
When you set a value for a field it will be validated first (see \fBsetup_field()\fR ). 
If the value doesn't pass validation the field will keep it's old value and the 
set method will return 0. If everything goes well the set method will return 1.
.IP "\(bu" 4
Retrieving values
.Sp
.Vb 1
\&    my $user = $session\->get(\*(Aquser\*(Aq);
\&    
\&    or
\&    
\&    my $user = $session\->user();
.Ve
.Sp
If the requested field (\*(L"user\*(R" in the example above) already exists it will return 
it's value, otherwise will return \f(CW\*(C`undef\*(C'\fR
.PP
We can automaticaly deflate/inflate certain informations when we store / retrieve
from storage the session data (see \fBsetup_field()\fR for more details):
.PP
.Vb 4
\&    WWW::Session\->setup_field( \*(Aquser\*(Aq,
\&                               inflate => sub { return Some::Package\->new( $_[0] ) },
\&                               deflate => sub { $_[0]\->id() }
\&                            );
.Ve
.PP
We can automaticaly validate certain informations when we store / retrieve
from storage the session data (see \fBsetup_field()\fR for more details):
.PP
.Vb 3
\&    WWW::Session\->setup_field( \*(Aqage\*(Aq,
\&                               filter => sub { $_[0] >= 18 }
\&                             );
.Ve
.PP
Another way to initialize the module :
.PP
.Vb 11
\&    use WWW::Session storage => [ \*(AqFile\*(Aq => { path => \*(Aq/tmp/sessions\*(Aq},
\&                                  \*(AqMemcached\*(Aq => { servers => [\*(Aq127.0.0.1\*(Aq] }
\&                                ],
\&                     serialization => \*(AqJSON\*(Aq,
\&                     expires => 3600,
\&                     fields => {
\&                               user => {
\&                                     inflate => sub { return Some::Package\->new( $_[0] ) },
\&                                     deflate => sub { $_[0]\->id() },
\&                                     }
\&                               };
.Ve
.SH "SESSION & OBJECTS"
.IX Header "SESSION & OBJECTS"
The default serialization engine is \s-1JSON,\s0 but \s-1JSON\s0 can't serialize objects by default,
you will have to write more code to accomplish that. If your session data data contains 
objects you can take one of the following approaches :
.IP "\(bu" 4
Use inflate/deflate (recommended)
.Sp
.Vb 1
\&    # if we have a user object (eg MyApp::User) we can deflate it like this
\&    
\&    WWW::Session\->setup_field(\*(Aquser\*(Aq, deflate => sub { return $_[0]\->id() } );
\&    
\&    #and inflate it back like this
\&    
\&    WWW::Session\->setup_field(\*(Aquser\*(Aq,inflate => sub { return Some::Package\->new( $_[0] ) } );
.Ve
.Sp
This method even thow it's slower, it reduces the size of the session object when stored, and 
it ensures that if the object data changed since we saved it, this changes will be reflected in the 
object when we retrieve restore it (usefull for database result objects)
.IP "\(bu" 4
Change the serialization module to 'Storable'
.Sp
The 'Storable' serialization engine can handle object without any additional changes
.Sp
.Vb 1
\&    WWW::Session\->serialization_engine(\*(AqStorable\*(Aq);
.Ve
.Sp
Note : The perl Storable module is not very compatible between different version, so sharing data 
between multiple machines could cause problems. We recommad using the '\s-1JSON\s0' engine with 
inflate/defate (described above);
.SH "STORAGE BACKENDS"
.IX Header "STORAGE BACKENDS"
You can use one or more of the fallowing backends (the list might not be complete, more backends might be available on \s-1CPAN\s0):
.SS "File storage"
.IX Subsection "File storage"
Here is how you can set up the File storage backend :
.PP
.Vb 1
\&    use WWW::Session;
\&
\&    WWW::Session\->add_storage(\*(AqFile\*(Aq, {path => \*(Aq.\*(Aq} );
.Ve
.PP
See WWW::Session::Storage::File for more details
.SS "Database storage"
.IX Subsection "Database storage"
If you want to store your session is MySQL do this :
.PP
.Vb 1
\&    use WWW::Session;
\&
\&    WWW::Session\->add_storage( \*(AqMySQL\*(Aq, { 
\&                                            dbh => $dbh,
\&                                            table => \*(Aqsessions\*(Aq,
\&                                            fields => {
\&                                                    sid => \*(Aqsession_id\*(Aq,
\&                                                    expires => \*(Aqexpires\*(Aq,
\&                                                    data => \*(Aqdata\*(Aq
\&                                            },
\&                                        }
\&                              );
.Ve
.PP
The \*(L"fields\*(R" hasref contains the mapping of session internal data to the column names from MySQL. 
The keys are the session fields (\*(L"sid\*(R",\*(L"expires\*(R" and \*(L"data\*(R") and must all be present.
.PP
The MySQL types of the columns should be :
.IP "\(bu" 4
sid => varchar(32)
.IP "\(bu" 4
expires => \s-1DATETIME\s0 or \s-1TIMESTAMP\s0
.IP "\(bu" 4
data => text
.PP
See WWW::Session::Storage::MySQL for more details
.SS "Memcached storage"
.IX Subsection "Memcached storage"
.Vb 1
\&    To use memcached as a storage backend do this :
\&
\&    use WWW::Session;
\&
\&    WWW::Session\->add_storage(\*(AqMemcached\*(Aq, {servers => [\*(Aq127.0.0.1:11211\*(Aq]} );
.Ve
.PP
See WWW::Session::Storage::Memcached for more details
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new"
.IX Subsection "new"
Creates a new session object with the unique identifier and the given data.
If a session with the same identifier previously existed it will be overwritten
.PP
Parameters
.IP "\(bu" 4
sid = unique id for this session
.IP "\(bu" 4
data = hash reference containing the data that we want to store in the session object
.IP "\(bu" 4
exipres = for how many secconds is this session valid (defaults to the default expiration time)
.PP
Retuns a WWW::Session object
.PP
Usage :
.PP
.Vb 1
\&    my $session = WWW::Session\->new(\*(Aqsession_id\*(Aq,{ a=> 1, b=> 2});
.Ve
.SS "find"
.IX Subsection "find"
Retieves the session object for the given session id
.PP
Usage :
.PP
.Vb 1
\&    my $session = WWW::Session\->find(\*(Aqsession_id\*(Aq);
.Ve
.SS "find_or_create"
.IX Subsection "find_or_create"
Retieves the session object for the given session id if it exists, if not it
creates a new object with the given session id
.IP "\(bu" 4
sid = unique id for this session
.IP "\(bu" 4
data = hash reference containing the data that we want to store in the session object
.IP "\(bu" 4
exipres = for how many secconds is this session valid (defaults to the default expiration time),
.PP
Usage:
.PP
.Vb 1
\&    my $session = WWW::Session\->find_or_create(\*(Aqsession_id\*(Aq,{ c=>2 })
.Ve
.SS "set"
.IX Subsection "set"
Adds/sets a new value for the given field
.PP
Usage :
.PP
.Vb 1
\&    $session\->set(\*(Aquser\*(Aq,$user);
.Ve
.PP
The values can also be set by calling the name of the field you want to set 
as a method :
.PP
.Vb 1
\&    $session\->user($user);
.Ve
.SS "get"
.IX Subsection "get"
Retrieves the value of the given key from the session object
.PP
Usage :
.PP
.Vb 1
\&    my $user = $session\->get(\*(Aquser\*(Aq);
.Ve
.PP
You can also use the name of the field you want to retrieve as a method.
The above call does the same as :
.PP
.Vb 1
\&    my $user = $session\->user();
.Ve
.SS "delete"
.IX Subsection "delete"
Removes the given key from the session data
.PP
Usage :
.PP
.Vb 1
\&    $session\->delete(\*(Aquser\*(Aq);
.Ve
.SS "sid"
.IX Subsection "sid"
Returns the session id associated with this session
.SS "expires"
.IX Subsection "expires"
Getter/Setter for the expiration time of this session
.SS "add_storage"
.IX Subsection "add_storage"
Adds a new storge engine to the list of Storage engines that will be used to
store the session info
.PP
Usage :
.PP
.Vb 1
\&    WWW::Session\->add_storage($storage_engine_name,$storage_engine_options);
.Ve
.PP
Parameters :
.IP "\(bu" 4
\&\f(CW$storage_engine_name\fR = Name of the class that defines a valid storage engine
.Sp
For WWW::Session::Storage::* modules you can use only the name of the storage,
you don't need the full name. eg Memcached and WWW::Session::Storage::Memcached
are synonyms
.IP "\(bu" 4
\&\f(CW$storage_engine_options\fR = hash ref containing the options that will be
passed on to the storage engine module when \fBnew()\fR is called
.PP
Example :
.PP
.Vb 1
\&    WWW::Session\->add_storage( \*(AqFile\*(Aq, {path => \*(Aq/tmp/sessions\*(Aq} );
\&    
\&    WWW::Session\->add_storage( \*(AqMemcached\*(Aq, {servers => [\*(Aq127.0.0.1:11211\*(Aq]} );
.Ve
.PP
See each storage module for aditional details
.SS "serialization_engine"
.IX Subsection "serialization_engine"
Configures the serialization engine to be used for serialising sessions.
.PP
The default serialization engine is \s-1JSON\s0
.PP
Usage :
.PP
.Vb 1
\&    WWW::Session\->serialization_engine(\*(AqJSON\*(Aq);
.Ve
.PP
Parameters :
.IP "\(bu" 4
\&\f(CW$serialization_engine_name\fR = Name of the class that defines a valid serialization engine
.Sp
For WWW::Session::Serialization::* modules you can use only the short name of the module,
you don't need the full name. eg \s-1JSON\s0 and WWW::Session::Serialization::JSON
are synonyms
.SS "autosave"
.IX Subsection "autosave"
Turn on/off the autosave feature (on by default)
.PP
If this feature is on the object will always be saved before beying destroyed
.PP
Usage :
.PP
.Vb 1
\&    WWW::Session\->autosave(1);
.Ve
.SS "default_expiration_time"
.IX Subsection "default_expiration_time"
Setter/Getter for the default expiration time
.PP
Usage :
.PP
.Vb 1
\&    WWW::Session\->default_expiration_time(1800);
.Ve
.SS "destroy"
.IX Subsection "destroy"
Completely removes all the data related to the current session
.PP
\&\s-1NOTE:\s0 After calling destroy the session object will no longer be usable
.PP
Usage :
.PP
.Vb 1
\&    $session\->destroy();
.Ve
.SS "setup_field"
.IX Subsection "setup_field"
Sets up the filters, inflators and deflators for the given field
.PP
\fIdeflators\fR
.IX Subsection "deflators"
.PP
Deflators are passed as code refs. The only argument the deflator
method receives is the value of the filed that it must be deflated and 
it must return a single value (scalar, object or reference) that will be 
asigned to the key.
.PP
Example :
.PP
.Vb 1
\&    # if we have a user object (eg MyApp::User) we can deflate it like this
\&    
\&    WWW::Session\->setup_field(\*(Aquser\*(Aq, deflate => sub { return $_[0]\->id() } );
.Ve
.PP
\fIinflators\fR
.IX Subsection "inflators"
.PP
Inflators are passed as code refs. The only argument the inflator 
method receives is the value of the filed that it must inflate and 
it must return a single value (scalar, object or reference) that will be 
asigned to the key.
.PP
Example :
.PP
.Vb 1
\&    # if we have a user object (eg MyApp::User) we can inflate it like this
\&
\&    WWW::Session\->setup_field(\*(Aquser\*(Aq,inflate => sub { return Some::Package\->new( $_[0] ) } );
.Ve
.PP
\fIfilters\fR
.IX Subsection "filters"
.PP
Filters can be used to ensure that the values from the session have the required values
.PP
Filters can be :
.IP "\(bu" 4
array ref
.Sp
In this case when we call \f(CW$session\fR\->set($field,$value) the values will have to be one of the 
values from the array ref , or the operation will fail
.Sp
Example :
.Sp
.Vb 2
\&    #Check that the age is between 18 and 99
\&    WWW::Session\->setup_field(\*(Aqage\*(Aq,filter => [18..99] );
.Ve
.IP "\(bu" 4
code ref
.Sp
In this case the field value will be passed to the code ref as the only parameter. The code ref
must return a true or false value. If it returns a false value the \fBset()\fR operation will fail
.Sp
Example :
.Sp
.Vb 2
\&    #Check that the age is > 18
\&    WWW::Session\->setup_field(\*(Aqage\*(Aq,filter => sub { $_[0] > 18 } );
.Ve
.IP "\(bu" 4
hash ref
.Sp
In this case the only key from the hash that is recognised is \*(L"isa\*(R" will will chek that the 
given value has the types specified as the value for \*(L"isa\*(R"
.Sp
Example :
.Sp
.Vb 2
\&    #Check that the \*(Aqrights\*(Aq field is an array
\&    WWW::Session\->setup_field(\*(Aqage\*(Aq,filter => { isa => "ARRAY" } );
\&    
\&    #Check that the \*(Aquser\*(Aq field is an MyApp::User object
\&    WWW::Session\->setup_field(\*(Aquser\*(Aq,filter => { isa => "MyApp::User" } );
.Ve
.PP
\fItriggers\fR
.IX Subsection "triggers"
.PP
Triggers allow you to execute a code ref when certain events happen on the key.
.PP
The return values from the triggers are completely ignored.
.PP
Available triggers are:
.IP "\(bu" 4
before_set_value
.Sp
Executed before the value is actually storred on the code. Arguments sent to the code ref 
are : session object , new value, old value \- in this order
.IP "\(bu" 4
after_set_value
.Sp
Executed after the new value is set on the session object. Arguments sent to the code ref 
are : session object, new value
.IP "\(bu" 4
before_delete
.Sp
Executed before the key is removed from the session object. Arguments sent to the code ref
are : session object, current_value
.IP "\(bu" 4
after_delete
.Sp
Executed after the key is removed from the session object. Arguments sent to the code ref
are : session object, previous_value
.PP
Example :
.PP
.Vb 9
\&    WWW::Session\->setup_field(
\&                            \*(Aquser\*(Aq,
\&                            filter => { isa => "MyApp::User" },
\&                            deflate => sub { $_[0]\->id() },
\&                            inflate => sub { return MyApp::User\->find($_[0]) }
\&                            trigger => { before_set_value => sub { warn "About to set the user },
\&                                         after_delete => sub { ... },
\&                                        }
\&                            );
.Ve
.SS "save"
.IX Subsection "save"
Serializes a WWW::Session object sends it to all storage engines for saving
.SH "ACCESSING SESSION DATA"
.IX Header "ACCESSING SESSION DATA"
Allows us to get/set session data directly by calling the field name as a method
.PP
Example:
.PP
.Vb 1
\&    my $user = $session\->user(); #same as $user = $session\->get(\*(Aquser\*(Aq);
\&    
\&    #or 
\&    
\&    $session\->age(21); #same as $session\->set(\*(Aqage\*(Aq,21);
.Ve
.SH "AUTOSAVE FEATURE"
.IX Header "AUTOSAVE FEATURE"
If you set autosave to 1 the session will be saved before the object is 
destroyed if any data has changed
.PP
\&\s-1BE CAREFULL :\s0 If you store complex structures only the changes made to direct 
session keys will be detected.
.PP
Example :
.PP
.Vb 2
\&    #this change will be detected because it affects a direct session attribute
\&    $session\->age(21); 
\&
\&    #this changes won\*(Aqt be detected :
\&    my $user = $session\->user();
\&    $user\->{age} = 21;
.Ve
.PP
You have two choices :
.IP "1 Make a change that can be detected" 4
.IX Item "1 Make a change that can be detected"
.Vb 1
\&    $session\->some_random_field( time() );
.Ve
.IP "2 Save the session manually" 4
.IX Item "2 Save the session manually"
.Vb 1
\&    $session\->save();
.Ve
.SH "PRIVATE METHODS"
.IX Header "PRIVATE METHODS"
.SS "load"
.IX Subsection "load"
Deserializes a WWW::Session object from the given string and deflates all the fields that
were inflated when the session was serialized
.SS "import"
.IX Subsection "import"
Allows us to configure all the module options in one line
.PP
Example :
.PP
.Vb 10
\&    use WWW::Session storage => [ 
\&                                    \*(AqFile\*(Aq => { path => \*(Aq/tmp/sessions\*(Aq},
\&                                    \*(AqMemcached\*(Aq => { servers => [\*(Aq127.0.0.1\*(Aq] }
\&                                ],
\&                     serialization => \*(AqStorable\*(Aq,
\&                     expires => 3600,
\&                     fields => {
\&                         user => {
\&                             inflate => sub { return Some::Package\->new( $_[0]\->id() ) },
\&                             deflate => sub { $_[0]\->id() },
\&                             },
\&                         age => {
\&                             filter => [21..99],
\&                             }
\&                     },
\&                     autosave => 1;
.Ve
.SS "run_trigger"
.IX Subsection "run_trigger"
Runs a trigger for the given field
.SH "TIE INTERFACE"
.IX Header "TIE INTERFACE"
The WWW::Session objects can be tied to hashes to make them easier to use
.PP
Example :
.PP
.Vb 1
\&    my %session;
\&    
\&    tie %session, WWW::Session, \*(Aqsession_id\*(Aq, {user => $user, authenticated => 1};
\&    
\&    ...
\&    my $user = $session{user};
\&
\&    ...
\&    $session{authenticated} = 0;
\&    delete $session{user};
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Gligan Calin Horea, \f(CW\*(C`<gliganh at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-www\-session at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=WWW\-Session>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc WWW::Session
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW\-Session>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/WWW\-Session>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/WWW\-Session>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/WWW\-Session/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 Gligan Calin Horea.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
