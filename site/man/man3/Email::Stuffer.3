.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Email::Stuffer 3"
.TH Email::Stuffer 3 "2020-07-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::Stuffer \- A more casual approach to creating and sending Email:: emails
.SH "VERSION"
.IX Header "VERSION"
version 0.018
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # Prepare the message
\&  my $body = <<\*(AqAMBUSH_READY\*(Aq;
\&  Dear Santa
\&
\&  I have killed Bun Bun.
\&
\&  Yes, I know what you are thinking... but it was actually a total accident.
\&
\&  I was in a crowded line at a BayWatch signing, and I tripped, and stood on
\&  his head.
\&
\&  I know. Oops! :/
\&
\&  So anyways, I am willing to sell you the body for $1 million dollars.
\&
\&  Be near the pinhole to the Dimension of Pain at midnight.
\&
\&  Alias
\&
\&  AMBUSH_READY
\&
\&  # Create and send the email in one shot
\&  Email::Stuffer\->from     (\*(Aqcpan@ali.as\*(Aq             )
\&                \->to       (\*(Aqsanta@northpole.org\*(Aq     )
\&                \->bcc      (\*(Aqbunbun@sluggy.com\*(Aq       )
\&                \->text_body($body                     )
\&                \->attach_file(\*(Aqdead_bunbun_faked.gif\*(Aq )
\&                \->send;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBThe basics should all work, but this module is still subject to
name and/or \s-1API\s0 changes\fR
.PP
Email::Stuffer, as its name suggests, is a fairly casual module used
to stuff things into an email and send them. It is a high-level module
designed for ease of use when doing a very specific common task, but
implemented on top of the light and tolerable Email:: modules.
.PP
Email::Stuffer is typically used to build emails and send them in a single
statement, as seen in the synopsis. And it is certain only for use when
creating and sending emails. As such, it contains no email parsing
capability, and little to no modification support.
.PP
To re-iterate, this is very much a module for those \*(L"slap it together and
fire it off\*(R" situations, but that still has enough grunt behind the scenes
to do things properly.
.SS "Default Transport"
.IX Subsection "Default Transport"
Although it cannot be relied upon to work, the default behaviour is to
use \f(CW\*(C`sendmail\*(C'\fR to send mail, if you don't provide the mail send channel
with either the \f(CW\*(C`transport\*(C'\fR method, or as an argument to \f(CW\*(C`send\*(C'\fR.
.PP
(Actually, the choice of default is delegated to
Email::Sender::Simple, which makes its own choices.  But usually, it
uses \f(CW\*(C`sendmail\*(C'\fR.)
.SS "Why use this?"
.IX Subsection "Why use this?"
Why not just use Email::Simple or Email::MIME? After all, this just adds
another layer of stuff around those. Wouldn't using them directly be better?
.PP
Certainly, if you know \s-1EXACTLY\s0 what you are doing. The docs are clear enough,
but you really do need to have an understanding of the structure of \s-1MIME\s0
emails. This structure is going to be different depending on whether you have
text body, \s-1HTML,\s0 both, with or without an attachment etc.
.PP
Then there's brevity... compare the following roughly equivalent code.
.PP
First, the Email::Stuffer way.
.PP
.Vb 5
\&  Email::Stuffer\->to(\*(AqSimon Cozens<simon@somewhere.jp>\*(Aq)
\&                \->from(\*(AqSanta@northpole.org\*(Aq)
\&                \->text_body("You\*(Aqve been good this year. No coal for you.")
\&                \->attach_file(\*(Aqchoochoo.gif\*(Aq)
\&                \->send;
.Ve
.PP
And now doing it directly with a knowledge of what your attachment is, and
what the correct \s-1MIME\s0 structure is.
.PP
.Vb 3
\&  use Email::MIME;
\&  use Email::Sender::Simple;
\&  use IO::All;
\&
\&  Email::Sender::Simple\->try_to_send(
\&    Email::MIME\->create(
\&      header => [
\&          To => \*(Aqsimon@somewhere.jp\*(Aq,
\&          From => \*(Aqsanta@northpole.org\*(Aq,
\&      ],
\&      parts => [
\&          Email::MIME\->create(
\&            body => "You\*(Aqve been a good boy this year. No coal for you."
\&          ),
\&          Email::MIME\->create(
\&            body => io(\*(Aqchoochoo.gif\*(Aq),
\&            attributes => {
\&                filename => \*(Aqchoochoo.gif\*(Aq,
\&                content_type => \*(Aqimage/gif\*(Aq,
\&            },
\&         ),
\&      ],
\&    );
\&  );
.Ve
.PP
Again, if you know \s-1MIME\s0 well, and have the patience to manually code up
the Email::MIME structure, go do that, if you really want to.
.PP
Email::Stuffer as the name suggests, solves one case and one case only:
generate some stuff, and email it to somewhere, as conveniently as
possible. \s-1DWIM,\s0 but do it as thinly as possible and use the solid
Email:: modules underneath.
.SH "METHODS"
.IX Header "METHODS"
As you can see from the synopsis, all methods that \fBmodify\fR the
Email::Stuffer object returns the object, and thus most normal calls are
chainable.
.PP
However, please note that \f(CW\*(C`send\*(C'\fR, and the group of methods that do not
change the Email::Stuffer object \fBdo not\fR return the object, and thus
\&\fBare not\fR chainable.
.SS "new"
.IX Subsection "new"
Creates a new, empty, Email::Stuffer object.
.PP
You can pass a hashref of properties to set, including:
.IP "\(bu" 4
to
.IP "\(bu" 4
from
.IP "\(bu" 4
cc
.IP "\(bu" 4
bcc
.IP "\(bu" 4
reply_to
.IP "\(bu" 4
subject
.IP "\(bu" 4
text_body
.IP "\(bu" 4
html_body
.IP "\(bu" 4
transport
.PP
The to, cc, bcc, and reply_to headers properties may be provided as array
references.  The array's contents will be used as the list of arguments to the
setter.
.SS "header_names"
.IX Subsection "header_names"
Returns, as a list, all of the headers currently set for the Email
For backwards compatibility, this method can also be called as B[headers].
.SS "parts"
.IX Subsection "parts"
Returns, as a list, the Email::MIME parts for the Email
.ie n .SS "header $header => $value"
.el .SS "header \f(CW$header\fP => \f(CW$value\fP"
.IX Subsection "header $header => $value"
Sets a named header in the email. Multiple calls with the same \f(CW$header\fR
will overwrite previous calls \f(CW$value\fR.
.ie n .SS "to @addresses"
.el .SS "to \f(CW@addresses\fP"
.IX Subsection "to @addresses"
Sets the To: header in the email
.ie n .SS "from $address"
.el .SS "from \f(CW$address\fP"
.IX Subsection "from $address"
Sets the From: header in the email
.ie n .SS "reply_to $address"
.el .SS "reply_to \f(CW$address\fP"
.IX Subsection "reply_to $address"
Sets the Reply-To: header in the email
.ie n .SS "cc @addresses"
.el .SS "cc \f(CW@addresses\fP"
.IX Subsection "cc @addresses"
Sets the Cc: header in the email
.ie n .SS "bcc @addresses"
.el .SS "bcc \f(CW@addresses\fP"
.IX Subsection "bcc @addresses"
Sets the Bcc: header in the email
.ie n .SS "subject $text"
.el .SS "subject \f(CW$text\fP"
.IX Subsection "subject $text"
Sets the Subject: header in the email
.ie n .SS "text_body $body [, $attribute => $value, ... ]"
.el .SS "text_body \f(CW$body\fP [, \f(CW$attribute\fP => \f(CW$value\fP, ... ]"
.IX Subsection "text_body $body [, $attribute => $value, ... ]"
Sets the text body of the email. Appropriate headers are set for you.
You may override \s-1MIME\s0 attributes as needed. See the \f(CW\*(C`attributes\*(C'\fR
parameter to \*(L"create\*(R" in Email::MIME for the headers you can set.
.PP
If \f(CW$body\fR is undefined, this method will do nothing.
.PP
Prior to Email::Stuffer version 0.015 text body was marked as flowed,
which broke all pre-formated body text.  Empty space at the beggining
of the line was dropped and every new line character could be changed
to one space (and vice versa).  Version 0.015 (and later) does not set
flowed format automatically anymore and so text body is really plain
text.  If you want to use old behavior of \*(L"advanced\*(R" flowed formatting,
set flowed format manually by: \f(CW\*(C`text_body($body, format => \*(Aqflowed\*(Aq)\*(C'\fR.
.ie n .SS "html_body $body [, $header => $value, ... ]"
.el .SS "html_body \f(CW$body\fP [, \f(CW$header\fP => \f(CW$value\fP, ... ]"
.IX Subsection "html_body $body [, $header => $value, ... ]"
Sets the \s-1HTML\s0 body of the email. Appropriate headers are set for you.
You may override \s-1MIME\s0 attributes as needed. See the \f(CW\*(C`attributes\*(C'\fR
parameter to \*(L"create\*(R" in Email::MIME for the headers you can set.
.PP
If \f(CW$body\fR is undefined, this method will do nothing.
.ie n .SS "attach $contents [, $attribute => $value, ... ]"
.el .SS "attach \f(CW$contents\fP [, \f(CW$attribute\fP => \f(CW$value\fP, ... ]"
.IX Subsection "attach $contents [, $attribute => $value, ... ]"
Adds an attachment to the email. The first argument is the file contents
followed by (as for text_body and html_body) the list of headers to use.
Email::Stuffer will \fItry\fR to guess the headers correctly, but you may wish
to provide them anyway to be sure. Encoding is Base64 by default. See
the \f(CW\*(C`attributes\*(C'\fR parameter to \*(L"create\*(R" in Email::MIME for the headers you
can set.
.ie n .SS "attach_file $file [, $attribute => $value, ... ]"
.el .SS "attach_file \f(CW$file\fP [, \f(CW$attribute\fP => \f(CW$value\fP, ... ]"
.IX Subsection "attach_file $file [, $attribute => $value, ... ]"
Attachs a file that already exists on the filesystem to the email.
\&\f(CW\*(C`attach_file\*(C'\fR will attempt to auto-detect the \s-1MIME\s0 type, and use the
file's current name when attaching. See the \f(CW\*(C`attributes\*(C'\fR parameter to
\&\*(L"create\*(R" in Email::MIME for the headers you can set.
.SS "transport"
.IX Subsection "transport"
.Vb 1
\&  $stuffer\->transport( $moniker, @options )
.Ve
.PP
or
.PP
.Vb 1
\&  $stuffer\->transport( $transport_obj )
.Ve
.PP
The \f(CW\*(C`transport\*(C'\fR method specifies the Email::Sender transport that
you want to use to send the email, and any options that need to be
used to instantiate the transport.  \f(CW$moniker\fR is used as the transport
name; if it starts with an equals sign (\f(CW\*(C`=\*(C'\fR) then the text after the
sign is used as the class.  Otherwise, the text is prepended by
\&\f(CW\*(C`Email::Sender::Transport::\*(C'\fR.
.PP
Alternatively, you can pass a complete transport object (which must be
an Email::Sender::Transport object) and it will be used as is.
.SS "email"
.IX Subsection "email"
Creates and returns the full Email::MIME object for the email.
.SS "as_string"
.IX Subsection "as_string"
Returns the string form of the email. Identical to (and uses behind the
scenes) Email::MIME\->as_string.
.SS "send"
.IX Subsection "send"
.Vb 1
\&  $stuffer\->send;
.Ve
.PP
or
.PP
.Vb 1
\&  $stuffer\->send({ to => [ $to_1, $to_2 ], from => $sender });
.Ve
.PP
Sends the email via Email::Sender::Simple.
Envelope information
can be specified in a hash reference.
.PP
On failure, returns false.
.SS "send_or_die"
.IX Subsection "send_or_die"
.Vb 1
\&  $stuffer\->send_or_die;
.Ve
.PP
or
.PP
.Vb 1
\&  $stuffer\->send_or_die({ to => [ $to_1, $to_2 ], from => $sender });
.Ve
.PP
Sends the email via Email::Sender::Simple.
Envelope information
can be specified in a hash reference.
.PP
On failure, throws an exception.
.SH "COOKBOOK"
.IX Header "COOKBOOK"
Here is another example (maybe plural later) of how you can use
Email::Stuffer's brevity to your advantage.
.SS "Custom Alerts"
.IX Subsection "Custom Alerts"
.Vb 2
\&  package SMS::Alert;
\&  use base \*(AqEmail::Stuffer\*(Aq;
\&
\&  sub new {
\&    shift()\->SUPER::new(@_)
\&           \->from(\*(Aqmonitor@my.website\*(Aq)
\&           # Of course, we could have pulled these from
\&           # $MyConfig\->{support_tech} or something similar.
\&           \->to(\*(Aq0416181595@sms.gateway\*(Aq)
\&           \->transport(\*(AqSMTP\*(Aq, { host => \*(Aq123.123.123.123\*(Aq });
\&  }
.Ve
.PP

.PP
.Vb 1
\&  package My::Code;
\&
\&  unless ( $Server\->restart ) {
\&          # Notify the admin on call that a server went down and failed
\&          # to restart.
\&          SMS::Alert\->subject("Server $Server failed to restart cleanly")
\&                    \->send;
\&  }
.Ve
.SH "TO DO"
.IX Header "TO DO"
.IP "\(bu" 4
Fix a number of bugs still likely to exist
.IP "\(bu" 4
Write more tests.
.IP "\(bu" 4
Add any additional small bit of automation that isn't too expensive
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Email::MIME, Email::Sender, <http://ali.as/>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Adam Kennedy <adamk@cpan.org>
.IP "\(bu" 4
Ricardo \s-1SIGNES\s0 <rjbs@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Aaron W. Swenson <aaron.w.swenson@gmail.com>
.IP "\(bu" 4
adam <adam@88f4d9cd\-8a04\-0410\-9d60\-8f63309c3137>
.IP "\(bu" 4
adamk@cpan.org <adamk@cpan.org@88f4d9cd\-8a04\-0410\-9d60\-8f63309c3137>
.IP "\(bu" 4
adam@phase\-n.com <adam@phase\-n.com@88f4d9cd\-8a04\-0410\-9d60\-8f63309c3137>
.IP "\(bu" 4
Alastair Douglas <altreus@altre.us>
.IP "\(bu" 4
Aristotle Pagaltzis <pagaltzis@gmx.de>
.IP "\(bu" 4
Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
.IP "\(bu" 4
Chase Whitener <chase.whitener@infotechfl.com>
.IP "\(bu" 4
CosmicNet <webmaster@cosmicperl.com>
.IP "\(bu" 4
Dan Book <grinnz@gmail.com>
.IP "\(bu" 4
John Napiorkowski <jjn1056@yahoo.com>
.IP "\(bu" 4
Josh Stompro <github@stompro.org>
.IP "\(bu" 4
Kevin Tew <tewk@tan.tewk.com>
.IP "\(bu" 4
Kieren Diment <kd@fenchurch.local>
.IP "\(bu" 4
Kris Matthews <krismatth@icloud.com>
.IP "\(bu" 4
Kris Matthews <kris@tigerlms.com>
.IP "\(bu" 4
Lee Johnson <lee@givengain.ch>
.IP "\(bu" 4
Manni Heumann <github@lxxi.org>
.IP "\(bu" 4
Pali <pali@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@semiotic.systems>
.IP "\(bu" 4
Ross Attrill <ross.attrill@gmail.com>
.IP "\(bu" 4
Russell Jenkins <russell.jenkins@strategicdata.com.au>
.IP "\(bu" 4
Shawn Sorichetti <shawn@coloredblocks.com>
.IP "\(bu" 4
Steve Dondley <s@dondley.com>
.IP "\(bu" 4
tokuhirom <tokuhirom@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2004 by Adam Kennedy and Ricardo \s-1SIGNES.\s0
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
