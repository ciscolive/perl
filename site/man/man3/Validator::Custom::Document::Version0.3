.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Validator::Custom::Document::Version0 3"
.TH Validator::Custom::Document::Version0 3 "2015-12-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Validator::Custom::Document::Version0 \- Documentation in Version 0.xx
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 2
\&  use Validator::Custom;
\&  my $vc = Validator::Custom\->new;
\&  
\&  # Data
\&  my $data = {id => 1, name => \*(AqKen Suzuki\*(Aq, age => \*(Aq 19 \*(Aq};
\&
\&  # Create Rule
\&  my $rule = $vc\->create_rule;
\&  
\&  # Rule syntax \- integer, have error message
\&  $rule\->require(\*(Aqid\*(Aq)\->check(\*(Aqint\*(Aq)\->message(\*(Aqid should be integer\*(Aq);
\&  
\&  # Rule syntax \- string, not blank, length is 1 to 5, have error messages
\&  $rule\->require(\*(Aqname\*(Aq)
\&    \->check(\*(Aqstring\*(Aq)\->message(\*(Aqname should be string\*(Aq)
\&    \->check(\*(Aqnot_blank\*(Aq)\->message(\*(Aqname should be not blank\*(Aq)
\&    \->check({length => [1, 5]})\->message(\*(Aqname is too long\*(Aq);
\&  
\&  # Rule syntax \- value is optional, default is 20
\&  $rule\->optional(\*(Aqage\*(Aq)\->filter(\*(Aqtrim\*(Aq)\->check(\*(Aqint\*(Aq)\->default(20);
\&  
\&  # Validation
\&  my $result = $vc\->validate($data, $rule);
\&  if ($result\->is_ok) {
\&    # Safety data
\&    my $safe_data = $vresult\->data;
\&  }
\&  else {
\&    # Error messgaes
\&    my $errors = $vresult\->messages;
\&  }
\&  
\&  # You original constraint(you can call constraint from $_)
\&  my $blank_or_number = sub {
\&    my $value = shift;
\&    return $_\->blank($value) || $_\->regex($value, qr/[0\-9]+/);
\&  };
\&  $rule\->require(\*(Aqage\*(Aq)
\&    \->check($blank_or_number)\->message(\*(Aqage must be blank or number\*(Aq)
\&  
\&  # Rule old syntax, please use above new syntax.
\&  # Old syntax take many miss\-typing.
\&  my $rule = [
\&    id => {message => \*(Aqid should be integer\*(Aq} => [
\&      \*(Aqint\*(Aq
\&    ],
\&    name => [
\&      [\*(Aqnot_blank\*(Aq => \*(Aqname is emtpy\*(Aq],
\&      [{length => [1, 5]} => \*(Aqname is too long\*(Aq]
\&    ],
\&    age => {require => 0, default => 20} => [
\&      [\*(Aqnot_blank\*(Aq => \*(Aqage is empty.\*(Aq],
\&      [\*(Aqint\*(Aq => \*(Aqage must be integer\*(Aq]
\&    ]
\&  ];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Validator::Custom validate \s-1HTML\s0 form data easy and flexibly.
The features are the following ones.
.IP "\(bu" 4
Many constraint functions are available by default, such as \f(CW\*(C`not_blank\*(C'\fR,
\&\f(CW\*(C`int\*(C'\fR, \f(CW\*(C`defined\*(C'\fR, \f(CW\*(C`in_array\*(C'\fR, \f(CW\*(C`length\*(C'\fR.
.IP "\(bu" 4
Several filter functions are available by default, such as \f(CW\*(C`trim\*(C'\fR,
\&\f(CW\*(C`datetime_to_timepiece\*(C'\fR, \f(CW\*(C`date_to_timepiece\*(C'\fR.
.IP "\(bu" 4
You can register your constraint function.
.IP "\(bu" 4
You can set error messages for invalid parameter value.
The order of messages is kept.
.IP "\(bu" 4
Support \f(CW\*(C`OR\*(C'\fR condition constraint and negative constraint,
.SH "GUIDE"
.IX Header "GUIDE"
.SS "1. Basic"
.IX Subsection "1. Basic"
\&\fB1. Create a new Validator::Custom object\fR
.PP
.Vb 2
\&  use Validator::Custom;
\&  my $vc = Validator::Custom\->new;
.Ve
.PP
\&\fB2. Prepare data for validation\fR
.PP
.Vb 1
\&  my $data = {age => 19, name => \*(AqKen Suzuki\*(Aq};
.Ve
.PP
Data must be hash reference.
.PP
\&\fB3. Prepare a rule for validation\fR
.PP
.Vb 4
\&  my $ruel = $vc\->create_rule;
\&  $rule\->require(\*(Aqage\*(Aq)
\&    \->check(\*(Aqnot_blank\*(Aq)
\&    \->check(\*(Aqint\*(Aq)\->message(\*(Aqage must be integer\*(Aq);
\&  
\&  $rule\->require(\*(Aqname\*(Aq)
\&    \->check(\*(Aqnot_blank\*(Aq)\->message(\*(Aqname is empty\*(Aq)
\&    \->check({length => [1, 5]})\->message(\*(Aqname must be length 1 to 5\*(Aq);
.Ve
.PP
Please see \*(L"\s-1RULE\*(R"\s0 in Validator::Custom about rule syntax.
.PP
You can use many constraint function,
such as \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`not_blank\*(C'\fR, \f(CW\*(C`length\*(C'\fR.
See \*(L"\s-1CONSTRAINTS\*(R"\s0 in Validator::Custom
to know all constraint functions.
.PP
Rule details is explained in \*(L"3. Rule syntax\*(R" section.
.PP
\&\fB4. Validate data\fR
.PP
.Vb 1
\&  my $result = $vc\->validate($data, $rule);
.Ve
.PP
use \f(CW\*(C`validate()\*(C'\fR to validate the data applying the rule.
\&\f(CW\*(C`validate()\*(C'\fR return Validator::Custom::Result object.
.PP
\&\fB5. Manipulate the validation result\fR
.PP
.Vb 4
\&  unless ($result\->is_ok) {
\&    if ($result\->has_missing) {
\&      my $missing_params = $result\->missing_params;
\&    }
\&    
\&    if ($result\->has_invalid) {
\&      my $messages = $result\->messages_to_hash;
\&    }
\&  }
.Ve
.PP
If you check the data is completely valid, use \f(CW\*(C`is_ok()\*(C'\fR.
\&\f(CW\*(C`is_ok()\*(C'\fR return true value
if invalid parameter values is not found and all parameter
names specified in the rule is found in the data.
.PP
If at least one of parameter names specified in the rule
is not found in the data,
\&\f(CW\*(C`has_missing()\*(C'\fR return true value.
.PP
You can get missing parameter names using \f(CW\*(C`missing_params()\*(C'\fR.
In this example, return value is the following one.
.PP
.Vb 1
\&  [\*(Aqprice\*(Aq]
.Ve
.PP
If at least one of parameter value is invalid,
\&\f(CW\*(C`has_invalid()\*(C'\fR return true value.
.PP
You can get the pairs of invalid parameter name and message
using \f(CW\*(C`messages_to_hash()\*(C'\fR.
In this example, return value is the following one.
.PP
.Vb 3
\&  {
\&    name => \*(Aqname must be string. the length 1 to 5\*(Aq
\&  }
.Ve
.PP
Validator::Custom::Result details is explained
in \*(L"2. Validation result\*(R".
.SS "2. Validation result"
.IX Subsection "2. Validation result"
\&\f(CW\*(C`validate()\*(C'\fR return Validator::Custom::Result object.
You can manipulate the result by various methods.
.PP
\&\f(CW\*(C`is_ok()\*(C'\fR, \f(CW\*(C`has_missing()\*(C'\fR, \f(CW\*(C`has_invalid()\*(C'\fR, \f(CW\*(C`missing_params()\*(C'\fR,
\&\f(CW\*(C`messages_to_hash()\*(C'\fR is already explained in \*(L"1. Basic\*(R"
.PP
The following ones is often used methods.
.PP
\&\fB\fBdata()\fB\fR
.PP
.Vb 1
\&  my $data = $result\->data;
.Ve
.PP
Get the data in the end state. Validator::Custom has filtering ability.
The parameter values in data passed to \f(CW\*(C`validate()\*(C'\fR
is maybe converted to other data by filter.
You can get filtered data using \f(CW\*(C`data()\*(C'\fR.
.PP
\&\fB\fBmessages()\fB\fR
.PP
.Vb 1
\&  my $messages = $result\->messages;
.Ve
.PP
Get messages corresponding to the parameter names which value is invalid.
Messages keep the order of parameter names of the rule.
.PP
\&\fB\fBmessage()\fB\fR
.PP
.Vb 1
\&  my $message = $result\->message(\*(Aqname\*(Aq);
.Ve
.PP
Get a message corresponding to the parameter name which value is invalid.
.PP
All Validator::Custom::Result's APIs is explained
in the \s-1POD\s0 of Validator::Custom::Result
.SS "\s-1RULE\s0"
.IX Subsection "RULE"
.Vb 2
\&  # Create Rule
\&  my $rule = $vc\->create_rule;
\&  
\&  # Rule syntax \- integer, have error message
\&  $rule\->require(\*(Aqid\*(Aq)\->check(\*(Aqint\*(Aq)\->message(\*(Aqid should be integer\*(Aq);
\&  
\&  # Rule syntax \- not blank, length is 1 to 5, have error messages
\&  $rule\->require(\*(Aqname\*(Aq)
\&    \->check(\*(Aqnot_blank\*(Aq)\->message(\*(Aqname is emtpy\*(Aq)
\&    \->check({length => [1, 5]})\->message(\*(Aqname is too long\*(Aq);
\&  
\&  # Rule syntax \- value is optional, default is 20
\&  $rule\->optional(\*(Aqage\*(Aq)\->check(\*(Aqint\*(Aq)\->default(20);
.Ve
.PP
Rule is Validator::Custom::Rule ojbect.
You can create \f(CW\*(C`create_rule\*(C'\fR method of Validator::Custom.
.PP
.Vb 1
\&  my $rule = $vc\->create_rule
.Ve
.PP
At first you set topic, \f(CW\*(C`require\*(C'\fR method or \f(CW\*(C`optional\*(C'\fR method.
If the value is required, you use \f(CW\*(C`require\*(C'\fR method.
If the value is not always required, you use \f(CW\*(C`optional\*(C'\fR method.
.PP
.Vb 2
\&  # Required
\&  $rule\->require(\*(Aqage\*(Aq);
\&  
\&  # Optional
\&  $rule\->optional(\*(Aqage\*(Aq);
.Ve
.PP
If you set topic to multiple keys, you should set key name by \f(CW\*(C`name\*(C'\fR method.
.PP
.Vb 2
\&  # Key name
\&  $rule\->require([\*(Aqmail1\*(Aq, \*(Aqmail2\*(Aq])\->name(\*(Aqmail\*(Aq);
.Ve
.PP
You can set options, \f(CW\*(C`message\*(C'\fR, \f(CW\*(C`default\*(C'\fR, and \f(CW\*(C`copy\*(C'\fR.
.IP "1. message" 4
.IX Item "1. message"
.Vb 1
\& $rule\->require(\*(Aqage\*(Aq)\->message(\*(Aqage is invalid\*(Aq);
.Ve
.Sp
Message corresponding to the parameter name which value is invalid.
.IP "2. default" 4
.IX Item "2. default"
.Vb 1
\&  $rule\->require(\*(Aqage\*(Aq)\->default(5)
.Ve
.Sp
Default value. This value is automatically set to result data
if the parameter value is invalid or the parameter name specified in rule is missing in the data.
.Sp
If you set not string or number value, you should the value which surrounded by code reference
.Sp
.Vb 1
\&  $rule\->require(\*(Aqage\*(Aq)\->default(sub { [] })
.Ve
.IP "3. copy" 4
.IX Item "3. copy"
.Vb 1
\&  $rule\->require(\*(Aqage\*(Aq)\->copy(0)
.Ve
.Sp
If this value is 0, The parameter value is not copied to result data. 
Default to 1. Parameter value is copied to the data.
.PP
You set constraints by \f(CW\*(C`check\*(C'\fR method.
.PP
.Vb 1
\&  $rule\->require(\*(Aqage\*(Aq)\->check({\*(Aqlength\*(Aq => [1, 5]});
.Ve
.PP
You can set message for each constraint function
.PP
.Vb 3
\&  $rule\->require(\*(Aqname\*(Aq)
\&    \->check(\*(Aqnot_blank\*(Aq)\->message(\*(Aqname must be not blank\*(Aq)
\&    \->check({length => [1, 5]})\->message(\*(Aqname must be 1 to 5 length\*(Aq);
.Ve
.PP
You can create original constraint function using
original constraints.
you can call constraints from \f(CW$_\fR in subroutine.
.PP
.Vb 10
\&  # You original constraint(you can call constraint from $_)
\&  my $blank_or_number = sub {
\&    my $value = shift;
\&    return $_\->blank($value) || $_\->regex($value, qr/[0\-9]+/);
\&  };
\&  my $rule = [
\&    name => [
\&      [$blank_or_number => \*(Aqname must be blank or number\*(Aq]
\&    ]
\&  ];
.Ve
.PP
\fIMultiple parameters validation\fR
.IX Subsection "Multiple parameters validation"
.PP
Multiple parameters validation is available.
.PP
.Vb 3
\&  Data: {password1 => \*(Aqxxx\*(Aq, password2 => \*(Aqxxx\*(Aq}
\&  Rule: $rule\->require([qw/password1 password2/])\->name(\*(Aqpassword_check)
\&          \->check(\*(Aqduplication\*(Aq)
.Ve
.PP
In this example, We check if 'password1' and 'password2' is same.
The following value is passed to constraint function \f(CW\*(C`duplication\*(C'\fR.
.PP
.Vb 1
\&  [\*(Aqxxx\*(Aq, \*(Aqxxx\*(Aq]
.Ve
.PP
You must specify new key, such as \f(CW\*(C`password_check\*(C'\fR.
This is used by Validator::Result object.
.PP
You can also use the reference of regular expression if you need.
.PP
.Vb 3
\&  Data: {person1 => \*(AqTaro\*(Aq, person2 => \*(AqRika\*(Aq, person3 => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(qr/^person/)\->name(\*(Aqmerged_person\*(Aq)
\&          \->check(\*(Aqmerge\*(Aq) # TaroRikaKen
.Ve
.PP
All matched value is passed to constraint function as array reference.
In this example, the following value is passed.
.PP
.Vb 1
\&  [\*(AqTaro\*(Aq, \*(AqRika\*(Aq, \*(AqKen\*(Aq]
.Ve
.PP
\fINegative constraint function\fR
.IX Subsection "Negative constraint function"
.PP
You can negative a constraint function
.PP
.Vb 1
\&  Rule: $rule\->require(\*(Aqage\*(Aq)\->check(\*(Aq!int\*(Aq)
.Ve
.PP
\&\*(L"!\*(R" is added to the head of the constraint name
if you negative a constraint function.
\&'!int' means not 'int'.
.PP
In this example,
.PP
\fI\*(L"\s-1OR\*(R"\s0 condition\fR
.IX Subsection "OR condition"
.PP
You can create \*(L"\s-1OR\*(R"\s0 condition by using \f(CW\*(C`check_or\*(C'\fR method.
.PP
.Vb 1
\&  Rule: $rule\->require(\*(Aqemail\*(Aq)\->check_or(\*(Aqblank\*(Aq, \*(Aqemail\*(Aq);
.Ve
.PP
Check is ok if email value is blank or email.
.PP
The folloing way is old syntax. Please use above syntax.
.PP
.Vb 1
\&  Rule: $rule\->require(\*(Aqemail\*(Aq)\->check(\*(Aqblank || email\*(Aq)
.Ve
.PP
\fIArray validation\fR
.IX Subsection "Array validation"
.PP
You can check if all the elements of array is valid.
.PP
.Vb 2
\&  Data: {nums => [1, 2, 3]}
\&  Rule: $rule\->require(\*(Aqnums\*(Aq)\->array(1)\->check(\*(Aqint\*(Aq)
.Ve
.PP
If nums is one value, this is automatically convert to array.
.PP
The following is old syntax. Please use above syntax.
.PP
.Vb 2
\&  Data: {nums => [1, 2, 3]}
\&  Rule: $rule\->require(\*(Aqnums\*(Aq)\->check(\*(Aq@int\*(Aq)
.Ve
.PP
\&\*(L"@\*(R" is added to the head of constraint function name
to validate all the elements of array.
.SS "4. Constraint functions"
.IX Subsection "4. Constraint functions"
\fIRegister constraint function\fR
.IX Subsection "Register constraint function"
.PP
Validator::Custom has various constraint functions.
You can see constraint functions registered by default
\&\*(L"\s-1CONSTRAINTS\*(R"\s0 in Validator::Custom.
.PP
and you can register your constraint function if you need.
.PP
.Vb 3
\&  $vc\->register_constraint(
\&    telephone => sub {
\&      my $value = shift;
\&      
\&      my $is_valid;
\&      if ($value =~ /^[\ed\-]+$/) {
\&        $is_valid = 1;
\&      }
\&      return $is_valid;
\&    }
\&  );
.Ve
.PP
Constraint function for telephone number is registered.
.PP
Constraint function receive a scalar value as first argument and
return boolean value which check if the value is valid.
.PP
Constraint function receive argument of constraint function as second argument
and Validator::Custom object as third argument.
.PP
.Vb 3
\&  $vc\->register_constraint(
\&    telephone => sub {
\&      my ($value, $arg, $vc) = @_;
\&      
\&      return $is_valid;
\&    }
\&  );
.Ve
.PP
If you know the implementations of constraint functions,
see the source of Validator::Custom::Constraint.
.PP
If you want to return custom message, you can use hash reference as return value.
.PP
.Vb 3
\&  $vc\->register_constraint(
\&    telephone => sub {
\&      my ($value, $arg, $vc) = @_;
\&      
\&      # Process
\&      my $is_valid = ...;
\&      
\&      if ($is_valid) {
\&        return 1;
\&      }
\&      else {
\&        return {result => 0, message => \*(AqCustom error message\*(Aq};
\&      }
\&    }
\&  );
.Ve
.PP
\fIRegister filter function\fR
.IX Subsection "Register filter function"
.PP
\&\f(CW\*(C`register_constraint()\*(C'\fR is also used to register filter function.
.PP
Filter function is same as constraint function except for return value;
.PP
.Vb 3
\&  $vc\->register_constraint(
\&    to_upper_case => sub {
\&      my $value = shift;
\&      
\&      $value = uc $value;
\&                  
\&      return {result => 1, output => $value};
\&    }
\&  );
.Ve
.PP
Return value of filter function must be array reference.
First element is boolean value which check if the value is valid.
Second element is filtered value.
.PP
In this example, First element of array reference is set to 1
because this function is intended to filter only.
.PP
You can also use array reference representation.
This is old syntax. I recommend hash reference.
.PP
.Vb 4
\&  # This is old syntax
\&  $vc\->register_constraint(
\&    to_upper_case => sub {
\&      my $value = shift;
\&      
\&      $value = uc $value;
\&                  
\&      return [1, $value];
\&    }
\&  );
.Ve
.SS "Old rule syntax"
.IX Subsection "Old rule syntax"
This is rule old syntax. Plese use new rule syntax.
.PP
\fIBasic\fR
.IX Subsection "Basic"
.PP
Rule has specified structure.
.PP
Rule must be array reference.
.PP
.Vb 1
\&  my $rule = [
\&  
\&  ];
.Ve
.PP
This is for keeping the order of
parameter names.
.PP
Rule has pairs of parameter name and constraint functions.
.PP
.Vb 5
\&  my $rule = [
\&    age =>  [            # parameter name1
\&      \*(Aqnot_blank\*(Aq,       #   constraint function1
\&      \*(Aqint\*(Aq              #   constraint function2
\&    ],                                                   
\&                                                         
\&    name => [              # parameter name2       
\&      \*(Aqnot_blank\*(Aq,         #   constraint function1
\&      {\*(Aqlength\*(Aq => [1, 5]} #   constraint function2
\&    ]
\&  ];
.Ve
.PP
Constraint function can receive arguments using hash reference.
.PP
.Vb 5
\&  my $rule = [
\&    name => [
\&        {\*(Aqlength\*(Aq => [1, 5]}
\&    ]
\&  ];
.Ve
.PP
You can set message for each constraint function
.PP
.Vb 6
\&  my $rule = [
\&    name => [
\&        [\*(Aqnot_blank\*(Aq, \*(Aqname must be not blank\*(Aq],
\&        [{length => [1, 5]}, \*(Aqname must be 1 to 5 length\*(Aq]
\&    ]
\&  ];
.Ve
.PP
You can pass subroutine reference as constraint.
.PP
.Vb 10
\&  # You original constraint(you can call constraint from $_)
\&  my $blank_or_number = sub {
\&    my $value = shift;
\&    return $_\->blank($value) || $_\->regex($value, qr/[0\-9]+/);
\&  };
\&  my $rule = [
\&    name => [
\&      [$blank_or_number => \*(Aqname must be blank or number\*(Aq]
\&    ]
\&  ];
.Ve
.PP
\fIOption\fR
.IX Subsection "Option"
.PP
You can set options for each parameter name.
.PP
.Vb 6
\&  my $rule = [
\&           # Option
\&    age => {message => \*(Aqage must be integer\*(Aq} => [
\&        \*(Aqnot_blank\*(Aq,
\&    ]
\&  ];
.Ve
.PP
Option is located after the parameter name,
and option must be hash reference.
.PP
The following options is available.
.IP "1. message" 4
.IX Item "1. message"
.Vb 1
\& {message => "This is invalid"}
.Ve
.Sp
Message corresponding to the parameter name which value is invalid.
.IP "2. default" 4
.IX Item "2. default"
.Vb 1
\&  {default => 5}
.Ve
.Sp
Default value. This value is automatically set to result data
if the parameter value is invalid or the parameter name specified in rule is missing in the data.
.Sp
If you set not string or number value, you should the value which surrounded by code reference
.Sp
.Vb 1
\&  {default => sub { [] }}
.Ve
.IP "3. copy" 4
.IX Item "3. copy"
.Vb 1
\&  {copy => 0}
.Ve
.Sp
If this value is 0, The parameter value is not copied to result data.
.Sp
Default to 1. Parameter value is copied to the data.
.IP "4. require" 4
.IX Item "4. require"
If this value is 0 and parameter value is not found,
the parameter is not added to missing parameter list.
.Sp
Default to 1.
.SH "CONSTRAINTS"
.IX Header "CONSTRAINTS"
.SS "ascii"
.IX Subsection "ascii"
.Vb 2
\&  Data: {name => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqascii\*(Aq)
.Ve
.PP
Ascii graphic characters(hex 21\-7e).
.SS "between"
.IX Subsection "between"
.Vb 3
\&  # Check (1, 2, .. 19, 20)
\&  Data: {age => 19}
\&  Rule: $rule\->require(\*(Aqage\*(Aq)\->check({between => [1, 20]})
.Ve
.PP
Between A and B.
.SS "blank"
.IX Subsection "blank"
.Vb 2
\&  Data: {name => \*(Aq\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqblank\*(Aq)
.Ve
.PP
Blank.
.SS "decimal"
.IX Subsection "decimal"
.Vb 3
\&  Data: {num1 => \*(Aq123\*(Aq, num2 => \*(Aq1.45\*(Aq}
\&  Rule: $rule\->require(\*(Aqnum1\*(Aq)\->check({\*(Aqdecimal\*(Aq => 3})
\&        $rule\->require(\*(Aqnum2\*(Aq)\->check({\*(Aqdecimal\*(Aq => [1, 2]})
.Ve
.PP
Decimal. You can specify maximum digits number at before
and after '.'.
.PP
If you set undef value or don't set any value, that means there is no maximum limit.
.PP
.Vb 4
\&  Data: {num1 => \*(Aq1233555.89345\*(Aq, num2 => \*(Aq1121111.45\*(Aq, num3 => \*(Aq12.555555555\*(Aq}
\&  Rule: $rule\->require(\*(Aqnum1\*(Aq)\->check(\*(Aqdecimal\*(Aq)
\&        $rule\->require(\*(Aqnum2\*(Aq)\->check({\*(Aqdecimal\*(Aq => [undef, 2]})
\&        $rule\->require(\*(Aqnum2\*(Aq)\->check({\*(Aqdecimal\*(Aq => [2, undef]})
.Ve
.SS "defined"
.IX Subsection "defined"
.Vb 2
\&  Data: {name => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqdefined\*(Aq)
.Ve
.PP
Defined.
.SS "duplication"
.IX Subsection "duplication"
.Vb 2
\&  Data: {mail1 => \*(Aqa@somehost.com\*(Aq, mail2 => \*(Aqa@somehost.com\*(Aq};
\&  Rule: $rule\->require([\*(Aqmail1\*(Aq, \*(Aqmail2\*(Aq])\->name(\*(Aqmail\*(Aq)\->check(\*(Aqduplication)
.Ve
.PP
Check if the two data are same or not.
.PP
You can get result value
.PP
.Vb 1
\&  my $mail = $vresult\->data\->{mail};
.Ve
.PP
Note that if one value is not defined or both values are not defined,
result of validation is false.
.SS "equal_to"
.IX Subsection "equal_to"
.Vb 2
\&  Data: {price => 1000}
\&  Rule: $rule\->require(\*(Aqprice\*(Aq)\->check({\*(Aqequal_to\*(Aq => 1000})
.Ve
.PP
Numeric equal comparison.
.SS "greater_than"
.IX Subsection "greater_than"
.Vb 2
\&  Data: {price => 1000}
\&  Rule: $rule\->require(\*(Aqprice\*(Aq)\->check({\*(Aqgreater_than\*(Aq => 900})
.Ve
.PP
Numeric \*(L"greater than\*(R" comparison
.SS "http_url"
.IX Subsection "http_url"
.Vb 2
\&  Data: {url => \*(Aqhttp://somehost.com\*(Aq};
\&  Rule: $rule\->require(\*(Aqurl\*(Aq)\->check(\*(Aqhttp_url\*(Aq)
.Ve
.PP
\&\s-1HTTP\s0(or \s-1HTTPS\s0) \s-1URL.\s0
.SS "int"
.IX Subsection "int"
.Vb 2
\&  Data: {age => 19};
\&  Rule: $rule\->require(\*(Aqage\*(Aq)\->check(\*(Aqint\*(Aq)
.Ve
.PP
Integer.
.SS "in_array"
.IX Subsection "in_array"
.Vb 2
\&  Data: {food => \*(Aqsushi\*(Aq};
\&  Rule: $rule\->require(\*(Aqfood\*(Aq)\->check({\*(Aqin_array\*(Aq => [qw/sushi bread apple/]})
.Ve
.PP
Check if the values is in array.
.SS "length"
.IX Subsection "length"
.Vb 11
\&  Data: {value1 => \*(Aqaaa\*(Aq, value2 => \*(Aqbbbbb\*(Aq};
\&  Rule: # length is equal to 3
\&        require(\*(Aqvalue1\*(Aq)\->check({\*(Aqlength\*(Aq => 3}) 
\&        # length is greater than or equal to 2 and lower than or equeal to 5
\&        require(\*(Aqvalue2\*(Aq)\->check({\*(Aqlength\*(Aq => [2, 5]}) 
\&        # length is greater than or equal to 2 and lower than or equeal to 5
\&        require(\*(Aqvalue3\*(Aq)\->check({\*(Aqlength\*(Aq => {min => 2, max => 5}}) 
\&        # greater than or equal to 2
\&        require(\*(Aqvalue4\*(Aq)\->check({\*(Aqlength\*(Aq => {min => 2}}) 
\&        # lower than or equal to 5
\&        require(\*(Aqvalue5\*(Aq)\->check({\*(Aqlength\*(Aq => {max => 5}})
.Ve
.PP
Length of the value.
.PP
Not that if value is internal string, length is character length.
if value is byte string, length is byte length.
.SS "less_than"
.IX Subsection "less_than"
.Vb 2
\&  Data: {num => 20}
\&  Rule: $rule\->require(\*(Aqnum\*(Aq)\->check({\*(Aqless_than\*(Aq => 25});
.Ve
.PP
Numeric \*(L"less than\*(R" comparison.
.SS "not_blank"
.IX Subsection "not_blank"
.Vb 2
\&  Data: {name => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqnot_blank\*(Aq) # Except for \*(Aq\*(Aq
.Ve
.PP
Not blank.
.SS "not_defined"
.IX Subsection "not_defined"
.Vb 2
\&  Data: {name => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqnot_defined\*(Aq)
.Ve
.PP
Not defined.
.SS "not_space"
.IX Subsection "not_space"
.Vb 2
\&  Data: {name => \*(AqKen\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqnot_space\*(Aq) # Except for \*(Aq\*(Aq, \*(Aq \*(Aq, \*(Aq   \*(Aq
.Ve
.PP
Not contain only space characters. 
Not that space is only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "space"
.IX Subsection "space"
.Vb 2
\&  Data: {name => \*(Aq   \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqspace\*(Aq) # \*(Aq\*(Aq, \*(Aq \*(Aq, \*(Aq   \*(Aq
.Ve
.PP
White space or empty string.
Not that space is only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "string"
.IX Subsection "string"
.Vb 2
\&  Data: {name => \*(Aqabc\*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->check(\*(Aqstring\*(Aq) # \*(Aq\*(Aq, \*(Aqabc\*(Aq, 0, 1, 1.23
.Ve
.PP
Check if the value is string, which contain numeric value.
if value is not defined or reference, this check return false.
.SS "uint"
.IX Subsection "uint"
.Vb 2
\&  Data: {age => 19}
\&  Rule: $rule\->require(\*(Aqage\*(Aq)\->check(\*(Aquint\*(Aq)
.Ve
.PP
Unsigned integer(contain zero).
.SS "regex"
.IX Subsection "regex"
.Vb 2
\&  Data: {num => \*(Aq123\*(Aq}
\&  Rule: $rule\->require(\*(Aqnum\*(Aq)\->check({\*(Aqregex\*(Aq => qr/\ed{0,3}/})
.Ve
.PP
Match a regular expression.
.SS "selected_at_least"
.IX Subsection "selected_at_least"
.Vb 2
\&  Data: {hobby => [\*(Aqmusic\*(Aq, \*(Aqmovie\*(Aq ]}
\&  Rule: $rule\->require(\*(Aqhobby\*(Aq)\->check({selected_at_least => 1})
.Ve
.PP
Selected at least specified count item.
In other word, the array contains at least specified count element.
.SH "FILTERS"
.IX Header "FILTERS"
You can use the following filter by default.
\&\f(CW\*(C`filter\*(C'\fR method is only alias for \f(CW\*(C`check\*(C'\fR method for readability.
.SS "date_to_timepiece"
.IX Subsection "date_to_timepiece"
.Vb 2
\&  Data: {date => \*(Aq2010/11/12\*(Aq}
\&  Rule: $rule\->require(\*(Aqdate\*(Aq)\->filter(\*(Aqdate_to_timepiece\*(Aq)
.Ve
.PP
The value which looks like date is converted
to Time::Piece object.
If the value contains 8 digits, the value is assumed date.
.PP
.Vb 5
\&  2010/11/12 # ok
\&  2010\-11\-12 # ok
\&  20101112   # ok
\&  2010       # NG
\&  2010111106 # NG
.Ve
.PP
And year and month and mday combination is ok.
.PP
.Vb 3
\&  Data: {year => 2011, month => 3, mday => 9}
\&  Rule: $rule\->require([\*(Aqyear\*(Aq, \*(Aqmonth\*(Aq, \*(Aqmday\*(Aq])\->name(\*(Aqdate\*(Aq)
\&                                          \->filter(\*(Aqdate_to_timepiece\*(Aq)
.Ve
.PP
You can get result value.
.PP
.Vb 1
\&  my $date = $vresult\->data\->{date};
.Ve
.PP
Note that Time::Piece is required.
.SS "datetime_to_timepiece"
.IX Subsection "datetime_to_timepiece"
.Vb 2
\&  Data: {datetime => \*(Aq2010/11/12 12:14:45\*(Aq}
\&  Rule: $rule\->require(\*(Aqdatetime\*(Aq)\->filter(\*(Aqdatetime_to_timepiece\*(Aq);
.Ve
.PP
The value which looks like date and time is converted
to Time::Piece object.
If the value contains 14 digits, the value is assumed date and time.
.PP
.Vb 5
\&  2010/11/12 12:14:45 # ok
\&  2010\-11\-12 12:14:45 # ok
\&  20101112 121445     # ok
\&  2010                # NG
\&  2010111106 12       # NG
.Ve
.PP
And year and month and mday combination is ok.
.PP
.Vb 4
\&  Data: {year => 2011, month => 3, mday => 9
\&         hour => 10, min => 30, sec => 30}
\&  Rule: $rule\->require([\*(Aqyear\*(Aq, \*(Aqmonth\*(Aq, \*(Aqmday\*(Aq, \*(Aqhour\*(Aq, \*(Aqmin\*(Aq, \*(Aqsec\*(Aq])
\&          \->name(\*(Aqdatetime\*(Aq)\->filter(\*(Aqdatetime_to_timepiece\*(Aq)
.Ve
.PP
You can get result value.
.PP
.Vb 1
\&  my $date = $vresult\->data\->{datetime};
.Ve
.PP
Note that Time::Piece is required.
.SS "merge"
.IX Subsection "merge"
.Vb 3
\&  Data: {name1 => \*(AqKen\*(Aq, name2 => \*(AqRika\*(Aq, name3 => \*(AqTaro\*(Aq}
\&  Rule: $rule\->require([\*(Aqname1\*(Aq, \*(Aqname2\*(Aq, \*(Aqname3\*(Aq])\->name(\*(Aqmergd_name\*(Aq)
\&          \->filter(\*(Aqmerge\*(Aq) # KenRikaTaro
.Ve
.PP
Merge the values.
.PP
You can get result value.
.PP
.Vb 1
\&  my $merged_name = $vresult\->data\->{merged_name};
.Ve
.PP
Note that if one value is not defined, merged value become undefined.
.SS "shift"
.IX Subsection "shift"
.Vb 2
\&  Data: {names => [\*(AqKen\*(Aq, \*(AqTaro\*(Aq]}
\&  Rule: $rule\->require(\*(Aqnames\*(Aq)\->filter(\*(Aqshift\*(Aq) # \*(AqKen\*(Aq
.Ve
.PP
Shift the head element of array.
.SS "to_array"
.IX Subsection "to_array"
.Vb 2
\&  Data: {languages => \*(AqJapanese\*(Aq}
\&  Rule: $rule\->require(\*(Aqlanguages\*(Aq)\->filter(\*(Aqto_array\*(Aq) # [\*(AqJapanese\*(Aq]
.Ve
.PP
Convert non array reference data to array reference.
This is useful to check checkbox values or select multiple values.
.SS "trim"
.IX Subsection "trim"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim\*(Aq) # \*(AqKen\*(Aq
.Ve
.PP
Trim leading and trailing white space.
Not that trim only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "trim_collapse"
.IX Subsection "trim_collapse"
.Vb 2
\&  Data: {name => \*(Aq  Ken   Takagi  \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_collapse\*(Aq) # \*(AqKen Takagi\*(Aq
.Ve
.PP
Trim leading and trailing white space,
and collapse all whitespace characters into a single space.
Not that trim only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "trim_lead"
.IX Subsection "trim_lead"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_lead\*(Aq) # \*(AqKen  \*(Aq
.Ve
.PP
Trim leading white space.
Not that trim only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "trim_trail"
.IX Subsection "trim_trail"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_trail\*(Aq) # \*(Aq  Ken\*(Aq
.Ve
.PP
Trim trailing white space.
Not that trim only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR
which don't contain unicode space character.
.SS "trim_uni"
.IX Subsection "trim_uni"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq}
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_uni\*(Aq) # \*(AqKen\*(Aq
.Ve
.PP
Trim leading and trailing white space, which contain unicode space character.
.SS "trim_uni_collapse"
.IX Subsection "trim_uni_collapse"
.Vb 2
\&  Data: {name => \*(Aq  Ken   Takagi  \*(Aq};
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_uni_collapse\*(Aq) # \*(AqKen Takagi\*(Aq
.Ve
.PP
Trim leading and trailing white space, which contain unicode space character.
.SS "trim_uni_lead"
.IX Subsection "trim_uni_lead"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq};
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_uni_lead\*(Aq) # \*(AqKen  \*(Aq
.Ve
.PP
Trim leading white space, which contain unicode space character.
.SS "trim_uni_trail"
.IX Subsection "trim_uni_trail"
.Vb 2
\&  Data: {name => \*(Aq  Ken  \*(Aq};
\&  Rule: $rule\->require(\*(Aqname\*(Aq)\->filter(\*(Aqtrim_uni_trail\*(Aq) # \*(Aq  Ken\*(Aq
.Ve
.PP
Trim trailing white space, which contain unicode space character.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "constraints"
.IX Subsection "constraints"
.Vb 2
\&  my $constraints = $vc\->constraints;
\&  $vc             = $vc\->constraints(\e%constraints);
.Ve
.PP
Constraint functions.
.SS "data_filter"
.IX Subsection "data_filter"
.Vb 2
\&  my $filter = $vc\->data_filter;
\&  $vc        = $vc\->data_filter(\e&data_filter);
.Ve
.PP
Filter for input data. If data is not hash reference, you can convert
the data to hash reference.
.PP
.Vb 2
\&  $vc\->data_filter(sub {
\&    my $data = shift;
\&    
\&    my $hash = {};
\&    
\&    # Convert data to hash reference
\&    
\&    return $hash;
\&  });
.Ve
.SS "error_stock"
.IX Subsection "error_stock"
.Vb 2
\&  my $error_stock = $vc\->error_stcok;
\&  $vc             = $vc\->error_stock(1);
.Ve
.PP
If error_stock is set to 0, \f(CW\*(C`validate()\*(C'\fR return soon after invalid value is found.
.PP
Default to 1.
.SS "rule_obj \s-1EXPERIMENTAL\s0"
.IX Subsection "rule_obj EXPERIMENTAL"
.Vb 1
\&  my $rule_obj = $vc\->rule_obj($rule);
.Ve
.PP
Validator::Custom rule is a little complex.
You maybe make mistakes often.
If you want to know that how Validator::Custom parse rule,
See \f(CW\*(C`rule_obj\*(C'\fR attribute after calling \f(CW\*(C`validate\*(C'\fR method.
This is Validator::Custom::Rule object.
.PP
.Vb 1
\&  my $vresult = $vc\->validate($data, $rule);
\&
\&  use Data::Dumper;
\&  print Dumper $vc\->rule_obj\->rule;
.Ve
.PP
If you see \f(CW\*(C`ERROR\*(C'\fR key, rule syntax is wrong.
.SS "rule"
.IX Subsection "rule"
.Vb 2
\&  my $rule = $vc\->rule;
\&  $vc      = $vc\->rule(\e@rule);
.Ve
.PP
Validation rule. If second argument of \f(CW\*(C`validate()\*(C'\fR is not specified.
this rule is used.
.SH "METHODS"
.IX Header "METHODS"
Validator::Custom inherits all methods from Object::Simple
and implements the following new ones.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $vc = Validator::Custom\->new;
.Ve
.PP
Create a new Validator::Custom object.
.SS "js_fill_form_button"
.IX Subsection "js_fill_form_button"
.Vb 4
\&  my $button = $self\->js_fill_form_button(
\&    mail => \*(Aq[abc]{3}@[abc]{2}.com,
\&    title => \*(Aq[pqr]{5}\*(Aq
\&  );
.Ve
.PP
Create javascript button source code to fill form.
You can specify string or pattern like regular expression.
.PP
If you click this button, each text box is filled with the
specified pattern string,
and checkbox, radio button, and list box is automatically selected.
.PP
Note that this methods require \s-1JSON\s0 module.
.SS "validate"
.IX Subsection "validate"
.Vb 2
\&  $result = $vc\->validate($data, $rule);
\&  $result = $vc\->validate($data);
.Ve
.PP
Validate the data.
Return value is Validator::Custom::Result object.
If second argument isn't passed, \f(CW\*(C`rule\*(C'\fR attribute is used as rule.
.PP
\&\f(CW$rule\fR is array reference
(or Validator::Custom::Rule object, this is \s-1EXPERIMENTAL\s0).
.SS "register_constraint"
.IX Subsection "register_constraint"
.Vb 2
\&  $vc\->register_constraint(%constraint);
\&  $vc\->register_constraint(\e%constraint);
.Ve
.PP
Register constraint function.
.PP
.Vb 12
\&  $vc\->register_constraint(
\&    int => sub {
\&      my $value    = shift;
\&      my $is_valid = $value =~ /^\e\-?[\ed]+$/;
\&      return $is_valid;
\&    },
\&    ascii => sub {
\&      my $value    = shift;
\&      my $is_valid = $value =~ /^[\ex21\-\ex7E]+$/;
\&      return $is_valid;
\&    }
\&  );
.Ve
.PP
You can register filter function.
.PP
.Vb 5
\&  $vc\->register_constraint(
\&    trim => sub {
\&      my $value = shift;
\&      $value =~ s/^\es+//;
\&      $value =~ s/\es+$//;
\&      
\&      return {result => 1, output => $value];
\&    }
\&  );
.Ve
.PP
Filter function return array reference,
first element is the value if the value is valid or not,
second element is the converted value by filter function.
.SH "FAQ"
.IX Header "FAQ"
.SS "How to do check box validation?"
.IX Subsection "How to do check box validation?"
Check box validation is a little difficult because
check box value is not exists or one or multiple.
.PP
.Vb 4
\&  # Data
\&  my $data = {}
\&  my $data = {feature => 1}
\&  my $data = {feature => [1, 2]}
.Ve
.PP
You can do the following way.
.PP
.Vb 5
\&  $rule\->require(\*(Aqfeature\*(Aq)
\&    \->filter(\*(Aqto_array\*(Aq)
\&    \->check({selected_at_least => 1})\->message(\*(Aqfeature should select at least 1\*(Aq)
\&    \->each(1)
\&    \->check(\*(Aqint\*(Aq)\->message(\*(Aqfeatures should be integer\*(Aq);
.Ve
.SH "DEPRECATED FUNCTIONALITIES"
.IX Header "DEPRECATED FUNCTIONALITIES"
Validator::Custom
.PP
.Vb 2
\&  # Atrribute methods
\&  shared_rule # Removed at 2017/1/1
\&  
\&  # Methods
\&  _\|_PACKAGE_\|_\->constraints(...); # Call constraints method as class method
\&                                 # Removed at 2017/1/1
\&L<Validator::Custom::Result>
\&
\&  # Attribute methods
\&  error_infos # Removed at 2017/1/1 
\&
\&  # Methods
\&  error_reason # Removed at 2017/1/1
\&  add_error_info # Removed at 2017/1/1
\&  error # Removed at 2017/1/1
\&  errors # Removed at 2017/1/1
\&  errors_to_hash # Removed at 2017/1/1
\&  invalid_keys # Removed at 2017/1/1
\&  remove_error_info # Removed at 2017/1/1
.Ve
.SH "BACKWORD COMPATIBLE POLICY"
.IX Header "BACKWORD COMPATIBLE POLICY"
If a functionality is \s-1DEPRECATED,\s0 you can know it by \s-1DEPRECATED\s0 warnings.
\&\s-1DEPRECATED\s0 functionality is removed after five years,
but if at least one person use the functionality and tell me that thing
I extend one year each time you tell me it.
.PP
\&\s-1EXPERIMENTAL\s0 functionality will be changed without warnings.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.PP
<http://github.com/yuki\-kimoto/Validator\-Custom>
.SH "COPYRIGHT & LICENCE"
.IX Header "COPYRIGHT & LICENCE"
Copyright 2009\-2014 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
