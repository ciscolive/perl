.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Number::RGB 3"
.TH Number::RGB 3 "2015-09-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Number::RGB \- Manipulate RGB Tuples
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Number::RGB;
\&  my $white :RGB(255);
\&  my $black :RGB(0);
\&
\&  my $gray = $black + ( $white / 2 );
\&
\&  my @rgb = @{ $white\->rgb };
\&  my $hex = $black\->hex;
\&
\&  my $blue   = Number::RGB\->new(rgb => [0,0,255]);
\&  my $green  = Number::RGB\->new(hex => \*(Aq#00FF00\*(Aq);
\&
\&  my $red :RGB(255,0,0);
\&
\&  my $purple = $blue + $green;
\&  my $yellow = $red  + $green;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module creates \s-1RGB\s0 tuple objects and overloads their operators to
make \s-1RGB\s0 math easier. An attribute is also exported to the caller to
make construction shorter.
.SS "Methods"
.IX Subsection "Methods"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 4
\&  my $red   = Number::RGB\->new(rgb => [255,0,0])
\&  my $blue  = Number::RGB\->new(hex => \*(Aq#0000FF\*(Aq);
\&  my $blue  = Number::RGB\->new(hex => \*(Aq#00F\*(Aq);
\&  my $black = Number::RGB\->new(rgb_number => 0);
.Ve
.PP
This constructor accepts named parameters. One of three parameters are
required.
.PP
\&\f(CW\*(C`rgb\*(C'\fR is a array reference containing three integers within the range
of \f(CW0..255\fR. In order, each integer represents \fIred\fR, \fIgreen\fR, and
\&\fIblue\fR.
.PP
\&\f(CW\*(C`hex\*(C'\fR is a hexadecimal representation of an \s-1RGB\s0 tuple commonly used in
Cascading Style Sheets. The format begins with an optional hash (\f(CW\*(C`#\*(C'\fR)
and follows with three groups of hexadecimal numbers representing
\&\fIred\fR, \fIgreen\fR, and \fIblue\fR in that order. A shorthand, 3\-digit version
can be used: \f(CW\*(C`#123\*(C'\fR is equivalent to \f(CW\*(C`#112233\*(C'\fR.
.PP
\&\f(CW\*(C`rgb_number\*(C'\fR is a single integer to use for each of the three primary colors.
This is shorthand to create \fIwhite\fR, \fIblack\fR, and all shades of
\&\fIgray\fR.
.PP
This method throws an exception on error.
.PP
\fI\f(CI\*(C`new_from_guess\*(C'\fI\fR
.IX Subsection "new_from_guess"
.PP
.Vb 1
\&  my $color = Number::RGB\->new_from_guess( ... );
.Ve
.PP
This constructor tries to guess the format being used and returns a
tuple object. If it can't guess, an exception will be thrown.
.PP
\&\fINote:\fR a single number between \f(CW0..255\fR will \fInever\fR be interpreted as
a hex shorthand. You'll need to explicitly prepend \f(CW\*(C`#\*(C'\fR character to
disambiguate and force hex mode.
.PP
\fI\f(CI\*(C`r\*(C'\fI\fR
.IX Subsection "r"
.PP
Accessor and mutator for the \fIred\fR value.
.PP
\fI\f(CI\*(C`g\*(C'\fI\fR
.IX Subsection "g"
.PP
Accessor and mutator for the \fIgreen\fR value.
.PP
\fI\f(CI\*(C`b\*(C'\fI\fR
.IX Subsection "b"
.PP
Accessor and mutator for the \fIblue\fR value.
.PP
\fI\f(CI\*(C`rgb\*(C'\fI\fR
.IX Subsection "rgb"
.PP
Returns a array reference containing three elements. In order they
represent \fIred\fR, \fIgreen\fR, and \fIblue\fR.
.PP
\fI\f(CI\*(C`hex\*(C'\fI\fR
.IX Subsection "hex"
.PP
Returns a hexadecimal representation of the tuple conforming to the format
used in Cascading Style Sheets.
.PP
\fI\f(CI\*(C`hex_uc\*(C'\fI\fR
.IX Subsection "hex_uc"
.PP
Returns the same thing as \*(L"hex\*(R", but any hexadecimal numbers that
include \f(CW\*(AqA\*(Aq..\*(AqF\*(Aq\fR will be in upper case.
.PP
\fI\f(CI\*(C`as_string\*(C'\fI\fR
.IX Subsection "as_string"
.PP
Returns a string representation of the tuple.  For example, \fIwhite\fR
would be the string \f(CW\*(C`255,255,255\*(C'\fR.
.SS "Attributes"
.IX Subsection "Attributes"
\fI\f(CI\*(C`:RGB()\*(C'\fI\fR
.IX Subsection ":RGB()"
.PP
.Vb 3
\&  my $red   :RGB(255,0,0);
\&  my $blue  :RGB(#0000FF);
\&  my $white :RGB(0);
.Ve
.PP
This attribute is exported to the caller and provides a shorthand wrapper
around \*(L"new_from_guess\*(R".
.SS "Overloads"
.IX Subsection "Overloads"
\&\f(CW\*(C`Number::RGB\*(C'\fR overloads the following operations:
.PP
.Vb 12
\&    ""
\&    +
\&    \-
\&    *
\&    /
\&    %
\&    **
\&    <<
\&    >>
\&    &
\&    ^
\&    |
.Ve
.PP
Stringifying a \f(CW\*(C`Number::RGB\*(C'\fR object will produce a string with three
\&\s-1RGB\s0 tuples joined with commas. All other operators operate on each
individual \s-1RGB\s0 tuple number.
.PP
If the tuple value is below \f(CW0\fR after
the operation, it will set to \f(CW0\fR. If the tuple value is above \f(CW255\fR after
the operation, it will set to \f(CW255\fR.
.PP
\&\fINote:\fR illegal operations (such us dividing by zero) result in the tuple
value being set to \f(CW0\fR.
.PP
Operations create new \f(CW\*(C`Number::RGB\*(C'\fR objects,
which means that even something as strange as this still works:
.PP
.Vb 2
\&    my $color :RGB(5,10,50);
\&    print 110 \- $color; # prints \*(Aq105,100,60\*(Aq
.Ve
.SH "REPOSITORY"
.IX Header "REPOSITORY"
Fork this module on GitHub:
<https://github.com/zoffixznet/Number\-RGB>
.SH "BUGS"
.IX Header "BUGS"
To report bugs or request features, please use
<https://github.com/zoffixznet/Number\-RGB/issues>
.PP
If you can't access GitHub, you can email your request
to \f(CW\*(C`bug\-Number\-RGB at rt.cpan.org\*(C'\fR
.SH "MAINTAINER"
.IX Header "MAINTAINER"
This module is currently maintained by:
.SH "AUTHOR"
.IX Header "AUTHOR"
.SH "LICENSE"
.IX Header "LICENSE"
You can use and distribute this module under the same terms as Perl itself.
See the \f(CW\*(C`LICENSE\*(C'\fR file included in this distribution for complete
details.
