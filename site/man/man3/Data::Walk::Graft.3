.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Walk::Graft 3"
.TH Data::Walk::Graft 3 "2016-08-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Walk::Graft \- A way to say what should be added
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        #!perl
\&        use Data::Walk::Extracted;
\&        use Data::Walk::Graft;
\&        use Data::Walk::Print;
\&        use MooseX::ShortCut::BuildInstance qw( build_instance );
\&
\&        my  $gardener = build_instance( 
\&                        package => \*(AqJordan::Porter\*(Aq,
\&                        superclasses =>[\*(AqData::Walk::Extracted\*(Aq],
\&                        roles =>[qw( Data::Walk::Graft Data::Walk::Clone Data::Walk::Print )],
\&                        sorted_nodes =>{
\&                                HASH => 1,
\&                        },# For demonstration consistency
\&                        #Until Data::Walk::Extracted and ::Graft support these types
\&                        #(watch Data\-Walk\-Extracted on github)
\&                        skipped_nodes =>{ 
\&                                OBJECT => 1,
\&                                CODEREF => 1,
\&                        },
\&                        graft_memory => 1,
\&                );
\&        my  $tree_ref = {
\&                        Helping =>{
\&                                KeyTwo => \*(AqA New Value\*(Aq,
\&                                KeyThree => \*(AqAnother Value\*(Aq,
\&                                OtherKey => \*(AqSomething\*(Aq,
\&                        },
\&                        MyArray =>[
\&                                \*(AqValueOne\*(Aq,
\&                                \*(AqValueTwo\*(Aq,
\&                                \*(AqValueThree\*(Aq,
\&                        ],
\&                };
\&        $gardener\->graft_data(
\&                scion_ref =>{
\&                        Helping =>{
\&                                OtherKey => \*(AqOtherthing\*(Aq,
\&                        },
\&                        MyArray =>[
\&                                \*(AqIGNORE\*(Aq,
\&                                {
\&                                        What => \*(AqChicken_Butt!\*(Aq,
\&                                },
\&                                \*(AqIGNORE\*(Aq,
\&                                \*(AqIGNORE\*(Aq,
\&                                \*(AqValueFive\*(Aq,
\&                        ],
\&                },
\&                tree_ref  => $tree_ref,
\&        );
\&        $gardener\->print_data( $tree_ref );
\&        print "Now a list of \-" . $gardener\->number_of_scions . "\- grafted positions\en";
\&        $gardener\->print_data( $gardener\->get_grafted_positions );
\&
\&        #####################################################################################
\&        #     Output of SYNOPSIS
\&        # 01 {
\&        # 02    Helping => {
\&        # 03            KeyThree => \*(AqAnother Value\*(Aq,
\&        # 04            KeyTwo => \*(AqA New Value\*(Aq,
\&        # 05            OtherKey => \*(AqOtherthing\*(Aq,
\&        # 06    },
\&        # 07    MyArray => [
\&        # 08            \*(AqValueOne\*(Aq,
\&        # 09            {
\&        # 10                    What => \*(AqChicken_Butt!\*(Aq,
\&        # 11            },
\&        # 12            \*(AqValueThree\*(Aq,
\&        # 13            undef,
\&        # 14            \*(AqValueFive\*(Aq,
\&        # 15    ],
\&        # 16 },
\&        # 17 Now a list of \-3\- grafted positions
\&        # 18 [
\&        # 19    {
\&        # 20            Helping => {
\&        # 21                    OtherKey => \*(AqOtherthing\*(Aq,
\&        # 22            },
\&        # 23    },
\&        # 24    {
\&        # 25            MyArray => [
\&        # 26                    undef,
\&        # 27                    {
\&        # 28                            What => \*(AqChicken_Butt!\*(Aq,
\&        # 29                    },
\&        # 30            ],
\&        # 31    },
\&        # 32    {
\&        # 33            MyArray => [
\&        # 34                    undef,
\&        # 35                    undef,
\&        # 36                    undef,
\&        # 37                    undef,
\&        # 38                    \*(AqValueFive\*(Aq,
\&        # 39            ],
\&        # 40    },
\&        # 41 ],
\&        #####################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose::Role contains methods for adding a new branch ( or three ) to an existing 
data ref.  The method used to do this is graft_data using
Data::Walk::Extracted.  Grafting is accomplished by sending a \f(CW$scion_ref\fR that has 
additions that need to be made to a \f(CW$tree_ref\fR.  Anything in the scion ref that does not 
exist in the tree ref is grafted to the tree ref.  \fIAnytime the scion_ref is different 
from the tree_ref the scion_ref branch will replace the tree_ref branch!\fR
.SS "\s-1USE\s0"
.IX Subsection "USE"
This is a Moose::Role <https://metacpan.org/module/Moose::Manual::Roles> specifically
designed to be used with Data::Walk::Extracted
\&.  It can be combined traditionaly 
to the ~::Extracted class using Moose or at run time. see Moose::Util and 
MooseX::ShortCut::BuildInstance for more information.
.SS "Deep cloning the graft"
.IX Subsection "Deep cloning the graft"
In general grafted data refs are subject to external modification by changing the data
in that ref from another location of the code.  This module assumes that you don't want
to do that!  As a consequence it checks to see if a 'deep_clone' method has been provided to
the class that consumes this role.  If so it calls that method on the data ref to be
grafted.  One possiblity is to add the Role Data::Walk::Clone to your object so that 
a deep_clone method is automatically available (all compatability testing complete).  If 
you choose to add your own deep_clone method it will be called like this;
.PP
.Vb 2
\&        my $clone_value = ( $self\->can( \*(Aqdeep_clone\*(Aq ) ) ?
\&                                $self\->deep_clone( $scion_ref ) : $scion_ref ;
.Ve
.PP
Where \f(CW$self\fR is the active object instance.
.SS "Grafting unsupported node types"
.IX Subsection "Grafting unsupported node types"
If you want to add data from another ref to a current ref and the add ref contains nodes
that are not supported then you need to skip those 
nodes in the cloning process.
.SH "Attributes"
.IX Header "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes
see Methods.  The \->new function will either accept fat comma lists or a
complete hash ref that has the possible attributes as the top keys.  Additionally
some attributes that have all the following methods; get_$attribute, set_$attribute,
has_$attribute, and clear_$attribute, can be passed to graft_data
 and will be adjusted for just the run of that
method call.  These are called 'one shot' attributes.  The class and each role (where
applicable) in this package have a list of supported one shot attributes
\&.
.SS "graft_memory"
.IX Subsection "graft_memory"
.RS 4
\&\fBDefinition:\fR When running a 'graft_data' operation any branch of the \f(CW$scion_ref\fR
that does not terminate past the end of the tree ref or differ from the tree_ref
will not be used.  This attribute turns on tracking of the actual grafts made and
stores them for review after the method is complete.  This is a way to know if a graft
was actually implemented.  The potentially awkward wording of the associated methods
is done to make this an eligible 'one shot' attribute.
.Sp
\&\fBDefault\fR undefined = don't remember the grafts
.Sp
\&\fBRange\fR 1 = remember the grafts | 0 = don't remember
.RE
.SS "(see also)"
.IX Subsection "(see also)"
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted#Attributes>
Attributes
.SH "Methods"
.IX Header "Methods"
.ie n .SS "graft_data( %args|$arg_ref )"
.el .SS "graft_data( \f(CW%args\fP|$arg_ref )"
.IX Subsection "graft_data( %args|$arg_ref )"
.RS 4
\&\fBDefinition:\fR This is a method to add defined elements to targeted parts of a data
reference.
.Sp
\&\fBAccepts:\fR a hash ref with the keys 'scion_ref' and 'tree_ref'.  The scion
ref can contain more than one place that will be grafted to the tree data.
.Sp
.RS 4
\&\fBtree_ref\fR This is the primary data ref that will be manipulated and returned
changed.  If an empty 'tree_ref' is passed then the 'scion_ref' is returned in it's
entirety.
.Sp
\&\fBscion_ref\fR This is a data ref that will be used to graft to the 'tree_ref'.
For the scion ref to work it must contain the parts of the tree ref below the new
scions as well as the scion itself.  During data walking when a difference is found
graft_data will attempt to clone the remaining untraveled portion of the 'scion_ref'
and then graft the result to the 'tree_ref' at that point.  Any portion of the tree
ref that differs from the scion ref at that point will be replaced.  If graft_memory
 is on then a full recording of the graft with a map to the data root
will be saved in the object.  The word '\s-1IGNORE\s0' can be used in either an array position
or the value for a key in a hash ref.  This tells the program to ignore differences (in
depth) past that point.  For example if you wish to change the third element of an array
node then placing '\s-1IGNORE\s0' in the first two positions will cause 'graft_data' to skip the
analysis of the first two branches.  This saves replicating deep references in the
scion_ref while also avoiding a defacto 'prune' operation.  If an array position in the
scion_ref is set to '\s-1IGNORE\s0' in the 'scion_ref' but a graft is made below the node with
\&\s-1IGNORE\s0 then the grafted tree will contain '\s-1IGNORE\s0' in that element of the array (not
undef).  Any positions that exist in the tree_ref that do not exist in the scion_ref
will be ignored.  If an empty 'scion_ref' is sent then the code will cluck
 <https://metacpan.org/module/Carp> and then return the 'tree_ref'.
.Sp
\&\fB[attribute name]\fR \- attribute names are accepted with temporary attribute settings.
These settings are temporarily set for a single \*(L"graft_data\*(R" call and then the original
attribute values are restored.  For this to work the the attribute must meet the
necessary criteria.
.Sp
\&\fBExample\fR
.Sp
.Vb 5
\&        $grafted_tree_ref = $self\->graft_data(
\&                tree_ref => $tree_data,
\&                scion_ref => $addition_data,
\&                graft_memory => 0,
\&        );
.Ve
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR The \f(CW$tree_ref\fR with any changes (possibly deep cloned)
.RE
.SS "has_graft_memory"
.IX Subsection "has_graft_memory"
.RS 4
\&\fBDefinition:\fR This will indicate if the attribute graft_memory is active
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 or 0
.RE
.ie n .SS "set_graft_memory( $Bool )"
.el .SS "set_graft_memory( \f(CW$Bool\fP )"
.IX Subsection "set_graft_memory( $Bool )"
.RS 4
\&\fBDefinition:\fR This will set the graft_memory attribute
.Sp
\&\fBAccepts:\fR 1 or 0
.Sp
\&\fBReturns:\fR nothing
.RE
.SS "get_graft_memory"
.IX Subsection "get_graft_memory"
.RS 4
\&\fBDefinition:\fR This will return the current value for the graft_memory attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 or 0
.RE
.SS "clear_graft_memory"
.IX Subsection "clear_graft_memory"
.RS 4
\&\fBDefinition:\fR This will clear the graft_memory attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.SS "number_of_scions"
.IX Subsection "number_of_scions"
.RS 4
\&\fBDefinition:\fR This will return the number of scion points grafted in the most recent
graft action if the graft_memory attribute is on.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a positive integer
.RE
.SS "has_grafted_positions"
.IX Subsection "has_grafted_positions"
.RS 4
\&\fBDefinition:\fR This will indicate if any grafted positions were saved.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 or 0
.RE
.SS "get_grafted_positions"
.IX Subsection "get_grafted_positions"
.RS 4
\&\fBDefinition:\fR This will return any saved grafted positions.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an \s-1ARRAY\s0 ref of grafted positions.  This will include
one full data branch to the root for each position actually grafted.
.RE
.SH "Caveat utilitor"
.IX Header "Caveat utilitor"
.SS "Supported Node types"
.IX Subsection "Supported Node types"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
.IP "Other node support" 4
.IX Item "Other node support"
.PD
Support for Objects is partially implemented and as a consequence graft_data won't
immediatly die when asked to graft an object.  It will still die but on a dispatch table
call that indicates where there is missing object support not at the top of the node.
.SS "Supported one shot attributes"
.IX Subsection "Supported one shot attributes"
explanation
.IP "graft_memory" 4
.IX Item "graft_memory"
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.RS 4
\&\fB\f(CB$ENV\fB{Smart_Comments}\fR
.Sp
The module uses Smart::Comments <https://metacpan.org/module/Smart::Comments> if the '\-ENV'
option is set.  The 'use' is encapsulated in an if block triggered by an environmental
variable to comfort non-believers.  Setting the variable \f(CW$ENV\fR{Smart_Comments} in a \s-1BEGIN\s0
block will load and turn on smart comment reporting.  There are three levels of 'Smartness'
available in this module '###',  '####', and '#####'.
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Data\-Walk\-Extracted/issues <https://github.com/jandrew/Data-Walk-Extracted/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Add Log::Shiras <https://metacpan.org/module/Log::Shiras> debugging in exchange for
Smart::Comments <https://metacpan.org/module/Smart::Comments>
.Sp
\&\fB2.\fR Support grafting through class instance nodes (can \- should you even do this?)
.Sp
\&\fB3.\fR Support grafting through CodeRef nodes (can \- should you even do this?)
.Sp
\&\fB4.\fR Support grafting through \s-1REF\s0 nodes
.Sp
\&\fB5.\fR A possible depth check to ensure the scion is deeper than the tree_ref
.Sp
.RS 4
Implemented with an attribute that turns the feature on and off.  The goal
would be to eliminate unintentional swapping of small branches for large branches.
This feature has some overhead downside and may not be usefull so I'm not sure
if it makes sence yet.
.RE
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund.
.SH "Dependencies"
.IX Header "Dependencies"
.RS 4
version
.Sp
Moose::Role
.Sp
.RS 4
\&\fBrequires\fR
.IP "_process_the_data" 4
.IX Item "_process_the_data"
.PD 0
.IP "_dispatch_method" 4
.IX Item "_dispatch_method"
.IP "_build_branch" 4
.IX Item "_build_branch"
.RE
.RS 4
.RE
.RE
.RS 4
.PD
.Sp
MooseX::Types::Moose
.Sp
Data::Walk::Extracted
.Sp
Data::Walk::Extracted::Dispatch
.Sp
Carp \- cluck
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Log::Shiras::Unhide \- Can use to unhide '###InternalExtracteDGrafT' tags
.Sp
Log::Shiras::TapWarn \- to manage the output of exposed '###InternalExtracteDGrafT' lines
.Sp
Data::Dumper \- used in the '###InternalExtracteDGrafT' lines
.RE
