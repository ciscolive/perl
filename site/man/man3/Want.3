.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Want 3"
.TH Want 3 "2016-02-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Want \- A generalisation of "wantarray"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Want;
\&  sub foo :lvalue {
\&      if    (want(qw\*(AqLVALUE ASSIGN\*(Aq)) {
\&        print "We have been assigned ", want(\*(AqASSIGN\*(Aq);
\&        lnoreturn;
\&      }
\&      elsif (want(\*(AqLIST\*(Aq)) {
\&        rreturn (1, 2, 3);
\&      }
\&      elsif (want(\*(AqBOOL\*(Aq)) {
\&        rreturn 0;
\&      }
\&      elsif (want(qw\*(AqSCALAR !REF\*(Aq)) {
\&        rreturn 23;
\&      }
\&      elsif (want(\*(AqHASH\*(Aq)) {
\&        rreturn { foo => 17, bar => 23 };
\&      }
\&      return;  # You have to put this at the end to keep the compiler happy
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module generalises the mechanism of the \fBwantarray\fR function,
allowing a function to determine in some detail how its return value
is going to be immediately used.
.SS "Top-level contexts:"
.IX Subsection "Top-level contexts:"
The three kinds of top-level context are well known:
.IP "\fB\s-1VOID\s0\fR" 4
.IX Item "VOID"
The return value is not being used in any way. It could be an entire statement
like \f(CW\*(C`foo();\*(C'\fR, or the last component of a compound statement which is itself in
void context, such as \f(CW\*(C`$test || foo();\*(C'\fRn. Be warned that the last statement
of a subroutine will be in whatever context the subroutine was called in, because
the result is implicitly returned.
.IP "\fB\s-1SCALAR\s0\fR" 4
.IX Item "SCALAR"
The return value is being treated as a scalar value of some sort:
.Sp
.Vb 6
\&  my $x = foo();
\&  $y += foo();
\&  print "123" x foo();
\&  print scalar foo();
\&  warn foo()\->{23};
\&  ...etc...
.Ve
.IP "\fB\s-1LIST\s0\fR" 4
.IX Item "LIST"
The return value is treated as a list of values:
.Sp
.Vb 7
\&  my @x = foo();
\&  my ($x) = foo();
\&  () = foo();           # even though the results are discarded
\&  print foo();
\&  bar(foo());           # unless the bar subroutine has a prototype
\&  print @hash{foo()};   # (hash slice)
\&  ...etc...
.Ve
.SS "Lvalue subroutines:"
.IX Subsection "Lvalue subroutines:"
The introduction of \fBlvalue subroutines\fR in Perl 5.6 has created a new type
of contextual information, which is independent of those listed above. When
an lvalue subroutine is called, it can either be called in the ordinary way
(so that its result is treated as an ordinary value, an \fBrvalue\fR); or else
it can be called so that its result is considered updatable, an \fBlvalue\fR.
.PP
These rather arcane terms (lvalue and rvalue) are easier to remember if you
know why they are so called. If you consider a simple assignment statement
\&\f(CW\*(C`left = right\*(C'\fR, then the \fBl\fReft-hand side is an \fBl\fRvalue and the \fBr\fRight-hand
side is an \fBr\fRvalue.
.PP
So (for lvalue subroutines only) there are two new types of context:
.IP "\fB\s-1RVALUE\s0\fR" 4
.IX Item "RVALUE"
The caller is definitely not trying to assign to the result:
.Sp
.Vb 3
\&  foo();
\&  my $x = foo();
\&  ...etc...
.Ve
.Sp
If the sub is declared without the \f(CW\*(C`:lvalue\*(C'\fR attribute, then it will
\&\fIalways\fR be in \s-1RVALUE\s0 context.
.Sp
If you need to return values from an lvalue subroutine in \s-1RVALUE\s0 context,
you should use the \f(CW\*(C`rreturn\*(C'\fR function rather than an ordinary \f(CW\*(C`return\*(C'\fR.
Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
.IP "\fB\s-1LVALUE\s0\fR" 4
.IX Item "LVALUE"
Either the caller is directly assigning to the result of the sub call:
.Sp
.Vb 2
\&  foo() = $x;
\&  foo() = (1, 1, 2, 3, 5, 8);
.Ve
.Sp
or the caller is making a reference to the result, which might be assigned to
later:
.Sp
.Vb 1
\&  my $ref = \e(foo());   # Could now have: $$ref = 99;
\&  
\&  # Note that this example imposes LIST context on the sub call.
\&  # So we\*(Aqre taking a reference to the first element to be
\&  # returned _in list context_.
\&  # If we want to call the function in scalar context, we can
\&  # do it like this:
\&  my $ref = \e(scalar foo());
.Ve
.Sp
or else the result of the function call is being used as part of the argument list
for \fIanother\fR function call:
.Sp
.Vb 3
\&  bar(foo());   # Will *always* call foo in lvalue context,
\&                # (provided that foo is an C<:lvalue> sub)
\&                # regardless of what bar actually does.
.Ve
.Sp
The reason for this last case is that bar might be a sub which modifies its
arguments. They're rare in contemporary Perl code, but perfectly possible:
.Sp
.Vb 3
\&  sub bar {
\&    $_[0] = 23;
\&  }
.Ve
.Sp
(This is really a throwback to Perl 4, which didn't support explicit references.)
.SS "Assignment context:"
.IX Subsection "Assignment context:"
The commonest use of lvalue subroutines is with the assignment statement:
.PP
.Vb 2
\&  size() = 12;
\&  (list()) = (1..10);
.Ve
.PP
A useful motto to remember when thinking about assignment statements is
\&\fIcontext comes from the left\fR. Consider code like this:
.PP
.Vb 4
\&  my ($x, $y, $z);
\&  sub list () :lvalue { ($x, $y, $z) }
\&  list = (1, 2, 3);
\&  print "\e$x = $x; \e$y = $y; \e$z = $z\en";
.Ve
.PP
This prints \f(CW\*(C`$x = ; $y = ; $z = 3\*(C'\fR, which may not be what you were expecting.
The reason is that the assignment is in scalar context, so the comma operator
is in scalar context too, and discards all values but the last. You can fix
it by writing \f(CW\*(C`(list) = (1,2,3);\*(C'\fR instead.
.PP
If your lvalue subroutine is used on the left of an assignment statement,
it's in \fB\s-1ASSIGN\s0\fR context.  If \s-1ASSIGN\s0 is the only argument to \f(CW\*(C`want()\*(C'\fR, then
it returns a reference to an array of the value(s) of the right-hand side.
.PP
In this case, you should return with the \f(CW\*(C`lnoreturn\*(C'\fR function, rather than
an ordinary \f(CW\*(C`return\*(C'\fR.
.PP
This makes it very easy to write lvalue subroutines which do clever things:
.PP
.Vb 10
\&  use Want;
\&  use strict;
\&  sub backstr :lvalue {
\&    if (want(qw\*(AqLVALUE ASSIGN\*(Aq)) {
\&      my ($a) = want(\*(AqASSIGN\*(Aq);
\&      $_[0] = reverse $a;
\&      lnoreturn;
\&    }
\&    elsif (want(\*(AqRVALUE\*(Aq)) {
\&      rreturn scalar reverse $_[0];
\&    }
\&    else {
\&      carp("Not in ASSIGN context");
\&    }
\&    return
\&  }
\& 
\&  print "foo \-> ", backstr("foo"), "\en";        # foo \-> oof
\&  backstr(my $robin) = "nibor";
\&  print "\e$robin is now $robin\en";              # $robin is now robin
.Ve
.PP
Notice that you need to put a (meaningless) return
statement at the end of the function, otherwise you will get the
error
\&\fICan't modify non-lvalue subroutine call in lvalue subroutine return\fR.
.PP
The only way to write that \f(CW\*(C`backstr\*(C'\fR function without using Want is to return
a tied variable which is tied to a custom class.
.SS "Reference context:"
.IX Subsection "Reference context:"
Sometimes in scalar context the caller is expecting a reference of some sort
to be returned:
.PP
.Vb 5
\&    print foo()\->();     # CODE reference expected
\&    print foo()\->{bar};  # HASH reference expected
\&    print foo()\->[23];   # ARRAY reference expected
\&    print ${foo()};      # SCALAR reference expected
\&    print foo()\->bar();  # OBJECT reference expected
\&    
\&    my $format = *{foo()}{FORMAT} # GLOB reference expected
.Ve
.PP
You can check this using conditionals like \f(CW\*(C`if (want(\*(AqCODE\*(Aq))\*(C'\fR.
There is also a function \f(CW\*(C`wantref()\*(C'\fR which returns one of the strings
\&\*(L"\s-1CODE\*(R", \*(L"HASH\*(R", \*(L"ARRAY\*(R", \*(L"GLOB\*(R", \*(L"SCALAR\*(R"\s0 or \*(L"\s-1OBJECT\*(R"\s0; or the empty string
if a reference is not expected.
.PP
Because \f(CW\*(C`want(\*(AqSCALAR\*(Aq)\*(C'\fR is already used to select ordinary scalar context,
you have to use \f(CW\*(C`want(\*(AqREFSCALAR\*(Aq)\*(C'\fR to find out if a \s-1SCALAR\s0 reference is
expected. Or you could use \f(CW\*(C`want(\*(AqREF\*(Aq) eq \*(AqSCALAR\*(Aq\*(C'\fR of course.
.PP
Be warned that \f(CW\*(C`want(\*(AqARRAY\*(Aq)\*(C'\fR is a \fBvery\fR different thing from \f(CW\*(C`wantarray()\*(C'\fR.
.SS "Item count"
.IX Subsection "Item count"
Sometimes in list context the caller is expecting a particular number of items
to be returned:
.PP
.Vb 1
\&    my ($x, $y) = foo();   # foo is expected to return two items
.Ve
.PP
If you pass a number to the \f(CW\*(C`want\*(C'\fR function, then it will return true or false
according to whether at least that many items are wanted. So if we are in the
definition of a sub which is being called as above, then:
.PP
.Vb 3
\&    want(1) returns true
\&    want(2) returns true
\&    want(3) returns false
.Ve
.PP
Sometimes there is no limit to the number of items that might be used:
.PP
.Vb 2
\&    my @x = foo();
\&    do_something_with( foo() );
.Ve
.PP
In this case, \f(CWwant(2)\fR, \f(CW\*(C`want(100)\*(C'\fR, \f(CW\*(C`want(1E9)\*(C'\fR and so on will all return
true; and so will \f(CW\*(C`want(\*(AqInfinity\*(Aq)\*(C'\fR.
.PP
The \f(CW\*(C`howmany\*(C'\fR function can be used to find out how many items are wanted.
If the context is scalar, then \f(CWwant(1)\fR returns true and \f(CW\*(C`howmany()\*(C'\fR returns
1. If you want to check whether your result is being assigned to a singleton
list, you can say \f(CW\*(C`if (want(\*(AqLIST\*(Aq, 1)) { ... }\*(C'\fR.
.SS "Boolean context"
.IX Subsection "Boolean context"
Sometimes the caller is only interested in the truth or falsity of a function's
return value:
.PP
.Vb 3
\&    if (everything_is_okay()) {
\&        # Carry on
\&    }
\&    
\&    print (foo() ? "ok\en" : "not ok\en");
.Ve
.PP
In the following example, all subroutine calls are in \s-1BOOL\s0 context:
.PP
.Vb 1
\&    my $x = ( (foo() && !bar()) xor (baz() || quux()) );
.Ve
.PP
Boolean context, like the reference contexts above, is considered to be a subcontext
of \s-1SCALAR.\s0
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "want(\s-1SPECIFIERS\s0)" 4
.IX Item "want(SPECIFIERS)"
This is the primary interface to this module, and should suffice for most
purposes. You pass it a list of context specifiers, and the return value
is true whenever all of the specifiers hold.
.Sp
.Vb 3
\&    want(\*(AqLVALUE\*(Aq, \*(AqSCALAR\*(Aq);   # Are we in scalar lvalue context?
\&    want(\*(AqRVALUE\*(Aq, 3);          # Are at least three rvalues wanted?
\&    want(\*(AqARRAY\*(Aq);      # Is the return value used as an array ref?
.Ve
.Sp
You can also prefix a specifier with an exclamation mark to indicate that you
\&\fBdon't\fR want it to be true
.Sp
.Vb 5
\&    want(2, \*(Aq!3\*(Aq);              # Caller wants exactly two items.
\&    want(qw\*(AqREF !CODE !GLOB\*(Aq);  # Expecting a reference that
\&                                #   isn\*(Aqt a CODE or GLOB ref.
\&    want(100, \*(Aq!Infinity\*(Aq);     # Expecting at least 100 items,
\&                                #   but there is a limit.
.Ve
.Sp
If the \fI\s-1REF\s0\fR keyword is the only parameter passed, then the type of reference will be
returned.  This is just a synonym for the \f(CW\*(C`wantref\*(C'\fR function: it's included because
you might find it useful if you don't want to pollute your namespace by importing
several functions, and to conform to Damian Conway's suggestion in \s-1RFC 21.\s0
.Sp
Finally, the keyword \fI\s-1COUNT\s0\fR can be used, provided that it's the only keyword
you pass. Mixing \s-1COUNT\s0 with other keywords is an error. This is a synonym for the
\&\f(CW\*(C`howmany\*(C'\fR function.
.Sp
A full list of the permitted keyword is in the \fB\s-1ARGUMENTS\s0\fR section below.
.IP "rreturn" 4
.IX Item "rreturn"
Use this function instead of \f(CW\*(C`return\*(C'\fR from inside an lvalue subroutine when
you know that you're in \s-1RVALUE\s0 context. If you try to use a normal \f(CW\*(C`return\*(C'\fR,
you'll get a compile-time error in Perl 5.6.1 and above unless you return an
lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
will once again work.)
.IP "lnoreturn" 4
.IX Item "lnoreturn"
Use this function instead of \f(CW\*(C`return\*(C'\fR from inside an lvalue subroutine when
you're in \s-1ASSIGN\s0 context and you've used \f(CW\*(C`want(\*(AqASSIGN\*(Aq)\*(C'\fR to carry out the
appropriate action.
.Sp
If you use \f(CW\*(C`rreturn\*(C'\fR or \f(CW\*(C`lnoreturn\*(C'\fR, then you have to put a bare \f(CW\*(C`return;\*(C'\fR
at the very end of your lvalue subroutine, in order to stop the Perl compiler
from complaining. Think of it as akin to the \f(CW\*(C`1;\*(C'\fR that you have to put at the
end of a module. (Note: this is no longer true in Perl 5.16.)
.IP "\fBhowmany()\fR" 4
.IX Item "howmany()"
Returns the \fIexpectation count\fR, i.e. the number of items expected. If the 
expectation count is undefined, that
indicates that an unlimited number of items might be used (e.g. the return
value is being assigned to an array). In void context the expectation count
is zero, and in scalar context it is one.
.Sp
The same as \f(CW\*(C`want(\*(AqCOUNT\*(Aq)\*(C'\fR.
.IP "\fBwantref()\fR" 4
.IX Item "wantref()"
Returns the type of reference which the caller is expecting, or the empty string
if the caller isn't expecting a reference immediately.
.Sp
The same as \f(CW\*(C`want(\*(AqREF\*(Aq)\*(C'\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 8
\&    use Carp \*(Aqcroak\*(Aq;
\&    use Want \*(Aqhowmany\*(Aq;
\&    sub numbers {
\&        my $count = howmany();
\&        croak("Can\*(Aqt make an infinite list") if !defined($count);
\&        return (1..$count);
\&    }
\&    my ($one, $two, $three) = numbers();
\&    
\&    
\&    use Want \*(Aqwant\*(Aq;
\&    sub pi () {
\&        if    (want(\*(AqARRAY\*(Aq)) {
\&            return [3, 1, 4, 1, 5, 9];
\&        }
\&        elsif (want(\*(AqLIST\*(Aq)) {
\&            return (3, 1, 4, 1, 5, 9);
\&        }
\&        else {
\&            return 3;
\&        }
\&    }
\&    print pi\->[2];      # prints 4
\&    print ((pi)[3]);    # prints 1
.Ve
.SH "ARGUMENTS"
.IX Header "ARGUMENTS"
The permitted arguments to the \f(CW\*(C`want\*(C'\fR function are listed below.
The list is structured so that sub-contexts appear below the context that they
are part of.
.IP "\(bu" 4
\&\s-1VOID\s0
.IP "\(bu" 4
\&\s-1SCALAR\s0
.RS 4
.IP "\(bu" 4
\&\s-1REF\s0
.RS 4
.IP "\(bu" 4
\&\s-1REFSCALAR\s0
.IP "\(bu" 4
\&\s-1CODE\s0
.IP "\(bu" 4
\&\s-1HASH\s0
.IP "\(bu" 4
\&\s-1ARRAY\s0
.IP "\(bu" 4
\&\s-1GLOB\s0
.IP "\(bu" 4
\&\s-1OBJECT\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\s-1BOOL\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\s-1LIST\s0
.RS 4
.IP "\(bu" 4
\&\s-1COUNT\s0
.IP "\(bu" 4
<number>
.IP "\(bu" 4
Infinity
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\s-1LVALUE\s0
.RS 4
.IP "\(bu" 4
\&\s-1ASSIGN\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\s-1RVALUE\s0
.SH "EXPORT"
.IX Header "EXPORT"
The \f(CW\*(C`want\*(C'\fR and \f(CW\*(C`rreturn\*(C'\fR functions are exported by default.
The \f(CW\*(C`wantref\*(C'\fR and/or \f(CW\*(C`howmany\*(C'\fR functions can also be imported:
.PP
.Vb 1
\&  use Want qw\*(Aqwant howmany\*(Aq;
.Ve
.PP
If you don't import these functions, you must qualify their names as (e.g.)
\&\f(CW\*(C`Want::wantref\*(C'\fR.
.SH "INTERFACE"
.IX Header "INTERFACE"
This module is still under development, and the public interface may change in
future versions. The \f(CW\*(C`want\*(C'\fR function can now be regarded as stable.
.PP
I'd be interested to know how you're using this module.
.SH "SUBTLETIES"
.IX Header "SUBTLETIES"
There are two different levels of \fB\s-1BOOL\s0\fR context. \fIPure\fR boolean context
occurs in conditional expressions, and the operands of the \f(CW\*(C`xor\*(C'\fR and \f(CW\*(C`!\*(C'\fR/\f(CW\*(C`not\*(C'\fR
operators.
Pure boolean context also propagates down through the \f(CW\*(C`&&\*(C'\fR and \f(CW\*(C`||\*(C'\fR operators.
.PP
However, consider an expression like \f(CW\*(C`my $x = foo() && "yes"\*(C'\fR. The subroutine
is called in \fIpseudo\fR\-boolean context \- its return value isn't \fBentirely\fR
ignored, because the undefined value, the empty string and the integer 0 are
all false.
.PP
At the moment \f(CW\*(C`want(\*(AqBOOL\*(Aq)\*(C'\fR is true in either pure or pseudo boolean
context. Let me know if this is a problem.
.SH "BUGS"
.IX Header "BUGS"
.Vb 1
\& * Doesn\*(Aqt work from inside a tie\-handler.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Houston, <robin@cpan.org>
.PP
Thanks to Damian Conway for encouragement and good suggestions,
and Father Chrysostomos for a patch.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\*(L"wantarray\*(R" in perlfunc
.IP "\(bu" 4
Perl6 \s-1RFC 21,\s0 by Damian Conway.
http://dev.perl.org/rfc/21.html
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2012, Robin Houston. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as Perl itself.
