.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Prometheus::Metric 3"
.TH Net::Prometheus::Metric 3 "2020-07-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Net::Prometheus::Metric" \- the base class for observed metrics
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides the basic methods shared by the concrete subclasses,
.IP "\(bu" 2
Net::Prometheus::Gauge \- a snapshot value-reporting metric
.IP "\(bu" 2
Net::Prometheus::Counter \- a monotonically-increasing counter metric
.IP "\(bu" 2
Net::Prometheus::Summary \- summarise individual numeric observations
.IP "\(bu" 2
Net::Prometheus::Histogram \- count the distribution of numeric observations
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 4
\&   $metric = Net::Prometheus::Metric\->new(
\&      name => $name,
\&      help => $help,
\&   )
.Ve
.PP
The constructor is not normally used directly by instrumented code. Instead it
is more common to use one of the \f(CW\*(C`new_*\*(C'\fR methods on the containing
Net::Prometheus client instance so that the new metric is automatically
registered as a collector, and gets exported by the render method.
.PP
.Vb 4
\&   $metric = $prometheus\->new_counter(
\&      name => $name,
\&      help => $help,
\&   )
.Ve
.PP
In either case, it returns a newly-constructed metric.
.PP
Takes the following named arguments:
.IP "namespace => \s-1STR\s0" 4
.IX Item "namespace => STR"
.PD 0
.IP "subsystem => \s-1STR\s0" 4
.IX Item "subsystem => STR"
.PD
Optional strings giving the namespace and subsystem name parts of the variable
name.
.IP "name => \s-1STR\s0" 4
.IX Item "name => STR"
The basename of the exported variable.
.IP "help => \s-1STR\s0" 4
.IX Item "help => STR"
Descriptive help text for the variable.
.IP "labels => \s-1ARRAY\s0 of \s-1STR\s0" 4
.IX Item "labels => ARRAY of STR"
Optional \s-1ARRAY\s0 reference giving the names of labels for the metric.
.SH "METHODS"
.IX Header "METHODS"
.SS "fullname"
.IX Subsection "fullname"
.Vb 1
\&   $fullname = $metric\->fullname
.Ve
.PP
Returns the full name for the metric. This is formed by joining any of the
defined values for \f(CW\*(C`namespace\*(C'\fR, \f(CW\*(C`subsystem\*(C'\fR and \f(CW\*(C`name\*(C'\fR with \f(CW\*(Aq_\*(Aq\fR.
.SS "labelcount"
.IX Subsection "labelcount"
.Vb 1
\&   $labels = $metric\->labelcount
.Ve
.PP
Returns the number of labels defined for this metric.
.SS "labels"
.IX Subsection "labels"
.Vb 1
\&   $child = $metric\->labels( @values )
\&
\&   $child = $metric\->labels( { name => $value, name => $value, ... } )
.Ve
.PP
Returns a child metric to represent the general one with the given set of
labels. The label values may be provided either in a list corresponding to the
list of label names given at construction time, or by name in a single \s-1HASH\s0
reference.
.PP
The child instance supports the same methods to control the value of the
reported metric as the parent metric object, except that any label values are
already provided.
.PP
This object may be cached for efficiency.
.SS "make_sample"
.IX Subsection "make_sample"
.Vb 1
\&   $sample = $metric\->make_sample( $suffix, $labelkey, $value, $extralabels )
.Ve
.PP
Returns a new \*(L"Sample\*(R" in Net::Prometheus::Types structure to represent the
given value, by expanding the opaque \f(CW$labelkey\fR value into its actual label
names and values and appending the given suffix (which may be an empty string)
to the metric's fullname. If provided, the suffix will be separated by an
underscore \f(CW\*(Aq_\*(Aq\fR. If provided, \f(CW$extralabels\fR provides more label names and
values to be added to the sample.
.SS "samples"
.IX Subsection "samples"
.Vb 1
\&   @samples = $metric\->samples
.Ve
.PP
An abstract method in this class, this method is intended to be overridden by
subclasses.
.PP
Called during the value collection process, this method should return a list
of \*(L"Sample\*(R" in Net::Prometheus::Types instances containing the values to report
from this metric.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
