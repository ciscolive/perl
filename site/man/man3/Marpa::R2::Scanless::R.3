.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Scanless::R 3"
.TH Marpa::R2::Scanless::R 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Marpa::R2::Scanless::R \- Scanless interface recognizers
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 3
\&    my $recce = Marpa::R2::Scanless::R\->new( { grammar => $grammar } );
\&    my $self = bless { grammar => $grammar }, \*(AqMy_Actions\*(Aq;
\&    $self\->{recce} = $recce;
\&
\&    if ( not defined eval { $recce\->read($p_input_string); 1 }
\&        )
\&    {
\&        ## Add last expression found, and rethrow
\&        my $eval_error = $EVAL_ERROR;
\&        chomp $eval_error;
\&        die $self\->show_last_expression(), "\en", $eval_error, "\en";
\&    } ## end if ( not defined eval { $event_count = $recce\->read...})
\&
\&    my $value_ref = $recce\->value( $self );
\&    if ( not defined $value_ref ) {
\&        die $self\->show_last_expression(), "\en",
\&            "No parse was found, after reading the entire input\en";
\&    }
.Ve
.PP
.Vb 9
\&    package My_Actions;
\&    sub do_parens    { shift; return $_[1] }
\&    sub do_add       { shift; return $_[0] + $_[2] }
\&    sub do_subtract  { shift; return $_[0] \- $_[2] }
\&    sub do_multiply  { shift; return $_[0] * $_[2] }
\&    sub do_divide    { shift; return $_[0] / $_[2] }
\&    sub do_pow       { shift; return $_[0]**$_[2] }
\&    sub do_first_arg { shift; return shift; }
\&    sub do_script    { shift; return join q{ }, @_ }
.Ve
.SH "About this document"
.IX Header "About this document"
This page is the reference document for the recognizer objects
of Marpa's \s-1SLIF\s0 (Scanless interface).
.PP
The Scanless interface is so-called because
it does not require the application to supply a scanner (lexer).
The \s-1SLIF\s0 contains its own lexer,
one whose use is integrated into
its syntax.
In this document, use of the \s-1SLIF\s0's
internal scanner is called
\&\fBinternal scanning\fR.
.PP
The \s-1SLIF\s0 allows applications that find it useful to
do their own scanning.
When an application
bypasses the \s-1SLIF\s0's internal scanner
and does its own scanning,
this document calls it
\&\fBexternal scanning\fR.
An application can use
external scanning to supplement internal
scanning,
or to replace the \s-1SLIF\s0's internal scanner entirely.
.SH "The input stream"
.IX Header "The input stream"
The recognizer reads a virtual input stream.
By default, this
is identical to a physical input stream.
The physical input stream is
a Perl string passed as the first argument
to the \f(CW\*(C`$recce\->read()\*(C'\fR method method.
Once set by the \f(CW\*(C`read()\*(C'\fR method, the physical input
stream cannot be changed.
.PP
Physical input stream location is simply
the Perl \f(CW\*(C`pos()\*(C'\fR location
in the physical input string.
Physical input stream location may be zero,
but is never negative.
.PP
In this document,
the phrase \*(L"input stream\*(R" and
the word \*(L"stream\*(R",
unless otherwise specified,
refer to the physical input stream.
The phrase \*(L"input stream location\*(R" and
the word \*(L"location\*(R",
unless otherwise specified,
refer
to physical input stream location.
.PP
Virtual input streams complicate the idea of parse
location,
but they are essential for some applications.
Implementing the C language's pre-processor directives requires
either two passes, or
a virtual approach to the input.
And Perl here-documents cannot be parsed correctly
by an application which insists on moving forward
serially in the input.
The
\&\s-1SLIF\s0 allows applications to skip
backward and forward in the physical input stream,
and to read sections of the stream repeatedly.
.PP
Input streams are ordered sets of characters,
and the locations in them are
represented as the integers from 0 to \fIN\fR,
where \fIN+1\fR is the size of the set.
In this document, we will refer to ordered subsets of
contiguous locations as either \fBranges\fR or \fBspans\fR.
.SH "Ranges"
.IX Header "Ranges"
A range is an ordered set of contiguous locations
specified by start location and end location:
[\fIS ... E\fR].
A range is a subset of a \*(L"universe\*(R" \*(--
some larger ordered set of locations
0 to \fIN\fR.
In this document the larger sets,
or universes, will be
either physical input streams
or G1 location streams.
.PP
The start and end locations of the range
refer to locations
in its universe.
Negative locations
refer to a locations relative
to the end of the range's universe, so that
\&\-1 refers to the last location of the universe,
\&\-2 refers to the second-to-last location of the universe,
etc.
.SH "Spans"
.IX Header "Spans"
A span is an ordered set of contiguous locations
specified by start location and length:
[\fIS, L\fR].
A span is a subset of a universe of locations,
as was
described above for ranges.
.PP
The range corresponding to the span
[\fIS, L\fR] is [\fIS ... (S+L)\-1\fR].
The span corresponding to the range
[\fIS ... E\fR] is [\fIS, (E\-S)+1\fR].
A span with
a negative length
is interpreted as if it was the range
with that same pair of values.
.PP
In general, spans are more convenient for programming.
But when fencepost issues are important,
spans require a lot of mental arithmetic,
and a discussion that uses ranges is easier to follow.
.PP
As examples,
.IP "\(bu" 4
The entire input stream is the range \f(CW\*(C`[0 ... \-1]\*(C'\fR
and the span \f(CW\*(C`[0, \-1]\*(C'\fR.
.IP "\(bu" 4
The first 42 characters of the input stream are the range \f(CW\*(C`[0 ... 41]\*(C'\fR
and the span \f(CW\*(C`[0, 42]\*(C'\fR.
.IP "\(bu" 4
The entire input stream, except for the last character,
is the range \f(CW\*(C`[0 ... \-2]\*(C'\fR
and the span \f(CW\*(C`[0, \-2]\*(C'\fR.
.IP "\(bu" 4
The substring consisting only of the last character is
the range \f(CW\*(C`[\-1 ... \-1]\*(C'\fR and the span \f(CW\*(C`[\-1, 1]\*(C'\fR.
.IP "\(bu" 4
The substring which consists of the last 3 characters is
the range \f(CW\*(C`[\-3 ... \-1]\*(C'\fR
and the span \f(CW\*(C`[\-3,  3]\*(C'\fR.
.IP "\(bu" 4
The substring which consists
of only the third-to-last character
is the range \f(CW\*(C`[\-3 ... \-3]\*(C'\fR
and the span \f(CW\*(C`[\-3, 1]\*(C'\fR.
.SH "Internal scanning"
.IX Header "Internal scanning"
The virtual input stream is a series of input strings.
An input string is a substring
of the physical input stream.
By default the virtual input stream consists of
exactly one input string,
one which begins at location 0 in the physical input stream
and whose length is the length of the physical input stream.
.PP
The \s-1SLIF\s0 always starts scanning using the \f(CW\*(C`read()\*(C'\fR
method, and
the first input string is specified, implicitly or explicitly,
by the \f(CW\*(C`read()\*(C'\fR method.
When not specified, the
input string
for \f(CW\*(C`read()\*(C'\fR defaults to the range [\fI0 ... \-1\fR].
.PP
\&\f(CW\*(C`read()\*(C'\fR will return success when it reaches the end of its
input string, or when a \s-1SLIF\s0 parse event triggers.
(Parse events are described in
a separate
document.)
In many cases there are no parse events declared,
or none trigger.
If no parse event triggers
and the parse does not fail,
then \f(CW\*(C`read()\*(C'\fR will read to the end of string.
.PP
The \s-1SLIF\s0 tracks a \f(CW\*(C`current location\*(C'\fR in the physical input stream.
On return from
the \f(CW\*(C`read()\*(C'\fR method,
current location will depend on the reason for the return.
If a
\&\s-1SLIF\s0 parse event
triggered, the current location will be
the trigger location;
otherwise the current location will be at the end of the
input string.
.PP
The \f(CW\*(C`read()\*(C'\fR method may only be called once for a recognizer,
but internal scanning can be resumed with the \f(CW\*(C`resume()\*(C'\fR method.
The \f(CW\*(C`resume()\*(C'\fR method, as the name suggests,
resumes the internal scanning with a new input string.
This input string must always be a substring
of the physical input stream
that was specified to the \f(CW\*(C`read()\*(C'\fR method.
By default, the new input string runs from the current location
to the end of the physical input stream.
.PP
On successful return from the
\&\f(CW\*(C`resume()\*(C'\fR method,
the current location is set in the same way as it for the
\&\f(CW\*(C`read()\*(C'\fR method:
the trigger location, if an event triggered;
otherwise, the end of string.
The \f(CW\*(C`resume()\*(C'\fR method may be called repeatedly,
until the application considers the virtual input stream
complete.
More details are in the reference descriptions
of the
\&\f(CW\*(C`read()\*(C'\fR and
\&\f(CW\*(C`resume()\*(C'\fR methods, below.
.PP
When the application considers input complete,
and is ready to produce a parse value,
the \f(CW\*(C`$recce\->value()\*(C'\fR method method
is used.
In most cases, this is all that is needed.
But Marpa also allows repeated passes over the same input
with different settings.
More details on the semantics are provided in
a separate document.
.SH "External scanning"
.IX Header "External scanning"
External scanning is usually performed by reading lexemes using the
\&\f(CW\*(C`$recce\->lexeme_read()\*(C'\fR method, which
allows the reading of unambiguous lexemes.
If ambiguous lexemes are needed, then
the \f(CW\*(C`$recce\->lexeme_alternative()\*(C'\fR and
\&\f(CW\*(C`$recce\->lexeme_complete()\*(C'\fR methods can be used.
.PP
Scanning must always begin with a call
to the \f(CW\*(C`read()\*(C'\fR method,
so that, in a pedantic sense, scanning always begins with internal scanning.
But the first input string may be zero length:
.PP
.Vb 1
\&    $recce\->read( \e$string, 0, 0 );
.Ve
.PP
and there is no requirement that internal scanning ever be resumed.
.SS "External lexemes and the input stream"
.IX Subsection "External lexemes and the input stream"
For error message and other purposes,
even externally scanned lexemes
are required to correspond to a span of the input stream.
An external scanner
must set up a relationship to the input stream,
even if that relationship is completely artificial.
.PP
Here is
one very general way to deal with external lexemes
which have no natural mapping into
the physical input stream.
We will call what would ordinarily be the input string, the \*(L"natural input\*(R".
To form the physical input stream, we append these 7 characters:
"\f(CW\*(C`NO TEXT\*(C'\fR\*(L".
For example, if the natural input is \*(R"\f(CW\*(C`Hi! I am the real input\*(C'\fR",
then the physical input stream will be
.PP
.Vb 1
\&    "Hi! I am the real inputNO TEXT"
.Ve
.PP
To read the natural input,
we will use
an initial call to the \f(CW\*(C`read()\*(C'\fR method
of the form
\&\f(CW\*(C`$recce\->read($input_string, \-8)\*(C'\fR.
If we want to read a lexeme
which has no real relationship
to the natural input,
we can read it externally,
using a method call similar to
\&\f(CW\*(C`$recce\->lexeme_read($symbol_name, \-7, \-1, $value)\*(C'\fR.
.SH "G1 locations"
.IX Header "G1 locations"
In addition to input stream location,
the \s-1SLIF\s0 also tracks G1 location.
G1 locations run from 0 to \fIN\fR,
where \fIN+1\fR is the length of the input stream.
The conventions
and notation
for numbering G1 locations
and for describing G1 spans and ranges
are the same as for input stream locations.
.PP
G1 location can be ignored most of the time,
but it does become relevant
when tracing the G1 grammar,
and when dealing with ambiguous terminals.
(For those familiar with Marpa's internals,
the G1 location is the G1 Earley set index.)
.PP
Because lexemes may be ambiguous,
more than one lexeme may be read
at a single G1 location.
We can think of the lexemes read at a single
G1 location as a set \*(-- call it the \fBG1 lexeme set\fR,
or, for brevity, the \fBG1 set\fR.
If a lexeme is unambiguous,
its G1 set will contain exactly one lexeme.
.PP
G1 location can be thought of
as location in terms of
boundaries of G1 sets,
so that the
the first G1 set starts at G1 location 0
and ends at G1 location 1.
When we speak of a G1 set \fBat\fR G1 location \fIL\fR,
we refer to the G1 set ending at G1 location \fIL\fR.
That means that there is no G1 set at
G1 location 0.
.PP
As each G1 set is read,
G1 location
increases by one.
\&\fBG1 length\fR
is length calculated in terms of G1 locations.
For example, if a span of G1 locations which begin at G1 location
42 and has length 2,
it will contain a pair of G1 locations: G1 location 42 and G1 location 43.
.PP
Sometimes it is convenient to think of
a G1 location as corresponding to a single input stream location.
When this is the case,
what is meant is the location
at the end of physical input stream span:
\&\f(CW\*(C`$span_start+$span_length\*(C'\fR.
.SS "Literals and G1 spans"
.IX Subsection "Literals and G1 spans"
It is sometimes
useful to find the literal substring
of the physical input stream which corresponds to a span
of G1 locations.
If an application reads the physical stream in sequence within the G1 span,
Marpa \*(L"does what you mean\*(R".
For more complicated cases, the exact rules are described in
this section.
.PP
Except for G1 location zero,
every G1 location \fIX\fR corresponds
to one or more characters
in the physical input stream.
Let [\fIs(X) ... e(X)\fR] be
the physical input stream range that corresponds to
G1 location \fIX\fR.
Only two things are guaranteed about \fIs(X)\fR and \fIe(X)\fR as
a function of \fIX\fR:
.IP "\(bu" 4
\&\fIs(X)\fR and \fIe(X)\fR are not defined when \fIX\fR is zero.
.IP "\(bu" 4
It will always be the case that
\&\fIs(X) <= e(X)\fR.
.PP
In mapping ranges of G1 locations to ranges of physical
input stream locations, there are several complications:
.IP "\(bu" 4
There is a fencepost versus interval issue:
physical input stream locations correspond to characters,
but G1 locations are locations before and after characters.
.IP "\(bu" 4
Both kinds of locations are zero-based,
but G1 location 0 does not corresponds to a range in
the physical input stream.
.IP "\(bu" 4
Scanning is allowed to skip backward and forward,
so the mapping of G1 location to physical stream locations
is not necessarily monotonic.
For example, if \fIX\fR and \fIY\fR are G1 locations
such that \fIX < Y\fR,
it is possible that
\&\fIs(X) > e(Y)\fR.
.IP "\(bu" 4
Repeated scanning of the same physical input stream locations
is allowed, as well as overlaps.
For example, if \fIX\fR and \fIY\fR are G1 locations,
it is possible that
\&\fIs(X) < s(Y) < e(X) < e(Y)\fR.
.IP "\(bu" 4
Even when there is a monotonic function from G1 location to physical
input stream span,
there will usually be gaps.
For example, applications typically discard whitespace.
This means that if \fIW\fR is the physical input stream location of
a whitespace character,
there will be no G1 location \fIX\fR such that
\&\fIs(X) <= W <= e(X)\fR.
.PP
To cope with these situations,
the following rules are used when
translating G1 locations into literal substrings
of the physical input stream.
.IP "\(bu" 4
If [\fIX ... Y\fR] is a G1 range,
and
\&\fIs(X) < e(Y)\fR,
the literal will be
substring made of the characters in the
physical input stream range [\fIs(X) ... e(Y)\fR].
.IP "\(bu" 4
If \fIs(X) >= e(Y)\fR,
the literal will be the empty string.
.PP
For applications which read the physical input stream in lexical order,
without skipping forward,
the above rules will work as expected.
For other applications,
the above may be \*(L"close enough\*(R".
But some applications
may want to use custom logic to reassemble the input
from the physical input stream.
The \*(L"\fBliteral()\fR\*(R" method can assist in this process.
.SH "The life cycle of a recognizer"
.IX Header "The life cycle of a recognizer"
This describes the life cycle of a recognizer
which has only one parse series.
Your recognizer has only one parse series
unless it
calls the \f(CW\*(C`series_restart()\*(C'\fR method.
Use of multiple parse series is an advanced technique,
one which most applications will not need.
Full details about parse series are in
a separate document.
.SS "The Initial Phase"
.IX Subsection "The Initial Phase"
The \fBInitial Phase\fR
begins when the recognizer is created with the
calls the \f(CW\*(C`new()\*(C'\fR method.
It ends when
the \f(CW\*(C`read()\*(C'\fR method
is called.
It will also end, of course, if
the recognizer is destroyed,
but most applications will want to
continue into the next phase.
Very little can happen in this phase.
It is possible to change some recognizer settings
using the \f(CW\*(C`set()\*(C'\fR method.
.SS "The Reading Phase"
.IX Subsection "The Reading Phase"
The \fBReading Phase\fR of a recognizer
begins when
it calls the \f(CW\*(C`read()\*(C'\fR method.
It ends when it first calls
the \f(CW\*(C`value()\*(C'\fR method.
The Reading Phase will also end, of course, if
the recognizer is destroyed,
but most applications will want to
continue into the next phase.
During this phase, it is possible to add other
input strings to the virtual input,
by calling
the \f(CW\*(C`resume()\*(C'\fR method.
.SS "The Evaluation Phase"
.IX Subsection "The Evaluation Phase"
The \fBEvaluation Phase\fR of a \s-1SLIF\s0 recognizer
begins when
it first calls the \f(CW\*(C`value()\*(C'\fR method,
which returns the result of the first parse tree.
If there were no parses,
the \f(CW\*(C`value()\*(C'\fR method will return
a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
The \f(CW\*(C`value()\*(C'\fR method
may be called more than once during the Evaluation Phase.
The second and later calls of
the \f(CW\*(C`value()\*(C'\fR method will return
the result of the next parse tree.
When there are no more parse trees,
the \f(CW\*(C`value()\*(C'\fR method will return
a Perl \f(CW\*(C`undef\*(C'\fR
The \f(CW\*(C`resume()\*(C'\fR method should
\&\fBnot\fR be called during Evaluation Phase.
.SS "For more details"
.IX Subsection "For more details"
In the above, we have described the life cycle for
recognizers which have
only one parse series.
A recognizer will have only one parse series,
unless it calls
the \f(CW\*(C`series_restart()\*(C'\fR method.
.PP
Using multiple parse series,
an application can run
the \s-1SLIF\s0 recognizer several times on the same
virtual input stream.
More detail
about the recognizer's life cycle,
including a full treatment of parse series,
is in
a separate document.
.SH "Recognizer settings"
.IX Header "Recognizer settings"
The \fBrecognizer settings\fR are the named arguments
accepted by
the recognizer setting-aware methods.
The \fBrecognizer setting-aware methods\fR
are the \f(CW\*(C`new()\*(C'\fR,
\&\f(CW\*(C`set()\*(C'\fR and
\&\f(CW\*(C`series_restart()\*(C'\fR methods.
Not every recognizer setting-aware method accepts all of the settings.
The details are given below, by setting.
.SS "end"
.IX Subsection "end"
Most users will not need this setting.
The \f(CW\*(C`end\*(C'\fR setting
specifies the parse end, as a G1 location.
The default is for the parse to end where the input did,
so that the parse returned is of the entire virtual input stream.
The \f(CW\*(C`end\*(C'\fR setting is only allowed in
the \f(CW\*(C`new()\*(C'\fR
and \f(CW\*(C`series_restart()\*(C'\fR methods.
.SS "event_is_active"
.IX Subsection "event_is_active"
.Vb 6
\&    $slr = Marpa::R2::Scanless::R\->new(
\&        {   grammar           => $grammar,
\&            semantics_package => \*(AqMy_Actions\*(Aq,
\&            event_is_active   => { \*(Aqbefore c\*(Aq => 1, \*(Aqafter b\*(Aq => 0 }
\&        }
\&    );
.Ve
.PP
The \f(CW\*(C`event_is_active\*(C'\fR recognizer setting
changes the activation setting of events.
Its value should be a reference to a hash,
in which the key of every entry is an event name,
and its value is either 0 or 1.
If the value is 1,
the event named in the hash key will be activated
when the recognizer starts.
If the value is 0,
the event named in the hash key will be inactive
when the recognizer starts.
The \f(CW\*(C`event_is_active\*(C'\fR setting is only allowed
with the recognizer's \f(CW\*(C`new() method\*(C'\fR.
.PP
The setting in the 
\&\f(CW\*(C`event_is_active\*(C'\fR hash
overrides the activation setting in the grammar.
The setting will be in effect
before events at earleme 0 are triggered,
and before any of the input stream is read.
The \f(CW\*(C`activate()\*(C'\fR method
can also be used to change an event's activation
setting for events that trigger after earleme 0.
But
events at earleme 0
trigger during
the recognizer's \f(CW\*(C`new() method\*(C'\fR \*(--
they can not be affected
by calls of the \f(CW\*(C`activate()\*(C'\fR method.
.PP
If an event is initialized to inactive
in the grammar,
the \f(CW\*(C`event_is_active\*(C'\fR recognizer setting
is the only way
for a recognizer
to allow that event to be active
at earleme 0.
Similarly,
if an event is initialized to active
in the grammar,
the \f(CW\*(C`event_is_active\*(C'\fR recognizer setting
is the only way
for a recognizer
to set that event
to be inactive
at earleme 0.
.SS "exhaustion"
.IX Subsection "exhaustion"
The \f(CW\*(C`exhaustion\*(C'\fR recognizer setting
determines what happens when asynchronous parse exhaustion occurs.
Intuitively, \*(L"asynchronous\*(R" parse exhaustion is parse
exhaustion at a point when control would not normally
return to the application.
The \f(CW\*(C`exhaustion\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
For details
see the
description of exhaustion parse events.
.PP
The value
of the \f(CW\*(C`exhaustion\*(C'\fR recognizer setting
must be either "\f(CW\*(C`fatal\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`event\*(C'\fR\*(L".
\&\*(R"\f(CW\*(C`fatal\*(C'\fR\*(L" is the default.
If the value is \*(R"\f(CW\*(C`fatal\*(C'\fR\*(L",
asynchronous parse exhaustion is treated as an error,
and an exception is thrown.
If the value is \*(R"\f(CW\*(C`event\*(C'\fR",
an event occurs
as described in the
section on exhaustion parse events.
.SS "grammar"
.IX Subsection "grammar"
The value of the \f(CW\*(C`grammar\*(C'\fR setting must be
a \s-1SLIF\s0 grammar object.
The \f(CW\*(C`new()\*(C'\fR method is required to have
a \f(CW\*(C`grammar\*(C'\fR setting.
The \f(CW\*(C`grammar\*(C'\fR setting is only allowed
by the \f(CW\*(C`new() method\*(C'\fR.
Once the recognizer is created, the grammar cannot be
changed.
.SS "max_parses"
.IX Subsection "max_parses"
If non-zero, causes a fatal error when that number
of parse results is exceeded.
\&\f(CW\*(C`max_parses\*(C'\fR is useful to
limit \s-1CPU\s0 usage and output length when testing
and debugging.
Stable and production applications may
prefer to count the number of parses,
and take a less Draconian response when the
count is exceeded.
.PP
The value must be an integer.
If it is zero, there will be no
limit on the number of parse results returned.
The default is for
there to be no limit.
The \f(CW\*(C`max_parses\*(C'\fR setting is valid in all
calls of the recognizer setting-aware methods.
.SS "ranking_method"
.IX Subsection "ranking_method"
The \f(CW\*(C`ranking_method\*(C'\fR
is only allowed in
calls of the \f(CW\*(C`new()\*(C'\fR method.
The value must be a string:
one of "\f(CW\*(C`none\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`rule\*(C'\fR\*(L",
or \*(R"\f(CW\*(C`high_rule_only\*(C'\fR\*(L".
When the value is \*(R"\f(CW\*(C`none\*(C'\fR", Marpa returns the parse results
in arbitrary order.
This is the default.
.PP
The "\f(CW\*(C`rule\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`high_rule_only\*(C'\fR" ranking methods
allows the user
to control the order
in which parse results are returned by
the \f(CW\*(C`value\*(C'\fR method,
and to exclude some parse results from the parse series.
For details, see the document
on parse order.
.SS "rejection"
.IX Subsection "rejection"
The \f(CW\*(C`rejection\*(C'\fR recognizer setting
determines what happens when all tokens are rejected by the
G1 parser.
The \f(CW\*(C`rejection\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
The value must be either "\f(CW\*(C`fatal\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`event\*(C'\fR\*(L".
\&\*(R"\f(CW\*(C`fatal\*(C'\fR" is the default.
.PP
If the value is "\f(CW\*(C`fatal\*(C'\fR\*(L",
rejection of all tokens is treated as an error,
and an exception is thrown.
If the value is \*(R"\f(CW\*(C`event\*(C'\fR",
an event occurs
as described in the
section on rejection parse events.
.SS "semantics_package"
.IX Subsection "semantics_package"
Sets the semantic package for the recognizer.
This setting takes precedence
over any package implied by the blessing of the per-parse arguments to
the \s-1SLIF\s0 recognizer's \f(CW\*(C`value()\*(C'\fR method.
The \f(CW\*(C`semantics_package\*(C'\fR recognizer setting
is used when resolving action names to
fully qualified Perl names.
For more details on the \s-1SLIF\s0 semantics,
see the document on \s-1SLIF\s0
semantics.
.PP
The \f(CW\*(C`semantics_package\*(C'\fR setting is only allowed
when a new parse series is begun.
That is, it is only allowed in calls
of the \f(CW\*(C`new()\*(C'\fR
and \f(CW\*(C`series_restart()\*(C'\fR methods.
The \f(CW\*(C`semantics_package\*(C'\fR recognizer setting
should not be confused with the
\&\s-1SLIF\s0's
\&\f(CW\*(C`bless_package\*(C'\fR grammar setting.
The two are not closely related.
.SS "too_many_earley_items"
.IX Subsection "too_many_earley_items"
The \f(CW\*(C`too_many_earley_items\*(C'\fR setting is optional,
and very few applications will need it.
If specified, it sets the \fBEarley item warning threshold\fR to
a value other than its default.
If an Earley set becomes larger than the
Earley item warning threshold,
a recognizer event is generated,
and
a warning is printed to the trace file handle.
.PP
Marpa parses from any \s-1BNF,\s0
and can handle grammars and inputs which produce very large
Earley sets.
But parsing that involves very large Earley sets can be slow.
.PP
By default, Marpa calculates
an Earley item warning threshold
for the G1 recognizer
based on the size of the
G1 grammar,
and for each L0 recognizer based on the size
of the L0 grammar.
The default thresholds will never be less than 100.
The default is the result of considerable experience
and almost all users will be happy with it.
.PP
If the
Earley item warning threshold is changed from its default,
the change applies to both L0 and G1 \*(-- currently
there is no way to set them separately.
If the Earley item warning threshold is set to 0,
no recognizer event is generated,
and
warnings about large Earley sets are turned off.
An Earley item threshold warning almost always
indicates a serious issue,
and turning these warnings off will
rarely be something
that an application wants to do.
.PP
The \f(CW\*(C`too_many_earley_items\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
.SS "trace_terminals"
.IX Subsection "trace_terminals"
If non-zero, traces the lexemes \*(--
those tokens passed from the L0 parser to
the G1 parser.
This recognizer setting is the best way to follow
what the L0 parser is doing,
and it is also very helpful for tracing the G1 parser.
The \f(CW\*(C`trace_terminals\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
.SS "trace_values"
.IX Subsection "trace_values"
The value of the \f(CW\*(C`trace_values\*(C'\fR setting is a numeric trace level.
If the
numeric trace level is 1, Marpa prints tracing information as values
are computed in the evaluation stack.  A trace level of 0 turns
value tracing off, which is the default. Traces are written to the
trace file handle.
The \f(CW\*(C`trace_values\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
.SS "trace_file_handle"
.IX Subsection "trace_file_handle"
The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default, the trace file handle is inherited from the
grammar.
The \f(CW\*(C`trace_file_handle\*(C'\fR setting is allowed
in any call of any of the recognizer setting-aware methods.
.SH "Constructor"
.IX Header "Constructor"
.Vb 1
\&    my $recce = Marpa::R2::Scanless::R\->new( { grammar => $grammar } );
.Ve
.PP
The \f(CW\*(C`new()\*(C'\fR method is the constructor for \s-1SLIF\s0 recognizers.
The arguments
to the \f(CW\*(C`new()\*(C'\fR constructor must be one or more hashes of named arguments,
where each hash key is a recognizer setting.
The \f(CW\*(C`grammar\*(C'\fR recognizer setting is required.
All other recognizer settings are optional.
For more on recognizer settings,
see
the section describing them.
.SH "Basic mutators"
.IX Header "Basic mutators"
.SS "\fBambiguous()\fP"
.IX Subsection "ambiguous()"
.Vb 4
\&    if ( my $ambiguous_status = $recce\->ambiguous() ) {
\&        chomp $ambiguous_status;
\&        die "Parse is ambiguous\en", $ambiguous_status;
\&    }
.Ve
.PP
This method should be called after the \f(CW\*(C`read()\*(C'\fR method.
If there is exactly one parse, it returns the empty string.
If there is no parse, it returns a non-empty string indicating that fact.
If there are two or more parses,
it returns a non-empty string describing the ambiguity.
.PP
Applications should only test the returned string to see if it is
empty or non-empty.
The non-empty strings are intended only for reading by
humans \*(-- their exact format is subject to change.
.PP
When \f(CW\*(C`ambiguous()\*(C'\fR detects an ambiguous parse,
it puts
the recognizer into \*(L"forest mode\*(R",
so that it can examine the parse.
As long as the recognizer is in forest mode,
calls to the \f(CW\*(C`value()\*(C'\fR method
will produce fatal errors.
Forest mode can be cleared using the
\&\f(CW\*(C`series_restart()\*(C'\fR method.
This will start a new parse series in \*(L"tree mode\*(R",
which will allow calls to the
\&\f(CW\*(C`value()\*(C'\fR method
to succeed.
.SS "\fBread()\fP"
.IX Subsection "read()"
.Vb 1
\&    $recce\->read($p_input_string);
.Ve
.PP
.Vb 1
\&    $recce\->read( \e$string, 0, 0 );
.Ve
.PP
Given a pointer to a physical input stream and,
optionally, a span specifying an input string within it,
\&\f(CW\*(C`read()\*(C'\fR parses the input string according to the grammar.
\&\f(CW\*(C`read()\*(C'\fR returns success if it parses to the end
of the input string,
or if it triggers a \s-1SLIF\s0 parse event.
Only a single call to \f(CW\*(C`read()\*(C'\fR
is allowed for a \s-1SLIF\s0
recognizer.
.PP
The first argument of \f(CW\*(C`read()\*(C'\fR is a pointer to the physical
input stream which,
by default,
will be
exactly the same as the virtual input stream.
To specify the input string,
\&\f(CW\*(C`read()\*(C'\fR recognizes
optional second and third arguments and treats them
as the start and length
of a span of the physical input stream.
The default start location is zero.
The default length is \-1.
Negative locations and lengths are
interpreted as described above.
.PP
If a \s-1SLIF\s0 parse event occurs during the \f(CW\*(C`read()\*(C'\fR method,
the current location is set to the trigger location.
\&\s-1SLIF\s0 parse events are described in detail in
a separate document.
If no \s-1SLIF\s0 parse event triggers,
and the parse reaches the end of the input string without a
failure,
the current location is set to the end of the input string.
.PP
On success, \f(CW\*(C`read()\*(C'\fR returns the current
physical input stream location.
This value may be zero.
The call is considered successful
if it reaches the end of input string,
or if a \s-1SLIF\s0 parse event triggers.
On failure, \f(CW\*(C`read()\*(C'\fR throws an exception.
.SS "\fBseries_restart()\fP"
.IX Subsection "series_restart()"
.Vb 1
\&    $recce\->series_restart( { end => $i } );
.Ve
.PP
The \f(CW\*(C`series_restart()\*(C'\fR method ends the current parse series,
and starts another.
Parse series are described in another document.
The \f(CW\*(C`series_restart()\*(C'\fR method allows,
as optional arguments, hashes whose key-value pairs
are recognizer settings.
.PP
The \f(CW\*(C`series_restart()\*(C'\fR method
cannot change the \f(CW\*(C`grammar\*(C'\fR recognizer setting.
If any other recognizer setting is not specified explicitly,
it is reset to its default.
If an application wants an explicit recognizer setting to persist
into a new parse series,
it must specify that setting explicitly in the new parse series.
\&\f(CW\*(C`series_restart()\*(C'\fR is particularly useful with
the
\&\f(CW\*(C`end\*(C'\fR and \f(CW\*(C`semantics_package\*(C'\fR named arguments.
.PP
The \f(CW\*(C`series_restart()\*(C'\fR method
must be called before \f(CW\*(C`value()\*(C'\fR
when \f(CW\*(C`ambiguous()\*(C'\fR
detects an ambiguous parse and the application needs to get the parse values.
.SS "\fBset()\fP"
.IX Subsection "set()"
.Vb 1
\&    $recce\->set( { max_parses => 42 } );
.Ve
.PP
This method allows recognizer settings to be changed after a \s-1SLIF\s0
grammar is created.
The arguments to
\&\f(CW\*(C`set()\*(C'\fR must be one or more hashes whose key-value pairs
are recognizer settings and their values.
The allowed recognizer settings are
described above.
.SS "\fBvalue()\fP"
.IX Subsection "value()"
.Vb 1
\&    my $value_ref = $recce\->value( $self );
.Ve
.PP
The \f(CW\*(C`value\*(C'\fR method call evaluates the next parse tree
in the parse series,
and returns a reference to the parse result for that parse tree.
If there are no more parse trees,
the \f(CW\*(C`value\*(C'\fR method returns \f(CW\*(C`undef\*(C'\fR.
There are zero parse trees if there was no valid parse
of the input according to the grammar.
There will be more than one parse tree if the parse
was ambiguous.
.PP
The \f(CW\*(C`value()\*(C'\fR method allows one optional argument.
If provided, the argument
explicitly specifies the per-parse argument for the
parse tree.
This per-parse argument can be a Perl scalar of any type,
but the most useful
type for a per-parse argument is a reference
(blessed or unblessed) to a hash or to an array.
The per-parse argument,
if provided,
will be the first argument of all
Perl semantics closures.
When data does not conveniently fit into the bottom-up
flow of parse tree evaluation,
the per-parse argument
is useful for sharing it within
the tree.
Symbol tables are one example of the kind of data which parses often
require, but which it is not convenient to accumulate bottom-up.
.PP
If the \f(CW\*(C`semantics_package\*(C'\fR
setting of the \s-1SLIF\s0
recognizer was not specified,
Marpa will use the package into which the per-parse argument was blessed
as the semantics package.
(As a reminder, the semantics package is the package
in which Marpa looks for the parse's Perl semantic closures.)
.PP
When the per-parse argument of the \f(CW\*(C`value()\*(C'\fR method is the
source of the semantics package,
all calls to the \f(CW\*(C`value()\*(C'\fR method in the same
parse series must have a per-parse
argument that
specifies the same semantics package.
More precisely,
if the per-parse argument of the first
call of the \f(CW\*(C`value()\*(C'\fR method
in a parse series
is
the source of the semantics package,
it will be a fatal error if any subsequent
\&\f(CW\*(C`value()\*(C'\fR call in that parse series
.IP "\(bu" 4
does not have a per-parse argument;
.IP "\(bu" 4
if that per-parse argument is not blessed; or
.IP "\(bu" 4
if that per-parse argument is blessed into a different package.
.SH "Mutators for external scanning"
.IX Header "Mutators for external scanning"
.SS "\fBactivate()\fP"
.IX Subsection "activate()"
.Vb 1
\&        $recce\->activate($_, 0) for @events;
.Ve
.PP
The \f(CW\*(C`activate()\*(C'\fR method allows the recognizer to deactivate and reactivate
\&\s-1SLIF\s0 parse events.
\&\s-1SLIF\s0 parse events are described in
a separate document.
.PP
The \f(CW\*(C`activate()\*(C'\fR method takes two arguments.
The first is the name of an event, and the second (optional) argument is
0 or 1.
If the argument is 0, the event is deactivated.
If the argument is 1, the event is activated.
An argument of 1 is the default.
Since an \s-1SLIF\s0 recognizer always starts with all defined events
activated,
0 will probably be more common as the second argument to
\&\f(CW\*(C`activate()\*(C'\fR
.PP
Though they are not reported until the call of the
\&\f(CW\*(C`read()\*(C'\fR method,
location 0 events are triggered in the \s-1SLIF\s0 recognizer's
constructor,
before the \f(CW\*(C`activate()\*(C'\fR method can be called.
Currently there is no way to deactivate
location zero events.
.PP
The overhead imposed by events
can be reduced by using the \f(CW\*(C`activate()\*(C'\fR method.
But making many calls to
the \f(CW\*(C`activate()\*(C'\fR method purely for efficiency
purposes will be counter-productive.
Also, deactivated events still impose
some overhead, so if an event is never used,
it should be commented out in the \s-1SLIF DSL.\s0
.SS "\fBlexeme_alternative()\fP"
.IX Subsection "lexeme_alternative()"
.Vb 5
\&            if ( not defined $recce\->lexeme_alternative($token_name) ) {
\&                die
\&                    qq{Parser rejected token "$long_name" at position $start_of_lexeme, before "},
\&                    substr( $string, $start_of_lexeme, 40 ), q{"};
\&            }
.Ve
.PP
The \f(CW\*(C`lexeme_alternative()\*(C'\fR method
allows an external scanner to read
ambiguous tokens.
Most applications
will prefer the simpler \f(CW\*(C`lexeme_read()\*(C'\fR.
.PP
\&\f(CW\*(C`lexeme_alternative()\*(C'\fR takes one or two arguments.
The first argument,
which is required,
is the name of a symbol to be read
at the current location.
The second argument,
which is optional,
is the value of the symbol.
The value argument is interpreted as described for \f(CW\*(C`lexeme_read()\*(C'\fR.
.PP
Any number of tokens may be read using \f(CW\*(C`lexeme_alternative()\*(C'\fR
without advancing the current location.
This allows an application to use ambiguous tokens.
To complete reading at a G1 location,
and advance the current G1 location to the next G1 location,
use the \f(CW\*(C`lexeme_complete()\*(C'\fR method.
.PP
On success, returns a non-negative number,
which may be zero.
Returns \f(CW\*(C`undef\*(C'\fR if the token was rejected.
Failures are thrown as exceptions.
.SS "\fBlexeme_complete()\fP"
.IX Subsection "lexeme_complete()"
.Vb 3
\&            next TOKEN
\&                if $recce\->lexeme_complete( $start_of_lexeme,
\&                        ( length $lexeme ) );
.Ve
.PP
The \f(CW\*(C`lexeme_complete()\*(C'\fR method allows an external scanner to read
ambiguous tokens.
It completes the reading of a set of tokens specified by
one or more calls of the \f(CW\*(C`lexeme_alternative()\*(C'\fR
method
at a G1 location.
Most applications
will prefer the simpler \f(CW\*(C`lexeme_read()\*(C'\fR method.
.PP
The \f(CW\*(C`lexeme_complete()\*(C'\fR method
requires two arguments,
which represent the start and length parameters of
a span in the physical input stream.
The span is interpreted,
and G1 location and current input stream location
are adjusted,
as described for
the \f(CW\*(C`lexeme_read()\*(C'\fR method.
.PP
\&\s-1SLIF\s0 parse events may occur during
the \f(CW\*(C`lexeme_complete()\*(C'\fR method,
as described for
the \f(CW\*(C`lexeme_read()\*(C'\fR method.
.PP
\&\fBReturn value:\fR
On success, \f(CW\*(C`lexeme_complete()\*(C'\fR
returns the new current location.
This will never be location zero, because a succesful
call of \f(CW\*(C`lexeme_complete()\*(C'\fR always advances the location.
Failure is thrown as an exception.
.SS "\fBlexeme_priority_set()\fP"
.IX Subsection "lexeme_priority_set()"
.Vb 1
\&        $recce\->lexeme_priority_set( \*(Aqprefix lexeme\*(Aq, \-1 );
.Ve
.PP
Takes as its first argument the name of a lexeme
and changes the priority of that lexeme to the value
of its second argument.
Both arguments are required.
.PP
Changing the lexeme priority is a very flexible
technique.
It can, in effect, allow an application
to switch lexers.
.PP
On success, returns the old priority value.
Failure is thrown.
.SS "\fBlexeme_read()\fP"
.IX Subsection "lexeme_read()"
.Vb 1
\&    $re\->lexeme_read( \*(Aqlstring\*(Aq, $start, $length, $value ) // die;
.Ve
.PP
The \f(CW\*(C`lexeme_read()\*(C'\fR method reads a single, unambiguous, lexeme.
It takes four arguments, only the first of which is required.
The first argument is the lexeme's symbol name.
The second and third arguments specify the span in
the physical input stream.
The last argument specifies the value of the lexeme.
.PP
In the span specified by
the second and third arguments,
the start location defaults to the current location.
If the
pause span
is defined,
and the start of the pause lexeme is
the same as the current location,
length defaults to the length of the pause span.
Otherwise length defaults to \-1.
Negative values are allowed and are interpreted
as described above.
.PP
The span will be interpreted as the section
of the physical input stream
that corresponds to the current G1 set.
(As a reminder, the G1 set consists
of the tokens read at single G1 location.)
This correspondence between the span and the token
may be artificial, but a span is defined for every token,
even if only by default.
.PP
The fourth argument specifies the lexeme value.
The lexeme value plays an important role in the \s-1SLIF\s0's semantics.
More details on the \s-1SLIF\s0's semantics are in
a document dedicated to them.
If the fourth argument
is omitted,
the lexeme value will be a string
containing the corresponding substring
of the input stream.
Omitting the value argument does not have the same
effect as passing an explicit Perl \f(CW\*(C`undef\*(C'\fR.
If the value argument is an explicit Perl \f(CW\*(C`undef\*(C'\fR,
the lexeme value will be a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 1
\&    $recce\->lexeme_read($symbol, $start, $length, $value)
.Ve
.PP
is roughly equivalent to
.PP
.Vb 2
\&    $recce\->lexeme_alternative($symbol, $value)
\&    $recce\->lexeme_complete($start, $length)
.Ve
.PP
Non-lexeme
\&\s-1SLIF\s0 parse events may trigger during the \f(CW\*(C`lexeme_read()\*(C'\fR method.
Lexeme \s-1SLIF\s0 parse events are ignored because they are designed
to allow switching over to external scanning, and
make no sense when external scanning is already in progress.
\&\s-1SLIF\s0 parse events are described in detail in
a separate document.
.PP
Current input stream location will be set
to \f(CW\*(C`$start+$length\*(C'\fR.
If a \s-1SLIF\s0 parse event triggers, current input stream location
will be set to the trigger location.
Currently the trigger location and
\&\f(CW\*(C`$start+$length\*(C'\fR will always be the same,
but that may change.
.PP
When successful,
\&\f(CW\*(C`lexeme_read()\*(C'\fR advances
the current G1 location by one.
The token read by \f(CW\*(C`lexeme_read()\*(C'\fR
will start at the previous G1 location
and end at the new current G1 location.
The new current location in the input stream will
be at the end location of the new lexeme.
.PP
On success, \f(CW\*(C`lexeme_read()\*(C'\fR returns the new current physical
input stream location.
This will never be location zero, because lexemes cannot be zero length.
If the token was rejected,
\&\f(CW\*(C`lexeme_read()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
Failure is thrown as an exception.
.SS "\fBresume()\fP"
.IX Subsection "resume()"
.Vb 10
\&    my $re = Marpa::R2::Scanless::R\->new(
\&        {   grammar           => $parser\->{grammar},
\&            semantics_package => \*(AqMarpaX::JSON::Actions\*(Aq
\&        }
\&    );
\&    my $length = length $string;
\&    for (
\&        my $pos = $re\->read( \e$string );
\&        $pos < $length;
\&        $pos = $re\->resume()
\&        )
\&    {
\&        my ( $start, $length ) = $re\->pause_span();
\&        my $value = substr $string, $start + 1, $length \- 2;
\&        $value = decode_string($value) if \-1 != index $value, \*(Aq\e\e\*(Aq;
\&        $re\->lexeme_read( \*(Aqlstring\*(Aq, $start, $length, $value ) // die;
\&    } ## end for ( my $pos = $re\->read( \e$string ); $pos < $length...)
\&    my $per_parse_arg = bless {}, \*(AqMarpaX::JSON::Actions\*(Aq;
\&    my $value_ref = $re\->value($per_parse_arg);
\&    return ${$value_ref};
.Ve
.PP
The \f(CW\*(C`resume()\*(C'\fR method resumes
the \s-1SLIF\s0's internal scanning,
as described
above.
A physical input stream must already have
been specified using the
\&\f(CW\*(C`$recce\->read()\*(C'\fR method.
The \f(CW\*(C`resume()\*(C'\fR method should only be called during the
Reading Phase.
.PP
The \f(CW\*(C`resume()\*(C'\fR method takes two optional arguments,
which represent the start and length parameters of
a span in the physical input stream.
The default start location is the current location.
The default length is \-1.
Negative arguments are interpreted
as described above.
.PP
If a \s-1SLIF\s0 parse event occurs during the \f(CW\*(C`read()\*(C'\fR method,
the current location is set to the trigger location.
\&\s-1SLIF\s0 parse events are described in detail in
a separate document.
If no \s-1SLIF\s0 parse event triggers,
and the parse reaches the end of the input string without a
failure,
the current location is set to the end of the input string.
.PP
\&\f(CW\*(C`resume()\*(C'\fR is considered successful
if it reads input to the end of input string,
or if a \s-1SLIF\s0 parse event triggers.
On success, \f(CW\*(C`resume()\*(C'\fR returns
the new current location.
On unthrown failure,
\&\f(CW\*(C`resume()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR.
Currently, all failures are thrown.
.SH "Accessors"
.IX Header "Accessors"
.SS "\fBambiguity_metric()\fP"
.IX Subsection "ambiguity_metric()"
.Vb 1
\&    my $ambiguity_metric = $recce\->ambiguity_metric();
.Ve
.PP
Succeeds and
returns 1 if there was an unambiguous parse,
in other words if there was exactly one parse tree.
Succeeds and
returns 2 or greater if the parse was ambiguous,
in other words if there was more than one parse tree.
Succeeds and returns 0 if there are no parse trees,
because parsing failed.
Currently, all other failures are thrown.
.PP
When the return value is 2 or greater,
the return value is \fBnot\fR necessarily the parse count.
Instead, it is a value which is subject to change.
and on which an application should not rely.
The intent was that, some day,
return values of 2 or greater would represent a \*(L"metric\*(R" which
was cheap to compute,
but which
estimated the degree of ambiguity in some useful way.
The best metric is, of course,
would be the exact parse count,
but determining that is expensive.
.SS "\fBcurrent_g1_location()\fP"
.IX Subsection "current_g1_location()"
.Vb 1
\&    my $current_g1_location = $recce\->current_g1_location();
.Ve
.PP
Returns the current G1 location.
.SS "\fBevents()\fP"
.IX Subsection "events()"
.Vb 5
\&        EVENT:
\&        for my $event ( @{ $recce\->events() } ) {
\&            my ($name) = @{$event};
\&            push @actual_events, $name;
\&        }
.Ve
.PP
The \f(CW\*(C`events()\*(C'\fR method takes no arguments,
and returns an array of \s-1SLIF\s0 parse event descriptors.
It returns the empty array
if there were no event.
.PP
\&\s-1SLIF\s0 parse events are described in detail in
a separate
document.
Each \s-1SLIF\s0 parse event descriptor is a reference to an array of one
or more elements.
The first element of every named event descriptor is a string
containing the name of the event.
Typically the name of the event is only element.
Other elements
will be as
described for each type of parse
event.
.PP
Any other \s-1SLIF\s0 recognizer mutator
may clear the events.
It is expected that
an application interested in events
will call
the \f(CW\*(C`events()\*(C'\fR method immediately after the
event-triggering event.
.PP
Named events are returned in order by type:
.IP "\(bu" 4
Lexeme events
.IP "\(bu" 4
Completion events
.IP "\(bu" 4
Nulling events
.IP "\(bu" 4
Prediction events
.PP
Within each type,
the order of events is arbitrary.
.SS "\fBexhausted()\fP"
.IX Subsection "exhausted()"
.Vb 1
\&    my $exhausted_status = $recce\->exhausted();
.Ve
.PP
The exhausted method returns a Perl true if parsing in a \s-1SLIF\s0
recognizer is
exhausted, and a Perl false otherwise. Parsing is exhausted when the
recognizer will not accept any further input.
.PP
Marpa usually \*(L"does what you mean\*(R" in case of parse exhaustion,
but this method
allows the recognizer's exhaustion status to be discovered directly.
Parse exhaustion is discussed in detail in
a separate document.
.SS "\fBg1_location_to_span()\fP"
.IX Subsection "g1_location_to_span()"
.Vb 2
\&        my ( $span_start, $span_length ) =
\&            $recce\->g1_location_to_span($g1_location);
.Ve
.PP
G1 locations do not correspond to a single input stream
location, but to a span of them.
The \f(CW\*(C`g1_location_to_span()\*(C'\fR method
returns an \fBarray\fR of two elements, representing a
span in the physical input stream.
G1 location 0 does not correspond to a input stream span so,
as a special case,
the input stream span for G1 location 0 is returned as (0,0).
.SS "\fBinput_length()\fP"
.IX Subsection "input_length()"
.Vb 1
\&    my $input_length = $recce\->input_length();
.Ve
.PP
The \f(CW\*(C`input_length()\*(C'\fR method accepts no arguments,
and returns the length of the physical input stream.
.SS "\fBlast_completed()\fP"
.IX Subsection "last_completed()"
.Vb 8
\&    sub show_last_expression {
\&        my ($self) = @_;
\&        my $recce = $self\->{recce};
\&        my ( $g1_start, $g1_length ) = $recce\->last_completed(\*(AqExpression\*(Aq);
\&        return \*(AqNo expression was successfully parsed\*(Aq if not defined $g1_start;
\&        my $last_expression = $recce\->substring( $g1_start, $g1_length );
\&        return "Last expression successfully parsed was: $last_expression";
\&    } ## end sub show_last_expression
.Ve
.PP
.Vb 1
\&    my ( $g1_start, $g1_length ) = $recce\->last_completed(\*(AqExpression\*(Aq);
.Ve
.PP
Given the name of a symbol,
\&\f(CW\*(C`last_completed()\*(C'\fR returns the 2\-element array
that is the G1 location
span of the most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match,
\&\f(CW\*(C`last_completed()\*(C'\fR returns the empty array in array context
and a Perl false in scalar context.
.SS "\fBlast_completed_span()\fP"
.IX Subsection "last_completed_span()"
.Vb 2
\&        my @longest_span = $recce\->last_completed_span(\*(Aqtarget\*(Aq);
\&        diag( "Actual target at $pos: ", $recce\->literal(@longest_span) ) if $verbose;
.Ve
.PP
Returns the most recent input stream span for a completed
instance of the symbol name
that is its first and only argument.
That argument is required.
The search for a completed instance of a symbol
can only succeed if the first argument
is the name
of the \s-1LHS\s0 symbol of some rule in the grammar.
For details on how the input stream span is determined,
see \*(L"Literals and G1 spans\*(R".
.PP
If more than one instance of the symbol
ends at the same location,
\&\f(CW\*(C`last_completed_span()\*(C'\fR returns the longest span.
If there is no symbol instance for the argument symbol,
\&\f(CW\*(C`last_completed_span()\*(C'\fR returns the empty array.
Other failures are thrown.
.SS "\fBline_column()\fP"
.IX Subsection "line_column()"
.Vb 2
\&    my ( $start, $span_length ) = $re\->pause_span();
\&    my ( $line,  $column )      = $re\->line_column($start);
.Ve
.PP
The \f(CW\*(C`line_column()\*(C'\fR method accepts one, optional, argument:
a location in the input stream.
The location defaults to the current location.
\&\f(CW\*(C`line_column()\*(C'\fR returns the corresponding line and column position,
as a 2\-element array.
The first element of the array is the line position,
and the second element is the column position.
.PP
Numbering of lines and columns is 1\-based,
following \s-1UNIX\s0 editor tradition.
Except at \fB\s-1EOVS\s0\fR
(the \fBend of the virtual input stream\fR),
the line and column will be that of an
actual character.
At \s-1EOVS\s0 the line number
will be that of the last line,
and the column number will be that of the last column
plus one.
Applications which want to treat \s-1EOVS\s0 as a special case
can test for it using the \f(CW\*(C`pos()\*(C'\fR method
and the \f(CW\*(C`input_length()\*(C'\fR method.
.PP
A line is considered to end with any newline sequence
as defined in the
Unicode Specification 4.0.0, Section 5.8.
Specifically, a line ends with one of the following:
.IP "\(bu" 4
a \s-1LF\s0 (line feed U+000A);
.IP "\(bu" 4
a \s-1CR\s0 (carriage return, U+000D), when it is not followed by a \s-1LF\s0;
.IP "\(bu" 4
a \s-1CRLF\s0 sequence (U+000D,U+000A);
.IP "\(bu" 4
a \s-1NEL\s0 (next line, U+0085);
.IP "\(bu" 4
a \s-1VT\s0 (vertical tab, U+000B);
.IP "\(bu" 4
a \s-1FF\s0 (form feed, U+000C);
.IP "\(bu" 4
a \s-1LS\s0 (line separator, U+2028) or
.IP "\(bu" 4
a \s-1PS\s0 (paragraph separator, U+2029).
.SS "\fBliteral()\fP"
.IX Subsection "literal()"
.Vb 1
\&    my $literal_string = $re\->literal( $start, $span_length );
.Ve
.PP
The \f(CW\*(C`literal()\*(C'\fR method accepts two arguments,
the start location and length of a span in the
physical input stream.
It returns the substring of the input stream
corresponding to that span.
.SS "\fBpause_lexeme()\fP"
.IX Subsection "pause_lexeme()"
.Vb 1
\&   my $lexeme = $re\->pause_lexeme();
.Ve
.PP
Use of this method is discouraged.
New applications should avoid it.
Instead the lexeme event should be declared as
a named event.
The named lexeme event can be set up in such
a way that
it uniquely identifies
the lexeme that triggered it.
\&\s-1SLIF\s0 parse events are described in detail in
a separate document.
.PP
The \f(CW\*(C`pause_lexeme()\*(C'\fR method accepts no arguments.
It returns the current
pause lexeme.
More than one lexeme may trigger at the same location,
in which case the choice of pause lexeme
is made arbitrarily.
This is one reason that the use of
\&\f(CW\*(C`pause_lexeme()\*(C'\fR is discouraged.
\&\f(CW\*(C`pause_lexeme()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR when
the pause lexeme is undefined.
.SS "\fBpause_span()\fP"
.IX Subsection "pause_span()"
.Vb 1
\&    my ( $start, $length ) = $re\->pause_span();
.Ve
.PP
The \f(CW\*(C`pause_span()\*(C'\fR method accepts no arguments,
and returns
the pause span
as a 2\-element array: start and length.
The \*(L"pause span\*(R" is
described in detail
in another document.
\&\f(CW\*(C`pause_span()\*(C'\fR returns a Perl \f(CW\*(C`undef\*(C'\fR if
the pause span is undefined.
.SS "\fBpos()\fP"
.IX Subsection "pos()"
.Vb 1
\&    my $pos = $recce\->pos();
.Ve
.PP
The \f(CW\*(C`pos()\*(C'\fR method accepts no arguments,
and returns the current physical input stream location.
.SS "\fBprogress()\fP"
.IX Subsection "progress()"
.Vb 1
\&    my $progress_output = $recce\->progress();
.Ve
.PP
Returns a reference to an array
that describes the progress
of a parse
at a location.
With no argument, \f(CW\*(C`progress()\*(C'\fR reports progress at
the current location.
If a G1 location is
given as its argument,
\&\f(CW\*(C`progress()\*(C'\fR reports progress at that G1 location.
Negative G1 locations are interpreted as
described above.
.PP
The progress reports returned by
the \f(CW\*(C`progress()\*(C'\fR method
identify rules by their G1 rule \s-1ID.
G1\s0 rule IDs can be converted to a list of the rule's
symbols using the \f(CW\*(C`rule()\*(C'\fR method
of the \s-1SLIF\s0 grammar.
Details on progress reports can be found in
their own document.
.SS "\fBshow_progress()\fP"
.IX Subsection "show_progress()"
.Vb 1
\&    my $show_progress_output = $recce\->show_progress();
.Ve
.PP
Returns a string showing
the progress of the G1 parse.
For a description of its output,
see Marpa::R2::Progress.
With no arguments,
the string contains reports for
the current location.
.PP
Locations can be specified as arguments to
\&\f(CW\*(C`show_progress()\*(C'\fR.
With a single integer argument \fIN\fR,
the string contains reports for G1 location \fIN\fR.
Two numeric arguments are interpreted as a
span of G1 locations,
and the returned string contains
reports for all locations in the span.
For example,
the method call \f(CW\*(C`$recce\->show_progress(0, \-1)\*(C'\fR
will print progress reports for the entire parse.
.PP
The arguments are G1 locations instead of physical input stream locations,
because G1 locations represent a unique point in the parse.
By contrast,
a single physical input stream location might be visited many times
by a \s-1SLIF\s0 recognizer.
.PP
The output is intended only for reading by humans.
The exact format is subject to change
and should not be relied on by applications.
.SS "\fBsubstring()\fP"
.IX Subsection "substring()"
.Vb 1
\&    my $last_expression = $recce\->substring( $g1_start, $g1_length );
.Ve
.PP
Given a G1 span \*(-- that is, a G1 start location and a length in G1 locations \*(--
the \f(CW\*(C`substring()\*(C'\fR method
returns a substring of the input
stream.
A G1 length of zero will produce the zero-length string.
.PP
The substring of the input stream is determined on the assumption
that the application reads the input in lexical order and
without gaps
except for whitespace and other normal discards.
When this is not the case, the substring is determined as
described above.
.SS "\fBterminals_expected()\fP"
.IX Subsection "terminals_expected()"
.Vb 1
\&    my @terminals_expected = @{$recce\->terminals_expected()};
.Ve
.PP
Returns a reference to a list of strings, where the strings are the
names of the lexemes acceptable at the current location.
The presence of a lexeme in this list means
that lexeme will be acceptable in the next call of the \f(CW\*(C`resume()\*(C'\fR method.
This is highly useful for Ruby Slippers parsing.
A more fine-tuned approach is to identify the lexemes of interest
and create \*(L"predicted symbol\*(R" events for them.
.PP
Some lexemes are specified in the G1 rules
of the \s-1DSL\s0 as quoted strings
or as character classes,
This is convenient,
but the lexemes created in this way
do not have real names.
Instead, internal names, like
\&\f(CW\*(C`[Lex\-1]\*(C'\fR are created for them,
and these are what appear in the
list of strings
returned by \f(CW\*(C`terminals_expected()\*(C'\fR.
If an application wants a quoted string
or a character class to have a
mnemonic name,
the application must provide that name explicitly,
by specifying the character class
or quoted string in an L0 rule.
.SH "Discouraged methods"
.IX Header "Discouraged methods"
Methods in this section continue to be supported, but their use is
discouraged in favor of other, better solutions.
New applications should avoid using discouraged methods.
.SS "\fBevent()\fP"
.IX Subsection "event()"
.Vb 1
\&            my $event    = $recce\->event($event_ix);
.Ve
.PP
Use of this method is discouraged in favor of the more efficient
\&\fBevents()\fR method.
The \f(CW\*(C`event()\*(C'\fR method requires one argument,
an event index.
It returns a descriptor of
the named event with that index, or a Perl \f(CW\*(C`undef\*(C'\fR
if there is no such event.
For more details on events, see the
description of the \fBevents()\fR method.
.SS "\fBlast_completed_range()\fP"
.IX Subsection "last_completed_range()"
Use of this method is discouraged in favor of
\&\*(L"\fBlast_completed()\fR\*(R".
Given the name of a symbol,
\&\f(CW\*(C`last_completed_range()\*(C'\fR
returns the G1 start and G1 end locations of the most recent match.
If there was more than one most recent match,
\&\f(CW\*(C`last_completed_range()\*(C'\fR
returns the longest.
If there was no match,
\&\f(CW\*(C`last_completed_range()\*(C'\fR
returns the empty array in array context
and a Perl false in scalar context.
.SS "\fBrange_to_string()\fP"
.IX Subsection "range_to_string()"
Use of this method is discouraged in favor of
\&\*(L"\fBsubstring()\fR\*(R".
Given a G1 start and a G1 end location,
\&\f(CW\*(C`range_to_string()\*(C'\fR
returns the substring of the input
stream that is between the two.
The \f(CW\*(C`range_to_string()\*(C'\fR method
assumes that
the application read
the physical input stream in
lexical order and
without gaps
except for whitespace and other normal discards.
When that is not the case,
\&\f(CW\*(C`range_to_string()\*(C'\fR behaves in
much the same way as described above
for \*(L"\fBsubstring()\fR\*(R".
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
