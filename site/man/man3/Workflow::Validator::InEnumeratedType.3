.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Validator::InEnumeratedType 3"
.TH Workflow::Validator::InEnumeratedType 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Validator::InEnumeratedType \- Ensure a value is one of a declared set of values
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.04 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Inline the enumeration...
\&
\& <action name="PlayGame">
\&   <validator name="InEnumeratedType">
\&      <value>Rock</value>
\&      <value>Scissors</value>
\&      <value>Paper</value>
\&      <arg value="$play"/>
\&   </validator>
\& </action>
\&
\& # Or declare it in the validator to be more readable...
\& <validator name="RSP"
\&            class="Validator::InEnumeratedType">
\&      <value>Rock</value>
\&      <value>Scissors</value>
\&      <value>Paper</value>
\& </validator>
\&
\& # ...and use it in your action
\& <action name="PlayGame">
\&    <validator name="RSP">
\&       <arg value="$play"/>
\&    </validator>
\& </action>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This validator ensures that a value matches one of a set of
values. You declare the values in the set (or enumerated type) in
either the main validator declaration or in the declaration inside the
action, then pass a single argument of the value in the context you
would like to check.
.PP
Declaring the members of the enumerated type in the validator
configuration makes for more readable (and brief) action
configurations, as well as making the types more reusable, but it is
really up to you.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
.SS "Strategy"
.IX Subsection "Strategy"
Unlike some other validator classes this one is setup to be
subclassable. It is usable as-is, of course, but many times you will
find that you have need of more interesting types in your enumeration
than simple strings. So this class provides the hooks for you to
simply create your own.
.PP
For instance, in a trouble ticket system you may have the idea that
tickets can only be assigned to particular users. Maybe they are in a
\&'worker' role, maybe they are some administrators, whatever. By
creating a class to have these users as an enumerated type, combined
with declaring the required Action fields, you make for a pretty
powerful piece of reflection.
.PP
Onto the code. First we declare a field type of 'worker':
.PP
.Vb 2
\& <field type="worker"
\&        class="MyApp::Field::Worker"/>
.Ve
.PP
Next a validator of this enumerated type:
.PP
.Vb 2
\& <validator name="IsWorker"
\&            class="MyApp::Validator::WorkerEnumeration"/>
.Ve
.PP
We then associate this field type with a field in the action and the
validator to ensure the user selects a worker from the right pool:
.PP
.Vb 8
\& <action name="AssignTicket">
\&    <field name="assignee"
\&           type="worker"
\&           is_required="yes"/>
\&   ...
\&   <validator name="IsWorker">
\&       <arg value="$assignee"/>
\&   </validator>
.Ve
.PP
Note that the name of the field and the name used in the validator are
the same. This allows external applications to query the action for
its fields, get 'assignee' as the name and get a list of User objects
(or something similar) as the types from which to choose a value, and
checks that same field to ensure a correct choice was submitted.
.PP
The implementation for the validator might look like:
.PP
.Vb 1
\& package MyApp::Validator::WorkerEnumeration;
\&
\& sub validate {
\&     my ( $self, $wf, $worker_id ) = @_;
\&     my $ticket = $context\->param( \*(Aqticket\*(Aq );
\&     unless ( $ticket ) {
\&         my $ticket_id = $context\->param( \*(Aqticket_id\*(Aq );
\&         $ticket = Ticket\->fetch( $ticket_id );
\&     }
\&     my $workers = $ticket\->fetch_available_workers();
\&     my @worker_id = map { $_\->id } @{ $workers };
\&     $self\->add_enumerated_values( @worker_id );
\&     $self\->SUPER::validate( $wf, $worker_id );
\& }
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
\fI_init( \e%params )\fR
.IX Subsection "_init( %params )"
.PP
This method initializes the class and the enumerated class.
.PP
It uses \*(L"add_enumerated_values\*(R" to add the set of values for enumeration.
.PP
The primary parameter is value, which should be used to specify the
either a single value or a reference to array of values to be added.
.PP
\fIvalidator\fR
.IX Subsection "validator"
.PP
The validator method is the public \s-1API.\s0 It encapulates \*(L"is_enumerated:value\*(R"
and works with Workflow.
.PP
\fIadd_enumerated_values( \f(CI@values\fI )\fR
.IX Subsection "add_enumerated_values( @values )"
.PP
This method ads an array of values to be regarded as enumerations for the
validator.
.PP
\fI\f(BIget_enumerated_values()\fI\fR
.IX Subsection "get_enumerated_values()"
.PP
This method returns the defined enumerated values for the class as an array.
.PP
\fIis_enumerated_value( \f(CI$value\fI )\fR
.IX Subsection "is_enumerated_value( $value )"
.PP
This is most often the single method you will want to modify.
.PP
The method offers assertion of a given value, as to whether it is an enumerated
type as defined in the class.
.SH "EXCEPTIONS"
.IX Header "EXCEPTIONS"
.IP "\(bu" 4
Validator 'InEnumeratedType' must be initialized with the values you wish to validate against using the parameter 'value'.
.Sp
This Workflow::Exception is thrown from \*(L"_init\*(R" if the 'value'
parameter is not set.
.IP "\(bu" 4
Value '$value' must be one of: <@values>
.Sp
This Workflow::Exception is thrown from \*(L"_validator\*(R" if the value
to be asserted is not mathing any of the enumerated values defined as
part of the set.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2007 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Current maintainer Jonas B. Nielsen <jonasbn@cpan.org>
.PP
Original author Chris Winters <chris@cwinters.com>
