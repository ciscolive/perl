.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tree::Binary2 3"
.TH Tree::Binary2 3 "2019-06-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree::Binary2 \- An implementation of a binary tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $tree = Tree::Binary2\->new( \*(Aqroot\*(Aq );
\&
\&  my $left = Tree::Binary2\->new( \*(Aqleft\*(Aq );
\&  $tree\->left( $left );
\&
\&  my $right = Tree::Binary2\->new( \*(Aqleft\*(Aq );
\&  $tree\->right( $right );
\&
\&  my $right_child = $tree\->right;
\&
\&  $tree\->right( undef ); # Unset the right child.
\&
\&  my @nodes = $tree\->traverse( $tree\->POST_ORDER );
\&
\&  my $traversal = $tree\->traverse( $tree\->IN_ORDER );
\&  while ( my $node = $traversal\->() ) {
\&      # Do something with $node here
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an implementation of a binary tree. This class inherits from Tree,
which is an N\-ary tree implemenation. Because of this, this class actually
provides an implementation of a complete binary tree vs. a sparse binary tree.
The empty nodes are instances of Tree::Null, which is described in Tree.
This should have no effect on your usage of this class.
.SH "METHODS"
.IX Header "METHODS"
In addition to the methods provided by Tree, the following items are
provided or overriden.
.IP "\(bu" 4
\&\f(CW\*(C`left([$child])\*(C'\fR / \f(CW\*(C`right([$child])\*(C'\fR
.Sp
These access the left and right children, respectively. They are mutators,
which means that their behavior changes depending on if you pass in a value.
.Sp
If you do not pass in any parameters, then it will act as a getter for the
specific child, return the child (if set) or undef (if not).
.Sp
If you pass in a child, it will act as a setter for the specific child,
setting the child to the passed-in value and returning the \f(CW$tree\fR. (Thus, this
method chains.)
.Sp
If you wish to unset the child, do \f(CW\*(C`$tree>left( undef );\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`children()\*(C'\fR
.Sp
This will return the children of the tree.
.Sp
\&\fB\s-1NOTE:\s0\fR There will be two children, always. Tree::Binary2 implements a
complete binary tree, filling in missing children with Tree::Null objects.
(Please see Tree::Fast for more information on Tree::Null.)
.IP "\(bu" 4
\&\fBtraverse( [$order] )\fR
.Sp
When called in list context (\f(CW\*(C`my @traversal = $tree\->traverse()\*(C'\fR), this will
return a list of the nodes in the given traversal order. When called in scalar
context (\f(CW\*(C`my $traversal = $tree\->traverse()\*(C'\fR), this will return a closure
that will, over successive calls, iterate over the nodes in the given
traversal order. When finished it will return false.
.Sp
The default traversal order is pre-order.
.Sp
In addition to the traversal orders provided by Tree, Tree::Binary2 provides
in-order traversals.
.RS 4
.IP "\(bu" 4
In-order
.Sp
This will return the result of an in-order traversal on the left node (if
any), then the node, then the result of an in-order traversal on the right
node (if any).
.RE
.RS 4
.RE
.PP
\&\fB\s-1NOTE:\s0\fR You have access to all the methods provided by Tree, but it is not
recommended that you use many of them, unless you know what you're doing. This
list includes \f(CW\*(C`add_child()\*(C'\fR and \f(CW\*(C`remove_child()\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Make in-order closure traversal work iteratively
.IP "\(bu" 4
Make post-order closure traversal work iteratively
.SH "CODE COVERAGE"
.IX Header "CODE COVERAGE"
Please see the relevant sections of Tree.
.SH "SUPPORT"
.IX Header "SUPPORT"
Please see the relevant sections of Tree.
.SH "AUTHORS"
.IX Header "AUTHORS"
Rob Kinyon <rob.kinyon@iinteractive.com>
.PP
Stevan Little <stevan.little@iinteractive.com>
.PP
Thanks to Infinity Interactive for generously donating our time.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004, 2005 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
