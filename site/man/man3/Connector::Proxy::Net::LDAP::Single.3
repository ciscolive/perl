.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector::Proxy::Net::LDAP::Single 3"
.TH Connector::Proxy::Net::LDAP::Single 3 "2020-06-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Connector::Proxy::Net::LDAP::Single
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Search and return a single item from the repository. Attributes from the ldap
entry can be mapped to the returned structure using a map.
.PP
The connector will die if multiple entries are found.
.SH "configuration options"
.IX Header "configuration options"
See Connector::Proxy::Net::LDAP for basic configuration options
.PP
The class needs a map of attribute names to map between the returned hash
and the names of the ldap attributes.
.PP
.Vb 6
\& connector:
\&    LOCATION:...
\&    ....
\&    attrmap:
\&      certificate:usercertificate
\&      department:ou
.Ve
.PP
\&\fBWarning: Do not set the attr property\fR
.SH "accessor methods"
.IX Header "accessor methods"
.SS "get"
.IX Subsection "get"
Not supported.
.SS "get_hash"
.IX Subsection "get_hash"
You need to define a map to assign the resulting ldap attributes to the
returned hash structure. The maps keys remain keys whereas the value is
set to the value of the ldap attribute with that name. Multivalued attributes
are truncated to the first entry by default. To get them as array ref, set
the deep parameter to true \f(CW\*(C`{ deep =\*(C'\fR 1}>.
.PP
Note: the special name \fIpkey\fR is reserved and contains the dn of the entry.
.SS "get_keys"
.IX Subsection "get_keys"
Return the keys which are set in the resulting hash.
Keys that do not have a matching attribute value are not set.
.SS "get_list / get_size"
.IX Subsection "get_list / get_size"
Not supported.
.SS "set"
.IX Subsection "set"
Set attributes of a node, if configured will create a non-exisiting node.
The set method requires a hash as value parameter.
.PP
You can control how existing attributes in the node are treated and if missing
nodes are created on the fly. See \fIConnector::Proxy::Net::LDAP\fR for details.
.PP
\fISet multiple attributes on an existing node\fR
.IX Subsection "Set multiple attributes on an existing node"
.PP
The connector first does a search similar to its \f(CW\*(C`get\*(C'\fR method based on the
passed filter arguments. If exactly one entry is found, it works like the
inverse of the \fIget_hash\fR method. It needs an attributemap and
maps all values from the input hash to the ldap attributes. Only keys which
are present in the input array are handled.
.PP
\fISet operation when the dn is known\fR
.IX Subsection "Set operation when the dn is known"
.PP
If you used another ldap operation before and already know the dn, you can pass
this dn as parameter \fIpkey\fR to the set method.
.PP
.Vb 1
\&    $conn\->set(\*(AqJohn Doe\*(Aq, { mail => <new mail address>}, { pkey => $dn });
.Ve
.PP
The dn is returned by example by the \f(CW\*(C`get_hash\*(C'\fR method.
.PP
\fISet operation with node autocreation\fR
.IX Subsection "Set operation with node autocreation"
.PP
To enable the automated creation of missing nodes, look for the corresponding
section in the base class \fIConnector::Proxy::Net::LDAP\fR.
