.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MCE::Signal 3"
.TH MCE::Signal 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MCE::Signal \- Temporary directory creation/cleanup and signal handling
.SH "VERSION"
.IX Header "VERSION"
This document describes MCE::Signal version 1.874
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& ## Creates tmp_dir under $ENV{TEMP} if defined, otherwise /tmp.
\&
\& use MCE::Signal;
\&
\& ## Attempts to create tmp_dir under /dev/shm if writable.
\&
\& use MCE::Signal qw( \-use_dev_shm );
\&
\& ## Keeps tmp_dir after the script terminates.
\&
\& use MCE::Signal qw( \-keep_tmp_dir );
\& use MCE::Signal qw( \-use_dev_shm \-keep_tmp_dir );
\&
\& ## MCE loads MCE::Signal by default when not present.
\& ## Therefore, load MCE::Signal first for options to take effect.
\&
\& use MCE::Signal qw( \-keep_tmp_dir \-use_dev_shm );
\& use MCE;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package configures \f(CW$SIG\fR{ \s-1HUP, INT, PIPE, QUIT,\s0 and \s-1TERM\s0 } to point to
stop_and_exit and creates a temporary directory. The main process and workers
receiving said signals call stop_and_exit, which signals all workers to
terminate, removes the temporary directory unless \-keep_tmp_dir is specified,
and terminates itself.
.PP
The location of the temp directory resides under \f(CW$ENV\fR{\s-1TEMP\s0} if defined,
otherwise /dev/shm if writeable and \-use_dev_shm is specified, or /tmp.
On Windows, the temp directory is made under \f(CW$ENV\fR{\s-1TEMP\s0}/Perl\-MCE/.
.PP
As of \s-1MCE 1.405,\s0 MCE::Signal no longer calls setpgrp by default. Pass the
\&\-setpgrp option to MCE::Signal to call setpgrp.
.PP
.Vb 2
\& ## Running MCE through Daemon::Control requires setpgrp to be called
\& ## for MCE releases 1.511 and below.
\&
\& use MCE::Signal qw(\-setpgrp);   ## Not necessary for MCE 1.512 and above
\& use MCE;
.Ve
.PP
The following are available options and their meanings.
.PP
.Vb 2
\& \-keep_tmp_dir     \- The temporary directory is not removed during exiting
\&                     A message is displayed with the location afterwards
\&
\& \-use_dev_shm      \- Create the temporary directory under /dev/shm
\& \-no_kill9         \- Do not kill \-9 after receiving a signal to terminate
\&
\& \-setpgrp          \- Calls setpgrp to set the process group for the process
\&                     This option ensures all workers terminate when reading
\&                     STDIN for MCE releases 1.511 and below.
\&
\&                        cat big_input_file | ./mce_script.pl | head \-10
\&
\&                     This works fine without the \-setpgrp option:
\&
\&                        ./mce_script.pl < big_input_file | head \-10
.Ve
.PP
Nothing is exported by default. Exportable are 1 variable and 2 subroutines.
.PP
.Vb 2
\& use MCE::Signal qw( $tmp_dir stop_and_exit sys_cmd );
\& use MCE::Signal qw( :all );
\&
\& $tmp_dir          \- Path to the temporary directory.
\& stop_and_exit     \- Described below
\& sys_cmd           \- Described below
.Ve
.ie n .SS "stop_and_exit ( [ $exit_status | $signal ] )"
.el .SS "stop_and_exit ( [ \f(CW$exit_status\fP | \f(CW$signal\fP ] )"
.IX Subsection "stop_and_exit ( [ $exit_status | $signal ] )"
Stops execution, removes temp directory, and exits the entire application.
Pass '\s-1INT\s0' to terminate a spawned or running \s-1MCE\s0 session.
.PP
.Vb 2
\& MCE::Signal::stop_and_exit(1);
\& MCE::Signal::stop_and_exit(\*(AqINT\*(Aq);
.Ve
.ie n .SS "sys_cmd ( $command )"
.el .SS "sys_cmd ( \f(CW$command\fP )"
.IX Subsection "sys_cmd ( $command )"
The system function in Perl ignores \s-1SIGINT\s0 and \s-1SIGQUIT.\s0 These 2 signals are
sent to the command being executed via \fBsystem()\fR but not back to the underlying
Perl script. For this reason, sys_cmd was added to MCE::Signal.
.PP
.Vb 2
\& ## Execute command and return the actual exit status. The perl script
\& ## is also signaled if command caught SIGINT or SIGQUIT.
\&
\& use MCE::Signal qw(sys_cmd);   ## Include before MCE
\& use MCE;
\&
\& my $exit_status = sys_cmd($command);
.Ve
.SH "DEFER SIGNAL"
.IX Header "DEFER SIGNAL"
.ie n .SS "defer ( $signal )"
.el .SS "defer ( \f(CW$signal\fP )"
.IX Subsection "defer ( $signal )"
Returns immediately inside a signal handler if signaled during \s-1IPC.\s0
The signal is deferred momentarily and re-signaled automatically upon
completing \s-1IPC.\s0 Currently, all \s-1IPC\s0 related methods in \f(CW\*(C`MCE::Shared\*(C'\fR and
one method \f(CW\*(C`send2\*(C'\fR in \f(CW\*(C`MCE::Channel\*(C'\fR set the flag \f(CW$MCE::Signal::IPC\fR
before initiating \s-1IPC.\s0
.PP
Current \s-1API\s0 available since 1.863.
.PP
.Vb 4
\& sub sig_handler {
\&    return MCE::Signal::defer($_[0]) if $MCE::Signal::IPC;
\&    ...
\& }
.Ve
.PP
In a nutshell, \f(CW\*(C`defer\*(C'\fR helps safeguard \s-1IPC\s0 from stalling between workers
and the shared manager-process. The following is a demonstration for Unix
platforms. Deferring the signal inside the \f(CW\*(C`WINCH\*(C'\fR handler prevents the
app from eventually failing while resizing the window.
.PP
.Vb 2
\& use strict;
\& use warnings;
\&
\& use MCE::Hobo;
\& use MCE::Shared;
\& use Time::HiRes \*(Aqsleep\*(Aq;
\&
\& my $count = MCE::Shared\->scalar(0);
\& my $winch = MCE::Shared\->scalar(0);
\& my $done  = MCE::Shared\->scalar(0);
\&
\& $SIG{WINCH} = sub {
\&    # defer signal if signaled during IPC
\&    return MCE::Signal::defer($_[0]) if $MCE::Signal::IPC;
\&
\&    # mask signal handler
\&    local $SIG{$_[0]} = \*(AqIGNORE\*(Aq;
\&
\&    printf "inside winch handler %d\en", $winch\->incr;
\& };
\&
\& $SIG{INT} = sub {
\&    # defer signal if signaled during IPC
\&    return MCE::Signal::defer($_[0]) if $MCE::Signal::IPC;
\&
\&    # set flag for workers to leave loop
\&    $done\->set(1);
\& };
\&
\& sub task {
\&    while ( ! $done\->get ) {
\&       $count\->incr;
\&       sleep 0.03;
\&    };
\& }
\&
\& print "Resize the terminal window continuously.\en";
\& print "Press Ctrl\-C to stop.\en";
\&
\& MCE::Hobo\->create(\*(Aqtask\*(Aq) for 1..8;
\& sleep 0.015 until $done\->get;
\& MCE::Hobo\->wait_all;
\&
\& printf "\encount incremented %d times\en\en", $count\->get;
.Ve
.SH "INDEX"
.IX Header "INDEX"
\&\s-1MCE\s0, MCE::Core
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario E. Roy, <marioeroy AT gmail DOT com>
