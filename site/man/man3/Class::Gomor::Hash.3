.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class::Gomor::Hash 3"
.TH Class::Gomor::Hash 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Gomor::Hash \- class and object builder, hash version
.SH "SYNPOSIS"
.IX Header "SYNPOSIS"
.Vb 2
\&   # Create a base class in BaseClass.pm
\&   package My::BaseClass;
\&
\&   require Class::Gomor::Hash;
\&   our @ISA = qw(Class::Gomor::Hash);
\&
\&   our @AS = qw(attribute1 attribute2);
\&   our @AA = qw(attribute3 attribute4);
\&   our @AO = qw(other);
\&
\&   # You should initialize yourself array attributes
\&   sub new { shift\->SUPER::new(attribute3 => [], attribute4 => [], @_) }
\&
\&   # Create accessors
\&   My::BaseClass\->cgBuildAccessorsScalar(\e@AS);
\&   My::BaseClass\->cgBuildAccessorsArray(\e@AA);
\&
\&   sub other {
\&      my $self = shift;
\&      @_ ? $self\->{\*(Aqother\*(Aq} = [ split(/\en/, shift) ]
\&         : @{$self\->{\*(Aqother\*(Aq}};
\&   }
\&
\&   1;
\&
\&   # Create a subclass in SubClass.pm
\&   package My::SubClass;
\&
\&   require My::BaseClass;
\&   our @ISA = qw(My::BaseClass);
\&
\&   our @AS = qw(subclassAttribute);
\&
\&   My::SubClass\->cgBuildAccessorsScalar(\e@AS);
\&
\&   sub new {
\&      shift\->SUPER::new(
\&         attribute1 => \*(Aqval1\*(Aq,
\&         attribute2 => \*(Aqval2\*(Aq,
\&         attribute3 => [ \*(Aqval3\*(Aq, ],
\&         attribute4 => [ \*(Aqval4\*(Aq, ],
\&         other      => [ \*(Aqnone\*(Aq, ],
\&         subclassAttribute => \*(AqsubVal\*(Aq,
\&      );
\&   }
\&
\&   1;
\&
\&   # A program using those classes
\&
\&   my $new = My::SubClass\->new;
\&
\&   my $val1     = $new\->attribute1;
\&   my @values3  = $new\->attribute3;
\&   my @otherOld = $new\->other;
\&
\&   $new\->other("str1\enstr2\enstr3");
\&   my @otherNew = $new\->other;
\&   print "@otherNew\en";
\&
\&   $new\->attribute2(\*(AqnewValue\*(Aq);
\&   $new\->attribute4([ \*(AqnewVal1\*(Aq, \*(AqnewVal2\*(Aq, ]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a subclass from \fBClass::Gomor\fR. It implements objects as hash references, and inherits methods from \fBClass::Gomor\fR.
.SH "GLOBAL VARIABLE"
.IX Header "GLOBAL VARIABLE"
See \fBClass::Gomor\fR.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR (hash)" 4
.IX Item "new (hash)"
Object constructor. This is where user passed attributes (hash argument) are checked against valid attributes (gathered by \fBcgGetAttributes\fR method). Valid attributes are those that exists (doh!), and have not an undef value. The default is to check this, you can avoid it by setting \fB\f(CB$NoCheck\fB\fR global variable (see perldoc \fBClass::Gomor\fR).
.IP "\fBcgBuildIndices\fR" 4
.IX Item "cgBuildIndices"
This method does nothing. It only exists to make it more easy to switch between \fBClass::Gomor::Array\fR and \fBClass::Gomor::Hash\fR.
.IP "\fBcgBuildAccessorsScalar\fR (array ref)" 4
.IX Item "cgBuildAccessorsScalar (array ref)"
.PD 0
.IP "\fBcgBuildAccessorsArray\fR (array ref)" 4
.IX Item "cgBuildAccessorsArray (array ref)"
.PD
See \fBClass::Gomor\fR.
.IP "\fBcgGetIndice\fR (scalar)" 4
.IX Item "cgGetIndice (scalar)"
This method does nearly nothing. It only returns the passed-in scalar parameter (so the syntax is the same as in \fBClass::Gomor::Array\fR). It only exists to make it more easy to switch between \fBClass::Gomor::Array\fR and \fBClass::Gomor::Hash\fR.
.IP "\fBcgClone\fR [ (scalar) ]" 4
.IX Item "cgClone [ (scalar) ]"
You can clone one of your objects by calling this method. An optional parameter may be used to create multiple clones. Cloning will occure only on the first level attributes, that is, if you have attributes containing other objects, they will not be cloned.
.IP "\fBcgFullClone\fR [ (scalar) ]" 4
.IX Item "cgFullClone [ (scalar) ]"
This method is the same as \fBcgClone\fR, but will clone all attributes recursively, but only if they are subclassed from \fBClass::Gomor\fR. So, objects created with other modules than \fBClass::Gomor::Array\fR or \fBClass::Gomor::Hash\fR will not be cloned.
.Sp
Another thing to note, there is no catch for cycling references (when you link two objects with each others). You have been warned.
.IP "\fBcgDumper\fR" 4
.IX Item "cgDumper"
Will return a string as with \fBData::Dumper\fR Dumper method. This is less useful for hashref objects, because they already include attributes names.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::Gomor
.SH "AUTHOR"
.IX Header "AUTHOR"
Patrice <GomoR> Auffret
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2004\-2015, Patrice <GomoR> Auffret
.PP
You may distribute this module under the terms of the Artistic license.
See \s-1LICENSE\s0.Artistic file in the source distribution archive.
