.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Shiras::Switchboard 3"
.TH Log::Shiras::Switchboard 3 "2016-10-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Shiras::Switchboard \- Log::Shiras message screening and delivery
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Shiras <http://en.wikipedia.org/wiki/Moose#Subspecies> \- A small subspecies of
Moose found in the western United States (of America).
.PP
This is the class for message traffic control in the 'Log::Shiras' package.  For a
general overview of the whole package see the top level documentation
\&.  Traffic is managed using name spaces.  For the purposes of logging this
package uses three types of name space with an additional wrapper.  The first name space
is the source code name space.  This name space is managed by putting labeled comment
tags in the code and then exposing them with a source code filter.  This is mostly used
when you want to have debug code available that does not impact your regular runs of the
code.  This space is managed by Log::Shiras::Unhide.  The source code name space is a
flat list.  The next name space is the caller name space.  The caller name space is
assigned in the code with targeted embedded statements to the master_talk
 method.  Boilerplate for managing these calls can be found
in Log::Shiras::Telephone.  If you wish to inject name_space modifications from the
calling script you can use the role Log::Shiras::LogSpace.  The caller namespace can
be heirarchical and represented by a Hash of hashrefs.  The final name space is the
destination or report namespace.  This namespace is flat but each position can contain
more than one actual report.  Any message to a specific report name is sent to all reports
assigned to that name.  Managing the traffic between the caller name space and the report
name space is done by setting allowed urgency levels in the
name space bounds., urgency levels, and report names.
.PP
In order to stich all this together at run time this is a singleton class and so
\&'new' is the wrong way to get a new instance of this class.  The right way is to use the
method get_operator. The upside of using a singleton is you
can write a caller (message source) with an intended urgency and destination name and not
build the actual destination till run time.
.SS "Initialization"
.IX Subsection "Initialization"
This class does not use \->new.  Use 'get_operator' instead.
.PP
\fIget_operator( \f(CI%args\fI )\fR
.IX Subsection "get_operator( %args )"
.Sp
.RS 4
\&\fBDefinition:\fR This method replaces the call to \->new or other instantiation
methods.  The Log::Shiras::Switchboard class is a MooseX::Singleton
 <https://metacpan.org/module/MooseX::Singleton>  and as such needs to be called in a
slightly different fashion.  This method can be used to either connect to the existing
switchboard or start the switchboard with new settings.  Each call to this method will
implement the settings passed in \f(CW%args\fR merging them with any pre-existing settings.
Where pre-existing settings disagree with new settings the new settings take
precedence.  So be careful!
.Sp
\&\fBAccepts:\fR [%args|$args_ref|full/file/path.(json|yml)] \f(CW%args\fR are treated the same
as attributes passed to other class style calls to new.  The data can either be
passed as a fat comma list or a hashref.  If this method receives a string it will
try to treat it like a full file path to a \s-1JSON\s0 or \s-1YAML\s0 file with the equivalent
\&\f(CW$args_ref\fR stored.  See conf_file to pass a file path and arguments.
.Sp
\&\fBReturns:\fR an instance of the Log::Shiras::Switchboard class called an 'operator'.
This operator can act on the switchboard to perform any of the methods including
any attribute access methods.
.RE
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to get_operator when creating an instance.  For
modification of these attributes see the remaining Methods
used to act on the operator.  \fB\s-1DO NOT USE\s0 'Log::Shiras::Switchboard\->new' to get
a new class instance\fR
.PP
\fIname_space_bounds\fR
.IX Subsection "name_space_bounds"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute stores the boundaries set for the name-space management of
communications (generally from Log::Shiras::Telephone) message data sources. This
value ref defines where in the name-space, to which reports, and at what
urgency level messages are allows to pass.  Name spaces are stored as
a hash of hashes <http://perldoc.perl.org/perldsc.html#HASHES-OF-HASHES> that goes as
deep as needed.  To send a message between a specific caller name-space and a named
\&'report' destination this hash ref tree must have the key '\s-1UNBLOCK\s0' at or below the
target name space in the hashref tree.  The \s-1UNBLOCK\s0 key must have as a value a hashref
with report names as keys and the minimum allowed pass level as the
value.  That(ose) report(s) then remain(s) open to communication farther out on the
caller name space branch until a new \s-1UNBLOCK\s0 key sets different permission level or
a '\s-1BLOCK\s0' key is implemented.  The difference between a \s-1BLOCK\s0 and \s-1UNBLOCK\s0 key is that
a \s-1BLOCK\s0 key value only needs to contain report keys (the key values are unimportant).
Any level assigned to the report name by a \s-1BLOCK\s0 key is ignored and all communication
at that point and further in the branch is cut off all for all deeper levels of the
name space branch for that report.  There are a couple of significant points for review;
.Sp
.RS 4
\&\fB*\fR \s-1UNBLOCK\s0 and \s-1BLOCK\s0 should not be used as branch of the telephone name-space tree
.Sp
\&\fB*\fR If a caller name-space is not listed here or a report name is not explicitly
UNBLOCKed then the message is blocked by default.
.Sp
\&\fB*\fR Even though 'log_file' is the default report it is not '\s-1UNBLOCK\s0'ed by default.
It must be explicitly UNBLOCKed to be used.
.Sp
\&\fB*\fR UNBLOCKing or BLOCKing of a report can occur independant of it's existance.
This allows the addition of a report later and have it work upon its creation.
.Sp
\&\fB*\fR If an \s-1UNBLOCK\s0 and \s-1BLOCK\s0 key exist at the same point in a name space then
the hashref associated with the \s-1UNBLOCK\s0 key is evaluated first and the hashref
associated with the \s-1BLOCK\s0 key is evaluated second.  This means that the \s-1BLOCK\s0
command can negate a report UNBLOCKing level.
.Sp
\&\fB*\fR Any name space on the same branch (but deeper) than an \s-1UNBLOCK\s0 command remains
UNBLOCKed for the listed report urgency levels until a deeper \s-1UNBLOCK\s0 or \s-1BLOCK\s0 is
registered for that report.
.Sp
\&\fB*\fR When UNBLOCKing a report at a deeper level than an initial \s-1UNBLOCK\s0 setting
the new level can be set higher or lower than the initial setting.
.Sp
\&\fB*\fR \s-1BLOCK\s0 commands are only valuable deeper than an initial \s-1UNBLOCK\s0 command.  The
Tree trunk starts out '\s-1BLOCK\s0'ed by default.
.Sp
\&\fB*\fR All \s-1BLOCK\s0 commands completly block the report(s) named for that point and
deeper independant of the urgency value associated with report name key in
the \s-1BLOCK\s0 hashref.
.Sp
\&\fB*\fR The hash key whos hashref value contains an \s-1UNBLOCK\s0 hash key is the point in
the NameSpace where the report is UNBLOCKed to the defined level.
.RE
.RE
.RS 4
.Sp
\&\fBDefault\fR all caller name-spaces are blocked (no reporting)
.Sp
\&\fBRange\fR The caller name-space is stored and searched as a hash of hashes.  No
array refs will be correctly read as any part of the name-space definition.  At each
level of the name-space the switchboard will also recognize the special keys '\s-1UNBLOCK\s0'
and '\s-1BLOCK\s0' \fIin that order\fR.  As a consequence \s-1UNBLOCK\s0 and \s-1BLOCK\s0 are not supported as
name-space elements.  Each \s-1UNBLOCK\s0 (or \s-1BLOCK\s0) key should have a hash ref of report
 name keys as it's value.  The hash ref of report name keys should contain
the minimum allowed urgency level down to which the report is UNBLOCKed.  The value
associated with any report key in a \s-1BLOCK\s0 hash ref is not tested since \s-1BLOCK\s0 closes
all reporting from that point and deeper.
.Sp
\&\fBExample\fR
.Sp
.Vb 10
\&        name_space_bounds =>{
\&                Name =>{#<\-\- name\-space
\&                        Space =>{#<\-\- name\-space
\&                                UNBLOCK =>{#<\-\- Telephone name\-space \*(AqName::Space\*(Aq is unblocked
\&                                        log_file => \*(Aqwarn\*(Aq#<\-\- but only for calls to the \*(Aqlog_file\*(Aq report
\&                                },                                        #     with an urgency of \*(Aqwarn\*(Aq or greater
\&                                Boundary =>{#<\-\- name\-space
\&                                        UNBLOCK =>{#<\-\- The deeper space \*(AqName::Space::Boundary\*(Aq receives a new setting
\&                                                log_file => \*(Aqtrace\*(Aq,#<\-\- messages are allowed at \*(Aqtrace\*(Aq urgency now
\&                                                special_report => \*(Aqeleven\*(Aq,<\-\- a new report and level are added
\&                                        },
\&                                        Place =>{},<\-\- deeper name\-space \- log_file permissions still \*(Aqtrace\*(Aq
\&                                },
\&                        },
\&                },
\&        }
.Ve
.Sp
\&\fBWarning\fR All active name-space boundaries must coexist in the singleton.  There
is only one master name-space for the singleton.  New calls for object intances can
overwrite existing object instances name-space boundaries.  No cross instance name-space
protection is done. This requires conscious managment!  \fIIt is entirely possible to call
for another operator in the same program space with overlapping name-space boundaries that
changes reporting for a callers originally used in the context of the original operator.\fR
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_name_space\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the full program namespace
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIreports\fR
.IX Subsection "reports"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute stores report names and associated composed class
instances for that name.  The attribute expects a hash of arrays
 <http://perldoc.perl.org/perldsc.html#HASHES-OF-ARRAYS>.  Each hash key is the
report name and the array contains the report instances associated with that name.  Each
passed array object will be tested to see if it is an object that can( 'add_line' ).
If not this code will try to coerce the passed reference at the array position into an
object using MooseX::ShortCut::BuildInstance.
.Sp
\&\fBDefault\fR no reports are active.  If a message is sent to a non-existant report
name then nothing happens unless self reporting is fully enabled.
Then it is possible to collect various warning messages related to the failure of a
message.
.Sp
\&\fBExample\fR
.Sp
.Vb 10
\&        reports =>{
\&                log_file =>[<\-\- report name
\&                                Print::Wisper\->new,#<\-\- a reporting instance of a class ( see Synopsis )
\&                                {#<\-\- MooseX::ShortCut::BuildInstance definition for a different report
\&                                        package => \*(AqPrint::Excited\*(Aq,#<\-\- name this (new) class
\&                                        add_methods =>{
\&                                                add_line => sub{#<\-\- ensure it has an \*(Aqadd_line\*(Aq method
\&                                                        shift;
\&                                                        my @input = ( ref $_[0]\->{message} eq \*(AqARRAY\*(Aq ) ?
\&                                                                                        @{$_[0]\->{message}} : $_[0]\->{message};
\&                                                        my @new_list;
\&                                                        map{ push @new_list, $_ if $_ } @input;
\&                                                        chomp @new_list;
\&                                                        print \*(Aq!!!\*(Aq . uc(join( \*(Aq \*(Aq, @new_list)) . "!!!\en";
\&                                                }
\&                                        },
\&                                }
\&                        ],
\&                other_name =>[],#<\-\- name created but no report instances added (maybe later?)
\&        },
.Ve
.Sp
\&\fBwarning:\fR any re-definition of the outputs for a report name will only push the new
report instance onto the existing report array ref.  To remove an existing report output
instance you must delete all report instances and the
report name and then re-implement the report name and it's outputs.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_reports\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the full report hashref of arrays
.RE
.RE
.RS 4
.Sp
\&\fBhas_no_reports( \f(CB$report\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Checks if the \f(CW$report\fR requested has a key in the hashref
.RE
.RE
.RS 4
.Sp
\&\fBget_report( \f(CB$report\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the array ref of stored report objects for that \f(CW$report\fR
.RE
.RE
.RS 4
.Sp
\&\fBremove_reports( \f(CB$report1\fB [, \f(CB$report2\fB] )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Deletes all storeage (and use of) \f(CW$report1\fR etc.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIlogging_levels\fR
.IX Subsection "logging_levels"
.Sp
.RS 4
\&\fBDefinition:\fR Each report name recognizes 12 different logging levels [0..11]
(They go to 11!
 <http://en.wikipedia.org/wiki/Up_to_eleven#Original_scene_from_This_Is_Spinal_Tap> :).  Each
position within the logging levels can be assigned a name that is not case sensitive.
Either the position integer or the name assigned to that position can be used to describe
the urgency 'level'.  Each message can be sent with name.  The urgency level of a message
can be defined for each sent message.  If you do not wish to
use the default name for each logging position or you wish to name the logging positions
that are not named then use this attribute.  Not all of the elements need to be defined.
There can be gaps between defined levels but counting undefined positions there can never
be more than 12 total positions in the level array.  The priority or urgency is lowest
first to highest last on the list.  Where requests sent with an urgency at or above the
permissions barrier will pass.  Since there are default priority names already in place
this attribute is a window dressing setting and not much more.
.Sp
\&\fBDefault\fR The default array of priority / urgency levels is;
.Sp
.Vb 2
\&        \*(Aqtrace\*(Aq, \*(Aqdebug\*(Aq, \*(Aqinfo\*(Aq, \*(Aqwarn\*(Aq, \*(Aqerror\*(Aq, \*(Aqfatal\*(Aq,
\&        undef, undef, undef, undef, undef, \*(Aqeleven\*(Aq,
.Ve
.Sp
Any report name without a custom priority array will use the default array.
.Sp
\&\fBExample\fR
.Sp
.Vb 8
\&        logging_levels =>{
\&                log_file =>[ qw(<\-\- report name (others use the default list)
\&                                foo
\&                                bar
\&                                baz
\&                                fatal
\&                ) ],
\&        }
.Ve
.Sp
\&\fBfatal\fR The Switchboard will confess for all messages sent with a
priority or urgency level that matches qr/fatal/i.  The switchboard will fully dispatch 
the message to it's intended report(s) prior to confessing the message.  At this point 
the script will die.  If the message is not approved (even at the fatal level) then 
nothing happens.  'fatal' can be set anywhere in the custom priority list from lowest 
to highest but fatal is the only string that will die.  (priorities higher than fatal 
will not die) \fBBut\fR, if the message is blocked for the message \fIname-space, report, 
and level\fR then the code will \s-1NOT\s0 die.>  If 'fatal' is the requested level from the 
caller but it is not on the (custom) list for the report desination then the priority 
of the message drops to 0 (trace equivalent) and that level of urgencie must be accepted 
for the report to die. (even if the listed level at the 0 position is not 'fatal').
.RE
.PP
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBhas_log_levels( \f(CB$report\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if a custom log level list is stored for \f(CW$report\fR.
.RE
.RE
.RS 4
.Sp
\&\fBadd_log_levels( \f(CB$report\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Sets the log level name strings for \f(CW$report\fR
.Sp
\&\fBAccepts:\fR the value must be an array ref of no more than 12 total positions
.RE
.RE
.RS 4
.Sp
\&\fBremove_log_levels( \f(CB$report1\fB [, \f(CB$report2\fB] )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Removes the custom log_level list for the \f(CW$report\fR[s]
.RE
.RE
.RS 4
.Sp
\&\fBset_all_log_levels( \f(CB$full_hashref_of_arrayrefs\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Completely resets all custom log levels to \f(CW$full_hashref_of_arrayrefs\fR
.RE
.RE
.RS 4
.Sp
\&\fBget_all_log_levels\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the full hashref of arrayrefs for all custom log levels
.RE
.RE
.RS 4
.RE
.PP
\fIall_buffering\fR
.IX Subsection "all_buffering"
.Sp
.RS 4
\&\fBDefinition:\fR Buffering in this package is only valuable if you want to eliminate some
of the sent messages after they were created.  Buffering allows for clearing of sent
messages from between two save points.  For this to occur buffering must be on and
flushing the buffer to the report need to
occur at all known good points.  When some section of prior messages are to be discarded
then a clear_buffer command can be sent and all buffered
messages after the last flush will be discarded.  If buffering is turned off the
messages are sent directly to the report for processing with no holding period.  This
attribute accepts a hash ref where the keys are report names and the values empty arrayrefs
You could theoretically pre-load your buffer here but it is not reccomended.  If a new
instance of this class is called with an 'all_buffering' arg sent then it will flush any
pre-existing buffers (even if they are duplicated in the new call) then delete them and
set the new passed list fresh.
.Sp
\&\fBDefault\fR All buffering is off
.Sp
\&\fBExample\fR
.Sp
.Vb 3
\&        buffering =>{
\&                log_file => [],
\&        }
.Ve
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_all_buffering( \f(CB$hasref_of_arrayrefs\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR completely resets all buffers to \f(CW$hasref_of_arrayrefs\fR but flushes
all the old buffers first
.RE
.RE
.RS 4
.Sp
\&\fBhas_buffer( \f(CB$report\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Checks if there is an active buffer for \f(CW$report\fR
.RE
.RE
.RS 4
.Sp
\&\fBstop_buffering( \f(CB$report1\fB [, \f(CB$report2\fB] )\fR
.Sp
.RS 4
\&\fBDefinition:\fR Removes the buffer for the \f(CW$report\fR[s] (flushing them first)
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIconf_file\fR
.IX Subsection "conf_file"
.Sp
.RS 4
\&\fBDefinition:\fR It is possible to pass all the Attribute settings to get_operator
 as a config file.  If you wish to mix your metaphores then
one of the attribute keys can be 'conf_file' with the value being the full file path
of a \s-1YAML\s0 or \s-1JSON\s0 file.  If you pass other attributes and conf_file then where there
is conflict the other attributes overwrite the file settings.
.Sp
\&\fBDefault\fR nothing
.Sp
\&\fBAccepts:\fR a full file path to a config file with attribute settings
.RE
.SS "Methods"
.IX Subsection "Methods"
These are methods used to adjust outcomes for the activities in the switchboard or to
leverage information held by the switchboard.
.PP
\fImaster_talk( \f(CI$args_ref\fI )\fR
.IX Subsection "master_talk( $args_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This is a way to directly call a report using the switchboard operator.  In a
real telephone situation this would be that cool handset that the telephone repairman brought
with him.  Like the Telephone repairman's phone it plugs in directly to the switchboard (or
in the repairmains case into a telephone line) and is a bit trickier to operate than absolutely
necessary.  For a nicer message sending interface see Log::Shiras::Telephone.  When the
\&\f(CW$args_ref\fR message is received the switchboard will check the name_space_bounds
 permissions.  If the message passes that test then it will attach metadata 
to to the \f(CW$args_ref\fR.  The metadata attached to the message is a follows;
.Sp
.Vb 1
\&        date_time => The date and time the message was sent in CLDR format of \*(Aqyyyy\-MM\-dd hh:mm:ss\*(Aq
\&
\&        package => The package name of the message source
\&
\&        filename => The (full) file name of the message source
\&
\&        line => The line number of the message sourceIf  and then test;
.Ve
.Sp
Any message buffering is then handled or the message is sent to the report 
name and each report in that name-space receives the \f(CW$args_ref\fR as the arguments to a call 
\&\f(CW$report\fR\->add_line( \f(CW$args_ref\fR ).  When that is complete the message is checked to see if it 
is fatal;
.Sp
.Vb 1
\&        $args_ref\->{level} =~ /fatal/i
.Ve
.Sp
\&\fIIf the message was buffered first the script will not die until the message was flushed into 
the report from the buffer.\fR
.Sp
\&\fBReturns:\fR The number of times the add_line call was made.  There are some special cases.
.Sp
.Vb 5
\&        \-3 = The call was not allowed by name_space permissions set in the switchboard
\&        \-2 = The message was buffered rather than sent to a report
\&        \-1 = The message was blocked as risking deep recursion
\&         0 = The call had permissions but found no report implementations to connect with
\&         1(and greater) = This indicates how many report instances received the message
.Ve
.Sp
\&\fBAccepts:\fR The passed args must be a HashRef and contain the following elements (any
others will be ignored by the switchboard but not stripped).
.Sp
.RS 4
\&\fBname_space\fR the value is the caller name_space as used by name_space_bounds
.Sp
\&\fBlevel\fR value is the urgency level of the message sent.  It can either be an integer in the
set [0..11] or one of the defined logging level strings.
.Sp
\&\fBreport\fR the value is the report name (destination) for the message ref
.Sp
\&\fBmessage\fR the message key must have a value that is an array_ref.  It is assumed that
content can be parsed into somthing else at the report level including any ArrayRef
sub-elements that may be Objects or hashrefs.
.Sp
\&\fBcarp_stack\fR if this key is passed and set to a true value then Carp \- longmess will
be run on the message and the results will be split on the newline and pushed onto the end
of the 'message' array_ref.
.Sp
\&\fBsource_sub\fR this key is generally handled in the background by Log::Shiras but if you
write a new caller subroutine to lay over 'master_talk' then providing that name to this
key will make the metada added to the message stop at the correct caller level.
.Sp
.RS 4
\&\fBexample\fR
.Sp
.Vb 6
\&        {
\&                name_space => \*(AqMyCoolScript::my_subroutine\*(Aq,
\&                level => \*(Aqwarn\*(Aq,
\&                report => \*(Aqlog_file\*(Aq,
\&                message =>[ \*(AqDont ignore these words\*(Aq ],
\&        }
.Ve
.RE
.RE
.RS 4
.Sp
\&\fBcarp_stack\fR [optional] This is a simple passed boolean value that will trigger a traditional
Carp longmess stack to be split by /\en\es*/ and then pushed on the end of the message array ref.
Before the message is stored this key will be deleted whether it was positive or negative.
.Sp
\&\fBsource_sub\fR [really optional] This is rarely used unless you are writing a replacement for
Log::Shiras::Telephone.  If you are writing a replacement then a full method space string is
passed here.  This will be used to travel the caller <http://perldoc.perl.org/functions/caller.html>
stack to find where the message line originated.  The equivalent for Log::Shiras::Telephone is;
.Sp
.RS 4
\&\fBexample\fR
.Sp
.Vb 1
\&    { source_sub => \*(AqLog::Shiras::Telephone::talk\*(Aq }
.Ve
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIadd_name_space_bounds( \f(CI$ref\fI )\fR
.IX Subsection "add_name_space_bounds( $ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This will graft
more name-space boundaries onto the existing name-space.  \fIThe passed ref will be treated
as the 'scion_ref' using Data::Walk::Graft.\fR
.Sp
\&\fBAccepts:\fR a data_ref (must start at the root of the main ref) of data to graft to the main
name_space_bounds ref
.Sp
\&\fBReturns:\fR The updated name-space data ref
.RE
.PP
\fIremove_name_space_bounds( \f(CI$ref\fI )\fR
.IX Subsection "remove_name_space_bounds( $ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This will prune the name-space
boundaries using the passed name-space ref. \fIThe passed ref will
be treated as the 'slice_ref' using Data::Walk::Prune.\fR
.Sp
\&\fBAccepts:\fR a data_ref (must start at the root of the main ref) of data used to prune the
main name_space_bounds ref
.Sp
\&\fBReturns:\fR The updated name-space data ref
.RE
.PP
\fIadd_reports( \f(CI%args\fI )\fR
.IX Subsection "add_reports( %args )"
.Sp
.RS 4
\&\fBDefinition:\fR This will add more report output instances to the existing
named report registered instances.  If the items in the passed report list are not already
report object instances that \->can( 'add_line' ) there will be an attempt to build
them using \*(L"build_instance( \f(CW%args\fR|\e%args )\*(R" in MooseX::ShortCut::BuildInstance.
If (and only if) the report name does not exist then the report name will also be added to the
report registry.
.Sp
\&\fBAccepts:\fR a hash of arrays with the report objects as items in the array
.Sp
\&\fBReturns:\fR 1
.RE
.PP
\fIget_log_levels( \f(CI$report_name\fI )\fR
.IX Subsection "get_log_levels( $report_name )"
.Sp
.RS 4
\&\fBDefinition:\fR This will return the log level names names for a given
report name in an array ref.  If no custom levels are defined it will return the default
level list.
.Sp
\&\fBAccepts:\fR a report name
.Sp
\&\fBReturns:\fR an array ref of the defined log levels for that report.
.RE
.PP
\fIsend_buffer_to_output( \f(CI$report_name\fI )\fR
.IX Subsection "send_buffer_to_output( $report_name )"
.Sp
.RS 4
\&\fBDefinition:\fR This will flush the contents of the \f(CW$report_name\fR buffer
to all the associated report objects.
.Sp
\&\fBAccepts:\fR  a \f(CW$report_name\fR
.Sp
\&\fBReturns:\fR The number of times that \f(CW$report_object\fR\->add_line( \f(CW$message_ref\fR ) was called to
complete the buffer flush.
.RE
.PP
\fIstart_buffering( \f(CI$report_name\fI )\fR
.IX Subsection "start_buffering( $report_name )"
.Sp
.RS 4
\&\fBDefinition:\fR This will start buffering for the \f(CW$report_name\fR.  If the buffering is
already implemented then nothing new happens.  No equivalent report or name_space_bounds
are required to turn buffering on!
.Sp
\&\fBAccepts:\fR  a \f(CW$report_name\fR string
.Sp
\&\fBReturns:\fR 1
.RE
.PP
\fIclear_buffer( \f(CI$report_name\fI )\fR
.IX Subsection "clear_buffer( $report_name )"
.Sp
.RS 4
\&\fBDefinition:\fR This will remove all messages currently in the buffer
without sending them to the report.
.Sp
\&\fBAccepts:\fR  a \f(CW$report_name\fR string
.Sp
\&\fBReturns:\fR 1
.RE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is pretty long so I put it at the end
.PP
.Vb 10
\&        #!perl
\&        use Modern::Perl;
\&        use lib \*(Aqlib\*(Aq, \*(Aq../lib\*(Aq,;
\&        use Log::Shiras::Unhide qw( :debug :InternalSwitchboarD );#
\&        use Log::Shiras::Switchboard;
\&        ###InternalSwitchboarD  use Log::Shiras::Report::Stdout;
\&        $| = 1;
\&        ###LogSD warn "lets get ready to rumble...";
\&        my $operator = Log::Shiras::Switchboard\->get_operator(
\&                        name_space_bounds =>{
\&                                main =>{
\&                                        UNBLOCK =>{
\&                                                # UNBLOCKing the quiet, loud, and run reports (destinations)
\&                                                #       at the \*(Aqmain\*(Aq caller name_space and deeper
\&                                                quiet   => \*(Aqwarn\*(Aq,
\&                                                loud    => \*(Aqinfo\*(Aq,
\&                                                run             => \*(Aqtrace\*(Aq,
\&                                        },
\&                                },
\&                                Log =>{
\&                                        Shiras =>{
\&        ###InternalSwitchboarD  Switchboard =>{#<\-\- Internal reporting enabled here
\&        ###InternalSwitchboarD          get_operator =>{
\&        ###InternalSwitchboarD                  UNBLOCK =>{
\&        ###InternalSwitchboarD                          # UNBLOCKing log_file
\&        ###InternalSwitchboarD                          #       at Log::Shiras::Switchboard::get_operator
\&        ###InternalSwitchboarD                          #       (self reporting)
\&        ###InternalSwitchboarD                          log_file => \*(Aqinfo\*(Aq,
\&        ###InternalSwitchboarD                  },
\&        ###InternalSwitchboarD          },
\&        ###InternalSwitchboarD          master_talk =>{
\&        ###InternalSwitchboarD                  _buffer_decision =>{
\&        ###InternalSwitchboarD                          UNBLOCK =>{
\&        ###InternalSwitchboarD                                  # UNBLOCKing log_file
\&        ###InternalSwitchboarD                                  #       at Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        ###InternalSwitchboarD                                  #       (self reporting)
\&        ###InternalSwitchboarD                                  log_file => \*(Aqtrace\*(Aq,
\&        ###InternalSwitchboarD                          },
\&        ###InternalSwitchboarD                  },
\&        ###InternalSwitchboarD          },
\&        ###InternalSwitchboarD          send_buffer_to_output =>{
\&        ###InternalSwitchboarD                  UNBLOCK =>{
\&        ###InternalSwitchboarD                          # UNBLOCKing log_file
\&        ###InternalSwitchboarD                          #       at Log::Shiras::Switchboard::_flush_buffer
\&        ###InternalSwitchboarD                          #       (self reporting)
\&        ###InternalSwitchboarD                          log_file => \*(Aqinfo\*(Aq,
\&        ###InternalSwitchboarD                  },
\&        ###InternalSwitchboarD          },
\&        ###InternalSwitchboarD  },#<\-\- Internal reporting enabled through here
\&                                        },
\&                                },
\&                        },
\&                        reports =>{
\&                                quiet =>[
\&                                        Print::Wisper\->new,
\&                                ],
\&                                loud =>[
\&                                        {
\&                                                package => \*(AqPrint::Excited\*(Aq,
\&                                                add_methods =>{
\&                                                        add_line => sub{
\&                                                                shift;
\&                                                                my @input = ( ref $_[0]\->{message} eq \*(AqARRAY\*(Aq ) ?
\&                                                                                                @{$_[0]\->{message}} : $_[0]\->{message};
\&                                                                my @new_list;
\&                                                                map{ push @new_list, $_ if $_ } @input;
\&                                                                chomp @new_list;
\&                                                                print \*(Aq!!!\*(Aq . uc(join( \*(Aq \*(Aq, @new_list)) . "!!!\en";
\&                                                        }
\&                                                },
\&                                        }
\&                                ],
\&        ###InternalSwitchboarD  log_file =>[
\&        ###InternalSwitchboarD          Log::Shiras::Report::Stdout\->new,
\&        ###InternalSwitchboarD  ],
\&                        },
\&                        all_buffering =>{
\&                                quiet => [],
\&                        },
\&                );
\&        ###LogSD warn "sending the message \*(AqHello World 1\*(Aq";
\&        $operator\->master_talk({
\&                report => \*(Aqlog_file\*(Aq, level => \*(Aqwarn\*(Aq, name_space => \*(Aqmain\*(Aq,
\&                message =>[ \*(AqHello World 1\*(Aq ] });
\&        ###LogSD warn "The name_space \*(Aqmain\*(Aq does not have destination \*(Aqlog_file\*(Aq permissions";
\&        ###LogSD warn "sending the message \*(AqHello World 2\*(Aq to the report \*(Aqquiet\*(Aq";
\&        $operator\->master_talk({
\&                report => \*(Aqquiet\*(Aq, level => \*(Aqwarn\*(Aq, name_space => \*(Aqmain\*(Aq,
\&                message =>[ \*(AqHello World 2\*(Aq ] });
\&        ###LogSD warn "message went to the buffer \- turning off buffering for the \*(Aqquiet\*(Aq destination ...";
\&        $operator\->stop_buffering( \*(Aqquiet\*(Aq );
\&        ###LogSD warn "should have printed what was in the \*(Aqquiet\*(Aq buffer ...";
\&        $operator\->master_talk({
\&                report => \*(Aqquiet\*(Aq, level => \*(Aqdebug\*(Aq, name_space => \*(Aqmain\*(Aq,
\&                message =>[ \*(AqHello World 3\*(Aq ] });
\&        ###LogSD warn "sending the message \*(AqHello World 4\*(Aq to the report \*(Aqloud\*(Aq";
\&        $operator\->master_talk({
\&                report => \*(Aqloud\*(Aq, level => \*(Aqinfo\*(Aq, name_space => \*(Aqmain\*(Aq,
\&                message =>[ \*(AqHello World 4\*(Aq ] });
\&        ###LogSD warn "sending the message \*(AqHello World 5\*(Aq to the report \*(Aqrun\*(Aq";
\&        my $result = 1;
\&        $result = $operator\->master_talk({
\&                report => \*(Aqrun\*(Aq, level => \*(Aqwarn\*(Aq, name_space => \*(Aqmain\*(Aq,
\&                message =>[ \*(AqHello World 5\*(Aq ] });
\&        ###LogSD warn "message to \*(Aqrun\*(Aq at \*(Aqwarn\*(Aq level was approved";
\&        ###LogSD warn "...but found \-$result\- reporting destinations (None were set up)";
\&
\&        package Print::Wisper;
\&        sub new{
\&                bless {}, shift;
\&        }
\&        sub add_line{
\&                shift;
\&                my @input = ( ref $_[0]\->{message} eq \*(AqARRAY\*(Aq ) ?
\&                                                @{$_[0]\->{message}} : $_[0]\->{message};
\&                my @new_list;
\&                map{ push @new_list, $_ if $_ } @input;
\&                chomp @new_list;
\&                print \*(Aq\-\-\->\*(Aq . lc(join( \*(Aq \*(Aq, @new_list )) . "<\-\-\-\en";
\&        }
\&
\&        1;
\&
\&        #######################################################################################
\&        # Synopsis Screen Output for the following condition
\&        # use Log::Shiras::Unhide;
\&        # 01: \-\-\->hello world 2<\-\-\-
\&        # 02: !!!HELLO WORLD 4!!!
\&        #######################################################################################
\&
\&        #######################################################################################
\&        # Synopsis Screen Output for the following condition
\&        # use Log::Shiras::Unhide qw( :debug );
\&        # 01: Using Log::Shiras::Unhide\-v0.29_1 strip_match string: (LogSD) at ../lib/Log/Shiras/Unhide.pm line 88.
\&        # 02: lets get ready to rumble... at log_shiras_switchboard.pl line 7.
\&        # 03: sending the message \*(AqHello World 1\*(Aq at log_shiras_switchboard.pl line 80.
\&        # 04: The name_space \*(Aqmain\*(Aq does not have destination \*(Aqlog_file\*(Aq permissions at log_shiras_switchboard.pl line 84.
\&        # 05: sending the message \*(AqHello World 2\*(Aq to the report \*(Aqquiet\*(Aq at log_shiras_switchboard.pl line 85.
\&        # 06: message went to the buffer \- turning off buffering for the \*(Aqquiet\*(Aq destination ... at log_shiras_switchboard.pl line 89.
\&        # 07: \-\-\->hello world 2<\-\-\-
\&        # 08: should have printed what was in the \*(Aqquiet\*(Aq buffer ... at log_shiras_switchboard.pl line 91.
\&        # 09: sending the message \*(AqHello World 4\*(Aq to the report \*(Aqloud\*(Aq at log_shiras_switchboard.pl line 95.
\&        # 10: !!!HELLO WORLD 4!!!
\&        # 11: sending the message \*(AqHello World 5\*(Aq to the report \*(Aqrun\*(Aq at log_shiras_switchboard.pl line 99.
\&        # 12: message to \*(Aqrun\*(Aq at \*(Aqwarn\*(Aq level was approved at log_shiras_switchboard.pl line 104.
\&        # 13: ...but found \-0\- reporting destinations (None were set up) at log_shiras_switchboard.pl line 105.
\&        #######################################################################################
\&
\&        #######################################################################################
\&        # Synopsis Screen Output for the following conditions
\&        # use Log::Shiras::Unhide qw( :debug :InternalSwitchboarD );
\&        # 01: Using Log::Shiras::Unhide\-v0.29_1 strip_match string: (LogSD|InternalSwitchboarD) at ../lib/Log/Shiras/Unhide.pm line 88.
\&        # 02: You uncovered internal logging statements for Log::Shiras::Types\-v0.29_1 at ..\elib\eLog\eShiras\eTypes.pm line 5.
\&        # 03: You uncovered internal logging statements for Log::Shiras::Switchboard\-v0.29_1 at ..\elib\eLog\eShiras\eSwitchboard.pm line 5.
\&        # 04: lets get ready to rumble... at log_shiras_switchboard.pl line 7.
\&        # 05: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 06: | line  \- 0704   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 07:   :(      Arrived at _buffer_decision for report: log_file
\&        # 08:           ..with buffer setting:  ):
\&        # 09: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 10: | line  \- 0715   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 11:   :(      Current action for report \-log_file\- is: report ):
\&        # 12: | level \- 2      | name_space \- Log::Shiras::Switchboard::get_operator
\&        # 13: | line  \- 0211   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 14:   :(      Switchboard finished updating the following arguments:
\&        # 15:           reports
\&        # 16:           name_space_bounds
\&        # 17:           all_buffering ):
\&        # 18: sending the message \*(AqHello World 1\*(Aq at log_shiras_switchboard.pl line 80.
\&        # 19: The name_space \*(Aqmain\*(Aq does not have destination \*(Aqlog_file\*(Aq permissions at log_shiras_switchboard.pl line 84.
\&        # 20: sending the message \*(AqHello World 2\*(Aq to the report \*(Aqquiet\*(Aq at log_shiras_switchboard.pl line 85.
\&        # 21: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 22: | line  \- 0704   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 23:   :(      Arrived at _buffer_decision for report: quiet
\&        # 24:           ..with buffer setting: 1 ):
\&        # 25: | level \- 1      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 26: | line  \- 0709   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 27:   # 01:   :(      The buffer is active \- sending the message to the buffer (not the report). ):
\&        # 28: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 29: | line  \- 0715   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 30:   :(      Current action for report \-quiet\- is: buffer ):
\&        # 31: message went to the buffer \- turning off buffering for the \*(Aqquiet\*(Aq destination ... at log_shiras_switchboard.pl line 89.
\&        # 32: \-\-\->hello world 2<\-\-\-
\&        # 33: should have printed what was in the \*(Aqquiet\*(Aq buffer ... at log_shiras_switchboard.pl line 91.
\&        # 34: sending the message \*(AqHello World 4\*(Aq to the report \*(Aqloud\*(Aq at log_shiras_switchboard.pl line 95.
\&        # 35: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 36: | line  \- 0704   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 37:   :(      Arrived at _buffer_decision for report: loud
\&        # 38:           ..with buffer setting:  ):
\&        # 39: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 40: | line  \- 0715   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 41:   :(      Current action for report \-loud\- is: report ):
\&        # 42: !!!HELLO WORLD 4!!!
\&        # 43: sending the message \*(AqHello World 5\*(Aq to the report \*(Aqrun\*(Aq at log_shiras_switchboard.pl line 99.
\&        # 44: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 45: | line  \- 0704   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 46:   :(      Arrived at _buffer_decision for report: run
\&        # 47:           ..with buffer setting:  ):
\&        # 48: | level \- 2      | name_space \- Log::Shiras::Switchboard::master_talk::_buffer_decision
\&        # 49: | line  \- 0715   | file_name  \- ..\elib\eLog\eShiras\eSwitchboard.pm
\&        # 50:   :(      Current action for report \-run\- is: report ):
\&        # 51: message to \*(Aqrun\*(Aq at \*(Aqwarn\*(Aq level was approved at log_shiras_switchboard.pl line 104.
\&        # 52: ...but found \-0\- reporting destinations (None were set up) at log_shiras_switchboard.pl line 105.
\&        #######################################################################################
.Ve
.SS "\s-1SYNOPSIS EXPLANATION\s0"
.IX Subsection "SYNOPSIS EXPLANATION"
.Vb 3
\&        use Log::Shiras::Unhide qw( :debug :InternalSwitchboarD );
\&        ..
\&        ###LogSD warn "lets get ready to rumble...";
.Ve
.Sp
.RS 4
Log::Shiras::Unhide strips ###MyCoolTag tags \- see Log::Shiras::Unhide for more information.
It represents the only driver between the three example outputs (All run from the same basic
script).  For instance when the :debug tag is passed to Unhide then ###LogSD is stripped.
When :InternalSwitchboarD is passed it strips ###InternalSwitchboarD.
.Sp
Each of the remaining functions is documented above but the difference between the three
outputs are based on what is unhid.  In all cases 'Hello World [1..5]' is sent to master_talk
in the switchboard.  All of the calls are valid syntax but not all calls have the necessary
target or urgency to be completed.
.Sp
In the first output it is obvious that only 'Hello World 2' and 'Hello World 4' have the
necessary permissions to be completed.  Each one is sent to a different report object so it
will be obvious based on the output what path it took to be printed.
.Sp
In the second output only the ###LogSD tags are removed and so comments associated with the
actions are exposed.  In this case these comments only exist in the script space so
warning messages are mostly the only thing exposed that is visible.  Since ~::Unhide is a
source filter it also provides a warning from the class showing that a source filter is
turned on and what is being scrubbed.  This includes scrubbing through the script and
all used modules.  (But not 'with' roles!).
.Sp
In the final output the ###InternalSwitchboarD tags are also stripped.  Since there
are a lot of these in Log::Shiras::Switchboard there is a number of things available to
see from that class.  However the operator only has released log_file messages for the
~::get_operator and ~::_buffer_decision name spaces.  A new class is also exposed that
can take advantage of message metadata and uses it to show where the message came from
as well has what urgency it was sent with.
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Log\-Shiras/issues <https://github.com/jandrew/Log-Shiras/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Add method to pull a full caller($x) stack and add it to message
metadata.  Probably should be triggered in the master_talk call args.
.Sp
\&\fB2.\fR Investigate the possibility of an \s-1ONLY\s0 keyword in addition to
of \s-1UNBLOCK\s0 \- how would this be implemented? \- Future uncertain
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
version
.Sp
5.010 <http://perldoc.perl.org/perl5100delta.html>
.Sp
utf8
.Sp
MooseX::Singleton
.Sp
MooseX::StrictConstructor
.Sp
MooseX::HasDefaults::RO
.Sp
DateTime
.Sp
Carp \- cluck confess
.Sp
MooseX::Types::Moose \- HashRef ArrayRef Bool RegexpRef Str Int
.Sp
Clone \- clone
.Sp
Data::Dumper
.Sp
MooseX::ShortCut::BuildInstance \- v1.44 \- build_instance should_re_use_classes
.Sp
Data::Walk::Extracted \- v0.28
.Sp
Data::Walk::Prune \- v0.028
.Sp
Data::Walk::Graft \- v0.028
.Sp
Data::Walk::Print \- v0.028
.Sp
Data::Walk::Clone \- v0.024
.Sp
Log::Shiras::Types
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Log::Shiras
.RE
