.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Object::Import 3"
.TH Object::Import 3 "2018-10-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Import \- import methods of an object as functions to a package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Object::Import $object;
\&        foo(@bar); # now means $object\->foo(@bar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lets you call methods of a certain object more easily by
exporting them as functions to a package.  The exported functions are
not called as methods and do not receive an object argument, but instead
the object is fixed at the time you import them with this module.
.PP
You use the module with the following syntax:
.PP
.Vb 1
\&        use Object::Import $object, %options;
.Ve
.PP
Here, \f(CW$object\fR is the object from which you want to import the methods.
This can be a perl object (blessed reference), or the name of a package
that has class methods.
.PP
As usual, a \f(CW\*(C`use\*(C'\fR statement is executed in compile time, so you should
take care not to use values that you compute only in run-time, eg.
.PP
.Vb 2
\&        my $object = Foo::Bar\->new();
\&        use Object::Import $object; # WRONG: $object is not yet initialized
.Ve
.PP
Instead, you have to create the object before you import, such as
.PP
.Vb 1
\&        use Object::Import Foo::Bar\->new();
.Ve
.PP
You can also call import in run-time, eg.
.PP
.Vb 3
\&        use Object::Import ();
\&        my $object = Foo::Bar\->new();
\&        import Object::Import $object;
.Ve
.PP
but in that case, you can't call the imported functions without parenthesis.
.PP
If you don't give an explicit list of methods to export, Object::Import
tries to find out what callable methods the object has and import
all of them.  Some methods are excluded from exporting in this case,
namely any methods where exporting would overwrite a function existing
in the target package or would override a builtin function, also
any methods with names that are special to perl, such as \f(CW\*(C`DESTROY\*(C'\fR,
and any methods whose name starts with an underscore.  This automatic
search for methods is quite fragile because of the way perl \s-1OO\s0 works,
so it can find subroutines that shouldn't actually be called as methods,
or not find methods that can actually be called.  In particular, even
if you import an object from a purely object oriented module, it can
find non-method subs imported from other (non-OO) modules.
.PP
If you do give a list of methods to export, Object::Import trusts you
know what you mean, so it exports all those subs even if it has to
replace existing subs or break something else.
.SH "OPTIONS"
.IX Header "OPTIONS"
The following import options can be passed to the module.
.ie n .IP """list =>"" \fI\f(CI$arrayref\fI\fR" 4
.el .IP "\f(CWlist =>\fR \fI\f(CI$arrayref\fI\fR" 4
.IX Item "list => $arrayref"
Sets the list of methods to export, instead of the module deciding automatically.
\&\fI\f(CI$arrayref\fI\fR must be a reference to an array containing method names.  Eg.
.Sp
.Vb 2
\&        use Object::Import LWP::UserAgent\->new, list =>
\&                [qw"get post head mirror request simple_request"];
.Ve
.ie n .IP """target =>"" \fI\f(CI$package_name\fI\fR" 4
.el .IP "\f(CWtarget =>\fR \fI\f(CI$package_name\fI\fR" 4
.IX Item "target => $package_name"
Export the sub names to the given namespace.  Default is the package
from where you call import.
.ie n .IP """deref => 1""" 4
.el .IP "\f(CWderef => 1\fR" 4
.IX Item "deref => 1"
Signals that the first import argument, instead of being the object
itself, is a reference to a scalar that contains the object.
.Sp
The content of this scalar may later be changed, and the imported
functions will be called on the new contents.  (The scalar may even be
filled with undef, as long as you don't call the functions at that time.)
If you don't pass the list of methods explicitly, the content of the
scalar at the time of the import is used for determining the methods as
a template to determine the methods.  If, however, you give the list
of methods, the content of the scalar is not examined at the time of
the import.
.ie n .IP """prefix =>"" \fI\f(CI$string\fI\fR" 4
.el .IP "\f(CWprefix =>\fR \fI\f(CI$string\fI\fR" 4
.IX Item "prefix => $string"
Prepends a string to the names of functions imported.  This is useful if
some of the method names are the same as existing subs or builtins.  Eg.
.Sp
.Vb 2
\&        use Object::Import $object, prefix => "foo";
\&        foo_bar(); # calls $object\->bar();
.Ve
.ie n .IP """suffix =>"" \fI\f(CI$string\fI\fR" 4
.el .IP "\f(CWsuffix =>\fR \fI\f(CI$string\fI\fR" 4
.IX Item "suffix => $string"
Like the prefix option, only the string is appended.
.ie n .IP """underscore => 1""" 4
.el .IP "\f(CWunderscore => 1\fR" 4
.IX Item "underscore => 1"
Consider a method for automatic inclusion even if its name starts with
an underscore.  Such methods are normally excluded, because they are
usually used as private subs.
.ie n .IP """exclude_methods =>"" \fI\f(CI$hashref\fI\fR" 4
.el .IP "\f(CWexclude_methods =>\fR \fI\f(CI$hashref\fI\fR" 4
.IX Item "exclude_methods => $hashref"
Sets a list of additional methods that are not automatically imported.
The argument must be a reference to a hash whose keys are potential
method names.  Ignored if you use the \f(CW\*(C`list\*(C'\fR option.
.ie n .IP """exclude_imports =>"" \fI\f(CI$hashref\fI\fR" 4
.el .IP "\f(CWexclude_imports =>\fR \fI\f(CI$hashref\fI\fR" 4
.IX Item "exclude_imports => $hashref"
Sets a list of additional sub names which the module must never use as
names of imported subs.  These names are thus compared not with the
original method names, but the names possibly transformed by adding
prefixes and suffixes.  This applies even if you give an explicit \f(CW\*(C`list\*(C'\fR
of methods to import.
.ie n .IP """savenames =>"" \fI\f(CI$hashref\fI\fR" 4
.el .IP "\f(CWsavenames =>\fR \fI\f(CI$hashref\fI\fR" 4
.IX Item "savenames => $hashref"
Save the (unqualified) names of the functions exported by adding them
as a key to a hash (the value is incremented with the ++ operator).
This could be useful if you wanted to reexport them with Exporter.
\&\fI\f(CI$arrayref\fI\fR must be a real reference to a hash, not an undef.
.ie n .IP """nowarn_redefine => 1""" 4
.el .IP "\f(CWnowarn_redefine => 1\fR" 4
.IX Item "nowarn_redefine => 1"
Do not warn when an existing sub is redefined.  That is currently only
possible if you give the list of methods to be exported explicitly with
the \f(CW\*(C`list\*(C'\fR option, because if the module chooses automatically then it
will not redefine subs.
.ie n .IP """nowarn_nomethod => 1""" 4
.el .IP "\f(CWnowarn_nomethod => 1\fR" 4
.IX Item "nowarn_nomethod => 1"
Suppress the warning when you try to import methods from an object you
might have passed in by mistake.  Namely the object could be the name
of a nonexistent package, a string that is not a valid package name,
an unblessed object, or undef.  Such values either don't currently have
any methods, or calling methods on them is impossible.  That warning
often indicates that you passed the wrong value to Object::Import or
forgot to require a package.
.ie n .IP """debug => 1""" 4
.el .IP "\f(CWdebug => 1\fR" 4
.IX Item "debug => 1"
Print debugging messages about what the module exports.
.SH "NOTES"
.IX Header "NOTES"
.SS "Importing from \s-1IO\s0 handles"
.IX Subsection "Importing from IO handles"
It is possible to use an \s-1IO\s0 handle as the object to export methods from.
If you do this, you should require IO::Handle first so that the handle
actually has methods.  You should probably also use the prefix or suffix
option in such a case, because many methods of handles have the same name
as a builtin function.
.PP
The handle must not be a symbolic reference, whether qualified or
unqualified, eg.
.PP
.Vb 2
\&        open FOO, "<", "somefile" or die;
\&        use Object::Import "FOO"; # WRONG
.Ve
.PP
You can pass a handle as a glob, reference to glob, or an IO::Handle
object, so any of these would work as the object after the above open
statement: \f(CW*FOO\fR, \f(CW\*(C`\e*FOO\*(C'\fR, \f(CW*FOO{IO}\fR.  Another way to pass an
IO::Handle object would be like this:
.PP
.Vb 2
\&        use IO::File;
\&        use Object::Import IO::File\->new("somefile", "<");
.Ve
.SS "Changing the object"
.IX Subsection "Changing the object"
The \f(CW\*(C`deref\*(C'\fR option deserves special mention.
This option adds a level of indirection to the imported functions:
instead of them calling methods on an object passed to import,
the methods are called on the object currently contained by a scalar
to which a reference is passed in to import.
This can be useful for various reasons:
operating on multiple objects throughout the course of the program,
being able to import the functions at compile time before you create the object,
or being able to destroy the object.
The first of this use is straightforward,
but you may need to know the following for the other two uses.
.PP
The list of methods imported is decided at the time you call import,
and will not be changed later,
no matter how the object is changed or methods the object supports are changed.
You thus have to do extra loops if you want to call import
before the object is available.
The simplest solution is to pass the list of methods you want explicitly
using the \fIlist\fR option.
If for some reason you don't want to do this,
you need to fill the scalar with a suitable prototype object
that has all the methods of the actual object you want to use.
In many cases,
the package name the object will be blessed to is a suitable prototype,
but note that if you do not control the module implementing the object,
then that module may not guarantee
what package the object will actually be blessed to:
the package may depend on some run-time parameters
and the details about this could change in future versions of the module.
This is, of course, not specific to the deref option,
but true to a lesser extent to any case when you're using
Object::Import without an explicit list of methods:
a future version of the module could create the methods of the class
in runtime or \s-1AUTOLOAD\s0 them without declaring them,
or it could add new private methods that will clash with function names you're using.
Nevertheless, using the classname as a prototype can be a useful trick
in quick and dirty programs,
or if you are in control of the implementation of the object.
.PP
Now let's hear about destroying an object that may hold resources you want to free.
Object::Import guarantees that if you use the \fIderef\fR option,
it does not hold references to the object other than through the one scalar,
so if undef the contents of that scalar,
the object will be freed unless there are references from somewhere else.
.PP
Finally, there's one thing you don't want to know but I must document it for completeness:
if a method called through Object::Import changes its invocant (zeroth argument),
that will also change the object the imported functions refer to,
whether you use the deref option or not,
and will change the contents of the scalar if you use the deref option.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Our examples assume the following declarations:
.PP
.Vb 1
\&        use feature "say";
.Ve
.SS "Basic usage"
.IX Subsection "Basic usage"
First a simple example of importing class methods.
.PP
.Vb 3
\&        use Math::BigInt;
\&        use Object::Import Math::BigInt::;
\&        say new("0x100");
.Ve
.PP
This prints 256, because Math::BigInt\->new(\*(L"0x100\*(R") creates a big integer equal to 256.
.PP
Now let's see a simple example of importing object methods.
.PP
.Vb 4
\&        use Math::BigInt;
\&        use Object::Import Math::BigInt\->new("100");
\&        say bmul(2);
\&        say as_hex();
.Ve
.PP
This prints 200 (2 multiplied by 100), then 0xc8 (100 as hexadecimal).
.SS "Multiple imports"
.IX Subsection "Multiple imports"
Now let's see a more complicated example.  This prints the leading news from the English
Wikinews website.
.PP
.Vb 10
\&        use warnings; use strict;
\&        use LWP::UserAgent;
\&        use XML::Twig;
\&        use Object::Import LWP::UserAgent\->new;
\&        my $response = get "http://en.wikinews.org/wiki/Special:Export?".
\&                "pages=Template:Lead_article_1&limit=1";
\&        import Object::Import $response;
\&        if (is_success()) {
\&                use Object::Import XML::Twig\->new;
\&                parse content();
\&                for my $parmname (qw"title summary") {
\&                        first_elt("text")\->text =~ /\e|\es*$parmname\es*=([^\e|\e}]+)/ or die;
\&                        print $1;
\&                }
\&        } else {
\&                die message();
\&        }
.Ve
.PP
For example, as I am writing this (2010\-09\-05), this outputs
.Sp
.RS 4
Magnitude 7.0 earthquake hits New Zealand
.Sp
An earthquake with magnitude 7.0 occurred near South Island, New
Zealand at Saturday 04:35:44 \s-1AM\s0 local time (16:35:44 \s-1UTC\s0). The
earthquake occurred at a depth of 16.1 kilometers (10.0 miles). The
earthquake was reported to have caused widespread damage and power
outages. Several aftershocks were also reported.
.RE
.PP
In this, \f(CW\*(C`get\*(C'\fR refers to the useragent object; \f(CW\*(C`is_success\*(C'\fR, \f(CW\*(C`content\*(C'\fR
and \f(CW\*(C`message\*(C'\fR refers to the response object (and these must be called
with a parenthesis); while \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`first_elt\*(C'\fR refer to the
twig object.  This is not a good example to follow: it's quite fragile,
and not only because of the simple regex used to parse out the right
parts, but because if a new sub is added to a future version of the
LWP::UserAgent or HTTP::Response classes, they might suddenly get
imported and would shadow the methods we're supposed to import later.
.SS "Suffix"
.IX Subsection "Suffix"
Now let's see an example of using a suffix.
.PP
.Vb 6
\&        use File::Temp;
\&        use Object::Import scalar(File::Temp\->new()), suffix => "temp";
\&        printtemp "hello, world\enhidden";
\&        seektemp 0, 0;
\&        print getlinetemp;
\&        say filenametemp;
.Ve
.PP
Here we need the suffix because print and seek are names of builtin
functions.
.SS "Creating the object later"
.IX Subsection "Creating the object later"
Let's see how we can import methods before we create an object.
.PP
.Vb 6
\&        use Math::BigInt;
\&        our $number;
\&        use Object::Import \e$number, deref => 1, list => ["bmul"];
\&        sub double { bmul 2 }
\&        $number = Math::BigInt\->new("100");
\&        say double;
.Ve
.PP
This will output 200.
Notice how here we're using the bmul function without parenthesis,
so we must import it compile time for the code to parse correctly,
but the object is not created till later.
.SS "Prototype object"
.IX Subsection "Prototype object"
This code is the same as above,
except that instead of supplying a list of methods,
we use a prototype object, namely the Math::BigInt package.
At least one of the two is needed, for otherwise Object::Import
would have no way to know what methods to import.
.PP
.Vb 6
\&        use Math::BigInt;
\&        our $number;
\&        use Object::Import \e($number = Math::BigInt::), deref => 1;
\&        sub double { bmul 2 }
\&        $number = Math::BigInt\->new("100");
\&        say double;
.Ve
.SS "Exporting to other package"
.IX Subsection "Exporting to other package"
This example shows how to export to a different namespace.
This is useful if you want to write your own
sugar module that provides a procedural syntax:
.PP
.Vb 3
\&        package My::Object::DSL;
\&        use Object::Import;
\&        use My::Object;
\&
\&        sub import {
\&            my ($class, %options);
\&            if (@_ == 2) {
\&                ($class, $options{ name }) = @_;
\&            } else {
\&                ($class, %options) = @_;
\&            };
\&            my $target = delete $options{ target } || caller;
\&            my $name = delete $options{ name } || \*(Aq$obj\*(Aq;
\&            my $obj = My::Object\->new(%options);
\&
\&            $name =~ s/^[\e$]//
\&                or croak \*(AqVariable name must start with $\*(Aq;
\&            {
\&                no strict \*(Aqrefs\*(Aq;
\&                *{"$target\e::$name"} = \e$obj;
\&                # Now install in $target::
\&                import Object::Import \e${"$target\e::$name"},
\&                                      deref => 1,
\&                                      target => $target;
\&            }
\&        }
.Ve
.PP
You can use the module \f(CW\*(C`My::Object::DSL\*(C'\fR as follows:
.PP
.Vb 1
\&        use My::Object::DSL \*(Aq$obj\*(Aq;
.Ve
.PP
If you want to pass more options, you can use
.PP
.Vb 1
\&        use My::Object::DSL name => \*(Aq$obj\*(Aq, foo => \*(Aqbar\*(Aq;
.Ve
.PP
Implementing a small \f(CW\*(C`::DSL\*(C'\fR module instead of using
\&\f(CW\*(C`Object::Import\*(C'\fR directly has the advantage that you can add defaults
in \f(CW\*(C`DSL.pm\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::Exporter, Scope::With, Sub::Exporter, Acme::Nooo
.SH "BUGS"
.IX Header "BUGS"
Please report bugs using the \s-1CPAN\s0 bug tracker (under the distribution
name Object-Import), or, failing that, to \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "CREDITS"
.IX Header "CREDITS"
The primary author and maintainer of this module is Zsban Ambrus
\&\f(CW\*(C`ambrus@math.bme.hu\*(C'\fR.  Some of the code was written by Max Maischein, who
also gave the motivation to turn a prototype to the full module you see.
Thanks to exussum0 for the original inspiration.
.PP
The module is maintained by Max Maischein since 2018.
.SH "COPYING"
.IX Header "COPYING"
Copyright (C) Zsban Ambrus 2010
.PP
This program is free software: you can redistribute it and/or modify
it under the terms of either the \s-1GNU\s0 General Public License version 3,
as published by the Free Software Foundation; or the \*(L"Artistic License\*(R"
which comes with perl.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
A copy of the \s-1GNU\s0 General Public License can be found in the
source tree of this module under the name \*(L"\s-1GPL\*(R",\s0 or else see
\&\*(L"http://www.gnu.org/licenses/\*(R".  A copy of the Artistic License can
be found in the source tree under the name \*(L"\s-1ARTISTIC\*(R",\s0 or else see
\&\*(L"http://search.cpan.org/~rjbs/perl\-5.16.1/pod/perlartistic.pod\*(R".
