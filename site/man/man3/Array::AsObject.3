.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Array::AsObject 3"
.TH Array::AsObject 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Array::AsObject \- full set of array and set operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   $obj = new Array::AsObject [@list];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module attempts to provide a complete set of array operations,
including set operations. It acts as a standalone module, or is
available in Template::Toolkit templates using the companion module
Template::Plugin::ListOps .
.PP
It performs many of the same functions as the Set::Array module,
but has better support for handling duplicate elements in
lists, and does not require the Want module.  For more
details, please refer to the \s-1HISTORY AND RATIONALE\s0 section
below.
.SH "BASE OBJECT METHODS"
.IX Header "BASE OBJECT METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&   $obj = new Array::AsObject [@list];
.Ve
.Sp
This creates a new Array::AsObject object. If \f(CW@list\fR is passed in, this
is set to the initial list of elements.
.Sp
If \f(CW@list\fR is passed in, the following two are equivalent:
.Sp
.Vb 1
\&   $obj = new Array::AsObject @list;
.Ve
.Sp
and
.Sp
.Vb 2
\&   $obj = new Array::AsObject;
\&   $obj\->list(@list);
.Ve
.Sp
There is no restriction on the type of elements in \f(CW@list\fR. They can be
scalars, references, objects, or undefs.
.IP "version" 4
.IX Item "version"
.Vb 1
\&   $vers = $obj\->version();
.Ve
.Sp
Gets the version of this module.
.IP "err" 4
.IX Item "err"
.PD 0
.IP "errmsg" 4
.IX Item "errmsg"
.PD
.Vb 1
\&   $err = $obj\->err();
.Ve
.Sp
Check to see if the previous operation produced an error.
.Sp
.Vb 1
\&   $msg = $obj\->errmsg();
.Ve
.Sp
If an operation did produce an error, this will get the error message.
.SH "LIST EXAMINATION METHODS"
.IX Header "LIST EXAMINATION METHODS"
The following methods examine a list but do not modify the object.
They will all produce an error if the list has not been defined and
undef is returned.
.IP "as_hash" 4
.IX Item "as_hash"
.Vb 1
\&   %hash = $obj\->as_hash();
.Ve
.Sp
This returns a hash that describes the scalars in the list contained
in \f(CW$obj\fR. References and undef values are ignored.
.Sp
Every scalar in the list is one of the keys in \f(CW%hash\fR.  The value of
\&\f(CW%hash\fR is the number of times that element appears in the list.
.Sp
.Vb 1
\&   ($count,$vals) = $obj\->as_hash(1);
.Ve
.Sp
This returns two hash references that describe \s-1ALL\s0 values in the
list, including references, objects, and undef.
.Sp
Every unique value in the list is assigned a label (which has no
significance). The hash %$vals has the labels as keys and the
actual values as values for the keys.
.Sp
The hash %$count has the labels as keys and the values are the
number of times that value appears in the list.
.Sp
The following example should illustrate this:
.Sp
.Vb 10
\&   $i = [1,2];
\&   $j = [1,2];
\&   @l = (\*(Aqa\*(Aq, $i, \*(Aqb\*(Aq, $j, \*(Aqa\*(Aq, undef, undef, $i);
\&   $o = new Array::AsObject(@l);
\&   ($c,$v) = $o\->as_hash(1)
\&      => $c = { 1 => 2,
\&                2 => 2,
\&                3 => 1,
\&                4 => 1,
\&                5 => 2 }
\&         $v = { 1 => \*(Aqa\*(Aq,
\&                2 => [1,2],
\&                3 => \*(Aqb\*(Aq,
\&                4 => [1,2],
\&                5 => undef }
.Ve
.Sp
Note that the two elements \f(CW$i\fR and \f(CW$j\fR are treated as different since
they point to different references, even though the data is the same
in those two lists.
.IP "at" 4
.IX Item "at"
.Vb 2
\&   $ele = $obj\->at($n);
\&   @ele = $obj\->at(@n);
.Ve
.Sp
This returns the element at position \f(CW$n\fR in the list, or a list of the
elements at the positions given in the list \f(CW@n\fR.
.Sp
In scalar context, only a single position may be passed in. In list
context, any number of positions may be passed in.
.Sp
Positions follow standard perl conventions with numbering starting at
0. Negative numbers can also be used to count from the end.  All
positions must refer to elements in the list (i.e. you may not refer
to the 6th element in a list containing 5 elements).
.IP "count" 4
.IX Item "count"
.Vb 1
\&   $num = $obj\->count([$val]);
.Ve
.Sp
This counts the number of times val appears in the list. If \f(CW$val\fR
is not given, it counts the number of undef elements in the list.
.IP "exists" 4
.IX Item "exists"
.Vb 1
\&   $flag = $obj\->exists(@val);
.Ve
.Sp
This returns 1 if every value exists in the list. If \f(CW@val\fR is not
passed in, it tests for undef values.
.Sp
It returns 0 if any of the values do not exists in the list.
.IP "first" 4
.IX Item "first"
.PD 0
.IP "last" 4
.IX Item "last"
.PD
.Vb 2
\&   $val = $obj\->first();
\&   $val = $obj\->last();
.Ve
.Sp
These return the first or last elements of the list. If the list contains
no elements, an error is set.
.IP "index" 4
.IX Item "index"
.PD 0
.IP "rindex" 4
.IX Item "rindex"
.PD
.Vb 2
\&   $idx = $obj\->index([$val]);
\&   @idx = $obj\->index([$val]);
\&
\&   $idx = $obj\->rindex([$val]);
\&   @idx = $obj\->rindex([$val]);
.Ve
.Sp
In list context, these return the index of every occurrence of \f(CW$val\fR in
the list. If \f(CW$val\fR is not passed in, the indices of all undef elements
are returned.
.Sp
If the value is not found, \-1 is returned in scalar context, or
an empty list in list context.
.Sp
The rindex function returns them in reverse order.
.Sp
In scalar context, the index and rindex methods return the index of
the first or last occurrence of \f(CW$val\fR in the list.
.Sp
\&\f(CW$val\fR can be a scalar, undef, or a reference, and all will work
as expected. For example:
.Sp
.Vb 8
\&   $i = [1,2];
\&   $j = [1,2];
\&   @l = (\*(Aqa\*(Aq, $i, \*(Aqb\*(Aq, $j, \*(Aqa\*(Aq, undef, undef, $i);
\&   $o = new Array::AsObject(@l);
\&   (@idx) = $o\->index();
\&      => @idx = (5, 6)
\&   (@idx) = $o\->index($i);
\&      => @idx = (1)
.Ve
.IP "is_empty" 4
.IX Item "is_empty"
.Vb 1
\&   $flag = $obj\->is_empty([$undef]);
.Ve
.Sp
This checks to see if the list is empty. If \f(CW$undef\fR is not passed in,
a list is empty only if the length is 0.
.Sp
If \f(CW$undef\fR is passed in, the list is also empty if it consists only
of undef values.
.IP "length" 4
.IX Item "length"
.Vb 1
\&   $num = $obj\->length();
.Ve
.Sp
Returns the number of elements in the list.
.IP "list" 4
.IX Item "list"
.Vb 1
\&   @list = $obj\->list();
.Ve
.Sp
This returns the list stored in the object.
.SH "SIMPLE LIST MODIFICATION METHODS"
.IX Header "SIMPLE LIST MODIFICATION METHODS"
The following methods will modify the object.
.PP
They will all produce an error if the list has not been defined
and undef is returned.
.IP "clear" 4
.IX Item "clear"
.Vb 1
\&   $obj\->clear();
.Ve
.Sp
This removes all elements from the list (sets it to a zero-length
list).
.Sp
.Vb 1
\&   $obj\->clear(1);
.Ve
.Sp
This sets all elements in the list to be undef (preserving the length).
The list must be defined or an error results.
.IP "compact" 4
.IX Item "compact"
.Vb 1
\&   $obj\->compact();
.Ve
.Sp
This removes any undef objects from the list.
.IP "delete" 4
.IX Item "delete"
.Vb 1
\&   $obj\->delete($all,$undef,@val);
.Ve
.Sp
This deletes occurences of each values from the list.
.Sp
If \f(CW$all\fR is 1, all occurences are removed. Otherwise, only the first
occurence of each value is removed.
.Sp
If \f(CW$undef\fR is 1, values are replaced with undef. Otherwise, they
are completely removed.
.IP "delete_at" 4
.IX Item "delete_at"
.Vb 1
\&   $obj\->delete($undef,@idx);
.Ve
.Sp
This deletes elements at the given indices. The order of the
indices is not important. They will be deleted in the order of
last to first.
.Sp
If \f(CW$undef\fR is 1, values are replaced with undef. Otherwise, they
are completely removed.
.IP "fill" 4
.IX Item "fill"
.Vb 1
\&   $obj\->fill([$val,] [$start,] [$length]);
.Ve
.Sp
This sets elements of a list to be \f(CW$val\fR. If \f(CW$val\fR is not passed in,
values are set to undef.
.Sp
\&\f(CW$start\fR can be a positive or negative number. It must be an index
in the list. It can also be the index of the first element after
the list. So, if the list contains 3 elements, \f(CW$start\fR can be \-3 to +3.
Negative values refer to the index from the end as usual. 0 to 2 refer
to the index of the elements in the list, and 3 is the first element
after the list. \f(CW$start\fR defaults to 0.
.Sp
\&\f(CW$length\fR can be any positive value and refers to the number of elements
that will be set to the value. If \f(CW$length\fR is omitted, it defaults
to the number of elements in the list starting at \f(CW$start\fR, or to 1 if
\&\f(CW$start\fR is the first element after the list.
.Sp
So if list contains 3 elements, and \f(CW$start\fR is 1, \f(CW$length\fR will default
to 2 (the number of elements in the list starting at index 1.
.IP "list" 4
.IX Item "list"
.Vb 1
\&   $obj\->list(@list);
.Ve
.Sp
This sets the object to contain the given list. Any previous list is
replaced.
.IP "min" 4
.IX Item "min"
.PD 0
.IP "max" 4
.IX Item "max"
.PD
.Vb 2
\&   $ele = $obj\->min([$method [,@args]]);
\&   $ele = $obj\->max([$method [,@args]]);
.Ve
.Sp
These return the first/last value from the list if it were sorted
with the given method using the Sort::DataTypes module.
.Sp
By default, if \f(CW$method\fR is not given, the numerical minimum/maximum
value is given.
.Sp
Otherwise, \f(CW$method\fR can be any sort method available from the
Sort::DataTypes module.
.Sp
For example, to get the first word alphabetically, use
.Sp
.Vb 1
\&   $ele = $obj\->min("alphabetic");
.Ve
.IP "pop" 4
.IX Item "pop"
.PD 0
.IP "shift" 4
.IX Item "shift"
.PD
.Vb 1
\&   $val = $obj\->pop();
\&
\&   $val = $obj\->shift();
.Ve
.Sp
These perform the standard pop/shift operations.
.IP "push" 4
.IX Item "push"
.PD 0
.IP "unshift" 4
.IX Item "unshift"
.PD
.Vb 1
\&   $obj\->push(@list);
\&
\&   $obj\->unshift(@list);
.Ve
.Sp
These perform the standard push/unshift operations.
.IP "randomize" 4
.IX Item "randomize"
.Vb 1
\&   $obj\->randomize();
.Ve
.Sp
This randomly shuffles the list.
.IP "reverse" 4
.IX Item "reverse"
.Vb 1
\&   $obj\->reverse();
.Ve
.Sp
This reverses the list.
.IP "rotate" 4
.IX Item "rotate"
.Vb 1
\&   $obj\->rotate([$num]);
.Ve
.Sp
This rotates the list.
.Sp
If \f(CW$num\fR is not included, it defaults to 1.
.Sp
If \f(CW$num\fR is a positive number, the first element from the list is
removed and pushed on to the end a total of \f(CW$num\fR times.
.Sp
If \f(CW$num\fR is a negative number, the last element from the list is
removed and shifted onto the front a total of \f(CW$num\fR times.
.IP "set" 4
.IX Item "set"
.Vb 1
\&   $obj\->set($index [,$val]);
.Ve
.Sp
This sets the list index to the given value, or undef if no value
is passedin.
.IP "sort" 4
.IX Item "sort"
.Vb 1
\&   $obj\->sort([$method [,@args]]);
.Ve
.Sp
This uses any method from the Sort::DataTypes module to sort the
list.
.Sp
Method can be of the form \*(L"numerical\*(R" or \*(L"rev_numerical\*(R" to do
forward and reverse sorting.
.Sp
\&\f(CW@args\fR may be passed in if the method requires additional arguments.
.Sp
If no method is given, it defaults to alphabetical sorting.
.IP "splice" 4
.IX Item "splice"
.Vb 1
\&   @vals = $obj\->splice([$start,] [$length,] [@list]);
.Ve
.Sp
This performs the perl splice command on a list.
.Sp
If \f(CW$start\fR is omitted (or is undefined), it defaults to 0. If \f(CW$length\fR
is omitted (or undefined), it defaults to the end of the list.
.Sp
The values removed are returned, and are replaced with \f(CW@list\fR if
present.
.IP "unique" 4
.IX Item "unique"
.Vb 1
\&   $obj\->unique();
.Ve
.Sp
This removes any duplicates in a list. The first occurrence of each element
is kept, and the order of those first occurrences is preserved.
.SH "SET METHODS"
.IX Header "SET METHODS"
The following methods work with two Array::AsObject objects. They apply
a set operation to the two of them and produce a value or a third
Array::AsObject object containing the results.
.PP
If an error occurs, it is set in the returned object, \s-1NOT\s0 in any of the
original objects.
.PP
The original objects are unmodified in all cases.
.IP "difference" 4
.IX Item "difference"
.Vb 1
\&   $obj3 = $obj\->difference($obj2 [,$unique]);
.Ve
.Sp
This takes two lists and removes the second list from the first.
.Sp
By default, one occurence of every element in the second list is
removed from the first list.
.Sp
If \f(CW$unique\fR is given, every element in the first list is removed.
.Sp
For example, the difference of the two lists (a a b b c) and (a)
is either (a b b c) or (b b c). If \f(CW$unique\fR is non-zero, the second
is given.
.Sp
It should be noted that both \*(L"b\*(R" elements in the example will be
kept regardless of the value of \f(CW$unique\fR because the \f(CW$unique\fR
flag only affects elements being removed.
.IP "intersection" 4
.IX Item "intersection"
.Vb 1
\&   $obj3 = $obj\->intersection($obj2 [,$unique]);
.Ve
.Sp
This takes two lists and finds the intersection of the two. The
intersection are elements that are in both lists. The returned
list is in the order they appear in the first list.
.Sp
By default, duplicate elements are treated individually unless
\&\f(CW$unique\fR is passed in.
.Sp
For example, the intersection of two lists (a a b b c) and (a a c d)
is either (a a c) or (a c). If \f(CW$unique\fR is non-zero, the second is
given.
.IP "is_equal" 4
.IX Item "is_equal"
.PD 0
.IP "not_equal" 4
.IX Item "not_equal"
.PD
.Vb 2
\&   $flag = $obj\->is_equal($obj2 [,$unique]);
\&   $flag = $obj\->not_equal($obj2 [,$unique]);
.Ve
.Sp
These take two lists and test to see if they are equal. If an
error is encountered, undef is returned, but no error is stored.
.Sp
The order of the elements is ignored so (a,b) = (b,a).
.Sp
If \f(CW$unique\fR is non-zero, the count of each type of element is
ignored so (a,a,b) = (a,b). Otherwise, the count is important
so (a,a,b) != (a,b).
.IP "is_subset" 4
.IX Item "is_subset"
.PD 0
.IP "not_subset" 4
.IX Item "not_subset"
.PD
.Vb 2
\&   $flag = $obj\->is_subset($obj2 [,$unique]);
\&   $flag = $obj\->not_subset($obj2 [,$unique]);
.Ve
.Sp
These return 1 if the list in \f(CW$obj2\fR is a subset of the list in \f(CW$obj\fR
(or is \s-1NOT\s0 a subset).
.Sp
If \f(CW$unique\fR is not passed in, every element in \f(CW$obj2\fR must have an
instance in \f(CW$obj\fR. So (a a b) is a subset of (a a a b c) but \s-1NOT\s0 of
(a b c).
.Sp
If \f(CW$unique\fR is passed in, every element in \f(CW$obj2\fR must exists in \f(CW$obj\fR
but the count is unimportant, so (a a b) is a subset of (a b c).
.IP "symmetric_difference" 4
.IX Item "symmetric_difference"
.Vb 1
\&   $obj3 = $obj\->symmetric_difference($obj2 [,$unique]);
.Ve
.Sp
This takes two lists and finds the symmetric difference of the
two. The symmetric difference are elements that are in either list,
but not both. The order of the list produced are the elements from
the first object (order preserved) followed by those from the
second object.
.Sp
If \f(CW$unique\fR is non-zero, one instance of an element cancels out
all of the instances in the other list.
.Sp
For example, the symmetric difference between the two lists (a a b b
c) and (a c) is either (a b b) or (b b). If \f(CW$unique\fR is non-zero, the
second is used.
.Sp
Note that both instances of 'b' are kept because the \f(CW$unique\fR flag
only affects elements which exist in both objects.
.IP "union" 4
.IX Item "union"
.Vb 1
\&   $obj3 = $obj\->union($obj2 [,$unique]);
.Ve
.Sp
This takes two lists and combines them.
.Sp
By default, every element is preserved. If \f(CW$unique\fR is passed in,
the duplicates are removed.
.Sp
For example, the union of the two lists (a a b) and (a c) is either
(a a b a c) or (a b c). The second is returned if \f(CW$unique\fR is non-zero.
.SH "HISTORY AND RATIONALE"
.IX Header "HISTORY AND RATIONALE"
With several other modules out there that do various set and array
operations, a brief history of why I wrote this module is in order.
.PP
The origin of this module came when I needed better list handling
operations (especially involving lists that might contain duplicate
elements) inside of a Template::Toolkit template. The built in list
functions in Template::Toolkit weren't sufficent for my needs, so I
looked around.
.PP
The module that came closest to my needs was Set::Array. Although not
a perfect match for what I wanted (I really wanted better support for
lists with duplicate elements), it came close enough, so I wrote a
wrapper module (Template::Plugin::ListOps) around it to do most of
what I wanted.
.PP
Unfortunately, I discovered almost immediately that Set::Array
suffered from a fairly serious problem. It depends on the Want
module which, at the time, had some known problems and would fail
under some circumstances (older versions of perl if I recall
correctly, though I could be wrong about that), and unfortunately,
some of the places I needed my module to run failed due to those
problems.
.PP
I looked at the Want module, but correcting it was beyond my abiltity,
so the best solution seemed to be to rewrite the module without
depending on Set::Array. This would also allow me to add the
functionality that I wanted.
.PP
So I did that. I rewrote each function to do the list/set operation
I wanted instead of calling Set::Array functions.
.PP
Almost as soon as I was done (and perhaps even before), I started
regretting rewriting the module in that way. I should have written a
standalone module and then had the Template::Plugin::ListOps be a
wrapper for it instead of Set::Array... but in the interest of time, I
didn't go back and redo it... until later.
.PP
Later, I ran into a case where I wanted the set/list functionality
from Template::Plugin::ListOps for another perl application. At
that point, I decided to create the standalone module.
.PP
So, this module takes the routines from the original
Template::Plugin::ListOps module and moves them into a standalone
module. Template::Plugin::ListOps was then rewritten trivially
to be a wrapper around this module.
.PP
Some other notes:
.PP
Since the original version of Template::Plugin::ListOps (which was
never released) was a wrapper around Set::Array, the naming of the
functions is very similar, but the functionality differs slightly.
.PP
This module was initially named Set::ArrayAlt to indicate that it is
based on Set::Array, but with a few changes. It has enhanced
functionality with respect to duplicate elements but is missing some
of the functionality of Set::Array (especially method chaining and
operator overloading) which depend on the Want module.  This module
is not intended to be a drop-in replacement for Set::Array. It is
also missing a couple functions (join and impose) that are applicable
only to all-scalar lists.
.PP
It may well be that the problems with the Want module have been
corrected at this point, and that I could have used Set::Array, but
since some of the functionality I needed was the enhanced duplicate
element handling, and since creating this module from what I'd already
written was actually a pretty easy task, I decided to go ahead with
the creation of this module.
.PP
Anyway, that's the history. Hopefully, I'm justified in reinventing
the wheel.
.PP
After a while, I decided I wanted to register this module (which
basically means to get it put in the official list of perl modules).
The upside is that the module will get added publicity and use...
the downside (if you can call it that) is that they expect the name
of the module to accurately reflect the module.
.PP
This module is more accurately thought of as a module for handling
arrays, than as a module for handling sets. True, it does do set
operations, but it really works on an array, doing most of the
operations that you could want to do with an array. Included in
those operations are a subset of functions where you treat the array
as a set.
.PP
Anyway, it was requested that I rename the module to be in the Array::
namespace rather than the Set:: namespace (and Array::AsObject was
suggested), so that's why it's been renamed.
.PP
Versions of this module before 1.02 were released under the name
Set::ArrayAlt. Version 1.02 was released simultaneously under the
names Set::ArrayAlt and Array::AsObject. Versions after 1.02 will
only be released under the name Array::AsObject.
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
None at this point.
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
