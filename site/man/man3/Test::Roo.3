.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Roo 3"
.TH Test::Roo 3 "2014-08-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Roo \- Composable, reusable tests with roles and Moo
.SH "VERSION"
.IX Header "VERSION"
version 1.004
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Define test behaviors and required fixtures in a role:
.PP
.Vb 1
\&    # t/lib/ObjectCreation.pm
\&
\&    package ObjectCreation;
\&    use Test::Roo::Role;    # loads Moo::Role and Test::More
\&
\&    requires \*(Aqclass\*(Aq;       # we need this fixture
\&
\&    test \*(Aqobject creation\*(Aq => sub {
\&        my $self = shift;
\&        require_ok( $self\->class );
\&        my $obj  = new_ok( $self\->class );
\&    };
\&
\&    1;
.Ve
.PP
Provide fixtures and run tests from the .t file:
.PP
.Vb 1
\&    # t/test.t
\&
\&    use Test::Roo; # loads Moo and Test::More
\&    use lib \*(Aqt/lib\*(Aq;
\&
\&    # provide the fixture
\&    has class => (
\&        is      => \*(Aqro\*(Aq,
\&        default => sub { "Digest::MD5" },
\&    );
\&
\&    # specify behaviors to test
\&    with \*(AqObjectCreation\*(Aq;
\&
\&    # give our subtests a pretty label
\&    sub _build_description { "Testing " . shift\->class }
\&
\&    # run the test with default fixture
\&    run_me;
\&
\&    # run the test with different fixture
\&    run_me( { class => "Digest::SHA1" } );
\&
\&    done_testing;
.Ve
.PP
Result:
.PP
.Vb 10
\&    $ prove \-lv t
\&    t/test.t ..
\&            ok 1 \- require Digest::MD5;
\&            ok 2 \- The object isa Digest::MD5
\&            1..2
\&        ok 1 \- object creation
\&        1..1
\&    ok 1 \- Testing Digest::MD5
\&            ok 1 \- require Digest::SHA1;
\&            ok 2 \- The object isa Digest::SHA1
\&            1..2
\&        ok 1 \- object creation
\&        1..1
\&    ok 2 \- Testing Digest::SHA1
\&    1..2
\&    ok
\&    All tests successful.
\&    Files=1, Tests=2,  0 wallclock secs ( 0.02 usr  0.01 sys +  0.06 cusr  0.00 csys =  0.09 CPU)
\&    Result: PASS
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to compose Test::More tests from roles.  It is
inspired by the excellent Test::Routine module, but uses Moo instead of
Moose.  This gives most of the benefits without the need for Moose as a
test dependency.
.PP
Test files are Moo classes.  You can define any needed test fixtures as Moo
attributes.  You define tests as method modifiers \*(-- similar in concept to
\&\f(CW\*(C`subtest\*(C'\fR in Test::More, but your test method will be passed the test
object for access to fixture attributes.  You may compose any Moo::Role into
your test to define attributes, require particular methods, or define tests.
.PP
This means that you can isolate test \fIbehaviors\fR into roles which require
certain test \fIfixtures\fR in order to run.  Your main test file will provide the
fixtures and compose the roles to run.  This makes it easy to reuse test
behaviors.
.PP
For example, if you are creating tests for Awesome::Module, you could create
the test behaviors as Awesome::Module::Test::Role and distribute it with
your module.  If another distribution subclasses Awesome::Module, it can
compose the Awesome::Module::Test::Role behavior for its own tests.
.PP
No more copying and pasting tests from a super class!  Superclasses define and
share their tests.  Subclasses provide their own fixtures and run the tests.
.SH "USAGE"
.IX Header "USAGE"
Importing Test::Roo also loads Moo (which gives you strictures with
fatal warnings and other goodies) and makes the current package a subclass
of Test::Roo::Class.
.PP
Importing also loads Test::More.  No test plan is used.  The \f(CW\*(C`done_testing\*(C'\fR
function must be used at the end of every test file.  Any import arguments are
passed through to Test::More's \f(CW\*(C`import\*(C'\fR method.
.PP
See also Test::Roo::Role for test role usage.
.SS "Creating fixtures"
.IX Subsection "Creating fixtures"
You can create fixtures with normal Moo syntax.  You can even make them lazy if
you want:
.PP
.Vb 3
\&    has fixture => (
\&        is => \*(Aqlazy\*(Aq
\&    );
\&
\&    sub _build_fixture { ... }
.Ve
.PP
This becomes really useful with Test::Roo::Role.  A role could define the
attribute and require the builder method to be provided by the main test class.
.SS "Composing test roles"
.IX Subsection "Composing test roles"
You can use roles to define units of test behavior and then compose them into
your test class using the \f(CW\*(C`with\*(C'\fR function.  Test roles may define attributes,
declare tests, require certain methods and anything else you can regularly do
with roles.
.PP
.Vb 1
\&    use Test::Roo;
\&
\&    with \*(AqMyTestRole1\*(Aq, \*(AqMyTestRole2\*(Aq;
.Ve
.PP
See Test::Roo::Role and the Test::Roo::Cookbook for details and
examples.
.SS "Setup and teardown"
.IX Subsection "Setup and teardown"
You can add method modifiers around the \f(CW\*(C`setup\*(C'\fR and \f(CW\*(C`teardown\*(C'\fR methods and
these will be run before tests begin and after tests finish (respectively).
.PP
.Vb 1
\&    before  setup     => sub { ... };
\&
\&    after   teardown  => sub { ... };
.Ve
.PP
You can also add method modifiers around \f(CW\*(C`each_test\*(C'\fR, which will be
run before and after \fBevery\fR individual test.  You could use these to
prepare or reset a fixture.
.PP
.Vb 1
\&    has fixture => ( is => \*(Aqlazy, clearer => 1, predicate => 1 );
\&
\&    after  each_test => sub { shift\->clear_fixture };
.Ve
.PP
Roles may also modify \f(CW\*(C`setup\*(C'\fR, \f(CW\*(C`teardown\*(C'\fR, and \f(CW\*(C`each_test\*(C'\fR, so the order
that modifiers will be called will depend on when roles are composed.  Be
careful with \f(CW\*(C`each_test\*(C'\fR, though, because the global effect may make
composition more fragile.
.PP
You can call test functions in modifiers. For example, you could
confirm that something has been set up or cleaned up.
.PP
.Vb 1
\&    before each_test => sub { ok( ! shift\->has_fixture ) };
.Ve
.SS "Running tests"
.IX Subsection "Running tests"
The simplest way to use Test::Roo with a single \fI.t\fR file is to let the
\&\f(CW\*(C`main\*(C'\fR package be the test class and call \f(CW\*(C`run_me\*(C'\fR in it:
.PP
.Vb 2
\&    # t/test.t
\&    use Test::Roo; # loads Moo and Test::More
\&
\&    has class => (
\&        is      => \*(Aqro\*(Aq,
\&        default => sub { "Digest::MD5" },
\&    );
\&
\&    test \*(Aqload class\*(Aq => sub {
\&        my $self = shift;
\&        require_ok( $self\->class );
\&    }
\&
\&    run_me;
\&    done_testing;
.Ve
.PP
Calling \f(CW\*(C`run_me(@args)\*(C'\fR is equivalent to calling
\&\f(CW\*(C`_\|_PACKAGE_\|_\->run_tests(@args)\*(C'\fR and runs tests for the current package.
.PP
You may specify an optional description or hash reference of constructor
arguments to customize the test object:
.PP
.Vb 3
\&    run_me( "load MD5" );
\&    run_me( { class => "Digest::MD5" } );
\&    run_me( "load MD5", { class => "Digest::MD5" } );
.Ve
.PP
See Test::Roo::Class for more about the \f(CW\*(C`run_tests\*(C'\fR method.
.PP
Alternatively, you can create a separate package (in the test file or in a
separate \fI.pm\fR file) and run tests explicitly on that class.
.PP
.Vb 3
\&    # t/test.t
\&    package MyTest;
\&    use Test::Roo;
\&
\&    use lib \*(Aqt/lib\*(Aq;
\&
\&    has class => (
\&        is       => \*(Aqro\*(Aq,
\&        required => 1,
\&    );
\&
\&    with \*(AqMyTestRole\*(Aq;
\&
\&    package main;
\&    use strictures;
\&    use Test::More;
\&
\&    for my $c ( qw/Digest::MD5 Digest::SHA/ ) {
\&        MyTest\->run_tests("Testing $c", { class => $c } );
\&    }
\&
\&    done_testing;
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Loading Test::Roo exports subroutines into the calling package to declare
and run tests.
.SS "test"
.IX Subsection "test"
.Vb 1
\&    test $label => sub { ... };
.Ve
.PP
The \f(CW\*(C`test\*(C'\fR function adds a subtest.  The code reference will be called with
the test object as its only argument.
.PP
Tests are run in the order declared, so the order of tests from roles will
depend on when they are composed relative to other test declarations.
.SS "top_test"
.IX Subsection "top_test"
.Vb 1
\&    top_test $label => sub { ... };
.Ve
.PP
The \f(CW\*(C`top_test\*(C'\fR function adds a \*(L"top level\*(R" test.  Works exactly like \*(L"test\*(R"
except it will not start a subtest.  This is especially useful in very simple
testing situations where the extra subtest level is just noise.
.PP
So for example the following test
.PP
.Vb 2
\&    # t/test.t
\&    use Test::Roo;
\&
\&    has class => (
\&        is       => \*(Aqro\*(Aq,
\&        required => 1,
\&    );
\&
\&    top_test basic => sub {
\&        my $self = shift;
\&
\&        require_ok($self\->class);
\&        isa_ok($self\->class\->new, $self\->class);
\&    };
\&
\&    for my $c ( qw/Digest::MD5 Digest::SHA/ ) {
\&        run_me("Testing $c", { class => $c } );
\&    }
\&
\&    done_testing;
.Ve
.PP
produces the following \s-1TAP\s0
.PP
.Vb 10
\&    t/test.t ..
\&        ok 1 \- require Digest::MD5;
\&        ok 2 \- The object isa Digest::MD5
\&        1..2
\&    ok 1 \- Testing Digest::MD5
\&        ok 1 \- require Digest::SHA1;
\&        ok 2 \- The object isa Digest::SHA1
\&        1..2
\&    ok 2 \- Testing Digest::SHA1
\&    1..2
\&    ok
\&    All tests successful.
\&    Files=1, Tests=2,  0 wallclock secs ( 0.02 usr  0.01 sys +  0.06 cusr  0.00 csys =  0.09 CPU)
\&    Result: PASS
.Ve
.SS "run_me"
.IX Subsection "run_me"
.Vb 4
\&    run_me;
\&    run_me( $description );
\&    run_me( $init_args   );
\&    run_me( $description, $init_args );
.Ve
.PP
The \f(CW\*(C`run_me\*(C'\fR function calls the \f(CW\*(C`run_tests\*(C'\fR method on the current package
and passes all arguments to that method.  It takes a description and/or
a hash reference of constructor arguments.
.SH "DIFFERENCES FROM TEST::ROUTINE"
.IX Header "DIFFERENCES FROM TEST::ROUTINE"
While this module was inspired by Test::Routine, it is not a drop-in
replacement.  Here is an overview of major differences:
.IP "\(bu" 4
Test::Roo uses Moo; Test::Routine uses Moose
.IP "\(bu" 4
Loading Test::Roo makes the importing package a class; in Test::Routine it becomes a role
.IP "\(bu" 4
Loading Test::Roo loads Test::More; Test::Routine does not
.IP "\(bu" 4
In Test::Roo, \f(CW\*(C`run_test\*(C'\fR is a method; in Test::Routine it is a function and takes arguments in a different order
.IP "\(bu" 4
In Test::Roo, all role composition must be explicit using \f(CW\*(C`with\*(C'\fR; in Test::Routine, the \f(CW\*(C`run_tests\*(C'\fR command can also compose roles
.IP "\(bu" 4
In Test::Roo, test blocks become method modifiers hooked on an empty method; in Test::Routine, they become methods run via introspection
.IP "\(bu" 4
In Test::Roo, setup and teardown are done by modifying \f(CW\*(C`setup\*(C'\fR and \f(CW\*(C`teardown\*(C'\fR methods; in Test::Routine they are done by modifying \f(CW\*(C`run_test\*(C'\fR
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Test\-Roo/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Test\-Roo>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Test\-Roo.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
.IP "\(bu" 4
Diab Jerius <djerius@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
