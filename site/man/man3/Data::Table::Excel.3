.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Excel 3"
.TH Excel 3 "2014-05-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Table::Excel \- Convert between Data::Table objects and Excel (xls/xlsx) files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  News: The package now includes "Perl Data::Table Cookbook" (PDF), which may serve as a better learning material.
\&  To download the free Cookbook, visit https://sites.google.com/site/easydatabase/
\&
\&  use Data::Table::Excel qw (tables2xls xls2tables tables2xlsx xlsx2tables excelFileToTable is_xlsx xls2xlsx xlsx2xls);
\&
\&  # read in two CSV tables and generate an Excel .xls binary file with two spreadsheets
\&  my $t_category = Data::Table::fromFile("Category.csv");
\&  my $t_product = Data::Table::fromFile("Product.csv");
\&  # the workbook will contain two sheets, named Category and Product
\&  # parameters: output file name, an array of tables to write, and their corresponding names
\&  tables2xls("NorthWind.xls", [$t_category, $t_product], ["Category","Product"]);
\&
\&  # read in NorthWind.xls file as two Data::Table objects
\&  my ($tableObjects, $tableNames, $column_headers)=xls2tables("NorthWind.xls");
\&  for (my $i=0; $i<@$tableNames; $i++) {
\&    print "*** ". $tableNames\->[$i], " ***\en";
\&    print $tableObjects\->[$i]\->csv($column_headers[$i]);
\&  }
\&
\&  Outputs:
\&  *** Category ***
\&  CategoryID,CategoryName,Description
\&  1,Beverages,"Soft drinks, coffees, teas, beers, and ales"
\&  2,Condiments,"Sweet and savory sauces, relishes, spreads, and seasonings"
\&  3,Confections,"Desserts, candies, and sweet breads"
\&  ...
\&  
\&  *** Product ***
\&  ProductID,ProductName,CategoryID,UnitPrice,UnitsInStock,Discontinued
\&  1,Chai,1,18,39,FALSE
\&  2,Chang,1,19,17,FALSE
\&  3,Aniseed Syrup,2,10,13,FALSE
\&  ...
\&
\&  # to deal with Excel 2007 format (.xlsx), use xlsx2tables instead.
\&  # since no table name is supplied, they will be named Sheet1 and Sheet2.
\&  # here we also provide custom colors for each sheet, color array is for [OddRow, EvenRow, HeaderRow]
\&
\&  tables2xlsx("NorthWind.xlsx", [$t_category, $t_product], undef, [[\*(Aqsilver\*(Aq,\*(Aqwhite\*(Aq,\*(Aqblack\*(Aq], [45,\*(Aqwhite\*(Aq,37]]);
\&  # read in NorthWind.xlsx file as two Data::Table objects
\&  my ($tableObjects, $tableNames)=xlsx2tables("NorthWind.xlsx");
\&  # note: Spreadsheet::ParseXLSX module is used to parse .xlsx file.
\&
\&  ($tableObjects, $tableNames, $column_headers)=excelFileToTable("NorthWind.xlsx");
\&  # excelFileToTable will automatically detect the Excel format for the input file
\&
\&  # To convert Excel files between the two formats, use
\&  xlsx2xls("NorthWind.xlsx", "NorthWind.xls");
\&  xls2xlsx("NorthWind.xls", "NorthWind.xlsx");
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
This perl package provide utility methods to convert between an Excel file and Data::Table objects. It then enables you to take advantage of the Data::Table methods to further manipulate the data and/or export it into other formats such as \s-1CSV/TSV/HTML,\s0 etc.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.RS 4
To read and write Excel .xls (2003 and prior) format, we use Spreadsheet::WriteExcel and Spreadsheet::ParseExcel; to read and write Excel .xlsx (2007 format),
we use Spreadsheet::ParseXLSX and Excel::Writer::XLSX.  If this module gives incorrect results, please check if the corresponding Perl modules are updated. (We switch to Spreadsheet::ParseXLSX from Spreadsheet::XLSX from version 0.5)
.Sp
xls2tables ($fileName, \f(CW$sheetNames\fR, \f(CW$sheetIndices\fR)
.Sp
xlsx2tables ($fileName, \f(CW$sheetNames\fR, \f(CW$sheetIndices\fR)
.Sp
excelFileToTable ($fileName, \f(CW$sheetNames\fR, \f(CW$sheetIndices\fR, \f(CW$excelFormat\fR)
.Sp
xls2tables is for reading Excel .xls files (binary, 2003 and prior), xlsx2table is for reading .xlsx file (2007, compressed \s-1XML\s0 format).
excelFileToTable can automatically detect Excel format if format is not specified.
.Sp
\&\f(CW$fileName\fR is the input Excel file.
\&\f(CW$sheetNames\fR is a string or a reference to an array of sheet names.
\&\f(CW$sheetIndices\fR is a int or a reference to an array of sheet indices.
\&\f(CW$excelFormat\fR in excelFileToTable has to be either \*(L"2003\*(R" or \*(L"2007\*(R". Auto-detected if not specified.
If neither \f(CW$sheetNames\fR or \f(CW$sheetIndices\fR is provides, all sheets are converted into table objects, one table per sheet.
If \f(CW$sheetNames\fR is provided, only sheets found in the @$sheetNames array is converted.
If \f(CW$sheetIndices\fR is provided, only sheets match the index in the @$sheetIndices array is converted (notice the first spreadsheet has an index of 1).
.Sp
The method returns an array ($tableObjects, \f(CW$tableNames\fR, \f(CW$columnHeaders\fR).
\&\f(CW$tableObjects\fR is a reference to an array of Data::Table objects.
\&\f(CW$tableNames\fR is a reference to an array of sheet names, corresponding to \f(CW$tableObjects\fR.
\&\f(CW$columnHeaders\fR is a reference to an array of booleans, indicating whether each table has original column header
If a table does not have a column header, columns are named Col1, Col2, etc.
.Sp
.Vb 6
\&  # print each of spreadsheet into an HTML table on the web
\&  ($tableObjects, $tableNames, $columnHeaders)=xls2tables("Tables.xls");
\&  foreach my $t (@$tableObjects) {
\&    print "<h1>", shift @$tableNames, "</h1><br>";
\&    print $t\->html;
\&  }
\&
\&  ($tableObjects, $tableNames, $columnHeaders)=xlsx2tables("Tables.xlsx", undef, [1]);
.Ve
.Sp
This will only read the first sheet. By providing sheet names or sheet indicies, you save time if you are not interested in all the sheets.
.Sp
tables2xls ($fileName, \f(CW$tables\fR, \f(CW$names\fR, \f(CW$colors\fR, \f(CW$portrait\fR, \f(CW$columnHeaders\fR)
.Sp
tables2xlsx ($fileName, \f(CW$tables\fR, \f(CW$names\fR, \f(CW$colors\fR, \f(CW$portrait\fR, \f(CW$columnHeaders\fR)
.Sp
tables2excel ($fileName, \f(CW$tables\fR, \f(CW$names\fR, \f(CW$colors\fR, \f(CW$portrait\fR, \f(CW$excelFormat\fR, \f(CW$columnHeaders\fR)
.Sp
table2xls is for writing Excel .xls files (binary, 2003 and prior), xlsx2table is for writing .xlsx file (2007, compressed \s-1XML\s0 format).
tables2excel will export to 2007 format, if \f(CW$excelFormat\fR is not specified.
.Sp
\&\f(CW$fileName\fR is used to name the output Excel file.
\&\f(CW$tables\fR is a reference to an array of Data::Table objects to be write into the file, one sheet per table.
\&\f(CW$names\fR is a reference to an array of names used to name Spreadsheets, if not provided, it uses \*(L"Sheet1\*(R", \*(L"Sheet2\*(R", etc.
\&\f(CW$colors\fR is a reference to an array of reference to a color array.
Each color array has to contains three elements, defining Excel color index for odd rows, even rows and header row. 
Acceptable color index (or name) is defined by the docs\epalette.html file in the \s-1CPAN\s0 Spreadsheet::WriteExcel package.
.Sp
\&\f(CW$portrait\fR is a reference to an array of orientation flag (0 or 1), 1 is for Portrait (the default), where each row represents a table row.  In landscape (0) mode, each row represents a column.  (Similar to Data::Table::html and Data::Table::html2).
.Sp
\&\f(CW$columnHeaders\fR is a reference to an array of boolean, indicating whether to export column headers for each table. By default, column headers are exported.
.Sp
The arrays pointed by \f(CW$names\fR, \f(CW$colors\fR, \f(CW$portraits\fR and \f(CW$columnHeader\fR should be the same length as that of \f(CW$tables\fR. these customization values are applied to each table objects sequentially.
If a value is missing for a table, the method will use the setting from the previous table.
.Sp
.Vb 1
\&  tables2xls("TwoTables.xls", [$t_A, $t_B], ["Table_A","Table_B"], [["white","silver","gray"], undef], [1, 0], [1, 1]);
.Ve
.Sp
This will produce two spreadsheets named Table_A and Table_B for table \f(CW$t_A\fR and \f(CW$t_B\fR, respectively.  The first table is colored in a black-white style, the second is colored by the default style.
The first table is the default portrait oritentation, the second is in the transposed orientation.
.Sp
is_xlsx($fileName)
.Sp
Returns boolean whether the given file is 2007 format. It does not rely on file name, but reads the first two bytes of the file. .xlsx is in Zip format, therefore the first two bytes are \*(L"\s-1PK\*(R".\s0
.Sp
xlsx2xls($fromFileName, \f(CW$toFileName\fR)
.Sp
xls2xlsx($fromFileName, \f(CW$toFileName\fR)
.Sp
Converts an Excel file from one format to another. If \f(CW$toFileName\fR is not specified, \f(CW$toFileName\fR will be the same as \f(CW$fromFileName\fR, except with extension sets to .xlsx or .xls.
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2008, Yingyao Zhou. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Please send bug reports and comments to: easydatabase at gmail dot com. When sending
bug reports, please provide the version of Data::Table::Excel.pm, the version of
Perl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\&  Data::Table.
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 297:" 4
.IX Item "Around line 297:"
You can't have =items (as at line 302) unless the first thing after the =over is an =item
