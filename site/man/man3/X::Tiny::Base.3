.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "X::Tiny::Base 3"
.TH X::Tiny::Base 3 "2019-12-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X::Tiny::Base \- super\-light exception base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package My::Module::X::Base;
\&
\&    use parent qw( X::Tiny::Base );
\&
\&    sub _new {
\&        my ($class, @args) = @_;
\&
\&        ...
\&    }
\&
\&    #Optionally, redefine this:
\&    sub get {
\&        my ($self, $attr_name) = @_;
\&
\&        ...
\&    }
\&
\&    #Optionally, redefine this:
\&    sub get_message { ... }
\&
\&    #Optionally, redefine this:
\&    sub to_string { ... }
\&
\&    #If you override this, be sure also to call the base method.
\&    sub DESTROY {
\&        my ($self) = @_;
\&
\&        ...
\&
\&        #vv This. Be sure to do this in your override method.
\&        $self\->SUPER::DESTROY();
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This base class can be subclassed into your distribution’s own
exception base class (e.g., \f(CW\*(C`My::Module::X::Base\*(C'\fR), or you can treat it
as that base class itself (i.e., forgo \f(CW\*(C`My::Module::X::Base\*(C'\fR).
.PP
\&\f(CW\*(C`X::Tiny::Base\*(C'\fR serves two functions:
.IP "1) It is a useful set of defaults for overridable methods." 4
.IX Item "1) It is a useful set of defaults for overridable methods."
.PD 0
.IP "2) Framework handling of overload stringification behavior, e.g., when an uncaught exception is printed." 4
.IX Item "2) Framework handling of overload stringification behavior, e.g., when an uncaught exception is printed."
.PD
.PP
That stringification’s precise formatting is not defined; however, it
will always include, in addition to the exception’s main message:
.IP "\(bu" 4
A stack trace (including function arguments)
.Sp
\&\fB\s-1IMPORTANT:\s0\fR For security purposes, take care not to expose any function
arguments that might contain sensitive information (e.g., passwords).
.Sp
Note that, in pre\-5.16 Perls, this writes to the \f(CW@DB::args\fR global.
(That shouldn’t affect you, but it’s interaction with the environment, so
better documented than not.)
.IP "\(bu" 4
Propagations
.PP
There is currently no access provided in code to these; if that’s something
you’d like to have, let me know.
.PP
\&\fB\s-1NOTE:\s0\fR The overload stringification doesn’t seem to work as implemented in
Perl 5.8 or earlier. Perl 5.8 went end-of-life on 14 December 2008. Yeah.
.SH "SUBCLASS INTERFACE"
.IX Header "SUBCLASS INTERFACE"
The default behaviors seem pretty usable and desirable to me, but there may
be circumstances where someone wants other behaviors. Toward that end,
the following methods are meant to be overridden in subclasses:
.SS "\fI\s-1CLASS\s0\fP\->\s-1\fBOVERLOAD\s0()\fP"
.IX Subsection "CLASS->OVERLOAD()"
Returns a boolean to indicate whether this exception class should load
overload as part of creating exceptions. If you don’t want the
memory overhead of overload, then make this return 0. It returns 1
by default.
.PP
You might also make this 0 if, for example, you want to handle the
overload behavior yourself. (But at that point, why use X::Tiny??)
.SS "\fI\s-1CLASS\s0\fP\->_new( \s-1MESSAGE, KEY1\s0 => \s-1VALUE1, ..\s0 )"
.IX Subsection "CLASS->_new( MESSAGE, KEY1 => VALUE1, .. )"
The main constructor. Whatever args this accepts are the args that
you should use to create exceptions via your X::Tiny subclass’s
\&\f(CW\*(C`create()\*(C'\fR method. You’re free to design whatever internal representation
you want for your class: hash reference, array reference, etc.
.PP
The default implementation accepts a string message and, optionally, a
list of key/value pairs. It is useful that subclasses of your base class
define their own \s-1MESSAGE,\s0 so all you’ll pass in is a specific piece of
information about this instance—e.g., an error code, a parameter name, etc.
.SS "\fI\s-1OBJ\s0\fP\->\fBget_message()\fP"
.IX Subsection "OBJ->get_message()"
Return the exception’s main \s-1MESSAGE.\s0
This is useful for contexts where you want to encapsulate the error
internals from how you’re reporting them, e.g., for protocols.
.SS "\fI\s-1OBJ\s0\fP\->get( \s-1ATTRIBUTE_NAME\s0 )"
.IX Subsection "OBJ->get( ATTRIBUTE_NAME )"
Retrieves the value of an attribute.
.SS "\fI\s-1OBJ\s0\fP\->\fBto_string()\fP"
.IX Subsection "OBJ->to_string()"
Creates a simple string representation of your exception. The default
implementation contains the class and the \s-1MESSAGE\s0 given on instantiation.
.PP
This method’s return value should \fB\s-1NOT\s0\fR include a strack trace;
X::Tiny::Base’s internals handle that one for you.
.SH "DESTRUCTOR METHODS"
.IX Header "DESTRUCTOR METHODS"
If you define your own \f(CW\*(C`DESTROY()\*(C'\fR method, make sure you also call
\&\f(CW\*(C`SUPER::DESTROY()\*(C'\fR, or else you’ll get memory leaks as X::Tiny::Base’s
internal tracking of object properties will never be cleared out.
