.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object 3"
.TH Data::Object 3 "2020-04-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Object-Orientation for Perl 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package main;
\&
\&  use Data::Object;
\&
\&  my $array = Box Array [1..4];
\&
\&  # my $iterator = $array\->iterator;
\&
\&  # $iterator\->next; # 1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package automatically exports and provides constructor functions for
creating chainable data type objects from raw Perl data types.
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Data::Object::Types
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This package implements the following functions:
.SS "args"
.IX Subsection "args"
.Vb 1
\&  Args(HashRef $data) : InstanceOf["Data::Object::Args"]
.Ve
.PP
The Args function returns a Data::Object::Args object.
.IP "Args example #1" 4
.IX Item "Args example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqArgs\*(Aq;
\&
\&  my $args = Args; # [...]
.Ve
.IP "Args example #2" 4
.IX Item "Args example #2"
.Vb 1
\&  package main;
\&
\&  my $args = Args {
\&    subcommand => 0
\&  };
\&
\&  # $args\->subcommand;
.Ve
.SS "array"
.IX Subsection "array"
.Vb 1
\&  Array(ArrayRef $data) : InstanceOf["Data::Object::Array"]
.Ve
.PP
The Array function returns a Data::Object::Box which wraps a
Data::Object::Array object.
.IP "Array example #1" 4
.IX Item "Array example #1"
.Vb 1
\&  package main;
\&
\&  my $array = Array; # []
.Ve
.IP "Array example #2" 4
.IX Item "Array example #2"
.Vb 1
\&  package main;
\&
\&  my $array = Array [1..4];
.Ve
.SS "boolean"
.IX Subsection "boolean"
.Vb 1
\&  Boolean(Bool $data) : BooleanObject
.Ve
.PP
The Boolean function returns a Data::Object::Boolean object representing a
true or false value.
.IP "Boolean example #1" 4
.IX Item "Boolean example #1"
.Vb 1
\&  package main;
\&
\&  my $boolean = Boolean;
.Ve
.IP "Boolean example #2" 4
.IX Item "Boolean example #2"
.Vb 1
\&  package main;
\&
\&  my $boolean = Boolean 0;
.Ve
.SS "box"
.IX Subsection "box"
.Vb 1
\&  Box(Any $data) : InstanceOf["Data::Object::Box"]
.Ve
.PP
The Box function returns a Data::Object::Box object representing a data type
object which is automatically deduced.
.IP "Box example #1" 4
.IX Item "Box example #1"
.Vb 1
\&  package main;
\&
\&  my $box = Box;
.Ve
.IP "Box example #2" 4
.IX Item "Box example #2"
.Vb 1
\&  package main;
\&
\&  my $box = Box 123;
.Ve
.IP "Box example #3" 4
.IX Item "Box example #3"
.Vb 1
\&  package main;
\&
\&  my $box = Box [1..4];
.Ve
.IP "Box example #4" 4
.IX Item "Box example #4"
.Vb 1
\&  package main;
\&
\&  my $box = Box {1..4};
.Ve
.SS "code"
.IX Subsection "code"
.Vb 1
\&  Code(CodeRef $data) : InstanceOf["Data::Object::Code"]
.Ve
.PP
The Code function returns a Data::Object::Box which wraps a
Data::Object::Code object.
.IP "Code example #1" 4
.IX Item "Code example #1"
.Vb 1
\&  package main;
\&
\&  my $code = Code;
.Ve
.IP "Code example #2" 4
.IX Item "Code example #2"
.Vb 1
\&  package main;
\&
\&  my $code = Code sub { shift };
.Ve
.SS "data"
.IX Subsection "data"
.Vb 1
\&  Data(Str $file) : InstanceOf["Data::Object::Data"]
.Ve
.PP
The Data function returns a Data::Object::Data object.
.IP "Data example #1" 4
.IX Item "Data example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqData\*(Aq;
\&
\&  my $data = Data;
.Ve
.IP "Data example #2" 4
.IX Item "Data example #2"
.Vb 1
\&  package main;
\&
\&  my $data = Data \*(Aqt/Data_Object.t\*(Aq;
\&
\&  # $data\->contents(...);
.Ve
.SS "error"
.IX Subsection "error"
.Vb 1
\&  Error(Str | HashRef) : InstanceOf["Data::Object::Exception"]
.Ve
.PP
The Error function returns a Data::Object::Exception object.
.IP "Error example #1" 4
.IX Item "Error example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqError\*(Aq;
\&
\&  my $error = Error;
\&
\&  # die $error;
.Ve
.IP "Error example #2" 4
.IX Item "Error example #2"
.Vb 1
\&  package main;
\&
\&  my $error = Error \*(AqOops!\*(Aq;
\&
\&  # die $error;
.Ve
.IP "Error example #3" 4
.IX Item "Error example #3"
.Vb 1
\&  package main;
\&
\&  my $error = Error {
\&    message => \*(AqOops!\*(Aq,
\&    context => { time => time }
\&  };
\&
\&  # die $error;
.Ve
.SS "false"
.IX Subsection "false"
.Vb 1
\&  False() : BooleanObject
.Ve
.PP
The False function returns a Data::Object::Boolean object representing a
false value.
.IP "False example #1" 4
.IX Item "False example #1"
.Vb 1
\&  package main;
\&
\&  my $false = False;
.Ve
.SS "float"
.IX Subsection "float"
.Vb 1
\&  Float(Num $data) : InstanceOf["Data::Object::Float"]
.Ve
.PP
The Float function returns a Data::Object::Box which wraps a
Data::Object::Float object.
.IP "Float example #1" 4
.IX Item "Float example #1"
.Vb 1
\&  package main;
\&
\&  my $float = Float;
.Ve
.IP "Float example #2" 4
.IX Item "Float example #2"
.Vb 1
\&  package main;
\&
\&  my $float = Float \*(Aq0.0\*(Aq;
.Ve
.SS "hash"
.IX Subsection "hash"
.Vb 1
\&  Hash(HashRef $data) : InstanceOf["Data::Object::Hash"]
.Ve
.PP
The Hash function returns a Data::Object::Box which wraps a
Data::Object::Hash object.
.IP "Hash example #1" 4
.IX Item "Hash example #1"
.Vb 1
\&  package main;
\&
\&  my $hash = Hash;
.Ve
.IP "Hash example #2" 4
.IX Item "Hash example #2"
.Vb 1
\&  package main;
\&
\&  my $hash = Hash {1..4};
.Ve
.SS "name"
.IX Subsection "name"
.Vb 1
\&  Name(Str $data) : InstanceOf["Data::Object::Name"]
.Ve
.PP
The Name function returns a Name::Object::Name object.
.IP "Name example #1" 4
.IX Item "Name example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqName\*(Aq;
\&
\&  my $name = Name \*(AqExample Title\*(Aq;
\&
\&  # $name\->package;
.Ve
.SS "number"
.IX Subsection "number"
.Vb 1
\&  Number(Num $data) : InstanceOf["Data::Object::Number"]
.Ve
.PP
The Number function returns a Data::Object::Box which wraps a
Data::Object::Number object.
.IP "Number example #1" 4
.IX Item "Number example #1"
.Vb 1
\&  package main;
\&
\&  my $number = Number;
.Ve
.IP "Number example #2" 4
.IX Item "Number example #2"
.Vb 1
\&  package main;
\&
\&  my $number = Number 123;
.Ve
.SS "opts"
.IX Subsection "opts"
.Vb 1
\&  Opts(HashRef $data) : InstanceOf["Data::Object::Opts"]
.Ve
.PP
The Opts function returns a Data::Object::Opts object.
.IP "Opts example #1" 4
.IX Item "Opts example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqOpts\*(Aq;
\&
\&  my $opts = Opts;
.Ve
.IP "Opts example #2" 4
.IX Item "Opts example #2"
.Vb 1
\&  package main;
\&
\&  my $opts = Opts {
\&    spec => [\*(Aqfiles|f=s\*(Aq]
\&  };
\&
\&  # $opts\->files; [...]
.Ve
.SS "regexp"
.IX Subsection "regexp"
.Vb 1
\&  Regexp(RegexpRef $data) : InstanceOf["Data::Object::Regexp"]
.Ve
.PP
The Regexp function returns a Data::Object::Box which wraps a
Data::Object::Regexp object.
.IP "Regexp example #1" 4
.IX Item "Regexp example #1"
.Vb 1
\&  package main;
\&
\&  my $regexp = Regexp;
.Ve
.IP "Regexp example #2" 4
.IX Item "Regexp example #2"
.Vb 1
\&  package main;
\&
\&  my $regexp = Regexp qr/.*/;
.Ve
.SS "scalar"
.IX Subsection "scalar"
.Vb 1
\&  Scalar(Ref $data) : InstanceOf["Data::Object::Scalar"]
.Ve
.PP
The Scalar function returns a Data::Object::Box which wraps a
Data::Object::Scalar object.
.IP "Scalar example #1" 4
.IX Item "Scalar example #1"
.Vb 1
\&  package main;
\&
\&  my $scalar = Scalar;
.Ve
.IP "Scalar example #2" 4
.IX Item "Scalar example #2"
.Vb 1
\&  package main;
\&
\&  my $scalar = Scalar \e*main;
.Ve
.SS "space"
.IX Subsection "space"
.Vb 1
\&  Space(Str $data) : InstanceOf["Data::Object::Space"]
.Ve
.PP
The Space function returns a Data::Object::Space object.
.IP "Space example #1" 4
.IX Item "Space example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqSpace\*(Aq;
\&
\&  my $space = Space \*(AqExample Namespace\*(Aq;
.Ve
.SS "string"
.IX Subsection "string"
.Vb 1
\&  String(Str $data) : InstanceOf["Data::Object::String"]
.Ve
.PP
The String function returns a Data::Object::Box which wraps a
Data::Object::String object.
.IP "String example #1" 4
.IX Item "String example #1"
.Vb 1
\&  package main;
\&
\&  my $string = String;
.Ve
.IP "String example #2" 4
.IX Item "String example #2"
.Vb 1
\&  package main;
\&
\&  my $string = String \*(Aqabc\*(Aq;
.Ve
.SS "struct"
.IX Subsection "struct"
.Vb 1
\&  Struct(HashRef $data) : InstanceOf["Data::Object::Struct"]
.Ve
.PP
The Struct function returns a Data::Object::Struct object.
.IP "Struct example #1" 4
.IX Item "Struct example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqStruct\*(Aq;
\&
\&  my $struct = Struct;
.Ve
.IP "Struct example #2" 4
.IX Item "Struct example #2"
.Vb 1
\&  package main;
\&
\&  my $struct = Struct {
\&    name => \*(Aqexample\*(Aq,
\&    time => time
\&  };
.Ve
.SS "true"
.IX Subsection "true"
.Vb 1
\&  True() : BooleanObject
.Ve
.PP
The True function returns a Data::Object::Boolean object representing a true
value.
.IP "True example #1" 4
.IX Item "True example #1"
.Vb 1
\&  package main;
\&
\&  my $true = True;
.Ve
.SS "undef"
.IX Subsection "undef"
.Vb 1
\&  Undef() : InstanceOf["Data::Object::Undef"]
.Ve
.PP
The Undef function returns a Data::Object::Undef object representing the
\&\fIundefined\fR value.
.IP "Undef example #1" 4
.IX Item "Undef example #1"
.Vb 1
\&  package main;
\&
\&  my $undef = Undef;
.Ve
.SS "vars"
.IX Subsection "vars"
.Vb 1
\&  Vars() : InstanceOf["Data::Object::Vars"]
.Ve
.PP
The Vars function returns a Data::Object::Vars object representing the
available environment variables.
.IP "Vars example #1" 4
.IX Item "Vars example #1"
.Vb 1
\&  package main;
\&
\&  use Data::Object \*(AqVars\*(Aq;
\&
\&  my $vars = Vars;
.Ve
.IP "Vars example #2" 4
.IX Item "Vars example #2"
.Vb 1
\&  package main;
\&
\&  my $vars = Vars {
\&    user => \*(AqUSER\*(Aq
\&  };
\&
\&  # $vars\->user; # $USER
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object/issues>
