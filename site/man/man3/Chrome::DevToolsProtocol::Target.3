.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Chrome::DevToolsProtocol::Target 3"
.TH Chrome::DevToolsProtocol::Target 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chrome::DevToolsProtocol::Target \- wrapper for talking to a page in a Target
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    # Usually, WWW::Mechanize::Chrome automatically creates a driver for you
\&    my $driver = Chrome::DevToolsProtocol::Target\->new(
\&        transport => $target,
\&    );
\&    $driver\->connect( new_tab => 1 )\->get
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """\->new( %args )"""
.el .SS "\f(CW\->new( %args )\fP"
.IX Subsection "->new( %args )"
.Vb 8
\&    my $driver = Chrome::DevToolsProtocol::Target\->new(
\&        transport => $target,
\&        auto_close => 0,
\&        error_handler => sub {
\&            # Reraise the error
\&            croak $_[1]
\&        },
\&    );
.Ve
.PP
These members can mostly be set through the constructor arguments:
.IP "\fBjson\fR" 4
.IX Item "json"
The \s-1JSON\s0 decoder used
.IP "\fBtab\fR" 4
.IX Item "tab"
Which tab to reuse (if any)
.IP "\fBautoclose\fR" 4
.IX Item "autoclose"
Close the tab when the object goes out of scope
.IP "\fBlog\fR" 4
.IX Item "log"
A premade Log::Log4perl object to act as logger
.IP "\fBon_message\fR" 4
.IX Item "on_message"
A callback invoked for every message
.IP "\fBtransport\fR" 4
.IX Item "transport"
The event-loop specific transport backend
.ie n .SS """\->future"""
.el .SS "\f(CW\->future\fP"
.IX Subsection "->future"
.Vb 1
\&    my $f = $driver\->future();
.Ve
.PP
Returns a backend-specific generic future
.ie n .SS """\->endpoint"""
.el .SS "\f(CW\->endpoint\fP"
.IX Subsection "->endpoint"
.Vb 1
\&    my $url = $driver\->endpoint();
.Ve
.PP
Returns the \s-1URL\s0 endpoint to talk to for the connected tab
.ie n .SS """\->add_listener"""
.el .SS "\f(CW\->add_listener\fP"
.IX Subsection "->add_listener"
.Vb 6
\&    my $l = $driver\->add_listener(
\&        \*(AqPage.domContentEventFired\*(Aq,
\&        sub {
\&            warn "The DOMContent event was fired";
\&        },
\&    );
\&
\&    # ...
\&
\&    undef $l; # stop listening
.Ve
.PP
Adds a callback for the given event name. The callback will be removed once
the return value goes out of scope.
.ie n .SS """\->remove_listener"""
.el .SS "\f(CW\->remove_listener\fP"
.IX Subsection "->remove_listener"
.Vb 1
\&    $driver\->remove_listener($l);
.Ve
.PP
Explicitly remove a listener.
.ie n .SS """\->log"""
.el .SS "\f(CW\->log\fP"
.IX Subsection "->log"
.Vb 1
\&    $driver\->log(\*(Aqdebug\*(Aq, "Warbling doodads", { doodad => \*(Aqthis\*(Aq } );
.Ve
.PP
Log a message
.ie n .SS """\->connect"""
.el .SS "\f(CW\->connect\fP"
.IX Subsection "->connect"
.Vb 1
\&    my $f = $driver\->connect()\->get;
.Ve
.PP
Asynchronously connect to the Chrome browser, returning a Future.
.ie n .SS """\->close"""
.el .SS "\f(CW\->close\fP"
.IX Subsection "->close"
.Vb 1
\&    $driver\->close();
.Ve
.PP
Shut down the connection to our tab and close it.
.ie n .SS """\->sleep"""
.el .SS "\f(CW\->sleep\fP"
.IX Subsection "->sleep"
.Vb 1
\&    $driver\->sleep(0.2)\->get;
.Ve
.PP
Sleep for the amount of seconds in an event-loop compatible way
.ie n .SS """\->one_shot"""
.el .SS "\f(CW\->one_shot\fP"
.IX Subsection "->one_shot"
.Vb 1
\&    my $f = $driver\->one_shot(\*(AqPage.domContentEventFired\*(Aq)\->get;
.Ve
.PP
Returns a future that resolves when the event is received
.ie n .SS """$chrome\->json_get"""
.el .SS "\f(CW$chrome\->json_get\fP"
.IX Subsection "$chrome->json_get"
.Vb 1
\&    my $data = $driver\->json_get( \*(Aqversion\*(Aq )\->get;
.Ve
.PP
Requests an \s-1URL\s0 and returns decoded \s-1JSON\s0 from the future
.ie n .SS """$chrome\->version_info"""
.el .SS "\f(CW$chrome\->version_info\fP"
.IX Subsection "$chrome->version_info"
.Vb 1
\&    print $chrome\->version_info\->get\->{"protocolVersion"};
.Ve
.ie n .SS """$chrome\->protocol_version"""
.el .SS "\f(CW$chrome\->protocol_version\fP"
.IX Subsection "$chrome->protocol_version"
.Vb 1
\&    print $chrome\->protocol_version\->get;
.Ve
.ie n .SS """$chrome\->send_packet"""
.el .SS "\f(CW$chrome\->send_packet\fP"
.IX Subsection "$chrome->send_packet"
.Vb 3
\&  $chrome\->send_packet(\*(AqPage.handleJavaScriptDialog\*(Aq,
\&      accept => JSON::true,
\&  );
.Ve
.PP
Sends a \s-1JSON\s0 packet to the remote end
.ie n .SS """$chrome\->send_message"""
.el .SS "\f(CW$chrome\->send_message\fP"
.IX Subsection "$chrome->send_message"
.Vb 5
\&  my $future = $chrome\->send_message(\*(AqDOM.querySelectorAll\*(Aq,
\&      selector => \*(Aqp\*(Aq,
\&      nodeId => $node,
\&  );
\&  my $nodes = $future\->get;
.Ve
.PP
This function expects a response. The future will not be resolved until Chrome
has sent a response to this query.
.ie n .SS """$chrome\->callFunctionOn"""
.el .SS "\f(CW$chrome\->callFunctionOn\fP"
.IX Subsection "$chrome->callFunctionOn"
.ie n .SS """$chrome\->evaluate"""
.el .SS "\f(CW$chrome\->evaluate\fP"
.IX Subsection "$chrome->evaluate"
.ie n .SS """$chrome\->eval"""
.el .SS "\f(CW$chrome\->eval\fP"
.IX Subsection "$chrome->eval"
.ie n .SS """$chrome\->get_domains"""
.el .SS "\f(CW$chrome\->get_domains\fP"
.IX Subsection "$chrome->get_domains"
.ie n .SS """$chrome\->list_tabs"""
.el .SS "\f(CW$chrome\->list_tabs\fP"
.IX Subsection "$chrome->list_tabs"
.Vb 1
\&  my @tabs = $chrome\->list_tabs\->get();
.Ve
.ie n .SS """$chrome\->new_tab"""
.el .SS "\f(CW$chrome\->new_tab\fP"
.IX Subsection "$chrome->new_tab"
.Vb 1
\&    my $new_tab = $chrome\->new_tab(\*(Aqhttps://www.google.com\*(Aq)\->get;
.Ve
.ie n .SS """$chrome\->activate_tab"""
.el .SS "\f(CW$chrome\->activate_tab\fP"
.IX Subsection "$chrome->activate_tab"
.Vb 1
\&    $chrome\->activate_tab( $tab )\->get
.Ve
.PP
Brings the tab to the foreground of the application
.ie n .SS """$target\->getTargetInfo"""
.el .SS "\f(CW$target\->getTargetInfo\fP"
.IX Subsection "$target->getTargetInfo"
Returns information about the current target
.ie n .SS """$target\->info"""
.el .SS "\f(CW$target\->info\fP"
.IX Subsection "$target->info"
Returns information about the current target
.ie n .SS """$target\->title"""
.el .SS "\f(CW$target\->title\fP"
.IX Subsection "$target->title"
Returns the title of the current target
.ie n .SS """$target\->getVersion"""
.el .SS "\f(CW$target\->getVersion\fP"
.IX Subsection "$target->getVersion"
Returns information about the Chrome instance we are connected to.
.ie n .SS """$target\->createTarget"""
.el .SS "\f(CW$target\->createTarget\fP"
.IX Subsection "$target->createTarget"
.Vb 8
\&    my $info = $chrome\->createTarget(
\&        url => \*(Aqabout:blank\*(Aq,
\&        width => 1280,
\&        height => 800,
\&        newWindow => JSON::false,
\&        background => JSON::false,
\&    )\->get;
\&    print $info\->{targetId};
.Ve
.PP
Creates a new target
.ie n .SS """$target\->attach"""
.el .SS "\f(CW$target\->attach\fP"
.IX Subsection "$target->attach"
.Vb 1
\&    $target\->attach();
.Ve
.PP
Attaches to the target set up in \f(CW\*(C`targetId\*(C'\fR and \f(CW\*(C`sessionId\*(C'\fR. If a targetId is
given, attaches to it and remembers the value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The inofficial Chrome debugger \s-1API\s0 documentation at
<https://github.com/buggerjs/bugger\-daemon/blob/master/README.md#api>
.PP
Chrome DevTools at <https://chromedevtools.github.io/devtools\-protocol/1\-2>
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/www\-mechanize\-chrome>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is <https://perlmonks.org/>.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-Chrome>
or via mail to www\-mechanize\-Chrome\-Bugs@rt.cpan.org <mailto:www-mechanize-Chrome-Bugs@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2010\-2020 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
