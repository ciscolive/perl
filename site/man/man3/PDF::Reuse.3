.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PDF::Reuse 3"
.TH PDF::Reuse 3 "2016-09-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDF::Reuse \- Reuse and mass produce PDF documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   use PDF::Reuse;
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   prText(100, 500, \*(AqHello World !\*(Aq);
\&   prEnd();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module could be used when you want to mass produce similar (but not identical)
\&\s-1PDF\s0 documents and reuse templates, JavaScripts and some other components. It is
functional to be fast, and to give your programs capacity to produce many pages
per second and very big \s-1PDF\s0 documents if necessary.
.PP
The module produces \s-1PDF\-1.4\s0 files. Some features of \s-1PDF\-1.5,\s0 like \*(L"object streams\*(R"
and \*(L"cross reference streams\*(R", are supported, but only at an experimental level. More
testing is needed. (If you get problems with a new document from Acrobat 6 or higher, try to
save it or recreate it as a \s-1PDF\-1.4\s0 document first, before using it together with
this module.)
.IP "Templates" 2
.IX Item "Templates"
Use your favorite program, probably a commercial visual tool, to produce single
PDF-files to be used as templates, and then use this module to \fBmass produce\fR files
from them.
.Sp
(If you want small PDF-files or want special graphics, you can use this module also,
but visual tools are often most practical.)
.IP "Lists" 2
.IX Item "Lists"
The module uses \*(L"XObjects\*(R" extensively. This is a format that makes it possible
create big lists, which are compact at the same time.
.IP "PDF-operators" 2
.IX Item "PDF-operators"
The module gives you a good possibility to program at a \*(L"low level\*(R" with the basic
graphic operators of \s-1PDF,\s0 if that is what you want to do. You can build your
own libraries of low level routines, with PDF-directives \*(L"controlled\*(R" by Perl.
.IP "Archive-format" 2
.IX Item "Archive-format"
If you want, you get your new documents logged in a format suitable for archiving
or transfer.
.Sp
PDF::Reuse::Tutorial might show you best what you can do with this module.
.IP "JavaScript" 2
.IX Item "JavaScript"
You can attach JavaScripts to your PDF-files.
.Sp
You can have libraries of JavaScripts. No cutting or pasting, and those who include
the scripts in documents only need to know how to initiate them. (Of course those
who write the scripts have to know Acrobat JavaScript well.)
.SS "Remarks about JavaScript"
.IX Subsection "Remarks about JavaScript"
Some of the functions handling JavaScript have to be rewritten for Acrobat 7.
.PP
There are many limitations with Acrobat JavaScript, and the rules often change.
So what works for one version of Acrobat/Reader, might not work for another.
Another complication is this:
When documents are downloaded via the net by Acrobat, they are most often
converted (!) and necessary JavaScripts are lost.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
All functions which are successful return specified values or 1.
.PP
The module doesn't make any attempt to import anything from encrypted files.
.SH "Overview"
.IX Header "Overview"
To write a program with PDF::Reuse, you need these components:
.SH "Mandatory Functions"
.IX Header "Mandatory Functions"
.SS "prFile       \- define output"
.IX Subsection "prFile - define output"
Alternative 1:
.PP
.Vb 1
\&   prFile ( $fileName );
.Ve
.PP
Alternative 2 with parameters in an anonymous hash:
.PP
.Vb 6
\&   prFile ( { Name         => $fileName,
\&              HideToolbar  => 1,            # 1 or 0
\&              HideMenubar  => 1,            # 1 or 0
\&              HideWindowUI => 1,            # 1 or 0
\&              FitWindow    => 1,            # 1 or 0
\&              CenterWindow => 1   } );      # 1 or 0
.Ve
.PP
Alternative 3:
.PP
.Vb 1
\&   prFile ( $r );  # For mod_perl 2 pass the request object
.Ve
.PP
\&\f(CW$fileName\fR is optional, just like the rest of the parameters.
File to create. If another file is current when this function is called, the first
one is written and closed. Only one file is processed at a single moment. If
\&\f(CW$fileName\fR is undefined, output is written to \s-1STDOUT.\s0
.PP
HideToolbar, HideMenubar, HideWindowUI, FitWindow and CenterWindow control the
way the document is initially displayed.
.PP
Look at any program in this documentation for examples. \fBprInitVars()\fR shows how
this function could be used together with a web server.
.SS "prEnd        \- end/flush buffers"
.IX Subsection "prEnd - end/flush buffers"
.Vb 1
\&   prEnd ()
.Ve
.PP
When the processing is going to end, the buffers of the \fBlast\fR file has to be written to the disc.
If this function is not called, the page structure, xref part and so on will be
lost.
.PP
Look at any program in this documentation for an example.
.SH "Optional Functions"
.IX Header "Optional Functions"
.ie n .SS "prAdd        \- add ""low level"" instructions"
.el .SS "prAdd        \- add ``low level'' instructions"
.IX Subsection "prAdd - add low level instructions"
.Vb 1
\&    prAdd ( $string )
.Ve
.PP
With this command you can add whatever you want to the current content stream.
No syntactical checks are made, but if you use an internal name, the module tries
to add the resource of the \*(L"name object\*(R" to the \*(L"Resources\*(R" of current page.
\&\*(L"Name objects\*(R" always begin with a '/'.
.PP
(In this documentation I often use talk about an \*(L"internal name\*(R". It denotes a
\&\*(L"name object\*(R". When PDF::Reuse creates these objects, it assigns Ft1, Ft2, Ft3 ...
for fonts, Ig1, Ig2, Ig3 for images, Fo1 .. for forms, Cs1 .. for Color spaces,
Pt1 .. for patterns, Sh1 .. for shading directories, Gs0 .. for graphic state
parameter dictionaries. These names are kept until the program finishes,
and my ambition is also to keep the resources available in internal tables.)
.PP
This is a simple and very powerful function. You should study the examples and
the \*(L"PDF-reference manual\*(R", if you want to use it.(When this text is written,
a possible link to download it is:
http://partners.adobe.com/asn/developer/acrosdk/docs.html)
.PP
This function is intended to give you detail control at a low level.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   my $string = "150 600 100 50 re\en";  # a rectangle
\&   $string   .= "0 0 1 rg\en";           # blue (to fill)
\&   $string   .= "b\en";                  # fill and stroke
\&   prAdd($string);
\&   prEnd();
.Ve
.SS "prBookmark       \- define bookmarks"
.IX Subsection "prBookmark - define bookmarks"
.Vb 1
\&   prBookmark($reference)
.Ve
.PP
Defines a \*(L"bookmark\*(R". \f(CW$reference\fR refers to a hash or array of hashes which looks
something like this:
.PP
.Vb 10
\&          {  text  => \*(AqDocument\*(Aq,
\&             act   => \*(Aqthis.pageNum = 0; this.scroll(40, 500);\*(Aq,
\&             kids  => [ { text => \*(AqChapter 1\*(Aq,
\&                          act  => \*(Aq1, 40, 600\*(Aq
\&                        },
\&                        { text => \*(AqChapter 2\*(Aq,
\&                          act  => \*(Aq10, 40, 600\*(Aq
\&                        }
\&                      ]
\&          }
.Ve
.PP
Each hash can have these components:
.PP
.Vb 9
\&        text    the text shown beside the bookmark
\&        act     the action to be triggered. Has to be a JavaScript action.
\&                (Three simple numbers are translated to page, x and y in the
\&                sentences: this.pageNum = page; this.scroll(x, y); )
\&        kids    will have a reference to another hash or array of hashes
\&        close   if this component is present, the bookmark will be closed
\&                when the document is opened
\&        color   3 numbers, RGB\-colors e.g. \*(Aq0.5 0.5 1\*(Aq for light blue
\&        style   0, 1, 2, or 3. 0 = Normal, 1 = Italic, 2 = Bold, 3 = Bold Italic
.Ve
.PP
Creating bookmarks for a document:
.PP
.Vb 2
\&    use PDF::Reuse;
\&    use strict;
\&
\&    my @pageMarks;
\&
\&    prFile(\*(AqmyDoc.pdf\*(Aq);
\&
\&    for (my $i = 0; $i < 100; $i++)
\&    {   prText(40, 600, \*(AqSomething is written\*(Aq);
\&        # ...
\&        my $page = $i + 1;
\&        my $bookMark = { text => "Page $page",
\&                         act  => "$i, 40, 700" };
\&        push @pageMarks, $bookMark;
\&        prPage();
\&    }
\&    prBookmark( { text  => \*(AqDocument\*(Aq,
\&                  close => 1,
\&                  kids  => \e@pageMarks } );
\&    prEnd();
.Ve
.PP
Traditionally bookmarks have mainly been used for navigation within a document,
but they can be used for many more things. You can e.g. use them to navigate within
your data. You can let your users go to external links also, so they can \*(L"drill down\*(R"
to other documents.
.PP
\&\fBSee \*(L"Remarks about JavaScript\*(R"\fR
.SS "prCompress       \- compress/zip added streams"
.IX Subsection "prCompress - compress/zip added streams"
.Vb 1
\&   prCompress (1)
.Ve
.PP
\&'1' here is a directive to compress all \fBnew\fR streams of the current file. Streams
which are included with prForm, prDocForm, prDoc or prSinglePage are not changed. New
JavaScripts are also created as streams and compressed, if they are at least 100
bytes long. The streams are compressed in memory, so probably there is a limit of
how big they can be.
.PP
\&\fBprCompress()\fR; is a directive not to compress. This is default.
.PP
See e.g. \*(L"Starting to reuse\*(R" in the tutorial for an example.
.SS "prDoc        \- include pages from a document"
.IX Subsection "prDoc - include pages from a document"
.Vb 1
\&   prDoc ( $documentName, $firstPage, $lastPage )
.Ve
.PP
or with the parameters in an anonymous hash:
.PP
.Vb 3
\&   prDoc ( { file  => $documentName,
\&             first => $firstPage,
\&             last  => $lastPage } );
.Ve
.PP
Returns number of extracted pages.
.PP
If \*(L"first\*(R" is not given, 1 is assumed. If \*(L"last\*(R" is not given, you don't have any upper
limit. N.B. The numbering of the pages differs from Acrobat JavaScript. In JavaScript
the first page has index 0.
.PP
Adds pages from a document to the one you are creating.
N.B. From version 0.32 of this module:
If there are contents created with with prText, prImage,prAdd, prForm and so on,
prDoc tries to put the contents on the first extracted page
from the old document.
.PP
If it is the first interactive
component ( \fBprDoc()\fR or \fBprDocForm()\fR ) the interactive functions are kept and also merged
with JavaScripts you have added, if any. But, if you specify a first page different than 1
or a last page, no JavaScript are extracted from the document, because then there is a
risk that an included JavaScript function might refer to something not included.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);                  # file to make
\&   prJs(\*(AqcustomerResponse.js\*(Aq);           # include a JavaScript file
\&   prInit(\*(AqnameAddress(12, 150, 600);\*(Aq);  # init a JavaScript function
\&   prForm(\*(Aqbest.pdf\*(Aq);                    # page 1 from best.pdf
\&   prPage();
\&   prDoc(\*(Aqlong.pdf\*(Aq);                     # a document with 11 pages
\&   prForm(\*(Aqbest.pdf\*(Aq);                    # page 1 from best.pdf
\&   prText(150, 700, \*(AqCustomer Data\*(Aq);     # a line of text
\&   prEnd();
.Ve
.PP
To extract pages 2\-3 and 5\-7 from a document and create a new document:
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(Aqnew.pdf\*(Aq);
\&   prDoc( { file  => \*(Aqold.pdf\*(Aq,
\&            first => 2,
\&            last  => 3 });
\&   prDoc( { file  => \*(Aqold.pdf\*(Aq,
\&            first => 5,
\&            last  => 7 });
\&   prEnd();
.Ve
.PP
To add a form, image and page number to each page of an 16 pages long document
(The document Battery.pdf is cropped so each page is fairly small)  You could also have
used prSinglePage, look at a very similar example under that function.
.PP
.Vb 3
\&   use PDF::Reuse;
\&   use PDF::Reuse::Util;
\&   use strict;
\&
\&   prFile(\*(Aqtest.pdf\*(Aq);
\&
\&     my $pageNumber = 0;
\&
\&     for (my $page = 1; $page < 17; $page++)
\&     {   $pageNumber++;
\&         prForm(  { file =>\*(AqWords.pdf\*(Aq,
\&                    page => 5,
\&                    x    => 150,
\&                    y    => 150} );
\&
\&         prImage( { file =>\*(AqMedia.pdf\*(Aq,
\&                    page => 6,
\&                    imageNo => 1,
\&                    x  => 450,
\&                    y  => 450 } );
\&         blackText();
\&         prText( 360, 250, $pageNumber);
\&         prDoc(\*(AqBattery.pdf\*(Aq, $pageNumber, $pageNumber);
\&     }
\&   prEnd;
.Ve
.SS "prDocDir     \- set directory for produced documents"
.IX Subsection "prDocDir - set directory for produced documents"
.Vb 1
\&   prDocDir ( $directoryName )
.Ve
.PP
Sets directory for produced documents
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prDocDir(\*(AqC:/temp/doc\*(Aq);
\&   prFile(\*(AqmyFile.pdf\*(Aq);         # writes to C:\etemp\edoc\emyFile.pdf
\&   prForm(\*(AqmyFile.pdf\*(Aq);         # page 1 from ..\emyFile.pdf
\&   prText(200, 600, \*(AqNew text\*(Aq);
\&   prEnd();
.Ve
.SS "prDocForm        \- use an interactive page as a form"
.IX Subsection "prDocForm - use an interactive page as a form"
Alternative 1) You put your parameters in an anonymous hash (only \fBfile\fR is really
necessary, the others get default values if not given).
.PP
.Vb 10
\&   prDocForm ( { file     => $pdfFile,       # template file
\&                 page     => $page,          # page number (of imported template)
\&                 adjust   => $adjust,        # try to fill the media box
\&                 effect   => $effect,        # action to be taken
\&                 tolerant => $tolerant,      # continue even with an invalid form
\&                 x        => $x,             # $x points from the left
\&                 y        => $y,             # $y points from the bottom
\&                 rotate   => $degree,        # rotate
\&                 size     => $size,          # multiply everything by $size
\&                 xsize    => $xsize,         # multiply horizontally by $xsize
\&                 ysize    => $ysize } )      # multiply vertically by $ysize
\&Ex.:
\&    my $internalName = prDocForm ( {file     => \*(AqmyFile.pdf\*(Aq,
\&                                    page     => 2 } );
.Ve
.PP
Alternative 2) You put your parameters in this order
.PP
.Vb 2
\&    prDocForm ( $pdfFile, [$page, $adjust, $effect, $tolerant, $x, $y, $degree,
\&            $size, $xsize, $ysize] )
.Ve
.PP
Anyway the function returns in list context:  \fB\f(CB$intName\fB, \f(CB@BoundingBox\fB,
\&\f(CB$numberOfImages\fB\fR, in scalar context:  \fB\f(CB$internalName\fB\fR of the form.
.PP
Look at \fBprForm()\fR for an explanation of the parameters.
.PP
N.B. Usually you shouldn't adjust or change size and proportions of an interactive
page. The graphic and interactive components are independent of each other and there
is a great risk that any coordination is lost.
.PP
This function redefines a page to an \*(L"XObject\*(R" (the graphic parts), then the
page can be reused in a much better way. Unfortunately there is an important
limitation here. \*(L"XObjects\*(R" can only have single streams. If the page consists
of many streams, you should concatenate them first. Adobe Acrobat can do that.
(If it is an important file, take a copy of it first. Sometimes the procedure fails.)
Open the document with Acrobat. Then choose the the \*(L"TouchUp Text\*(R" tool (icon or
from the tools menu). Select a line of text somewhere on the page. Right-click the
mouse. Choose \*(L"Attributes\*(R".Change font size or anything else, and then you change
it back to the old value. Save the document.
If there was no text on the page, use some other \*(L"Touch Up\*(R" tool.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prDocDir(\*(AqC:/temp/doc\*(Aq);
\&   prFile(\*(AqnewForm.pdf\*(Aq);
\&   prField(\*(AqMr/Ms\*(Aq, \*(AqMr\*(Aq);
\&   prField(\*(AqFirst_Name\*(Aq, \*(AqLars\*(Aq);
\&   prDocForm(\*(AqmyFile.pdf\*(Aq);
\&   prFontSize(24);
\&   prText(75, 790, \*(AqThis text is added\*(Aq);
\&   prEnd();
.Ve
.PP
(You can use the output from the example in \fBprJs()\fR as input to this example.
Remember to save that file before closing it.)
.PP
\&\fBSee Remarks about JavaScript\fR
.SS "prExtract        \- extract an object group"
.IX Subsection "prExtract - extract an object group"
.Vb 1
\&   prExtract ( $pdfFile, $pageNo, $oldInternalName )
.Ve
.PP
\&\fBoldInternalName\fR, a \*(L"name\*(R"\-object.  This is the internal name you find in the original file.
Returns a \fB\f(CB$newInternalName\fB\fR which can be used for \*(L"low level\*(R" programming. You
have better look at graphObj_pl and modules it has generated for the tutorial,
e.g. thermometer.pm, to see how this function can be used.
.PP
When you call this function, the necessary objects will be copied to your new
PDF-file, and you can refer to them with the new name you receive.
.SS "prField      \- assign a value to an interactive field"
.IX Subsection "prField - assign a value to an interactive field"
.Vb 1
\&    prField ( $fieldName, $value )
.Ve
.PP
\&\fB\f(CB$fieldName\fB\fR is an interactive field in the document you are creating.
It has to be spelled exactly the same way here as it spelled in the document.
\&\fB\f(CB$value\fB\fR is what you want to assigned to the field.
Put all your sentences with prField early in your script. After prFile and \fBbefore\fR
prDoc or prDocForm and of course before prEnd. Each sentence with prField is
translated to JavaScript and merged with old JavaScript
.PP
See \fBprDocForm()\fR for an example
.PP
If you are going to assign a value to a field consisting of several lines, you
can write like this:
.PP
.Vb 2
\&   my $string = "This is the first line \er second line \en 3:rd line";
\&   prField(\*(AqfieldName\*(Aq, $string);
.Ve
.PP
You can also let '$value' be a  snippet of JavaScript-code that assigns something
to the field. Then you have to put 'js:' first in \*(L"$value\*(R" like this:
.PP
.Vb 2
\&   my $sentence = encrypt(\*(AqThis will be decrypted by "unPack"(JavaScript) \*(Aq);
\&   prField(\*(AqInterest_9\*(Aq, "js: unPack(\*(Aq$sentence\*(Aq)");
.Ve
.PP
If you refer to a JavaScript function, it has to be included with prJs first. (The
JavaScript interpreter will simply not be aware of old functions in the PDF-document,
when the initiation is done.)
.SS "prFont       \- set current font"
.IX Subsection "prFont - set current font"
.Vb 1
\&   prFont ( $fontName )
.Ve
.PP
\&\f(CW$fontName\fR is an \*(L"external\*(R" font name. The parameter is optional.
In list context returns \fB\f(CB$internalName\fB, \f(CB$externalName\fB, \f(CB$oldInternalName\fB,
\&\f(CB$oldExternalname\fB\fR The first two variables refer to the current font, the two later
to the font before the change. In scalar context returns b<$internalName>
.PP
If a font wasn't found, Helvetica will be set.
These names are always recognized:
\&\fBTimes-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold,
Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique,
Helvetica-BoldOblique\fR or abbreviated
\&\fB\s-1TR, TB, TI, TBI, C, CB, CO, CBO, H, HB, HO, HBO\s0\fR.
(\fBSymbol and ZapfDingbats\fR or abbreviated \fBS, Z\fR, also belong to the predefined
fonts, but there is something with them that I really don't understand. You should
print them first on a page, and then use other fonts, otherwise they are not displayed.)
.PP
You can also use a font name from an included page. It has to be spelled exactly as
it is done there. Look in the file and search for \*(L"/BaseFont\*(R" and the font
name. But take care, e.g. the PDFMaker which converts to \s-1PDF\s0 from different
Microsoft programs, only defines exactly those letters you can see on the page. You
can use the font, but perhaps some of your letters were not defined.
.PP
In the distribution there is an utility program, 'reuseComponent_pl', which displays
included fonts in a PDF-file and prints some letters. Run it to see the name of the
font and if it is worth extracting.
.PP
.Vb 3
\&   use PDF::Reuse;
\&   use strict;
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&
\&   ####### One possibility #########
\&
\&   prFont(\*(AqTimes\-Roman\*(Aq);     # Just setting a font
\&   prFontSize(20);
\&   prText(180, 790, "This is a heading");
\&
\&   ####### Another possibility #######
\&
\&   my $font = prFont(\*(AqC\*(Aq);    # Setting a font, getting an
\&                              # internal name
\&   prAdd("BT /$font 12 Tf 25 760 Td (This is some other text)Tj ET");
\&   prEnd();
.Ve
.PP
The example above shows you two ways of setting and using a font. One simple, and
one complicated with a possibility to detail control.
.SS "prFontSize       \- set current font size"
.IX Subsection "prFontSize - set current font size"
.Vb 1
\&   prFontSize ( $size )
.Ve
.PP
Returns \fB\f(CB$actualSize\fB, \f(CB$fontSizeBeforetheChange\fB\fR. Without parameters
\&\fBprFontSize()\fR sets the size to 12 points, which is default.
.SS "prForm       \- use a page from an old document as a form/background"
.IX Subsection "prForm - use a page from an old document as a form/background"
Alternative 1) You put your parameters in an anonymous hash (only \fBfile\fR is really
necessary, the others get default values if not given).
.PP
.Vb 10
\&   prForm ( { file     => $pdfFile,       # template file
\&              page     => $page,          # page number (of imported template)
\&              adjust   => $adjust,        # try to fill the media box
\&              effect   => $effect,        # action to be taken
\&              tolerant => $tolerant,      # continue even with an invalid form
\&              x        => $x,             # $x points from the left
\&              y        => $y,             # $y points from the bottom
\&              rotate   => $degree,        # rotate
\&              size     => $size,          # multiply everything by $size
\&              xsize    => $xsize,         # multiply horizontally by $xsize
\&              ysize    => $ysize } )      # multiply vertically by $ysize
\&Ex.:
\&    my $internalName = prForm ( {file     => \*(AqmyFile.pdf\*(Aq,
\&                                 page     => 2 } );
.Ve
.PP
Alternative 2) You put your parameters in this order
.PP
.Vb 2
\&    prForm ( $pdfFile, $page, $adjust, $effect, $tolerant, $x, $y, $degree,
\&            $size, $xsize, $ysize )
.Ve
.PP
Anyway the function returns in list context:  \fB\f(CB$intName\fB, \f(CB@BoundingBox\fB,
\&\f(CB$numberOfImages\fB\fR, in scalar context:  \fB\f(CB$internalName\fB\fR of the form.
.PP
if \fBpage\fR is excluded 1 is assumed.
.PP
\&\fBadjust\fR, could be 1, 2 or 0/nothing. If it is 1, the program tries to adjust the
form to the current media box (paper size) and keeps the proportions unchanged.
If it is 2, the program tries to fill as much of the media box as possible, without
regards to the original proportions.
If this parameter is given, \*(L"x\*(R", \*(L"y\*(R", \*(L"rotate\*(R", \*(L"size\*(R", \*(L"xsize\*(R" and \*(L"ysize\*(R"
will be ignored.
.PP
\&\fBeffect\fR can have 3 values: \fB'print'\fR, which is default, loads the page in an internal
table, adds it to the document and prints it to the current page. \fB'add'\fR, loads the
page and adds it to the document. (Now you can \*(L"manually\*(R" manage the way you want to
print it to different pages within the document.) \fB'load'\fR just loads the page in an
internal table. (You can now take \fIparts\fR of a page like fonts and objects and manage
them, without adding all the page to the document.)You don't get any defined
internal name of the form, if you let this parameter be 'load'.
.PP
\&\fBtolerant\fR can be nothing or something. If it is undefined, you will get an error if your program tries to load
a page which the system cannot really handle, if it e.g. consists of many streams.
If it is set to something, you have to test the first return value \f(CW$internalName\fR to
know if the function was successful. Look at the program 'reuseComponent_pl' for an
example of usage.
.PP
\&\fBx\fR where to start along the x\-axis   (cannot be combined with \*(L"adjust\*(R")
.PP
\&\fBy\fR where to start along the y\-axis   (cannot be combined with \*(L"adjust\*(R")
.PP
\&\fBrotate\fR A degree 0\-360 to rotate the form counter-clockwise. (cannot be combined
with \*(L"adjust\*(R") Often the form disappears out of the media box if degree >= 90.
Then you can move it back with the x and y\-parameters. If degree == 90, you can
add the width of the form to x, If degree == 180 add both width and height to x
and y, and if degree == 270 you can add the height to y.
.PP
\&\fBrotate\fR can also by one of 'q1', 'q2' or 'q3'. Then the system rotates the form
clockwise 90, 180 or 270 degrees and tries to keep the form within the media box.
.PP
The rotation takes place after the form has been resized or moved.
.PP
.Vb 1
\&   Ex. To rotate from portrait (595 x 842 pt) to landscape (842 x 595 pt)
\&
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqNew_Report.pdf\*(Aq);
\&   prMbox(0, 0, 842, 595);
\&
\&   prForm({file   => \*(Aqcert1.pdf\*(Aq,
\&           rotate => \*(Aqq1\*(Aq } );
\&   prEnd();
.Ve
.PP
The same rotation can be achieved like this:
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqNew_Report.pdf\*(Aq);
\&   prMbox(0, 0, 842, 595);
\&
\&   prForm({file   => \*(Aqcert1.pdf\*(Aq,
\&           rotate => 270,
\&           y      => 595 } );
\&   prEnd();
.Ve
.PP
\&\fBsize\fR multiply every measure by this value (cannot be combined with \*(L"adjust\*(R")
.PP
\&\fBxsize\fR multiply horizontally by this value (cannot be combined with \*(L"adjust\*(R")
.PP
\&\fBysize\fR multiply vertically by \f(CW$ysize\fR (cannot be combined with \*(L"adjust\*(R")
.PP
This function redefines a page to an \*(L"XObject\*(R" (the graphic parts), then the
page can be reused and referred to as a unit. Unfortunately there is an important
limitation here. \*(L"XObjects\*(R" can only have single streams. If the page consists
of many streams, you should concatenate them first. Adobe Acrobat can do that.
(If it is an important file, take a copy of it first. Sometimes the procedure fails.)
Open the document with Acrobat. Then choose the \*(L"TouchUp Text\*(R" tool.
Select a line of text somewhere. Right-click the mouse. Choose \*(L"Attributes\*(R".
Change font size or anything else, and then you change it back to the old value.
Save the document. You could alternatively save the file as Postscript and redistill
it with the distiller or with Ghost script, but this is a little more risky. You
might loose fonts or something else. Another alternative could be to use \fBprSinglePage()\fR.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   prForm(\*(Aqbest.pdf\*(Aq);    # Takes page No 1
\&   prText(75, 790, \*(AqDear Mr Gates\*(Aq);
\&   # ...
\&   prPage();
\&   prMbox(0, 0, 900, 960);
\&   my @vec = prForm(   { file => \*(AqEUSA.pdf\*(Aq,
\&                         adjust => 1 } );
\&   prPage();
\&   prMbox();
\&   prText(35, 760, \*(AqThis is the final page\*(Aq);
\&
\&   # More text ..
\&
\&   #################################################################
\&   # We want to put a miniature of EUSA.pdf, 35 points from the left
\&   # 85 points up, and in the format 250 X 200 points
\&   #################################################################
\&
\&   my $xScale = 250 / ($vec[3] \- $vec[1]);
\&   my $yScale = 200 / ($vec[4] \- $vec[2]);
\&
\&   prForm ({ file => \*(AqEUSA.pdf\*(Aq,
\&             xsize => $xScale,
\&             ysize => $yScale,
\&             x     => 35,
\&             y     => 85 });
\&
\&   prEnd();
.Ve
.PP
The first \fBprForm()\fR, in the code, is a simple and \*(L"normal\*(R" way of using the
the function. The second time it is used, the size of the imported page is
changed. It is adjusted to the media box which is current at that moment.
Also data about the form is taken, so you can control more in detail how it
will be displayed.
.SS "prGetLogBuffer       \- get the log buffer."
.IX Subsection "prGetLogBuffer - get the log buffer."
prGetLogBuffer ()
.PP
returns a \fB\f(CB$buffer\fB\fR of the log of the current page. (It could be used
e.g. to calculate a MD5\-digest of what has been registered that far, instead of
accumulating the single values) A log has to be active, see \fBprLogDir()\fR below
.PP
Look at \*(L"Using the template\*(R" and \*(L"Restoring a document from the log\*(R" in the
tutorial for examples of usage.
.SS "prGraphState     \- define a graphic state parameter dictionary"
.IX Subsection "prGraphState - define a graphic state parameter dictionary"
.Vb 1
\&   prGraphState ( $string )
.Ve
.PP
This is a \*(L"low level\*(R" function. Returns \fB\f(CB$internalName\fB\fR. The \fB\f(CB$string\fB\fR has to
be a complete dictionary with initial \*(L"<<\*(R" and terminating \*(L">>\*(R". No syntactical
checks are made. Perhaps you will never have to use this function.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&
\&   ###################################################
\&   # Draw a triangle with Gs0 (automatically defined)
\&   ###################################################
\&
\&   my $str = "q\en";
\&   $str   .= "/Gs0 gs\en";
\&   $str   .= "150 700 m\en";
\&   $str   .= "225 800 l\en";
\&   $str   .= "300 700 l\en";
\&   $str   .= "150 700 l\en";
\&   $str   .= "S\en";
\&   $str   .= "Q\en";
\&   prAdd($str);
\&
\&   ########################################################
\&   # Define a new graph. state param. dic. and draw a new
\&   # triangle further down
\&   ########################################################
\&
\&   $str = \*(Aq<</Type/ExtGState/SA false/SM 0.02/TR2 /Default\*(Aq
\&                      . \*(Aq/LW 15/LJ 1/ML 1>>\*(Aq;
\&   my $gState = prGraphState($str);
\&   $str  = "q\en";
\&   $str .= "/$gState gs\en";
\&   $str .= "150 500 m\en";
\&   $str .= "225 600 l\en";
\&   $str .= "300 500 l\en";
\&   $str .= "150 500 l\en";
\&   $str .= "S\en";
\&   $str .= "Q\en";
\&   prAdd($str);
\&
\&   prEnd();
.Ve
.SS "prImage      \- reuse an image from an old \s-1PDF\s0 document"
.IX Subsection "prImage - reuse an image from an old PDF document"
Alternative 1) You put your parameters in an anonymous hash (only \fBfile\fR is really
necessary, the others get default values if not given).
.PP
.Vb 10
\&   prImage( { file     => $pdfFile,       # template file
\&              page     => $page,          # page number
\&              imageNo  => $imageNo        # image number
\&              adjust   => $adjust,        # try to fill the media box
\&              effect   => $effect,        # action to be taken
\&              x        => $x,             # $x points from the left
\&              y        => $y,             # $y points from the bottom
\&              rotate   => $degree,        # rotate
\&              size     => $size,          # multiply everything by $size
\&              xsize    => $xsize,         # multiply horizontally by $xsize
\&              ysize    => $ysize } )      # multiply vertically by $ysize
\&Ex.:
\&   prImage( { file    => \*(AqmyFile.pdf\*(Aq,
\&              page    => 10,
\&              imageNo => 2 } );
.Ve
.PP
Alternative 2) You put your parameters in this order
.PP
.Vb 2
\&    prImage ( $pdfFile, [$page, $imageNo, $effect, $adjust, $x, $y, $degree,
\&            $size, $xsize, $ysize] )
.Ve
.PP
Returns in scalar context \fB\f(CB$internalName\fB\fR As a list \fB\f(CB$internalName\fB, \f(CB$width\fB,
\&\f(CB$height\fB\fR
.PP
Assumes that \f(CW$pageNo\fR and \f(CW$imageNo\fR are 1, if not specified. If \f(CW$effect\fR is given and
anything else then 'print', the image will be defined in the document,
but not shown at this moment.
.PP
For all other parameters, look at \fBprForm()\fR.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   my @vec = prImage({ file  => \*(Aqbest.pdf\*(Aq,
\&                       x     => 10,
\&                       y     => 400,
\&                       xsize => 0.9,
\&                       ysize => 0.8 } );
\&   prText(35, 760, \*(AqThis is some text\*(Aq);
\&   # ...
\&   prPage();
\&   my @vec2 = prImage( { file    => \*(Aqdestiny.pdf\*(Aq,
\&                         page    => 1,
\&                         imageNo => 1,
\&                         effect  => \*(Aqadd\*(Aq } );
\&   prText(25, 760, "There shouldn\*(Aqt be any image on this page");
\&   prPage();
\&   ########################################################
\&   #  Now we make both images so that they could fit into
\&   #  a box 300 X 300 points, and they are displayed
\&   ########################################################
\&
\&   prText(25, 800, \*(AqThis is the first image :\*(Aq);
\&
\&   my $xScale = 300 / $vec[1];
\&   my $yScale = 300 / $vec[2];
\&   if ($xScale < $yScale)
\&   {  $yScale = $xScale;
\&   }
\&   else
\&   {  $xScale = $yScale;
\&   }
\&   prImage({ file   => \*(Aqbest.pdf\*(Aq,
\&             x      => 25,
\&             y      => 450,
\&             xsize  => $xScale,
\&             ysize  => $yScale} );
\&
\&   prText(25, 400, \*(AqThis is the second image :\*(Aq);
\&
\&   $xScale = 300 / $vec2[1];
\&   $yScale = 300 / $vec2[2];
\&   if ($xScale < $yScale)
\&   {  $yScale = $xScale;
\&   }
\&   else
\&   {  $xScale = $yScale;
\&   }
\&   prImage({ file   => \*(Aqdestiny.pdf\*(Aq,
\&             x      => 25,
\&             y      => 25,
\&             xsize  => $xScale,
\&             ysize  => $yScale} );
\&
\&   prEnd();
.Ve
.PP
On the first page an image is displayed in a simple way. While the second page
is processed, \fBprImage()\fR, loads an image, but it is not shown here. On the 3:rd
page, the two images are scaled and shown.
.PP
In the distribution there is an utility program, 'reuseComponent_pl', which displays
included images in a PDF-file and their \*(L"names\*(R".
.SS "prInit       \- add JavaScript to be executed at initiation"
.IX Subsection "prInit - add JavaScript to be executed at initiation"
.Vb 1
\&   prInit ( $string, $duplicateCode )
.Ve
.PP
\&\fB\f(CB$string\fB\fR can be any JavaScript code, but you can only refer to functions included
with prJs. The JavaScript interpreter will not know other functions in the document.
Often you can add new things, but you can't remove or change interactive fields,
because the interpreter hasn't come that far, when initiation is done.
.PP
\&\fB\f(CB$duplicateCode\fB\fR is undefined or anything. It duplicates the JavaScript code
which has been used at initiation, so you can look at it from within Acrobat and
debug it. It makes the document bigger. This parameter is \fBdeprecated\fR.
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   prInit(\*(Aqapp.alert("This is displayed when opening the document");\*(Aq);
\&
\&   prEnd();
.Ve
.PP
Remark: Avoid to use \*(L"return\*(R" in the code you use at initiation. If your user has
downloaded a page with Web Capture, and after that opens a PDF-document where a
JavaScript is run at initiation and that JavaScript contains a return-statement,
a bug occurs. The JavaScript interpreter \*(L"exits\*(R" instead of returning, the execution
of the JavaScript might finish to early. This is a bug in Acrobat/Reader 5.
.SS "prInitVars       \- initiate global variables and internal tables"
.IX Subsection "prInitVars - initiate global variables and internal tables"
.Vb 1
\&   prInitVars(1)
.Ve
.PP
If you run programs with PDF::Reuse as persistent procedures, you probably need to
initiate global variables. If you have '1' or anything as parameter, internal tables for forms, images, fonts
and interactive functions are \fBnot\fR initiated. The module \*(L"learns\*(R" offset and sizes of
used objects, and can process them faster, but at the same time the size of the
program grows.
.PP
.Vb 4
\&   use PDF::Reuse;
\&   use strict;
\&   prInitVars();     # To initiate ALL global variables and tables
\&   # prInitVars(1);  # To make it faster, but more memory consuming
\&
\&   $| = 1;
\&   print STDOUT "Content\-Type: application/pdf \en\en";
\&
\&   prFile();         # To send the document uncatalogued to STDOUT
\&
\&   prForm(\*(Aqbest.pdf\*(Aq);
\&   prText(25, 790, \*(AqDear Mr. Anders Persson\*(Aq);
\&   # ...
\&   prEnd();
.Ve
.PP
If you call this function without parameters all global variables, including the
internal tables, are initiated.
.SS "prAltJpeg        \- import a low-res jpeg-image for display and a high-res jpeg-image for printing"
.IX Subsection "prAltJpeg - import a low-res jpeg-image for display and a high-res jpeg-image for printing"
.Vb 1
\&   prAltJpeg ( $imageData, $width, $height, $format, $altImageData, $altWidth, $altHeight, $altFormat )
.Ve
.PP
\&\fB\f(CB$imageData\fB\fR contains 1 single jpeg-image. \fB\f(CB$width\fB\fR and \fB\f(CB$height\fB\fR
also have to be specified. \fB\f(CB$format\fB\fR indicates the format the image
data takes: 0 for file, 1 for binary string. \fB\f(CB$altImageData\fB\fR etc.
follows the same foramt. Returns the \fB\f(CB$internalName\fB\fR
.PP
.Vb 3
\&   use PDF::Reuse;
\&   use Image::Info qw(image_info dim);
\&   use strict;
\&
\&   my $file = \*(AqmyImage.jpg\*(Aq;
\&   my $info = image_info($file);
\&   my ($width, $height) = dim($info);    # Get the dimensions
\&   my $colortype = $info\->{color_type};  # get color space
\&
\&   my $alt_file = \*(AqmyImage.jpg\*(Aq;
\&   my $alt_info = image_info($alt_file);
\&   my ($alt_width, $alt_height) = dim($alt_info);
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   my $intName = prAltJpeg("$file",         # Define the image
\&                            $width,         # in the document
\&                            $height,
\&                            0,
\&                            "$alt_file",
\&                            $alt_width,
\&                            $alt_height,
\&                            0);
\&
\&   my $str = "q\en";
\&   $str   .= "$width 0 0 $height 10 10 cm\en";
\&   $str   .= "/$intName Do\en";
\&   $str   .= "Q\en";
\&   prAdd($str);
\&   prEnd();
.Ve
.SS "prJpeg       \- import a jpeg-image"
.IX Subsection "prJpeg - import a jpeg-image"
.Vb 1
\&   prJpeg ( $imageData, $width, $height, $format )
.Ve
.PP
\&\fB\f(CB$imageData\fB\fR contains 1 single jpeg-image. \fB\f(CB$width\fB\fR and \fB\f(CB$height\fB\fR
also have to be specified. \fB\f(CB$format\fB\fR indicates the format the image
data takes: 0 for file, 1 for binary string. Returns the \fB\f(CB$internalName\fB\fR
.PP
.Vb 3
\&   use PDF::Reuse;
\&   use Image::Info qw(image_info dim);
\&   use strict;
\&
\&   my $file = \*(AqmyImage.jpg\*(Aq;
\&   my $info = image_info($file);
\&   my ($width, $height) = dim($info);    # Get the dimensions
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   my $intName = prJpeg("$file",         # Define the image
\&                         $width,         # in the document
\&                         $height,
\&                         0);
\&
\&   my $str = "q\en";
\&   $str   .= "$width 0 0 $height 10 10 cm\en";
\&   $str   .= "/$intName Do\en";
\&   $str   .= "Q\en";
\&   prAdd($str);
\&   prEnd();
.Ve
.PP
This is a little like an extra or reserve routine to add images to the document.
The most simple way is to use \fBprImage()\fR
.SS "prJs     \- add JavaScript"
.IX Subsection "prJs - add JavaScript"
.Vb 1
\&   prJs ( $string|$fileName )
.Ve
.PP
To add JavaScript to your new document. \fB\f(CB$string\fB\fR has to consist only of
JavaScript functions: function a (..){ ... } function b (..) { ...} and so on
If \fB\f(CB$string\fB\fR doesn't contain '{', \fB\f(CB$string\fB\fR is interpreted as a filename.
In that case the file has to consist only of JavaScript functions.
.PP
\&\fBSee \*(L"Remarks about JavaScript\*(R"\fR
.SS "prLink    \- add a hyper link"
.IX Subsection "prLink - add a hyper link"
.Vb 6
\&   prLink( { page   => $pageNo,     # Starting with 1  !
\&             x      => $x,
\&             y      => $y,
\&             width  => $width,
\&             height => $height,
\&             URI    => $URI     } );
.Ve
.PP
You can also call prLink like this:
.PP
.Vb 1
\&   prLink($page, $x, $y, $width, $height, $URI);
.Ve
.PP
You have to put prLink \fBafter prFile and before the sentences where its' page
is created\fR. The links are created at the page-breaks. If the page is already
created, no new link will be inserted.
.PP
Here is an example where the links of a 4 page document are preserved, and a link is
added at the end of the document. We assume that there is some suitable text at that
place (x = 400, y = 350):
.PP
.Vb 2
\&   use strict;
\&   use PDF::Reuse;
\&
\&   prFile(\*(Aqtest.pdf\*(Aq);
\&
\&   prLink( {page   => 4,
\&            x      => 400,
\&            y      => 350,
\&            width  => 105,
\&            height => 15,
\&            URI    => \*(Aqhttp://www.purelyInvented.com/info.html\*(Aq } );
\&
\&   prDoc(\*(AqfourPages.pdf\*(Aq);
\&
\&   prEnd();
.Ve
.PP
( If you are creating each page of a document separately, you can also use 'hyperLink'
from PDF::Reuse::Util. Then you get an external text in Helvetica-Oblique, underlined
and in blue.
.PP
.Vb 3
\&  use strict;
\&  use PDF::Reuse;
\&  use PDF::Reuse::Util;
\&
\&  prFile(\*(Aqtest.pdf\*(Aq);
\&  prForm(\*(Aqtemplate.pdf\*(Aq, 5);
\&  my ($from, $pos) = prText(25, 700, \*(AqTo get more information  \*(Aq);
\&
\&  $pos = hyperLink( $pos, 700, \*(AqPress this link\*(Aq,
\&                    \*(Aqhttp://www.purelyInvented.com/info.html\*(Aq );
\&  ($from, $pos) = prText( $pos, 700, \*(Aq And get connected\*(Aq);
\&  prEnd();
.Ve
.PP
\&'hyperLink' has a few parameters: \f(CW$x\fR, \f(CW$y\fR, \f(CW$textToBeShown\fR, \f(CW$hyperLink\fR and
\&\f(CW$fontSize\fR (not shown in the example). It returns current x\-position. )
.SS "prLog        \- add a string to the log"
.IX Subsection "prLog - add a string to the log"
.Vb 1
\&   prLog ( $string )
.Ve
.PP
Adds whatever you want to the current log (a reference No, a commentary, a tag ?)
A log has to be active see \fBprLogDir()\fR
.PP
Look at \*(L"Using the template\*(R" and \*(L"Restoring the document from the log\*(R" in
the tutorial for an example.
.SS "prLogDir     \- set directory for the log"
.IX Subsection "prLogDir - set directory for the log"
.Vb 1
\&   prLogDir ( $directory )
.Ve
.PP
Sets a directory for the logs and activates the logging.
A little log file is created for each PDF-file. Normally it should be much, much
more compact then the PDF-file, and it should be possible to restore or verify
a document with the help of it. (Of course you could compress or store the logs in a
database to save even more space.)
.PP
.Vb 2
\&   use PDF::Reuse;
\&   use strict;
\&
\&   prDocDir(\*(AqC:/temp/doc\*(Aq);
\&   prLogDir(\*(AqC:/run\*(Aq);
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   prForm(\*(Aqbest.pdf\*(Aq);
\&   prText(25, 790, \*(AqDear Mr. Anders Persson\*(Aq);
\&   # ...
\&   prEnd();
.Ve
.PP
In this example a log file with the name 'myFile.pdf.dat' is created in the
directory 'C:\erun'. If that directory doesn't exist, the system tries to create it.
(But, just as mkdir does, it only creates the last level in a directory tree.)
.SS "prMbox       \- define the format (MediaBox) for a new page."
.IX Subsection "prMbox - define the format (MediaBox) for a new page."
.Vb 1
\&   prMbox ( $lowerLeftX, $lowerLeftY, $upperRightX, $upperRightY )
.Ve
.PP
If the function or the parameters are missing, they are set to 0, 0, 595, 842 points respectively.
Only for new pages. Pages created with prDoc and prSinglePage keep their media boxes unchanged.
.PP
See \fBprForm()\fR for an example.
.SS "prPage       \- create/insert a page"
.IX Subsection "prPage - create/insert a page"
.Vb 1
\&   prPage ($noLog)
.Ve
.PP
Don't use the optional parameter, it is only used internally, not to clutter the log,
when automatic page breaks are made.
.PP
See \fBprForm()\fR for an example.
.SS "prSinglePage  \- take single pages, one by one, from an old document"
.IX Subsection "prSinglePage - take single pages, one by one, from an old document"
.Vb 1
\&   prSinglePage($file, $pageNumber)
.Ve
.PP
\&\f(CW$pageNumber\fR is optional. If not given, next page is assumed
Returns number of remaining pages.
This function is a variant of prDoc for single pages, with the addition that it
has a counter of last page read, and total number of pages of the old document,
so it can be used to loop through a document.
.PP
To add a form, image and page number to each page of a document
(The document Battery.pdf is cropped so each page is fairly small)  You could also have
used prDoc, but only if you knew in advance the number of pages of the old document
.PP
.Vb 3
\&   use PDF::Reuse;
\&   use PDF::Reuse::Util;
\&   use strict;
\&
\&   prFile(\*(Aqtest.pdf\*(Aq);
\&
\&   my $pageNumber = 0;
\&   my $left = 1;            # Every valid PDF\-document has at least 1 page,
\&                            # so that can be assumed
\&
\&   while ($left)
\&   {   $pageNumber++;
\&       prForm(  { file =>\*(AqWords.pdf\*(Aq,
\&                  page => 5,
\&                  x    => 150,
\&                  y    => 150} );
\&
\&       prImage( { file    =>\*(AqMedia.pdf\*(Aq,
\&                  page    => 6,
\&                  imageNo => 1,
\&                  x       => 450,
\&                  y       => 450 } );
\&       blackText();
\&       prText( 360, 250, $pageNumber);
\&       $left = prSinglePage(\*(AqBattery.pdf\*(Aq);
\&    }
\&
\&    prEnd;
.Ve
.PP
prSinglePage creates a new page from an old document and adds new content (to the array of
streams of that page). Most often you can add new contents to the page like the example above,
and it works fine, but sometimes you get surprises. There can e.g. be instructions in the earlier
contents to make filling color white, and then you will probably not see added new text. That
is why \fBPDF::Reuse::Util::blackText()\fR is used in the example. There can be other instructions
like moving or rotating the user space. Also new contents can end up outside the crop-box.
Of course all new programs should be tested. If prSinglePage can't be used, try to use prForm
followed by prPage instead.
.SS "prStrWidth   \- calculate the string width"
.IX Subsection "prStrWidth - calculate the string width"
.Vb 1
\&   prStrWidth($string, $font, $fontSize)
.Ve
.PP
Returns string width in points.
Should be used in conjunction with one of these predefined fonts of Acrobat/Reader:
Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold, Courier-Oblique,
Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique,
Helvetica-BoldOblique or with a TrueType font embedded with prTTFont. If some other font is
given, Helvetica is used, and the returned value will at the best be approximate.
.SS "prText       \- add a text-string"
.IX Subsection "prText - add a text-string"
.Vb 1
\&   prText ( $x, $y, $string, $align, $rotation )
.Ve
.PP
Puts \fB\f(CB$string\fB\fR at position \fB\f(CB$x\fB, \f(CB$y\fB\fR
Returns 1 in scalar context. Returns ($xFrom, \f(CW$xTo\fR) in list context. \f(CW$xTo\fR will not
be defined together with a rotation. \fBprStrWidth()\fR is used to calculate the length of the
strings, so only the predefined fonts together with Acrobat/Reader, or embedded TrueType
fonts will give reliable values for \f(CW$xTo\fR.
.PP
\&\f(CW$align\fR can be 'left' (= default), 'center' or 'right'. The parameter is optional.
.PP
\&\f(CW$rotation\fR can be a degree 0 \- 360, 'q1', 'q2' or 'q3'. Also optional.
.PP
Current font and font size are used. (If you use \fBprAdd()\fR before this function,
many other things could also influence the text.)
.PP
.Vb 2
\&   use strict;
\&   use PDF::Reuse;
\&
\&   prFile(\*(Aqtest.pdf\*(Aq);
\&
\&   #####################################
\&   # Use a "curser" ($pos) along a line
\&   #####################################
\&
\&   my ($from, $pos) = prText(25, 800, \*(AqFirst write this. \*(Aq);
\&   ($from, $pos) = prText($pos, 800, \*(AqThen write this. \*(Aq);
\&   prText($pos, 800, \*(AqFinally write this.\*(Aq);
\&
\&   #####################################
\&   # Right adjust and center sentences
\&   #####################################
\&
\&   prText( 200, 750, \*(AqA short sentence\*(Aq, \*(Aqright\*(Aq);
\&   prText( 200, 735, \*(AqThis is a longer sentence\*(Aq, \*(Aqright\*(Aq);
\&   prText( 200, 720, \*(AqA word\*(Aq, \*(Aqright\*(Aq);
\&
\&   prText( 200, 705, \*(AqCentered around a point 200 points from the left\*(Aq, \*(Aqcenter\*(Aq);
\&   prText( 200, 690, \*(AqThe same center\*(Aq, \*(Aqcenter\*(Aq);
\&   prText( 200, 675, \*(Aq\->.<\-\*(Aq, \*(Aqcenter\*(Aq);
\&
\&   ############
\&   # Rotation
\&   ############
\&
\&   prText( 200, 550, \*(Aq Rotate 0 degrees\*(Aq,\*(Aq\*(Aq, 0);
\&   prText( 200, 550, \*(Aq Rotate 60 degrees\*(Aq,\*(Aq\*(Aq, 60);
\&   prText( 200, 550, \*(Aq Rotate 120 degrees\*(Aq,\*(Aq\*(Aq, 120);
\&   prText( 200, 550, \*(Aq Rotate 180 degrees\*(Aq,\*(Aq\*(Aq, 180);
\&   prText( 200, 550, \*(Aq Rotate 240 degrees\*(Aq,\*(Aq\*(Aq, 240);
\&   prText( 200, 550, \*(Aq Rotate 300 degrees\*(Aq,\*(Aq\*(Aq, 300);
\&
\&   prText( 400, 430, \*(AqRotate 90 degrees clock\-wise\*(Aq,\*(Aq\*(Aq,\*(Aqq1\*(Aq);
\&   prText( 400, 430, \*(AqRotate 180 degrees clock\-wise\*(Aq,\*(Aq\*(Aq, \*(Aqq2\*(Aq);
\&   prText( 400, 430, \*(AqRotate 270 degrees clock\-wise\*(Aq,\*(Aq\*(Aq, \*(Aqq3\*(Aq);
\&
\&   ##########################
\&   # Rotate and right adjust
\&   ##########################
\&
\&   prText( 200, 230, \*(AqRotate 90 degrees clock\-wise ra\->\*(Aq,\*(Aqright\*(Aq,\*(Aqq1\*(Aq);
\&   prText( 200, 230, \*(AqRotate 180 degrees clock\-wise ra\->\*(Aq,\*(Aqright\*(Aq, \*(Aqq2\*(Aq);
\&   prText( 200, 230, \*(AqRotate 270 degrees clock\-wise ra\->\*(Aq,\*(Aqright\*(Aq, \*(Aqq3\*(Aq);
\&
\&   prEnd();
.Ve
.SS "prTTFont         \- select and embed a TrueType font"
.IX Subsection "prTTFont - select and embed a TrueType font"
.Vb 1
\&  prTTFont ( "/path/to/font/file.ttf" )
.Ve
.PP
This function is equivalent to \f(CW\*(C`prFont\*(C'\fR except that rather than restricting
you to the list of core built-in fonts, it allows you to select an external
TrueType font file and have it embedded in your \s-1PDF\s0 document.  Using TrueType
fonts also enables the \f(CW\*(C`prText\*(C'\fR function to accept \s-1UTF\-8\s0 strings, which allows
you to use characters outside the Mac\-Roman/Win\-ANSI character sets used by the
built-in fonts.
.PP
You can specify the same font path multiple times in one document and only one
copy will be embedded.  Alternatively, \f(CW\*(C`prTTFont\*(C'\fR returns an identifier which
can be used to select the same font again:
.PP
.Vb 10
\&  my $arial = prTTFont(\*(Aq/path/to/Arial.ttf\*(Aq);
\&  prFontSize(20);
\&  prText(20, 700, \*(AqSome text in Arial\*(Aq);
\&  #
\&  # ... later ...
\&  #
\&  prPage();
\&  prTTFont($arial);
\&  prFontSize(12);
\&  prText(20, 700, \*(AqSome more text in Arial\*(Aq);
\&  #
\&  #  to pass a UTF8 string to prText
\&  #
\&  prText(20, 675, "T\ex{113}n\ex{101} koutou");  # T?n? Koutou
.Ve
.PP
In list context this function returns \f(CW$internalName\fR, \f(CW$externalName\fR,
\&\f(CW$oldInternalName\fR, \f(CW$oldExternalname\fR. The first two variables refer to the
current font, the last two refer to the font before the change. In scalar
context only \f(CW$internalName\fR is returned.
.PP
Note: To use this function, you must have the Font::TTF and Text::PDF
modules installed.
.SH "INTERNAL OR DEPRECATED FUNCTIONS"
.IX Header "INTERNAL OR DEPRECATED FUNCTIONS"
.IP "prBar     \- define and paint bars for bar fonts" 2
.IX Item "prBar - define and paint bars for bar fonts"
.Vb 1
\&   prBar ($x, $y, $string)
.Ve
.Sp
Prints a bar font pattern at the current page.
Returns \f(CW$internalName\fR for the font.
\&\f(CW$x\fR and \f(CW$y\fR are coordinates in points and \f(CW$string\fR should consist of the characters
\&'0', '1' and '2' (or 'G'). '0' is a white bar, '1' is a dark bar. '2' and 'G' are
dark, slightly longer bars, guard bars.
You can use e.g. GD::Barcode or one module in that group to calculate the bar code
pattern. prBar \*(L"translates\*(R" the pattern to white and black bars.
.Sp
.Vb 3
\&   use PDF::Reuse;
\&   use GD::Barcode::Code39;
\&   use strict;
\&
\&   prFile(\*(AqmyFile.pdf\*(Aq);
\&   my $oGdB = GD::Barcode::Code39\->new(\*(AqJOHN DOE\*(Aq);
\&   my $sPtn = $oGdB\->barcode();
\&   prBar(100, 600, $sPtn);
\&   prEnd();
.Ve
.Sp
Internally the module uses a font for the bars, so you might want to change the font size before calling
this function. In that case, use \fBprFontSize()\fR .
If you call this function without arguments it defines the bar font but does
not write anything to the current page.
.Sp
\&\fBAn easier and often better way to produce bar codes is to use PDF::Reuse::Barcode.\fR
Look at that module!
.IP "prCid     \- define time stamp/check id" 2
.IX Item "prCid - define time stamp/check id"
.Vb 1
\&   prCid ( $timeStamp )
.Ve
.Sp
An internal function. Don't bother about it. It is used in automatic
routines when you want to restore a document. It gives modification time of
the next PDF-file or JavaScript.
See \*(L"Restoring a document from the log\*(R" in the tutorial for more about the
time stamp
.IP "prId      \- define id-string of a \s-1PDF\s0 document" 2
.IX Item "prId - define id-string of a PDF document"
.Vb 1
\&   prId ( $string )
.Ve
.Sp
An internal function. Don't bother about it. It is used e.g. when a document is
restored and an id has to be set, not calculated.
.IP "prIdType      \- define id-type" 2
.IX Item "prIdType - define id-type"
.Vb 1
\&   prIdType ( $string )
.Ve
.Sp
An internal function. Avoid using it. \fB\f(CB$string\fB\fR could be \*(L"Rep\*(R" for replace or
\&\*(L"None\*(R" to avoid calculating an id.
.Sp
Normally you don't use this function. Then an id is calculated with the help of
Digest::MD5::md5_hex and some data from the run.
.IP "prTouchUp     \- make changes and reuse more difficult" 2
.IX Item "prTouchUp - make changes and reuse more difficult"
.Vb 1
\&   prTouchUp (1);
.Ve
.Sp
By default and after you have issued \fBprTouchUp\fR\|(1), you can change the document
with the TouchUp tool from within Acrobat.
If you want to switch off this possibility, you use \fBprTouchUp()\fR without any
parameter.  Then the user shouldn't be able to change anything graphic by mistake.
He has to do something premeditated and perhaps with a little effort.
He could still save it as Postscript and redistill, or he could remove or add single pages.
(Here is a strong reason why the log files, and perhaps also check sums, are needed.
It would be very difficult to forge a document unless the forger also has access to your
computer and knows how the check sums are calculated.)
.Sp
\&\fBAvoid to switch off the TouchUp tool for your templates.\fR It creates an
extra level within the PDF-documents . Use this function for your final documents.
.Sp
See \*(L"Using the template\*(R" in the tutorial for an example.
.Sp
This function works for pages created with prPage, but mot with prDoc and prSinglePage,
So it is more or less deprecated as these function have developed.
.Sp
(To encrypt your documents: use the batch utility within Acrobat)
.IP "prVers        \- check version of log and program" 2
.IX Item "prVers - check version of log and program"
.Vb 1
\&   prVers ( $versionNo )
.Ve
.Sp
To check version of this module in case a document has to be
restored.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 3
\&   PDF::Reuse::Tutorial
\&   PDF::Reuse::Barcode
\&   PDF::Reuse::OverlayChart
.Ve
.PP
To program with PDF-operators, look at \*(L"The PDF-reference Manual\*(R" which probably
is possible to download from http://partners.adobe.com/asn/tech/pdf/specifications.jsp
Look especially at chapter 4 and 5, Graphics and Text, and the Operator summary.
.PP
Technical Note # 5186 contains the \*(L"Acrobat JavaScript Object Specification\*(R". I
downloaded it from http://partners.adobe.com/asn/developer/technotes/acrobatpdf.html
.PP
If you are serious about producing PDF-files, you probably need Adobe Acrobat sooner
or later. It has a price tag. Other good programs are GhostScript and GSview.
I got them via http://www.cs.wisc.edu/~ghost/index.html  Sometimes they can replace Acrobat.
A nice little detail is e.g. that GSview shows the x\- and y\-coordinates better then Acrobat. If you need to convert HTML-files to \s-1PDF, HTMLDOC\s0 is a possible tool. Download it from
http://www.easysw.com . A simple tool for vector graphics is Mayura Draw 2.04, download
it from http://www.mayura.com. It is free. I have used it to produce the graphic
OO-code in the tutorial. It produces postscript which the Acrobat Distiller (you get it together with Acrobat)
or Ghostscript can convert to \s-1PDF.\s0(The commercial product, Mayura Draw 4.01 or something
higher can produce PDF-files straight away)
.PP
If you want to import jpeg-images, you might need
.PP
.Vb 1
\&   Image::Info
.Ve
.PP
To get definitions for e.g. colors, take them from
.PP
.Vb 1
\&   PDF::API2::Util
.Ve
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Meta data, info and many other features of the PDF-format have not been
implemented in this module.
.PP
Many things can be added afterwards, after creating the files. If you e.g. need
files to be encrypted, you can use a standard batch routine within Adobe Acrobat.
.SH "THANKS TO"
.IX Header "THANKS TO"
Martin Langhoff, Matisse Enzer, Yunliang Yu and others who have contributed with code, suggestions and error
reports.
.PP
Grant McLean has implemented font embedding by grafting Font::TTF and
Text::PDF::TTFont0 onto the PDF::Reuse \s-1API.\s0 He has written the embedded packages PDF::Reuse::DocProxy
and PDF::Reuse::TTFont.
.PP
The functionality of prDoc and prSinglePage to include new contents was developed for a
specific task with support from the Electoral Enrolment Centre, Wellington, New Zealand
.SH "MAILING LIST"
.IX Header "MAILING LIST"
.Vb 1
\&   http://groups.google.com/group/PDF\-Reuse
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Lars Lundberg larslund@cpan.org
Chris Nighswonger cnighs@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003 \- 2004 Lars Lundberg, Solidez \s-1HB.\s0
Copyright (C) 2005 Karin Lundberg.
Copyright (C) 2006 \- 2010 Lars Lundberg, Solidez \s-1HB.\s0
Copyright (C) 2010 \- 2014 Chris Nighswonger
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
You get this module free as it is, but nothing is guaranteed to work, whatever
implicitly or explicitly stated in this document, and everything you do,
you do at your own risk \- I will not take responsibility
for any damage, loss of money and/or health that may arise from the use of this module.
