.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Regexp::Parser 3"
.TH Regexp::Parser 3 "2020-01-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Parser \- base class for parsing regexes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See examples in \*(L"\s-1USAGE\*(R"\s0.
.SH "WARNING"
.IX Header "WARNING"
This is version \fB0.022b\fR.  The documentation is (still) incomplete.  It
may be a little jumbled or hard to understand.  If you find a problem,
please let me know.
.PP
Documentation has been added and moved around. See
Regexp::Parser::Objects for documentation about nodes and the objects
that represent them.  See Regexp::Parser::Handlers for information
about sub-classing this module.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module parses regular expressions (regexes).  Its default \*(L"grammar\*(R"
is Perl 5.8.4's regex set.  Grammar is quoted because the module does
not so much define a grammar as let each matched node state what it
expects to match next, but there is not currently a way of extracting a
complete grammar.  This may change in future versions.
.PP
This module is designed as a replacement (though not drop-in) for my old
\&\fIYAPE::Regex\fR modules.
.SH "USAGE"
.IX Header "USAGE"
.SS "Creating an Instance"
.IX Subsection "Creating an Instance"
To use this module as is, load it, and create an instance:
.PP
.Vb 2
\&  use Regexp::Parser;
\&  my $parser = Regexp::Parser\->new;
.Ve
.SS "Setting a Regex"
.IX Subsection "Setting a Regex"
To have the parser work on a specific regex, you can do use any of the
following methods:
.ie n .IP "$parser = Regexp::Parser\->new($regex)" 4
.el .IP "\f(CW$parser\fR = Regexp::Parser\->new($regex)" 4
.IX Item "$parser = Regexp::Parser->new($regex)"
You can send the regex to be parsed as the argument to the constructor.
.ie n .IP "$parser\->regex($regex)" 4
.el .IP "\f(CW$parser\fR\->regex($regex)" 4
.IX Item "$parser->regex($regex)"
Clears the parser's memory and sets \f(CW$regex\fR as the regex to be parsed.
.PP
These two approaches do an initial pass over the regex to make sure it
is well-formed \*(-- any warnings or errors will be determined during this
initial pass.
.PP
\fIFatal Errors\fR
.IX Subsection "Fatal Errors"
.PP
\&\fBIf there is a compilation-stopping error\fR, \f(CW$parser\fR\->errmsg will return
that error message, and \f(CW$parser\fR\->errnum will return the numerical value
of the message.  If you use \fBnew()\fR the \fIRegexp::Parser\fR object will
still be returned, but if you use \fBregex()\fR then it will return false.
.PP
.Vb 5
\&  if (! $parser\->regex($rx)) {
\&    my $errmsg = $parser\->errmsg;
\&    my $errnum = $parser\->errnum;
\&    # ...
\&  }
.Ve
.PP
If you want to see if an error is a particular error, see
\&\*(L"\s-1ERROR HANDLING\*(R"\s0.
.SS "Inspecting the Parsing"
.IX Subsection "Inspecting the Parsing"
To intercept each node as it is parsed, use the \fBnext()\fR method:
.PP
.Vb 3
\&  while (my $node = $parser\->next) {
\&    # $node is a Regexp::Parser::* object
\&  }
.Ve
.PP
When the regex is finished being parsed, \fBnext()\fR returns false, and will
return false if called again.
.SS "Building the Tree"
.IX Subsection "Building the Tree"
If you don't care to intercept the building of the tree, you can use the
\&\fBparse()\fR method to explicitly build it:
.PP
.Vb 1
\&  $parser\->parse;
.Ve
.PP
This is not necessary, though, because the following methods will
invoke \fBparse()\fR if the tree has not been made yet.
.SS "Setting and Parsing Together"
.IX Subsection "Setting and Parsing Together"
You can also use \fBparse()\fR instead of \fBregex()\fR to set the regex and create
the tree in one step:
.PP
.Vb 1
\&  my $ok = $parser\->parse($new_regex);
.Ve
.PP
Again, \f(CW$ok\fR will be false if a fatal error was raised in the inital scan
of the regex.
.SS "Getting the Tree"
.IX Subsection "Getting the Tree"
You can access the root of the tree with the \fBroot()\fR method:
.PP
.Vb 1
\&  my $root = $parser\->root;
.Ve
.PP
It will be an array reference of objects.
.SS "Getting the \s-1OPEN\s0 Count"
.IX Subsection "Getting the OPEN Count"
You can access the number capture groups with the \fBnparen()\fR method:
.PP
.Vb 1
\&  my $captgroups = $parser\->nparen;
.Ve
.SS "Getting All Captures"
.IX Subsection "Getting All Captures"
You can access all the capture groups with the \fBcaptures()\fR method:
.PP
.Vb 1
\&  my $all_captures = $parser\->captures();
.Ve
.PP
If you want to access a specific capture group, pass its numerical
value:
.PP
.Vb 1
\&  my $capture_2 = $parser\->captures(2);
.Ve
.SS "Walking the Tree"
.IX Subsection "Walking the Tree"
To walk over the created tree, create an iterator with \fBwalker()\fR:
.PP
.Vb 1
\&  my $iter = $parser\->walker;
.Ve
.PP
This will produce an iterator that will traverse the entire parse tree,
to any depth.  To restrict the depth to which it reaches, pass \fBwalker()\fR
an argument:
.PP
.Vb 3
\&  my $iter = $parser\->walker(0);  # top\-level
\&  my $iter = $parser\->walker(1);  # top\- and second\-level
\&  my $iter = $parser\->walker(2);  # top\- through third\-level
.Ve
.PP
The iterator returned is a function reference.  When called in scalar
context, it returns the next node:
.PP
.Vb 3
\&  while (my $node = $iter\->()) {
\&    # $node is a Regexp::Parser::* object
\&  }
.Ve
.PP
In list context, it returns the next node and its depth:
.PP
.Vb 4
\&  while (my ($node, $depth) = $iter\->()) {
\&    # $node is a Regexp::Parser::* object
\&    # $depth = 0, 1, 2...
\&  }
.Ve
.PP
If passed the argument \f(CW\*(C`\-depth\*(C'\fR, it returns the depth to which it will
look:
.PP
.Vb 5
\&  while (my ($node, $depth) = $iter\->()) {
\&    if ($depth == $iter\->(\-depth)) {
\&      # this is as deep as it will look
\&    }
\&  }
.Ve
.PP
If passed any other argument, it will warn that it is ignoring it.
.PP
The iterator will return undef when it has reached the end of the tree;
it will then reset itself, and will start from the beginning the next
time it is called.
.SS "Viewing the Regex"
.IX Subsection "Viewing the Regex"
You can get the regex back from the parser with the \fBvisual()\fR method:
.PP
.Vb 1
\&  my $rx = $parser\->visual;
.Ve
.PP
This will not return a \fIRegexp\fR object, but the regex; it might be
slightly different from the regex you passed it, but it will not operate
differently.
.PP
The string representation is built by calling the \fBvisual()\fR method of
each node in the tree.
.SS "Using the Regex"
.IX Subsection "Using the Regex"
You can use the \fBqr()\fR method to get back a \fIRegexp\fR object:
.PP
.Vb 1
\&  my $real_rx = $parser\->qr;
.Ve
.PP
The regex is formed by calling the \fBqr()\fR method of each node in the tree,
which may be different from the \fBvisual()\fR method; specifically, in the case
of a sub-class that adds a handler, the \fBqr()\fR method is used to produce
the Perl regex implementation of the new node.
.SS "Named Character Support"
.IX Subsection "Named Character Support"
Perl's regex engine doesn't see \eN{\s-1NAME\s0} escapes \*(-- they get interpolated
by Perl first.  In fact, if one slipped through:
.PP
.Vb 2
\&  my $rx = \*(Aq\eN{LATIN CAPITAL LETTER R}\*(Aq;
\&  my $qr = qr/$rx/;
.Ve
.PP
Perl's regex interprets the '\eN' as a needlessly backslashed 'N'.  My
module parses them and handles them properly.  The \fBnchar()\fR method takes
a named character's name, and returns the actual character:
.PP
.Vb 1
\&  my $R = $parser\->nchar("LATIN CAPITAL LETTER R");
.Ve
.PP
This means you must have the \fIcharnames\fR pragma installed, but since
this module requires Perl 5.6 or better, I don't expect that to be a
problem.
.SS "Using the Tree"
.IX Subsection "Using the Tree"
If you want to work with the parse tree independently, use the \fBroot()\fR
method to get it.  From there, you're on your own.  You'll probably
want to make a recursive function that takes an object (or a reference
to an array of them) and does something to them (and their children).
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
.SS "Determining Error"
.IX Subsection "Determining Error"
Use the \fBerrmsg()\fR and \fBerrnum()\fR methods to get the error information.
.PP
To see if an error is a particular one, use the \fBerror_is()\fR method:
.PP
.Vb 3
\&  if ($parser\->error_is($parser\->RPe_BCURLY)) {
\&    # there was a {n,m} quantifier with n > m
\&  }
.Ve
.SS "Standard Warnings and Errors"
.IX Subsection "Standard Warnings and Errors"
Here are the standard warning and error messages.  Their values are all
negative; positive values are left available for extensions.  Please
refer to perldiag for the explanations of the messages.
.PP
These are all constants in the \fIRegexp::Parser\fR package, which means
you can access them as though they were methods.  They return two
values, their numeric value, and a format string for use with \fBsprintf()\fR.
.PP
.Vb 3
\&  # for when you have a zero\-width chunk
\&  # with a boundless quantifier on it
\&  my ($num, $fmt) = $parser\->RPe_NULNUL;
.Ve
.IP "RPe_ZQUANT (\-1)" 4
.IX Item "RPe_ZQUANT (-1)"
Quantifier unexpected on zero-length expression
.IP "RPe_NOTIMP (\-2)" 4
.IX Item "RPe_NOTIMP (-2)"
Sequence (?%.*s...) not implemented
.IP "RPe_NOTERM (\-3)" 4
.IX Item "RPe_NOTERM (-3)"
Sequence (?#... not terminated
.IP "RPe_LOGDEP (\-4)" 4
.IX Item "RPe_LOGDEP (-4)"
(?p{}) is deprecated \*(-- use (??{})
.IP "RPe_NOTBAL (\-5)" 4
.IX Item "RPe_NOTBAL (-5)"
Sequence (?{...}) not terminated or not {}\-balanced
.IP "RPe_SWNREC (\-6)" 4
.IX Item "RPe_SWNREC (-6)"
Switch condition not recognized
.IP "RPe_SWBRAN (\-7)" 4
.IX Item "RPe_SWBRAN (-7)"
Switch (?(condition)... contains too many branches
.IP "RPe_SWUNKN (\-8)" 4
.IX Item "RPe_SWUNKN (-8)"
Unknown switch condition (?(%.2s
.IP "RPe_SEQINC (\-9)" 4
.IX Item "RPe_SEQINC (-9)"
Sequence (? incomplete
.IP "RPe_UQUANT (\-10)" 4
.IX Item "RPe_UQUANT (-10)"
Useless (%s%s) \*(-- \f(CW%suse\fR /%s modifier
.IP "RPe_NOTREC (\-11)" 4
.IX Item "RPe_NOTREC (-11)"
Sequence (?%.*s...) not recognized
.IP "RPe_LPAREN (\-12)" 4
.IX Item "RPe_LPAREN (-12)"
Unmatched (
.IP "RPe_RPAREN (\-13)" 4
.IX Item "RPe_RPAREN (-13)"
Unmatched )
.IP "RPe_BCURLY (\-14)" 4
.IX Item "RPe_BCURLY (-14)"
Can't do {n,m} with n > m
.IP "RPe_NULNUL (\-15)" 4
.IX Item "RPe_NULNUL (-15)"
\&\f(CW%s\fR matches null string many times
.IP "RPe_NESTED (\-16)" 4
.IX Item "RPe_NESTED (-16)"
Nested quantifiers
.IP "RPe_LBRACK (\-17)" 4
.IX Item "RPe_LBRACK (-17)"
Unmatched [
.IP "RPe_EQUANT (\-18)" 4
.IX Item "RPe_EQUANT (-18)"
Quantifier follows nothing
.IP "RPe_BRACES (\-19)" 4
.IX Item "RPe_BRACES (-19)"
Missing braces on \e%s{}
.IP "RPe_RBRACE (\-20)" 4
.IX Item "RPe_RBRACE (-20)"
Missing right brace on \e%s{}
.IP "RPe_BGROUP (\-21)" 4
.IX Item "RPe_BGROUP (-21)"
Reference to nonexistent group
.IP "RPe_ESLASH (\-22)" 4
.IX Item "RPe_ESLASH (-22)"
Trailing \e
.IP "RPe_BADESC (\-23)" 4
.IX Item "RPe_BADESC (-23)"
Unrecognized escape \f(CW%s\fR%s passed through
.IP "RPe_BADPOS (\-24)" 4
.IX Item "RPe_BADPOS (-24)"
\&\s-1POSIX\s0 class [:%s:] unknown
.IP "RPe_OUTPOS (\-25)" 4
.IX Item "RPe_OUTPOS (-25)"
\&\s-1POSIX\s0 syntax [%s \f(CW%s\fR] belongs inside character classes
.IP "RPe_EMPTYB (\-26)" 4
.IX Item "RPe_EMPTYB (-26)"
Empty \e%s{}
.IP "RPe_FRANGE (\-27)" 4
.IX Item "RPe_FRANGE (-27)"
False [] range \*(L"%s\-%s\*(R"
.IP "RPe_IRANGE (\-28)" 4
.IX Item "RPe_IRANGE (-28)"
Invalid [] range \*(L"%s\-%s\*(R"
.SH "EXTENSIONS"
.IX Header "EXTENSIONS"
Here are some ideas for extensions (sub-classes) for this module.  Some
of them may be absorbed into the core functionality of \fIRegexp::Parser\fR
in the future.  Module names are merely the author's suggestions.
.IP "Regexp::WordBounds" 4
.IX Item "Regexp::WordBounds"
Adds handlers for \f(CW\*(C`<\*(C'\fR and \f(CW\*(C`>\*(C'\fR anchors, which match at the
beginning and end of a \*(L"word\*(R", respectively.  \f(CW\*(C`/</\*(C'\fR is equivalent to
\&\f(CW\*(C`/(?!\ew)(?=\ew)/\*(C'\fR, and \f(CW\*(C`/>/\*(C'\fR is equivalent to \f(CW\*(C`/(?<=\ew)(?!\ew)/\*(C'\fR. (So
that's the object's \fBqr()\fR method for you right there!)
.IP "Regexp::MinLength" 4
.IX Item "Regexp::MinLength"
Implements a \fBmin_length()\fR method for all objects that determines the
minimum length of a string that would be matched by the regex; provides
a front-end method for the parser.
.IP "Regexp::QuantAttr" 4
.IX Item "Regexp::QuantAttr"
Removes quantifiers as objects, and makes 'min' and 'max' attributes of
other objects themselves.
.IP "Regexp::Explain (pending, Jeff Pinyan)" 4
.IX Item "Regexp::Explain (pending, Jeff Pinyan)"
Produces a human-readable explanation of the execution of a regex.  Will
be able to produce \s-1HTML\s0 output that color-codes the elements of the regex
according to a style-sheet (syntax highlighting).
.IP "Regexp::Reverse (difficulty rating: ****)" 4
.IX Item "Regexp::Reverse (difficulty rating: ****)"
Reverses a regex so it matches backwards.  Ex.: \f(CW\*(C`/\es+$/\*(C'\fR becomes
\&\f(CW\*(C`/^\en?\es+/\*(C'\fR, which perhaps gets optimized to \f(CW\*(C`/^\es+/\*(C'\fR.  The difficulty
rating is so high because of cases like \f(CW\*(C`/(\ed+)(\ew+)/\*(C'\fR which, when
reversed, \fIcan\fR match differently.
.Sp
.Vb 2
\&  "100years" =~ /(\ed+)(\ew+)/;  # $1 = 100, $2 = years
\&  "sraey001" =~ /(\ew+)(\ed+)/;  # $1 = sraey00, $2 = 1
.Ve
.Sp
This means character classes should store a hash of what characters
they represent, as well as the macros \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, etc.  Then this
example would be reversed into something like \f(CW\*(C`/(\ew+(?<!\ed))(\ed+)/\*(C'\fR.
The other difficulty is complex regexes with if-then assertions.  I
don't want to think about that.  This module is more of a theoretical
exercise, a jump-start to built-in reversing capability in Perl.
.IP "Regexp::CharClassOps" 4
.IX Item "Regexp::CharClassOps"
Implements character class operations like union, intersection, and
subtraction.
.IP "Regexp::Optimize" 4
.IX Item "Regexp::Optimize"
Eliminates redundancy from a regex.  It should have various options,
such as whether to do optimize...
.Sp
.Vb 2
\&  # strings
\&  /foo|father|fort/  => /f(?:o(?:o|rt)|ather)/
\&
\&  # char classes
\&  /[\ew\ed][a\-zaeiou]/ => /[\ew][a\-z]/
\&
\&  # redundancy
\&  /^\en?\es+/          => /^\es+/
\&  /[\ew]/             => /\ew/
.Ve
.Sp
There are other possibilities as well.
.SH "HISTORY"
.IX Header "HISTORY"
.SS "0.022b \*(-- July 6, 2004"
.IX Subsection "0.022b July 6, 2004"
.IP "Hierarchy Changes" 4
.IX Item "Hierarchy Changes"
There are now abstract classes \fIanchor\fR and \fIassertion\fR. You can't call
their \fBnew()\fR method directly, you can only call it through an object that
inherits from that class.
.Sp
There are no longer \fIstar\fR, \fIplus\fR, and \fIcurly\fR classes; they have been
combined into one class, \fIquantifier\fR.  You pass it the min and max,
and the object's \f(CW\*(C`type\*(C'\fR is determined dynamically.
.IP "Character Class Hashes" 4
.IX Item "Character Class Hashes"
Character classes (\fIanyof\fR objects) now have another attribute, \f(CW\*(C`charmap\*(C'\fR,
which is a hash reference holding character values (eg. 65 for 'A') and
the number of times that character appeared in the character class.  The
character class \f(CW\*(C`[A\-CB\-E]\*(C'\fR would have a character map of \f(CW\*(C`{ 65 => 1, 66
=> 2, 67 => 2, 68 => 1, 69 => 1}\*(C'\fR.  This will reflect ranges and embedded
classes (such as \f(CW\*(C`[:cntrl:]\*(C'\fR or \f(CW\*(C`\ep{Print}\*(C'\fR.
.IP "Character Class Rendering" 4
.IX Item "Character Class Rendering"
The \fBvisual()\fR method of \fIanyof\fR objects will quell the repetition of any
character in the class \fIoutside\fR of embedded classes, so the class
\&\f(CW\*(C`[\ew\ed:4\-65:]\*(C'\fR will render as \f(CW\*(C`[\ew\ed:4\-6]\*(C'\fR.  If you want to prevent
characters and ranges from being display if they are included in an embedded
class, set the \fIanyof\fR object's \f(CW\*(C`strict\*(C'\fR attribute to 1; the character
class would render as \f(CW\*(C`[\ew\ed:]\*(C'\fR.  If you want to go even further and remove
any embedded class that is \fIentirely\fR redundant (that is, \fIevery\fR
character in that embedded class is already found in the class), set the
\&\f(CW\*(C`strict\*(C'\fR attribute to 2; the class above would render as \f(CW\*(C`[\ew:]\*(C'\fR.
.SS "0.021 \*(-- July 3, 2004"
.IX Subsection "0.021 July 3, 2004"
.IP "\fIanyof_class\fR Changed" 4
.IX Item "anyof_class Changed"
If an \fIanyof_class\fR element is a Unicode property or a Perl class (like
\&\f(CW\*(C`\ew\*(C'\fR or \f(CW\*(C`\eS\*(C'\fR), the object's \f(CW\*(C`data\*(C'\fR field points to the underlying
object type (\fIprop\fR, \fIalnum\fR, etc.).  If the element is a \s-1POSIX\s0 class,
the \f(CW\*(C`data\*(C'\fR field is the string \*(L"\s-1POSIX\*(R".\s0  \s-1POSIX\s0 classes don't exist in a
regex outside of a character class, so I'm a little wary of making them
objects in their own right, even if it would create a better sense of
uniformity.
.IP "Documentation" 4
.IX Item "Documentation"
Fixed some poor wording, and documented the problem with using \fI\s-1SUPER::\s0\fR
inside \fIMyClass::_\|_object_\|_\fR.
.IP "Bug Fixes" 4
.IX Item "Bug Fixes"
Character classes weren't closing properly in the tree.  Fixed.
.Sp
Standard escapes (\f(CW\*(C`\ea\*(C'\fR, \f(CW\*(C`\ee\*(C'\fR, etc.) were being returned as \fIexact\fR
nodes instead of \fIanyof_char\fR nodes when inside character classes.  Fixed.
(Mike Lambert)
.Sp
Non-grouping parentheses weren't being parsed properly.  Fixed.  (Mike
Lambert)
.Sp
Flags weren't being turned off.  Fixed.
.SS "0.02 \*(-- July 1, 2004"
.IX Subsection "0.02 July 1, 2004"
.IP "Better Abstracting" 4
.IX Item "Better Abstracting"
The \fBobject()\fR method calls \fBforce_object()\fR.  \fBforce_object()\fR creates an
object no matter what pass the parser is making; \fBobject()\fR will return
immediately if it's just the first pass.  This means that \fBforce_object()\fR
should be used to create stand-alone objects.
.Sp
Each object now has an \fBinsert()\fR method that defines how it gets placed
into the regex tree.  Most objects inherit theirs from the base object
class.
.Sp
The \fBwalker()\fR method is also now abstracted \*(-- each node it comes across
will have its \fBwalk()\fR method called.  And the ending node for stack-type
nodes has been abstracted to the \fBender()\fR method of the node.
.Sp
The \fBinit()\fR method has been moved to another file to help keep \fIthis\fR
file as abstract as possible.  \fIRegexp::Parser\fR installs its handlers
in \fIRegexp/Parser/Handlers.pm\fR.  That file might end up being where
documentation on writing handlers goes.
.Sp
The documentation on sub-classing includes an ordered list of what
packages a method is looked up in for a given object of type '\s-1OBJ\s0':
\&\fIYourMod::OBJ\fR, \fIYourMod::_\|_object_\|_\fR, \fIRegexp::Parser::OBJ\fR,
\&\fIRegexp::Parser::_\|_object_\|_\fR.
.IP "Cleaner Grammar Flow" 4
.IX Item "Cleaner Grammar Flow"
Now the only places 'atom' gets pushed to the queue are after an opening
parenthesis or after 'atom' matches.  This makes things flow more
cleanly.
.IP "Flag Handlers" 4
.IX Item "Flag Handlers"
Flag handlers now receive an additional argument that says whether
they're being turned on or off.  Also, if the flag handler returns 0,
that flag is removed from the resulting object's visual flag set.  That
means \f(CW\*(C`(?gi\-o)\*(C'\fR becomes \f(CW\*(C`(?i)\*(C'\fR.
.IP "Diagnostics and Bug Fixes" 4
.IX Item "Diagnostics and Bug Fixes"
More tests added (specifically, making sure \f(CW\*(C`(?(N)T|F)\*(C'\fR works right).
In doing so, found that the \*(L"too many branches\*(R" error wasn't being raised
until the second pass.  Figured out how to improve the grammar to get
it to work properly.  Also added tests for the new \fBcaptures()\fR method.
.Sp
I changed the field 'class' to 'family' in objects.  I was getting
confused by it, so I figured it was a sign that I'd chosen an awful name
for the field.  There will still be a \fBclass()\fR method in \fI_\|_object_\|_\fR,
but it will throw a \*(L"use of \fBclass()\fR is deprecated\*(R" warning.
.Sp
Quantifiers of the form \f(CW\*(C`{n}\*(C'\fR were being misrepresented as \f(CW\*(C`{n,}\*(C'\fR.
It's been corrected.  (Mike Lambert)
.Sp
\&\f(CW\*(C`\eb\*(C'\fR was being turned into \*(L"b\*(R" inside a character class, instead of
a backspace.  (Mike Lambert)
.Sp
Fixed errant \*(L"Quantifier unexpected\*(R" warning raised by a zero-width
assertion followed by \f(CW\*(C`?\*(C'\fR, which doesn't warrant the warning.
.Sp
Added \*(L"Unrecognized escape\*(R" warnings to \fIall\fR escape sequence handlers.
.Sp
The 'g', 'c', and 'o' flags now evoke \*(L"Useless ...\*(R" warnings when used
in flag and non-capturing group constructs.
.SS "0.01 \*(-- June 29, 2004"
.IX Subsection "0.01 June 29, 2004"
.IP "First Release" 4
.IX Item "First Release"
Documentation not complete, etc.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
Bugs...?
.Sp
I'd like to say this module doesn't have bugs.  I don't know of any in
this current version, because I've tried to fix those I've already
found. Those who find bugs should email me.  Messages should include the
code you ran that contains the bug, and your opinion on what's wrong
with it.
.IP "\(bu" 4
Variable interpolation
.Sp
This module parses \fIregexes\fR, not Perl.  If you send a single-quoted
string as a regex with a variable in it, that '$' will be interpreted as
an anchor. If you want to include variables, use \f(CW\*(C`qr//\*(C'\fR, or mix single\-
and double-quoted strings in building your regex.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeff \f(CW\*(C`japhy\*(C'\fR Pinyan, \fIjaphy@perlmonk.org\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Jeff Pinyan \fIjaphy@perlmonk.org\fR. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
