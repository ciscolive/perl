.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SNMP::Info::CiscoStack 3"
.TH SNMP::Info::CiscoStack 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SNMP::Info::CiscoStack \- SNMP Interface to data from CISCO\-STACK\-MIB
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Baker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& # Let SNMP::Info determine the correct subclass for you.
\& my $ciscostack = new SNMP::Info(
\&                          AutoSpecify => 1,
\&                          Debug       => 1,
\&                          DestHost    => \*(Aqmyswitch\*(Aq,
\&                          Community   => \*(Aqpublic\*(Aq,
\&                          Version     => 2
\&                        )
\&    or die "Can\*(Aqt connect to DestHost.\en";
\&
\& my $class = $ciscostack\->class();
\& print "SNMP::Info determined this device to fall under subclass : $class\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SNMP::Info::CiscoStack is a subclass of SNMP::Info that provides
an interface to the \f(CW\*(C`CISCO\-STACK\-MIB\*(C'\fR.  This \s-1MIB\s0 is used across
the Catalyst family under CatOS and \s-1IOS.\s0
.PP
Use or create in a subclass of SNMP::Info.  Do not use directly.
.SS "Inherited Classes"
.IX Subsection "Inherited Classes"
none.
.SS "Required MIBs"
.IX Subsection "Required MIBs"
.IP "\fICISCO-STACK-MIB\fR" 4
.IX Item "CISCO-STACK-MIB"
.SH "GLOBALS"
.IX Header "GLOBALS"
.PD 0
.ie n .IP "$stack\->\fBbroadcast()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBbroadcast()\fR" 4
.IX Item "$stack->broadcast()"
.PD
(\f(CW\*(C`sysBroadcast\*(C'\fR)
.ie n .IP "$stack\->\fBfan()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBfan()\fR" 4
.IX Item "$stack->fan()"
(\f(CW\*(C`chassisFanStatus\*(C'\fR)
.ie n .IP "$stack\->\fBmodel()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBmodel()\fR" 4
.IX Item "$stack->model()"
(\f(CW\*(C`chassisModel\*(C'\fR)
.ie n .IP "$stack\->\fBnetmask()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBnetmask()\fR" 4
.IX Item "$stack->netmask()"
(\f(CW\*(C`sysNetMask\*(C'\fR)
.ie n .IP "$stack\->\fBps1_type()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBps1_type()\fR" 4
.IX Item "$stack->ps1_type()"
(\f(CW\*(C`chassisPs1Type\*(C'\fR)
.ie n .IP "$stack\->\fBps2_type()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBps2_type()\fR" 4
.IX Item "$stack->ps2_type()"
(\f(CW\*(C`chassisPs2Type\*(C'\fR)
.ie n .IP "$stack\->\fBps1_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBps1_status()\fR" 4
.IX Item "$stack->ps1_status()"
(\f(CW\*(C`chassisPs1Status\*(C'\fR)
.ie n .IP "$stack\->\fBps2_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBps2_status()\fR" 4
.IX Item "$stack->ps2_status()"
(\f(CW\*(C`chassisPs2Status\*(C'\fR)
.ie n .IP "$stack\->\fBserial()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBserial()\fR" 4
.IX Item "$stack->serial()"
(\f(CW\*(C`chassisSerialNumberString\*(C'\fR) or (\f(CW\*(C`chassisSerialNumber\*(C'\fR)
.ie n .IP "$stack\->\fBslots()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBslots()\fR" 4
.IX Item "$stack->slots()"
(\f(CW\*(C`chassisNumSlots\*(C'\fR)
.SH "TABLE METHODS"
.IX Header "TABLE METHODS"
.SS "Interface Tables"
.IX Subsection "Interface Tables"
.ie n .IP "$stack\->\fBi_physical()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBi_physical()\fR" 4
.IX Item "$stack->i_physical()"
Returns a map to \s-1IID\s0 for ports that are physical ports, not vlans, etc.
.ie n .IP "$stack\->\fBi_type()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBi_type()\fR" 4
.IX Item "$stack->i_type()"
Crosses \fBp_port()\fR with \fBp_type()\fR and returns the results.
.Sp
Overrides with \f(CW\*(C`ifType\*(C'\fR if \fBp_type()\fR isn't available.
.ie n .IP "$stack\->\fBi_duplex()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBi_duplex()\fR" 4
.IX Item "$stack->i_duplex()"
Returns reference to hash of iid to current link duplex setting.
.Sp
First checks for fixed gigabit ports which are always full duplex.  Next, if
the port is not operational and reported port duplex (\f(CW\*(C`portDuplex\*(C'\fR) is auto
then the operational duplex can not be determined.  Otherwise it uses the
reported port duplex (\f(CW\*(C`portDuplex\*(C'\fR).
.ie n .IP "$stack\->\fBi_duplex_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBi_duplex_admin()\fR" 4
.IX Item "$stack->i_duplex_admin()"
Returns reference to hash of iid to administrative duplex setting.
.Sp
First checks for fixed gigabit ports which are always full duplex. Next checks
the port administrative speed (\f(CW\*(C`portAdminSpeed\*(C'\fR) which if set to
autonegotiate then the duplex will also autonegotiate, otherwise it uses the
reported port duplex (\f(CW\*(C`portDuplex\*(C'\fR).
.ie n .IP "$stack\->\fBi_speed_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBi_speed_admin()\fR" 4
.IX Item "$stack->i_speed_admin()"
Returns reference to hash of iid to administrative speed setting.
.Sp
\&\f(CW\*(C`portAdminSpeed\*(C'\fR
.ie n .IP "$stack\->set_i_speed_admin(speed, ifIndex)" 4
.el .IP "\f(CW$stack\fR\->set_i_speed_admin(speed, ifIndex)" 4
.IX Item "$stack->set_i_speed_admin(speed, ifIndex)"
.Vb 1
\&    Sets port speed, must be supplied with speed and port C<ifIndex>
\&
\&    Speed choices are \*(Aqauto\*(Aq, \*(Aq10\*(Aq, \*(Aq100\*(Aq, \*(Aq1000\*(Aq
\&
\&    Crosses $stack\->p_port() with $stack\->p_duplex() to
\&    utilize port C<ifIndex>.
\&
\&    Example:
\&    my %if_map = reverse %{$stack\->interfaces()};
\&    $stack\->set_i_speed_admin(\*(Aqauto\*(Aq, $if_map{\*(AqFastEthernet0/1\*(Aq})
\&        or die "Couldn\*(Aqt change port speed. ",$stack\->error(1);
.Ve
.ie n .IP "$stack\->set_i_duplex_admin(duplex, ifIndex)" 4
.el .IP "\f(CW$stack\fR\->set_i_duplex_admin(duplex, ifIndex)" 4
.IX Item "$stack->set_i_duplex_admin(duplex, ifIndex)"
.Vb 1
\&    Sets port duplex, must be supplied with duplex and port C<ifIndex>
\&
\&    Speed choices are \*(Aqauto\*(Aq, \*(Aqhalf\*(Aq, \*(Aqfull\*(Aq
\&
\&    Crosses $stack\->p_port() with $stack\->p_duplex() to
\&    utilize port C<ifIndex>.
\&
\&    Example:
\&    my %if_map = reverse %{$stack\->interfaces()};
\&    $stack\->set_i_duplex_admin(\*(Aqauto\*(Aq, $if_map{\*(AqFastEthernet0/1\*(Aq})
\&        or die "Couldn\*(Aqt change port duplex. ",$stack\->error(1);
.Ve
.SS "Module table"
.IX Subsection "Module table"
This table holds configuration information for each of the blades installed in
the Catalyst device.
.ie n .IP "$stack\->\fBm_type()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_type()\fR" 4
.IX Item "$stack->m_type()"
(\f(CW\*(C`moduleType\*(C'\fR)
.ie n .IP "$stack\->\fBm_model()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_model()\fR" 4
.IX Item "$stack->m_model()"
(\f(CW\*(C`moduleModel\*(C'\fR)
.ie n .IP "$stack\->\fBm_serial()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_serial()\fR" 4
.IX Item "$stack->m_serial()"
(\f(CW\*(C`moduleSerialNumber\*(C'\fR)
.ie n .IP "$stack\->\fBm_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_status()\fR" 4
.IX Item "$stack->m_status()"
(\f(CW\*(C`moduleStatus\*(C'\fR)
.ie n .IP "$stack\->\fBm_name()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_name()\fR" 4
.IX Item "$stack->m_name()"
(\f(CW\*(C`moduleName\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports()\fR" 4
.IX Item "$stack->m_ports()"
(\f(CW\*(C`moduleNumPorts\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_status()\fR" 4
.IX Item "$stack->m_ports_status()"
Returns a list of space separated status strings for the ports.
.Sp
To see the status of port 4 :
.Sp
.Vb 2
\&    @ports_status = split(\*(Aq \*(Aq, $stack\->m_ports_status() );
\&    $port4 = $ports_status[3];
.Ve
.Sp
(\f(CW\*(C`modulePortStatus\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_hwver()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_hwver()\fR" 4
.IX Item "$stack->m_ports_hwver()"
(\f(CW\*(C`moduleHwVersion\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_fwver()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_fwver()\fR" 4
.IX Item "$stack->m_ports_fwver()"
(\f(CW\*(C`moduleFwVersion\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_swver()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_swver()\fR" 4
.IX Item "$stack->m_ports_swver()"
(\f(CW\*(C`moduleSwVersion\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_ip()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_ip()\fR" 4
.IX Item "$stack->m_ports_ip()"
(\f(CW\*(C`moduleIPAddress\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_sub1()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_sub1()\fR" 4
.IX Item "$stack->m_ports_sub1()"
(\f(CW\*(C`moduleSubType\*(C'\fR)
.ie n .IP "$stack\->\fBm_ports_sub2()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ports_sub2()\fR" 4
.IX Item "$stack->m_ports_sub2()"
(\f(CW\*(C`moduleSubType2\*(C'\fR)
.SS "Modules \- Router Blades"
.IX Subsection "Modules - Router Blades"
.ie n .IP "$stack\->\fBm_ip()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_ip()\fR" 4
.IX Item "$stack->m_ip()"
(\f(CW\*(C`moduleIPAddress\*(C'\fR)
.ie n .IP "$stack\->\fBm_sub1()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_sub1()\fR" 4
.IX Item "$stack->m_sub1()"
(\f(CW\*(C`moduleSubType\*(C'\fR)
.ie n .IP "$stack\->\fBm_sub2()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBm_sub2()\fR" 4
.IX Item "$stack->m_sub2()"
(\f(CW\*(C`moduleSubType2\*(C'\fR)
.ie n .SS "Port Entry Table (""CISCO\-STACK\-MIB::portTable"")"
.el .SS "Port Entry Table (\f(CWCISCO\-STACK\-MIB::portTable\fP)"
.IX Subsection "Port Entry Table (CISCO-STACK-MIB::portTable)"
.ie n .IP "$stack\->\fBp_name()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_name()\fR" 4
.IX Item "$stack->p_name()"
(\f(CW\*(C`portName\*(C'\fR)
.ie n .IP "$stack\->\fBp_type()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_type()\fR" 4
.IX Item "$stack->p_type()"
(\f(CW\*(C`portType\*(C'\fR)
.ie n .IP "$stack\->\fBp_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_status()\fR" 4
.IX Item "$stack->p_status()"
(\f(CW\*(C`portOperStatus\*(C'\fR)
.ie n .IP "$stack\->\fBp_status2()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_status2()\fR" 4
.IX Item "$stack->p_status2()"
(\f(CW\*(C`portAdditionalStatus\*(C'\fR)
.ie n .IP "$stack\->\fBp_speed()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_speed()\fR" 4
.IX Item "$stack->p_speed()"
(\f(CW\*(C`portAdminSpeed\*(C'\fR)
.ie n .IP "$stack\->\fBp_duplex()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_duplex()\fR" 4
.IX Item "$stack->p_duplex()"
(\f(CW\*(C`portDuplex\*(C'\fR)
.ie n .IP "$stack\->\fBp_port()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_port()\fR" 4
.IX Item "$stack->p_port()"
(\f(CW\*(C`portIfIndex\*(C'\fR)
.ie n .IP "$stack\->\fBp_rx_flow_control()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_rx_flow_control()\fR" 4
.IX Item "$stack->p_rx_flow_control()"
Can be either \f(CW\*(C`on\*(C'\fR \f(CW\*(C`off\*(C'\fR or \f(CW\*(C`disagree\*(C'\fR
.Sp
\&\*(L"Indicates the receive flow control operational status of the port. If the
port could not agree with the far end on a link protocol, its operational
status will be \fBdisagree\fR\|(3).\*(R"
.Sp
\&\f(CW\*(C`portOperRxFlowControl\*(C'\fR
.ie n .IP "$stack\->\fBp_tx_flow_control()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_tx_flow_control()\fR" 4
.IX Item "$stack->p_tx_flow_control()"
Can be either \f(CW\*(C`on\*(C'\fR \f(CW\*(C`off\*(C'\fR or \f(CW\*(C`disagree\*(C'\fR
.Sp
\&\*(L"Indicates the transmit flow control operational status of the port. If the
port could not agree with the far end on a link protocol, its operational
status will be \fBdisagree\fR\|(3).\*(R"
.Sp
\&\f(CW\*(C`portOperTxFlowControl\*(C'\fR
.ie n .IP "$stack\->\fBp_rx_flow_control_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_rx_flow_control_admin()\fR" 4
.IX Item "$stack->p_rx_flow_control_admin()"
Can be either \f(CW\*(C`on\*(C'\fR \f(CW\*(C`off\*(C'\fR or \f(CW\*(C`desired\*(C'\fR
.Sp
\&\*(L"Indicates the receive flow control administrative status set on the port. If
the status is set to \fBon\fR\|(1), the port will require the far end to send flow
control. If the status is set to \fBoff\fR\|(2), the port will not allow far end to
send flow control.  If the status is set to \fBdesired\fR\|(3), the port will allow
the far end to send the flow control.\*(R"
.Sp
\&\f(CW\*(C`portAdminRxFlowControl\*(C'\fR
.ie n .IP "$stack\->\fBp_tx_flow_control_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_tx_flow_control_admin()\fR" 4
.IX Item "$stack->p_tx_flow_control_admin()"
Can be either \f(CW\*(C`on\*(C'\fR \f(CW\*(C`off\*(C'\fR or \f(CW\*(C`desired\*(C'\fR
.Sp
\&\*(L"Indicates the transmit flow control administrative status set on the port.
If the status is set to \fBon\fR\|(1), the port will send flow control to the far end.  If
the status is set to \fBoff\fR\|(2), the port will not send flow control to the far
end. If the status is set to \fBdesired\fR\|(3), the port will send flow control to
the far end if the far end supports it.\*(R"
.Sp
\&\f(CW\*(C`portAdminTxFlowControl\*(C'\fR
.ie n .SS "Port Capability Table (""CISCO\-STACK\-MIB::portCpbTable"")"
.el .SS "Port Capability Table (\f(CWCISCO\-STACK\-MIB::portCpbTable\fP)"
.IX Subsection "Port Capability Table (CISCO-STACK-MIB::portCpbTable)"
.ie n .IP "$stack\->\fBp_speed_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_speed_admin()\fR" 4
.IX Item "$stack->p_speed_admin()"
(\f(CW\*(C`portCpbSpeed\*(C'\fR)
.ie n .IP "$stack\->\fBp_duplex_admin()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBp_duplex_admin()\fR" 4
.IX Item "$stack->p_duplex_admin()"
(\f(CW\*(C`portCpbDuplex\*(C'\fR)
.SH "Data Munging Callback Subroutines"
.IX Header "Data Munging Callback Subroutines"
.ie n .IP "$stack\->\fBmunge_port_status()\fR" 4
.el .IP "\f(CW$stack\fR\->\fBmunge_port_status()\fR" 4
.IX Item "$stack->munge_port_status()"
Munges binary byte describing each port into ascii, and returns an ascii
list separated by spaces.
