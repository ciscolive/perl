.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::ANSI::Fold 3"
.TH Text::ANSI::Fold 3 "2020-11-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::ANSI::Fold \- Text folding library supporting ANSI terminal sequence and Asian wide characters with prohibition character handling.
.SH "VERSION"
.IX Header "VERSION"
Version 2.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Text::ANSI::Fold qw(ansi_fold);
\&    ($folded, $remain) = ansi_fold($text, $width, [ option ]);
\&
\&    use Text::ANSI::Fold;
\&    my $f = Text::ANSI::Fold\->new(width => 80, boundary => \*(Aqword\*(Aq);
\&    $f\->configure(ambiguous => \*(Aqwide\*(Aq);
\&    ($folded, $remain) = $f\->fold($text);
\&
\&    use Text::ANSI::Fold;
\&    while (<>) {
\&        print join "\en",
\&            Text::ANSI::Fold\->new(width => 40, text => $_)\->chops;
\&    }
\&
\&    use Text::ANSI::Fold qw(:constants);
\&    my $fold = Text::ANSI::Fold\->new(
\&        width     => 70,
\&        boundary  => \*(Aqword\*(Aq,
\&        linebreak => LINEBREAK_ALL,
\&        runin     => 4,
\&        runout    => 4,
\&        );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::ANSI::Fold provides capability to fold a text into two strings
by given width.  Text can include \s-1ANSI\s0 terminal sequences.  If the
text is divided in the middle of ANSI-effect region, reset sequence is
appended to folded text, and recover sequence is prepended to trimmed
string.
.PP
This module also support Unicode Asian full-width and non-spacing
combining characters properly.  Japanese text formatting with
head-or-end of line prohibition character is also supported.  Set
the linebreak mode to enable it.
.PP
Use exported \fBansi_fold\fR function to fold original text, with number
of visual columns you want to cut off the text.
.PP
.Vb 1
\&    ($folded, $remain, $w) = ansi_fold($text, $width);
.Ve
.PP
It returns a pair of strings; first one is folded text, and second is
the rest.
.PP
Additional third result is the visual width of folded text.  You may
want to know how many columns returned string takes for further
processing.  If the width parameter is negative, it returns string
untouched and the visual width of it.
.PP
This function returns at least one character in any situation.  If you
provide Asian wide string and just one column as width, it trims off
the first wide character even if it does not fit to given width.
.PP
Default parameter can be set by \fBconfigure\fR class method:
.PP
.Vb 1
\&    Text::ANSI::Fold\->configure(width => 80, padding => 1);
.Ve
.PP
Then you don't have to pass second argument.
.PP
.Vb 1
\&    ($folded, $remain) = ansi_fold($text);
.Ve
.PP
Because second argument is always taken as width, use \fIundef\fR when
using default width with additional parameter:
.PP
.Vb 1
\&    ($folded, $remain) = ansi_fold($text, undef, padding => 1);
.Ve
.SH "OBJECT INTERFACE"
.IX Header "OBJECT INTERFACE"
You can create an object to hold parameters, which is effective during
object life time.  For example,
.PP
.Vb 4
\&    my $f = Text::ANSI::Fold\->new(
\&        width => 80,
\&        boundary => \*(Aqword\*(Aq,
\&        );
.Ve
.PP
makes an object folding on word boundaries with 80 columns width.
Then you can use this without parameters.
.PP
.Vb 1
\&    $f\->fold($text);
.Ve
.PP
Use \fBconfigure\fR method to update parameters:
.PP
.Vb 1
\&    $f\->configure(padding => 1);
.Ve
.PP
Additional parameter can be specified on each call, and they precede
saved value.
.PP
.Vb 1
\&    $f\->fold($text, width => 40);
.Ve
.SH "STRING OBJECT INTERFACE"
.IX Header "STRING OBJECT INTERFACE"
Fold object can hold string inside by \fBtext\fR method.
.PP
.Vb 1
\&    $f\->text("text");
.Ve
.PP
And folded string can be taken by \fBretrieve\fR method.  It returns
empty string if nothing remained.
.PP
.Vb 4
\&    while ((my $folded = $f\->retrieve) ne \*(Aq\*(Aq) {
\&        print $folded;
\&        print "\en" if $folded !~ /\en\ez/;
\&    }
.Ve
.PP
Method \fBchops\fR returns chopped string list.  Because \fBtext\fR method
returns the object itself, you can use \fBtext\fR and \fBchops\fR like this:
.PP
.Vb 1
\&    print join "\en", $f\->text($text)\->chops;
.Ve
.PP
Actually, text can be set by \fBnew\fR or \fBconfigure\fR method through
\&\fBtext\fR option.  Next program just works.
.PP
.Vb 5
\&    use Text::ANSI::Fold;
\&    while (<>) {
\&        print join "\en",
\&            Text::ANSI::Fold\->new(width => 40, text => $_)\->chops;
\&    }
.Ve
.PP
When using \fBchops\fR method, \fBwidth\fR parameter can take array
reference, and chops text into given width list.
.PP
.Vb 3
\&    my $fold = Text::ANSI::Fold\->new;
\&    my @list = $fold\->text("1223334444")\->chops(width => [ 1, 2, 3 ]);
\&    # return ("1", "22", "333") and keep "4444"
.Ve
.PP
If the width value is 0, it returns empty string.
.PP
Negative width value takes all the rest of holded string in
\&\fBretrieve\fR and \fBchops\fR method.
.SH "OPTIONS"
.IX Header "OPTIONS"
Option parameter can be specified as name-value list for \fBansi_fold\fR
function as well as \fBnew\fR and \fBconfigure\fR method.
.PP
.Vb 1
\&    ansi_fold($text, $width, boundary => \*(Aqword\*(Aq, ...);
\&
\&    Text::ANSI::Fold\->configure(boundary => \*(Aqword\*(Aq);
\&
\&    my $f = Text::ANSI::Fold\->new(boundary => \*(Aqword\*(Aq);
\&
\&    $f\->configure(boundary => \*(Aqword\*(Aq);
.Ve
.IP "\fBwidth\fR => \fIn\fR, \fI[ n, m, ... ]\fR" 7
.IX Item "width => n, [ n, m, ... ]"
Specify folding width.  Negative value means all the rest.
.Sp
Array reference can be specified but works only with \fBchops\fR method,
and retunrs empty string for zero width.
.ie n .IP "\fBboundary\fR => ""word""" 7
.el .IP "\fBboundary\fR => ``word''" 7
.IX Item "boundary => word"
\&\fBboundary\fR option currently takes only \*(L"word\*(R" as a valid value.  In
this case, text is folded on word boundary.  This occurs only when
enough space will be provided to hold the word on next call with same
width.
.IP "\fBpadding\fR => \fIbool\fR" 7
.IX Item "padding => bool"
If \fBpadding\fR option is given with true value, margin space is filled
up with space character.  Next code fills spaces if the given text is
shorter than 80.
.Sp
.Vb 1
\&    ansi_fold($text, 80, padding => 1);
.Ve
.IP "\fBpadchar\fR => \fIchar\fR" 7
.IX Item "padchar => char"
\&\fBpadchar\fR option specifies character used to fill up the remainder of
given width.
.Sp
.Vb 1
\&    ansi_fold($text, 80, padding => 1, padchar => \*(Aq_\*(Aq);
.Ve
.ie n .IP "\fBambiguous\fR => ""narrow"" or ""wide""" 7
.el .IP "\fBambiguous\fR => ``narrow'' or ``wide''" 7
.IX Item "ambiguous => narrow or wide"
Tells how to treat Unicode East Asian ambiguous characters.  Default
is \*(L"narrow\*(R" which means single column.  Set \*(L"wide\*(R" to tell the module
to treat them as wide character.
.IP "\fBlinebreak\fR => \fImode\fR" 7
.IX Item "linebreak => mode"
.PD 0
.IP "\fBrunin\fR => \fIwidth\fR" 7
.IX Item "runin => width"
.IP "\fBrunout\fR => \fIwidth\fR" 7
.IX Item "runout => width"
.PD
These options specify the behavior of line break handling for Asian
multi byte characters.  Only Japanese is supported currently.
.Sp
If the cut-off text start with space or prohibited characters
(e.g. closing parenthesis), they are ran-in at the end of current line
as much as possible.
.Sp
If the trimmed text end with prohibited characters (e.g. opening
parenthesis), they are ran-out to the head of next line, if it fits to
maximum width.
.Sp
Default \fBlinebreak\fR mode is \fB\s-1LINEBREAK_NONE\s0\fR and can be set one of
those:
.Sp
.Vb 4
\&    LINEBREAK_NONE
\&    LINEBREAK_RUNIN
\&    LINEBREAK_RUNOUT
\&    LINEBREAK_ALL
.Ve
.Sp
Import-tag \fB:constants\fR can be used to access these constants.
.Sp
Option \fBrunin\fR and \fBrunout\fR is used to set maximum width of moving
characters.  Default values are both 2.
.IP "\fBexpand\fR => \fIbool\fR" 7
.IX Item "expand => bool"
.PD 0
.IP "\fBtabstop\fR => \fIn\fR" 7
.IX Item "tabstop => n"
.PD
Enable tab character expansion.  Default tabstop is 8 and can be set
by \fBtabstop\fR option.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Next code implements almost perfect fold command for multi byte
characters with prohibited character handling.
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&    
\&    use strict;
\&    use warnings;
\&    use open IO => \*(Aqutf8\*(Aq, \*(Aq:std\*(Aq;
\&    
\&    use Text::ANSI::Fold qw(:constants);
\&    my $fold = Text::ANSI::Fold\->new(
\&        width     => 70,
\&        boundary  => \*(Aqword\*(Aq,
\&        linebreak => LINEBREAK_ALL,
\&        runin     => 4,
\&        runout    => 4,
\&        );
\&    
\&    $, = "\en";
\&    while (<>) {
\&        print $fold\->text($_)\->chops;
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "App::ansifold" 7
.IX Item "App::ansifold"
Command line utility using Text::ANSI::Fold.
.IP "Text::ANSI::Fold::Util" 7
.IX Item "Text::ANSI::Fold::Util"
Collection of utilities using Text::ANSI::Fold module.
.IP "App::sdif" 7
.IX Item "App::sdif"
Text::ANSI::Fold was originally implemented in \fBsdif\fR command for
long time, which provide side-by-side view for diff output.  It is
necessary to process output from \fBcdif\fR command which highlight diff
output using \s-1ANSI\s0 escape sequences.
.IP "Text::ANSI::Util, Text::ANSI::WideUtil" 7
.IX Item "Text::ANSI::Util, Text::ANSI::WideUtil"
These modules provide a rich set of functions to handle string
contains \s-1ANSI\s0 color terminal sequences.  In contrast,
Text::ANSI::Fold provides simple folding mechanism with minimum
overhead.  Also \fBsdif\fR need to process other than \s-1SGR\s0 (Select Graphic
Rendition) color sequence, and non-spacing combining characters, those
are not supported by these modules.
.IP "<https://en.wikipedia.org/wiki/ANSI_escape_code>" 7
.IX Item "<https://en.wikipedia.org/wiki/ANSI_escape_code>"
\&\s-1ANSI\s0 escape code definition.
.IP "<https://www.w3.org/TR/2012/NOTE\-jlreq\-20120403/>" 7
.IX Item "<https://www.w3.org/TR/2012/NOTE-jlreq-20120403/>"
Requirements for Japanese Text Layout,
W3C Working Group Note 3 April 2012
.IP "<http://www.ecma\-international.org/publications/files/ECMA\-ST/Ecma\-048.pdf>" 7
.IX Item "<http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf>"
Control Functions for Coded Character Sets
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2018\- Kazumasa Utashiro.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Kazumasa Utashiro" 4
.IX Item "Kazumasa Utashiro"
.PD 0
.IP "<https://github.com/kaz\-utashiro/Text\-ANSI\-Fold>" 4
.IX Item "<https://github.com/kaz-utashiro/Text-ANSI-Fold>"
