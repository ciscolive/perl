.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::NAIF::Progress 3"
.TH Marpa::R2::NAIF::Progress 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::NAIF::Progress \- Progress reports for the NAIF
.SH "About this document"
.IX Header "About this document"
This document describes
Marpa's progress reports for its named argument interface (\s-1NAIF\s0).
If you are a beginner,
or are not sure which interface you are interested in,
or do not know what the \s-1NAIF\s0 interfaces is,
you probably are looking for
the document on progress reports for the \s-1SLIF\s0
interface.
.PP
Progress reports allow an application to know
exactly where it is in the parse at any
point.
For parse locations of the user's choosing,
progress reports list all the rules in play,
and indicate the location at which the rule started,
and how far into the rule parsing has progressed.
.PP
For those new to parsing, this \*(L"situational awareness\*(R"
might seem to be a feature that they can expect
from any servicable parser.
In fact,
situation awareness in most parsers is extremely limited,
and it tends to be more limited in those
parsers considered production quality.
Marpa is not just unusual in the amount of feedback
it offers the application,
it breaks new ground.
.PP
Progress reports are extremely useful in
debugging grammars.
Because debugging creates a
clear \*(L"narrative\*(R",
the detailed example in
this document is a debugging situation.
Readers specifically interested in debugging
a grammar
should read the document
on tracing
problems before
reading this document.
.SH "Introduction to Earley parsing"
.IX Header "Introduction to Earley parsing"
To read the
\&\f(CW\*(C`show_progress\*(C'\fR
output, it is important to have a
basic idea of what
Earley items are,
and of what the information in them means.
Everything that the user needs to know
is explained in this section.
.SS "Dotted rules"
.IX Subsection "Dotted rules"
The idea behind Earley's algorithm is that you can
parse by building a table of rules
and where you are in those rules.
\&\*(L"Where\*(R" means two things: location in the rule relative to the rule's
symbols,
and location relative to the parse's input stream.
.PP
Let's look at an example of a rule in a context-free grammar.
Here's the rule for assignment from the Perl distribution's \f(CW\*(C`perly.y\*(C'\fR
.PP
\&\f(CW\*(C`\ \ \ \ termbinop\ \->\ term\ ASSIGNOP\ term\*(C'\fR
.PP
\&\f(CW\*(C`ASSIGNOP\*(C'\fR is \f(CW\*(C`perly.y\*(C'\fR's internal name for
the assignment operator.
In plain Perl terms, this is the "\f(CW\*(C`=\*(C'\fR" character.
.PP
In parsing this rule, we can be at any of four possible locations.
One location is at the beginning, before all of the symbols.
The other three locations are immediately after each of the rule's
three symbols.
.PP
Within a rule, position relative to the symbols of the rule
is traditionally indicated with a dot.  In fact, the symbol-relative
rule position is very often called the \fBdot location\fR.  Taken as
a pair, a rule and a dot location are called a \fBdotted rule\fR.
.PP
Here's our rule with a dot location indicated:
.PP
\&\f(CW\*(C`\ \ \ \ termbinop\ \->\ X\ term\ ASSIGNOP\ term\*(C'\fR
.PP
The dot location in this dotted rule is at the beginning.
A dot location at the beginning of a dotted rule means
that we have not recognized any symbols in the rule yet.
All we are doing is predicting that the rule will occur.
A dotted rule with the dot before all of its symbols is called a \fBprediction\fR
or a \fBpredicted rule\fR.
.PP
Here's another dotted rule:
.PP
\&\f(CW\*(C`\ \ \ \ termbinop\ \->\ term\ X\ ASSIGNOP\ term\*(C'\fR
.PP
In this dotted rule,
we are saying we have seen a \f(CW\*(C`term\*(C'\fR, but have not yet recognized
an \f(CW\*(C`ASSIGNOP\*(C'\fR.
.PP
There's another special kind of dotted rule, a completion.
A \fBcompletion\fR (also called a \fBcompleted rule\fR)
is a dotted rule with the dot after all of the symbols.
Here is the completion for the rule that we have been using as an example:
.PP
\&\f(CW\*(C`\ \ \ \ termbinop\ \->\ term\ ASSIGNOP\ term\ X\*(C'\fR
.PP
A completion indicates that a rule has been fully recognized.
.SS "Earley items"
.IX Subsection "Earley items"
The dotted rules contain
all but one piece of the information
that Earley's algorithm
needs to track.
The missing piece is the second of the two \*(L"wheres\*(R": where in the input stream.
To associate input stream location and dotted rules, Earley's algorithm uses what are now called Earley items.
.PP
A convenient way to think of an \fBEarley item\fR is as a triple, or 3\-tuple,
consisting of dotted rule, origin and current location.
The \fBorigin\fR is the location in the input stream where the dotted rule starts.
The \fBcurrent location\fR (also called the \fBdot location\fR)
is the location in the input stream which corresponds to the
dot position.
.PP
Two noteworthy consequences
follow from the way in which origin and current location are defined.
First,
if a dotted rule is a prediction,
then origin and current location will always be the same.
Second,
the input stream location where a rule ends is not tracked unless the
dotted rule is a completion.
In other cases,
an Earley item does not tell us
if a rule will
ever be completed,
much less at which location.
.SH "The example"
.IX Header "The example"
For this example of debugging,
I've taken a very common example
of a grammar
and deliberately introduced a problem.
(All the code and the full trace outputs
for this example are in the Appendix.)
I've commented out the correct start rule:
.PP
.Vb 1
\&        ## { lhs => \*(AqExpression\*(Aq, rhs => [qw/Term/] },
.Ve
.PP
and replaced it with another start rule,
one which will cause problems:
.PP
.Vb 1
\&        { lhs => \*(AqExpression\*(Aq, rhs => [qw/Factor/] },
.Ve
.PP
In what follows, we'll pretend we don't already know
where the problem is,
and use the Marpa diagnostics and tracing facilities
to \*(L"discover\*(R" it.
.SH "First warning"
.IX Header "First warning"
Right off the bat, we get two warning messages:
.PP
.Vb 2
\&    Inaccessible symbol: Add
\&    Inaccessible symbol: Term
.Ve
.PP
If we were alert, these would be enough to tell us there is
a serious problem.
\&\*(L"Inaccessible\*(R" symbols are symbols which cannot be reached
from the start symbol.
This means that the grammar will never produce them,
and that parses will never find them in the input.
.PP
Since \f(CW\*(C`Add\*(C'\fR and \f(CW\*(C`Term\*(C'\fR are both important symbols
in our application,
that should tell us our grammar has a serious problem.
In fact,
these warning messages would often be enough
to point us to the error.
But, in order to look at more of Marpa's
tracing facilities, let's pretend we have not
had our morning coffee,
and that we miss the significance of these warning messages.
.SH "Output from \fBtrace_terminals()\fP"
.IX Header "Output from trace_terminals()"
Before looking at Marpa's progress reports,
it is usually best to orient yourself by looking
at the output from
\&\f(CW\*(C`trace_terminals\*(C'\fR.
Typically, you will be interested in the last tokens
to be accepted, and perhaps also
in the tokens the recognizer was
looking for when it didn't find what it wanted.
Sometimes that information alone is enough to make it clear
where the problem is.
.PP
The full
\&\f(CW\*(C`trace_terminals\*(C'\fR
output for this example is in the Appendix.
We see that the recognizer seems to accept "\f(CW\*(C`42*1\*(C'\fR\*(L" but it fails
when it confronts the plus sign (\*(R"\f(CW\*(C`+\*(C'\fR").
The last two lines are:
.PP
.Vb 2
\&    Accepted "Number" at 2\-3
\&    Expecting "Multiply" at 3
.Ve
.PP
A note in passing: Marpa shows the location of the tokens it accepts
as a range of locations.  For \f(CW\*(C`Number\*(C'\fR, the range is "\f(CW\*(C`2\-3\*(C'\fR", indicating that
the token starts at location 2 and ends at location 3.
In its default input model, all tokens have length 1,
so this is clearly information overkill.
But Marpa allows other input models, and in those models the information
about start and end location of the token is important.
.PP
Returning to the problem at hand:
We notice that at location 3 we are expecting a \f(CW\*(C`Multiply\*(C'\fR operator,
but not an \f(CW\*(C`Add\*(C'\fR operator.
That should strike us as strange,
and send us back to the grammar.
But for the sake of our example we will
assume that we are slow on the uptake today,
and that this does not clue us in.
We move on.
.SH "Output from \fBshow_progress()\fP"
.IX Header "Output from show_progress()"
Marpa's most powerful tool for debugging
grammars is its progress report, which
shows the
Earley items being worked on.
In the Appendix, progress reports for the entire parse are shown.
Our example in this document is a very small one,
so that producing progress reports for the entire parse is
a reasonable thing to do in this case.
If a parse is at all large, you will usually need to be selective.
.PP
The progress report that is usually of most interest is
the one for the Earley set
that you were working on when the error occurred.
This is called the \fBcurrent location\fR.
In our example the current location is location 3.
By default,
\&\f(CW\*(C`show_progress\*(C'\fR
prints out only the progress reports for the current location.
.PP
Here are the progress reports for the current location,
location 3,
from our example.
.PP
.Vb 4
\&      F0 @0\-3 Expression \-> Factor .
\&      F2 @2\-3 Factor \-> Number .
\&      R4:1 x2 @0,2\-3 Factor \-> Factor . Multiply Factor
\&      F4 @0\-3 Factor \-> Factor Multiply Factor .
.Ve
.SS "Progress report lines"
.IX Subsection "Progress report lines"
The last field of
each Progress Report line shows,
in fully expanded form,
the dotted rule we were working on.
Since that is the most important information,
it may be tempting to skip the rest of this section,
and move directly forward with the debugging.
.PP
In fact, you might want to do exactly that \*(--
skip to the beginning of the next section.
What follows talks about the details of the format of the
first few fields in each progress report line.
These first few fields, while helpful,
are also usually one or more of obvious in their meaning,
not relevant to our example,
and repetitive of information which can
be deduced from other fields.
.PP
.Vb 1
\&      F0 @0\-3 Expression \-> Factor .
.Ve
.PP
Prefixed to the dotted rule are two fields: "\f(CW\*(C`F0 @0\-3\*(C'\fR\*(L".
The \*(R"\f(CW\*(C`F0\*(C'\fR" says that this is a completed or \fBfinal\fR rule,
and that it is rule number 0.
The rule number is used in
other tracing and debugging output,
when displaying the whole rule would take too much space.
In what follows we won't need the rule number.
.PP
The "\f(CW\*(C`@0\-3\*(C'\fR\*(L" describes the location of the dotted rule in
the parse.  In its simplest form, the location field is two
location numbers, separated by a hyphen.
The first location number is the origin, the place where Marpa
first started recognizing the rule.
The last location number is the dot location, the location location
of the dot in a dotted rule.
\&\*(R"\f(CW\*(C`@0\-3\*(C'\fR" say that this rule began at location 0, and that the
dot is at location 3.
.PP
The current location is location 3, and this is no coincidence.
Whenever we are displaying the progress report for an location,
all the progress report lines will have their dot location at
that location.
.PP
As an aside, notice that
the left hand side symbol is \f(CW\*(C`Expression\*(C'\fR.
That is the start symbol.
The presence of a completed start rule in our
progress report indicates that if our input ended at location 3, it would be a valid sentence
in the language of our grammar.
.PP
Let's look at another progress report line:
.PP
.Vb 1
\&      R4:1 x2 @0,2\-3 Factor \-> Factor . Multiply Factor
.Ve
.PP
Here the "\f(CW\*(C`R4:1\*(C'\fR\*(L" indicates that this is rule number 4
(the \*(R"\f(CW\*(C`R\*(C'\fR" stands for rule number) and that its dot
position is after the first symbol on the right hand side.
Symbol positions are numbered using the
ordinal of the symbol just before the position.
Symbols are numbered starting with 1, and
symbol position 1 is the position immediately after
symbol 1.
.PP
The next field ("\f(CW\*(C`x2\*(C'\fR\*(L") is new.
It is a count.
A progress report can contain multiple instances
of the same dotted rule, and when there is more
than one, a count field is included in
the progress report line.
Here the \*(R"\f(CW\*(C`x2\*(C'\fR" indicates that there are two
instances of \f(CW\*(C`Factor \-> Factor . Multiply Factor\*(C'\fR at
this location.
.PP
Multiple instances of a dotted rule
will differ in their origin,
and where they do, this is shown in
the location field of the
progress report line.
Here the location field is "\f(CW\*(C`@0,2\-3\*(C'\fR",
which indicates that one instance of this dotted rule has
its origin at location 0, and the other has its origin
at location 2.
All instances reported on a single progress report line
will always have the same dot location, and in this case
it is location 3.
.PP
Predicted rules also appear in progress reports:
.PP
.Vb 1
\&    P2 @2\-2 Factor \-> . Number
.Ve
.PP
Here the "\f(CW\*(C`P\*(C'\fR\*(L" in the summary field means \*(R"predicted".
As with much of the information in the summary field,
this only repeats what is obvious from the full expansion
of the dotted rule later in the line.
But final (or completed) and predicted rules can be important
and the initial \f(CW"F"\fR and \f(CW"P"\fR make these lines easy to spot.
.PP
Notice that in the predicted rule,
the origin is the same as the dot location.
This will always be the case with predicted rules.
.PP
For any given location,
no predicted rule has more than one instance.
For other dotted rules,
there may be many instances of the dotted
rule at a single location.
In grammars with right recursion,
the number of instances
is limited only by the
length of the recursion.
The length of a recursion is limited primarily by
the available memory.
.PP
When there are many
instances of a dotted rule at a single location,
it is inconvenient to show all the origins in a comma-separated
list.
In that case the origins in the location field are shown as a
range, with the earliest separated from the most recent
by a "\f(CW\*(C`...\*(C'\fR".
The example in this document contains no lines with
a large number of
instances, but here is an example from another grammar.
This is the progress report line for
the completed rule in a right recursion of length 20.
.PP
.Vb 1
\&    F1 x19 @0...18\-20 Top_sequence \-> Top Top_sequence .
.Ve
.SS "\s-1OK\s0!  Now to find the bug"
.IX Subsection "OK! Now to find the bug"
Here again are progress reports
at the location where things went wrong:
.PP
.Vb 4
\&      F0 @0\-3 Expression \-> Factor .
\&      F2 @2\-3 Factor \-> Number .
\&      R4:1 x2 @0,2\-3 Factor \-> Factor . Multiply Factor
\&      F4 @0\-3 Factor \-> Factor Multiply Factor .
.Ve
.PP
We see that we have completed rules for \f(CW\*(C`Expression\*(C'\fR, and \f(CW\*(C`Factor\*(C'\fR,
as expected.
We also see two Earley items that show
that we are in the process of building another \f(CW\*(C`Factor\*(C'\fR,
and that it is expecting a \f(CW\*(C`Multiply\*(C'\fR symbol.
This is not the rule we want, but it explains why the \f(CW\*(C`trace_terminals\*(C'\fR
output showed that the recognizer was expecting a
\&\f(CW\*(C`Multiply\*(C'\fR symbol.
.PP
What we want to know is,
why is the recognizer \fBnot\fR expecting an \f(CW\*(C`Add\*(C'\fR symbol?
Looking back at the grammar, we see that only one rule uses
the \f(CW\*(C`Add\*(C'\fR symbol: the rule "\f(CW\*(C`Term \-> Term Add Term\*(C'\fR".
The next step is to look at the Earley items for this rule.
But there is a problem.
We don't find any.
.PP
Next, we ask ourselves, what is the earliest place the
"\f(CW\*(C`Term \-> Term Add Term\*(C'\fR\*(L" rule should be appearing?
The answer is that
there should be a prediction of \*(R"\f(CW\*(C`Term \-> Term Add Term\*(C'\fR" at location 0.
So we look at the predictions at location 0.
.PP
.Vb 3
\&      P0 @0\-0 Expression \-> . Factor
\&      P2 @0\-0 Factor \-> . Number
\&      P4 @0\-0 Factor \-> . Factor Multiply Factor
.Ve
.PP
No "\f(CW\*(C`Term \-> Term Add Term\*(C'\fR\*(L" rule.
We are never even predicting a
\&\*(R"\f(CW\*(C`Term \-> Term Add Term\*(C'\fR" rule.
We look back at the grammar, and start from
the beginning.
.PP
.Vb 11
\&    { lhs     => \*(AqExpression\*(Aq, rhs => [qw/Factor/] },
\&    { lhs => \*(AqTerm\*(Aq,       rhs => [qw/Factor/] },
\&    { lhs => \*(AqFactor\*(Aq,     rhs => [qw/Number/] },
\&    {   lhs    => \*(AqTerm\*(Aq,
\&        rhs    => [qw/Term Add Term/],
\&        action => \*(Aqdo_add\*(Aq
\&    },
\&    {   lhs    => \*(AqFactor\*(Aq,
\&        rhs    => [qw/Factor Multiply Factor/],
\&        action => \*(Aqdo_multiply\*(Aq
\&    },
.Ve
.PP
The start symbol is \f(CW\*(C`Expression\*(C'\fR and
we do see a rule with
\&\f(CW\*(C`Expression\*(C'\fR
on the left hand side.
\&\f(CW\*(C`Expression\*(C'\fR in turn produces a \f(CW\*(C`Factor\*(C'\fR symbol,
and there are two rules
with \f(CW\*(C`Factor\*(C'\fR on the left
hand side.
.PP
But none of these rules ever produce a \f(CW\*(C`Term\*(C'\fR.
In fact, however far we follow the productions,
no rule ever produces a \f(CW\*(C`Term\*(C'\fR.
At this point we see the problem:
If we start at the start symbol,
and follow the rules of our grammar, we will never get to a \f(CW\*(C`Term\*(C'\fR
symbol.
Which is exactly what that first warning message was saying.
.PP
Now that we know what is wrong,
we can reread our grammar,
and see that our \f(CW\*(C`Expression \-> Factor\*(C'\fR rule is wrong.
It should be \f(CW\*(C`Expression \-> Term\*(C'\fR.
Change that and the problem is fixed.
.SH "Empty rules"
.IX Header "Empty rules"
When a symbol is nulled in your parse,
\&\f(CW\*(C`show_progress\*(C'\fR
does not show its expansion into rules.
This reduces clutter,
and seems to be the intuitive way to treat nulled rules.
.ie n .SH "Access to the ""raw"" progress report information"
.el .SH "Access to the ``raw'' progress report information"
.IX Header "Access to the raw progress report information"
This section deals with the \f(CW\*(C`progress()\*(C'\fR recognizer method,
which allows access to the raw progress report information.
This method is not needed for typical debugging and tracing
situations.
It is intended for applications which want to leverage
Marpa's \*(L"situational awareness\*(R" in innovative ways.
.SS "\fBprogress()\fP"
.IX Subsection "progress()"
.Vb 1
\&    my $report0 = $recce\->progress(0);
.Ve
.PP

.PP
.Vb 1
\&    my $latest_report = $recce\->progress();
.Ve
.PP
Given the parse location (Earley set \s-1ID\s0) as its argument,
the \f(CW\*(C`progress()\*(C'\fR recognizer method returns a reference
to an array of \*(L"report items\*(R".
The parse location may be negative.
An argument of \fI\-X\fR
will be interpreted as location \fIN+X+1\fR, where \fIN\fR is
the latest Earley set.
This means that an argument of \-1 indicates the latest
Earley set,
an argument of \-2 indicates the Earley set just before
the latest one, etc.
.PP
Each report item is a triple: an array of three elements.
The three elements are, in order,
rule \s-1ID,\s0 dot position, and origin.
The data returned by the two displays above,
as well as the data for the other parse locations
in our example,
are shown below.
.PP
The rule \s-1ID\s0 is the same number that Marpa uses
to identify rules
in tracing and debugging output.
Given a rule \s-1ID,\s0 an application can find
its \s-1LHS\s0 and \s-1RHS\s0 symbols using
the grammar's \f(CW\*(C`rule()\*(C'\fR method.
.PP
Dot position is \-1 for completions,
and 0 for predictions.
Where the report item is not for a completion or
a prediction, dot position is \fIN\fR,
where \fIN\fR is the number of \s-1RHS\s0 symbols
successfully recognized at the parse location of
the progress report.
.PP
Origin is parse location (Earley set \s-1ID\s0)
at which the rule application reported by
the report item began.
For a prediction, origin will always be
the same as the location of the parse report.
.SS "Progress reports and efficiency"
.IX Subsection "Progress reports and efficiency"
When progress reports are used for production parsing,
instead of just for debugging and tracing,
efficiency considerations become significant.
We will start with the good news.
\&\f(CW\*(C`progress()\*(C'\fR is implemented in C, so that the
application can usually expect calls to
\&\f(CW\*(C`progress()\*(C'\fR to be extremely fast.
.PP
Now, as to the potential bad news:
Applications planning frequent use of calls
to \f(CW\*(C`progress()\*(C'\fR need to be aware that,
where there is a right recursion at a parse location,
\&\f(CW\*(C`progress()\*(C'\fR needs to follow the entire chain
of recursions to create the progress report.
That this is happening will always be evident
from the parse report itself,
which will contain one report item
for every completion in the right-recursive
chain of completions.
If an application tries to
produce progress reports for a large number of parse locations,
and these parse locations have long right recursive chains,
it can prove computationally expensive.
.PP
The efficiency consideration just mentioned
for following right recursions
is not an issue for left recursions.
Left recursions only produce at most two report
items per parse location
and are extremely fast to process.
It is also not an issue for
Marpa's sequence rules, because sequence rules
are implemented internally as left recursions.
.SH "Appendix: full code and output for the example"
.IX Header "Appendix: full code and output for the example"
Below are the code, the trace outputs
and the progress report
for the example used in this
document.
.SS "Code"
.IX Subsection "Code"
.Vb 10
\&    my $grammar = Marpa::R2::Grammar\->new(
\&        {   start          => \*(AqExpression\*(Aq,
\&            actions        => \*(AqMy_Actions\*(Aq,
\&            default_action => \*(Aqfirst_arg\*(Aq,
\&            rules          => [
\&                ## This is a deliberate error in the grammar
\&                ## The next line should be:
\&                ## { lhs => \*(AqExpression\*(Aq, rhs => [qw/Term/] },
\&                ## I have changed the Term to \*(AqFactor\*(Aq which
\&                ## will cause problems.
\&                { lhs => \*(AqExpression\*(Aq, rhs => [qw/Factor/] },
\&                { lhs => \*(AqTerm\*(Aq,       rhs => [qw/Factor/] },
\&                { lhs => \*(AqFactor\*(Aq,     rhs => [qw/Number/] },
\&                {   lhs    => \*(AqTerm\*(Aq,
\&                    rhs    => [qw/Term Add Term/],
\&                    action => \*(Aqdo_add\*(Aq
\&                },
\&                {   lhs    => \*(AqFactor\*(Aq,
\&                    rhs    => [qw/Factor Multiply Factor/],
\&                    action => \*(Aqdo_multiply\*(Aq
\&                },
\&            ],
\&        }
\&    );
.Ve
.PP
.Vb 1
\&    $grammar\->precompute();
\&
\&    my @tokens = (
\&        [ \*(AqNumber\*(Aq,   42 ],
\&        [ \*(AqMultiply\*(Aq, q{*} ],
\&        [ \*(AqNumber\*(Aq,   1 ],
\&        [ \*(AqAdd\*(Aq,      q{+} ],
\&        [ \*(AqNumber\*(Aq,   7 ],
\&    );
\&
\&    sub My_Actions::do_add {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 + $t2;
\&    }
\&
\&    sub My_Actions::do_multiply {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 * $t2;
\&    }
\&
\&    sub My_Actions::first_arg { shift; return shift; }
\&
\&    my $recce = Marpa::R2::Recognizer\->new(
\&        { grammar => $grammar, trace_terminals => 2 } );
\&
\&    my $token_ix = 0;
\&
\&    TOKEN: for my $token_and_value (@tokens) {
\&        last TOKEN if not defined $recce\->read( @{$token_and_value} );
\&    }
\&
\&    $progress_report = $recce\->show_progress( 0, \-1 );
.Ve
.SS "Trace output"
.IX Subsection "Trace output"
.Vb 11
\&    Inaccessible symbol: Add
\&    Inaccessible symbol: Term
\&    Setting trace_terminals option
\&    Expecting "Number" at earleme 0
\&    Accepted "Number" at 0\-1
\&    Expecting "Multiply" at 1
\&    Accepted "Multiply" at 1\-2
\&    Expecting "Number" at 2
\&    Accepted "Number" at 2\-3
\&    Expecting "Multiply" at 3
\&    Rejected "Add" at 3\-4
.Ve
.PP
Note the use of the term \*(L"earleme\*(R".
If you are using the default input model,
you can assume that earleme means \*(L"location\*(R":
the earleme
and the location will always be exactly the same.
Advanced users, using alternative input models,
may set it up so that earleme and location are
two different things,
and in that case the distinction will matter.
.SS "\fBshow_progress()\fP output"
.IX Subsection "show_progress() output"
.Vb 10
\&    P0 @0\-0 Expression \-> . Factor
\&    P2 @0\-0 Factor \-> . Number
\&    P4 @0\-0 Factor \-> . Factor Multiply Factor
\&    F0 @0\-1 Expression \-> Factor .
\&    F2 @0\-1 Factor \-> Number .
\&    R4:1 @0\-1 Factor \-> Factor . Multiply Factor
\&    P2 @2\-2 Factor \-> . Number
\&    P4 @2\-2 Factor \-> . Factor Multiply Factor
\&    R4:2 @0\-2 Factor \-> Factor Multiply . Factor
\&    F0 @0\-3 Expression \-> Factor .
\&    F2 @2\-3 Factor \-> Number .
\&    R4:1 x2 @0,2\-3 Factor \-> Factor . Multiply Factor
\&    F4 @0\-3 Factor \-> Factor Multiply Factor .
.Ve
.SS "\fBprogress()\fP outputs"
.IX Subsection "progress() outputs"
These section contains the output of the \f(CW\*(C`progress()\*(C'\fR
method \*(-- the progress reports in their \*(L"raw\*(R" format.
The output is shown in Data::Dumper format,
with \f(CW\*(C`Data::Dumper::Indent\*(C'\fR set to 0
and \f(CW\*(C`Data::Dumper::Terse\*(C'\fR set to 1.
.PP
The \f(CW\*(C`Data::Dumper\*(C'\fR output from \f(CW\*(C`progress()\*(C'\fR at location 0:
.PP
.Vb 1
\&    [[0,0,0],[2,0,0],[4,0,0]]
.Ve
.PP
The \f(CW\*(C`Data::Dumper\*(C'\fR output from \f(CW\*(C`progress()\*(C'\fR at location 1:
.PP
.Vb 1
\&    [[0,\-1,0],[2,\-1,0],[4,1,0]]
.Ve
.PP
The \f(CW\*(C`Data::Dumper\*(C'\fR output from \f(CW\*(C`progress()\*(C'\fR at location 2:
.PP
.Vb 1
\&    [[2,0,2],[4,0,2],[4,2,0]]
.Ve
.PP
The default \f(CW\*(C`progress()\*(C'\fR output is for the latest Earley set,
which is location 3 in our example.
Here is the \f(CW\*(C`progress()\*(C'\fR output for location 3.
.PP
.Vb 1
\&    [[0,\-1,0],[2,\-1,2],[4,\-1,0],[4,1,0],[4,1,2]]
.Ve
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
