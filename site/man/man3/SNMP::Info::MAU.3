.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SNMP::Info::MAU 3"
.TH SNMP::Info::MAU 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SNMP::Info::MAU \- SNMP Interface to Medium Attachment Unit (MAU) MIB (RFC 2668)
via SNMP
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Baker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& my $mau = new SNMP::Info (
\&                             AutoSpecify => 1,
\&                             Debug       => 1,
\&                             DestHost    => \*(Aqhpswitch\*(Aq,
\&                             Community   => \*(Aqpublic\*(Aq,
\&                             Version     => 2
\&                           );
\&
\& my $class = $mau\->class();
\& print " Using device sub class : $class\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SNMP::Info::MAU is a subclass of SNMP::Info that supplies access to the
\&\fIMAU-MIB\fR (\s-1RFC 2668\s0). This \s-1MIB\s0 is sometimes implemented on Layer 2 network
devices.  \s-1MAU\s0 = Medium Attachment Unit.
.PP
The \s-1MAU\s0 table contains link and duplex info for the port itself and the device
connected to that port.
.PP
Normally you use or create a subclass of SNMP::Info that inherits this one.
Do not use directly.
.PP
For debugging purposes call the class directly as you would SNMP::Info
.PP
.Vb 1
\& my $mau = new SNMP::Info::MAU(...);
.Ve
.SS "Inherited Classes"
.IX Subsection "Inherited Classes"
None.
.SS "Required MIBs"
.IX Subsection "Required MIBs"
.IP "\fIMAU-MIB\fR" 4
.IX Item "MAU-MIB"
.PD 0
.IP "\fIIANA-MAU-MIB\fR" 4
.IX Item "IANA-MAU-MIB"
.PD
.SH "GLOBALS"
.IX Header "GLOBALS"
These are methods that return scalar value from \s-1SNMP\s0
.IP "None" 4
.IX Item "None"
.SH "TABLE METHODS"
.IX Header "TABLE METHODS"
These are methods that return tables of information in the form
of a reference to a hash.
.ie n .IP "$mau\->\fBmau_i_duplex()\fR" 4
.el .IP "\f(CW$mau\fR\->\fBmau_i_duplex()\fR" 4
.IX Item "$mau->mau_i_duplex()"
Parses mau_index and mau_link to return the duplex information for
interfaces.
.ie n .IP "$mau\->\fBmau_i_duplex_admin()\fR" 4
.el .IP "\f(CW$mau\fR\->\fBmau_i_duplex_admin()\fR" 4
.IX Item "$mau->mau_i_duplex_admin()"
Parses \f(CW\*(C`mac_index\*(C'\fR,\f(CW\*(C`mau_autostat\*(C'\fR,\f(CW\*(C`mau_type_admin\*(C'\fR in
order to find the admin duplex setting for all the interfaces.
.Sp
Returns either (auto,full,half).
.ie n .IP "$mau\->\fBmau_i_duplex_admin_old()\fR" 4
.el .IP "\f(CW$mau\fR\->\fBmau_i_duplex_admin_old()\fR" 4
.IX Item "$mau->mau_i_duplex_admin_old()"
Called by \fBmau_i_duplex_admin()\fR if \f(CW\*(C`mau_type_admin\*(C'\fR is empty.
Parses \f(CW\*(C`mau_index\*(C'\fR,\f(CW\*(C`mau_autostat\*(C'\fR,\f(CW\*(C`mau_autosent\*(C'\fR in
order to find the admin duplex setting for all the interfaces.
.Sp
Returns either (auto,none,full,half).
.ie n .IP "$mau\->\fBmau_i_speed_admin()\fR" 4
.el .IP "\f(CW$mau\fR\->\fBmau_i_speed_admin()\fR" 4
.IX Item "$mau->mau_i_speed_admin()"
Returns admin speed setting for all the interfaces.
.SS "\s-1MAU\s0 Interface Table Methods"
.IX Subsection "MAU Interface Table Methods"
.ie n .IP "$mau\->\fBmau_index()\fR \-  Returns a list of interfaces and their index in the \s-1MAU IF\s0 Table." 4
.el .IP "\f(CW$mau\fR\->\fBmau_index()\fR \-  Returns a list of interfaces and their index in the \s-1MAU IF\s0 Table." 4
.IX Item "$mau->mau_index() - Returns a list of interfaces and their index in the MAU IF Table."
(\f(CW\*(C`ifMauIfIndex\*(C'\fR)
.ie n .IP "$mau\->\fBmau_link()\fR \- Returns the type of Media Access used." 4
.el .IP "\f(CW$mau\fR\->\fBmau_link()\fR \- Returns the type of Media Access used." 4
.IX Item "$mau->mau_link() - Returns the type of Media Access used."
.Vb 2
\&    This is essentially the type of link in use.
\&    eg. dot3MauType100BaseTXFD \- 100BaseT at Full Duplex
.Ve
.Sp
(\f(CW\*(C`ifMauType\*(C'\fR)
.ie n .IP "$mau\->\fBmau_status()\fR \- Returns the admin link condition as" 4
.el .IP "\f(CW$mau\fR\->\fBmau_status()\fR \- Returns the admin link condition as" 4
.IX Item "$mau->mau_status() - Returns the admin link condition as"
.Vb 6
\&    1 \- other
\&    2 \- unknown
\&    3 \- operational
\&    4 \- standby
\&    5 \- shutdown
\&    6 \- reset
.Ve
.Sp
Use 5 and !5 to see if the link is up or down on the admin side.
.Sp
(\f(CW\*(C`ifMauStatus\*(C'\fR)
.ie n .IP "$mau\->\fBmau_up()\fR \-  Returns the current link condition" 4
.el .IP "\f(CW$mau\fR\->\fBmau_up()\fR \-  Returns the current link condition" 4
.IX Item "$mau->mau_up() - Returns the current link condition"
.Vb 1
\& (C<ifMauMediaAvailable>)
.Ve
.ie n .IP "$mau\->\fBmau_type()\fR \- Returns a 32bit string reporting the capabilities of the port from a \s-1MAU POV.\s0" 4
.el .IP "\f(CW$mau\fR\->\fBmau_type()\fR \- Returns a 32bit string reporting the capabilities of the port from a \s-1MAU POV.\s0" 4
.IX Item "$mau->mau_type() - Returns a 32bit string reporting the capabilities of the port from a MAU POV."
.Vb 10
\&  Directly from F<MAU\-MIB> :
\&          Bit   Capability
\&            0      other or unknown
\&            1      AUI
\&            2      10BASE\-5
\&            3      FOIRL
\&            4      10BASE\-2
\&            5      10BASE\-T duplex mode unknown
\&            6      10BASE\-FP
\&            7      10BASE\-FB
\&            8      10BASE\-FL duplex mode unknown
\&            9      10BROAD36
\&           10      10BASE\-T  half duplex mode
\&           11      10BASE\-T  full duplex mode
\&           12      10BASE\-FL half duplex mode
\&           13      10BASE\-FL full duplex mode
\&           14      100BASE\-T4
\&           15      100BASE\-TX half duplex mode
\&           16      100BASE\-TX full duplex mode
\&           17      100BASE\-FX half duplex mode
\&           18      100BASE\-FX full duplex mode
\&           19      100BASE\-T2 half duplex mode
\&           20      100BASE\-T2 full duplex mode
.Ve
.Sp
(\f(CW\*(C`ifMauTypeList\*(C'\fR)
.ie n .IP "$mau\->\fBmau_type_admin()\fR" 4
.el .IP "\f(CW$mau\fR\->\fBmau_type_admin()\fR" 4
.IX Item "$mau->mau_type_admin()"
(\f(CW\*(C`ifMauDefaultType\*(C'\fR)
.ie n .IP "$mau\->\fBmau_auto()\fR \- Indicates whether or not auto-negotiation is supported." 4
.el .IP "\f(CW$mau\fR\->\fBmau_auto()\fR \- Indicates whether or not auto-negotiation is supported." 4
.IX Item "$mau->mau_auto() - Indicates whether or not auto-negotiation is supported."
(\f(CW\*(C`ifMauAutoNegSupported\*(C'\fR)
.ie n .IP "$mau\->\fBmau_autostat()\fR \- Returns status of auto-negotiation mode for ports." 4
.el .IP "\f(CW$mau\fR\->\fBmau_autostat()\fR \- Returns status of auto-negotiation mode for ports." 4
.IX Item "$mau->mau_autostat() - Returns status of auto-negotiation mode for ports."
(\f(CW\*(C`ifMauAutoNegAdminStatus\*(C'\fR)
.ie n .IP "$mau\->\fBmau_autosent()\fR \- Returns a 32 bit bit-string representing the capabilities we are broadcasting on that port" 4
.el .IP "\f(CW$mau\fR\->\fBmau_autosent()\fR \- Returns a 32 bit bit-string representing the capabilities we are broadcasting on that port" 4
.IX Item "$mau->mau_autosent() - Returns a 32 bit bit-string representing the capabilities we are broadcasting on that port"
.Vb 1
\&    Uses the same decoder as $mau\->mau_type().
.Ve
.Sp
(\f(CW\*(C`ifMauAutoNegCapAdvertised\*(C'\fR)
.ie n .IP "$mau\->\fBmau_autorec()\fR \- Returns a 32 bit bit-string representing the capabilities of the device on the other end." 4
.el .IP "\f(CW$mau\fR\->\fBmau_autorec()\fR \- Returns a 32 bit bit-string representing the capabilities of the device on the other end." 4
.IX Item "$mau->mau_autorec() - Returns a 32 bit bit-string representing the capabilities of the device on the other end."
.Vb 1
\&    Uses the same decoder as $mau\->mau_type().
.Ve
.Sp
(\f(CW\*(C`ifMauAutoNegCapReceived\*(C'\fR)
.SH "SET METHODS"
.IX Header "SET METHODS"
These are methods that provide \s-1SNMP\s0 set functionality for overridden methods
or provide a simpler interface to complex set operations.  See
\&\*(L"\s-1SETTING DATA VIA SNMP\*(R"\s0 in SNMP::Info for general information on set
operations.
.ie n .IP "$mau\->mau_set_i_speed_admin(speed, ifIndex)" 4
.el .IP "\f(CW$mau\fR\->mau_set_i_speed_admin(speed, ifIndex)" 4
.IX Item "$mau->mau_set_i_speed_admin(speed, ifIndex)"
Sets port speed, must be supplied with speed and port \f(CW\*(C`ifIndex\*(C'\fR.
.Sp
Note that this method has some limitations since there is no way
to reliably set the port speed independently of the port duplex
setting on certain devices, notably the Cisco Cat4k series.
.Sp
Speed choices are '10', '100', '1000', 'auto'.
.ie n .IP "$mau\->mau_set_i_duplex_admin(duplex, ifIndex)" 4
.el .IP "\f(CW$mau\fR\->mau_set_i_duplex_admin(duplex, ifIndex)" 4
.IX Item "$mau->mau_set_i_duplex_admin(duplex, ifIndex)"
Sets port duplex, must be supplied with duplex and port \f(CW\*(C`ifIndex\*(C'\fR.
.Sp
Note that this method has some limitations since there is no way
to reliably set the port duplex independently of the port speed
setting on certain devices, notably the Cisco Cat4k series.
.Sp
Duplex choices are 'auto', 'half', 'full'.
.ie n .IP "$mau\->mau_set_i_speed_duplex_admin(speed, duplex, ifIndex)" 4
.el .IP "\f(CW$mau\fR\->mau_set_i_speed_duplex_admin(speed, duplex, ifIndex)" 4
.IX Item "$mau->mau_set_i_speed_duplex_admin(speed, duplex, ifIndex)"
Sets port speed and duplex settings, must be supplied with speed,
duplex and port \f(CW\*(C`ifIndex\*(C'\fR.
.Sp
Accepts the following values for speed and duplex:
.Sp
.Vb 9
\&        Speed/Duplex
\&        \-\-\-\-\-\-\-\-\-\-\-\-
\&        auto/auto (this is a special case)
\&        10/half
\&        10/full
\&        100/half
\&        100/full
\&        1000/half
\&        1000/full
.Ve
.SH "Utility Functions"
.IX Header "Utility Functions"
.IP "\fBmunge_int2bin()\fR \- Unpacks an integer into a 32bit bit string." 4
.IX Item "munge_int2bin() - Unpacks an integer into a 32bit bit string."
.PD 0
.ie n .IP "$mau\->_isfullduplex(bitstring)" 4
.el .IP "\f(CW$mau\fR\->_isfullduplex(bitstring)" 4
.IX Item "$mau->_isfullduplex(bitstring)"
.PD
.Vb 2
\&    Boolean. Checks to see if any of the full_duplex types from mau_type()
\&    are     high.  Currently bits 11,13,16,18,20.
.Ve
.ie n .IP "$mau\->_ishalfduplex(bitstring)" 4
.el .IP "\f(CW$mau\fR\->_ishalfduplex(bitstring)" 4
.IX Item "$mau->_ishalfduplex(bitstring)"
.Vb 2
\&    Boolean.  Checks to see if any of the half_duplex types from mau_type()
\&    are high.  Currently bits 10,12,15,17,19.
.Ve
