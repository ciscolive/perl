.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ToolKit 3"
.TH ToolKit 3 "2014-01-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::ToolKit \- tools for working with DNS packets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::DNS::ToolKit qw(
\&
\&        get1char
\&        get16
\&        get32
\&        put1char
\&        put16
\&        put32
\&        getIPv4
\&        putIPv4
\&        putIPv6
\&        getIPv6
\&        getstring
\&        putstring
\&        dn_comp
\&        dn_expand
\&        parse_char
\&        gethead
\&        newhead
\&        getflags
\&        putflags
\&        get_qdcount
\&        get_ancount
\&        get_nscount
\&        get_arcount
\&        put_qdcount
\&        put_ancount
\&        put_nscount
\&        put_arcount
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_n2x
\&        ipv6_n2d   
\&        sec2time
\&        ttlAlpha2Num
\&        collapse
\&        strip
\&        get_ns
\&        gettimeofday
\&  );
\&
\&  $char = get1char(\e$buffer,$offset);
\&  ($int, $newoff)  = get16(\e$buffer,$offset);
\&  ($long, $newoff) = get32(\e$buffer,$offset);
\&  $newoff = put1char(\e$buffer,$offset,$u_char);
\&  $newoff = put16(\e$buffer,$offset,$int);
\&  $newoff = put32(\e$buffer,$offset,$long);
\&  $flags = getflags(\e$buffer);
\&  true = putflags(\e$buffer,$flags);
\&  $int = get_qdcount(\e$buffer);
\&  $int = get_ancount(\e$buffer);
\&  $int = get_nscount(\e$buffer);
\&  $int = get_arcount(\e$buffer);
\&  $newoff = put_qdcount(\e$buffer,$int);
\&  $newoff = put_ancount(\e$buffer,$int);
\&  $newoff = put_nscount(\e$buffer,$int);
\&  $newoff = put_arcount(\e$buffer,$int);
\&  ($netaddr,$newoff)=getIPv4(\e$buffer,$offset);
\&  $newoff = putIPv4(\e$buffer,$offset,$netaddr);
\&  ($ipv6addr,$newoff)=getIPv6(\e$buffer,$offset);
\&  $newoff = putIPv6(\e$buffer,$offset,$ipv6addr);
\&  ($offset,
\&   $id,$qr,$opcode,$aa,$tc,$rd,$ra,$mbz,$ad,$cd,$rcode,
\&   $qdcount,$ancount,$nscount,$arcount)
\&        = gethead(\e$buffer);
\&  $newoff = newhead(\e$buffer,$id,$flags,
\&        $qdcount,$ancount,$nscount,$arcount);
\&  ($b,$h,$d,$a)=parse_char($char);
\&  ($newoff,$name) = dn_expand(\e$buffer,$offset);
\&  ($newoff,@dnptrs)=dn_comp(\e$buffer,$offset,\e$name,\e@dnptrs);
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6addr = ipv6_aton($ipv6_text);
\&  $hex_text = ipv6_n2x($ipv6addr);
\&  $dec_text = ipv6_n2d($ipv6addr);
\&  $timetxt = sec2time($seconds);
\&  $seconds = ttlAlpha2Num($timetext);
\&  $shorthost = collapse($zonename,$longhost);
\&  $tag = strip($P_tag);
\&  @nameservers = get_ns();
\&  ($secs,$usecs) = gettimeofday();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Routines to pick apart, examine and put together \s-1DNS\s0 packets. They can be
used for diagnostic purposes or as building blocks for \s-1DNS\s0 applications such
as \s-1DNS\s0 servers and clients or to allow user applications to interact
directly with remote \s-1DNS\s0 servers.
.PP
.Vb 3
\&  See: Net::DNS::ToolKit:RR and the subdirectory
\&        lib/Net/DNS/ToolKit/RR/
\&  for individual Resource Record methods.
\&
\&  Net::DNS::ToolKit does not handle every type of RR with context
\&  help for the record format. HOWEVER, it does handle all unknown
\&  record types per RFC\-3597 so if your program can manipulate the
\&  binary and/or hex representation of the data as proscribed in RFC\-3597 this
\&  module will always work for you.
.Ve
.PP
A good example of full utilization of this module is
Net::DNS::Dig/module.
.PP
See: Net::DNS::ToolKit::RR (included in this distribution) for a complete description of how to use this
module and the accompanying Resource Records tools.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These functions return a value and offset in list context and first value only in
scalar context.
.PP
.Vb 7
\&  ($int,$newoff)        = get16(...
\&  ($long,$newoff)       = get32(...
\&  ($netaddr,$newoff)    = getIPv4(...
\&  ($ipv6addr,$newoff)   = getIPv6(...
\&  ($string,$newoff)     = getstring(...
\&  ($newoff,$name)       = dn_expand(...
\&  ($secs,$usecs)        = gettimeofday(...
.Ve
.PP
These functions return only a value or an offset.
.PP
.Vb 10
\&  $newoff       = put1char(...
\&  $newoff       = put16(...  
\&  $newoff       = put32(...
\&  $newoff       = put_qdcount(...
\&  $newoff       = put_ancount(...
\&  $newoff       = put_nscount(...
\&  $newoff       = put_arcount(...
\&  $newoff       = putIPv4(...
\&  $newoff       = putIPv4(...
\&  $newoff       = putstring(...
\&  $newoff       = newhead(...
\&  $flags        = getflags(...
\&  true          = putflags(...
\&  $int          = get_qdcount(...
\&  $int          = get_ancount(...
\&  $int          = get_nscount(...
\&  $int          = get_arcount(...
\&  $char         = get1char(...
\&  $dotquad      = inet_ntoa(...
\&  $netaddr      = inet_aton(...
\&  $timetxt      = sec2time(...
\&  $seconds      = ttlAlpha2Num(...
\&  $tag          = strip(...
\&  $shorthost    = collapse(...
.Ve
.PP
This function always return list context prefixed by a new offset.
.PP
.Vb 2
\&  ($newoff,@dnptrs) = dn_comp(...
\&  ($offset,@list)   = gethead(...
.Ve
.PP
These functions always return list context.
.PP
.Vb 2
\&  @list         = parse_char(...
\&  @nameservers  = get_ns(...
.Ve
.IP "\(bu" 4
\&\f(CW$char\fR = get1char(\e$buffer,$offset);
.Sp
Get a single character from the buffer at \f(CW$offset\fR
.Sp
.Vb 5
\&  input:        pointer to buffer,
\&                offset into buffer
\&  output:       the "character"   
\&           or   undef if the pointer
\&                is outside the buffer
.Ve
.IP "\(bu" 4
($int, \f(CW$newoff\fR)  = get16(\e$buffer,$offset);
.Sp
Get a 16 bit integer from the buffer at \f(CW$offset\fR. Return 
the value and a new offset pointing at the next character.
.Sp
Returns and empty array on error.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      16 bit integer,
\&                offset + size of int
.Ve
.Sp
In \s-1SCALAR\s0 context, returns just the value.
.IP "\(bu" 4
\&\f(CW$newoff\fR = put1char(\e$buffer,$offset,$u_char);
.Sp
Put an unsigned 8 bit value into the buffer at \f(CW$offset\fR. Return the value of
the new offset pointer to the next char (usually end of buffer).
.IP "\(bu" 4
\&\f(CW$newoff\fR = put16(\e$buffer,$offset,$int);
.Sp
Put a 16 bit integer into the buffer at \f(CW$offset\fR. Return the value of
the new offset pointer to the the next char (usually end of buffer).
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer,
\&                16 bit integer
\&  returns:      offset + size of int
.Ve
.IP "\(bu" 4
($long, \f(CW$newoff\fR) = get32(\e$buffer,$offset);
.Sp
Get a 32 bit long from the buffer at \f(CW$offset\fR. Return the 
long and a new offset pointing at the next character.
.Sp
Returns and empty array on error.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      32 bit long,
\&                offset + size long
.Ve
.Sp
In \s-1SCALAR\s0 context, returns just the value.
.IP "\(bu" 4
\&\f(CW$newoff\fR = put32(\e$buffer,$offset,$long);
.Sp
Put a 32 bit long into the buffer at \f(CW$offset\fR. Return the value of
the new offset pointer to the the next char (usually end of buffer).
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer,
\&                32 bit long
\&  returns:      offset + size of int
.Ve
.IP "\(bu" 4
\&\f(CW$flags\fR = getflags(\e$buffer);
.Sp
Get the flag bits from the header
.Sp
.Vb 2
\&  input:        pointer to buffer,
\&  returns:      flag bits
.Ve
.IP "\(bu" 4
putflags(\e$buffer,$flags);
.Sp
Put flags bits back in header
.Sp
.Vb 3
\&  input:        pointer to buffer,
\&                flags bits
\&  returns:      n/a
.Ve
.IP "\(bu" 4
\&\f(CW$int\fR = get_qdcount(\e$buffer);
.Sp
Get the contents of the qdcount.
.Sp
.Vb 2
\&  input:        pointer to buffer,
\&  returns:      16 bit integer,
.Ve
.IP "\(bu" 4
\&\f(CW$int\fR = get_ancount(\e$buffer);
.Sp
Get the contents of the ancount.
.Sp
.Vb 2
\&  input:        pointer to buffer,
\&  returns:      16 bit integer,
.Ve
.IP "\(bu" 4
\&\f(CW$int\fR = get_nscount(\e$buffer);
.Sp
Get the contents of the nscount.
.Sp
.Vb 2
\&  input:        pointer to buffer,
\&  returns:      16 bit integer,
.Ve
.IP "\(bu" 4
\&\f(CW$int\fR = get_arcount(\e$buffer);
.Sp
Get the contents of the arcount.
.Sp
.Vb 2
\&  input:        pointer to buffer,
\&  returns:      16 bit integer,
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR = put_qdcount(\e$buffer,$int);
.Sp
Put a 16 bit integer into qdcount. Return an offset to ancount.
.Sp
.Vb 3
\&  input:        pointer to buffer,
\&                16 bit integer,
\&  returns:      offset to ancount
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR = put_ancount(\e$buffer,$int);
.Sp
Put a 16 bit integer into ancount. Return an offset to nscount.
.Sp
.Vb 3
\&  input:        pointer to buffer,
\&                16 bit integer,
\&  returns:      offset to nscount
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR = put_nscount(\e$buffer,$int);
.Sp
Put a 16 bit chunk into nscount. Return an offset to arcount.
.Sp
.Vb 3
\&  input:        pointer to buffer,
\&                16 bit integer,
\&  returns:      offset to arcount
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR = put_arcount(\e$buffer,$int);
.Sp
Put a 16 bit integer into arcount. Return an offset to answer section.
.Sp
.Vb 3
\&  input:        pointer to buffer,
\&                16 bit integer,
\&  returns:      offset to question section
.Ve
.IP "\(bu" 4
($netaddr,$newoff)=getIPv4(\e$buffer,$offset);
.Sp
Get an IPv4 network address from the buffer at \f(CW$offset\fR. Return the 
netaddr and a new offset pointing at the next character beyond.
.Sp
Returns and empty array on error.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      netaddr,
\&                offset + size of ipaddr
.Ve
.Sp
In \s-1SCALAR\s0 context, returns just netaddr.
.IP "\(bu" 4
\&\f(CW$newoff\fR = putIPv4(\e$buffer,$offset,$netaddr);
.Sp
Put a netaddr into the buffer. Return the value of the
new offset pointer to the next char (usually end of buffer).
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer,
\&                packed IPv4 net address
\&  returns:      pointer to end of buffer
.Ve
.IP "\(bu" 4
($ipv6addr,$newoff)=getIPv6(\e$buffer,$offset);
.Sp
Get an IPv6 network address from the buffer at \f(CW$offset\fR. Return the
ipv6addr and a new offset pointing at the next character beyond.
.Sp
Returns and empty array on error.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      ipv6addr,
\&                offset + size of ipv6addr
.Ve
.Sp
\&\s-1IN SCALAR\s0 context, returns just ipv6addr.
.IP "\(bu" 4
\&\f(CW$newoff\fR = putIPv6(\e$buffer,$offset,$ipv6addr);
.Sp
Put an ipv6addr into the buffer. Return the value of the
new offset pointer to the next char (usually end of buffer).
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer,
\&                128 bit IPv6 net address
\&  returns:      pointer to end of buffer
.Ve
.IP "\(bu" 4
($string,$newoff) =
	getstring(\e$buffer,$offset,$length);
.Sp
Return a string of \f(CW$length\fR from the buffer.
.Sp
.Vb 6
\&  input:        pointer to buffer,
\&                offset,
\&                length of string
\&  returns:      string,
\&                new offset to end
\&                off string in buffer
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR = putstring(\e$buffer,$offset,\e$string);
.Sp
Append a string to \f(CW$buffer\fR at \f(CW$offset\fR.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer,
\&                pointer to string
\&  returns:      new offset to end of buffer
.Ve
.IP "\(bu" 4
($offset,@headitems) = gethead(\e$buffer);
.Sp
.Vb 4
\&  ($offset,
\&  $id,$qr,$opcode,$aa,$tc,$rd,$ra,$mbz,$ad,$cd,$rcode,
\&   $qdcount,$ancount,$nscount,$arcount)
\&        = gethead(\e$buffer);
\&
\&  Get the numeric codes for header variables
\&
\&    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |                      ID                       |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |QR|   Opcode  |AA|TC|RD|RA| Z|AD|CD|   RCODE   |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |                    QDCOUNT                    |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |                    ANCOUNT                    |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |                    NSCOUNT                    |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&  |                    ARCOUNT                    |
\&  +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&
\&  The length of this header is NS_HFIXEDSZ
\&
\&  input:        pointer to message buffer
\&  returns:      offset to question section,
\&                array of variables
.Ve
.IP "\(bu" 4
\&\f(CW$newoff\fR=newhead(\e$buffer,
  \f(CW$id\fR,$flags,$qdcount,$ancount,$nscount,$arcount);
.Sp
Creat a new header and return the offset to question
.Sp
.Vb 9
\&  input:        \e$buffer
\&                $id,
\&                $flags,
\&                $qdcount,
\&                $ancount,
\&                $nscount,
\&                $arcount
\&  returns:      offset to question = NS_HFIXEDSZ
\&            or  undefined on error
\&
\&  If qdcount, ancount, nscount, arcount are
\&  not present, then they will be set to zero.
\&
\&  example dump script:
\&
\&  use lib qw(blib/lib blib/arch);
\&  use Net::DNS::Codes qw(:all);
\&  use Net::DNS::ToolKit::Debug qw(
\&        print_head
\&        print_buf
\&  );
\&  use Net::DNS::ToolKit qw(
\&        get1char
\&        parse_char
\&        newhead
\&  );
\&  my $buffer = \*(Aq\*(Aq;
\&  newhead(\e$buffer,
\&        1234,                   # ID
\&        QR | BITS_QUERY | RD,
\&        1,                      # questions
\&        5,                      # answers
\&        2,                      # ns authority
\&        3,                      # glue records
\&  );
\&
\&  print_head(\e$buffer);
\&  print_buf(\e$buffer);
\&
\&  Will produce the following output:
\&
\&  ID     => 1234    
\&  QR      => 1    
\&  OPCODE  => QUERY
\&  AA      => 0
\&  TC      => 0
\&  RD      => 1
\&  RA      => 0
\&  Z       => 0
\&  AD      => 0
\&  CD      => 0
\&  RCODE   => NOERROR
\&  QDCOUNT => 1
\&  ANCOUNT => 5
\&  NSCOUNT => 2
\&  ARCOUNT => 3
\&  0     :  0000_0100  0x04    4    
\&  1     :  1101_0010  0xD2  210    
\&  2     :  1000_0001  0x81  129    
\&  3     :  0000_0000  0x00    0    
\&  4     :  0000_0000  0x00    0    
\&  5     :  0000_0001  0x01    1    
\&  6     :  0000_0000  0x00    0    
\&  7     :  0000_0101  0x05    5    
\&  8     :  0000_0000  0x00    0    
\&  9     :  0000_0010  0x02    2    
\&  10    :  0000_0000  0x00    0    
\&  11    :  0000_0011  0x03    3
.Ve
.IP "\(bu" 4
($b,$h,$d,$a) = parse_char($char);
.Sp
.Vb 1
\&  return strings for the character in:
\&
\&    binary    hex   decimal   ascii
\&  0011_1001  0x39      57      9
\&
\&  as appropriate. Ascii is only 
\&  returned if printable.
.Ve
.Sp
A simple script using this routine can provide
a view into a \s-1DNS\s0 packet to examine the bits
and byte. Very useful while writing \s-1DNS\s0 client
and server routines. See the example below.
.IP "\(bu" 4
($name,$newoff) = dn_expand(\e$buffer,$offset);
.Sp
Expands a compressed domain name into a full domain name.
.Sp
.Vb 4
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      expanded name,
\&                pointer to next RR
.Ve
.IP "\(bu" 4
($newoff,@dnptrs)=dn_comp(\e$buffer,$offset,\e$name,\e@dnptrs);
.Sp
Compress a domain name and append it to the buffer.
.Sp
.Vb 9
\&  input:        pointer to buffer,
\&                offset to insertion point,
\&        (usually end of buffer)
\&                pointer to name,
\&                pointer to array of offsets of
\&                  previously compressed names,
\&  returns:      new offset to end of buffer,
\&                updated array of offsets to 
\&                  previous compressed names,
\&
\&  NOTES:   1)   When the first domain name
\&                is compressed, the \e@dnptrs
\&                array is ommited. dn_comp
\&                will return an initialized
\&                array that can then be used
\&                for subsequent calls.
\&
\&          i.e.  initial call
\&
\&  ($newoff,@dnptrs)=dn_comp(\e$buffer,$offset,\e$name);
\&
\&           2) if \e@dnptrs is null, no compression takes place
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.Sp
Imported/Exported from NetAdder::IP::Util
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.Sp
Imported/Exported from NetAdder::IP::Util
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.Sp
Imported/Exported from NetAdder::IP::Util
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
.Ve
.Sp
Imported/Exported from NetAdder::IP::Util
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
.Ve
.Sp
Imported/Exported from NetAdder::IP::Util
.IP "\(bu" 4
\&\f(CW$timetxt\fR = sec2time($seconds);
.Sp
Convert numeric seconds into a string of the form
.Sp
.Vb 1
\&  NNw NNd NNh NNm NNs
.Ve
.Sp
for weeks, days, hours, minutes, seconds respectively.
.Sp
.Vb 2
\&  input:        seconds
\&  returns:      elapsed time text
.Ve
.IP "\(bu" 4
\&\f(CW$seconds\fR = ttlAlpha2Num($timetext);
.Sp
Convert a string of time text of the form
.Sp
.Vb 1
\&  NNw NNd NNh NNm NNs
.Ve
.Sp
into seconds. Upper case is \s-1OK.\s0
.Sp
.Vb 3
\&  input:        ttl in form numeric
\&                or alpha numeric
\&  returns:      seconds
.Ve
.IP "\(bu" 4
\&\f(CW$shorthost\fR = collapse($zonename,$longhost);
.Sp
Remove the zone portion of a fully qualified domain name and return the host
portion.
.Sp
.Vb 3
\&  input:        zone name,
\&                fqdn
\&  returns:      short host name
\&
\&  i.e.  zone = bar.com
\&        fqdn = foo.bar.com
\&
\&  foo = collapse(zone,fqdn);
.Ve
.Sp
Testing is not case sensitive.
If the fqdn does not end in the zone name then the fqdn is returned.
.IP "\(bu" 4
\&\f(CW$tag\fR = strip($P_tag);
.Sp
Remove the leading character(s) from a type/class label.
.Sp
.Vb 2
\&  input:     label  # like T_MX or C_IN
\&  returns:   tag    # MX, IN
.Ve
.IP "\(bu" 4
\&\f(CW@nameservers\fR = \fBget_ns()\fR;
.Sp
Return a list of name server addresses in packed network form for use by this host.
.IP "\(bu" 4
($secs,$usecs) = \fBgettimeofday()\fR;
.Sp
Returns a time value that is accurate to the nearest
microsecond but also has a range of years.
.Sp
.Vb 3
\&  input:    none
\&  returns:  seconds since epoch,
\&            microseconds (of current sec)
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module, type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.Vb 2
\&        perl 5.00503
\&        Net::DNS::Codes 0.06
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the \fBscripts\fR directory in this distribution
.IP "\(bu" 4
dig.pl
.Sp
A script that functions like \fBdig\fR in the \s-1BIND\s0 distribution. It provides
additional functionality in that it will dump the packet buffer contents for
inspection in debug mode. It is easily modified to add features.
.Sp
.Vb 2
\& Syntax:
\& dig.pl [@server] [+tcp] [\-d] [\-p port#] [\-t type] name
\&
\& server is the name or IP address of the name server to query.  An IPv4
\&        address can be provided in dotted\-decimal notation.  When the
\&        supplied server argument is a hostname, dig resolves that name
\&        before querying that name server.
\&
\&  +tcp  only use TCP protocol
\&
\&  \-d    print the query to the console
\&
\&  \-p    port# is the port number that dig.pl will send its queries 
\&        instead of the standard DNS port number 53.
\&
\&  \-t    indicates what type of query is required. This script supports
\&        only A, MX, NS, CNAME, SOA, TXT, and ANY queries as well as
\&        AXFR record transfers. If no type argument is supplied, dig.pl
\&        will perform a lookup for an A record
\&
\& name   is the name of the resource record that is to be looked up.
.Ve
.IP "\(bu" 4
rdns_blk.pl
.Sp
A script to lookup an entire class \*(L"C\*(R" set of \s-1PTR\s0 records recursively.
This is useful hunting spam domains where many \s-1DNS\s0's do not allow \s-1AXFR\s0
record transfers to inspect what is in a range of \s-1IP\s0 addresses.
.Sp
.Vb 2
\& Syntax:
\&  ./rdns_blk.pl nn.nn.nn[.nn]
\&
\&  at least the first three groups of 
\&  dot.quad.addr numbers
\&
\&  returns PTR results for 1..255 of address range
\&  skips non\-existent records, notes timeouts
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
get1char
get16
get32
put1char
put16
put32
getIPv4
putIPv4
getIPv6
putIPv6
getstring
putstring
dn_comp
dn_expand
parse_char
gethead
newhead
getflags
putflags
get_qdcount
get_ancount
get_nscount
get_arcount
put_qdcount
put_ancount
put_nscount
put_arcount
inet_aton
inet_ntoa
ipv6_aton
ipv6_n2x
ipv6_n2d   
sec2time
ttlAlpha2Num
collapse
strip
get_ns
gettimeofday
.SH "BUGS"
.IX Header "BUGS"
There have been some reports of the \*(L"C\*(R" library function for
.PP
.Vb 1
\&  "int res_init(void);
.Ve
.PP
not properly returning the local resolver nameserver configuration
information for certain Perl 5.6 \-> 5.8 hosts. This is for the ToolKit function \*(L"\fBget_ns()\fR\*(R".
.PP
I have been unable to duplicate this on any of the ix86 Linux or Sun-Sparc systems that I have. 
If you have a system that exhibits this problem and can provide a user account, I'd
appreciate it if you would contact me so I can fix it.
.PP
Update v0.38 Thu Oct  2 14:49:26 \s-1PDT 2008\s0
This may be an issue with sharing of the _\|_res_state structure. The update
uses a private _\|_res_state structure rather than the shared one and calling
res_ninit(*private_res). Hopefully this will fix the problem.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The following functions are used in whole or in part as include files to
ToolKit.xs. The copyrights are include in the respective files.
.PP
.Vb 1
\&  file:           functions:
\&
\&  dn_expand.inc   dn_expand
.Ve
.PP
dn_expand is from Michael Fuhr's Net::DNS package (\s-1DNS\s0.pm), copyright (c)
1997\-2002. Thank you Michael.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&    Copyright 2003 \- 2014, Michael Robinton <michael@bizsystems.com>
.Ve
.PP
Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        59 Temple Place, Suite 330
\&        Boston, MA  02111\-1307, USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "See also:"
.IX Header "See also:"
\&\fBNet::DNS::Codes\fR\|(3), \fBNet::DNS::ToolKit::RR\fR\|(3), \fBNet::DNS::ToolKit::Debug\fR\|(3),
Net::DNS::ToolKit::Utilities, NetAdder::IP::Util
