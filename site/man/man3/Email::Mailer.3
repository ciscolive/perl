.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Email::Mailer 3"
.TH Email::Mailer 3 "2020-09-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Email::Mailer \- Multi\-purpose emailer for HTML, auto\-text, attachments, and templates
.SH "VERSION"
.IX Header "VERSION"
version 1.15
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Email::Mailer;
\&    my ( $to, $from, $subject, $text, $html );
\&
\&    # send a simple text email
\&    Email::Mailer\->send(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        text    => $text,
\&    );
\&
\&    # send multi\-part HTML/text email with the text auto\-generated from the HTML
\&    # and images and other resources embedded in the email
\&    my $mail = Email::Mailer\->new;
\&    $mail\->send(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&    );
\&
\&    # send multi\-part HTML/text email with the text auto\-generated from the HTML
\&    # but skip embedding images and other resources
\&    Email::Mailer\->new\->send(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&        embed   => 0,
\&    );
\&
\&    # send multi\-part HTML/text email but supply the text explicitly
\&    Email::Mailer\->new(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&        text    => $text,
\&    )\->send;
\&
\&    # send multi\-part HTML/text email with a couple of attached files
\&    use IO::All \*(Aqio\*(Aq;
\&    Email::Mailer\->send(
\&        to          => $to,
\&        from        => $from,
\&        subject     => $subject,
\&        html        => $html,
\&        text        => $text,
\&        attachments => [
\&            {
\&                ctype  => \*(Aqapplication/pdf\*(Aq,
\&                source => \*(Aqfile.pdf\*(Aq,
\&            },
\&            {
\&                ctype    => \*(Aqapplication/pdf\*(Aq,
\&                content  => io(\*(Aqfile.pdf\*(Aq)\->binary\->all,
\&                encoding => \*(Aqbase64\*(Aq,
\&                name     => \*(Aqfile.pdf\*(Aq,
\&            },
\&        ],
\&    );
\&
\&    # build an email and iterate over a data set for sending
\&    Email::Mailer\->new(
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&    )\->send(
\&        { to => \*(Aqperson_0@example.com\*(Aq },
\&        { to => \*(Aqperson_1@example.com\*(Aq },
\&        {
\&            to      => \*(Aqperson_2@example.com\*(Aq,
\&            subject => \*(AqOverride $subject with this\*(Aq,
\&        },
\&    );
\&
\&    # setup a second mail object based on the first but changing the "from"
\&    my $mail_0 = Email::Mailer\->new(
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&    );
\&    my $mail_1 = $mail_0\->new( from => \*(Aqdifferent_address@example.com\*(Aq );
\&    $mail_0\->send;
\&    $mail_1\->send;
\&
\&    # use a templating system for the HTML and subject
\&    use Template;
\&    my $tt    = Template\->new;
\&    my $tmail = Email::Mailer\->new(
\&        from    => $from,
\&        subject => \e$subject,
\&        html    => \e$html,
\&        process => sub {
\&            my ( $template, $data ) = @_;
\&            my $content;
\&            $tt\->process( \e$template, $data, \e$content );
\&            return $content;
\&        },
\&    );
\&    $tmail\->send($_) for (
\&        { to => \*(Aqperson_0@example.com\*(Aq, data => { name => \*(AqPerson 0\*(Aq } },
\&        { to => \*(Aqperson_1@example.com\*(Aq, data => { name => \*(AqPerson 1\*(Aq } },
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Following the charter and example of Email::Simple, this module provides a
simple and flexible interface to sending various types of email including
plain text, HTML/text multi-part, attachment support, and template hooks.
The module depends on a series of great modules in the Email::* and HTML::*
namespaces.
.SH "PRIMARY METHODS"
.IX Header "PRIMARY METHODS"
There are 2 primary methods.
.SS "new"
.IX Subsection "new"
This is an instantiator and a replicative instantiator. If passed nothing, it'll
return you a blank mail object. If you pass it anything, it'll use that data to
setup a more informed mail object for later sending.
.PP
.Vb 2
\&    my $mail_blank = Email::Mailer\->new;
\&    my $mail_to    = Email::Mailer\->new( to => \*(Aqdefault_to@example.com\*(Aq);
.Ve
.PP
If you call \f(CW\*(C`new()\*(C'\fR off an instantiated mail object, it'll make a copy of that
object, changing any internal data based on what you pass in to the \f(CW\*(C`new()\*(C'\fR.
.PP
.Vb 2
\&    # create a new object with both a default "To" and "From"
\&    my $mail_to_from = $mail_to\->new( from => \*(Aqdefault_from@example.com\*(Aq );
.Ve
.SS "send"
.IX Subsection "send"
This method will attempt to send mail. Any parameters you can pass to \f(CW\*(C`new()\*(C'\fR
you can pass to \f(CW\*(C`send()\*(C'\fR. Any incoming parameters will override any existing
parameters in an instantiated object.
.PP
.Vb 4
\&    $mail_to_from\->send(
\&        subject => \*(AqExample Subject Line\*(Aq,
\&        text    => \*(AqHello. This is example email content.\*(Aq,
\&    );
.Ve
.PP
If \f(CW\*(C`send()\*(C'\fR succeeds, it'll return an instantiated object based on the combined
parameters. If it fails, it'll throw an exception.
.PP
.Vb 1
\&    use Try::Tiny;
\&
\&    my $mail_with_all_the_parameters;
\&    try {
\&        $mail_with_all_the_parameters = $mail_to_from\->send(
\&            subject => \*(AqExample Subject Line\*(Aq,
\&            text    => \*(AqHello. This is example email content.\*(Aq,
\&        );
\&    }
\&    catch {
\&        print "There was an error, but I\*(Aqm going to ignore it and keep going.\en";
\&    };
.Ve
.PP
You can also pass to \f(CW\*(C`send()\*(C'\fR a list of hashrefs. If you do that, \f(CW\*(C`send()\*(C'\fR
will assume you want each of the hashrefs to be like a set of data sent to an
independent call to \f(CW\*(C`send()\*(C'\fR. The method will attempt to send multiple emails
based on your data, and it'll return an array or arrayref (based on context)
of the mail objects ultimately created.
.PP
.Vb 4
\&    my @emails_sent = $mail_with_all_the_parameters\->send(
\&        { to => \*(Aqperson_0@example.com\*(Aq },
\&        { to => \*(Aqperson_1@example.com\*(Aq },
\&    );
\&
\&    my $emails_sent = $mail_with_all_the_parameters\->send(
\&        { to => \*(Aqperson_0@example.com\*(Aq },
\&        { to => \*(Aqperson_1@example.com\*(Aq },
\&    );
\&
\&    $mail_with_all_the_parameters\->send($_) for (
\&        { to => \*(Aqperson_0@example.com\*(Aq },
\&        { to => \*(Aqperson_1@example.com\*(Aq },
\&    );
.Ve
.SH "PARAMETERS"
.IX Header "PARAMETERS"
There are a bunch of parameters you can pass to the primary methods. First off,
anything not explicitly mentioned in this section, the methods will assume is
a mail header.
.PP
If any value of a key is a reference to scalar text, the value of that scalar
text will be assumed to be a template and processed through the subref defined
by the \*(L"process\*(R" parameter.
.SS "html"
.IX Subsection "html"
This parameter should contain \s-1HTML\s0 content (or a reference to scalar text that
is the template that'll be used to generate \s-1HTML\s0 content).
.SS "text"
.IX Subsection "text"
This parameter should contain plain text content (or a template reference). If
not provided then \*(L"text\*(R" will be automatically generated based on the \*(L"html\*(R"
content.
.PP
By default, the text generated will be wrapped at 72 characters width. However,
you can override that by setting width explicitly:
.PP
.Vb 7
\&    Email::Mailer\->new\->send(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&        width   => 120,
\&    );
.Ve
.PP
If you set a width to 0, this will be interpreted as meaning not to wrap text
lines.
.SS "embed"
.IX Subsection "embed"
By default, if your \s-1HTML\s0 has links to things like images or \s-1CSS,\s0 those resources
will be pulled in and embedded into the email message. If you don't want that
behavior, turn it off by explicitly setting \*(L"embed\*(R" to a false value.
.PP
.Vb 7
\&    Email::Mailer\->new\->send(
\&        to      => $to,
\&        from    => $from,
\&        subject => $subject,
\&        html    => $html,
\&        embed   => 0,
\&    );
.Ve
.SS "attachments"
.IX Subsection "attachments"
This parameter if needed should be an arrayref of hashrefs that define the
attachments to add to an email. Each hashref should define a \*(L"ctype\*(R" for the
content type of the attachment and either a \*(L"source\*(R" or both a \*(L"name\*(R" and
\&\*(L"content\*(R" key. The \*(L"source\*(R" value should be a local relative path/file. The
\&\*(L"content\*(R" value should be binary data, and the \*(L"name\*(R" value should be the
filename of the attachment.
.PP
.Vb 1
\&    use IO::All \*(Aqio\*(Aq;
\&
\&    Email::Mailer\->send(
\&        to          => $to,
\&        from        => $from,
\&        subject     => $subject,
\&        html        => $html,
\&        text        => $text,
\&        attachments => [
\&            {
\&                ctype  => \*(Aqapplication/pdf\*(Aq,
\&                source => \*(Aqfile.pdf\*(Aq,
\&            },
\&            {
\&                ctype    => \*(Aqapplication/pdf\*(Aq,
\&                content  => io(\*(Aqfile.pdf\*(Aq)\->binary\->all,
\&                encoding => \*(Aqbase64\*(Aq,
\&                name     => \*(Aqfile.pdf\*(Aq,
\&            },
\&        ],
\&    );
.Ve
.PP
An optional parameter of \*(L"encoding\*(R" can be supplied in a hashref to
\&\*(L"attachments\*(R" to indicate what encoding the attachment should be encoded as.
If not specified, the default is \*(L"base64\*(R" encoding, which works in most cases.
Another popular choice is \*(L"quoted-printable\*(R".
.SS "process"
.IX Subsection "process"
This parameter expects a subref that will be called to process any templates.
You can hook in any template system you'd like. The subref will be passed the
template text and a hashref of the data for the message.
.PP
.Vb 1
\&    use Template;
\&
\&    my $tt    = Template\->new;
\&    my $tmail = Email::Mailer\->new(
\&        from    => $from,
\&        subject => \e$subject,
\&        html    => \e$html,
\&        process => sub {
\&            my ( $template, $data ) = @_;
\&            my $content;
\&            $tt\->process( \e$template, $data, \e$content );
\&            return $content;
\&        },
\&    );
.Ve
.SS "data"
.IX Subsection "data"
This parameter is the hashref of data that'll get passed to the \*(L"process\*(R"
subref.
.PP
.Vb 4
\&    $tmail\->send($_) for (
\&        { to => \*(Aqperson_0@example.com\*(Aq, data => { name => \*(AqPerson 0\*(Aq } },
\&        { to => \*(Aqperson_1@example.com\*(Aq, data => { name => \*(AqPerson 1\*(Aq } },
\&    );
.Ve
.SS "transport"
.IX Subsection "transport"
By default, this module will try to pick an appropriate transport. (Well,
technically, Email::Sender::Simple does that for us.) If you want to override
that and set your own transport, use the \*(L"transport\*(R" parameter.
.PP
.Vb 1
\&    use Email::Sender::Transport::SMTP;
\&
\&    Email::Mailer\->send(
\&        to        => $to,
\&        from      => $from,
\&        subject   => $subject,
\&        html      => $html,
\&        transport => Email::Sender::Transport::SMTP\->new({
\&            host => \*(Aqsmtp.example.com\*(Aq,
\&            port => 25,
\&        }),
\&    );
.Ve
.SH "AUTOMATIC HEADER-IFICATION"
.IX Header "AUTOMATIC HEADER-IFICATION"
There are some automatic header-ification features to be aware of. Unless you
specify a value, the \f(CW\*(C`Content\-Type\*(C'\fR and \f(CW\*(C`Content\-Transfer\-Encoding\*(C'\fR are
set as \*(L"text/plain; charset=us\-ascii\*(R" and \*(L"quoted-printable\*(R" respectively, as
if you set the following:
.PP
.Vb 5
\&    Email::Mailer\->send(
\&        to        => $to,
\&        from      => $from,
\&        subject   => $subject,
\&        html      => $html,
\&
\&        \*(AqContent\-Type\*(Aq              => \*(Aqtext/plain; charset=us\-ascii\*(Aq,
\&        \*(AqContent\-Transfer\-Encoding\*(Aq => \*(Aqquoted\-printable\*(Aq,
\&    );
.Ve
.PP
Also, normally your \f(CW\*(C`to\*(C'\fR, \f(CW\*(C`from\*(C'\fR, and \f(CW\*(C`subject\*(C'\fR values are left untouched;
however, for any of these that contain non-ASCII characters, they will be
mimewords-encoded via MIME::Words using the character set defined in
\&\f(CW\*(C`Content\-Type\*(C'\fR. If you don't like how that works, just encode them however
you'd like to \s-1ASCII.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Email::MIME, Email::MIME::CreateHTML, Email::Sender::Simple,
Email::Sender::Transport, HTML::FormatText, HTML::TreeBuilder.
.PP
You can also look for additional information at:
.IP "\(bu" 4
GitHub <https://github.com/gryphonshafer/Email-Mailer>
.IP "\(bu" 4
MetaCPAN <https://metacpan.org/pod/Email::Mailer>
.IP "\(bu" 4
Travis \s-1CI\s0 <https://travis-ci.org/gryphonshafer/Email-Mailer>
.IP "\(bu" 4
Coveralls <https://coveralls.io/r/gryphonshafer/Email-Mailer>
.IP "\(bu" 4
\&\s-1CPANTS\s0 <http://cpants.cpanauthors.org/dist/Email-Mailer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers <http://www.cpantesters.org/distro/D/Email-Mailer.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Gryphon Shafer <gryphon@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Gryphon Shafer.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
