.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Type::Guess 3"
.TH SQL::Type::Guess 3 "2018-12-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Type::Guess \- guess an appropriate column type for a set of data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    my @data=(
\&      { seen => 1, when => \*(Aq20140401\*(Aq, greeting => \*(AqHello\*(Aq, value => \*(Aq1.05\*(Aq  },
\&      { seen => 0, when => \*(Aq20140402\*(Aq, greeting => \*(AqWorld\*(Aq, value => \*(Aq99.05\*(Aq },
\&      { seen => 0, when => \*(Aq20140402\*(Aq, greeting => \*(AqWorld\*(Aq, value => \*(Aq9.005\*(Aq },
\&    );
\&
\&    my $g= SQL::Type::Guess\->new();
\&    $g\->guess( @data );
\&
\&    print $g\->as_sql( table => \*(Aqtest\*(Aq );
\&    # create table test (
\&    #    "seen" decimal(1,0),
\&    #    "greeting" varchar(5),
\&    #    "value" decimal(5,3),
\&    #    "when" date
\&    # )
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """SQL:::Type::Guess\->new( %OPTIONS )"""
.el .SS "\f(CWSQL:::Type::Guess\->new( %OPTIONS )\fP"
.IX Subsection "SQL:::Type::Guess->new( %OPTIONS )"
.Vb 1
\&  my $g= SQL::Type::Guess\->new();
.Ve
.PP
Creates a new \f(CW\*(C`SQL::Type::Guess\*(C'\fR instance. The following options are
supported:
.IP "\fBcolumn_type\fR" 4
.IX Item "column_type"
Hashref of already known column types.
.IP "\fBcolumn_map\fR" 4
.IX Item "column_map"
Hashref mapping the combinations \s-1SQL\s0 type names
to the resulting type name.
.ie n .SS """$g\->column_type"""
.el .SS "\f(CW$g\->column_type\fP"
.IX Subsection "$g->column_type"
.Vb 2
\&    $g\->guess({ foo => 1, bar => \*(AqHello\*(Aq },{ foo => 1000, bar => \*(AqWorld\*(Aq });
\&    print $g\->column_type\->{ \*(Aqfoo\*(Aq } # decimal(4,0)
.Ve
.PP
Returns a hashref containing the \s-1SQL\s0 types to store all
values in the columns seen so far.
.ie n .SS """$g\->column_map"""
.el .SS "\f(CW$g\->column_map\fP"
.IX Subsection "$g->column_map"
Returns the hashref used for the type transitions. The current
transitions used for generalizing data are:
.PP
.Vb 1
\&  date \-> decimal \-> varchar
.Ve
.PP
This is not entirely safe, as \f(CW\*(C`2014\-01\-01\*(C'\fR can't be safely
loaded into an \f(CW\*(C`decimal\*(C'\fR column, but assuming your data is representative
of the data to be stored that shouldn't be much of an issue.
.ie n .SS """$g\->guess_data_type $OLD_TYPE, @VALUES"""
.el .SS "\f(CW$g\->guess_data_type $OLD_TYPE, @VALUES\fP"
.IX Subsection "$g->guess_data_type $OLD_TYPE, @VALUES"
.Vb 1
\&    $type= $g\->guess_data_type( $type, 1,2,3,undef,\*(AqHello\*(Aq,\*(AqWorld\*(Aq, );
.Ve
.PP
Returns the data type that encompasses the already established data type in \f(CW$type\fR
and the new values as passed in via \f(CW@values\fR.
.PP
If there is no preexisting data type, \f(CW$type\fR can be \f(CW\*(C`undef\*(C'\fR or the empty string.
.ie n .SS """$g\->guess( @RECORDS )"""
.el .SS "\f(CW$g\->guess( @RECORDS )\fP"
.IX Subsection "$g->guess( @RECORDS )"
.Vb 6
\&    my @data= (
\&        { rownum => 1, name => \*(AqJohn Smith\*(Aq, street => \*(AqNowhere Road\*(Aq, birthday => \*(Aq1996\-01\-01\*(Aq },
\&        { rownum => 2, name => \*(AqJohn Doe\*(Aq, street => \*(AqAnywhere Plaza\*(Aq, birthday => \*(Aq1904\-01\-01\*(Aq },
\&        { rownum => 3, name => \*(AqJohn Bull\*(Aq, street => \*(AqEverywhere Street\*(Aq, birthday => \*(Aq2001\-09\-01\*(Aq },
\&    );
\&    $g\->guess( @data );
.Ve
.PP
Modifies the data types for the keys in the given hash.
.ie n .SS """$g\->as_sql %OPTIONS"""
.el .SS "\f(CW$g\->as_sql %OPTIONS\fP"
.IX Subsection "$g->as_sql %OPTIONS"
.Vb 1
\&    print $g\->as_sql();
.Ve
.PP
Returns an \s-1SQL\s0 string that describes the data seen so far.
.PP
Options:
.IP "\fBuser\fR" 4
.IX Item "user"
Supply a username for the table
.IP "\fBcolumns\fR" 4
.IX Item "columns"
This allows you to specify the columns and their order. The default
is alphabetical order of the columns.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=SQL\-Type\-Guess>
or via mail to sql\-type\-guess\-Bugs@rt.cpan.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2014\-2018 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
