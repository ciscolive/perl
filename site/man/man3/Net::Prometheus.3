.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Prometheus 3"
.TH Net::Prometheus 3 "2020-07-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Net::Prometheus" \- export monitoring metrics for prometheus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Net::Prometheus;
\&
\&   my $client = Net::Prometheus\->new;
\&
\&   my $counter = $client\->new_counter(
\&      name => "requests",
\&      help => "Number of received requests",
\&   );
\&
\&   sub handle_request
\&   {
\&      $counter\->inc;
\&      ...
\&   }
\&
\&   use Plack::Builder;
\&
\&   builder {
\&      mount "/metrics" => $client\->psgi_app;
\&      ...
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the ability for a program to collect monitoring metrics
and export them to the \fIprometheus.io\fR monitoring server.
.PP
As \f(CW\*(C`prometheus\*(C'\fR will expect to collect the metrics by making an \s-1HTTP\s0 request,
facilities are provided to yield a \s-1PSGI\s0 application that the containing
program can embed in its own structure to provide the results, or the
application can generate a plain-text result directly and serve them by its
own means.
.SS "Metrics::Any"
.IX Subsection "Metrics::Any"
For more flexibility of metrics reporting, other modules may wish to use
Metrics::Any as an abstraction interface instead of directly using this
\&\s-1API.\s0
.PP
By using \f(CW\*(C`Metrics::Any\*(C'\fR instead, the module does not directly depend on
\&\f(CW\*(C`Net::Prometheus\*(C'\fR, and in addition program ultimately using the module gets
the flexibility to use Prometheus (via Metrics::Any::Adapter::Prometheus)
or use another reporting system via a different adapter.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\&   $prometheus = Net::Prometheus\->new;
.Ve
.PP
Returns a new \f(CW\*(C`Net::Prometheus\*(C'\fR instance.
.PP
Takes the following named arguments:
.IP "disable_process_collector => \s-1BOOL\s0" 4
.IX Item "disable_process_collector => BOOL"
If present and true, this instance will not load the default process collector
from Net::Prometheus::ProcessCollector. If absent or false, such a
collector will be loaded by default.
.IP "disable_perl_collector => \s-1BOOL\s0" 4
.IX Item "disable_perl_collector => BOOL"
If present and true, this instance will not load perl-specific collector from
Net::Prometheus::PerlCollector. If absent or false this collector is loaded
by default.
.Sp
These two options are provided for testing purposes, or for specific use-cases
where such features are not required. Usually it's best just to leave these
enabled.
.SH "METHODS"
.IX Header "METHODS"
.SS "register"
.IX Subsection "register"
.Vb 1
\&   $collector = $prometheus\->register( $collector )
.Ve
.PP
Registers a new collector to be collected from by the \f(CW\*(C`render\*(C'\fR
method. The collector instance itself is returned, for convenience.
.SS "unregister"
.IX Subsection "unregister"
.Vb 1
\&   $prometheus\->unregister( $collector )
.Ve
.PP
Removes a previously-registered collector.
.SS "new_gauge"
.IX Subsection "new_gauge"
.Vb 1
\&   $gauge = $prometheus\->new_gauge( %args )
.Ve
.PP
Constructs a new Net::Prometheus::Gauge using the arguments given and
registers it with the exporter. The newly-constructed gauge is returned.
.SS "new_counter"
.IX Subsection "new_counter"
.Vb 1
\&   $counter = $prometheus\->new_counter( %args )
.Ve
.PP
Constructs a new Net::Prometheus::Counter using the arguments given and
registers it with the exporter. The newly-constructed counter is returned.
.SS "new_summary"
.IX Subsection "new_summary"
.Vb 1
\&   $summary = $prometheus\->new_summary( %args )
.Ve
.PP
Constructs a new Net::Prometheus::Summary using the arguments given
and registers it with the exporter. The newly-constructed summary is returned.
.SS "new_histogram"
.IX Subsection "new_histogram"
.Vb 1
\&   $histogram = $prometheus\->new_histogram( %args )
.Ve
.PP
Constructs a new Net::Prometheus::Histogram using the arguments given
and registers it with the exporter. The newly-constructed histogram is
returned.
.SS "new_metricgroup"
.IX Subsection "new_metricgroup"
.Vb 1
\&   $group = $prometheus\->new_metricgroup( %args )
.Ve
.PP
Returns a new Metric Group instance as a convenience for registering multiple
metrics using the same \f(CW\*(C`namespace\*(C'\fR and \f(CW\*(C`subsystem\*(C'\fR arguments. Takes the
following named arguments:
.IP "namespace => \s-1STR\s0" 4
.IX Item "namespace => STR"
.PD 0
.IP "subsystem => \s-1STR\s0" 4
.IX Item "subsystem => STR"
.PD
String values to pass by default into new metrics the group will construct.
.PP
Once constructed, the group acts as a proxy to the other \f(CW\*(C`new_*\*(C'\fR methods,
passing in these values as overrides.
.PP
.Vb 4
\&   $gauge = $group\->new_gauge( ... )
\&   $counter = $group\->new_counter( ... )
\&   $summary = $group\->new_summary( ... )
\&   $histogram = $group\->new_histogram( ... )
.Ve
.SS "collect"
.IX Subsection "collect"
.Vb 1
\&   @metricsamples = $prometheus\->collect( $opts )
.Ve
.PP
Returns a list of \*(L"MetricSamples\*(R" in Net::Prometheus::Types obtained from all
of the currently-registered collectors.
.SS "render"
.IX Subsection "render"
.Vb 1
\&   $str = $prometheus\->render
.Ve
.PP
Returns a string in the Prometheus text exposition format containing the
current values of all the registered metrics.
.PP
.Vb 1
\&   $str = $prometheus\->render( { options => "for collectors" } )
.Ve
.PP
An optional \s-1HASH\s0 reference may be provided; if so it will be passed into the
\&\f(CW\*(C`collect\*(C'\fR method of every registered collector.
.SS "handle"
.IX Subsection "handle"
.Vb 1
\&   $response = $prometheus\->handle( $request )
.Ve
.PP
Given an \s-1HTTP\s0 request in an HTTP::Request instance, renders the metrics in
response to it and returns an HTTP::Response instance.
.PP
This application will respond to any \f(CW\*(C`GET\*(C'\fR request, and reject requests for
any other method. If a query string is present on the \s-1URI\s0 it will be parsed
for collector options to pass into the \*(L"render\*(R" method.
.PP
This method is useful for integrating metrics into an existing \s-1HTTP\s0 server
application which uses these objects. For example:
.PP
.Vb 1
\&   my $prometheus = Net::Prometheus\->new;
\&
\&   sub serve_request
\&   {
\&      my ( $request ) = @_;
\&
\&      if( $request\->uri\->path eq "/metrics" ) {
\&         return $prometheus\->handle( $request );
\&      }
\&
\&      ...
\&   }
.Ve
.SS "psgi_app"
.IX Subsection "psgi_app"
.Vb 1
\&   $app = $prometheus\->psgi_app
.Ve
.PP
Returns a new \s-1PSGI\s0 application as a \f(CW\*(C`CODE\*(C'\fR reference. This application
will render the metrics in the Prometheus text exposition format, suitable for
scraping by the Prometheus collector.
.PP
This application will respond to any \f(CW\*(C`GET\*(C'\fR request, and reject requests for
any other method. If a \f(CW\*(C`QUERY_STRING\*(C'\fR is present in the environment it will
be parsed for collector options to pass into the \*(L"render\*(R" method.
.PP
This method is useful for integrating metrics into an existing \s-1HTTP\s0 server
application which is uses or is based on \s-1PSGI.\s0 For example:
.PP
.Vb 1
\&   use Plack::Builder;
\&
\&   my $prometheus = Net::Prometheus::\->new;
\&
\&   builder {
\&      mount "/metrics" => $prometheus\->psgi_app;
\&      ...
\&   }
.Ve
.SS "export_to_IO_Async"
.IX Subsection "export_to_IO_Async"
.Vb 1
\&   $prometheus\->export_to_IO_Async( $loop, %args )
.Ve
.PP
Performs the necessary steps to create an \s-1HTTP\s0 server for exporting metrics
over \s-1HTTP\s0 via IO::Async. This will involve creating a new
Net::Async::HTTP::Server instance added to the loop.
.PP
This new server will listen on its own port number for any incoming request,
and will serve metrics regardless of path.
.PP
Note this should only be used in applications that don't otherwise have an
\&\s-1HTTP\s0 server, such as self-contained monitoring exporters or exporting metrics
as a side-effect of other activity. For existing \s-1HTTP\s0 server applications it
is better to integrate with the existing request/response processing of the
application, such as by using the \*(L"handle\*(R" or \*(L"psgi_app\*(R" methods.
.PP
Takes the following named arguments:
.IP "port => \s-1INT\s0" 4
.IX Item "port => INT"
Port number on which to listen for incoming \s-1HTTP\s0 requests.
.SH "COLLECTORS"
.IX Header "COLLECTORS"
The toplevel \f(CW\*(C`Net::Prometheus\*(C'\fR object stores a list of \*(L"collector\*(R" instances,
which are used to generate the values that will be made visible via the
\&\*(L"render\*(R" method. A collector can be any object instance that has a method
called \f(CW\*(C`collect\*(C'\fR, which when invoked is passed no arguments and expected to
return a list of \*(L"MetricSamples\*(R" in Net::Prometheus::Types structures.
.PP
.Vb 1
\&   @metricsamples = $collector\->collect( $opts )
.Ve
.PP
The Net::Prometheus::Metric class is already a valid collector (and hence,
so too are the individual metric type subclasses). This interface allows the
creation of new custom collector objects, that more directly collect
information to be exported.
.PP
Collectors might choose to behave differently in the presence of some
specifically-named option; typically to provide extra detail not normally
provided (maybe at the expense of extra processing time to calculate it).
Collectors must not complain about the presence of unrecognised options; the
hash is shared among all potential collectors.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 8
Histogram/Summary 'start_timer' support
.IP "\(bu" 8
Add other \f(CW\*(C`export_to_*\*(C'\fR methods for other event systems and HTTP-serving
frameworks, e.g. Mojo.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
