.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Template 3"
.TH Template 3 "2003-09-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::ToolKit::RR::Template \- template for resource records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This file is a template from which to create new resource record
manipulation methods. While these modules may be loaded directly for
testing, they are intended to be loaded by the class loader
\&\fBNet::DNS::ToolKit::RR\fR. The \s-1SYNOPSIS\s0 section of specific \s-1RR\s0 documentation
should begin with the caveat:
.PP
\&\fIedit this text to conform to your \s-1RR\s0 method\fR
.PP
.Vb 2
\&  DO NOT use Net::DNS::ToolKit::RR::XYZ
\&  DO NOT require Net::DNS::ToolKit::RR::XYZ
\&
\&  Net::DNS::ToolKit::RR::XYZ is autoloaded by 
\&  class Net::DNS::ToolKit::RR and its methods
\&  are instantiated in a \*(Aqspecial\*(Aq manner.
\&
\&  use Net::DNS::ToolKit::RR;
\&  ($get,$put,$parse) = new Net::DNS::ToolKit::RR;
\&
\&  ($newoff,$name,$type,$class,$ttl,$rdlength,
\&        $rdata,...) = $get\->XYZ(\e$buffer,$offset);
\&
\&  Note: the $get\->XYZ method is normally called
\&  via:  @stuff = $get\->next(\e$buffer,$offset);
\&
\&  ($newoff,@dnptrs)=$put\->XYZ(\e$buffer,$offset,\e@dnptrs,
\&        $name,$type,$class,$ttl,$rdata,...);
\&
\&  $NAME,$TYPE,$CLASS,$TTL,$rdlength,$RDATA) 
\&    = $parse\->XYZ($name,$type,$class,$ttl,$rdlength,
\&        $rdata,...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNet::DNS::ToolKit::RR:XYZ\fR appends an \s-1XYZ\s0 resource record to a \s-1DNS\s0 packet under
construction, recovers an \s-1XYZ\s0 resource record from a packet being decoded, and 
converts the numeric/binary portions of the resource record to human
readable form.
.PP
Description from \s-1RFC1035\s0.txt or other specification document.
.PP
\&\fIedit this text to conform to your \s-1RR\s0 method\fR
.PP
See: \fINet::DNS::ToolKit::RR::A\fR and \fINet::DNS::ToolKit::RR::SOA\fR for
examples.
.PP
Each \s-1RR\s0 module contains three methods which provide the \s-1RR\s0 specific
content manipulation. The data common to all resource modules is handled
from within the class loader prior to handing the request over the the
specific resource record method. Because of this, the \s-1DESCRIPTION\s0 of the
method action is somewhat misleading. As an example, lets dissect the 'parse' method:
.PP
.Vb 3
\&  $NAME,$TYPE,$CLASS,$TTL,$rdlength,$RDATA,...) 
\&    = $parse\->XYZ($name,$type,$class,$ttl,$rdlength,
\&        $rdata,...);
.Ve
.PP
The common elements for all resource records are:
.PP
.Vb 1
\&  $name,$type,$class,$ttl,$rdlength
.Ve
.PP
These are handled by the class loader and the local method actually only
receives a request to provide the '$rdata' portion. While the description of
the method as called from the user program is as above, the implementation
looks like this for and 'A' resource record. The \f(CW$rdata\fR is handled as
follows:
.PP
.Vb 1
\&  $IPaddr = $classloader\->A($netaddr);
\&
\&  sub parse {
\&    shift;      # $self
\&    inet_ntoa($netaddr);
\&  }
.Ve
.PP
As you can see, all that is passed to the 'parse' method is the \f(CW$rdata\fR
portion of the request. 'parse' returns the ascii 'dotquad' \s-1IP\s0 address.
.PP
The actual \s-1DESCRIPTION\s0 from \fBNet::DNS::ToolKit::RR::A\fR follows with
annotation about the \s-1CODE\s0 and what is passed to all resource methods from
the class loader.
.PP
The rest of this Template example is taken \s-1DIRECTLY\s0 from
\&\fBNet::DNS::ToolKit::RR::A\fR, with comments added for clarity and to show the
\&\s-1CODE.\s0
.IP "\(bu" 4
\&\f(CW@stuff\fR = \f(CW$get\fR\->A(\e$buffer,$offset);
.Sp
.Vb 1
\&  Get the contents of the resource record.
\&
\&  USE: @stuff = $get\->next(\e$buffer,$offset);
\&
\&  where: @stuff = (
\&  $newoff $name,$type,$class,$ttl,$rdlength,
\&  $netaddr );
.Ve
.Sp
All except the last item, \fB\f(CB$netaddr\fB\fR, is provided by
the class loader, \fBNet::DNS::ToolKit::RR\fR. The code in this method knows
how to retrieve \fB\f(CB$netaddr\fB\fR.
.Sp
.Vb 6
\&  input:        pointer to buffer,
\&                offset into buffer
\&  returns:      offset to next resource,
\&                @common RR elements,
\&                packed IPv4 address 
\&                  in network order
\&
\&  NOTE: convert IPv4 address to dot quad text
\&        using Net::DNS::ToolKit::inet_ntoa
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  The get function is passed a pointer to the buffer
\&  and an offset within the buffer to RDATA. It is
\&  expected to return the RDATA in the appropriate
\&  format as provided in the relevant RFC.
.Ve
.Sp
The call to 'get' from the class loader looks like this:
.Sp
.Vb 1
\&  $netaddr = $classloader\->get(\e$buffer,$offset);
.Ve
.Sp
Implementation for A \s-1RR\s0's:
.Sp
.Vb 6
\&  sub get {
\&    my($self,$bp,$offset) = @_;
\&    $offset += INT16SZ; # don\*(Aqt need rdlength
\&    my($netaddr,$newoff) = getIPv4($bp,$offset);
\&    return ($newoff,$netaddr);
\&  }
.Ve
.IP "\(bu" 4
($newoff,@dnptrs)=$put\->A(\e$buffer,$offset,\e@dnptrs,
	\f(CW$name\fR,$type,$class,$ttl,$netaddr);
.Sp
Append an A record to \f(CW$buffer\fR.
.Sp
.Vb 2
\&  where @common = (
\&        $name,$type,$class,$ttl);
.Ve
.Sp
The method will insert the \f(CW$rdlength\fR and \f(CW$netaddr\fR, then
pass through the updated pointer to the array of compressed names
.Sp
The class loader, \fBNet::DNS::ToolKit::RR\fR, inserts the \f(CW@common\fR elements and
returns updated \f(CW@dnptrs\fR. This module knows how to insert its \s-1RDATA\s0 and
calculate the \f(CW$rdlength\fR.
.Sp
.Vb 9
\&  input:        pointer to buffer,
\&                offset (normally end of buffer), 
\&                pointer to compressed name array,
\&                @common RR elements,
\&                packed IPv4 address
\&                  in network order
\&  output:       offset to next RR,
\&                new compressed name pointer array,
\&           or   empty list () on error.
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.Sp
The put function is passed a pointer to the buffer an offset into the buffer
(normally the end of buffer) and a pointer to an array of previously
compressed names. It is expected to append the correct \s-1RDLENGTH\s0 and 
\&\s-1RDATA\s0 to the buffer and return an offset to the next \s-1RR\s0 (usually the end of
buffer) as well as a new array of compressed names
or the one to which it has a pointer if there are no names added to the
buffer by this \s-1RR\s0 record method.
.Sp
The call passed to 'put' by the class loader looks like this:
.Sp
.Vb 1
\&  $newoff = $classloader\->put(\e$buffer,$offset,\e@dnptrs,@rdata);
.Ve
.Sp
Implementation for A \s-1RR\s0's:
.Sp
.Vb 7
\&  sub put {
\&    return () unless @_;        # always return on error
\&    my($self,$bp,$off,$dnp,$netaddr) = @_;
\&    return () unless  
\&        ($off = put16($bp,$off,NS_INADDRSZ));
\&    return(putIPv4($bp,$off,$netaddr), @$dnp);
\&  }
.Ve
.Sp
Implementation for \s-1NS RR\s0's: This method calculates \f(CW$rdlength\fR
.Sp
.Vb 12
\&  sub put {
\&    return () unless @_;    # always return on error
\&    my($self,$bp,$off,$dnp,$nsdname) = @_;
\&    my $rdlp = $off;        # save pointer to rdlength
\&    return () unless        # check for valid offset and get
\&      ($off = put16($bp,$off,0)) &&   # offset to name space
\&      (@_ = dn_comp($bp,$off,\e$nsdname,$dnp));
\&    # new offset is first item in @_
\&    # rdlength = new offset \- previous offset
\&    put16($bp,$rdlp, $_[0] \- $off); 
\&    return @_;
\&  }
.Ve
.IP "\(bu" 4
(@COMMON,$IPaddr) = \f(CW$parse\fR\->A(@common,$netaddr);
.Sp
Converts binary/numeric field data into human readable form. The common \s-1RR\s0
elements are supplied by the class loader, \fBNet::DNS::ToolKit::RR\fR. This 
module knows how to parse its \s-1RDATA.\s0
.Sp
.Vb 2
\&        EXAMPLE
\&Common is: name,$type,$class,$ttl,$rdlength
\&
\&  name       \*(Aq.\*(Aq is appended
\&  type       numeric to text 
\&  class      numeric to text 
\&  ttl        numeric to text
\&  rdlength   is a number
\&  rdata      RR specific conversion
.Ve
.Sp
Resource Record \fBA\fR returns \f(CW$rdata\fR containing a packed IPv4 network
address. The parse operation would be:
.Sp
input:
.Sp
.Vb 6
\&  name       foo.bar.com
\&  type       1  
\&  class      1  
\&  ttl        123
\&  rdlength   4  
\&  rdata      a packed IPv4 address
.Ve
.Sp
output:
.Sp
.Vb 6
\&  name       foo.bar.com
\&  type       T_A 
\&  class      C_IN
\&  ttl        2m 3s
\&  rdlength   4   
\&  rdata      192.168.20.40
\&
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  The parse function is passed the RDATA for its type.
\&  It expected to convert the RDATA into human readable
\&  form and return it.
\&
\&  $IPaddress = $classloader\->parse($netaddr);
.Ve
.Sp
Implementation for A \s-1RR\s0's:
.Sp
.Vb 4
\&  sub parse {
\&    shift;      # $self
\&    inet_ntoa(shift);
\&  }
.Ve
.Sp
\&\s-1NOTE:\s0 while the \fBA\fR record does not return domain records, it is important
that developers remember to append a '.' to domain names which are text
formatted. i.e. foo.bar.com becomes foo.bar.com. when text formatted to
conform the record format for \s-1DNS\s0 files.
.SH "CODE for THIS MODULE"
.IX Header "CODE for THIS MODULE"
The code in this module (for an 'A' resource record) without the comments is
pretty compact and looks like this:
.PP
.Vb 1
\&  package Net::DNS::ToolKit::RR::A;
\&
\&  use strict;
\&  use Carp;
\&  # The functions needed for \*(AqA\*(Aq records
\&  # are \*(Aqput16\*(Aq, \*(AqgetIPv4\*(Aq, putIPv4, inet_aton,
\&  # and inet_ntoa.  Other RR types will need 
\&  # different and/or additional functions. 
\&
\&  use Net::DNS::ToolKit qw(
\&        put16
\&        getIPv4
\&        putIPv4
\&        inet_aton
\&        inet_ntoa
\&  );
\&  use Net::DNS::Codes qw(:constants);
\&  use vars qw($VERSION);
\&  require Socket;
\&
\&  $VERSION = do { my @r = (q$Revision: 0.01 $ =~ /\ed+/g); sprintf "%d."."%02d" x $#r, @r };
\&
\&  =head1 NAME
\&  B<Net::DNS::ToolKit::RR::A>
\&
\&  =head1 SYNOPSIS
\&        (removed for brevity)
\&
\&  =head1 DESCRIPTION
\&        (removed for brevity)
\&
\&  =over 4
\&
\&  =item * @stuff = $get\->A(\e$buffer,$offset);
\&        (removed for brevity)
\&
\&  =cut
\&
\&  sub get {
\&    my($self,$bp,$offset) = @_;
\&    $offset += INT16SZ; # don\*(Aqt need rdlength
\&    my($netaddr,$newoff) = getIPv4($bp,$offset);
\&    return ($newoff,$netaddr);
\&  }
\&
\&  =item * ($newoff,@dnptrs)=$put\->A(\e$buffer,$offset,\e@dnptrs,
\&        @common, $rdlength,$netaddr);  
\&        (removed for brevity)
\&
\&  sub put {
\&    return () unless @_;        # always return on error
\&    my($self,$bp,$off,$dnp,$netaddr) = @_;
\&    return () unless  
\&        ($off = put16($bp,$off,NS_INADDRSZ));
\&    return(putIPv4($bp,$off,$netaddr), @$dnp);
\&  }
\&
\&  =cut
\&
\&
\&  =item * (@COMMON,$IPaddr)=$parse\->A(@common,$netaddr);
\&        (removed for brevity)
\&
\&  =cut
\&
\&  sub parse {
\&    shift;      # $self
\&    inet_ntoa(shift);
\&  }
.Ve
.SH "TEST ROUTINES"
.IX Header "TEST ROUTINES"
See: t/Template.t in this distribution.
.PP
See: t/NS.t in the Net::DNS::Toolkit distribution for an example of a test
routine that is more complex as well as embedded debugging routines which
are commented out.
.PP
And.... what follows...
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.Vb 4
\&        Net::DNS::ToolKit
\&        Net::DNS::Codes
\&        any others you require
\&        for your new RR extension
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
.Vb 1
\&        none
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Your Name <your@emailaddy.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Portions copyright 2003, Michael Robinton <michael@bizsystems.com>
.PP
Copyright 20xx, Your Name <your@emailaddy.com>
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place \- Suite 330, Boston, \s-1MA 02111\-1307, USA.\s0
.SH "See also:"
.IX Header "See also:"
\&\fBNet::DNS::Codes\fR\|(3), \fBNet::DNS::ToolKit\fR\|(3), \fBNet::DNS::ToolKit::RR::A\fR\|(3)
