.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Excel::Reader::XLSX 3"
.TH Excel::Reader::XLSX 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Excel::Reader::XLSX \- Efficient data reader for the Excel XLSX file format.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following is a simple Excel \s-1XLSX\s0 file reader using \f(CW\*(C`Excel::Reader::XLSX\*(C'\fR:
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Excel::Reader::XLSX;
\&
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&
\&    if ( !defined $workbook ) {
\&        die $reader\->error(), "\en";
\&    }
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&
\&        my $sheetname = $worksheet\->name();
\&
\&        print "Sheet = $sheetname\en";
\&
\&        while ( my $row = $worksheet\->next_row() ) {
\&
\&            while ( my $cell = $row\->next_cell() ) {
\&
\&                my $row   = $cell\->row();
\&                my $col   = $cell\->col();
\&                my $value = $cell\->value();
\&
\&                print "  Cell ($row, $col) = $value\en";
\&            }
\&        }
\&    }
\&
\&    _\|_END_\|_
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Excel::Reader::XLSX\*(C'\fR is a fast and lightweight parser for Excel \s-1XLSX\s0 files. \s-1XLSX\s0 is the Office Open \s-1XML, OOXML,\s0 format used by Excel 2007 and later.
.PP
\&\fBNote: This software is designated as alpha quality until this notice is removed.\fR The \s-1API\s0 shouldn't change but functionality is currently limited.
.SH "Reader"
.IX Header "Reader"
The \f(CW\*(C`Excel::Reader::XLSX\*(C'\fR constructor returns a Reader object that is used to read an Excel \s-1XLSX\s0 file:
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    die $reader\->error() if !defined $workbook;
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        while ( my $row = $worksheet\->next_row() ) {
\&            while ( my $cell = $row\->next_cell() ) {
\&                my $value = $cell\->value();
\&                ...
\&            }
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`Excel::Reader::XLSX\*(C'\fR object is used to return sub-objects that represent the functional parts of an Excel spreadsheet, \*(L"Workbook\*(R", \*(L"Worksheet\*(R", \*(L"Row\*(R" and \*(L"Cell\*(R":
.PP
.Vb 5
\&     Reader
\&       +\- Workbook
\&          +\- Worksheet
\&             +\- Row
\&                +\- Cell
.Ve
.PP
The \f(CW\*(C`Reader\*(C'\fR object has the following methods:
.PP
.Vb 3
\&    read_file()
\&    error()
\&    error_code()
.Ve
.SS "\fBread_file()\fP"
.IX Subsection "read_file()"
The \f(CW\*(C`read_file\*(C'\fR Reader method is used to read an Excel \s-1XLSX\s0 file and return a \f(CW\*(C`Workbook\*(C'\fR object:
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    ...
.Ve
.PP
It is recommended that the success of the \f(CW\*(C`read_file()\*(C'\fR method is always checked using one of the error checking methods below.
.SS "\fBerror()\fP"
.IX Subsection "error()"
The \f(CW\*(C`error()\*(C'\fR Reader method returns an error string if \f(CW\*(C`read_file()\*(C'\fR fails:
.PP
.Vb 2
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&
\&    if ( !defined $workbook ) {
\&        die $reader\->error(), "\en";
\&    }
\&    ...
.Ve
.PP
The \f(CW\*(C`error()\*(C'\fR strings and associated \f(CW\*(C`error_code()\*(C'\fR numbers are:
.PP
.Vb 11
\&    error()                              error_code()
\&    =======                              ============
\&    \*(Aq\*(Aq                                   0
\&    \*(AqFile not found\*(Aq                     1
\&    \*(AqFile is xls not xlsx\*(Aq               2
\&    \*(AqFile is encrypted xlsx\*(Aq             3
\&    \*(AqFile is unknown OLE doc type\*(Aq       4
\&    \*(AqFile has zip error\*(Aq                 5
\&    \*(AqFile is missing subfile\*(Aq            6
\&    \*(AqFile has no [Content_Types].xml\*(Aq    7
\&    \*(AqFile has no workbook.xml\*(Aq           8
.Ve
.SS "\fBerror_code()\fP"
.IX Subsection "error_code()"
The \f(CW\*(C`error_code()\*(C'\fR Reader method returns an error code if \f(CW\*(C`read_file()\*(C'\fR fails:
.PP
.Vb 2
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&
\&    if ( !defined $workbook ) {
\&        die "Got error code ", $parser\->error_code, "\en";
\&    }
.Ve
.PP
This method is useful if you wish to use you own error strings or error handling methods.
.SH "Workbook"
.IX Header "Workbook"
.SS "Workbook Methods"
.IX Subsection "Workbook Methods"
An \f(CW\*(C`Excel::Reader::XLSX\*(C'\fR \f(CW\*(C`Workbook\*(C'\fR object is returned by the Reader \f(CW\*(C`read_file()\*(C'\fR method:
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    ...
.Ve
.PP
The \f(CW\*(C`Workbook\*(C'\fR object has the following methods:
.PP
.Vb 2
\&    worksheets()
\&    worksheet()
.Ve
.SS "\fBworksheets()\fP"
.IX Subsection "worksheets()"
The Workbook \f(CW\*(C`worksheets()\*(C'\fR method returns an array of
\&\f(CW\*(C`Worksheet\*(C'\fR objects. This method is generally used to iterate through
all the worksheets in an Excel workbook and read the data:
.PP
.Vb 3
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&      ...
\&    }
.Ve
.SS "\fBworksheet()\fP"
.IX Subsection "worksheet()"
The Workbook \f(CW\*(C`worksheet()\*(C'\fR method returns a single \f(CW\*(C`Worksheet\*(C'\fR
object using the sheetname or the zero based index.
.PP
.Vb 1
\&    my $worksheet = $workbook\->worksheet( \*(AqSheet1\*(Aq );
\&
\&    # Or via the index.
\&
\&    my $worksheet = $workbook\->worksheet( 0 );
.Ve
.SH "Worksheet"
.IX Header "Worksheet"
.SS "Worksheet Methods"
.IX Subsection "Worksheet Methods"
The \f(CW\*(C`Worksheet\*(C'\fR object is returned from a \*(L"Workbook\*(R" object and is used to access row data.
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    die $reader\->error() if !defined $workbook;
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        ...
\&    }
.Ve
.PP
The \f(CW\*(C`Worksheet\*(C'\fR object has the following methods:
.PP
.Vb 3
\&     next_row()
\&     name()
\&     index()
.Ve
.SS "\fBnext_row()\fP"
.IX Subsection "next_row()"
The \f(CW\*(C`next_row()\*(C'\fR method returns a \*(L"Row\*(R" object representing the next
row in the worksheet.
.PP
.Vb 1
\&        my $row = $worksheet\->next_row();
.Ve
.PP
It returns \f(CW\*(C`undef\*(C'\fR if there are no more rows containing data or formatting in the worksheet. This allows you to iterate over all the rows in a worksheet as follows:
.PP
.Vb 1
\&        while ( my $row = $worksheet\->next_row() ) { ... }
.Ve
.PP
Note, for efficiency the \f(CW\*(C`next_row()\*(C'\fR method returns the next row in the file. This may not be the next sequential row. An option to read sequential rows, wheter they contain data or not will be added in a later release.
.SS "\fBname()\fP"
.IX Subsection "name()"
The \f(CW\*(C`name()\*(C'\fR method returns the name of the Worksheet object.
.PP
.Vb 1
\&    my $sheetname = $worksheet\->name();
.Ve
.SS "\fBindex()\fP"
.IX Subsection "index()"
The \f(CW\*(C`index()\*(C'\fR method returns the zero-based index of the Worksheet
object.
.PP
.Vb 1
\&    my $sheet_index = $worksheet\->index();
.Ve
.SH "Row"
.IX Header "Row"
.SS "Row Methods"
.IX Subsection "Row Methods"
The \f(CW\*(C`Row\*(C'\fR object is returned from a \*(L"Worksheet\*(R" object and is use to access cells in the worksheet.
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    die $reader\->error() if !defined $workbook;
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        while ( my $row = $worksheet\->next_row() ) {
\&            ...
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`Row\*(C'\fR object has the following methods:
.PP
.Vb 3
\&    values()
\&    next_cell()
\&    row_number()
.Ve
.SS "\fBvalues()\fP"
.IX Subsection "values()"
The \f(CWvalues())\fR method returns an array of values for a row from the first column up to the last column containing data. Cells with no data value return an empty string \f(CW\*(Aq\*(Aq\fR.
.PP
.Vb 1
\&    my @values = $row\->values();
.Ve
.PP
For example if we extracted data for the first row of the following spreadsheet we would get the values shown below:
.PP
.Vb 6
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |   |     A     |     B     |     C     |     D     | ...
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | 1 |           | Foo       |           | Bar       | ...
\&    | 2 |           |           |           |           | ...
\&    | 3 |           |           |           |           | ...
\&
\&    # Code:
\&    ...
\&    my $row = $worksheet\->next_row();
\&    my @values = $row\->values();
\&    ...
\&
\&    # @values contains ( \*(Aq\*(Aq, \*(AqFoo\*(Aq, \*(Aq\*(Aq, \*(AqBar\*(Aq )
.Ve
.SS "\fBnext_cell()\fP"
.IX Subsection "next_cell()"
The \f(CW\*(C`next_cell\*(C'\fR method returns the next, non-blank cell in the current row.
.PP
.Vb 1
\&    my $cell = $row\->next_cell();
.Ve
.PP
It is usually used with a while loop. For example if we extracted data for the first row of the following spreadsheet we would get the values shown below:
.PP
.Vb 6
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |   |     A     |     B     |     C     |     D     | ...
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | 1 |           | Foo       |           | Bar       | ...
\&    | 2 |           |           |           |           | ...
\&    | 3 |           |           |           |           | ...
\&
\&    # Code:
\&    ...
\&    while ( my $cell = $row\->next_cell() ) {
\&        my $value = $cell\->value();
\&        print $value, "\en";
\&    }
\&    ...
\&
\&    # Output:
\&    Foo
\&    Bar
.Ve
.PP
Note, for efficiency the \f(CW\*(C`next_cell()\*(C'\fR method returns the next cell in the row. This may not be the next sequential cell. An option to read sequential cells, wheter they contain data or not will be added in a later release.
.SS "\fBrow_number()\fP"
.IX Subsection "row_number()"
The \f(CW\*(C`row_number()\*(C'\fR method returns the zero-indexed row number for the current row:
.PP
.Vb 2
\&    my $row = $worksheet\->next_row();
\&    print $row\->row_number(), "\en";
.Ve
.SH "Cell"
.IX Header "Cell"
.SS "Cell Methods"
.IX Subsection "Cell Methods"
The \f(CW\*(C`Cell\*(C'\fR object is used to extract data from Excel cells:
.PP
.Vb 3
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&    die $reader\->error() if !defined $workbook;
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        while ( my $row = $worksheet\->next_row() ) {
\&            while ( my $cell = $row\->next_cell() ) {
\&                my $value = $cell\->value();
\&               ...
\&            }
\&        }
\&    }
.Ve
.PP
The \f(CW\*(C`Cell\*(C'\fR object has the following methods:
.PP
.Vb 3
\&    value()
\&    row()
\&    col()
.Ve
.PP
For example if we extracted the data for the cells in the first row of the following spreadsheet we would get the values shown below:
.PP
.Vb 6
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |   |     A     |     B     |     C     |     D     | ...
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    | 1 |           | Foo       |           | Bar       | ...
\&    | 2 |           |           |           |           | ...
\&    | 3 |           |           |           |           | ...
\&
\&    # Code:
\&    ...
\&    while ( my $row = $worksheet\->next_row() ) {
\&        while ( my $cell = $row\->next_cell() ) {
\&            my $row   = $cell\->row();
\&            my $col   = $cell\->col();
\&            my $value = $cell\->value();
\&
\&            print "Cell ($row, $col) = $value\en";
\&        }
\&    }
\&    ...
\&
\&    # Output:
\&    Cell (0, 1) = Foo
\&    Cell (0, 2) = Bar
.Ve
.SS "\fBvalue()\fP"
.IX Subsection "value()"
The Cell \f(CW\*(C`value()\*(C'\fR method returns the unformatted value from the cell.
.PP
.Vb 1
\&    my $value = $cell\->value();
.Ve
.PP
The \*(L"value\*(R" of the cell can be a string or  a number. In the case of a formula it returns the result of the formula and not the formal string. For dates it returns the numeric serial date.
.SS "\fBrow()\fP"
.IX Subsection "row()"
The Cell \f(CW\*(C`row()\*(C'\fR method returns the zero-indexed row number of the cell.
.PP
.Vb 1
\&    my $row = $cell\->row();
.Ve
.SS "\fBcol()\fP"
.IX Subsection "col()"
The Cell \f(CW\*(C`col()\*(C'\fR method returns the zero-indexed column number of the cell.
.PP
.Vb 1
\&    my $col = $cell\->col();
.Ve
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Simple example of iterating through all worksheets in a workbook and printing out values from cells that contain data.
.PP
.Vb 3
\&    use strict;
\&    use warnings;
\&    use Excel::Reader::XLSX;
\&
\&    my $reader   = Excel::Reader::XLSX\->new();
\&    my $workbook = $reader\->read_file( \*(AqBook1.xlsx\*(Aq );
\&
\&    if ( !defined $workbook ) {
\&        die $reader\->error(), "\en";
\&    }
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&
\&        my $sheetname = $worksheet\->name();
\&
\&        print "Sheet = $sheetname\en";
\&
\&        while ( my $row = $worksheet\->next_row() ) {
\&
\&            while ( my $cell = $row\->next_cell() ) {
\&
\&                my $row   = $cell\->row();
\&                my $col   = $cell\->col();
\&                my $value = $cell\->value();
\&
\&                print "  Cell ($row, $col) = $value\en";
\&            }
\&        }
\&    }
.Ve
.SH "RATIONALE"
.IX Header "RATIONALE"
The rationale for this module is to have a fast memory efficient module for reading \s-1XLSX\s0 files. This is based on my experience of user requirements as the maintainer of Spreadsheet::ParseExcel.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Spreadsheet::XLSX, an \s-1XLSX\s0 reader using the old Spreadsheet::ParseExcel hash based interface: <http://search.cpan.org/dist/Spreadsheet\-XLSX/>.
.PP
SimpleXlsx, a \*(L"rudimentary extension to allow parsing of information stored in Microsoft Excel \s-1XLSX\s0 spreadsheets\*(R": <http://search.cpan.org/dist/SimpleXlsx/>.
.PP
Excel::Writer::XLSX, an \s-1XLSX\s0 file writer based on the Spreadsheet::WriteExcel interface: <http://search.cpan.org/dist/Excel\-Writer\-XLSX/>.
.SH "TODO"
.IX Header "TODO"
There are a lot of features still to be added. This module is very much a work in progress.
.IP "\(bu" 4
Reading from filehandles.
.IP "\(bu" 4
Option to read sequential rows via \f(CW\*(C`next_row()\*(C'\fR.
.IP "\(bu" 4
Option to read dates instead of raw serial style numbers. This is actually harder than it would seem due to the \s-1XLSX\s0 format.
.IP "\(bu" 4
Option to read formulas, urls, comments, images.
.IP "\(bu" 4
Spreadsheet::ParseExcel style interface.
.IP "\(bu" 4
Direct cell access.
.IP "\(bu" 4
Cell format data.
.SH "LICENSE"
.IX Header "LICENSE"
Either the Perl Artistic Licence <http://dev.perl.org/licenses/artistic.html> or the \s-1GPL\s0 <http://www.opensource.org/licenses/gpl\-license.php>.
.SH "AUTHOR"
.IX Header "AUTHOR"
John McNamara jmcnamara@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright \s-1MMXII,\s0 John McNamara.
.PP
All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software \*(L"as is\*(R" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
.PP
In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
