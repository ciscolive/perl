.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPIx::QuoteLike::Utils 3"
.TH PPIx::QuoteLike::Utils 3 "2020-10-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPIx::QuoteLike::Utils \- Utility subroutines for PPIx::QuoteLike;
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PPIx::QuoteLike::Utils qw{ _\|_variables };
\& 
\& say for _\|_variables( PPI::Document\->new( \e\*(Aq$foo\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Perl module holds code for PPIx::QuoteLike that
did not seem to fit anywhere else.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
This module supports the following public subroutines:
.SS "column_number"
.IX Subsection "column_number"
This subroutine/method returns the column number of the first character
in the element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "is_ppi_quotelike_element"
.IX Subsection "is_ppi_quotelike_element"
This subroutine returns true if its argument is a
PPI::Element that this package is capable of dealing
with. That is, one of the following:
.PP
.Vb 5
\&    PPI::Token::Quote
\&    PPI::Token::QuoteLike::Backtick
\&    PPI::Token::QuoteLike::Command
\&    PPI::Token::QuoteLike::Readline
\&    PPI::Token::HereDoc
.Ve
.PP
It returns false for unblessed references and for non-references.
.SS "line_number"
.IX Subsection "line_number"
This subroutine/method returns the line number of the first character in
the element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "logical_filename"
.IX Subsection "logical_filename"
This subroutine/method returns the logical file name (taking \f(CW\*(C`#line\*(C'\fR
directives into account) of the file containing first character in the
element, or \f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "logical_line_number"
.IX Subsection "logical_line_number"
This subroutine/method returns the logical line number (taking \f(CW\*(C`#line\*(C'\fR
directives into account) of the first character in the element, or
\&\f(CW\*(C`undef\*(C'\fR if that can not be determined.
.SS "_\|_normalize_interpolation_for_ppi"
.IX Subsection "__normalize_interpolation_for_ppi"
Despite the leading underscores, this exportable subroutine is public
and supported. The underscores are so it will not appear to be public
code to various tools when imported into other code.
.PP
This subroutine takes as its argument a string representing an
interpolation. It removes such things as braces around variable names to
make it into more normal Perl \*(-- which is to say Perl that produces a
more normal \s-1PPI\s0 parse. Sample transformations are:
.PP
.Vb 3
\& \*(Aq${foo}\*(Aq        => \*(Aq$foo\*(Aq
\& \*(Aq@{[ foo() ]}\*(Aq  => \*(Aqfoo()\*(Aq
\& \*(Aq${\e( foo() )}\*(Aq => \*(Aqfoo()\*(Aq
.Ve
.PP
\&\fB\s-1NOTE\s0\fR that this is not intended for general code cleanup.
Specifically, it assumes that its argument is an interpolation and
\&\fBonly\fR an interpolation. Feeding it anything else is unsupported, and
probably will not return anything useful.
.SS "statement"
.IX Subsection "statement"
This subroutine/method returns the PPI::Statement that
contains this element, or nothing if the statement can not be
determined.
.PP
In general this method will return something only under the following
conditions:
.IP "\(bu" 4
The element is contained in a PPIx::Regexp object;
.IP "\(bu" 4
That object was initialized from a PPI::Element;
.IP "\(bu" 4
The PPI::Element is contained in a statement.
.SS "visual_column_number"
.IX Subsection "visual_column_number"
This subroutine/method returns the visual column number (taking tabs
into account) of the first character in the element, or \f(CW\*(C`undef\*(C'\fR if that
can not be determined.
.SS "_\|_variables"
.IX Subsection "__variables"
.Vb 1
\& say for _\|_variables( PPI::Document\->new( \e\*(Aq$foo\*(Aq );
.Ve
.PP
\&\fB\s-1NOTE\s0\fR that this subroutine is discouraged, and may well be deprecated
and removed. My problem with it is that it returns variable names rather
than PPI::Element objects, leaving you no idea how the
variables are used. It was originally written for the benefit of
Perl::Critic::Policy::Variables::ProhibitUnusedVarsStricter,
but has proven inadequate to that policy's needs.
.PP
Despite the leading underscores, this exportable subroutine is public
and supported. The underscores are so it will not appear to be public
code to various tools when imported into other code.
.PP
This subroutine takes as its only argument a
PPI::Element, and returns the names of all variables
found in that element, in no particular order. Scope is not taken into
account.
.PP
In addition to reporting variables parsed as such by \s-1PPI\s0, and
various corner cases such as \f(CW\*(C`${]}\*(C'\fR where \s-1PPI\s0 is blind to the use of
the variable, this subroutine looks inside the following \s-1PPI\s0 classes:
.PP
.Vb 5
\&    PPI::Token::Quote
\&    PPI::Token::QuoteLike::Backtick
\&    PPI::Token::QuoteLike::Command
\&    PPI::Token::QuoteLike::Readline
\&    PPI::Token::HereDoc
.Ve
.PP
If PPIx::Regexp is installed, it will also look inside
.PP
.Vb 3
\&    PPI::Token::QuoteLike::Regexp
\&    PPI::Token::Regexp::Match
\&    PPI::Token::Regexp::Substitute
.Ve
.PP
Unfortunately I can not make \f(CW\*(C`PPIx::Regexp\*(C'\fR a requirement for this
module, because of the possibility of a circular dependency.
.SH "SUPPORT"
.IX Header "SUPPORT"
Support is by the author. Please file bug reports at
<https://rt.cpan.org>, or in electronic mail to the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas R. Wyant, \s-1III\s0 \fIwyant at cpan dot org\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2016\-2020 by Thomas R. Wyant, \s-1III\s0
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl 5.10.0. For more details, see the full text
of the licenses in the directory \s-1LICENSES.\s0
.PP
This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
