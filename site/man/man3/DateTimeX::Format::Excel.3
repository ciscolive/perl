.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTimeX::Format::Excel 3"
.TH DateTimeX::Format::Excel 3 "2016-05-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DateTimeX::Format::Excel \- Microsofty conversion of Excel epochs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        #!/usr/bin/env perl
\&        use DateTimeX::Format::Excel;
\&
\&        # From an Excel date number
\&
\&        my      $parser = DateTimeX::Format::Excel\->new();
\&        print   $parser\->parse_datetime( 25569 )\->ymd ."\en";
\&        my      $datetime = $parser\->parse_datetime( 37680 );
\&        print   $datetime\->ymd() ."\en";
\&                $datetime = $parser\->parse_datetime( 40123.625 );
\&        print   $datetime\->iso8601() ."\en";
\&
\&        # And back to an Excel number from a DateTime object
\&
\&        use DateTime;
\&        my      $dt = DateTime\->new( year => 1979, month => 7, day => 16 );
\&        my      $daynum = $parser\->format_datetime( $dt );
\&        print   $daynum ."\en";
\&
\&        my      $dt_with_time = DateTime\->new( year => 2010, month => 7, day => 23
\&                                                                        , hour => 18, minute => 20 );
\&        my      $parser_date = $parser\->format_datetime( $dt_with_time );
\&        print   $parser_date ."\en";
\&
\&        ###########################
\&        # SYNOPSIS Screen Output
\&        # 01: 1970\-01\-01
\&        # 02: 2003\-02\-28
\&        # 03: 2009\-11\-06T15:00:00
\&        # 04: 29052
\&        # 05: 40382.763888889
\&        ###########################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Excel uses a different system for its dates than most Unix programs.
This package allows you to convert between the Excel raw format and
and DateTime objects, which can then be further converted via any
of the other DateTime::Format::*
 <https://metacpan.org/search?q=DateTime%3A%3AFormat> modules, or just
with DateTime's methods.  The DateTime::Format::Excel module states
\&\*(L"we assume what Psion assumed for their Abacus / Sheet program\*(R".  As a
consequence the output does not follow exactly the output of Excel.
Especially in the Windows range of 0\-60.  This module attempts to more
faithfully follow actual Microsoft Excel with a few notable exceptions.
.PP
Excel has a few date quirks. First, it allows two different epochs.  One
for the Windows world and one for the Apple world.  The windows epoch
starts in 0\-January\-1900 and allows for 29\-February\-1900 (both non real
dates).  Most of the explanations for the difference between windows
implementations and Apple implementations focus on the fact that there
was no leap year in 1900 (the Gregorian vs Julian calendars)
 <http://en.wikipedia.org/wiki/Gregorian_calendar> and the Apple
version wanted to skip that issue.  Both non real dates appear to have
been a known issue in the original design of VisiCalc that was carried
through Lotus 1\-2\-3 and into Excel for compatibility
 <http://support.microsoft.com/kb/214326>.  (Spreadsheets were arguably the
first personal computer killer app and Excel was a johnny come lately
 <http://en.wikipedia.org/wiki/Lotus_1-2-3#VisiCalc> trying to gain an entry
into the market at the time.)  The closest microsoft discussion I could find
on this issue is here <http://www.joelonsoftware.com/items/2006/06/16.html>.
In any case the apple version starts 1\-January\-1904. (counting from 0 while
also avoiding the leap year issue).  In both cases the Windows and Apple
version use integers from the epoch start to represent days and the decimal
portion to represent a portion of a day.  Both Windows and Apple Excel will
attempt to convert recognized date strings to an Excel epoch for storage with
the exception that any date prior to the epoch start will be stored as a
string.  (31\-December\-1899 and earlier for Windows and 31\-December\-1903 and
earlier for Apple).  Next, Excel does not allow for a time zone component of
each number. Finally, in the Windows version when dealing with epochs that
do not have a date component just a time component all values will fall
between 0 and 1 which is a non real date (0\-January\-1900).
.SS "Caveat utilitor"
.IX Subsection "Caveat utilitor"
This explanation is not intended to justify Microsofts decisions with Excel
dates just replicate them as faithfully as possible.  This module makes the
assumption that you already know if your date is a string or a number in Excel
and that you will handle string to DateTime conversions elsewhere. see
DateTime::Format::Flexible.  Any passed strings will die.  (As a failure
of a Type::Tiny test)  This module also makes several unilateral decisions
to deal with corner cases.  When a 0 date is requested to be converted to
DateTime it will use Carp to cluck that it received a bad date and then
provide a DateTime object dated 1\-January\-1900 (Excel would provide
0\-January\-1900).  If a value between 0 and 1 is requested to be converted to
a DateTime object the module will \fB\s-1NOT\s0\fR cluck and provide an object dated
1\-January\-1900 with the appropriate time component. All Apple times are provide
as 1\-January\-1904.  Any requested numerical conversion for Windows >= 60 and
< 61 will cluck and provide a DateTime object dated 1\-March\-1900 (Excel would
provide 29\-Febrary\-1900).  All requests for conversion of negative numbers to
DateTime objects will die .  If a DateTime object is provided for conversion
to the Excel value and it falls earlier than 1\-January\-1900 for Windows and
1\-January\-1904 for Apple then the DateTime object itself will be returned.
If you accept the output of that method
as a scalar, DateTime will stringify itself and give you a text equivalent
date.  For time zones you can pass a time zone
with the excel number for conversion to the DateTime object.  In reverse,
the conversion to Excel Epoch uses the \->jd
 <https://metacpan.org/pod/DateTime#dt-jd-dt-mjd> method for calculation so
the time zone is stripped out.  No clone or duration calculations are provided
with this module.  Finally this is a Moose based module and does
not provide a functional interface. \fI(Moose would allow it I just chose not
to for design purposes)\fR.
.PP
The Types module for this package uses Type::Tiny which can, in the background,
use Type::Tiny::XS.  While in general this is a good thing you will need to make
sure that Type::Tiny::XS is version 0.010 or newer since the older ones didn't support
the 'Optional' method.
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to new when creating an instance (parser).  For modification of
these attributes see the listed \*(L"Methods\*(R" of the instance.
.PP
\fIsystem_type\fR
.IX Subsection "system_type"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute identifies whether the translation will be done
for Windows Excel => 'win_excel' or Apple Excel => 'apple_excel'.
.Sp
\&\fBDefault\fR win_excel (0\-January\-1900T00:00:00 = 0, range includes 29\-February\-1900)
.Sp
\&\fBRange\fR win_excel|apple_excel (1\-January\-1904T00:00:00 = 0)
.RE
.SS "Methods"
.IX Subsection "Methods"
These include methods to adjust attributes as well as providing methods to
provide the conversion functionality of the module.
.PP
\fIget_system_type\fR
.IX Subsection "get_system_type"
.Sp
.RS 4
\&\fBDefinition:\fR This is the way to see whether the conversion is Windows or Apple based
.Sp
\&\fBAccepts:\fRNothing
.Sp
\&\fBReturns:\fR win_excel|apple_excel
.RE
.PP
\fIset_system_type( \f(CI$system\fI )\fR
.IX Subsection "set_system_type( $system )"
.Sp
.RS 4
\&\fBDefinition:\fR This is the way to set the base epoch for the translator
.Sp
\&\fBAccepts:\fR win_excel|apple_excel (see the \*(L"\s-1DESCRIPTION\*(R"\s0 for details)
.Sp
\&\fBReturns:\fR Nothing
.RE
.PP
\fIparse_datetime( \f(CI@arg_list\fI )\fR
.IX Subsection "parse_datetime( @arg_list )"
.Sp
.RS 4
\&\fBDefinition:\fR This is how positive excel numbers are translated to DateTime objects
.Sp
\&\fBAccepts:\fR \f(CW@arg_list\fR \- the order is important!
.Sp
.RS 4
\&\fB0. \fR \f(CW$the_excel_number_for_translation\fR \- must be positive \- no strings allowed
.Sp
\&\fB1. \fR 'time_zone' (the only useful option \- other values here will ignore position 2)
.Sp
\&\fB2. \fR A recognizable time zone string or DateTime::TimeZone object
.Sp
\&\fBexample: \fR ( 12345, time_zone => 'America/Los_Angeles' )
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR A DateTime object set to match the passed values.  A floating time zone is default.
.RE
.PP
\fIformat_datetime( \f(CI$date_time\fI )\fR
.IX Subsection "format_datetime( $date_time )"
.Sp
.RS 4
\&\fBDefinition:\fR This is how DateTime objects can be translated to Excel epoch numbers
.Sp
\&\fBAccepts:\fR A DateTime object
.Sp
\&\fBReturns:\fR An excel epoch number or DateTime object if it is before the relevant epoch start.
.RE
.SS "A note on text dates"
.IX Subsection "A note on text dates"
Dates saved in Excel prior to 1\-January\-1900 for Windows or 1\-January\-1904 for Apple are stored as text.
I suggest using \*(L"Chained Coercions\*(R" in Type::Tiny::Manual::Coercions.  Or use an Excel reader
that implements this for you like Spreadsheet::XLSX::Reader::LibXML (self promotion).
Here is one possible way to integrate text and dates in the same field into a consistent DateTime
output. (I know it's a bit clunky but it's a place to start)
.PP
.Vb 10
\&        my $system_lookup = {
\&                        \*(Aq1900\*(Aq => \*(Aqwin_excel\*(Aq,
\&                        \*(Aq1904\*(Aq => \*(Aqapple_excel\*(Aq,
\&                };
\&        my      @args_list      = ( system_type => $system_lookup\->{$workbook\->get_epoch_year} );
\&        my      $converter      = DateTimeX::Format::Excel\->new( @args_list );
\&        my      $string_via     = sub{
\&                                                        my      $str = $_[0];
\&                                                        return DateTime::Format::Flexible\->parse_datetime( $str );
\&                                                };
\&        my      $num_via        = sub{
\&                                                        my      $num = $_[0];
\&                                                        return $converter\->parse_datetime( $num );
\&                                                };
\&        my      $date_time_from_value = Type::Coercion\->new(
\&                        type_coercion_map => [ Num, $num_via, Str, $string_via, ],
\&                );
\&        my      $date_time_type = Type::Tiny\->new(
\&                        name            => \*(AqCustom_date_type\*(Aq,
\&                        constraint      => sub{ ref($_) eq \*(AqDateTime\*(Aq },
\&                        coercion        => $date_time_from_value,
\&                );
\&        my      $string_type = Type::Tiny\->new(
\&                        name            => \*(AqYYYYMMDD\*(Aq,
\&                        constraint      => sub{
\&                                !$_ or (
\&                                $_ =~ /^\ed{4}\e\-(\ed{2})\-(\ed{2})$/ and
\&                                $1 > 0 and $1 < 13 and $2 > 0 and $2 < 32 )
\&                        },
\&                        coercion        => Type::Coercion\->new(
\&                                type_coercion_map =>[
\&                                        $date_time_type\->coercibles, sub{
\&                                                my $tmp = $date_time_type\->coerce( $_ );
\&                                                $tmp\->format_cldr( \*(Aqyyyy\-MM\-dd\*(Aq )
\&                                        },
\&                                ],
\&                        ),
\&        );
.Ve
.SH "THANKS"
.IX Header "THANKS"
Dave Rolsky (\s-1DROLSKY\s0) for kickstarting the DateTime project.
Iain Truskett, Dave Rolsky, and Achim Bursian for maintaining DateTime::Format::Excel.
	I used it heavily till I wrote this.
Peter (Stig) Edwards and Bobby Metz for contributing to DateTime::Format::Excel.
.SH "Build/Install from Source"
.IX Header "Build/Install from Source"
\&\fB1.\fR Download a compressed file with the code
.PP
\&\fB2.\fR Extract the code from the compressed file.  If you are using tar this should work:
.PP
.Vb 1
\&        tar \-zxvf DateTimeX\-Format\-Excel\-v1.xx.tar.gz
.Ve
.PP
\&\fB3.\fR Change (cd) into the extracted directory
.PP
\&\fB4.\fR Run the following commands
.Sp
.RS 4
(For Windows find what version of make was used to compile your perl)
.Sp
.Vb 1
\&        perl  \-V:make
.Ve
.Sp
(then for Windows substitute the correct make function (s/make/dmake/g)?)
.RE
.PP
.Vb 1
\&        >perl Makefile.PL
\&
\&        >make
\&
\&        >make test
\&
\&        >make install # As sudo/root
\&
\&        >make clean
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github DateTimeX::Format::Excel/issues <https://github.com/jandrew/DateTimeX-Format-Excel/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Add an error attribute to load soft failures or warnings to
.Sp
\&\fB2.\fR Convert Smart::Comments to Log::Shiras <https://github.com/jandrew/Log-Shiras> debug lines
.Sp
\&\fB3.\fR Allow localization as an input to the data so the object output will localize (DateTime::Local)
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2014 \- 2016 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
\&\fB5.010\fR \- (perl)
.Sp
version \- 0.77
.Sp
Moose
.Sp
MooseX::StrictConstructor
.Sp
MooseX::HasDefaults::RO
.Sp
DateTime
.Sp
Carp
.Sp
Types::Standard
.Sp
DateTimeX::Format::Excel::Types
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
DateTime::Format::Excel
.Sp
Smart::Comments \- Turned on with \f(CW$ENV\fR{ Smart_Comments }
.RE
