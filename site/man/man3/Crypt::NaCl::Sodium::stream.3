.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::stream 3"
.TH Crypt::NaCl::Sodium::stream 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::stream \- Stream ciphers (XSalsa20, ChaCha20, Salsa20, AES\-128\-CTR)
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_stream = Crypt::NaCl::Sodium\->stream();
\&
\&    my ($key, $nonce, $random_bytes, $secret, $decrypted_msg);
\&
\&    my $msg = "Secret message";
\&
\&    ## XSalsa20
\&    ########
\&
\&    # generate secret key
\&    $key = $crypto_stream\->keygen();
\&
\&    # generate nonce
\&    $nonce = $crypto_stream\->nonce();
\&
\&    # generate 256 bytes from $nonce and $key
\&    $random_bytes = $crypto_stream\->bytes( 256, $nonce, $key );
\&
\&    # encrypt
\&    $secret = $crypto_stream\->xor($msg, $nonce, $key);
\&
\&    # decrypt
\&    $decrypted_msg = $crypto_stream\->xor($secret, $nonce, $key);
\&
\&    ## ChaCha20
\&    ########
\&
\&    # generate secret key
\&    $key = $crypto_stream\->chacha20_keygen();
\&
\&    # generate nonce
\&    $nonce = $crypto_stream\->chacha20_nonce();
\&
\&    # generate 256 bytes from $nonce and $key
\&    $random_bytes = $crypto_stream\->chacha20_bytes( 256, $nonce, $key );
\&
\&    # encrypt
\&    $secret = $crypto_stream\->chacha20_xor($msg, $nonce, $key);
\&
\&    # decrypt
\&    $decrypted_msg = $crypto_stream\->chacha20_xor($secret, $nonce, $key);
\&
\&    ## Salsa20
\&    ########
\&
\&    # generate secret key
\&    $key = $crypto_stream\->salsa20_keygen();
\&
\&    # generate nonce
\&    $nonce = $crypto_stream\->salsa20_nonce();
\&
\&    # generate 256 bytes from $nonce and $key
\&    $random_bytes = $crypto_stream\->salsa20_bytes( 256, $nonce, $key );
\&
\&    # encrypt
\&    $secret = $crypto_stream\->salsa20_xor($msg, $nonce, $key);
\&
\&    # decrypt
\&    $decrypted_msg = $crypto_stream\->salsa20_xor($secret, $nonce, $key);
\&
\&    ## AES\-128\-CTR
\&    ########
\&
\&    # generate secret key
\&    $key = $crypto_stream\->aes128ctr_keygen();
\&
\&    # generate nonce
\&    $nonce = $crypto_stream\->aes128ctr_nonce();
\&
\&    # generate 256 bytes from $nonce and $key
\&    $random_bytes = $crypto_stream\->aes128ctr_bytes( 256, $nonce, $key );
\&
\&    # encrypt
\&    $secret = $crypto_stream\->aes128ctr_xor($msg, $nonce, $key);
\&
\&    # decrypt
\&    $decrypted_msg = $crypto_stream\->aes128ctr_xor($secret, $nonce, $key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`crypto_stream\*(C'\fR provides \fIXSalsa20\fR, \fIChaCha20\fR, \fISalsa20\fR and
\&\fI\s-1AES\-128\s0\fR stream ciphers which can be used to generate pseudo-random data
from a key and nonce, or as building blocks for implementing custom
constructions, but they are not alternatives to
Crypt::NaCl::Sodium::secretbox.
.PP
Nonce (number used once) does not have to be protected, but it is crucial that
the same nonce has not been ever reused with the same key.
.PP
The generated key must be distributed in secret.
.PP
The default stream cipher is \fIXSalsa20\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "XSalsa20"
.IX Subsection "XSalsa20"
\&\fIXSalsa20\fR is a stream cipher based upon Salsa20 but with a much
longer nonce: 192 bits instead of 64 bits.
.PP
\&\fIXSalsa20\fR uses a 256\-bit key as well as the first 128 bits of
the nonce in order to compute a subkey. This subkey, as well as
the remaining 64 bits of the nonce, are the parameters of the \fISalsa20\fR
function used to actually generate the stream.
.PP
Like \fISalsa20\fR, \fIXSalsa20\fR is immune to timing attacks and provides
its own 64\-bit block counter to avoid incrementing the
nonce after each block.
.PP
But with \fIXSalsa20's\fR longer nonce, it is safe to generate nonces
using \*(L"nonce\*(R" for every message encrypted with
the same key without having to worry about a collision.
.PP
\&\f(CW\*(C`crypto_stream\*(C'\fR exposes \fIXSalsa20\fR with 20 rounds as the default algorithm.
.PP
\fIkeygen\fR
.IX Subsection "keygen"
.PP
.Vb 1
\&    my $key = $crypto_stream\->keygen();
.Ve
.PP
Helper method to generate a \fIXSalsa20\fR random key to be used by \f(CW$crypto_stream\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fInonce\fR
.IX Subsection "nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_stream\->nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_stream\fR.
.PP
The length of the nonce equals \*(L"\s-1NONCEBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_stream\->nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key. It is large enough that the randomly
generated nonces have negligible risk of collision.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
\fIbytes\fR
.IX Subsection "bytes"
.PP
.Vb 2
\&    # stream of random bytes
\&    my $bytes = $crypto_stream\->bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
Generates unpredictable sequence of \f(CW$num_of_bytes\fR bytes using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW$bytes\fR equals the value of \f(CW$num_of_bytes\fR.
.PP
Returns Data::BytesLocker object.
.PP
\fIxor\fR
.IX Subsection "xor"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->xor($msg, $nonce, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->xor($secret, $nonce, $key);
.Ve
.PP
Encrypts/decrypts the message using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.PP
\fIxor_ic\fR
.IX Subsection "xor_ic"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->xor_ic($msg, $nonce, $ic, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->xor_ic($secret, $nonce, $ic, $key);
.Ve
.PP
\&\f(CW\*(C`xor_ic\*(C'\fR is similar to \*(L"xor\*(R" function and encrypts/decrypts
the message using given \f(CW$nonce\fR and \f(CW$key\fR, but adds the ability to set the
initial value of the block counter to a non-zero value, \f(CW$ic\fR.
.PP
This permits direct access to any block without having to compute the
previous ones.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.SS "ChaCha20"
.IX Subsection "ChaCha20"
\&\fIChaCha20\fR is a stream cipher developed by Daniel J. Bernstein that
expands a 256\-bit key into 2^64 randomly accessible
streams, each containing 2^64 randomly accessible 64\-byte (512
bits) blocks. It is a variant of \fISalsa20\fR with better diffusion.
.PP
\&\fIChaCha20\fR doesn't require any lookup tables and avoids the possibility of
timing attacks.
.PP
Internally, \fIChaCha20\fR works like a block cipher used in counter
mode. It uses a dedicated 64\-bit block counter to avoid
incrementing the 64\-bit nonce after each block.
.PP
Methods that use \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce (96\-bit) and a 32\-bit
counter are also available as \*(L"chacha20_ietf_nonce\*(R", \*(L"chacha20_ietf_bytes\*(R",
\&\*(L"chacha20_ietf_xor\*(R" and \*(L"chacha20_ietf_xor_ic\*(R".
.PP
\fIchacha20_keygen\fR
.IX Subsection "chacha20_keygen"
.PP
.Vb 1
\&    my $key = $crypto_stream\->chacha20_keygen();
.Ve
.PP
Helper method to generate a \fIChaCha20\fR random key to be used by \f(CW$crypto_stream\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1CHACHA20_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
\&\fB\s-1NOTE:\s0\fR this method can be used to generate keys used in original version of
\&\f(CW\*(C`ChaCha20\*(C'\fR and the \f(CW\*(C`IETF\*(C'\fR\-compatible.
.PP
Returns Data::BytesLocker object.
.PP
\fIchacha20_nonce\fR
.IX Subsection "chacha20_nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_stream\->chacha20_nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_stream\fR.
.PP
The length of the nonce equals \*(L"\s-1CHACHA20_NONCEBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_stream\->chacha20_nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key.
.PP
Bacause the nonce is 64 bits long, in order to prevent nonce reuse,
if a key is being reused, it is recommended to increment the
previous nonce instead of generating a random nonce every time
a new stream is required.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
chacha20_ietf_nonce
.IX Subsection "chacha20_ietf_nonce"
.PP
.Vb 1
\&    my $nonce_ietf = $crypto_stream\->chacha20_ietf_nonce();
.Ve
.PP
Same as above but generates an \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.PP
The length of the nonce equals \*(L"\s-1CHACHA20_IETF_NONCEBYTES\*(R"\s0.
.PP
\fIchacha20_bytes\fR
.IX Subsection "chacha20_bytes"
.PP
.Vb 2
\&    # stream of random bytes
\&    my $bytes = $crypto_stream\->chacha20_bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
Generates unpredictable sequence of \f(CW$num_of_bytes\fR bytes using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW$bytes\fR equals the value of \f(CW$num_of_bytes\fR.
.PP
Returns Data::BytesLocker object.
.PP
chacha20_ietf_bytes
.IX Subsection "chacha20_ietf_bytes"
.PP
.Vb 2
\&    # stream of random bytes
\&    my $bytes = $crypto_stream\->chacha20_ietf_bytes($num_of_bytes, $nonce_ietf, $key);
.Ve
.PP
Same as above but uses an \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.PP
\fIchacha20_xor\fR
.IX Subsection "chacha20_xor"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->chacha20_xor($msg, $nonce, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->chacha20_xor($secret, $nonce, $key);
.Ve
.PP
Encrypts/decrypts the message using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.PP
chacha20_ietf_xor
.IX Subsection "chacha20_ietf_xor"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->chacha20_ietf_xor($msg, $nonce_ietf, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->chacha20_ietf_xor($secret, $nonce_ietf, $key);
.Ve
.PP
Same as above but uses an \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.PP
\fIchacha20_xor_ic\fR
.IX Subsection "chacha20_xor_ic"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->chacha20_xor_ic($msg, $nonce, $ic, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->chacha20_xor_ic($secret, $nonce, $ic, $key);
.Ve
.PP
\&\f(CW\*(C`chacha20_xor_ic\*(C'\fR is similar to \*(L"chacha20_xor\*(R" function and encrypts/decrypts the message using
given \f(CW$nonce\fR and \f(CW$key\fR, but adds the ability to set the
initial value of the block counter to a non-zero value, \f(CW$ic\fR.
.PP
This permits direct access to any block without having to compute the
previous ones.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.PP
\fIchacha20_ietf_xor_ic\fR
.IX Subsection "chacha20_ietf_xor_ic"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->chacha20_ietf_xor_ic($msg, $nonce_ietf, $ic, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->chacha20_ietf_xor_ic($secret, $nonce_ietf, $ic, $key);
.Ve
.PP
Same as above but uses an \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.SS "Salsa20"
.IX Subsection "Salsa20"
\&\fISalsa20\fR is a stream cipher developed by Daniel J. Bernstein that
expands a 256\-bit key into 2^64 randomly accessible
streams, each containing 2^64 randomly accessible 64\-byte (512
bits) blocks.
.PP
\&\fISalsa20\fR doesn't require any lookup tables and avoids the possibility of
timing attacks.
.PP
Internally, \fISalsa20\fR works like a block cipher used in counter
mode. It uses a dedicated 64\-bit block counter to avoid
incrementing the nonce after each block.
.PP
Although the best known attack against \fISalsa20/8\fR is not practical,
the full-round (20 rounds) version provides a highest security margin
while still being fast enough for most purposes.
.PP
Faster, reduced-rounds versions of \*(L"salsa20_bytes\*(R" and \*(L"salsa20_xor\*(R" are also available.
.PP
\fIsalsa20_keygen\fR
.IX Subsection "salsa20_keygen"
.PP
.Vb 1
\&    my $key = $crypto_stream\->salsa20_keygen();
.Ve
.PP
Helper method to generate a \fISalsa20\fR random key to be used by \f(CW$crypto_stream\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1SALSA20_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fIsalsa20_nonce\fR
.IX Subsection "salsa20_nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_stream\->salsa20_nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_stream\fR.
.PP
The length of the nonce equals \*(L"\s-1SALSA20_NONCEBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_stream\->salsa20_nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
\fIsalsa20_bytes\fR
.IX Subsection "salsa20_bytes"
.PP
.Vb 2
\&    # stream of random bytes
\&    my $bytes = $crypto_stream\->salsa20_bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
Generates unpredictable sequence of \f(CW$num_of_bytes\fR bytes using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW$bytes\fR equals the value of \f(CW$num_of_bytes\fR.
.PP
Returns Data::BytesLocker object.
.PP
salsa2012_bytes
.IX Subsection "salsa2012_bytes"
.PP
Salsa20 reduced to 12 rounds:
.PP
.Vb 2
\&    # stream of random bytes using Salsa20/12
\&    my $bytes = $crypto_stream\->salsa2012_bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
See \*(L"salsa20_bytes\*(R" for details.
.PP
salsa208_bytes
.IX Subsection "salsa208_bytes"
.PP
Salsa20 reduced to 8 rounds:
.PP
.Vb 2
\&    # stream of random bytes using Salsa20/8
\&    my $bytes = $crypto_stream\->salsa208_bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
See \*(L"salsa20_bytes\*(R" for details.
.PP
\fIsalsa20_xor\fR
.IX Subsection "salsa20_xor"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->salsa20_xor($msg, $nonce, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->salsa20_xor($secret, $nonce, $key);
.Ve
.PP
Encrypts/decrypts the message using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.PP
salsa2012_xor
.IX Subsection "salsa2012_xor"
.PP
Salsa20 reduced to 12 rounds:
.PP
.Vb 2
\&    # encryption using Salsa20/12
\&    my $secret = $crypto_stream\->salsa2012_xor($msg, $nonce, $key);
\&
\&    # decryption using Salsa20/12
\&    my $decrypted_msg = $crypto_stream\->salsa2012_xor($secret, $nonce, $key);
.Ve
.PP
See \*(L"salsa20_xor\*(R" for details.
.PP
salsa208_xor
.IX Subsection "salsa208_xor"
.PP
Salsa20 reduced to 8 rounds:
.PP
.Vb 2
\&    # encryption using Salsa20/8
\&    my $secret = $crypto_stream\->salsa208_xor($msg, $nonce, $key);
\&
\&    # decryption using Salsa20/8
\&    my $decrypted_msg = $crypto_stream\->salsa208_xor($secret, $nonce, $key);
.Ve
.PP
See \*(L"salsa20_xor\*(R" for details.
.PP
\fIsalsa20_xor_ic\fR
.IX Subsection "salsa20_xor_ic"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->salsa20_xor_ic($msg, $nonce, $ic, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->salsa20_xor_ic($secret, $nonce, $ic, $key);
.Ve
.PP
\&\f(CW\*(C`salsa20_xor_ic\*(C'\fR is similar to \*(L"salsa20_xor\*(R" function and encrypts/decrypts
the message using given \f(CW$nonce\fR and \f(CW$key\fR, but adds the ability to set the
initial value of the block counter to a non-zero value, \f(CW$ic\fR.
.PP
This permits direct access to any block without having to compute the
previous ones.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.SS "\s-1AES\-128\-CTR\s0"
.IX Subsection "AES-128-CTR"
\&\f(CW\*(C`crypto_stream\*(C'\fR provides a software bitsliced implementation of \fI\s-1AES\-128\s0\fR in
counter mode written by Peter Schwabe and Emilia Käsper, which resists all
cache timing attacks.
.PP
Unless using \s-1AES\s0 is a requirement, you should consider
\&\*(L"XSalsa20\*(R" or \*(L"ChaCha20\*(R" instead.
.PP
\fIaes128ctr_keygen\fR
.IX Subsection "aes128ctr_keygen"
.PP
.Vb 1
\&    my $key = $crypto_stream\->aes128ctr_keygen();
.Ve
.PP
Helper method to generate a \fI\s-1AES\-128\-CTR\s0\fR random key to be used by \f(CW$crypto_stream\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1AES128CTR_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fIaes128ctr_nonce\fR
.IX Subsection "aes128ctr_nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_stream\->aes128ctr_nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_stream\fR.
.PP
The length of the nonce equals \*(L"\s-1AES128CTR_NONCEBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_stream\->aes128ctr_nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
\fIaes128ctr_bytes\fR
.IX Subsection "aes128ctr_bytes"
.PP
.Vb 2
\&    # stream of random bytes
\&    my $bytes = $crypto_stream\->aes128ctr_bytes($num_of_bytes, $nonce, $key);
.Ve
.PP
Generates unpredictable sequence of \f(CW$num_of_bytes\fR bytes using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW$bytes\fR equals the value of \f(CW$num_of_bytes\fR.
.PP
Returns Data::BytesLocker object.
.PP
\fIaes128ctr_xor\fR
.IX Subsection "aes128ctr_xor"
.PP
.Vb 2
\&    # encryption
\&    my $secret = $crypto_stream\->aes128ctr_xor($msg, $nonce, $key);
\&
\&    # decryption
\&    my $decrypted_msg = $crypto_stream\->aes128ctr_xor($secret, $nonce, $key);
.Ve
.PP
Encrypts/decrypts the message using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
The length of the \f(CW\*(C`$secret/$decrypted_msg\*(C'\fR is equal to the length of
\&\f(CW\*(C`$msg/$secret\*(C'\fR.
.PP
Returns Data::BytesLocker object.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1NONCEBYTES\s0"
.IX Subsection "NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_stream\->NONCEBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"XSalsa20\*(R" methods.
.SS "\s-1KEYBYTES\s0"
.IX Subsection "KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_stream\->KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"XSalsa20\*(R" methods.
.SS "\s-1CHACHA20_NONCEBYTES\s0"
.IX Subsection "CHACHA20_NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_stream\->CHACHA20_NONCEBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"ChaCha20\*(R" methods.
.SS "\s-1CHACHA20_IETF_NONCEBYTES\s0"
.IX Subsection "CHACHA20_IETF_NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_stream\->CHACHA20_NONCEBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"ChaCha20\*(R" methods.
.SS "\s-1CHACHA20_KEYBYTES\s0"
.IX Subsection "CHACHA20_KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_stream\->CHACHA20_KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"ChaCha20\*(R" methods.
.SS "\s-1SALSA20_NONCEBYTES\s0"
.IX Subsection "SALSA20_NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_stream\->SALSA20_NONCEBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"Salsa20\*(R" methods.
.SS "\s-1SALSA20_KEYBYTES\s0"
.IX Subsection "SALSA20_KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_stream\->SALSA20_KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"Salsa20\*(R" methods.
.SS "\s-1AES128CTR_NONCEBYTES\s0"
.IX Subsection "AES128CTR_NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_stream\->AES128CTR_NONCEBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"\s-1AES\-128\-CTR\*(R"\s0 methods.
.SS "\s-1AES128CTR_KEYBYTES\s0"
.IX Subsection "AES128CTR_KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_stream\->AES128CTR_KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"\s-1AES\-128\-CTR\*(R"\s0 methods.
.SH "SECURITY MODEL"
.IX Header "SECURITY MODEL"
\&\f(CW\*(C`crypto_stream\*(C'\fR stream ciphers, viewed as a functions of the nonce for a uniform
random key, are designed to meet the standard notion of unpredictability.
.PP
This means that an attacker cannot distinguish this function from a uniform
random function. Consequently, if a series of messages is encrypted by
\&\f(CW\*(C`*_xor()\*(C'\fR methods with a different nonce for each message, the ciphertexts are
indistinguishable from uniform random strings of the same length.
.PP
\&\f(CW\*(C`crypto_stream\*(C'\fR does not make any promises regarding the resistance to
\&\*(L"related-key attacks\*(R". It is the caller's responsibility to use proper
key-derivation functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
Crypt::NaCl::Sodium::secretbox
.IP "\(bu" 4
The security of the cipher block chaining message authentication code <http://cseweb.ucsd.edu/~mihir/papers/cbc.html>
.IP "\(bu" 4
Extending the Salsa20 nonce <http://cr.yp.to/snuffle/xsalsa-20110204.pdf>
\&\- the paper introducing XSalsa20
.IP "\(bu" 4
ChaCha, a variant of Salsa20 <http://cr.yp.to/chacha/chacha-20080128.pdf>
.IP "\(bu" 4
ChaCha20 and Poly1305 for \s-1IETF\s0 Protocols <https://tools.ietf.org/html/rfc7539>
.IP "\(bu" 4
Faster and Timing-Attach Resistant AES-GCM <http://www.chesworkshop.org/ches2009/presentations/01_Session_1/CHES2009_ekasper.pdf>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
