.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::aead 3"
.TH Crypt::NaCl::Sodium::aead 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::aead \- Authenticated Encryption with Additional Data (ChaCha20/Poly1305 MAC, AES256\-GCM)
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_aead = Crypt::NaCl::Sodium\->aead();
\&
\&    my ($key, $nonce, $additional_data, $decrypted_msg, $msg, $secret);
\&
\&    ## Alice
\&    ########
\&
\&    # Alice generates secret key
\&    $key = $crypto_aead\->keygen();
\&
\&    # ... and shares it with Bob
\&    send_to( Bob => { key => $key } );
\&
\&    # now Alice and Bob can start communicating
\&
\&    # then generates random nonce
\&    $nonce = $crypto_aead\->nonce();
\&
\&    send_to( Bob => { nonce => $nonce } );
\&
\&    # Alice\*(Aqs message to Bob
\&    $msg = "Hi Bob!";
\&
\&    # unencrypted metadata
\&    $additional_data = "greeting";
\&
\&    # Bob will need it to decrypt and verify secret message
\&    send_to( Bob => { additional_data => $additional_data } );
\&
\&    # the secret will include the additional data
\&    $secret = $crypto_aead\->encrypt( $msg, $additional_data, $nonce, $key );
\&
\&    # message is ready for Bob
\&    send_to( Bob => { secret => $secret } );
\&
\&    ## Bob
\&    ########
\&
\&    # Bob receives the secret key from Alice
\&    $key = receive_for( Bob => \*(Aqkey\*(Aq );
\&
\&    # and random nonce
\&    $nonce = receive_for( Bob => \*(Aqnonce\*(Aq );
\&
\&    # Bob is now ready to receive first message from Alice
\&    # first the additional data
\&    $additional_data = receive_for( Bob => \*(Aqadditional_data\*(Aq );
\&
\&    # then the secret itself
\&    $secret = receive_for( Bob => \*(Aqsecret\*(Aq );
\&
\&    # he has now all information required to decrypt message
\&    $decrypted_msg = $crypto_aead\->decrypt( $secret, $additional_data, $nonce, $key );
\&
\&    # time to reply
\&    $msg = "Hello Alice!";
\&
\&    # generates new nonce
\&    $nonce = $crypto_aead\->nonce();
\&
\&    # Bob replies with no additional data
\&    $additional_data = "";
\&
\&    # let\*(Aqs encrypt now
\&    $secret = $crypto_aead\->encrypt( $msg, $additional_data, $nonce, $key );
\&
\&    # Alice needs all pieces to verify and decrypt Bob\*(Aqs message
\&    send_to( Alice => { nonce => $nonce } );
\&    send_to( Alice => { additional_data => $additional_data } );
\&    send_to( Alice => { secret => $secret } );
\&
\&    ## Alice
\&    ########
\&
\&    # Bob\*(Aqs data sent to Alice
\&    $nonce           = receive_for( Alice => \*(Aqnonce\*(Aq );
\&    $additional_data = receive_for( Alice => \*(Aqadditional_data\*(Aq );
\&    $secret          = receive_for( Alice => \*(Aqsecret\*(Aq );
\&
\&    # we have now all information required to decrypt message
\&    $decrypted_msg = $crypto_aead\->decrypt( $secret, $additional_data, $nonce, $key );
\&
\&    # NOTE: send_to() and receive_for() and user functions providing transport of
\&    # messages
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Authenticated Encryption with Additional Data combines the secret-key encryption
with a mechanism to include an optional, non-confidential (not-encrypted) data
which can provide some protocol-specific metadata.
.PP
The additional data is included when computing the \s-1MAC\s0 of the secret and the
decryption will never be performed, even partially, before verification.
.PP
The generated key must be distributed in secret.
.PP
Nonce (number used once) does not have to be protected, but it is crucial that
the same nonce has not been ever reused with the same key. The recommended way
is to generate the initial nonce with first message and then increment it for
each subsequent message using the same key \- see \*(L"increment\*(R" in Crypt::NaCl::Sodium.
.PP
The default algorithm is \f(CW\*(C`ChaCha20\*(C'\fR with \f(CW\*(C`Poly1305 MAC\*(C'\fR.
.PP
If \f(CW\*(C`Intel SSSE3\*(C'\fR extensions, \f(CW\*(C`aesni\*(C'\fR and \f(CW\*(C`pcmul\*(C'\fR instructions are available
the hardware-accelerated \f(CW\*(C`AES256\-GCM\*(C'\fR cipher can also be used.
.SH "METHODS"
.IX Header "METHODS"
.SS "ChaCha20/Poly1305 \s-1MAC\s0"
.IX Subsection "ChaCha20/Poly1305 MAC"
The nonce is 64 bits long,
.PP
Methods that use \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce (96\-bit) and a 32\-bit
counter are also available as \*(L"ietf_nonce\*(R", \*(L"ietf_encrypt\*(R" and
\&\*(L"ietf_decrypt\*(R".
.PP
\fIkeygen\fR
.IX Subsection "keygen"
.PP
.Vb 1
\&    my $key = $crypto_aead\->keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_aead\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fInonce\fR
.IX Subsection "nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_aead\->nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_aead\fR.
.PP
The length of the nonce equals \*(L"\s-1NPUBBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_aead\->nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
ietf_nonce
.IX Subsection "ietf_nonce"
.PP
.Vb 1
\&    my $nonce_ietf = $crypto_aead\->ietf_nonce();
.Ve
.PP
Same as above but generates \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.PP
The length of the nonce equals \*(L"\s-1IETF_NPUBBYTES\*(R"\s0.
.PP
\fIencrypt\fR
.IX Subsection "encrypt"
.PP
.Vb 1
\&    my $secret = $crypto_aead\->encrypt($msg, $additional_data, $nonce, $key);
.Ve
.PP
Encrypts the plaintext message using given \f(CW$nonce\fR and \f(CW$key\fR. Even when empty the
\&\f(CW$additional_data\fR will be used to compute the \s-1MAC\s0 of the secret message.
.PP
The length of the \f(CW$secret\fR is at most equal to the length of \f(CW$msg\fR + \*(L"\s-1ABYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
ietf_encrypt
.IX Subsection "ietf_encrypt"
.PP
.Vb 1
\&    my $secret = $crypto_aead\->ietf_encrypt($msg, $additional_data, $nonce_ietf, $key);
.Ve
.PP
Same as above but uses \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.PP
\fIdecrypt\fR
.IX Subsection "decrypt"
.PP
.Vb 9
\&    my $msg;
\&    eval {
\&        $msg = $crypto_aead\->decrypt($secret, $additional_data, $nonce, $key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Verify and decrypt the secret message with \f(CW$additional_data\fR using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
Function croaks if the verification fails. Otherwise returns the decrypted message.
.PP
The length of the \f(CW$msg\fR is at most equal to the length of \f(CW$secret\fR \- \*(L"\s-1ABYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
ietf_decrypt
.IX Subsection "ietf_decrypt"
.PP
.Vb 9
\&    my $msg;
\&    eval {
\&        $msg = $crypto_aead\->ietf_decrypt($secret, $additional_data, $nonce_ietf, $key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Same as above but uses \f(CW\*(C`IETF\*(C'\fR\-compatible extended nonce.
.SS "\s-1AES256\-GCM\s0"
.IX Subsection "AES256-GCM"
When supported by the \s-1CPU,\s0 \f(CW\*(C`AES256\-GCM\*(C'\fR is the fastest \f(CW\*(C`AEAD\*(C'\fR cipher available
in this library.
.PP
If portability is a concern, use default \*(L"ChaCha20/Poly1305 \s-1MAC\*(R"\s0 cipher.
.PP
\fIaes256gcm_is_available\fR
.IX Subsection "aes256gcm_is_available"
.PP
.Vb 3
\&    if ( $crypto_aead\->aes256gcm_is_available ) {
\&        print "Can use AES256\-GCM!\en";
\&    }
.Ve
.PP
Returns true if the current \s-1CPU\s0 supports \f(CW\*(C`AES256\-GCM\*(C'\fR implementation.
.PP
\fIaes256gcm_keygen\fR
.IX Subsection "aes256gcm_keygen"
.PP
.Vb 1
\&    my $key = $crypto_aead\->aes256gcm_keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_aead\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1AES256GCM_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.PP
\fIaes256gcm_beforenm\fR
.IX Subsection "aes256gcm_beforenm"
.PP
.Vb 1
\&    my $precal_key = $crypto_aead\->aes256gcm_beforenm( $key );
.Ve
.PP
Applications that encrypt several messages using the same key can gain a little
speed by expanding the \s-1AES\s0 key only once, via the precalculation interface.
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::aead::aes256gcmstate\*(C'\fR object which encapsulates
the expanded key.
.PP
\&\fB\s-1NOTE:\s0\fR the returned object provides following methods to allow securing the
access to the expanded key:
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.PP
lock
.IX Subsection "lock"
.PP
.Vb 1
\&    $precal_key\->lock();
.Ve
.PP
When called makes the state inaccessible. It cannot be read or written,
but the data are preserved.
.PP
unlock
.IX Subsection "unlock"
.PP
.Vb 1
\&    $precal_key\->unlock();
.Ve
.PP
When called makes the state accessible for read access only.
.PP
is_locked
.IX Subsection "is_locked"
.PP
.Vb 3
\&    if ( $precal_key\->is_locked ) {
\&        $precal_key\->unlock;
\&    }
.Ve
.PP
Returns true if the \f(CW$precal_key\fR object is locked, false otherwise.
.PP
\fIaes256gcm_nonce\fR
.IX Subsection "aes256gcm_nonce"
.PP
.Vb 1
\&    my $nonce = $crypto_aead\->aes256gcm_nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_aead\fR.
.PP
The length of the nonce equals \*(L"\s-1AES256GCM_NPUBBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_aead\->aes256gcm_nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same key.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the key to avoid accidental reuse on
the next session. In connection-oriented protocols counter-based nonce could help
rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.PP
\fIaes256gcm_encrypt\fR
.IX Subsection "aes256gcm_encrypt"
.PP
.Vb 1
\&    my $secret = $crypto_aead\->aes256gcm_encrypt($msg, $additional_data, $nonce, $key);
.Ve
.PP
Encrypts the plaintext message using given \f(CW$nonce\fR and \f(CW$key\fR. Even when empty the
\&\f(CW$additional_data\fR will be used to compute the \s-1MAC\s0 of the secret message.
.PP
The length of the \f(CW$secret\fR is at most equal to the length of \f(CW$msg\fR +
\&\*(L"\s-1AES256GCM_ABYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.PP
aes256gcm_encrypt_afternm
.IX Subsection "aes256gcm_encrypt_afternm"
.PP
.Vb 2
\&    my $secret = $crypto_aead\->aes256gcm_encrypt_afternm($msg, $additional_data, $nonce,
\&        $precal_key);
.Ve
.PP
Same as above but uses precalculated key (as returned by \*(L"aes256gcm_beforenm\*(R").
.PP
\fIaes256gcm_decrypt\fR
.IX Subsection "aes256gcm_decrypt"
.PP
.Vb 9
\&    my $msg;
\&    eval {
\&        $msg = $crypto_aead\->aes256gcm_decrypt($secret, $additional_data, $nonce, $key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Verify and decrypt the secret message with \f(CW$additional_data\fR using given \f(CW$nonce\fR and \f(CW$key\fR.
.PP
Function croaks if the verification fails. Otherwise returns the decrypted message.
.PP
The length of the \f(CW$msg\fR is at most equal to the length of \f(CW$secret\fR \-
\&\*(L"\s-1AES256GCM_ABYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.PP
aes256gcm_decrypt_afternm
.IX Subsection "aes256gcm_decrypt_afternm"
.PP
.Vb 10
\&    my $msg;
\&    eval {
\&        $msg = $crypto_aead\->aes256gcm_decrypt_afternm($secret, $additional_data, $nonce,
\&            $precal_key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Same as above but uses precalculated key (as returned by \*(L"aes256gcm_beforenm\*(R").
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1NPUBBYTES\s0"
.IX Subsection "NPUBBYTES"
.Vb 1
\&    my $nonce_length = $crypto_aead\->NPUBBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"ChaCha20/Poly1305 \s-1MAC\*(R"\s0 methods.
.SS "\s-1IETF_NPUBBYTES\s0"
.IX Subsection "IETF_NPUBBYTES"
.Vb 1
\&    my $nonce_length = $crypto_aead\->IETF_NPUBBYTES;
.Ve
.PP
Returns the length of nonce used by \f(CW\*(C`IETF\*(C'\fR\-compatible \*(L"ChaCha20/Poly1305 \s-1MAC\*(R"\s0 methods.
.SS "\s-1AES256GCM_NPUBBYTES\s0"
.IX Subsection "AES256GCM_NPUBBYTES"
.Vb 1
\&    my $nonce_length = $crypto_aead\->AES256GCM_NPUBBYTES;
.Ve
.PP
Returns the length of nonce used by \*(L"\s-1AES256\-GCM\*(R"\s0 methods.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.SS "\s-1KEYBYTES\s0"
.IX Subsection "KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_aead\->KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"ChaCha20/Poly1305 \s-1MAC\*(R"\s0 methods.
.SS "\s-1AES256GCM_KEYBYTES\s0"
.IX Subsection "AES256GCM_KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_aead\->AES256GCM_KEYBYTES;
.Ve
.PP
Returns the length of key used by \*(L"\s-1AES256\-GCM\*(R"\s0 methods.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.SS "\s-1ABYTES\s0"
.IX Subsection "ABYTES"
.Vb 1
\&    my $additional_bytes = $crypto_aead\->ABYTES;
.Ve
.PP
Returns the maximum of number of additional bytes added to encrypted messages
used by \*(L"ChaCha20/Poly1305 \s-1MAC\*(R"\s0 methods.
.SS "\s-1AES256GCM_ABYTES\s0"
.IX Subsection "AES256GCM_ABYTES"
.Vb 1
\&    my $additional_bytes = $crypto_aead\->AES256GCM_ABYTES;
.Ve
.PP
Returns the maximum of number of additional bytes added to encrypted messages
used by \*(L"\s-1AES256\-GCM\*(R"\s0 methods.
.PP
\&\fB\s-1NOTE:\s0\fR if \f(CW\*(C`AES256\-GCM\*(C'\fR is not available this method croaks.
.SH "ALGORITHM DETAILS"
.IX Header "ALGORITHM DETAILS"
\&\f(CW\*(C`crypto_aead\*(C'\fR for encryption by default uses \f(CW\*(C`ChaCha20\*(C'\fR stream cipher and
\&\f(CW\*(C`Poly1305 MAC\*(C'\fR for authentication.
.PP
Google has selected those algorithms as a replacement for \s-1RC4\s0 in OpenSSL, and
shortly afterwards it has been added to OpenSSH.
.PP
The \f(CW\*(C`AES256\-GCM\*(C'\fR algorithm has been recommended by \f(CW\*(C`NIST\*(C'\fR and is a part of the
\&\f(CW\*(C`TLS 1.2\*(C'\fR ciphers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
ChaCha, a variant of Salsa20 <http://cr.yp.to/chacha/chacha-20080128.pdf>
.IP "\(bu" 4
The Poly1305\-AES message-authentication code <http://cr.yp.to/mac/poly1305-20050329.pdf>
.IP "\(bu" 4
ChaCha20 and Poly1305 based Cipher Suites for \s-1TLS\s0 <https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04>
.IP "\(bu" 4
\&\s-1AES\s0 Galois Counter Mode (\s-1GCM\s0) Cipher Suites for \s-1TLS\s0 <https://tools.ietf.org/html/rfc5288>
.IP "\(bu" 4
An Interface and Algorithms for Authenticated Encryption <https://tools.ietf.org/html/rfc5116>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
