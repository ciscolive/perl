.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Ops 3"
.TH Ops 3 "2020-09-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Ops \- Fundamental mathematical operators
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the functions used by \s-1PDL\s0 to
overload the basic mathematical operators (\f(CW\*(C`+ \- / *\*(C'\fR
etc.) and functions (\f(CW\*(C`sin sqrt\*(C'\fR etc.)
.PP
It also includes the function \f(CW\*(C`log10\*(C'\fR, which should
be a perl function so that we can overload it!
.PP
Matrix multiplication (the operator \f(CW\*(C`x\*(C'\fR) is handled
by the module PDL::Primitive.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
none
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "plus"
.IX Subsection "plus"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
add two piddles
.PP
.Vb 3
\&   $c = plus $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x + $y;           # overloaded call
\&   $x\->inplace\->plus($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`+\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
plus processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "mult"
.IX Subsection "mult"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
multiply two piddles
.PP
.Vb 3
\&   $c = mult $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x * $y;           # overloaded call
\&   $x\->inplace\->mult($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`*\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
mult processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "minus"
.IX Subsection "minus"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
subtract two piddles
.PP
.Vb 3
\&   $c = minus $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x \- $y;           # overloaded call
\&   $x\->inplace\->minus($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`\-\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
minus processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "divide"
.IX Subsection "divide"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
divide two piddles
.PP
.Vb 3
\&   $c = divide $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x / $y;           # overloaded call
\&   $x\->inplace\->divide($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`/\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
divide processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "gt"
.IX Subsection "gt"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary > (greater than) operation
.PP
.Vb 3
\&   $c = gt $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x > $y;           # overloaded call
\&   $x\->inplace\->gt($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
gt processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "lt"
.IX Subsection "lt"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary < (less than) operation
.PP
.Vb 3
\&   $c = lt $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x < $y;           # overloaded call
\&   $x\->inplace\->lt($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
lt processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "le"
.IX Subsection "le"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary <= (less equal) operation
.PP
.Vb 3
\&   $c = le $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x <= $y;           # overloaded call
\&   $x\->inplace\->le($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<=\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
le processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "ge"
.IX Subsection "ge"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary >= (greater equal) operation
.PP
.Vb 3
\&   $c = ge $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x >= $y;           # overloaded call
\&   $x\->inplace\->ge($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>=\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
ge processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "eq"
.IX Subsection "eq"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIequal to\fR operation (\f(CW\*(C`==\*(C'\fR)
.PP
.Vb 3
\&   $c = eq $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x == $y;           # overloaded call
\&   $x\->inplace\->eq($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`==\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
eq processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "ne"
.IX Subsection "ne"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fInot equal to\fR operation (\f(CW\*(C`!=\*(C'\fR)
.PP
.Vb 3
\&   $c = ne $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x != $y;           # overloaded call
\&   $x\->inplace\->ne($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`!=\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
ne processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "shiftleft"
.IX Subsection "shiftleft"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
leftshift \f(CW$a\fR by \f(CW$b\fR
.PP
.Vb 3
\&   $c = shiftleft $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x << $y;           # overloaded call
\&   $x\->inplace\->shiftleft($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<<\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
shiftleft processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "shiftright"
.IX Subsection "shiftright"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
rightshift \f(CW$a\fR by \f(CW$b\fR
.PP
.Vb 3
\&   $c = shiftright $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x >> $y;           # overloaded call
\&   $x\->inplace\->shiftright($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>>\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
shiftright processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "or2"
.IX Subsection "or2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIor\fR of two piddles
.PP
.Vb 3
\&   $c = or2 $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x | $y;           # overloaded call
\&   $x\->inplace\->or2($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`|\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
or2 processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "and2"
.IX Subsection "and2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIand\fR of two piddles
.PP
.Vb 3
\&   $c = and2 $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x & $y;           # overloaded call
\&   $x\->inplace\->and2($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`&\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
and2 processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "xor"
.IX Subsection "xor"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIexclusive or\fR of two piddles
.PP
.Vb 3
\&   $c = xor $x, $y, 0;     # explicit call with trailing 0
\&   $c = $x ^ $y;           # overloaded call
\&   $x\->inplace\->xor($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`^\*(C'\fR operator.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
xor processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "bitnot"
.IX Subsection "bitnot"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
unary bit negation
.PP
.Vb 2
\&   $y = ~ $x;
\&   $x\->inplace\->bitnot;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`~\*(C'\fR operator/function.
.PP
bitnot processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "power"
.IX Subsection "power"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
raise piddle \f(CW$a\fR to the power \f(CW$b\fR
.PP
.Vb 3
\&   $c = $x\->power($y,0); # explicit function call
\&   $c = $a ** $b;    # overloaded use
\&   $x\->inplace\->power($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`**\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
power processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "atan2"
.IX Subsection "atan2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \f(CW\*(C`atan2\*(C'\fR of two piddles
.PP
.Vb 3
\&   $c = $x\->atan2($y,0); # explicit function call
\&   $c = atan2 $a, $b;    # overloaded use
\&   $x\->inplace\->atan2($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`atan2\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
atan2 processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "modulo"
.IX Subsection "modulo"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \f(CW\*(C`modulo\*(C'\fR operation
.PP
.Vb 3
\&   $c = $x\->modulo($y,0); # explicit function call
\&   $c = $a % $b;    # overloaded use
\&   $x\->inplace\->modulo($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`%\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
modulo processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "spaceship"
.IX Subsection "spaceship"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \*(L"<=>\*(R" operation
.PP
.Vb 3
\&   $c = $x\->spaceship($y,0); # explicit function call
\&   $c = $a <=> $b;    # overloaded use
\&   $x\->inplace\->spaceship($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<=>\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
spaceship processes bad values.
The state of the bad-value flag of the output piddles is unknown.
.SS "sqrt"
.IX Subsection "sqrt"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
elementwise square root
.PP
.Vb 2
\&   $y = sqrt $x;
\&   $x\->inplace\->sqrt;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`sqrt\*(C'\fR operator/function.
.PP
sqrt processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "abs"
.IX Subsection "abs"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
elementwise absolute value
.PP
.Vb 2
\&   $y = abs $x;
\&   $x\->inplace\->abs;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`abs\*(C'\fR operator/function.
.PP
abs processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "sin"
.IX Subsection "sin"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the sin function
.PP
.Vb 2
\&   $y = sin $x;
\&   $x\->inplace\->sin;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`sin\*(C'\fR operator/function.
.PP
sin processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "cos"
.IX Subsection "cos"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the cos function
.PP
.Vb 2
\&   $y = cos $x;
\&   $x\->inplace\->cos;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`cos\*(C'\fR operator/function.
.PP
cos processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "not"
.IX Subsection "not"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the elementwise \fInot\fR operation
.PP
.Vb 2
\&   $y = ! $x;
\&   $x\->inplace\->not;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`!\*(C'\fR operator/function.
.PP
not processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "exp"
.IX Subsection "exp"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the exponential function
.PP
.Vb 2
\&   $y = exp $x;
\&   $x\->inplace\->exp;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`exp\*(C'\fR operator/function.
.PP
exp processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "log"
.IX Subsection "log"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the natural logarithm
.PP
.Vb 2
\&   $y = log $x;
\&   $x\->inplace\->log;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`log\*(C'\fR operator/function.
.PP
log processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "log10"
.IX Subsection "log10"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the base 10 logarithm
.PP
.Vb 2
\&   $y = log10 $x;
\&   $x\->inplace\->log10;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`log10\*(C'\fR operator/function.
.PP
log10 processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "assgn"
.IX Subsection "assgn"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
Plain numerical assignment. This is used to implement the \*(L".=\*(R" operator
.PP
If \f(CW\*(C`a\*(C'\fR is a child piddle (e.g., the result of a slice) and bad values are generated in \f(CW\*(C`b\*(C'\fR,
the bad value flag is set in \f(CW\*(C`b\*(C'\fR, but it is \fB\s-1NOT\s0\fR automatically propagated back to the parent of \f(CW\*(C`a\*(C'\fR.
The following idiom ensures that the badflag is propagated back to the parent of \f(CW\*(C`a\*(C'\fR:
.PP
.Vb 3
\& $pdl\->slice(":,(1)") .= PDL::Bad_aware_func();
\& $pdl\->badflag(1);
\& $pdl\->check_badflag();
.Ve
.PP
This is unnecessary if \f(CW$pdl\fR\->badflag is known to be 1 before the slice is performed.
.PP
See http://pdl.perl.org/PDLdocs/BadValues.html#dataflow_of_the_badflag for details.
.SS "ipow"
.IX Subsection "ipow"
.Vb 1
\&  Signature: (a(); b(); [o] ans())
.Ve
.PP
raise piddle \f(CW$a\fR to integer power \f(CW$b\fR
.PP
.Vb 3
\&   $c = $x\->ipow($y,0);     # explicit function call
\&   $c = ipow $x, $y;
\&   $x\->inplace\->ipow($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
Algorithm from Wikipedia <http://en.wikipedia.org/wiki/Exponentiation_by_squaring>
.PP
ipow does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tuomas J. Lukka (lukka@fas.harvard.edu),
Karl Glazebrook (kgb@aaoepp.aao.gov.au),
Doug Hunt (dhunt@ucar.edu),
Christian Soeller (c.soeller@auckland.ac.nz),
Doug Burke (burke@ifa.hawaii.edu),
and Craig DeForest (deforest@boulder.swri.edu).
