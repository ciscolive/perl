.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Genpass 3"
.TH App::Genpass 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::Genpass \- Quickly and easily create secure passwords
.SH "VERSION"
.IX Header "VERSION"
version 2.401
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use App::Genpass;
\&
\&    my $genpass = App::Genpass\->new();
\&    print $genpass\->generate, "\en";
\&
\&    $genpass = App::Genpass\->new( readable => 0, length => 20 );
\&    print "$_\en" for $genpass\->generate(10);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you've ever needed to create 10 (or even 10,000) passwords on the fly with
varying preferences (lowercase, uppercase, no confusing characters, special
characters, minimum length, etc.), you know it can become a pretty pesky task.
.PP
This module makes it possible to create flexible and secure passwords, quickly
and easily.
.PP
.Vb 2
\&    use App::Genpass;
\&    my $genpass = App::Genpass\->new();
\&
\&    my $single_password    = $genpass\->generate(1);  # returns scalar
\&    my @single_password    = $genpass\->generate(1);  # returns array
\&    my @multiple_passwords = $genpass\->generate(10); # returns array again
\&    my $multiple_passwords = $genpass\->generate(10); # returns arrayref
.Ve
.PP
This distribution includes a program called \fBgenpass\fR, which is a command line
interface to this module. If you need a program that generates passwords, use
\&\fBgenpass\fR.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new"
.IX Subsection "new"
Creates a new instance. It gets a lot of options.
.SS "new_with_options"
.IX Subsection "new_with_options"
Creates a new instance while reading the command line parameters.
.SS "parse_opts"
.IX Subsection "parse_opts"
Parses the command line options.
.SS "configfile"
.IX Subsection "configfile"
An attribute defining the configuration file that will be used. If one is not
provided, it tries to find one on its own. It checks for a \f(CW\*(C`.genpass.yaml\*(C'\fR in
your home directory (using File::HomeDir), and then for \f(CW\*(C`/etc/genpass.yaml\*(C'\fR.
.PP
If one is available, that's what it uses. Otherwise nothing.
.PP
You must use the \f(CW\*(C`new_with_options\*(C'\fR method described above for this.
.PP
\fIflags\fR
.IX Subsection "flags"
.PP
These are boolean flags which change the way App::Genpass works.
.IP "number" 4
.IX Item "number"
You can decide how many passwords to create. The default is 1.
.Sp
This can be overridden per \fIgenerate\fR so you can have a default of 30 but in a
specific case only generate 2, if that's what you want.
.IP "readable" 4
.IX Item "readable"
Use only readable characters, excluding confusing characters: \*(L"o\*(R", \*(L"O\*(R", \*(L"0\*(R",
\&\*(L"l\*(R", \*(L"1\*(R", \*(L"I\*(R", and special characters such as '#', '!', '%' and other symbols.
.Sp
You can overwrite what characters are considered unreadable under \*(L"character
attributes\*(R" below.
.Sp
Default: on.
.IP "verify" 4
.IX Item "verify"
Verify that every type of character wanted (lowercase, uppercase, numerical,
specials, etc.) are present in the password. This makes it just a tad slower,
but it guarantees the result. Best keep it on.
.Sp
To emphasize how \*(L"slower\*(R" it is: if you create 500 passwords of 500 character
length, using \f(CW\*(C`verify\*(C'\fR off, will make it faster by 0.1 seconds.
.Sp
Default: on.
.PP
\fIattributes\fR
.IX Subsection "attributes"
.IP "minlength" 4
.IX Item "minlength"
The minimum length of password to generate.
.Sp
Default: 8.
.IP "maxlength" 4
.IX Item "maxlength"
The maximum length of password to generate.
.Sp
Default: 10.
.IP "length" 4
.IX Item "length"
Use this if you want to explicitly specify the length of password to generate.
.PP
\fIcharacter attributes\fR
.IX Subsection "character attributes"
.PP
These are the attributes that control the types of characters. One can change
which lowercase characters will be used or whether they will be used at all,
for example.
.PP
.Vb 2
\&    # only a,b,c,d,e,g will be consdered lowercase and no uppercase at all
\&    my $gp = App::Genpass\->new( lowercase => [ \*(Aqa\*(Aq .. \*(Aqg\*(Aq ], uppercase => [] );
.Ve
.IP "lowercase" 4
.IX Item "lowercase"
All lowercase characters, excluding those that are considered unreadable if the
readable flag (described above) is turned on.
.Sp
Default: [ 'a' .. 'z' ] (not including excluded chars).
.IP "uppercase" 4
.IX Item "uppercase"
All uppercase characters, excluding those that are considered unreadable if the
readable flag (described above) is turned on.
.Sp
Default: [ 'A' .. 'Z' ] (not including excluded chars).
.IP "numerical" 4
.IX Item "numerical"
All numerical characters, excluding those that are considered unreadable if the
readable flag (described above) is turned on.
.Sp
Default: [ '0' .. '9' ] (not including excluded chars).
.IP "unreadable" 4
.IX Item "unreadable"
All characters which are considered (by me) unreadable. You can change this to
what you consider unreadable characters. For example:
.Sp
.Vb 1
\&    my $gp = App::Genpass\->new( unreadable => [ qw(jlvV) ] );
.Ve
.Sp
After all the characters are set, unreadable characters will be removed from all
sets.
.Sp
Thus, unreadable characters override all other sets. You can make unreadable
characters not count by using the \f(CW\*(C`readable => 0\*(C'\fR option, described by
the \fIreadable\fR flag above.
.IP "specials" 4
.IX Item "specials"
All special characters.
.Sp
Default: [ '!', '@', '#', '$', '%', '^', '&', '*', '(', ')' ].
.Sp
(not including excluded chars)
.SS "generate"
.IX Subsection "generate"
This method generates the password or passwords.
.PP
It accepts an optional parameter indicating how many passwords to generate.
.PP
.Vb 2
\&    $gp = App::Genpass\->new();
\&    my @passwords = $gp\->generate(300); # 300 passwords to go
.Ve
.PP
If you do not provide a parameter, it will use the default number of passwords
to generate, defined by the attribute \fBnumber\fR explained above.
.PP
This method tries to be tricky and \s-1DWIM\s0 (or rather, \s-1DWYM\s0). That is, if you
request it to generate only one password and use scalar context
(\f(CW\*(C`my $p = $gp\->generate(1)\*(C'\fR), it will return a single password.
.PP
However, if you try to generate multiple passwords and use scalar context
(\f(CW\*(C`my $p = $gp\->generate(30)\*(C'\fR), it will return an array reference for the
passwords.
.PP
Generating passwords with list context (\f(CW\*(C`my @p = $gp\->generate(...)\*(C'\fR)
will always return a list of the passwords, even if it's a single password.
.SS "get_config_from_file"
.IX Subsection "get_config_from_file"
Reads the configuration file using Config::Any.
.PP
Shamelessly lifted from MooseX::SimpleConfig.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sawyer X, \f(CW\*(C`<xsawyerx at cpan.org>\*(C'\fR
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Carp
.PP
Moo
.PP
MooX::Types::MooseLike
.PP
Getopt::Long
.PP
File::Spec
.PP
Config::Any
.PP
File::HomeDir
.PP
List::AllUtils
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-app\-genpass at rt.cpan.org\*(C'\fR,
or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=App\-Genpass>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc App::Genpass
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
Github: App::Genpass repository
.Sp
<http://github.com/xsawyerx/app\-genpass>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=App\-Genpass>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/App\-Genpass>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/App\-Genpass>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/App\-Genpass/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Sawyer X <xsawyerx@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Sawyer X.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
