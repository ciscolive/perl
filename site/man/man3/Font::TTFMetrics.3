.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Font::TTFMetrics 3"
.TH Font::TTFMetrics 3 "2003-06-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTFMetrics \- A parser for the TTF file.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Font::TTFMetrics;
\&
\&  my $metrics = Font::TTFMetrics\->new("somefont.ttf");
\&  my $ascent = $metrics\->get_ascent();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Font::TTFMetrics\*(C'\fR encapsulates the font metrics of a true type font
file. A true type font file contains several tables which need to be
parsed before any useful information could be gathered about the
font. There is the excellent module for parsing \s-1TTF\s0 font in \s-1CPAN\s0 by
Martin Hosken, \f(CW\*(C`Font::TTF\*(C'\fR. But in my opinion the use of \f(CW\*(C`Font::TTF\*(C'\fR
requires intimate knowledge of \s-1TTF\s0 font format. This module was
written to support the use of \s-1TTF\s0 in \f(CW\*(C`Pastel\*(C'\fR 2D graphics library in
Perl. Three factors prompted me to write this module: first, I
required a fast module to access \s-1TTF\s0 file. Second, all the access
required was read-only. Last, I wanted a user friendly, higher level
\&\s-1API\s0 to access \s-1TTF\s0 file.
.PP
Each font file actually contains several informations the most
important information is how a particular character will display on
screen. The shape of a character (glyph) is determined by a series of
points. The points are generally lines or points on curved path. For
details see the \s-1TTF\s0 specification. Remember, the points actually
determines the outline of the curve.TTF file stores the glyph shape in
the \*(L"glyf\*(R" table of the font. The first glyph described in this table
will be always a particular glyph, called \*(L"missing-glyph\*(R" which is
shown in case the font file doesnot contains the glyph that a software
wants.
.PP
Each character in computer is actually a number. You can find what
number corresponds to the character, you can call \f(CW\*(C`ord()\*(C'\fR on the
character. This value is called the ordinal value of the character. If
you just use common english typically the number of any character
falls between 32\-126, commonly called as \s-1ASCII.\s0 If you use some more
extra character not commonly found in key-board like \*(L"degree\*(R" then
your character code will fall between 0\-255, commonly called \s-1LATIN\-1\s0
character set. Unicode is a way to use charaters with ordinal values
beyond 255. The good thing about it is that the \s-1UTF8\s0 encoding in perl
works silently in the backdrop and you can intermix characters with
any ordinal value. This ofcourse does not mean that you will be able
to use character with any ordinal values for display. The font file
must contains the corresponding glyph.
.PP
The way to extract the glyph for a character is done by looking into
\&\*(L"cmap\*(R" table of the font. This table contains the character ordinal
number and a correspoding index. This index is used to look into the
\&\*(L"glyf\*(R" table to extract the shape of the character. Thar means if you
just substitute another index for a particular ordinal number you can
actually display a different character, a mechanism known as \*(L"glyph
substitution\*(R". As you can guess there is one more way to display a
particular character instead of what if should display in a more font
specific manner. If you just add a particular offset to a glyph
ordinal value and provide the index for this added value in the \*(L"cmap\*(R"
table, you can generate a completely different glyph. This mechanism
works for a particular type of fonts supplied by Microsoft called
symbol fonts. Example of these are symbol.ttf and wingding. Both these
fonts does not supply any glyphs corresponding to \s-1LATIN\-1\s0 character
sets but with ordinal values in the range of 61472\-61695. But notice
if you fire up your word-processor and change the font to symbol and
type any character on the key board you get a display. For example, if
you type A (ordinal value 65) what you get is greek capital
alpha. This works this way: as soon as the word-processor find that
you are using a symbol font (you can call \f(CW\*(C`is_symbol()\*(C'\fR method to
find that) it just adds 61440 to any character you type and then
queries the \*(L"cmap\*(R" table for the glyph.
.PP
One more important aspect of using a \s-1TTF\s0 file is to find the width of
a string. The easiest way to find this to query \*(L"htmx\*(R" table, which
contains advanced width of each character, add up all the advance
widths of the individual characters in the string and then go look
into \*(L"kern\*(R" table, which contains the kerning value for pair of glyphs
add deduct these values from the total width. You need to deduct also
the left-side bearing of the first character and the right-side
bearing of the last character from the total width.
.PP
User of this module should keep in mind that all the values
returned from this modules are in font-units and should be converted
to pixel unit by:
.PP
.Vb 1
\&  fIUnits * pointsize * resolution /(72 * units_per_em)
.Ve
.PP
An example from the true type specification at
<http://www.microsoft.com/typography/otspec/TTCH01.htm>:
.PP
A font-feature of 550 units when used with 18 pt on screen (typically
72 dpi resolution) will be
.PP
.Vb 1
\&  550 * 18 * 72 / ( 72 * 2048 ) = 4.83 pixels long.
.Ve
.PP
Note that the \f(CW\*(C`units_per_em\*(C'\fR value is 2048 which is typical for a \s-1TTF\s0
file. This value can be obtained by calling \f(CW\*(C`get_units_per_em()\*(C'\fR call.
.PP
This module also takes full advantage of the unicode support of
Perl. Any strings that you pass to any function call in this module
can have unicode built into into it. That means a string like:
.PP
.Vb 1
\& "Something \ex{70ff}" is perfectly valid.
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fBnew()\fP"
.IX Subsection "new()"
Creates and returns a \f(CW\*(C`Font::TTFMetrics\*(C'\fR object.
.PP
.Vb 3
\& Usage   : my $metrics = Font::TTFMetrics\->new($file); 
\& Args    : $file \- TTF filename.
\& Returns : A Font::TTFMetrics object.
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fBis_symbol()\fP"
.IX Subsection "is_symbol()"
Returns true if the font is a Symbol font from Microsoft. Remember
that Wingding is also a symbol font.
.PP
.Vb 3
\& Usage   : $metrics\->is_symbol();
\& Args    : Nothing.
\& Returns : True if the font is a Symbol font, false otherwise.
.Ve
.SS "\fBchar_width()\fP"
.IX Subsection "char_width()"
Returns the advance width of a single character, in font units.
.PP
.Vb 3
\& Usage   : $font\->char_width(\*(Aqa\*(Aq);
\& Args    : A single perl character. Can be even a unicode.
\& Returns : A scalar value. The width of the character in font units.
.Ve
.SS "\fBstring_width()\fP"
.IX Subsection "string_width()"
Given a string the function returns the width of the string in font
units. The function at present only calculates the advanced width of
the each character and deducts the calculated kerning from the whole
length. If some one has any better idea then let me know.
.PP
.Vb 3
\& Usage   : $font\->string_width("Some string");
\& Args    : A perl string. Can be embedded unicode.
\& Returns : A scalar indicating the width of the whole string in font units.
.Ve
.SS "\fBget_leading()\fP"
.IX Subsection "get_leading()"
\&\*(L"Leading\*(R" is the gap between two lines. The value is present in the
\&\f(CW\*(C`OS/2\*(C'\fR table of the font.
.PP
.Vb 3
\& Usage   : $metrics\->get_leading();
\& Args    : None.
\& Returns : A scalar Integer.
.Ve
.SS "\fBget_units_per_em()\fP"
.IX Subsection "get_units_per_em()"
Get \f(CW\*(C`units_per_em\*(C'\fR of the font. This value is present in the \f(CW\*(C`head\*(C'\fR
table of the font and for \s-1TTF\s0 is generally 2048.
.PP
.Vb 3
\& Usage   : $metrics\->get_units_per_em();
\& Args    : None.
\& Returns : A scalar integer.
.Ve
.SS "\fBget_ascent()\fP"
.IX Subsection "get_ascent()"
\&\*(L"Ascent\*(R" is the distance between the baseline to the top of the glyph.
.PP
.Vb 3
\& Usage   : $metrics\->get_ascent();
\& Args    : None.
\& Returns : A scalar integer.
.Ve
.SS "\fBget_descent()\fP"
.IX Subsection "get_descent()"
\&\*(L"Descent\*(R" is the negative distance from the baseline to the lowest
point of the glyph.
.PP
.Vb 3
\& Usage   : $metrics\->get_descent();
\& Args    : None.
\& Returns : A scalar integer.
.Ve
.SS "\fBis_bold()\fP"
.IX Subsection "is_bold()"
Returns true if the font is a bold variation of the font. That means
if you call this function of arial.ttf, it returns false. If you call
this function on arialb.ttf it returns true.
.PP
.Vb 3
\& Usage   : $metrics\->is_bold()
\& Args    : None.
\& Returns : True if the font is a bold font, returns false otherwise.
.Ve
.SS "\fBis_italic()\fP"
.IX Subsection "is_italic()"
Returns true if the font is italic version of the font. Thar means if
you call this function on arialbi.ttf or ariali.ttf it returns true.
.PP
.Vb 3
\& Usage   : $metrics\->is_italic()
\& Args    : None 
\& Returns : True if the font italic, false otherwise
.Ve
.SS "\fBget_font_family()\fP"
.IX Subsection "get_font_family()"
Returns the family name of the font.
.PP
.Vb 3
\& Usage   : $metrics\->get_font_family()
\& Args    : None
\& Returns : A scalar
.Ve
.SS "\fBget_subfamily()\fP"
.IX Subsection "get_subfamily()"
Reuturns the style variation of the font in text. Note that depending
on this description might actully be pretty confusing. Call
\&\f(CW\*(C`is_bold()\*(C'\fR and/or \f(CW\*(C`is_italic()\*(C'\fR to detemine the style. For example
a \*(L"demi\*(R" version of the font is not \*(L"bold\*(R" by text. But in display
this in actually bold variation. In this case \f(CW\*(C`is_bold()\*(C'\fR will return
true.
.PP
.Vb 3
\& Usage   : $metrics\->get_subfamily() 
\& Args    : None
\& Returns : A scalar.
.Ve
.SS "\fBis_fixed_pitch()\fP"
.IX Subsection "is_fixed_pitch()"
Returns true for a fixed-pitched font like courier.
.PP
.Vb 3
\& Usage   : $metrics\->is_fixed_pitch()
\& Args    : None
\& Returns : True for a fixed\-pitched font, false otherwise
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Font::TTF, Pastel::Font::TTF.
.SH "COPYRIGHTS"
.IX Header "COPYRIGHTS"
Copyright (c) 2003 by Malay <curiouser@ccmb.res.in>. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
