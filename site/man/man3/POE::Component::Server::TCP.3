.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "POE::Component::Server::TCP 3"
.TH POE::Component::Server::TCP 3 "2020-02-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Component::Server::TCP \- a simplified TCP server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!perl
\&
\&  use warnings;
\&  use strict;
\&
\&  use POE qw(Component::Server::TCP);
\&
\&  POE::Component::Server::TCP\->new(
\&    Port => 12345,
\&    ClientConnected => sub {
\&      print "got a connection from $_[HEAP]{remote_ip}\en";
\&      $_[HEAP]{client}\->put("Smile from the server!");
\&    },
\&    ClientInput => sub {
\&      my $client_input = $_[ARG0];
\&      $client_input =~ tr[a\-zA\-Z][n\-za\-mN\-ZA\-M];
\&      $_[HEAP]{client}\->put($client_input);
\&    },
\&  );
\&
\&  POE::Kernel\->run;
\&  exit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Component::Server::TCP implements a generic multi-Session server.
Simple services may be put together in a few lines of code.  For
example, a server that echoes input back to the client:
.PP
.Vb 6
\&  use POE qw(Component::Server::TCP);
\&  POE::Component::Server::TCP\->new(
\&    Port => 12345,
\&    ClientInput => sub { $_[HEAP]{client}\->put($_[ARG0]) },
\&  );
\&  POE::Kernel\->run();
.Ve
.SS "Accepting Connections Yourself"
.IX Subsection "Accepting Connections Yourself"
POE::Component::Server::TCP has a default mode where it accepts new
connections and creates the sessions to handle them.  Programs can do
this themselves by providing their own \f(CW\*(C`Acceptor\*(C'\fR callbacks.  See
\&\*(L"Acceptor\*(R" for details.
.SS "Master Listener Session"
.IX Subsection "Master Listener Session"
At creation time, POE::Component::Server::TCP starts one POE::Session
to listen for new connections.  The component's \f(CW\*(C`Alias\*(C'\fR refers to
this master session.
.PP
If \f(CW\*(C`Acceptor\*(C'\fR is specified, then it's up to that callback to deal
with newly accepted sockets.  Its parameters are that of
POE::Wheel::SocketFactory's \f(CW\*(C`SuccessEvent\*(C'\fR.
.PP
Otherwise, the default \f(CW\*(C`Acceptor\*(C'\fR callback will start a new session
to handle each connection.  These child sessions do not have their own
aliases, but their \f(CW\*(C`ClientConnected\*(C'\fR and \f(CW\*(C`ClientDisconnected\*(C'\fR
callbacks may be used to register and unregister the sessions with a
shared namespace, such as a hash keyed on session IDs, or an object
that manages such a hash.
.PP
.Vb 1
\&  my %client_namespace;
\&
\&  sub handle_client_connected {
\&    my $client_session_id = $_[SESSION]\->ID;
\&    $client_namespace{$client_session_id} = \e%anything;
\&  }
\&
\&  sub handle_client_disconnected {
\&    my $client_session_id = $_[SESSION]\->ID;
\&    $client_namespace{$client_session_id} = \e%anything;
\&  }
.Ve
.PP
The component's \f(CW\*(C`Started\*(C'\fR callback is invoked at the end of the
master session's start-up routine.  The \f(CW@_\fR[\s-1ARG0.\s0.$#_] parameters are
set to a copy of the values in the server's \f(CW\*(C`ListenerArgs\*(C'\fR
constructor parameter.  The other parameters are standard for
POE::Session's _start handlers.
.PP
The component's \f(CW\*(C`Stopped\*(C'\fR callback is invoked at the beginning of the
master session's _stop routine. The parameters are standard for
POE::Session's _stop handlers.
.PP
The component's \f(CW\*(C`Error\*(C'\fR callback is invoked when the server has a
problem listening for connections.  \f(CW\*(C`Error\*(C'\fR may also be called if the
component's default acceptor has trouble accepting a connection.
\&\f(CW\*(C`Error\*(C'\fR receives the usual ones for \*(L"FailureEvent\*(R" in POE::Wheel::SocketFactory and
\&\*(L"ErrorEvent\*(R" in POE::Wheel::ReadWrite.
.SS "Default Child Connection Sessions"
.IX Subsection "Default Child Connection Sessions"
If \f(CW\*(C`Acceptor\*(C'\fR isn't specified, POE::Component::Server::TCP's default
handler will start a new session for each new client connection.  As
mentioned above, these child sessions have no aliases of their own,
but they may set aliases or register themselves another way during
their \f(CW\*(C`ClientConnected\*(C'\fR and \f(CW\*(C`ClientDisconnected\*(C'\fR callbacks.
.PP
It can't be stressed enough that the following callbacks are executed
within the context of dynamic child sessions\-\-\-one per client
connection\-\-\-and not in the master listening session.  This has been a
major point of confusion.  We welcome suggestions for making this
clearer.
.PP
The component's \f(CW\*(C`ClientInput\*(C'\fR callback defines how child sessions
will handle input from their clients.  Its parameters are that of
POE::Wheel::ReadWrite's \f(CW\*(C`InputEvent\*(C'\fR.
.PP
As mentioned \f(CW\*(C`ClientConnected\*(C'\fR is called at the end of the child
session's \f(CW\*(C`_start\*(C'\fR routine.  The \f(CW\*(C`ClientConneted\*(C'\fR callback receives
the same parameters as the client session's _start does.  The arrayref
passed to the constructor's \f(CW\*(C`Args\*(C'\fR parameter is flattened and
included in \f(CW\*(C`ClientConnected\*(C'\fR's parameters as \f(CW@_\fR[\s-1ARG0.\s0.$#_].
.PP
.Vb 4
\&  sub handle_client_connected {
\&    my @constructor_args = @_[ARG0..$#_];
\&    ...
\&  }
.Ve
.PP
\&\f(CW\*(C`ClientPreConnect\*(C'\fR is called before \f(CW\*(C`ClientConnected\*(C'\fR, and its
purpose is to allow programs to reject connections or condition
sockets before they're given to POE::Wheel::ReadWrite for management.
.PP
The \f(CW\*(C`ClientPreConnect\*(C'\fR handler is called with the client socket in
\&\f(CW$_\fR[\s-1ARG0\s0], and its return value is significant.  It must return a
valid client socket if the connection is acceptable.  It must return
undef to reject the connection.
.PP
Most \f(CW$_\fR[\s-1HEAP\s0] values are valid in the \f(CW\*(C`ClientPreConnect\*(C'\fR handler.
Obviously, \f(CW$_\fR[\s-1HEAP\s0]{client} is not because that wheel hasn't been
created yet.
.PP
In the following example, the \f(CW\*(C`ClientPreConnect\*(C'\fR handler returns the
client socket after it has been upgraded to an \s-1SSL\s0 connection.
.PP
.Vb 1
\&  sub handle_client_pre_connect {
\&
\&    # Make sure the remote address and port are valid.
\&    return undef unless validate(
\&      $_[HEAP]{remote_ip}, $_[HEAP]{remote_port}
\&    );
\&
\&    # SSLify the socket, which is in $_[ARG0].
\&    my $socket = eval { Server_SSLify($_[ARG0]) };
\&    return undef if $@;
\&
\&    # Return the SSL\-ified socket.
\&    return $socket;
\&  }
.Ve
.PP
\&\f(CW\*(C`ClientDisconnected\*(C'\fR is called when the client has disconnected,
either because the remote socket endpoint has closed or the local
endpoint has been closed by the server.  This doesn't mean the
client's session has ended, but the session most likely will very
shortly.  \f(CW\*(C`ClientDisconnected\*(C'\fR is called from a couple disparate
places within the component, so its parameters are neither consistent
nor generally useful.
.PP
\&\f(CW\*(C`ClientError\*(C'\fR is called when an error has occurred on the socket.
Its parameters are those of POE::Wheel::ReadWrite's \f(CW\*(C`ErrorEvent\*(C'\fR.
.PP
\&\f(CW\*(C`ClientFlushed\*(C'\fR is called when all pending output has been flushed to
the client socket.  Its parameters come from POE::Wheel::ReadWrite's
\&\f(CW\*(C`ErrorEvent\*(C'\fR.
.SS "Performance Considerations"
.IX Subsection "Performance Considerations"
This ease of use comes at a price: POE::Component::Server::TCP often
performs significantly slower than a comparable server written with
POE::Wheel::SocketFactory and POE::Wheel::ReadWrite.
.PP
If performance is your primary goal, POE::Kernel's \fBselect_read()\fR and
\&\fBselect_write()\fR perform about the same as IO::Select, but your code
will be portable across every event loop \s-1POE\s0 supports.
.SS "Special Needs Considerations"
.IX Subsection "Special Needs Considerations"
POE::Component::Server::TCP is written to be easy for the most common
use cases.  Programs with more special needs should consider using
POE::Wheel::SocketFactory and POE::Wheel::ReadWrite instead.  These
are lower-level modules, and using them requires more effort.  They
are more flexible and customizable, however.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "new"
.IX Subsection "new"
\&\fBnew()\fR starts a server based on POE::Component::Server::TCP and returns
a session \s-1ID\s0 for the master listening session.  All error handling is
done within the server, via the \f(CW\*(C`Error\*(C'\fR and \f(CW\*(C`ClientError\*(C'\fR callbacks.
.PP
The server may be shut down by posting a \*(L"shutdown\*(R" event to the
master session, either by its \s-1ID\s0 or the name given to it by the
\&\f(CW\*(C`Alias\*(C'\fR parameter.
.PP
POE::Component::Server::TCP does a lot of work in its constructor.
The design goal is to push as much overhead into one-time construction
so that ongoing run-time has less overhead.  Because of this, the
server's constructor can take quite a daunting number of parameters.
.PP
POE::Component::Server::TCP always returns a POE::Session \s-1ID\s0 for the
session that will be listening for new connections.
.PP
Many of the constructor parameters have been previously described.
They are covered briefly again below.
.PP
\fIServer Session Configuration\fR
.IX Subsection "Server Session Configuration"
.PP
These constructor parameters affect POE::Component::Server::TCP's main
listening session.
.PP
Acceptor
.IX Subsection "Acceptor"
.PP
\&\f(CW\*(C`Acceptor\*(C'\fR defines a \s-1CODE\s0 reference that POE::Wheel::SocketFactory's
\&\f(CW\*(C`SuccessEvent\*(C'\fR will trigger to handle new connections.  Therefore the
parameters passed to \f(CW\*(C`Acceptor\*(C'\fR are identical to those given to
\&\f(CW\*(C`SuccessEvent\*(C'\fR.
.PP
\&\f(CW\*(C`Acceptor\*(C'\fR is optional; the default handler will create a new session
for each connection.  All the \*(L"Client\*(R" constructor parameters are used
to customize this session.  In other words, \f(CW\*(C`ClientInput\*(C'\fR and such
\&\fBare not used when \f(CB\*(C`Acceptor\*(C'\fB is set\fR.
.PP
The default \f(CW\*(C`Acceptor\*(C'\fR adds significant convenience and flexibility
to POE::Component::Server::TCP, but it's not always a good fit for
every application.  In some cases, a custom \f(CW\*(C`Acceptor\*(C'\fR or even
rolling one's own server with POE::Wheel::SocketFactory and
POE::Wheel::ReadWrite may be better and/or faster.
.PP
.Vb 4
\&  Acceptor => sub {
\&    my ($socket, $remote_address, $remote_port) = @_[ARG0..ARG2];
\&    # Set up something to interact with the client.
\&  }
.Ve
.PP
Address
.IX Subsection "Address"
.PP
\&\f(CW\*(C`Address\*(C'\fR defines a single interface address the server will bind to.
It defaults to \s-1INADDR_ANY\s0 or \s-1INADDR6_ANY,\s0 when using IPv4 or IPv6,
respectively.  It is often used with \f(CW\*(C`Port\*(C'\fR.
.PP
The value in \f(CW\*(C`Address\*(C'\fR is passed to POE::Wheel::SocketFactory's
\&\f(CW\*(C`BindAddress\*(C'\fR parameter, so it may be in whatever form that module
supports.  At the time of this writing, that may be a dotted IPv4
quad, an IPv6 address, a host name, or a packed Internet address.  See
also \*(L"Hostname\*(R".
.PP
.Vb 2
\&  Address => \*(Aq127.0.0.1\*(Aq   # Localhost IPv4
\&  Address => "::1"         # Localhost IPv6
.Ve
.PP
Alias
.IX Subsection "Alias"
.PP
\&\f(CW\*(C`Alias\*(C'\fR is an optional name that will be given to the server's master
listening session.  Events sent to this name will not be delivered to
individual connections.
.PP
The server's \f(CW\*(C`Alias\*(C'\fR may be important if it's necessary to shut a
server down.
.PP
.Vb 4
\&  sub sigusr1_handler {
\&    $_[KERNEL]\->post(chargen_server => \*(Aqshutdown\*(Aq);
\&    $_[KERNEL]\->sig_handled();
\&  }
.Ve
.PP
Concurrency
.IX Subsection "Concurrency"
.PP
\&\f(CW\*(C`Concurrency\*(C'\fR controls how many connections may be active at the same
time.  It defaults to \-1, which allows POE::Component::Server::TCP to
accept concurrent connections until the process runs out of resources.
.PP
Setting \f(CW\*(C`Concurrency\*(C'\fR to 0 prevents the server from accepting new
connections.  This may be useful if a server must perform lengthy
initialization before allowing connections.  When the initialization
finishes, it can yield(set_concurrency => \-1) to enable connections.
Likewise, a running server may yield(set_concurrency => 0) or any
other number to dynamically tune its concurrency.  See \*(L"\s-1EVENTS\*(R"\s0 for
more about the set_concurrency event.
.PP
Note: For \f(CW\*(C`Concurrency\*(C'\fR to work with a custom \f(CW\*(C`Acceptor\*(C'\fR, the
server's listening session must receive a \f(CW\*(C`disconnected\*(C'\fR event
whenever clients disconnect.  Otherwise the listener cannot mediate
between its connections.
.PP
Example:
.PP
.Vb 10
\&  Acceptor => sub {
\&    # ....
\&    POE::Session\->create(
\&      # ....
\&      inline_states => {
\&        _start => sub {
\&          # ....
\&          # remember who our parent is
\&          $_[HEAP]\->{server_tcp} = $_[SENDER]\->ID;
\&          # ....
\&        },
\&        got_client_disconnect => sub {
\&          # ....
\&          $_[KERNEL]\->post( $_[HEAP]\->{server_tcp} => \*(Aqdisconnected\*(Aq );
\&          # ....
\&        }
\&      }
\&    );
\&  }
.Ve
.PP
Domain
.IX Subsection "Domain"
.PP
\&\f(CW\*(C`Domain\*(C'\fR sets the address or protocol family within which to operate.
The \f(CW\*(C`Domain\*(C'\fR may be any value that POE::Wheel::SocketFactory
supports.  \s-1AF_INET\s0 (Internet address space) is used by default.
.PP
Use \s-1AF_INET6\s0 for IPv6 support.  This constant is exported by Socket
or Socket6, depending on your version of Perl. Also be sure to have
Socket::GetAddrInfo installed, which is required by
POE::Wheel::SocketFactory for IPv6 support.
.PP
Error
.IX Subsection "Error"
.PP
\&\f(CW\*(C`Error\*(C'\fR is the callback that will be invoked when the server socket
reports an error.  The Error callback will be used to handle
POE::Wheel::SocketFactory's FailureEvent, so it will receive the same
parameters as discussed there.
.PP
A default error handler will be provided if Error is omitted.  The
default handler will log the error to \s-1STDERR\s0 and shut down the server.
Active connections will be permitted to complete their transactions.
.PP
.Vb 4
\&  Error => sub {
\&    my ($syscall_name, $err_num, $err_str) = @_[ARG0..ARG2];
\&    # Handle the error.
\&  }
.Ve
.PP
Hostname
.IX Subsection "Hostname"
.PP
\&\f(CW\*(C`Hostname\*(C'\fR is the optional non-packed name of the interface the \s-1TCP\s0
server will bind to.  The hostname will always be resolved via
\&\fBinet_aton()\fR and so can either be a dotted quad or a name.  Name
resolution is a one-time start-up action; there are no ongoing
run-time penalties for using it.
.PP
\&\f(CW\*(C`Hostname\*(C'\fR guarantees name resolution, where \f(CW\*(C`Address\*(C'\fR does not.
It's therefore preferred to use \f(CW\*(C`Hostname\*(C'\fR in cases where resolution
must always be done.
.PP
InlineStates
.IX Subsection "InlineStates"
.PP
\&\f(CW\*(C`InlineStates\*(C'\fR is optional.  If specified, it must hold a hashref of
named callbacks.  Its syntax is that of POE:Session\->\fBcreate()\fR's
inline_states parameter.
.PP
Remember: These InlineStates handlers will be added to the client
sessions, not to the main listening session.  A \fByield()\fR in the listener
will not reach these handlers.
.PP
If POE::Kernel::ASSERT_USAGE is enabled, the constructor will \fBcroak()\fR if it
detects a state that it uses internally. For example, please use the \*(L"Started\*(R"
and \*(L"Stopped\*(R" callbacks if you want to specify your own \*(L"_start\*(R" and \*(L"_stop\*(R"
events respectively.
.PP
ObjectStates
.IX Subsection "ObjectStates"
.PP
If \f(CW\*(C`ObjectStates\*(C'\fR is specified, it must holde an arrayref of objects
and the events they will handle.  The arrayref must follow the syntax
for POE::Session\->\fBcreate()\fR's object_states parameter.
.PP
Remember: These ObjectStates handlers will be added to the client 
sessions, not to the main listening session.  A \fByield()\fR in the listener
will not reach these handlers.
.PP
If POE::Kernel::ASSERT_USAGE is enabled, the constructor will \fBcroak()\fR if it
detects a state that it uses internally. For example, please use the \*(L"Started\*(R"
and \*(L"Stopped\*(R" callbacks if you want to specify your own \*(L"_start\*(R" and \*(L"_stop\*(R"
events respectively.
.PP
PackageStates
.IX Subsection "PackageStates"
.PP
When the optional \f(CW\*(C`PackageStates\*(C'\fR is set, it must hold an arrayref of
package names and the events they will handle  The arrayref must
follow the syntax for POE::Session\->\fBcreate()\fR's package_states
parameter.
.PP
Remember: These PackageStates handlers will be added to the client 
sessions, not to the main listening session.  A \fByield()\fR in the listener
will not reach these handlers.
.PP
If POE::Kernel::ASSERT_USAGE is enabled, the constructor will \fBcroak()\fR if it
detects a state that it uses internally. For example, please use the \*(L"Started\*(R"
and \*(L"Stopped\*(R" callbacks if you want to specify your own \*(L"_start\*(R" and \*(L"_stop\*(R"
events respectively.
.PP
Port
.IX Subsection "Port"
.PP
\&\f(CW\*(C`Port\*(C'\fR contains the port the listening socket will be bound to.  It
defaults to 0, which usually lets the operating system pick a
port at random.
.PP
.Vb 1
\&  Port => 30023
.Ve
.PP
It is often used with \f(CW\*(C`Address\*(C'\fR.
.PP
Started
.IX Subsection "Started"
.PP
\&\f(CW\*(C`Started\*(C'\fR sets an optional callback that will be invoked within the
main server session's context.  It notifies the server that it has
fully started.  The callback's parameters are the usual for a
session's _start handler.
.PP
Stopped
.IX Subsection "Stopped"
.PP
\&\f(CW\*(C`Stopped\*(C'\fR sets an optional callback that will be invoked within the
main server session's context.  It notifies the server that it has
fully stopped.  The callback's parameters are the usual for a
session's _stop handler.
.PP
ListenerArgs
.IX Subsection "ListenerArgs"
.PP
\&\f(CW\*(C`ListenerArgs\*(C'\fR is passed to the listener session as the \f(CW\*(C`args\*(C'\fR parameter.  In
other words, it must be an arrayref, and the values are passed into the
\&\f(CW\*(C`Started\*(C'\fR handler as \s-1ARG0, ARG1,\s0 etc.
.PP
\fIConnection Session Configuration\fR
.IX Subsection "Connection Session Configuration"
.PP
These constructor parameters affect the individual sessions that
interact with established connections.
.PP
ClientArgs
.IX Subsection "ClientArgs"
.PP
\&\f(CW\*(C`ClientArgs\*(C'\fR is optional.  When specified, it holds an \s-1ARRAYREF\s0 that
will be expanded one level and passed to the \f(CW\*(C`ClientConnected\*(C'\fR
callback in \f(CW@_\fR[\s-1ARG0.\s0.$#_].
.PP
ClientConnected
.IX Subsection "ClientConnected"
.PP
Each new client connection is handled by a new POE::Session instance.
\&\f(CW\*(C`ClientConnected\*(C'\fR is a callback that notifies the application when a
client's session is started and ready for operation.  Banners are
often sent to the remote client from this callback.
.PP
The \f(CW@_\fR[\s-1ARG0.\s0.$#_] parameters to \f(CW\*(C`ClientConnected\*(C'\fR are a copy of the
values in the \f(CW\*(C`ClientArgs\*(C'\fR constructor parameter's array reference.
The other \f(CW@_\fR members are standard for a POE::Session _start handler.
.PP
\&\f(CW\*(C`ClientConnected\*(C'\fR is called once per session start-up.  It will never
be called twice for the same connection.
.PP
.Vb 4
\&  ClientConnected => sub {
\&    $_[HEAP]{client}\->put("Hello, client!");
\&    # Other client initialization here.
\&  },
.Ve
.PP
ClientDisconnected
.IX Subsection "ClientDisconnected"
.PP
\&\f(CW\*(C`ClientDisconnected\*(C'\fR is a callback that will be invoked when the
client disconnects or has been disconnected by the server.  It's
useful for cleaning up global client information, such as chat room
structures.  \f(CW\*(C`ClientDisconnected\*(C'\fR callbacks receive the usual \s-1POE\s0
parameters, but nothing special is included.
.PP
.Vb 3
\&  ClientDisconnected => sub {
\&    warn "Client disconnected"; # log it
\&  }
.Ve
.PP
ClientError
.IX Subsection "ClientError"
.PP
The \f(CW\*(C`ClientError\*(C'\fR callback is invoked when a client socket reports an
error.  \f(CW\*(C`ClientError\*(C'\fR is called with \s-1POE\s0's usual parameters, plus the
common error parameters: \f(CW$_\fR[\s-1ARG0\s0] describes what was happening at the
time of failure.  \f(CW$_\fR[\s-1ARG1\s0] and \f(CW$_\fR[\s-1ARG2\s0] contain the numeric and string
versions of $!, respectively.
.PP
\&\f(CW\*(C`ClientError\*(C'\fR is optional.  If omitted, POE::Component::Server::TCP
will provide a default callback that logs most errors to \s-1STDERR.\s0
.PP
If \f(CW\*(C`ClientShutdownOnError\*(C'\fR is set, the connection will be shut down
after \f(CW\*(C`ClientError\*(C'\fR returns.  If \f(CW\*(C`ClientDisconnected\*(C'\fR is specified,
it will be called as the client session is cleaned up.
.PP
\&\f(CW\*(C`ClientError\*(C'\fR is triggered by POE::Wheel::ReadWrite's ErrorEvent, so
it follows that event's form.  Please see the ErrorEvent documentation
in POE::Wheel::ReadWrite for more details.
.PP
.Vb 4
\&  ClientError => sub {
\&    my ($syscall_name, $error_num, $error_str) = @_[ARG0..ARG2];
\&    # Handle the client error here.
\&  }
.Ve
.PP
ClientFilter
.IX Subsection "ClientFilter"
.PP
\&\f(CW\*(C`ClientFilter\*(C'\fR specifies the POE::Filter object or class that will
parse input from each client and serialize output before it's sent to
each client.
.PP
\&\f(CW\*(C`ClientFilter\*(C'\fR may be a \s-1SCALAR,\s0 in which case it should name the
POE::Filter class to use.  Each new connection will be given a freshly
instantiated filter of that class.  No constructor parameters will be
passed.
.PP
.Vb 1
\&  ClientFilter => "POE::Filter::Stream",
.Ve
.PP
Some filters require constructor parameters.  These may be specified
by an \s-1ARRAYREF.\s0  The first element is the POE::Filter class name, and
subsequent elements are passed to the class' constructor.
.PP
.Vb 1
\&  ClientFilter => [ "POE::Filter::Line", Literal => "\en" ],
.Ve
.PP
\&\f(CW\*(C`ClientFilter\*(C'\fR may also be given an archetypical POE::Filter \s-1OBJECT.\s0
In this case, each new client session will receive a \fBclone()\fR of the
given object.
.PP
.Vb 1
\&  ClientFilter => POE::Filter::Line\->new(Literal => "\en"),
.Ve
.PP
\&\f(CW\*(C`ClientFilter\*(C'\fR is optional.  The component will use
\&\*(L"POE::Filter::Line\*(R" if it is omitted.  There is \*(L"ClientInputFilter\*(R"
and \*(L"ClientOutputFilter\*(R" if you want to specify a different filter
for both directions.
.PP
Filter modules are not automatically loaded.  Be sure that the program
loads the class before using it.
.PP
ClientFlushed
.IX Subsection "ClientFlushed"
.PP
\&\f(CW\*(C`ClientFlushed\*(C'\fR exposes POE::Wheel::ReadWrite's \f(CW\*(C`FlushedEvent\*(C'\fR as a
callback.  It is called whenever the client's output buffer has been
fully flushed to the client socket.  At this point it's safe to shut
down the socket without losing data.
.PP
\&\f(CW\*(C`ClientFlushed\*(C'\fR is useful for streaming servers, where a \*(L"flushed\*(R"
event signals the need to send more data.
.PP
.Vb 10
\&  ClientFlushed => sub {
\&    my $data_source = $_[HEAP]{file_handle};
\&    my $read_count = sysread($data_source, my $buffer = "", 65536);
\&    if ($read_count) {
\&      $_[HEAP]{client}\->put($buffer);
\&    }
\&    else {
\&      $_[KERNEL]\->yield("shutdown");
\&    }
\&  },
.Ve
.PP
POE::Component::Server::TCP's default \f(CW\*(C`Acceptor\*(C'\fR ensures that data is
flushed before finishing a client shutdown.
.PP
ClientInput
.IX Subsection "ClientInput"
.PP
\&\f(CW\*(C`ClientInput\*(C'\fR defines a per-connection callback to handle client
input.  This callback receives its parameters directly from
POE::Wheel::ReadWrite's \f(CW\*(C`InputEvent\*(C'\fR.  \s-1ARG0\s0 contains the input
record, the format of which is defined by \f(CW\*(C`ClientFilter\*(C'\fR or
\&\f(CW\*(C`ClientInputFilter\*(C'\fR.  \s-1ARG1\s0 has the wheel's unique \s-1ID,\s0 and so on.
Please see POE:Wheel::ReadWrite for an in-depth description of
\&\f(CW\*(C`InputEvent\*(C'\fR.
.PP
\&\f(CW\*(C`ClientInput\*(C'\fR and \f(CW\*(C`Acceptor\*(C'\fR are mutually exclusive.  Enabling one
prohibits the other.
.PP
.Vb 4
\&  ClientInput => sub {
\&    my $input = $_[ARG0];
\&    $_[HEAP]{wheel}\->put("You said: $input");
\&  },
.Ve
.PP
ClientInputFilter
.IX Subsection "ClientInputFilter"
.PP
\&\f(CW\*(C`ClientInputFilter\*(C'\fR is used with \f(CW\*(C`ClientOutputFilter\*(C'\fR to specify
different protocols for input and output.  Both must be used together.
Both follow the same usage as \*(L"ClientFilter\*(R".  Overrides the filter set
by \*(L"ClientFilter\*(R".
.PP
.Vb 2
\&  ClientInputFilter  => [ "POE::Filter::Line", Literal => "\en" ],
\&  ClientOutputFilter => \*(AqPOE::Filter::Stream\*(Aq,
.Ve
.PP
ClientOutputFilter
.IX Subsection "ClientOutputFilter"
.PP
\&\f(CW\*(C`ClientOutputFilter\*(C'\fR is used with \f(CW\*(C`ClientInputFilter\*(C'\fR to specify
different protocols for input and output.  Both must be used together.
Both follow the same usage as \*(L"ClientFilter\*(R".  Overrides the filter set
by \*(L"ClientFilter\*(R".
.PP
.Vb 2
\&  ClientInputFilter  => POE::Filter::Line\->new(Literal => "\en"),
\&  ClientOutputFilter => \*(AqPOE::Filter::Stream\*(Aq,
.Ve
.PP
ClientShutdownOnError
.IX Subsection "ClientShutdownOnError"
.PP
\&\f(CW\*(C`ClientShutdownOnError\*(C'\fR tells the component whether client
connections should be shut down automatically if an error is detected.
It defaults to \*(L"true\*(R".  Setting it to false (0, undef, "") turns off
this feature.
.PP
The application is responsible for dealing with client errors if this
feature is disabled.  Not doing so may cause the component to emit a
constant stream of errors, eventually bogging down the application
with dead connections that spin out of control.
.PP
Yes, this is terrible.  You have been warned.
.PP
SessionParams
.IX Subsection "SessionParams"
.PP
\&\f(CW\*(C`SessionParams\*(C'\fR specifies additional parameters that will be passed
to the \f(CW\*(C`SessionType\*(C'\fR constructor at creation time.  It must be an
array reference.
.PP
.Vb 1
\&  SessionParams => [ options => { debug => 1, trace => 1 } ],
.Ve
.PP
Note: POE::Component::Server::TCP supplies its own POE::Session
constructor parameters.  Conflicts between them and \f(CW\*(C`SessionParams\*(C'\fR
may cause the component to behave erratically.  To avoid such
problems, please limit SessionParams to the \f(CW\*(C`options\*(C'\fR hash.  See
POE::Session for an known options.
.PP
We may enable other options later.  Please let us know if you need
something.
.PP
SessionType
.IX Subsection "SessionType"
.PP
\&\f(CW\*(C`SessionType\*(C'\fR specifies the POE::Session subclass that will be
created for each new client connection.  \*(L"POE::Session\*(R" is the
default.
.PP
.Vb 1
\&  SessionType => "POE::Session::MultiDispatch"
.Ve
.SH "EVENTS"
.IX Header "EVENTS"
It's possible to manipulate a \s-1TCP\s0 server component by sending it
messages.
.SS "Main Server Commands"
.IX Subsection "Main Server Commands"
These events must be sent to the main server, usually by the alias set
in its Alias parameter.
.PP
\fIdisconnected\fR
.IX Subsection "disconnected"
.PP
The \*(L"disconnected\*(R" event informs the \s-1TCP\s0 server that a connection was
closed.  It is needed when using \*(L"Concurrency\*(R" with an \*(L"Acceptor\*(R"
callback.  The custom Acceptor must provide its own disconnect
notification so that the server's connection counting logic works.
.PP
Otherwise Concurrency clients will be accepted, and then no more.  The
server will never know when clients have disconnected.
.PP
\fIset_concurrency\fR
.IX Subsection "set_concurrency"
.PP
\&\*(L"set_concurrency\*(R" set the number of simultaneous connections the
server will be willing to accept.  See \*(L"Concurrency\*(R" for more
details.  \*(L"set_concurrency\*(R" must have one parameter: the new maximum
connection count.
.PP
.Vb 1
\&  $kernel\->call("my_server_alias", "set_concurrency", $max_count);
.Ve
.PP
\fIshutdown\fR
.IX Subsection "shutdown"
.PP
The \*(L"shutdown\*(R" event starts a graceful server shutdown.  No new
connections will be accepted.  Existing connections will be allowed to
finish.  The server will be destroyed after the last connection ends.
.SS "Per-Connection Commands"
.IX Subsection "Per-Connection Commands"
These commands affect each client connection session.
.PP
\fIshutdown\fR
.IX Subsection "shutdown"
.PP
Sending \*(L"shutdown\*(R" to an individual client session instructs the
server to gracefully shut down that connection.  No new input will be
received, and any buffered output will be sent before the session
ends.
.PP
Client sessions usually yield(\*(L"shutdown\*(R") when they wish to disconnect
the client.
.PP
.Vb 6
\&  ClientInput => sub {
\&    if ($_[ARG0] eq "quit") {
\&      $_[HEAP]{client}\->put("B\*(Aqbye!");
\&      $_[KERNEL]\->yield("shutdown");
\&      return;
\&    }
\&
\&    # Handle other input here.
\&  },
.Ve
.SH "Reserved HEAP Members"
.IX Header "Reserved HEAP Members"
Unlike most \s-1POE\s0 modules, POE::Component::Server::TCP stores data in
the client sessions' HEAPs.  These values are provided as conveniences
for application developers.
.SS "\s-1HEAP\s0 Members for Master Listening Sessions"
.IX Subsection "HEAP Members for Master Listening Sessions"
The master listening session holds different data than client
connections.
.PP
\fIalias\fR
.IX Subsection "alias"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{alias} contains the server's Alias.
.PP
\fIconcurrency\fR
.IX Subsection "concurrency"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{concurrency} remembers the server's \f(CW\*(C`Concurrency\*(C'\fR parameter.
.PP
\fIconnections\fR
.IX Subsection "connections"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{connections} is used to track the current number of
concurrent client connections.  It's incremented whenever a new
connection is accepted, and it's decremented whenever a client
disconnects.
.PP
\fIlistener\fR
.IX Subsection "listener"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{listener} contains the POE::Wheel::SocketFactory object used
to listen for connections and accept them.
.SS "\s-1HEAP\s0 Members for Connection Sessions"
.IX Subsection "HEAP Members for Connection Sessions"
These data members exist within the individual connections' sessions.
.PP
\fIclient\fR
.IX Subsection "client"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{client} contains a POE::Wheel::ReadWrite object used to
interact with the client.  All POE::Wheel::ReadWrite methods work.
.PP
\fIgot_an_error\fR
.IX Subsection "got_an_error"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{got_an_error} remembers whether the client connection has
already encountered an error.  It is part of the shutdown-on-error
procedure.
.PP
\fIremote_ip\fR
.IX Subsection "remote_ip"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{remote_ip} contains the remote client's numeric address in
human-readable form.
.PP
\fIremote_port\fR
.IX Subsection "remote_port"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{remote_port} contains the remote client's numeric socket port
in human-readable form.
.PP
\fIremote_addr\fR
.IX Subsection "remote_addr"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{remote_addr} contains the remote client's packed socket
address in computer-readable form.
.PP
\fIshutdown\fR
.IX Subsection "shutdown"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{shutdown} is true if the client is in the process of shutting
down.  The component uses it to ignore client input during shutdown,
and to close the connection after pending output has been flushed.
.PP
\fIshutdown_on_error\fR
.IX Subsection "shutdown_on_error"
.PP
\&\f(CW$_\fR[\s-1HEAP\s0]{shutdown_on_error} remembers whether the client connection
should automatically shut down if an error occurs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1SEE ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.PP
POE::Component::Client::TCP is the client-side counterpart to this
module.
.PP
This component uses and exposes features from POE::Filter,
POE::Wheel::SocketFactory, and POE::Wheel::ReadWrite.
.SH "BUGS"
.IX Header "BUGS"
This looks nothing like what Ann envisioned.
.PP
This component currently does not accept many of the options that
POE::Wheel::SocketFactory does.
.PP
This component will not bind to several addresses at once.  This may
be a limitation in SocketFactory, but it's not by design.
.PP
This component needs better error handling.
.PP
Some use cases require different session classes for the listener and
the connection handlers.  This isn't currently supported.  Please send
patches. :)
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
POE::Component::Server::TCP is Copyright 2000\-2013 by Rocco Caputo.
All rights are reserved.  POE::Component::Server::TCP is free
software, and it may be redistributed and/or modified under the same
terms as Perl itself.
.PP
POE::Component::Server::TCP is based on code, used with permission,
from Ann Barcomb <kudra@domaintje.com>.
.PP
POE::Component::Server::TCP is based on code, used with permission,
from Jos Boumans <kane@cpan.org>.
