.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Return::Type 3"
.TH Return::Type 3 "2020-10-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Return::Type \- specify a return type for a function (optionally with coercion)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Return::Type;
\&   use Types::Standard qw(Int);
\&   
\&   sub first_item :ReturnType(Int) {
\&      return $_[0];
\&   }
\&   
\&   my $answer = first_item(42, 43, 44);     # returns 42
\&   my $pie    = first_item(3.141592);       # throws an error!
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Return::Type allows you to specify a return type for your subs. Type
constraints from any Type::Tiny, MooseX::Types or MouseX::Types
type library are supported.
.PP
The simple syntax for specifying a type constraint is shown in the
\&\*(L"\s-1SYNOPSIS\*(R"\s0. If the attribute is passed a single type constraint as shown,
this will be applied to the return value if called in scalar context, and
to each item in the returned list if called in list context. (If the sub
is called in void context, type constraints are simply ignored.)
.PP
It is possible to specify different type constraints for scalar and
list context:
.PP
.Vb 8
\&   sub foo :ReturnType(scalar => Int, list => HashRef[Num]) {
\&      if (wantarray) {
\&         return (pie => 3.141592);
\&      }
\&      else {
\&         return 42;
\&      }
\&   }
.Ve
.PP
The return value is not type checked if the function is called in void
context.
.PP
.Vb 8
\&   # Note that the ~Any type is the opposite of Any.
\&   # So all values will fail the type check.
\&   # That means that the following function can only
\&   # be called in void context.
\&   #
\&   sub foo :ReturnType(scalar => ~Any, list => ~Any) {
\&      ...;
\&   }
\&   
\&   # Shortcut for the above.
\&   #
\&   sub foo :ReturnType(Void) {
\&      ...;
\&   }
.Ve
.PP
Note that because type constraint libraries are really aimed at
validating scalars, the type constraint for the list is specified as
a \fIhashref\fR of numbers and not a hash of numbers! For the purposes
of validation against the type constraint, we slurp the returned list
into a temporary arrayref or hashref.
.PP
For type constraints with coercions, you can also pass the option
\&\f(CW\*(C`coerce => 1\*(C'\fR:
.PP
.Vb 2
\&   use Return::Type;
\&   use Types::Standard qw( Int Num );
\&   
\&   # Define a subtype of "Int" at compile time, which can
\&   # coerce from "Num" by rounding to nearest integer.
\&   use constant Rounded => Int\->plus_coercions(Num, sub { int($_) });
\&   
\&   sub first_item :ReturnType(scalar => Rounded, coerce => 1) {
\&      return $_[0];
\&   }
\&   
\&   my $answer = first_item(42, 43, 44);     # returns 42
\&   my $pie    = first_item(3.141592);       # returns 3
.Ve
.PP
The options \f(CW\*(C`coerce_scalar\*(C'\fR and \f(CW\*(C`coerce_list\*(C'\fR are also available if
you wish to enable coercion only in particular contexts.
.SS "Power-user Inferface"
.IX Subsection "Power-user Inferface"
Rather than using the \f(CW\*(C`:ReturnType\*(C'\fR attribute, it's possible to
wrap a coderef like this:
.PP
.Vb 1
\&   my $wrapped = Return::Type\->wrap_sub($orig, %options);
.Ve
.PP
The accepted options are \f(CW\*(C`scalar\*(C'\fR, \f(CW\*(C`list\*(C'\fR, \f(CW\*(C`coerce\*(C'\fR, \f(CW\*(C`coerce_list\*(C'\fR,
and \f(CW\*(C`coerce_scalar\*(C'\fR, as per the attribute-based interface.
.PP
There is an additional option \f(CW\*(C`scope_upper\*(C'\fR which will load and use
Scope::Upper so that things like \f(CW\*(C`caller\*(C'\fR used within the wrapped
sub are unaware of being wrapped. This behaviour was the default
prior to Return::Type 0.004, but is now optional and disabled by
default.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=Return\-Type>.
.SH "SUPPORT"
.IX Header "SUPPORT"
\&\fB\s-1IRC:\s0\fR support is available through in the \fI#moops\fR channel
on irc.perl.org <http://www.irc.perl.org/channels.html>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Attribute::Contract,
Sub::Filter,
Sub::Contract.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
