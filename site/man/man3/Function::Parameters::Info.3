.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Function::Parameters::Info 3"
.TH Function::Parameters::Info 3 "2017-11-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Function::Parameters::Info \- Information about parameter lists
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Function::Parameters;
\&  
\&  fun foo($x, $y, :$hello, :$world = undef) {}
\&  
\&  my $info = Function::Parameters::info \e&foo;
\&  my @p0 = $info\->invocants;            # ()
\&  my @p1 = $info\->positional_required;  # (\*(Aq$x\*(Aq, \*(Aq$y\*(Aq)
\&  my @p2 = $info\->positional_optional;  # ()
\&  my @p3 = $info\->named_required;       # (\*(Aq$hello\*(Aq)
\&  my @p4 = $info\->named_optional;       # (\*(Aq$world\*(Aq)
\&  my $p5 = $info\->slurpy;               # undef
\&  my $min = $info\->args_min;  # 4
\&  my $max = $info\->args_max;  # inf
\&  
\&  my @invocants = Function::Parameters::info(method () { 42 })\->invocants;
\&  # (\*(Aq$self\*(Aq)
\&  
\&  my $slurpy = Function::Parameters::info(fun (@) {})\->slurpy;  # \*(Aq@\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Function::Parameters::info\*(C'\fR returns
objects of this class to describe parameter lists of functions. See below for
\&\*(L"Parameter Objects\*(R".  The following methods are available:
.PP
\fI\f(CI$info\fI\->invocants\fR
.IX Subsection "$info->invocants"
.PP
Returns a list of parameter objects for the variables into which initial
arguments are \f(CW\*(C`shift\*(C'\fRed automatically (or a count in
scalar context). This will usually return \f(CW\*(C`()\*(C'\fR for normal functions and
\&\f(CW\*(C`(\*(Aq$self\*(Aq)\*(C'\fR for methods.
.PP
\fI\f(CI$info\fI\->positional_required\fR
.IX Subsection "$info->positional_required"
.PP
Returns a list of parameter objects for the required positional parameters (or
a count in scalar context).
.PP
\fI\f(CI$info\fI\->positional_optional\fR
.IX Subsection "$info->positional_optional"
.PP
Returns a list of parameter objects for the optional positional parameters (or
a count in scalar context).
.PP
\fI\f(CI$info\fI\->named_required\fR
.IX Subsection "$info->named_required"
.PP
Returns a list of parameter objects for the required named parameters (or a
count in scalar context).
.PP
\fI\f(CI$info\fI\->named_optional\fR
.IX Subsection "$info->named_optional"
.PP
Returns a list of parameter objects for the optional named parameters (or a
count in scalar context).
.PP
\fI\f(CI$info\fI\->slurpy\fR
.IX Subsection "$info->slurpy"
.PP
Returns a parameter object for the final array or hash that gobbles up all remaining
arguments, or \f(CW\*(C`undef\*(C'\fR if no such thing exists.
.PP
\fI\f(CI$info\fI\->args_min\fR
.IX Subsection "$info->args_min"
.PP
Returns the minimum number of arguments this function requires. This is
computed as follows: Invocants and required positional parameters count 1 each.
Optional parameters don't count. Required named parameters count 2 each (key +
value). Slurpy parameters don't count either because they accept empty lists.
.PP
\fI\f(CI$info\fI\->args_max\fR
.IX Subsection "$info->args_max"
.PP
Returns the maximum number of arguments this function accepts. This is computed
as follows: If there are any named or slurpy parameters, the result is \f(CW\*(C`Inf\*(C'\fR.
Otherwise the result is the number of all invocants and positional parameters.
.PP
\fI\f(CI$info\fI\->invocant\fR
.IX Subsection "$info->invocant"
.PP
Similar to \*(L"$info\->invocants\*(R" above: Returns \f(CW\*(C`undef\*(C'\fR if the number of
invocants is 0, a parameter object for the invocant if there is exactly 1, and
throws an exception otherwise.
.PP
\fIParameter Objects\fR
.IX Subsection "Parameter Objects"
.PP
Many of the methods described above return parameter objects.  These objects
have two methods: \f(CW\*(C`name\*(C'\fR, which returns the name of the parameter (as a plain
string), and \f(CW\*(C`type\*(C'\fR, which returns the corresponding type constraint object
(or undef if there was no type specified).
.PP
This should be invisible if you don't care about types because the objects also
overload stringification to call \f(CW\*(C`name\*(C'\fR. That is, if you treat
parameter objects like strings, they behave like strings (i.e. their names).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Function::Parameters
.SH "AUTHOR"
.IX Header "AUTHOR"
Lukas Mai, \f(CW\*(C`<l.mai at web.de>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2013, 2016 Lukas Mai.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
