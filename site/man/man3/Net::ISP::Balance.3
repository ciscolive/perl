.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::ISP::Balance 3"
.TH Net::ISP::Balance 3 "2020-08-25" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::ISP::Balance \- Support load balancing across multiple internet service providers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Net::ISP::Balance;
\&
\& # initialize the module with its configuration file
\& my $bal = Net::ISP::Balance\->new(\*(Aq/etc/network/balance.conf\*(Aq);
\&
\& $bal\->verbose(1);    # verbosely print routing and firewall 
\&                      #  commands to STDERR before running them.
\& $bal\->echo_only(1);  # echo commands to STDOUT; don\*(Aqt execute them.
\&
\& # mark the balanced services that are up
\& $bal\->up(\*(AqCABLE\*(Aq,\*(AqDSL\*(Aq,\*(AqSATELLITE\*(Aq);
\&
\& # write out routing and firewall commands
\& $bal\->set_routes_and_firewall();
\&
\& # write out a forwarding rule
\& $bal\->forward(80 => \*(Aq192.168.10.35\*(Aq);  # forward web requests to this host
\&
\& # write out an arbitrary routing rule
\& $bal\->ip_route(\*(Aqadd 192.168.100.1  dev eth0 src 198.162.1.14\*(Aq);
\&
\& # write out an arbitrary iptables rule
\& $bal\->iptables(\*(Aq\-A INCOMING \-p tcp \-\-dport 6000 \-j REJECT\*(Aq);
\&
\& # get information about all services
\& my @s = $bal\->service_names;
\& for my $s (@s) {
\&    print $bal\->dev($s);
\&    print $bal\->ip($s);
\&    print $bal\->gw($s);
\&    print $bal\->net($s);
\&    print $bal\->fwmark($s);
\&    print $bal\->table($s);
\&    print $bal\->running($s);
\&    print $bal\->weight($s);
\& }
.Ve
.SH "USAGE"
.IX Header "USAGE"
This library supports load_balance.pl, a script to load-balance a home
network across two or more Internet Service Providers (\s-1ISP\s0). The
load_balance.pl script can be found in the bin subdirectory of this
distribution. Installation and configuration instructions can be found
at http://lstein.github.io/Net\-ISP\-Balance/.
.SH "CONFIGURATION FILE"
.IX Header "CONFIGURATION FILE"
This module reads a configuration file with the following format:
.PP
.Vb 6
\& #service    device   role     ping\-ip           weight    gateway
\& CABLE        eth0     isp      173.194.43.95     1        173.193.43.1
\& DSL          ppp0     isp      173.194.43.95     1
\& LAN1         eth1     lan                        
\& LAN2         eth2     lan                        
\& LAN3         eth3     lan
.Ve
.PP
The first column is a service name that is used to bring up or down
the needed routes and firewall rules.
.PP
The second column is the name of the network interface device that
connects to that service.
.PP
The third column is either \*(L"isp\*(R" or \*(L"lan\*(R". There may be any number of
these. The script will firewall traffic passing through any of the
ISPs, and will load balance traffic among them. Traffic can flow
freely among any of the interfaces marked as belonging to a \s-1LAN.\s0
.PP
The fourth column (optional) is the \s-1IP\s0 address of a host that can be
periodically pinged to test the integrity of each \s-1ISP\s0 connection. If
too many pings failed, the service will be brought down and all
traffic routed through the remaining \s-1ISP\s0(s). The service will continue
to be monitored and will be brought up when it is once again
working. Choose a host that is not likely to go offline for reasons
unrelated to your network connectivity, such as google.com, or the
\&\s-1ISP\s0's web site. If this column is absent or marked \*(L"default\*(R", then the
host will default to www.google.ca.
.PP
The fifth column (optional) is a weight to assign to the service, and
is only valid for \s-1ISP\s0 rows. If weights are equal, traffic will be
apportioned evenly between the two routes. Increase a weight to favor
one \s-1ISP\s0 over the others. For example, if \*(L"\s-1CABLE\*(R"\s0 has a weight of 2 and
\&\*(L"\s-1DSL\*(R"\s0 has a weight of 1, then twice as much traffic will flow through
the \s-1CABLE\s0 service. If this column is omitted or marked \*(L"default\*(R", then
equal weights are assumed.
.PP
The sixth column (optional) is the gateway for this service using
dotted \s-1IP\s0 notation. If absent or named \*(L"default\*(R", the system will
attempt to determine the proper gateway automatically. Note the
algorithm relies on the fact that the gateway is almost always the
first address in the \s-1IP\s0 range for the subnetwork. If this is not the
case, then routing through the interface won't work properly. Add the
correct gateway \s-1IP\s0 address manually to correct this.
.PP
If this package is running on a single Internet-connected host, not a
router, then do not include a \*(L"lan\*(R" line.
.PP
In addition to the main table, there are several configuration options
that follow the format \*(L"configuration_name=value\*(R":
.IP "forwarding_group=<space\-delimited list of services>" 4
.IX Item "forwarding_group=<space-delimited list of services>"
The forwarding_group configuration option defines a set of services
that the router is allowed to forward packets among. Provide a
space-delimited set of service names or one or more of the
abbreviations \*(L":isp\*(R" and \*(L":lan\*(R".  \*(L":isp\*(R" is an abbreviation for all
\&\s-1ISP\s0 services, while \*(L":lan\*(R" is an abbreviation for all \s-1LAN\s0 services. So
for example, the two configuration lines below will allow forwarding
of packets between \s-1LAN1, LAN2, LAN3\s0 and both ISPs. \s-1LAN4\s0 will be
granted access to both ISPs but won't be able to exchange packets with
LANs 1 through 3:
.Sp
.Vb 2
\& forwarding_group=LAN1 LAN2 LAN3 :isp
\& forwarding_group=LAN4 :isp
.Ve
.Sp
If no forwarding_group options are defined, then the router will
forward packets among all LANs and \s-1ISP\s0 interfaces. It is equivalent to
this:
.Sp
.Vb 1
\& forwarding_group=:lan :isp
.Ve
.IP "warn_email=<email address>" 4
.IX Item "warn_email=<email address>"
Warn_email provides an email address to send notification messages to
if the status of a link changes (goes down, or comes back up). You
must have the \*(L"mail\*(R" program installed and configured for this to
work.
.IP "interval_ms=<integer>" 4
.IX Item "interval_ms=<integer>"
Indicates how often to check the ping host for each \s-1ISP.\s0
.IP "min_packet_loss=<integer>" 4
.IX Item "min_packet_loss=<integer>"
.PD 0
.IP "max_packet_loss=<integer>" 4
.IX Item "max_packet_loss=<integer>"
.PD
These define the minimum and maximum packet losses required to declare
a link up or down.
.IP "min_successive_pkts_rcvd=<integer>" 4
.IX Item "min_successive_pkts_rcvd=<integer>"
.PD 0
.IP "max_successive_pkts_recvd=<integer>" 4
.IX Item "max_successive_pkts_recvd=<integer>"
.PD
These define the minimum and maximum numbers of
successively-transmitted pings that must be returned in order to
declare a link up or down.
.IP "long_down_time=<integer>" 4
.IX Item "long_down_time=<integer>"
This is a value in seconds after a service that has gone down is
considered to have been down for a long time. You may optionally run a
series of shell scripts when this has occurred (see below).
.SH "FREQUENTLY-USED METHODS"
.IX Header "FREQUENTLY-USED METHODS"
Here are the class methods for this module that can be called on the
class name.
.ie n .SS "$bal = Net::ISP::Balance\->new('/path/to/config_file.conf');"
.el .SS "\f(CW$bal\fP = Net::ISP::Balance\->new('/path/to/config_file.conf');"
.IX Subsection "$bal = Net::ISP::Balance->new('/path/to/config_file.conf');"
Creates a new balancer object.
.PP
The first optional argument is the balancer configuration file, which
defaults to /etc/network/balance.conf on Ubuntu/Debian\-derived
systems, and /etc/sysconfig/network\-scripts/balance.conf on
RedHat/CentOS\-derived systems. From hereon, we'll refer to the base of
the various configuration files as \f(CW$ETC_NETWORK\fR.
.ie n .SS "$bal\->set_routes_and_firewall"
.el .SS "\f(CW$bal\fP\->set_routes_and_firewall"
.IX Subsection "$bal->set_routes_and_firewall"
Once the Balance objecty is created, call \fBset_routes_and_firewall()\fR to
configure the routing tables and firewall for load balancing. These
rules will either be executed on the system, or printed to standard
output as a series of shell script commands if \fBecho_only()\fR is set to
true.
.PP
The routing tables and firewall rules are based on the configuration
described in \f(CW$ETC_NETWORK\fR/balance.conf. You may add custom routes and
rules by creating files in \f(CW$ETC_NETWORK\fR/balance/routes and
\&\f(CW$ETC_NETWORK\fR/balance/firewall. The former contains a series of files
or perl scripts that define additional routing rules. The latter
contains files or perl scripts that define additional firewall rules.
.PP
Files located in \f(CW$ETC_NETWORK\fR/balance/pre\-run will be executed \s-1AFTER\s0
load_balance.pl has cleared the routing table and firewall, but before
it has emitted any any route/firewall commands. Files located in
in \f(CW$ETC_NETWORK\fR/balance/post\-run will be run after load_balance.pl is
finished.
.PP
Any files you put into these directories will be read in alphabetic
order and added to the routes and/or firewall rules emitted by the
load balancing script.Contained in this directory are subdirectories named \*(L"routes\*(R" and
\&\*(L"firewall\*(R". The former contains a series of files or perl scripts that
define additional routing rules. The latter contains files or perl
scripts that define additional firewall rules.
.PP
Note that files ending in ~ or starting with # are treated as autosave files 
and ignored.
.PP
A typical routing rules file will look like the example shown
below.
.PP
.Vb 3
\& # file: /etc/network/balance/01.my_routes
\& ip route add 192.168.100.1  dev eth0 src 198.162.1.14
\& ip route add 192.168.1.0/24 dev eth2 src 10.0.0.4
.Ve
.PP
Each line will be sent to the shell, and it is intended (but not
required) that these be calls to the \*(L"ip\*(R" command. General shell
scripting constructs are not allowed here.
.PP
A typical firewall rules file will look like the example shown here:
.PP
.Vb 1
\& # file: /etc/network/firewall/01.my_firewall_rules
\&
\& # accept incoming telnet connections to the router
\& iptable \-A INPUT \-p tcp \-\-syn \-\-dport telnet \-j ACCEPT
\&
\& # masquerade connections to the DSL modem\*(Aqs control interface
\& iptables \-t nat \-A POSTROUTING \-o eth2 \-j MASQUERADE
.Ve
.PP
You may also insert routing and firewall rules via fragments of Perl
code, which is convenient because you don't have to hard-code any
network addresses and can make use of a variety of shortcuts. To do
this, simply end the file's name with .pl and make it executable.
.PP
Here's an example that defines a series of port forwarding rules for
incoming connections:
.PP
.Vb 1
\& # file: /etc/network/firewall/02.forwardings.pl 
\&
\& $B\->forward(80 => \*(Aq192.168.10.35\*(Aq); # forward port 80 to internal web server
\& $B\->forward(443=> \*(Aq192.168.10.35\*(Aq); # forward port 443 to 
\& $B\->forward(23 => \*(Aq192.168.10.35:22\*(Aq); # forward port 23 to ssh on  web sever
.Ve
.PP
The main thing to know is that on entry to the script the global
variable \f(CW$B\fR will contain an initialized instance of a
Net::ISP::Balance object. You may then make method calls on this
object to emit firewall and routing rules.
.PP
A typical routing rules file will look like the example shown
below.
.PP
.Vb 3
\& # file: /etc/network/balance/01.my_routes
\& ip route add 192.168.100.1  dev eth0 src 198.162.1.14
\& ip route add 192.168.1.0/24 dev eth2 src 10.0.0.4
.Ve
.PP
Each line will be sent to the shell, and it is intended (but not
required) that these be calls to the \*(L"ip\*(R" command. General shell
scripting constructs are not allowed here.
.PP
A typical firewall rules file will look like the example shown here:
.PP
.Vb 1
\& # file: /etc/network/firewall/01.my_firewall_rules
\&
\& # accept incoming telnet connections to the router
\& iptable \-A INPUT \-p tcp \-\-syn \-\-dport telnet \-j ACCEPT
\&
\& # masquerade connections to the DSL modem\*(Aqs control interface
\& iptables \-t nat \-A POSTROUTING \-o eth2 \-j MASQUERADE
.Ve
.PP
You may also insert routing and firewall rules via fragments of Perl
code, which is convenient because you don't have to hard-code any
network addresses and can make use of a variety of shortcuts. To do
this, simply end the file's name with .pl and make it executable.
.PP
Here's an example that defines a series of port forwarding rules for
incoming connections:
.PP
.Vb 1
\& # file: /etc/network/firewall/02.forwardings.pl 
\&
\& $B\->forward(80 => \*(Aq192.168.10.35\*(Aq); # forward port 80 to internal web server
\& $B\->forward(443=> \*(Aq192.168.10.35\*(Aq); # forward port 443 to 
\& $B\->forward(23 => \*(Aq192.168.10.35:22\*(Aq); # forward port 23 to ssh on  web sever
.Ve
.PP
The main thing to know is that on entry to the script the global
variable \f(CW$B\fR will contain an initialized instance of a
Net::ISP::Balance object. You may then make method calls on this
object to emit firewall and routing rules.
.ie n .SS "$verbose = $bal\->verbose([boolean]);"
.el .SS "\f(CW$verbose\fP = \f(CW$bal\fP\->verbose([boolean]);"
.IX Subsection "$verbose = $bal->verbose([boolean]);"
sub bal_conf_file { my \f(CW$self\fR = shift; my \f(CW$d\fR = \f(CW$self\fR\->{bal_conf_file};
\&\f(CW$self\fR\->{bal_conf_file} = shift if \f(CW@_\fR; \f(CW$d\fR; } Get/set verbosity of
the module. If verbose is true, then firewall and routing rules
will be echoed to \s-1STDERR\s0 before being executed on the system.
.ie n .SS "$echo = $bal\->echo_only([boolean]);"
.el .SS "\f(CW$echo\fP = \f(CW$bal\fP\->echo_only([boolean]);"
.IX Subsection "$echo = $bal->echo_only([boolean]);"
Get/set the echo_only flag. If this is true (default false), then
routing and firewall rules will be printed to \s-1STDOUT\s0 rathar than being
executed.
.ie n .SS "$mode = $bal\->operating_mode([$mode])"
.el .SS "\f(CW$mode\fP = \f(CW$bal\fP\->operating_mode([$mode])"
.IX Subsection "$mode = $bal->operating_mode([$mode])"
Set or interrogate the operating mode. Will return one of \*(L"balanced\*(R"
(currently the default) or \*(L"failover\*(R". This corresponds to the \*(L"mode\*(R"
option in the configuration file. If the option is neither \*(L"balanced\*(R"
nor \*(L"failover\*(R", then \*(L"balanced\*(R" is chosen (be warned!)
.ie n .SS "$retries = $bal\->dev_lookup_retries([$retries])"
.el .SS "\f(CW$retries\fP = \f(CW$bal\fP\->dev_lookup_retries([$retries])"
.IX Subsection "$retries = $bal->dev_lookup_retries([$retries])"
Get/set the number of times the library will try to look up an interface
that is not up or does not have an \s-1IP\s0 address. Default is 10
.ie n .SS "$seconds = $bal\->dev_lookup_retry_delay([$seconds])"
.el .SS "\f(CW$seconds\fP = \f(CW$bal\fP\->dev_lookup_retry_delay([$seconds])"
.IX Subsection "$seconds = $bal->dev_lookup_retry_delay([$seconds])"
Get/set the number of seconds between retries when an interface is not up
or is missing an \s-1IP\s0 address. Default is 1.
.ie n .SS "$boolean = $bal\->keep_custom_chains([boolean]);"
.el .SS "\f(CW$boolean\fP = \f(CW$bal\fP\->keep_custom_chains([boolean]);"
.IX Subsection "$boolean = $bal->keep_custom_chains([boolean]);"
Get/set the keep_custom_chains flag. If this is true (default), then
any custom iptables chains, such as those created by miniunpnpd or
fail2ban, will be restored after execution of the firewall rules. If
false, then these rules were be flushed.
.ie n .SS "$result_code = $bal\->sh(@args)"
.el .SS "\f(CW$result_code\fP = \f(CW$bal\fP\->sh(@args)"
.IX Subsection "$result_code = $bal->sh(@args)"
Pass \f(CW@args\fR to the shell for execution. If \fBecho_only()\fR is set to true,
the command will not be executed, but instead be printed to standard
output.
.PP
Example:
.PP
.Vb 1
\& $bal\->sh(\*(Aqip rule flush\*(Aq);
.Ve
.PP
The result code is the same as \fBCORE::system()\fR.
.ie n .SS "$bal\->iptables(@args)"
.el .SS "\f(CW$bal\fP\->iptables(@args)"
.IX Subsection "$bal->iptables(@args)"
Invoke \fBsh()\fR to call \*(L"iptables \f(CW@args\fR\*(R".
.PP
Example:
.PP
.Vb 1
\& $bal\->iptables(\*(Aq\-A OUTPUT \-o eth0 \-j DROP\*(Aq);
.Ve
.PP
You may pass an array reference to \fBiptables()\fR, in which case iptables
is called on each member of the array in turn.
.PP
Example:
.PP
.Vb 3
\& $bal\->iptables([\*(Aq\-P OUTPUT  DROP\*(Aq,
\&                 \*(Aq\-P INPUT   DROP\*(Aq,
\&                 \*(Aq\-P FORWARD DROP\*(Aq]);
.Ve
.PP
Note that the method keeps track of rules; if you try to enter the
same iptables rule more than once the redundant ones will be ignored.
.ie n .SS "$bal\->firewall_rule($chain,$table,@args)"
.el .SS "\f(CW$bal\fP\->firewall_rule($chain,$table,@args)"
.IX Subsection "$bal->firewall_rule($chain,$table,@args)"
Issue an iptables firewall rule.
.PP
.Vb 1
\& $chain \-\- The chain to apply the rule to, e.g. "INPUT". 
\& 
\& $table \-\- The table to apply the rule to, e.g. "nat". Undef defaults to
\&           the standard "filter" table.
\&
\& @args  \-\- The other arguments to pass to iptables.
.Ve
.PP
Here is a typical example of blocking incoming connections to port 25:
.PP
.Vb 1
\& $bal\->firewall_rule(INPUT=>undef,\-p=>\*(Aqtcp\*(Aq,\-dport=>25,\-j=>\*(AqREJECT\*(Aq);
.Ve
.PP
This will issue the following command:
.PP
.Vb 1
\& iptables \-A INPUT \-p tcp \-\-dport 25 \-j REJECT
.Ve
.PP
The default operation is to append the rule to the chain using
\&\-A. This can be changed by passing \f(CW$bal\fR\->\fBfirewall_op()\fR any of the
strings \*(L"append\*(R", \*(L"delete\*(R", \*(L"insert\*(R" or \*(L"check\*(R". Subsequent calls to
\&\fBfirewall_rule()\fR will return commands for the indicated function:
.PP
.Vb 3
\& $bal\->firewall_op(\*(Aqdelete\*(Aq);
\& $bal\->firewall_rule(INPUT=>undef,\-p=>\*(Aqtcp\*(Aq,\-dport=>25,\-j=>\*(AqREJECT\*(Aq);
\& # gives  iptables \-A INPUT \-p tcp \-\-dport 25 \-j REJECT
.Ve
.PP
If you want to apply a series of deletes and then revert to the
original append behavior, then it is easiest to localize the hash key
\&\*(L"firewall_op\*(R":
.PP
.Vb 5
\& {
\&   local $bal\->{firewall_op} = \*(Aqdelete\*(Aq;
\&   $bal\->firewall_rule(INPUT=>undef,\-dport=>25,\-j=>\*(AqACCEPT\*(Aq);
\&   $bal\->firewall_rule(INPUT\->undef,\-dport=>80,\-j=>\*(AqACCEPT\*(Aq);
\& }
\& 
\&   $bal\->firewall_rule(INPUT=>undef,\-dport=>25,\-j=>\*(AqDROP\*(Aq);
\&   $bal\->firewall_rule(INPUT=>undef,\-dport=>80,\-j=>\*(AqDROP\*(Aq);
.Ve
.ie n .SS "$bal\->force_route($service_or_device,@selectors)"
.el .SS "\f(CW$bal\fP\->force_route($service_or_device,@selectors)"
.IX Subsection "$bal->force_route($service_or_device,@selectors)"
The \fBforce_route()\fR method issues iptables commands that will force
certain traffic to travel over a particular \s-1ISP\s0 service or network
device. This is useful, for example, when one of your ISPs acts as
your e\-mail relay and only accepts connections from the \s-1IP\s0 address
it assigns.
.PP
\&\f(CW$service_or_device\fR is the symbolic name of an \s-1ISP\s0 service
(e.g. \*(L"\s-1CABLE\*(R"\s0) or a network device that a service is attached to
(e.g. \*(L"eth0\*(R").
.PP
\&\f(CW@selectors\fR are a series of options that will be passed to
iptables to select the routing of packets. For example, to forward all
outgoing mail (destined to port 25) to the \*(L"\s-1CABLE\*(R" ISP,\s0 you would
write:
.PP
.Vb 1
\&    $bal\->force_route(\*(AqCABLE\*(Aq,\*(Aq\-p\*(Aq=>\*(Aqtcp\*(Aq,\*(Aq\-\-syn\*(Aq,\*(Aq\-\-dport\*(Aq=>25);
.Ve
.PP
\&\f(CW@selectors\fR is a series of optional arguments that will be passed to
iptables on the command line. They will simply be space-separated, and
so the following is equivalent to the previous example:
.PP
.Vb 1
\&    $bal\->force_route(\*(AqCABLE\*(Aq,\*(Aq\-p tcp \-\-syn \-\-dport 25\*(Aq);
.Ve
.PP
Bare arguments that begin with a leading hyphen and are followed by
two or more alphanumeric characters are automatically converted into
double-hyphen arguments. This allows you to simplify commands
slightly. The following is equivalent to the previous examples:
.PP
.Vb 1
\&    $bal\->force_route(\*(AqCABLE\*(Aq,\-p=>\*(Aqtcp\*(Aq,\-syn,\-dport=>25);
.Ve
.PP
You can delete force_route rules by setting \fBfirewall_op()\fR to 'delete':
.PP
.Vb 2
\&    $bal\->firewall_op(\*(Aqdelete\*(Aq);
\&    $bal\->force_route(\*(AqCABLE\*(Aq,\-p=>\*(Aqtcp\*(Aq,\-syn,\-dport=>25);
.Ve
.ie n .SS "$bal\->add_route($address => $device, [$masquerade])"
.el .SS "\f(CW$bal\fP\->add_route($address => \f(CW$device\fP, [$masquerade])"
.IX Subsection "$bal->add_route($address => $device, [$masquerade])"
This method is used to create routing and firewall rules for a network
that isn't mentioned in balance.conf. This may be necessary to route
to VPNs and/or to the control interfaces of attached modems.
.PP
The first argument is the network address in \s-1CIDR\s0 format,
e.g. '192.168.2.0/24'. The second is the network interface that the
network can be accessed via. The third, optional, argument is a
boolean. If true, then firewall rules will be set up to masquerade
from the \s-1LAN\s0 into the attached network.
.PP
Note that this is pretty limited. If you want to do anything more
sophisticated you're better off setting the routes and firewall rules
manually.
.ie n .SS "$table_name = $bal\->mark_table($service)"
.el .SS "\f(CW$table_name\fP = \f(CW$bal\fP\->mark_table($service)"
.IX Subsection "$table_name = $bal->mark_table($service)"
This returns the iptables table name for connections marked for output
on a particular \s-1ISP\s0 service. The name is simply the word \*(L"\s-1MARK\-\*(R"\s0
appended to the service name. For example, for a service named \*(L"\s-1DSL\*(R",\s0
the corresponding firewall table will be named \*(L"MARK-DSL\*(R".
.ie n .SS "$bal\->forward($incoming_port,$destination_host,@protocols)"
.el .SS "\f(CW$bal\fP\->forward($incoming_port,$destination_host,@protocols)"
.IX Subsection "$bal->forward($incoming_port,$destination_host,@protocols)"
This method emits appropriate port/host forwarding rules using \s-1DNAT\s0
address translation. The destination host can be specified using
either of these forms:
.PP
.Vb 2
\&  192.168.100.1       # forward to same port as incoming
\&  192.168.100.1:8080  # forward to a different port on host
.Ve
.PP
Protocols are one or more of 'tcp','udp'. If omitted  defaults to tcp.
.PP
Examples:
.PP
.Vb 2
\&    $bal\->forward(80 => \*(Aq192.168.100.1\*(Aq);
\&    $bal\->forward(80 => \*(Aq192.168.100.1:8080\*(Aq,\*(Aqtcp\*(Aq);
.Ve
.ie n .SS "$bal\->forward_with_snat($incoming_port,$destination_host,@protocols)"
.el .SS "\f(CW$bal\fP\->forward_with_snat($incoming_port,$destination_host,@protocols)"
.IX Subsection "$bal->forward_with_snat($incoming_port,$destination_host,@protocols)"
This method is the same as \fBforward()\fR, except that it also does source
NATing from LAN-based requests to make the request appear to have come
from the router. This is used when you expose a server, such as a web
server, to the internet, but you also need to access the server from
machines on the \s-1LAN.\s0 Use this if you find that the service is visible
from outside the \s-1LAN\s0 but not inside the \s-1LAN.\s0
.PP
Examples:
.PP
.Vb 2
\&    $bal\->forward_with_snat(80 => \*(Aq192.168.100.1\*(Aq);
\&    $bal\->forward_with_snat(80 => \*(Aq192.168.100.1:8080\*(Aq,\*(Aqtcp\*(Aq);
.Ve
.ie n .SS "$bal\->ip_route(@args)"
.el .SS "\f(CW$bal\fP\->ip_route(@args)"
.IX Subsection "$bal->ip_route(@args)"
Shortcut for \f(CW$bal\fR\->sh('ip route',@args);
.ie n .SS "$bal\->ip_rule(@args)"
.el .SS "\f(CW$bal\fP\->ip_rule(@args)"
.IX Subsection "$bal->ip_rule(@args)"
Shortcut for \f(CW$bal\fR\->sh('ip rule',@args);
.ie n .SS "$verbose = $bal\->iptables_verbose([boolean])"
.el .SS "\f(CW$verbose\fP = \f(CW$bal\fP\->iptables_verbose([boolean])"
.IX Subsection "$verbose = $bal->iptables_verbose([boolean])"
Makes iptables send an incredible amount of debugging information to
syslog.
.SH "QUERYING THE CONFIGURATION"
.IX Header "QUERYING THE CONFIGURATION"
These methods allow you to get information about the Net::ISP::Balance
object's configuration, including settings and other characteristics
of the various network interfaces.
.ie n .SS "@names = $bal\->service_names"
.el .SS "\f(CW@names\fP = \f(CW$bal\fP\->service_names"
.IX Subsection "@names = $bal->service_names"
Return the list of service names defined in balance.conf.
.ie n .SS "@names = $bal\->isp_services"
.el .SS "\f(CW@names\fP = \f(CW$bal\fP\->isp_services"
.IX Subsection "@names = $bal->isp_services"
Return list of service names that correspond to load-balanced ISPs.
.ie n .SS "@names = $bal\->lan_services"
.el .SS "\f(CW@names\fP = \f(CW$bal\fP\->lan_services"
.IX Subsection "@names = $bal->lan_services"
Return list of service names that correspond to lans.
.ie n .SS "$state = $bal\->event($service => $new_state)"
.el .SS "\f(CW$state\fP = \f(CW$bal\fP\->event($service => \f(CW$new_state\fP)"
.IX Subsection "$state = $bal->event($service => $new_state)"
Record a transition between \*(L"up\*(R" and \*(L"down\*(R" for a named service. The
first argument is the name of the \s-1ISP\s0 service that has changed,
e.g. \*(L"\s-1CABLE\*(R".\s0 The second argument is either \*(L"up\*(R" or \*(L"down\*(R".
.PP
The method returns a hashref in which the keys are the \s-1ISP\s0 service names
and the values are one of 'up' or 'down'.
.PP
The persistent state information is stored in /var/lib/lsm/ under a
series of files named <\s-1SERVICE_NAME\s0>.state.
.ie n .SS "$bal\->run_eventd(@args)"
.el .SS "\f(CW$bal\fP\->run_eventd(@args)"
.IX Subsection "$bal->run_eventd(@args)"
Runs scripts in response to lsm events. The scripts are stored in
directories named after the events, e.g.:
.PP
.Vb 3
\& /etc/network/lsm/up.d/*
\& /etc/network/lsm/down.d/*
\& /etc/network/lsm/long_down.d/*
.Ve
.PP
Scripts are called with the following arguments:
.PP
.Vb 10
\&  0. STATE
\&  1. SERVICE NAME
\&  2. CHECKIP
\&  3. DEVICE
\&  4. WARN_EMAIL
\&  5. REPLIED
\&  6. WAITING
\&  7. TIMEOUT
\&  8. REPLY_LATE
\&  9. CONS_RCVD
\& 10. CONS_WAIT
\& 11. CONS_MISS
\& 12. AVG_RTT
\& 13. SRCIP
\& 14. PREVSTATE
\& 15. TIMESTAMP
.Ve
.ie n .SS "@up = $bal\->up(@up_services)"
.el .SS "\f(CW@up\fP = \f(CW$bal\fP\->up(@up_services)"
.IX Subsection "@up = $bal->up(@up_services)"
Get or set the list of \s-1ISP\s0 interfaces that are currently active and
should be used for balancing.
.ie n .SS "$services = $bal\->services"
.el .SS "\f(CW$services\fP = \f(CW$bal\fP\->services"
.IX Subsection "$services = $bal->services"
Return a hash containing the configuration information for  each
service. The keys are the service names. Here's an example:
.PP
.Vb 10
\& {
\& 0  HASH(0x91201e8)
\&   \*(AqCABLE\*(Aq => HASH(0x9170500)
\&      \*(Aqdev\*(Aq => \*(Aqeth0\*(Aq
\&      \*(Aqfwmark\*(Aq => 2
\&      \*(Aqgw\*(Aq => \*(Aq191.3.88.1\*(Aq
\&      \*(Aqip\*(Aq => \*(Aq191.3.88.152\*(Aq
\&      \*(Aqnet\*(Aq => \*(Aq191.3.88.128/27\*(Aq
\&      \*(Aqping\*(Aq => \*(Aqwww.google.ca\*(Aq
\&      \*(Aqrole\*(Aq => \*(Aqisp\*(Aq
\&      \*(Aqrunning\*(Aq => 1
\&      \*(Aqtable\*(Aq => 2
\&   \*(AqDSL\*(Aq => HASH(0x9113e00)
\&      \*(Aqdev\*(Aq => \*(Aqppp0\*(Aq
\&      \*(Aqfwmark\*(Aq => 1
\&      \*(Aqgw\*(Aq => \*(Aq112.211.154.198\*(Aq
\&      \*(Aqip\*(Aq => \*(Aq11.120.199.108\*(Aq
\&      \*(Aqnet\*(Aq => \*(Aq112.211.154.198/32\*(Aq
\&      \*(Aqping\*(Aq => \*(Aqwww.google.ca\*(Aq
\&      \*(Aqrole\*(Aq => \*(Aqisp\*(Aq
\&      \*(Aqrunning\*(Aq => 1
\&      \*(Aqtable\*(Aq => 1
\&   \*(AqLAN\*(Aq => HASH(0x913ce58)
\&      \*(Aqdev\*(Aq => \*(Aqeth1\*(Aq
\&      \*(Aqfwmark\*(Aq => undef
\&      \*(Aqgw\*(Aq => \*(Aq192.168.10.1\*(Aq
\&      \*(Aqip\*(Aq => \*(Aq192.168.10.1\*(Aq
\&      \*(Aqnet\*(Aq => \*(Aq192.168.10.0/24\*(Aq
\&      \*(Aqping\*(Aq => \*(Aq\*(Aq
\&      \*(Aqrole\*(Aq => \*(Aqlan\*(Aq
\&      \*(Aqrunning\*(Aq => 1
\& }
.Ve
.ie n .SS "$service = $bal\->service('\s-1CABLE\s0')"
.el .SS "\f(CW$service\fP = \f(CW$bal\fP\->service('\s-1CABLE\s0')"
.IX Subsection "$service = $bal->service('CABLE')"
Return the subhash describing the single named service (see \fBservices()\fR
above).
.ie n .SS "$dev = $bal\->dev('\s-1CABLE\s0')"
.el .SS "\f(CW$dev\fP = \f(CW$bal\fP\->dev('\s-1CABLE\s0')"
.IX Subsection "$dev = $bal->dev('CABLE')"
.ie n .SS "$ip = $bal\->ip('\s-1CABLE\s0')"
.el .SS "\f(CW$ip\fP = \f(CW$bal\fP\->ip('\s-1CABLE\s0')"
.IX Subsection "$ip = $bal->ip('CABLE')"
.ie n .SS "$gateway = $bal\->gw('\s-1CABLE\s0')"
.el .SS "\f(CW$gateway\fP = \f(CW$bal\fP\->gw('\s-1CABLE\s0')"
.IX Subsection "$gateway = $bal->gw('CABLE')"
.ie n .SS "$network = $bal\->net('\s-1CABLE\s0')"
.el .SS "\f(CW$network\fP = \f(CW$bal\fP\->net('\s-1CABLE\s0')"
.IX Subsection "$network = $bal->net('CABLE')"
.ie n .SS "$role = $bal\->role('\s-1CABLE\s0')"
.el .SS "\f(CW$role\fP = \f(CW$bal\fP\->role('\s-1CABLE\s0')"
.IX Subsection "$role = $bal->role('CABLE')"
.ie n .SS "$running = $bal\->running('\s-1CABLE\s0')"
.el .SS "\f(CW$running\fP = \f(CW$bal\fP\->running('\s-1CABLE\s0')"
.IX Subsection "$running = $bal->running('CABLE')"
.ie n .SS "$mark_number = $bal\->fwmark('\s-1CABLE\s0')"
.el .SS "\f(CW$mark_number\fP = \f(CW$bal\fP\->fwmark('\s-1CABLE\s0')"
.IX Subsection "$mark_number = $bal->fwmark('CABLE')"
.ie n .SS "$routing_table_number = $bal\->table('\s-1CABLE\s0')"
.el .SS "\f(CW$routing_table_number\fP = \f(CW$bal\fP\->table('\s-1CABLE\s0')"
.IX Subsection "$routing_table_number = $bal->table('CABLE')"
.ie n .SS "$ping_dest   = $bal\->ping('\s-1CABLE\s0')"
.el .SS "\f(CW$ping_dest\fP   = \f(CW$bal\fP\->ping('\s-1CABLE\s0')"
.IX Subsection "$ping_dest = $bal->ping('CABLE')"
These methods pull out the named information from the configuration
data. \fBfwmark()\fR returns a small integer that will be used for marking
connections for routing through one of the \s-1ISP\s0 connections when an
outgoing connection originates on the \s-1LAN\s0 and is routed through the
router. \fBtable()\fR returns a small integer corresponding to a routing
table used to route connections originating on the router itself.
.SH "FILES AND PATHS"
.IX Header "FILES AND PATHS"
These are methods that determine where Net::ISP::Balance finds its
configuration files.
.ie n .SS "$path = Net::ISP::Balance\->install_etc"
.el .SS "\f(CW$path\fP = Net::ISP::Balance\->install_etc"
.IX Subsection "$path = Net::ISP::Balance->install_etc"
Returns the path to where the network configuration files reside on
this system, e.g. /etc/network. Note that this only knows about
Ubuntu/Debian\-style network configuration files in /etc/network, and
RedHat/CentOS network configuration files in
/etc/sysconfig/network\-scripts.
.ie n .SS "$file = Net::ISP::Balance\->default_conf_file"
.el .SS "\f(CW$file\fP = Net::ISP::Balance\->default_conf_file"
.IX Subsection "$file = Net::ISP::Balance->default_conf_file"
Returns the path to the default configuration file,
\&\f(CW$ETC_NETWORK\fR/balance.conf.
.ie n .SS "$dir = Net::ISP::Balance\->default_rules_directory"
.el .SS "\f(CW$dir\fP = Net::ISP::Balance\->default_rules_directory"
.IX Subsection "$dir = Net::ISP::Balance->default_rules_directory"
Returns the path to the directory where the additional router and
firewall rules are stored. On Ubuntu-Debian-derived systems, this is
/etc/network/balance/. On RedHat/CentOS systems, this is
/etc/sysconfig/network\-scripts/balance/.
.ie n .SS "$file = Net::ISP::Balance\->default_lsm_conf_file"
.el .SS "\f(CW$file\fP = Net::ISP::Balance\->default_lsm_conf_file"
.IX Subsection "$file = Net::ISP::Balance->default_lsm_conf_file"
Returns the path to the place where we should store lsm.conf, the file
used to configure the lsm (link status monitor) application.
.PP
On Ubuntu/Debian\-derived systems, this will be the file
/etc/network/lsm.conf. On RedHad/CentOS\-derived systems, this will be
/etc/sysconfig/network\-scripts/lsm.conf.
.ie n .SS "$dir = Net::ISP::Balance\->default_lsm_scripts_dir"
.el .SS "\f(CW$dir\fP = Net::ISP::Balance\->default_lsm_scripts_dir"
.IX Subsection "$dir = Net::ISP::Balance->default_lsm_scripts_dir"
Returns the path to the place where lsm stores its helper scripts.  On
Ubuntu/Debian\-derived systems, this will be the directory
/etc/network/lsm/. On RedHad/CentOS\-derived systems, this will be
/etc/sysconfig/network\-scripts/lsm/.
.ie n .SS "$file = $bal\->bal_conf_file([$new_file])"
.el .SS "\f(CW$file\fP = \f(CW$bal\fP\->bal_conf_file([$new_file])"
.IX Subsection "$file = $bal->bal_conf_file([$new_file])"
Get/set the main configuration file path, balance.conf.
.ie n .SS "$dir = $bal\->rules_directory([$new_rules_directory])"
.el .SS "\f(CW$dir\fP = \f(CW$bal\fP\->rules_directory([$new_rules_directory])"
.IX Subsection "$dir = $bal->rules_directory([$new_rules_directory])"
Get/set the route and firewall rules directory.
.ie n .SS "$file = $bal\->lsm_conf_file([$new_conffile])"
.el .SS "\f(CW$file\fP = \f(CW$bal\fP\->lsm_conf_file([$new_conffile])"
.IX Subsection "$file = $bal->lsm_conf_file([$new_conffile])"
Get/set the path to the lsm configuration file.
.ie n .SS "$dir = $bal\->lsm_scripts_dir([$new_dir])"
.el .SS "\f(CW$dir\fP = \f(CW$bal\fP\->lsm_scripts_dir([$new_dir])"
.IX Subsection "$dir = $bal->lsm_scripts_dir([$new_dir])"
Get/set the path to the lsm scripts directory.
.SH "INFREQUENTLY-USED METHODS"
.IX Header "INFREQUENTLY-USED METHODS"
These are methods that are used internally, but may be useful to
applications developers.
.ie n .SS "$lsm_config_text = $bal\->lsm_config_file(\-warn_email=>'root@localhost')"
.el .SS "\f(CW$lsm_config_text\fP = \f(CW$bal\fP\->lsm_config_file(\-warn_email=>'root@localhost')"
.IX Subsection "$lsm_config_text = $bal->lsm_config_file(-warn_email=>'root@localhost')"
This method creates the text used to create the lsm.conf configuration
file. Pass it a series of \-name=>value pairs to incorporate into the
file.
.PP
Possible switches and their defaults are:
.PP
.Vb 10
\&    \-checkip                    127.0.0.1
\&    \-eventscript                /etc/network/load_balance.pl
\&    \-long_down_eventscript      /etc/network/load_balance.pl
\&    \-notifyscript               /etc/network/balance/lsm/default_script
\&    \-max_packet_loss            15
\&    \-max_successive_pkts_lost    7
\&    \-min_packet_loss             5
\&    \-min_successive_pkts_rcvd   10
\&    \-interval_ms              1000
\&    \-timeout_ms               1000
\&    \-warn_email               root
\&    \-check_arp                   0
\&    \-sourceip                 <autodiscovered>
\&    \-device                   <autodiscovered>                      \-eventscript          => $balance_script,
\&    \-ttl                      0 <use system value>
\&    \-status                   2 <no assumptions>
\&    \-debug                    8 <moderate verbosity from scale of 0 to 100>
.Ve
.ie n .SS "$if_hash = $bal\->interface_info"
.el .SS "\f(CW$if_hash\fP = \f(CW$bal\fP\->interface_info"
.IX Subsection "$if_hash = $bal->interface_info"
.ie n .SS "$if_hash = Net::ISP::Balance\->interface_info"
.el .SS "\f(CW$if_hash\fP = Net::ISP::Balance\->interface_info"
.IX Subsection "$if_hash = Net::ISP::Balance->interface_info"
This method returns a hashref containing information about each of the
network interfaces found on the system (independent of those mentioned
in the configuration file). It may be called as a class method or an
instance method.
.PP
Each key in the hash is the name of a (virtual) interface device. The
values are hashrefs with the following keys:
.PP
.Vb 6
\&  key       value
\&  \-\-\-       \-\-\-\-\-
\&  dev       name of the underlying physical device (usually same as vdev)
\&  running   boolean, true if interface is running
\&  gw        gateway, if present
\&  net       subnet in xxx.xxx.xxx.xxx/xx
.Ve
.ie n .SS "$bal\->\fBset_routes()\fP"
.el .SS "\f(CW$bal\fP\->\fBset_routes()\fP"
.IX Subsection "$bal->set_routes()"
This method is called by \fBset_routes_and_firewall()\fR to emit the rules
needed to create the load balancing routing tables.
.ie n .SS "$bal\->set_firewall"
.el .SS "\f(CW$bal\fP\->set_firewall"
.IX Subsection "$bal->set_firewall"
This method is called by \fBset_routes_and_firewall()\fR to emit the rules
needed to create the balancing firewall.
.ie n .SS "$bal\->enable_forwarding($boolean)"
.el .SS "\f(CW$bal\fP\->enable_forwarding($boolean)"
.IX Subsection "$bal->enable_forwarding($boolean)"
.ie n .SS "$bal\->\fBrouting_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBrouting_rules()\fP"
.IX Subsection "$bal->routing_rules()"
This method is called by \fBset_routes()\fR to emit the rules needed to
create the routing rules.
.ie n .SS "$service = $bal\->preferred_service"
.el .SS "\f(CW$service\fP = \f(CW$bal\fP\->preferred_service"
.IX Subsection "$service = $bal->preferred_service"
Returns the preferred service, which is the currently running service with the highest weight. Used for
failover mode.
.ie n .SS "$bal\->\fBlocal_routing_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBlocal_routing_rules()\fP"
.IX Subsection "$bal->local_routing_rules()"
This method is called by \fBset_routes()\fR to process the fules and emit
the commands contained in the customized route files located in
\&\f(CW$ETC_DIR\fR/balance/routes.
.ie n .SS "$bal\->\fBlocal_fw_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBlocal_fw_rules()\fP"
.IX Subsection "$bal->local_fw_rules()"
This method is called by \fBset_firewall()\fR to process the fules and emit
the commands contained in the customized route files located in
\&\f(CW$ETC_DIR\fR/balance/firewall.
.ie n .SS "$bal\->\fBpre_run_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBpre_run_rules()\fP"
.IX Subsection "$bal->pre_run_rules()"
This method is called by \fBset_routes_and_firewall()\fR to process the fules and emit
the commands contained in the customized route files located in
\&\f(CW$ETC_DIR\fR/balance/pre\-run.
.ie n .SS "$bal\->\fBpost_run_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBpost_run_rules()\fP"
.IX Subsection "$bal->post_run_rules()"
This method is called by set_\|\fB_routes_andfirewall()\fR to process the
fules and emit the commands contained in the customized route files
located in \f(CW$ETC_DIR\fR/balance/post\-run.
.ie n .SS "$bal\->\fBbase_fw_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBbase_fw_rules()\fP"
.IX Subsection "$bal->base_fw_rules()"
This method is called by \fBset_firewall()\fR to set up basic firewall
rules, including default rules and reporting.
.ie n .SS "$bal\->\fBbalancing_fw_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBbalancing_fw_rules()\fP"
.IX Subsection "$bal->balancing_fw_rules()"
This method is called by \fBset_firewall()\fR to set up the mangle/fwmark
rules for balancing outgoing connections.
.ie n .SS "$bal\->\fBsanity_fw_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBsanity_fw_rules()\fP"
.IX Subsection "$bal->sanity_fw_rules()"
This is called by \fBset_firewall()\fR to create a sensible series of
firewall rules that seeks to prevent spoofing, flooding, and other
antisocial behavior. It also enables UDP-based network time and domain
name service.
.ie n .SS "$bal\->\fBnat_fw_rules()\fP"
.el .SS "\f(CW$bal\fP\->\fBnat_fw_rules()\fP"
.IX Subsection "$bal->nat_fw_rules()"
This is called by \fBset_firewall()\fR to set up basic \s-1NAT\s0 rules for lan traffic over \s-1ISP\s0
.ie n .SS "$bal\->\fBstart_lsm()\fP"
.el .SS "\f(CW$bal\fP\->\fBstart_lsm()\fP"
.IX Subsection "$bal->start_lsm()"
Start an lsm process.
.ie n .SS "$bal\->signal_lsm($signal)"
.el .SS "\f(CW$bal\fP\->signal_lsm($signal)"
.IX Subsection "$bal->signal_lsm($signal)"
Send a signal to a running \s-1LSM\s0 and return true if successfully
signalled. The signal can be numeric (e.g. 9) or a string ('\s-1TERM\s0').
.SH "BUGS"
.IX Header "BUGS"
Please report bugs to GitHub: https://github.com/lstein/Net\-ISP\-Balance.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2014, Lincoln D. Stein (lincoln.stein@gmail.com)
.PP
Senior Principal Investigator,
Ontario Institute for Cancer Research
.SH "LICENSE"
.IX Header "LICENSE"
This package is distributed under the terms of the Perl Artistic
License 2.0. See http://www.perlfoundation.org/artistic_license_2_0.
