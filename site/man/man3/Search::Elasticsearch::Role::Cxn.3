.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Search::Elasticsearch::Role::Cxn 3"
.TH Search::Elasticsearch::Role::Cxn 3 "2020-09-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Search::Elasticsearch::Role::Cxn \- Provides common functionality to HTTP Cxn implementations
.SH "VERSION"
.IX Header "VERSION"
version 7.30
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Search::Elasticsearch::Role::Cxn provides common functionality to Cxn
implementations. Cxn instances are created by a
Search::Elasticsearch::Role::CxnPool implementation, using the
Search::Elasticsearch::Cxn::Factory class.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
The configuration options are as follows:
.ie n .SS """node"""
.el .SS "\f(CWnode\fP"
.IX Subsection "node"
A single \f(CW\*(C`node\*(C'\fR is passed to \f(CW\*(C`new()\*(C'\fR by the Search::Elasticsearch::Cxn::Factory
class.  It can either be a \s-1URI\s0 or a hash containing each part.  For instance:
.PP
.Vb 3
\&    node => \*(Aqlocalhost\*(Aq;                    # equiv of \*(Aqhttp://localhost:80\*(Aq
\&    node => \*(Aqlocalhost:9200\*(Aq;               # equiv of \*(Aqhttp://localhost:9200\*(Aq
\&    node => \*(Aqhttp://localhost:9200\*(Aq;
\&
\&    node => \*(Aqhttps://localhost\*(Aq;            # equiv of \*(Aqhttps://localhost:443\*(Aq
\&    node => \*(Aqlocalhost/path\*(Aq;               # equiv of \*(Aqhttp://localhost:80/path\*(Aq
\&
\&
\&    node => \*(Aqhttp://user:pass@localhost\*(Aq;   # equiv of \*(Aqhttp://localhost:80\*(Aq
\&                                            # with userinfo => \*(Aquser:pass\*(Aq
.Ve
.PP
Alternatively, a \f(CW\*(C`node\*(C'\fR can be specified as a hash:
.PP
.Vb 7
\&    {
\&        scheme      => \*(Aqhttp\*(Aq,
\&        host        => \*(Aqsearch.domain.com\*(Aq,
\&        port        => \*(Aq9200\*(Aq,
\&        path        => \*(Aq/path\*(Aq,
\&        userinfo    => \*(Aquser:pass\*(Aq
\&    }
.Ve
.PP
Similarly, default values can be specified with \f(CW\*(C`port\*(C'\fR, \f(CW\*(C`path_prefix\*(C'\fR,
\&\f(CW\*(C`userinfo\*(C'\fR and \f(CW\*(C`use_https\*(C'\fR:
.PP
.Vb 7
\&    $e = Search::Elasticsearch\->new(
\&        port        => 9201,
\&        path_prefix => \*(Aq/path\*(Aq,
\&        userinfo    => \*(Aquser:pass\*(Aq,
\&        use_https   => 1,
\&        nodes       => [ \*(Aqsearch1\*(Aq, \*(Aqsearch2\*(Aq ]
\&    )
.Ve
.ie n .SS """ssl_options"""
.el .SS "\f(CWssl_options\fP"
.IX Subsection "ssl_options"
By default, all backends that support \s-1HTTPS\s0 disable verification of
the host they are connecting to.  Use \f(CW\*(C`ssl_options\*(C'\fR to configure
the type of verification that you would like the client to perform,
or to configure the client to present its own certificate.
.PP
The values accepted by \f(CW\*(C`ssl_options\*(C'\fR depend on the \f(CW\*(C`Cxn\*(C'\fR class.  See the
documentation for the \f(CW\*(C`Cxn\*(C'\fR class that you are using.
.ie n .SS """max_content_length"""
.el .SS "\f(CWmax_content_length\fP"
.IX Subsection "max_content_length"
By default, Elasticsearch nodes accept a maximum post body of 100MB or
\&\f(CW\*(C`104_857_600\*(C'\fR bytes. This client enforces that limit.  The limit can
be customised with the \f(CW\*(C`max_content_length\*(C'\fR parameter (specified in bytes).
.PP
If you're using the Search::Elasticsearch::CxnPool::Sniff module, then the
\&\f(CW\*(C`max_content_length\*(C'\fR will be automatically retrieved from the live cluster,
unless you specify a custom \f(CW\*(C`max_content_length\*(C'\fR:
.PP
.Vb 4
\&    # max_content_length retrieved from cluster
\&    $e = Search::Elasticsearch\->new(
\&        cxn_pool => \*(AqSniff\*(Aq
\&    );
\&
\&    # max_content_length fixed at 10,000 bytes
\&    $e = Search::Elasticsearch\->new(
\&        cxn_pool           => \*(AqSniff\*(Aq,
\&        max_content_length => 10_000
\&    );
.Ve
.ie n .SS """gzip"""
.el .SS "\f(CWgzip\fP"
.IX Subsection "gzip"
Enable Gzip compression of requests to and responses from Elasticsearch
as follows:
.PP
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        gzip => 1
\&    );
.Ve
.ie n .SS """deflate"""
.el .SS "\f(CWdeflate\fP"
.IX Subsection "deflate"
Enable Inflate/Deflate compression of requests to and responses from Elasticsearch
as follows:
.PP
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        deflate => 1
\&    );
.Ve
.PP
\&\fB\s-1IMPORTANT:\s0\fR The \*(L"request_timeout\*(R", \*(L"ping_timeout\*(R", \*(L"sniff_timeout\*(R",
and \*(L"sniff_request_timeout\*(R" parameters default to values that allow
this module to function with low powered hardware and slow networks.
When you use Elasticsearch in production, you will probably want to reduce
these timeout parameters to values that suit your environment.
.PP
The configuration parameters are as follows:
.ie n .SS """request_timeout"""
.el .SS "\f(CWrequest_timeout\fP"
.IX Subsection "request_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        request_timeout => 30
\&    );
.Ve
.PP
How long a normal request (ie not a ping or sniff request) should wait
before throwing a \f(CW\*(C`Timeout\*(C'\fR error.  Defaults to \f(CW30\fR seconds.
.PP
\&\fBNote:\fR In production, no \s-1CRUD\s0 or search request should take 30 seconds to run,
although admin tasks like \f(CW\*(C`upgrade()\*(C'\fR, \f(CW\*(C`optimize()\*(C'\fR, or snapshot \f(CW\*(C`create()\*(C'\fR
may take much longer. A more reasonable value for production would be
\&\f(CW10\fR seconds or lower.
.ie n .SS """ping_timeout"""
.el .SS "\f(CWping_timeout\fP"
.IX Subsection "ping_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        ping_timeout => 2
\&    );
.Ve
.PP
How long a ping request should wait before throwing a \f(CW\*(C`Timeout\*(C'\fR error.
Defaults to \f(CW2\fR seconds. The Search::Elasticsearch::CxnPool::Static module
pings nodes on first use, after any failure, and periodically to ensure
that nodes are healthy. The \f(CW\*(C`ping_timeout\*(C'\fR should be long enough to allow
nodes respond in time, but not so long that sick nodes cause delays.
A reasonable value for use in production on reasonable hardware
would be \f(CW0.3\fR\-\f(CW1\fR seconds.
.ie n .SS """dead_timeout"""
.el .SS "\f(CWdead_timeout\fP"
.IX Subsection "dead_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        dead_timeout => 60
\&    );
.Ve
.PP
How long a Cxn should be considered to be \fIdead\fR (not used to serve requests),
before it is retried.  The default is \f(CW60\fR seconds.  This value is increased
by powers of 2 for each time a request fails.  In other words, the delay
after each failure is as follows:
.PP
.Vb 6
\&    Failure     Delay
\&    1           60 * 1  = 60 seconds
\&    2           60 * 2  = 120 seconds
\&    3           60 * 4  = 240 seconds
\&    4           60 * 8  = 480 seconds
\&    5           60 * 16 = 960 seconds
.Ve
.ie n .SS """max_dead_timeout"""
.el .SS "\f(CWmax_dead_timeout\fP"
.IX Subsection "max_dead_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        max_dead_timeout => 3600
\&    );
.Ve
.PP
The maximum delay that should be applied to a failed node. If the
\&\*(L"dead_timeout\*(R" calculation results in a delay greater than
\&\f(CW\*(C`max_dead_timeout\*(C'\fR (default \f(CW\*(C`3,600\*(C'\fR seconds) then the \f(CW\*(C`max_dead_timeout\*(C'\fR
is used instead.  In other words, dead nodes will be retried at least once
every hour by default.
.ie n .SS """sniff_request_timeout"""
.el .SS "\f(CWsniff_request_timeout\fP"
.IX Subsection "sniff_request_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        sniff_request_timeout => 2
\&    );
.Ve
.PP
How long a sniff request should wait before throwing a \f(CW\*(C`Timeout\*(C'\fR error.
Defaults to \f(CW2\fR seconds. A reasonable value for production would be
\&\f(CW0.5\fR\-\f(CW2\fR seconds.
.ie n .SS """sniff_timeout"""
.el .SS "\f(CWsniff_timeout\fP"
.IX Subsection "sniff_timeout"
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        sniff_timeout => 1
\&    );
.Ve
.PP
How long the node being sniffed should wait for responses from other nodes
before responding to the client.  Defaults to \f(CW1\fR second. A reasonable
value in production would be \f(CW0.3\fR\-\f(CW1\fR seconds.
.PP
\&\fBNote:\fR The \f(CW\*(C`sniff_timeout\*(C'\fR is distinct from the \*(L"sniff_request_timeout\*(R".
For example, let's say you have a cluster with 5 nodes, 2 of which are
unhealthy (taking a long time to respond):
.IP "\(bu" 4
If you sniff an unhealthy node, the request will throw a \f(CW\*(C`Timeout\*(C'\fR error
after \f(CW\*(C`sniff_request_timeout\*(C'\fR seconds.
.IP "\(bu" 4
If you sniff a healthy node, it will gather responses from the other nodes,
and give up after \f(CW\*(C`sniff_timeout\*(C'\fR seconds, returning just the information it
has managed to gather from the healthy nodes.
.PP
\&\fB\s-1NOTE:\s0\fR The \f(CW\*(C`sniff_request_timeout\*(C'\fR must be longer than the \f(CW\*(C`sniff_timeout\*(C'\fR
to ensure that you get information about healthy nodes from the cluster.
.ie n .SS """handle_args"""
.el .SS "\f(CWhandle_args\fP"
.IX Subsection "handle_args"
Any default arguments which should be passed when creating a new instance of
the class which handles the network transport, eg HTTP::Tiny.
.ie n .SS """default_qs_params"""
.el .SS "\f(CWdefault_qs_params\fP"
.IX Subsection "default_qs_params"
.Vb 5
\&    $e = Search::Elasticsearch\->new(
\&        default_qs_params => {
\&            session_key => \*(Aqmy_session_key\*(Aq
\&        }
\&    );
.Ve
.PP
Any values passed to \f(CW\*(C`default_qs_params\*(C'\fR will be added to the query string
of every request. Also see \*(L"\fBdefault_headers()\fR\*(R" in Search::Elasticsearch::Role::Cxn::HTTP.
.SH "METHODS"
.IX Header "METHODS"
None of the methods listed below are useful to the user. They are
documented for those who are writing alternative implementations only.
.ie n .SS """scheme()"""
.el .SS "\f(CWscheme()\fP"
.IX Subsection "scheme()"
.Vb 1
\&    $scheme = $cxn\->scheme;
.Ve
.PP
Returns the scheme of the connection, ie \f(CW\*(C`http\*(C'\fR or \f(CW\*(C`https\*(C'\fR.
.ie n .SS """is_https()"""
.el .SS "\f(CWis_https()\fP"
.IX Subsection "is_https()"
.Vb 1
\&    $bool = $cxn\->is_https;
.Ve
.PP
Returns \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR depending on whether the \f(CW\*(C`/scheme()\*(C'\fR is \f(CW\*(C`https\*(C'\fR
or not.
.ie n .SS """userinfo()"""
.el .SS "\f(CWuserinfo()\fP"
.IX Subsection "userinfo()"
.Vb 1
\&    $userinfo = $cxn\->userinfo
.Ve
.PP
Returns the username and password of the cxn, if any, eg \f(CW"user:pass"\fR.
If \f(CW\*(C`userinfo\*(C'\fR is provided, then a Basic Authorization header is added
to each request.
.ie n .SS """default_headers()"""
.el .SS "\f(CWdefault_headers()\fP"
.IX Subsection "default_headers()"
.Vb 1
\&    $headers = $cxn\->default_headers
.Ve
.PP
The default headers that are passed with each request.  This includes
the \f(CW\*(C`Accept\-Encoding\*(C'\fR header if \f(CW\*(C`/deflate\*(C'\fR is true, and the \f(CW\*(C`Authorization\*(C'\fR
header if \f(CW\*(C`/userinfo\*(C'\fR has a value.
Also see \*(L"default_qs_params\*(R" in Search::Elasticsearch::Role::Cxn.
.ie n .SS """max_content_length()"""
.el .SS "\f(CWmax_content_length()\fP"
.IX Subsection "max_content_length()"
.Vb 1
\&    $int = $cxn\->max_content_length;
.Ve
.PP
Returns the maximum length in bytes that the \s-1HTTP\s0 body can have.
.ie n .SS """build_uri()"""
.el .SS "\f(CWbuild_uri()\fP"
.IX Subsection "build_uri()"
.Vb 1
\&    $uri = $cxn\->build_uri({ path => \*(Aq/_search\*(Aq, qs => { size => 10 }});
.Ve
.PP
Returns the \s-1HTTP URI\s0 to use for a particular request, combining the passed
in \f(CW\*(C`path\*(C'\fR parameter with any defined \f(CW\*(C`path_prefix\*(C'\fR, and adding the
query-string parameters.
.SH "METHODS"
.IX Header "METHODS"
None of the methods listed below are useful to the user. They are
documented for those who are writing alternative implementations only.
.ie n .SS """host()"""
.el .SS "\f(CWhost()\fP"
.IX Subsection "host()"
.Vb 1
\&    $host = $cxn\->host;
.Ve
.PP
The value of the \f(CW\*(C`host\*(C'\fR parameter, eg \f(CW\*(C`search.domain.com\*(C'\fR.
.ie n .SS """port()"""
.el .SS "\f(CWport()\fP"
.IX Subsection "port()"
.Vb 1
\&    $port = $cxn\->port;
.Ve
.PP
The value of the \f(CW\*(C`port\*(C'\fR parameter, eg \f(CW9200\fR.
.ie n .SS """uri()"""
.el .SS "\f(CWuri()\fP"
.IX Subsection "uri()"
.Vb 1
\&    $uri = $cxn\->uri;
.Ve
.PP
A \s-1URI\s0 object representing the node, eg \f(CW\*(C`https://search.domain.com:9200/path\*(C'\fR.
.ie n .SS """is_dead()"""
.el .SS "\f(CWis_dead()\fP"
.IX Subsection "is_dead()"
.Vb 1
\&    $bool = $cxn\->is_dead
.Ve
.PP
Is the current node marked as \fIdead\fR.
.ie n .SS """is_live()"""
.el .SS "\f(CWis_live()\fP"
.IX Subsection "is_live()"
.Vb 1
\&    $bool = $cxn\->is_live
.Ve
.PP
Is the current node marked as \fIlive\fR.
.ie n .SS """next_ping()"""
.el .SS "\f(CWnext_ping()\fP"
.IX Subsection "next_ping()"
.Vb 1
\&    $time = $cxn\->next_ping($time)
.Ve
.PP
Get/set the time for the next scheduled ping.  If zero, no ping is scheduled
and the cxn is considered to be alive.  If \-1, a ping is scheduled before
the next use.
.ie n .SS """ping_failures()"""
.el .SS "\f(CWping_failures()\fP"
.IX Subsection "ping_failures()"
.Vb 1
\&    $num = $cxn\->ping_failures($num)
.Ve
.PP
The number of times that a cxn has been marked as dead.
.ie n .SS """mark_dead()"""
.el .SS "\f(CWmark_dead()\fP"
.IX Subsection "mark_dead()"
.Vb 1
\&    $cxn\->mark_dead
.Ve
.PP
Mark the cxn as \fIdead\fR, set \*(L"\fBnext_ping()\fR\*(R" and increment \*(L"\fBping_failures()\fR\*(R".
.ie n .SS """mark_live()"""
.el .SS "\f(CWmark_live()\fP"
.IX Subsection "mark_live()"
Mark the cxn as \fIlive\fR, set \*(L"\fBnext_ping()\fR\*(R" and \*(L"\fBping_failures()\fR\*(R" to zero.
.ie n .SS """force_ping()"""
.el .SS "\f(CWforce_ping()\fP"
.IX Subsection "force_ping()"
Set \*(L"\fBnext_ping()\fR\*(R" to \-1 (ie before next use) and \*(L"\fBping_failures()\fR\*(R" to zero.
.ie n .SS """pings_ok()"""
.el .SS "\f(CWpings_ok()\fP"
.IX Subsection "pings_ok()"
.Vb 1
\&    $bool = $cxn\->pings_ok
.Ve
.PP
Try to ping the node and call \*(L"\fBmark_live()\fR\*(R" or \*(L"\fBmark_dead()\fR\*(R" depending on
the success or failure of the ping.
.ie n .SS """sniff()"""
.el .SS "\f(CWsniff()\fP"
.IX Subsection "sniff()"
.Vb 1
\&    $response = $cxn\->sniff;
.Ve
.PP
Send a sniff request to the node and return the response.
.ie n .SS """process_response()"""
.el .SS "\f(CWprocess_response()\fP"
.IX Subsection "process_response()"
.Vb 1
\&    ($code,$result) = $cxn\->process_response($params, $code, $msg, $body );
.Ve
.PP
Processes the response received from an Elasticsearch node and either
returns the \s-1HTTP\s0 status code and the response body (deserialized from \s-1JSON\s0)
or throws an error of the appropriate type.
.PP
The \f(CW$params\fR are the original params passed to
\&\*(L"\fBperform_request()\fR\*(R" in Search::Elasticsearch::Transport, the \f(CW$code\fR is the \s-1HTTP\s0
status code, the \f(CW$msg\fR is the error message returned by the backend
library and the \f(CW$body\fR is the \s-1HTTP\s0 response body returned by
Elasticsearch.
.SH "AUTHOR"
.IX Header "AUTHOR"
Enrico Zimuel <enrico.zimuel@elastic.co>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Elasticsearch \s-1BV.\s0
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
