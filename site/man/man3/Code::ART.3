.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Code::ART 3"
.TH Code::ART 3 "2020-06-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Code::ART \- Analyze/Rename/Track Perl source code
.SH "VERSION"
.IX Header "VERSION"
This document describes Code::ART version 0.000005
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Code::ART;
\&
\&    # Convert source code fragment to sub and call...
\&    $refactored = refactor_to_sub( $source_code, \e%options );
\&
\&    # or:
\&    $refactored = hoist_to_lexical( $source_code, \e%options );
\&
\&    # Source code of sub or lexical...
\&    $sub_definition  = $refactored\->{code};
\&
\&    # Code to call sub with args, or to evaluate lexical...
\&    $sub_call_syntax = $refactored\->{call};
\&
\&    # Array of arg names (as strings, only for refactor_to_sub() )...
\&    @sub_arg_list    = @{ $refactored\->{args} };
\&
\&    # Only if refactoring failed...
\&    $failure_message = $refactored\->{failed};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a range of subroutines to help you refactor
valid Perl source into cleaner, better decomposed code.
.PP
The module also comes with a Vim plugin to plumb those
refactoring behaviours directly into that editor (see \*(L"Vim integration\*(R").
.PP
For example, the module provides a subroutine (\f(CW\*(C`refactor_to_sub()\*(C'\fR)
that takes a source code fragment as a string, analyzes it to determine
the unbound variables within it, then constructs the source code of an
equivalent subroutine (with the unbound variables converted to
parameters) plus the source code of a suitable call to that subroutine.
.PP
It is useful when hooked into an editor, allowing you to
(semi\-)automatically convert functional code like:
.PP
.Vb 11
\&    my @heatmap =
\&        map  { $config{$_} }
\&        sort {
\&               my $a_key = $a =~ /(\ed+)/ ? $1 : undef;
\&               my $b_key = $b =~ /(\ed+)/ ? $1 : undef;
\&               defined $a_key && defined $b_key
\&                  ? $a_key <=> $b_key
\&                  : $a     cmp $b;
\&             }
\&        grep { /^heatmap/ }
\&        keys %config;
.Ve
.PP
into a much cleaner:
.PP
.Vb 5
\&    my @heatmap =
\&        map  { $config{$_} }
\&        nsort
\&        grep { /^heatmap/ }
\&        keys %config;
.Ve
.PP
plus:
.PP
.Vb 9
\&    sub nsort {
\&        sort {
\&               my $a_key = $a =~ /(\ed+)/ ? $1 : undef;
\&               my $b_key = $b =~ /(\ed+)/ ? $1 : undef;
\&               defined $a_key && defined $b_key
\&                  ? $a_key <=> $b_key
\&                  : $a     cmp $b;
\&        }, @_;
\&    }
.Ve
.PP
Or to replace something long and imperative like:
.PP
.Vb 1
\&    my @heatmap_keys;
\&
\&    for my $key (keys %config) {
\&        next if $key !~ /^heatmap/;
\&        push @heatmap_keys, $key;
\&    }
\&
\&    @heatmap_keys
\&        = sort {
\&                my $a_key = $a =~ /(\ed+)/ ? $1 : undef;
\&                my $b_key = $b =~ /(\ed+)/ ? $1 : undef;
\&                defined $a_key && defined $b_key
\&                    ? $a_key <=> $b_key
\&                    : $a     cmp $b;
\&            } @heatmap_keys;
\&
\&    my @heatmap;
\&
\&    for (@heatmap_keys) {
\&        push @heatmap, $config{$_};
\&    }
.Ve
.PP
with something short and imperative:
.PP
.Vb 1
\&    my @heatmap;
\&
\&    for ( get_heatmap_keys(\e%config ) ) {
\&        push @heatmap, $config{$_};
\&    }
.Ve
.PP
plus:
.PP
.Vb 2
\&    sub get_heatmap_keys {
\&        my ($config_href) = @_;
\&
\&        my @heatmap_keys;
\&
\&        for my $key (keys %{$config_href}) {
\&            next if $key !~ /^heatmap/;
\&            push @heatmap_keys, $key;
\&        }
\&
\&        @heatmap_keys = sort {
\&                            my $a_key = $a =~ /(\ed+)/ ? $1 : undef;
\&                            my $b_key = $b =~ /(\ed+)/ ? $1 : undef;
\&                            defined $a_key && defined $b_key
\&                                ? $a_key <=> $b_key
\&                                : $a     cmp $b;
\&                        } @heatmap_keys;
\&
\&        return @heatmap_keys;
\&    }
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Refactoring a fragment of Perl code"
.IX Subsection "Refactoring a fragment of Perl code"
To refactor some Perl code, call the \f(CW\*(C`refactor_to_sub()\*(C'\fR
subroutine, which is automatically exported when the
module is loaded.
.PP
.Vb 1
\&    my $refactored = refactor_to_sub( $source_code_string, \e%options );
.Ve
.PP
Note that this subroutine does not actually rewrite the source code
with the refactoring; it merely returns the components with which you
could transform the original source yourself.
.PP
The subroutine takes a single required argument:
a string containing the complete source code within which
some element is to be refactored.
.PP
The options specify where and how to refactor that code element, as follows:
.ie n .IP """from => $starting_string_index""" 4
.el .IP "\f(CWfrom => $starting_string_index\fR" 4
.IX Item "from => $starting_string_index"
.PD 0
.ie n .IP """to => $ending_string_index""" 4
.el .IP "\f(CWto => $ending_string_index\fR" 4
.IX Item "to => $ending_string_index"
.PD
These two options are actually required. They must be non-negative integer
values that represent the indexes in the string where the fragment you 
wish to refactor begins and ends.
.ie n .IP """name => $name_of_new_sub""" 4
.el .IP "\f(CWname => $name_of_new_sub\fR" 4
.IX Item "name => $name_of_new_sub"
This option allows you to specify the name of the new subroutine.
If it is not provided, the module uses a bad generic name instead
(\f(CW\*(C`_\|_REFACTORED_SUB_\|_\*(C'\fR), which you'll have to change anyway,
so passing the option is strongly recommended.
.ie n .IP """data => $name_of_the_var_to_hold_any_trailing_data""" 4
.el .IP "\f(CWdata => $name_of_the_var_to_hold_any_trailing_data\fR" 4
.IX Item "data => $name_of_the_var_to_hold_any_trailing_data"
This option allows you to specify the name of the slurpy variable into
which any trailing arguments for the new subroutine (i.e. in addition to
those the refactorer determines are required) will be placed.
.Sp
If it is not provided, the module uses a generic name instead
(\f(CW\*(C`@_\|_EXTRA_DATA_\|_\*(C'\fR).
.ie n .IP """return => $source_of_the_expr_to_be_returned""" 4
.el .IP "\f(CWreturn => $source_of_the_expr_to_be_returned\fR" 4
.IX Item "return => $source_of_the_expr_to_be_returned"
If this option is specified, the refactorer places its value in a 
\&\f(CW\*(C`return\*(C'\fR statement at the end of the refactored subroutine.
.Sp
If it is not provided, no extra return statement is added.
.PP
The return value of \f(CW\*(C`refactor_to_sub()\*(C'\fR in all contexts and in all cases
is a hash reference containing one or more of the following keys:
.ie n .IP "\*(Aqcode\*(Aq" 4
.el .IP "\f(CW\*(Aqcode\*(Aq\fR" 4
.IX Item "code"
The value for this key will be a string representing the source code for
the new subroutine into which the original code was refactored.
.ie n .IP "\*(Aqcall\*(Aq" 4
.el .IP "\f(CW\*(Aqcall\*(Aq\fR" 4
.IX Item "call"
The value for this key will be a string representing the source code for
the specific call to the new subroutine (including it's arguments)
that can be used to replace the original code.
.ie n .IP "\*(Aqreturn\*(Aq" 4
.el .IP "\f(CW\*(Aqreturn\*(Aq\fR" 4
.IX Item "return"
The value of this key will be a reference to an hash, whose keys are
the names of the variables present inside the original code that was
refactored, and whose values are the equivalent names of those variables
in the refactored code.
.Sp
The purpose of these information is to allow your code to present the
user with a list of possible return values to select from (i.e. the keys
of the hash) and then install a suitable return statement (i.e. the
value of the selected key).
.ie n .IP "\*(Aqfailed\*(Aq" 4
.el .IP "\f(CW\*(Aqfailed\*(Aq\fR" 4
.IX Item "failed"
This key will be present only when the attempt to refactor the code failed
for some reason. The value of this key will be a string containing the
reason that the original code could not be refactored.
See \*(L"\s-1DIAGNOSTICS\*(R"\s0 for a list of these error messages.
.Sp
Note that, if the \f(CW\*(Aqfailed\*(Aq\fR key is present in the returned hash, then
the hash may not contain entries for \f(CW\*(Aqcode\*(Aq\fR, \f(CW\*(Aqcall\*(Aq\fR, or \f(CW\*(Aqreturn\*(Aq\fR.
.PP
Hence a generic usage might be:
.PP
.Vb 1
\&    my $refactoring = refactor_to_sub( $original_code );
\&
\&    if (exists $refactoring\->{failed}) {
\&        warn $refactoring\->{failed}
\&    }
\&    else {
\&        replace_original_code_with( $refactoring\->{call} );
\&        add_subroutine_definition(  $refactoring\->{code} );
\&    }
.Ve
.SS "Hoisting an expression to a variable or closure"
.IX Subsection "Hoisting an expression to a variable or closure"
To refactor a single Perl expression into a scalar variable or
a lexical closure, call the \f(CW\*(C`hoist_to_lexical()\*(C'\fR
subroutine, which is automatically exported when the
module is loaded:
.PP
.Vb 1
\&    my $refactored = hoist_to_lexical( $source_code_string, \e%options );
.Ve
.PP
Note that this subroutine does not actually rewrite the source code
with the hoisting; it merely returns the components with which you
could transform the original source yourself.
.PP
The subroutine takes a single required argument:
a string containing the complete source code within which
some expression is to be refactored.
.PP
The options specify where and how to refactor that expression, as follows:
.ie n .IP """from => $starting_string_index""" 4
.el .IP "\f(CWfrom => $starting_string_index\fR" 4
.IX Item "from => $starting_string_index"
.PD 0
.ie n .IP """to => $ending_string_index""" 4
.el .IP "\f(CWto => $ending_string_index\fR" 4
.IX Item "to => $ending_string_index"
.PD
These two options are actually required. They must be non-negative integer
values that represent the indexes in the string where the expression you 
wish to refactor begins and ends.
.ie n .IP """name => $name_of_new_lexical""" 4
.el .IP "\f(CWname => $name_of_new_lexical\fR" 4
.IX Item "name => $name_of_new_lexical"
This option allows you to specify the name of the new lexical variable or closure.
If it is not provided, the module uses a bad generic name instead
(\f(CW\*(C`_\|_REFACTORED_LEXICAL\*(C'\fR), which you'll have to change anyway,
so passing the option is strongly recommended.
.ie n .IP """all => $boolean""" 4
.el .IP "\f(CWall => $boolean\fR" 4
.IX Item "all => $boolean"
This option allows you to specify whether the refactorer should attempt to
hoist every instance of the specified expression (if the option is true)
or just the selected instance (if the option is false or omitted).
.ie n .IP """closure => $boolean""" 4
.el .IP "\f(CWclosure => $boolean\fR" 4
.IX Item "closure => $boolean"
This option allows you to specify whether the refactorer should attempt to
hoist the specified expression into a closure (if the option is true),
instead of into a lexical variable (if the option is false or omitted).
.Sp
Closures are a better choice whenever the expression has side-effects,
otherwise the behaviour of the refactored code will most likely change.
The \f(CW\*(C`hoist_to_lexical()\*(C'\fR subroutine can detect some types of side-effects
automatically, and will automatically use a closure in those cases, regardless
of the value of this option.
.PP
The return value of \f(CW\*(C`hoist_to_lexical()\*(C'\fR in all contexts and in all cases
is a hash reference containing one or more of the following keys:
.ie n .IP "\*(Aqcode\*(Aq" 4
.el .IP "\f(CW\*(Aqcode\*(Aq\fR" 4
.IX Item "code"
The value for this key will be a string representing the source code for
the new variable of closure declaration into which the original expression was
refactored.
.ie n .IP "\*(Aqcall\*(Aq" 4
.el .IP "\f(CW\*(Aqcall\*(Aq\fR" 4
.IX Item "call"
The value for this key will be a string representing the source code for
the specific call to the new closure, or use of the new variable,
that can be used to replace the original expression.
.ie n .IP "\*(Aqhoistloc\*(Aq" 4
.el .IP "\f(CW\*(Aqhoistloc\*(Aq\fR" 4
.IX Item "hoistloc"
The string index into the source string at which the \f(CW\*(Aqcode\*(Aq\fR declaration
should be installed.
.ie n .IP "\*(Aqmatches\*(Aq" 4
.el .IP "\f(CW\*(Aqmatches\*(Aq\fR" 4
.IX Item "matches"
A reference to an array of hashes. Each hash represents one location where
the specified expression was found, and the number of characters it occupies
in the string.
.Sp
For example:
.Sp
.Vb 5
\&    matches => [
\&                 { from => 140, length => 24 },
\&                 { from => 180, length => 22 },
\&                 { from => 299, length => 26 },
\&               ],
.Ve
.ie n .IP "\*(Aqmutators\*(Aq" 4
.el .IP "\f(CW\*(Aqmutators\*(Aq\fR" 4
.IX Item "mutators"
The number of mutation operators detected in the expression.
If this number is not zero, refactoring into a variable instead
of the closure will usually change the behaviour of the entire code.
\&\f(CW\*(C`hoist_to_lexical()\*(C'\fR tries its darnedest to prevent that.
.ie n .IP "\*(Aqtarget\*(Aq" 4
.el .IP "\f(CW\*(Aqtarget\*(Aq\fR" 4
.IX Item "target"
The actual selected expression that was hoisted.
.ie n .IP "\*(Aquse_version\*(Aq" 4
.el .IP "\f(CW\*(Aquse_version\*(Aq\fR" 4
.IX Item "use_version"
A \f(CW\*(C`version\*(C'\fR object representing the version that the source
code claimed to require (via an embedded \f(CW\*(C`use VERSION\*(C'\fR statement).
.ie n .IP "\*(Aqfailed\*(Aq" 4
.el .IP "\f(CW\*(Aqfailed\*(Aq\fR" 4
.IX Item "failed"
This key will be present only when the attempt to refactor the code failed
for some reason. The value of this key will be a string containing the
reason that the original code could not be refactored.
See \*(L"\s-1DIAGNOSTICS\*(R"\s0 for a list of these error messages.
.Sp
Note that, if the \f(CW\*(Aqfailed\*(Aq\fR key is present in the returned hash, then
the hash may not contain entries for \f(CW\*(Aqcode\*(Aq\fR, \f(CW\*(Aqcall\*(Aq\fR, or the other
keys listed above.
.SS "Analysing variable usage within some source code"
.IX Subsection "Analysing variable usage within some source code"
To detect and analyse the declaration and usage of variables in
a piece of source code, call the \f(CW\*(C`classify_all_vars_in()\*(C'\fR
subroutine which is exported by default when the module is used.
.PP
The subroutine takes a single argument: a string containing the
source code to be analysed.
.PP
It returns a hash containing two keys:
.ie n .IP "\*(Aquse_version\*(Aq" 4
.el .IP "\f(CW\*(Aquse_version\*(Aq\fR" 4
.IX Item "use_version"
The value of this key is a \f(CW\*(C`version\*(C'\fR object representing the
version that the source code claimed it required, via an 
embedded \f(CW\*(C`use VERSION\*(C'\fR statement.
.ie n .IP "\*(Aqvars\*(Aq" 4
.el .IP "\f(CW\*(Aqvars\*(Aq\fR" 4
.IX Item "vars"
A hash of hashes, each of which represents one distinct variable
in the source code. The key of each subhash is the string index within
the source at which the variable was declared (or a unique negative number)
if the variable wasn't declared. Each subhash has the following structure:
.Sp
.Vb 4
\&    {
\&      decl_name      => \*(Aq$name_and_sigil_with_which_the_variable_was_declared\*(Aq,
\&      sigil          => \*(Aq$|@|%\*(Aq,
\&      aliases        => \e%hash_of_any_known_aliases_for_the_variable,
\&
\&      declarator     => "my|our|state|for|sub",
\&      declared_at    => $string_index_where_declared,
\&      used_at        => \e%hash_of_indexes_within_source_string_where_variable_used,
\&
\&      desc           => "text of any comment on the same line as the declaration",
\&
\&      start_of_scope => $string_index_where_variable_came_into_scope,
\&      end_of_scope   => $string_index_where_variable_went_out_of_scope,
\&      scope_scale    => $fraction_of_the_complete_source_where_variable_is_in_scope,
\&
\&      is_builtin     => $true_if_variable_is_a_standard_Perl_built_in,
\&
\&      homograms      => \e%hash_of_names_and_keys_of_other_variables_with_the_same_name,
\&      parograms      => \e%hash_of_names_and_keys_of_other_variables_with_similar_names,
\&      is_cacogram    => $true_if_variable_name_is_pitifully_generic_and_uninformative,
\&    }
.Ve
.SS "Renaming a variable"
.IX Subsection "Renaming a variable"
To rename a variable throughout the source code, call the \f(CW\*(C`rename_variable()\*(C'\fR
subroutine, which is exported by default.
.PP
The subroutine expects three arguments:
.IP "\(bu" 4
The original source code (as a string),
.IP "\(bu" 4
A string index at which some usage of the variable is located
(i.e. a point in the source where a hypothetical cursor would be \*(L"over\*(R" the variable).
.IP "\(bu" 4
The new name of the variable.
.PP
The subroutine returns a hash with a single entry:
.PP
.Vb 1
\&    { source => $copy_of_source_string_with_the_variable_renamed }
.Ve
.PP
If the specified string index does not cover a variable, a hash is
still returned, but with the single entry:
.PP
.Vb 1
\&    { failed => "reason_for_failure" }
.Ve
.SS "Vim integration"
.IX Subsection "Vim integration"
The module distribution includes a Vim plugin: \fIvim/perlart.vim\fR
.PP
This plugin sets up a series of mappings that refactor or rename
code elements that have been visually selected or on which the
cursor is sitting.
.PP
For example, the <\s-1CTRL\-S\s0> mapping yanks the visual selection, refactors the
code into a subroutine, requests a name for the new subroutine, requests
a return value (if one seems needed), and then pastes the resulting
subroutine call over the original selected text.
.PP
The mapping also places the resulting subroutine definition code in the
unnamed register, as well as in register \f(CW\*(C`"s\*(C'\fR (for "\fBs\fRubroutine"),
so that the definition is easy to paste back into your source somewhere.
.PP
The following Normal mode mappings re also available:
.IP "<\s-1CTRL\-N\s0>" 4
.IX Item "<CTRL-N>"
Rename the variable under the cursor.
.IP "<\s-1CTRL\-S\s0>" 4
.IX Item "<CTRL-S>"
Search for all instances of the variable under the cursor.
.Sp
\&\fB\f(BI\s-1WARNING\s0\fB\fR: In some environments, \f(CW\*(C`CTRL\-S\*(C'\fR will suspend terminal
interactions. If your terminal locks up when you use this mapping,
hit \f(CW\*(C`CTRL\-Q\*(C'\fR to restart terminal interactions. In this case, 
you will need to either change the behaviour of \f(CW\*(C`CTRL\-S\*(C'\fR in
your terminal (for example:
<https://coderwall.com/p/ltiqsq/disable\-ctrl\-s\-and\-ctrl\-q\-on\-terminal>,
or <https://stackoverflow.com/questions/3446320/in\-vim\-how\-to\-map\-save\-to\-ctrl\-s>),
or else change this mapping to something else.>
.IP "gd" 4
.IX Item "gd"
Jump to the declaration of the variable under the cursor.
.IP "*" 4
Jump to the next usage of the variable under the cursor.
.PP
The following Visual mode mappings are also available:
.IP "<\s-1CTRL\-M\s0>" 4
.IX Item "<CTRL-M>"
Match all instances of the variable under the cursor.
.IP "<\s-1CTRL\-H\s0>" 4
.IX Item "<CTRL-H>"
Hoist all instances of the visually selected code into a lexical variable.
.IP "<\s-1CTRL\-C\s0>" 4
.IX Item "<CTRL-C>"
Hoist all instances of the visually selected code into a lexical closure.
.IP "<\s-1CTRL\-R\s0>" 4
.IX Item "<CTRL-R>"
Refactor all instances of the visually selected code into a parameterized subroutine.
.IP "<\s-1CTRL\-H\s0><\s-1CTRL\-H\s0>" 4
.IX Item "<CTRL-H><CTRL-H>"
.PD 0
.IP "<\s-1CTRL\-C\s0><\s-1CTRL\-C\s0>" 4
.IX Item "<CTRL-C><CTRL-C>"
.IP "<\s-1CTRL\-R\s0><\s-1CTRL\-R\s0>" 4
.IX Item "<CTRL-R><CTRL-R>"
.PD
Same as the single-control-character versions above, but these only refactor
the code actually selected, rather than every equivalent instance throughout
the buffer.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
The analysis and refactoring subroutines all return a hash, in all
cases. However, if any subroutine cannot perform its task (usually
because the code it has been given is invalid), then the returned hash
will contain the key 'failed', and the corresponding value will give a
reason for the failure (if possible).
.PP
The following failure messages may be encountered:
.ie n .IP """failed => \*(Aqinvalid source code\*(Aq""" 4
.el .IP "\f(CWfailed => \*(Aqinvalid source code\*(Aq\fR" 4
.IX Item "failed => invalid source code"
The code you passed in as the first argument could not be recognized
by \s-1PPR\s0 as a valid Perl.
.Sp
There is a small chance this was caused by a bug in \s-1PPR,\s0
but it's more likely that something was wrong with the code you passed in.
.ie n .IP """failed => \*(Aqnot a valid series of statements\*(Aq""" 4
.el .IP "\f(CWfailed => \*(Aqnot a valid series of statements\*(Aq\fR" 4
.IX Item "failed => not a valid series of statements"
The subset of the code you asked \f(CW\*(C`refactor_to_sub()\*(C'\fR to refactor
could not be recognized by \s-1PPR\s0 as a refactorable sequence of Perl statements.
.Sp
Check whether you caught an extra unmatched opening or closing brace, or
started in the middle of a string.
.ie n .IP """failed => \*(Aqthe code has an internal return statement\*(Aq""" 4
.el .IP "\f(CWfailed => \*(Aqthe code has an internal return statement\*(Aq\fR" 4
.IX Item "failed => the code has an internal return statement"
If the code you're trying to put into a subroutine contains a (conditional) return
statement anywhere but at the end of the fragment, then there's no way to refactor it
cleanly into another subroutine, because the internal return will return from the newly
refactored subroutine, \fInot\fR from the place where you'll be replacing the original 
code with a call tothe newly refactored subroutine. So \f(CW\*(C`refactor_to_sub()\*(C'\fR doesn't try.
.ie n .IP """failed => ""code has both a leading assignment and an explicit return""""" 4
.el .IP "\f(CWfailed => ``code has both a leading assignment and an explicit return''\fR" 4
.IX Item "failed => ""code has both a leading assignment and an explicit return"""
If you're attempting to refactor a fragment of code that starts with the
rvalue of an assignment, and ends in a return, there's no way to put
both into a new subroutine and still have the previous behaviour of the 
original code preserved. So \f(CW\*(C`refactor_to_sub()\*(C'\fR doesn't try.
.ie n .IP """failed => ""because the target code is not a simple expression""""" 4
.el .IP "\f(CWfailed => ``because the target code is not a simple expression''\fR" 4
.IX Item "failed => ""because the target code is not a simple expression"""
Only simple expressions (not full statements) can be hoisted into a lexical
variable or closure. You tried to hoist something \*(L"bigger\*(R" than that.
.ie n .IP """failed => ""because there is no variable at the specified location""""" 4
.el .IP "\f(CWfailed => ``because there is no variable at the specified location''\fR" 4
.IX Item "failed => ""because there is no variable at the specified location"""
You called \f(CW\*(C`classify_var_at()\*(C'\fR but gave it a position in the source code
where there was no variable. If you're doing that from within some editor,
you may have an out-by-one error if the buffer positions you're detecting
and passing back to the module start at 1 instead of zero.
.ie n .IP """failed => \*(Aqbecause the apparent variable is not actually a variable\*(Aq""" 4
.el .IP "\f(CWfailed => \*(Aqbecause the apparent variable is not actually a variable\*(Aq\fR" 4
.IX Item "failed => because the apparent variable is not actually a variable"
You called \f(CW\*(C`classify_var_at()\*(C'\fR but gave it a position in the source code
where there was no variable. It \fIlooks\fR like there is a variable there,
but there isn't. Is the apparent variable actually in an uninterpolated
string, or a comment, or some \s-1POD,\s0 or after the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR or \f(CW\*(C`_\|_END_\|_\*(C'\fR
marker?
.PP
\&\s-1API\s0 errors are signalled by throwing an exception:
.ie n .IP """%s argument of %s must be a %s""" 4
.el .IP "\f(CW``%s argument of %s must be a %s''\fR" 4
.IX Item """%s argument of %s must be a %s"""
You called the specified subroutine with the wrong kind of argument.
The error message will specify which argument and what kind of value it requires.
.ie n .IP """Unexpected extra argument passed to %s""" 4
.el .IP "\f(CW``Unexpected extra argument passed to %s''\fR" 4
.IX Item """Unexpected extra argument passed to %s"""
You called the specified subroutine with an extra unexpected argument.
Did you mean to put that argument in the subroutine's options hash instead?
.ie n .IP """Unknown option (%s) passed to %s""" 4
.el .IP "\f(CW``Unknown option (%s) passed to %s''\fR" 4
.IX Item """Unknown option (%s) passed to %s"""
You passed an unexpected named argument via the specified subroutine's
options hash. Did you misspell it, perhaps?
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Code::ART requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
The \s-1PPR\s0 module (version 0.000027 or later)
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
Because this module relies on the \s-1PPR\s0 module,
it will not run under Perl 5.20
(because regexes are broken in that version of Perl).
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
These refactoring and analysis algorithms are not intelligent or
self-aware. They do not understand the code they are processing, and
especially not the purpose or intent of that code. They are merely
applying a set of heuristics (i.e. informed guessing) to try to
determine what you actually wanted the replacement code to do. Sometimes
they will guess wrong. Treat them as handy-but-dumb tools, not as
magical A.I. superfriends. Trust...but verify.
.PP
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-code\-art@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2018, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
