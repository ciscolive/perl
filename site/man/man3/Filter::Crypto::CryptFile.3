.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Filter::Crypto::CryptFile 3"
.TH Filter::Crypto::CryptFile 3 "2018-07-31" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Filter::Crypto::CryptFile \- Encrypt (and decrypt) Perl files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Filter::Crypto::CryptFile qw(:DEFAULT $ErrStr);
\&
\&    # Encrypt one filehandle (or file name) to another.
\&    crypt_file($in_fh,   $out_fh,   $crypt_mode) or
\&        die "crypt_file() failed: $ErrStr\en";
\&    crypt_file($in_file, $out_file, $crypt_mode) or
\&        die "crypt_file() failed: $ErrStr\en";
\&
\&    # The crypt mode can be determined automatically.
\&    crypt_file($in_fh,   $out_fh)   or die "crypt_file() failed: $ErrStr\en";
\&    crypt_file($in_file, $out_file) or die "crypt_file() failed: $ErrStr\en";
\&
\&    # Encrypt one filehandle (or file name) in\-place (in memory).
\&    crypt_file($in_out_fh,   $crypt_mode) or
\&        die "crypt_file() failed: $ErrStr\en";
\&    crypt_file($in_out_file, $crypt_mode) or
\&        die "crypt_file() failed: $ErrStr\en";
\&
\&    # The crypt mode can be determined automatically.
\&    crypt_file($in_out_fh)   or die "crypt_file() failed: $ErrStr\en";
\&    crypt_file($in_out_file) or die "crypt_file() failed: $ErrStr\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a single function called \f(CW\*(C`crypt_file()\*(C'\fR for converting
files to/from an encrypted state in which they can be run via
Filter::Crypto::Decrypt.
.PP
The function takes either a pair of open filehandles (one to read from and one
to write to) or else a single open filehandle (to process \*(L"in-place\*(R").  (File
names can also be specified instead of open filehandles.)  It reads data from
the input source, either encrypts it or decrypts it according to the \*(L"crypt
mode\*(R", and then writes the result to the output source.
.PP
In each case, the \*(L"crypt mode\*(R" may either be explicitly specified using the
\&\f(CW\*(C`CRYPT_MODE_*\*(C'\fR flags, or else it can be omitted (or specified as \f(CW\*(C`undef\*(C'\fR or
the null string) in order to be determined automatically by \f(CW\*(C`crypt_file()\*(C'\fR.
.SS "Functions"
.IX Subsection "Functions"
.ie n .IP """crypt_file($in_fh, $out_fh[, $crypt_mode])""" 4
.el .IP "\f(CWcrypt_file($in_fh, $out_fh[, $crypt_mode])\fR" 4
.IX Item "crypt_file($in_fh, $out_fh[, $crypt_mode])"
.PD 0
.ie n .IP """crypt_file($in_out_fh[, $crypt_mode])""" 4
.el .IP "\f(CWcrypt_file($in_out_fh[, $crypt_mode])\fR" 4
.IX Item "crypt_file($in_out_fh[, $crypt_mode])"
.PD
If two open filehandles, \f(CW$in_fh\fR and \f(CW$out_fh\fR, are supplied then input is read
from \f(CW$in_fh\fR, encrypted or decrypted, and the output is written to \f(CW$out_fh\fR.
Clearly \f(CW$in_fh\fR must have been opened for reading and \f(CW$out_fh\fR must have been
opened for writing.  Only a small amount of data is held in memory at any time,
so this method is safe to use for \*(L"large\*(R" files without using unduly large
amounts of memory.
.Sp
If only one open filehandle, \f(CW$in_out_fh\fR, is supplied then input is read from it,
encrypted or decrypted, and the output is written back to it after truncating
the file to zero size.  In this case, \f(CW$in_out_fh\fR must have been opened for
\&\*(L"updating\*(R" (both reading and writing).  Using this method the whole file is read
into memory in one go, so it is not suitable for use on \*(L"large\*(R" files.  This is
unlikely to be a problem in practice, however, since Perl source code files are
rarely, if ever, sufficiently large to cause any trouble in this regard.
.Sp
Note that the filehandle being written to when encrypting and the filehandle
being read from when decrypting \fImust\fR be opened in \*(L"binary\*(R" mode on those
platforms where it makes a difference (notably Win32), otherwise the encrypted
\&\*(L"binary\*(R" data being written or read may become corrupted by CR-LF translations.
It will also be necessary to open the other filehandle (which the Perl source
code itself is being read from or written to) in \*(L"binary\*(R" mode too if the Perl
source code happens to contain any \*(L"binary\*(R" data, e.g. in a \f(CW\*(C`_\|_DATA_\|_\*(C'\fR section.
.Sp
File names may be supplied instead of open filehandles, in which case they will
be opened appropriately by \f(CW\*(C`crypt_file()\*(C'\fR itself and closed again after use.
(\f(CW\*(C`crypt_file()\*(C'\fR always opens the filehandles in \*(L"binary\*(R" mode so any \*(L"binary\*(R"
data in the Perl source code will be correctly handled.)
.Sp
The optional \f(CW$crypt_mode\fR argument specifies whether to
perform encryption or decryption.  If it is omitted or specified as \f(CW\*(C`undef\*(C'\fR or
the null string then the crypt mode will be determined automatically by reading
the beginning of the input data.  If the beginning is
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
then the data is presumed to be in an encrypted state already so the mode will
be set to \f(CW\*(C`CRYPT_MODE_DECRYPT\*(C'\fR; otherwise the mode will be set to
\&\f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR.
.Sp
On success, returns the number of bytes written (which could be zero if the
input was already in the requested state, in which case the special \*(L"zero but
true\*(R" value will be returned); on failure returns the undefined value (in scalar
context) or the empty list (in list context) and sets \f(CW$ErrStr\fR.
.SS "Crypt Mode Flags"
.IX Subsection "Crypt Mode Flags"
The \f(CW$crypt_mode\fR argument in \f(CW\*(C`crypt_file()\*(C'\fR specifies whether to encrypt or
decrypt the input data, as follows:
.ie n .IP """CRYPT_MODE_AUTO""" 4
.el .IP "\f(CWCRYPT_MODE_AUTO\fR" 4
.IX Item "CRYPT_MODE_AUTO"
Have the crypt mode determined automatically by the same means as described
under \f(CW\*(C`crypt_file()\*(C'\fR in the case where the \f(CW$crypt_mode\fR argument is omitted or
specified as \f(CW\*(C`undef\*(C'\fR or the null string.
.ie n .IP """CRYPT_MODE_ENCRYPT""" 4
.el .IP "\f(CWCRYPT_MODE_ENCRYPT\fR" 4
.IX Item "CRYPT_MODE_ENCRYPT"
Encrypt the input data and prepend the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
to the output data so that it can be run via
Filter::Crypto::Decrypt.  Produces a warning if the
input data already has that statement at the beginning.
.ie n .IP """CRYPT_MODE_DECRYPT""" 4
.el .IP "\f(CWCRYPT_MODE_DECRYPT\fR" 4
.IX Item "CRYPT_MODE_DECRYPT"
Decrypt the input data after first removing the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
from the beginning.  Produces a warning if the input data does not have that
statement at the beginning.
.ie n .IP """CRYPT_MODE_ENCRYPTED""" 4
.el .IP "\f(CWCRYPT_MODE_ENCRYPTED\fR" 4
.IX Item "CRYPT_MODE_ENCRYPTED"
The same as \f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR except that the encryption is not performed if
the input data already begins with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
Thus, unencrypted data will be encrypted, while encrypted data will not be
encrypted a second time.
.ie n .IP """CRYPT_MODE_DECRYPTED""" 4
.el .IP "\f(CWCRYPT_MODE_DECRYPTED\fR" 4
.IX Item "CRYPT_MODE_DECRYPTED"
The same as \f(CW\*(C`CRYPT_MODE_DECRYPT\*(C'\fR except that the decryption is not attempted if
the input data does not begin with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
Thus, encrypted data will be decrypted, while unencrypted data will not be
decrypted a second time.
.SS "Variables"
.IX Subsection "Variables"
.ie n .IP "$ErrStr" 4
.el .IP "\f(CW$ErrStr\fR" 4
.IX Item "$ErrStr"
Last error message.
.Sp
If the \f(CW\*(C`crypt_file()\*(C'\fR function fails then a description of the last error will
be set in this variable for use in reporting the cause of the failure, much like
the use of the Perl Special Variables \f(CW$!\fR and \f(CW$^E\fR after failed system calls
and \s-1OS API\s0 calls.  See \*(L"Error Values\*(R" for a listing of the possible values of
\&\f(CW$ErrStr\fR.
.Sp
If the function succeeds then this variable will generally be set to the null
string.  The only exceptions to this are when the crypt mode was specified as
either \f(CW\*(C`CRYPT_MODE_ENCRYPTED\*(C'\fR or \f(CW\*(C`CRYPT_MODE_DECRYPTED\*(C'\fR and the input data was
found to be already encrypted or decrypted respectively so that no action was
required: in these cases a message to this effect will be set in \f(CW$ErrStr\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.SS "Warnings and Error Messages"
.IX Subsection "Warnings and Error Messages"
This module may produce the following diagnostic messages.  They are classified
as follows (a la perldiag):
.PP
.Vb 3
\&    (W) A warning (optional).
\&    (F) A fatal error (trappable).
\&    (I) An internal error that you should never see (trappable).
.Ve
.ie n .IP "Can't close file '%s' after updating: %s" 4
.el .IP "Can't close file '%s' after updating: \f(CW%s\fR" 4
.IX Item "Can't close file '%s' after updating: %s"
(W) The specified file opened by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from and
writing data to when updating a file \*(L"in-place\*(R" could not be closed after use.
The system error message corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR
variable is also given.
.ie n .IP "Can't close input file '%s' after reading: %s" 4
.el .IP "Can't close input file '%s' after reading: \f(CW%s\fR" 4
.IX Item "Can't close input file '%s' after reading: %s"
(W) The specified input file opened by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from
could not be closed after use.  The system error message corresponding to the
standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't close output file '%s' after writing: %s" 4
.el .IP "Can't close output file '%s' after writing: \f(CW%s\fR" 4
.IX Item "Can't close output file '%s' after writing: %s"
(W) The specified output file opened by \f(CW\*(C`crypt_file()\*(C'\fR for writing data to
could not be closed after use.  The system error message corresponding to the
standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't release lock on filehandle after updating: %s" 4
.el .IP "Can't release lock on filehandle after updating: \f(CW%s\fR" 4
.IX Item "Can't release lock on filehandle after updating: %s"
(W) The exclusive lock acquired by \f(CW\*(C`crypt_file()\*(C'\fR on the filehandle used for
reading data from and writing data to when updating a file \*(L"in-place\*(R" could not
be released after use.  The system error message corresponding to the standard 
library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't release lock on input filehandle after reading: %s" 4
.el .IP "Can't release lock on input filehandle after reading: \f(CW%s\fR" 4
.IX Item "Can't release lock on input filehandle after reading: %s"
(W) The shared lock acquired by \f(CW\*(C`crypt_file()\*(C'\fR on the input filehandle used for
reading data from could not be released after use.  The system error message
corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't release lock on output filehandle after writing: %s" 4
.el .IP "Can't release lock on output filehandle after writing: \f(CW%s\fR" 4
.IX Item "Can't release lock on output filehandle after writing: %s"
(W) The exclusive lock acquired by \f(CW\*(C`crypt_file()\*(C'\fR on the output filehandle used
for writing data to could not be released after use.  The system error message
corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.IP "chsize/ftruncate not implemented" 4
.IX Item "chsize/ftruncate not implemented"
(F) The attempt by \f(CW\*(C`crypt_file()\*(C'\fR to truncate the file to zero size before
writing the data to it when updating a file \*(L"in-place\*(R" failed because the
\&\f(CW\*(C`chsize()\*(C'\fR and \f(CW\*(C`ftruncate()\*(C'\fR functions are not implemented on this system.
.IP "Input data already contains decryption filter" 4
.IX Item "Input data already contains decryption filter"
(W) The crypt mode was specified as \f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR but data read from the
input filehandle already begins with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
Perhaps you are attempting to encrypt data when you meant to be decrypting it?
.IP "Input data does not contain decryption filter" 4
.IX Item "Input data does not contain decryption filter"
(W) The crypt mode was specified as \f(CW\*(C`CRYPT_MODE_DECRYPT\*(C'\fR but data read from the
input filehandle did not begin with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
Perhaps you are attempting to decrypt data when you meant to be encrypting it?
.ie n .IP "%s is not a filehandle or a file name" 4
.el .IP "\f(CW%s\fR is not a filehandle or a file name" 4
.IX Item "%s is not a filehandle or a file name"
(F) The first parameter for \f(CW\*(C`crypt_file()\*(C'\fR must be either a valid (open)
filehandle or a file name, but the argument passed was neither of these things.
.ie n .IP "%s is not a valid crypt mode" 4
.el .IP "\f(CW%s\fR is not a valid crypt mode" 4
.IX Item "%s is not a valid crypt mode"
(F) The third parameter for \f(CW\*(C`crypt_file()\*(C'\fR must be either \f(CW\*(C`undef\*(C'\fR or the null
string (meaning determine the crypt mode automatically), or a valid crypt mode
(i.e. one of the \f(CW\*(C`CRYPT_MODE_*\*(C'\fR flags), but the argument passed was neither of
these things.
.ie n .IP "%s is not a valid crypt mode or a filehandle or a file name" 4
.el .IP "\f(CW%s\fR is not a valid crypt mode or a filehandle or a file name" 4
.IX Item "%s is not a valid crypt mode or a filehandle or a file name"
(F) The second parameter for \f(CW\*(C`crypt_file()\*(C'\fR must be one of: \f(CW\*(C`undef\*(C'\fR or the
null string (meaning determine the crypt mode automatically), a valid crypt mode
(i.e. one of the \f(CW\*(C`CRYPT_MODE_*\*(C'\fR flags), or a valid (open) filehandle or a file
name, but the argument passed was none of these things.
.ie n .IP "%s is not a valid Filter::Crypto::CryptFile macro" 4
.el .IP "\f(CW%s\fR is not a valid Filter::Crypto::CryptFile macro" 4
.IX Item "%s is not a valid Filter::Crypto::CryptFile macro"
(F) You attempted to lookup the value of the specified constant in the
Filter::Crypto::CryptFile module, but that constant is unknown to this module.
.IP "No such package '%s'" 4
.IX Item "No such package '%s'"
(F) This module's bootstrap function was called on the specified package, which
does not exist.
.IP "Random \s-1IV\s0 may not be cryptographically strong" 4
.IX Item "Random IV may not be cryptographically strong"
(W) libcrypto's random number generator failed to generate cryptographically
strong pseudo-random bytes for use as the initialization vector (\s-1IV\s0) in the
encryption.  A weaker sequence of pseudo-random bytes was used instead, which is
not necessarily unpredictable and may not be suitable for this purpose.
.IP "Random salt may not be cryptographically strong" 4
.IX Item "Random salt may not be cryptographically strong"
(W) libcrypto's random number generator failed to generate cryptographically
strong pseudo-random bytes for use as the salt when performing the key
derivation before encryption.  A weaker sequence of pseudo-random bytes was used
instead, which is not necessarily unpredictable and may not be suitable for this
purpose.
.IP "Unexpected error in \s-1\fBAUTOLOAD\s0()\fR: \fBconstant()\fR is not defined" 4
.IX Item "Unexpected error in AUTOLOAD(): constant() is not defined"
(I) There was an unexpected error looking up the value of a constant: the
constant-lookup function itself is apparently not defined.
.ie n .IP "Unexpected return type %d while processing Filter::Crypto::CryptFile macro %s" 4
.el .IP "Unexpected return type \f(CW%d\fR while processing Filter::Crypto::CryptFile macro \f(CW%s\fR" 4
.IX Item "Unexpected return type %d while processing Filter::Crypto::CryptFile macro %s"
(I) There was an unexpected error looking up the value of the specified
constant: the C component of the constant-lookup function returned an unknown
type.
.IP "Unknown crypt mode '%d'" 4
.IX Item "Unknown crypt mode '%d'"
(I) The \s-1XSUB\s0 called internally by \f(CW\*(C`crypt_file()\*(C'\fR was passed a crypt mode that
it does not recognize or failed to derive correctly a crypt mode for setting in
the crypto context structure to be used when performing the encryption or
decryption.
.IP "Unknown crypto context mode '%d'" 4
.IX Item "Unknown crypto context mode '%d'"
(I) The crypto context structure used internally when performing encryption or
decryption has been set-up with a crypt mode that it does not recognize.
.ie n .IP "Your vendor has not defined Filter::Crypto::CryptFile macro %s" 4
.el .IP "Your vendor has not defined Filter::Crypto::CryptFile macro \f(CW%s\fR" 4
.IX Item "Your vendor has not defined Filter::Crypto::CryptFile macro %s"
(I) You attempted to lookup the value of the specified constant in the
Filter::Crypto::CryptFile module, but that constant is apparently not defined.
.SS "Error Values"
.IX Subsection "Error Values"
The \f(CW\*(C`crypt_file()\*(C'\fR function sets \f(CW$ErrStr\fR to a value indicating the cause of the
error when it fails.  The possible values are as follows:
.ie n .IP "Can't acquire exclusive lock on output filehandle: %s" 4
.el .IP "Can't acquire exclusive lock on output filehandle: \f(CW%s\fR" 4
.IX Item "Can't acquire exclusive lock on output filehandle: %s"
The filehandle used by \f(CW\*(C`crypt_file()\*(C'\fR for writing data to could not be locked
for exclusive use.  The system error message corresponding to the standard C
library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't acquire exclusive lock on update filehandle: %s" 4
.el .IP "Can't acquire exclusive lock on update filehandle: \f(CW%s\fR" 4
.IX Item "Can't acquire exclusive lock on update filehandle: %s"
The filehandle used by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from and writing data to
when updating a file \*(L"in-place\*(R" could not be locked for exclusive use.  The
system error message corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable
is also given.
.ie n .IP "Can't acquire shared lock on input filehandle: %s" 4
.el .IP "Can't acquire shared lock on input filehandle: \f(CW%s\fR" 4
.IX Item "Can't acquire shared lock on input filehandle: %s"
The filehandle used by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from could not be locked
for shared use.  The system error message corresponding to the standard C
library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't cleanup cipher context: %s" 4
.el .IP "Can't cleanup cipher context: \f(CW%s\fR" 4
.IX Item "Can't cleanup cipher context: %s"
The cipher context structure used to perform the encryption or decryption could
not be cleaned up after use.  The last error message from libcrypto is also
given.
.IP "Can't decode odd-numbered (%d\-byte) length hexadecimal text" 4
.IX Item "Can't decode odd-numbered (%d-byte) length hexadecimal text"
The hexadecimal encoding of the encrypted source code, consisting of a pair of
hexadecimal digits for each byte of data, could not be decoded because an odd
number of hexadecimal digits were found.
.ie n .IP "Can't decode non-hexadecimal digit (byte %02x at position %d) in hexadecimal text" 4
.el .IP "Can't decode non-hexadecimal digit (byte \f(CW%02x\fR at position \f(CW%d\fR) in hexadecimal text" 4
.IX Item "Can't decode non-hexadecimal digit (byte %02x at position %d) in hexadecimal text"
The hexadecimal encoding of the encrypted source code, consisting of a pair of
hexadecimal digits for each byte of data, could not be decoded because a byte
other than a hexadecimal digit was found.
.ie n .IP "Can't derive %d\-byte key: %s" 4
.el .IP "Can't derive \f(CW%d\fR\-byte key: \f(CW%s\fR" 4
.IX Item "Can't derive %d-byte key: %s"
libcrypto's PKCS#5 v2.0 compatible key derivation algorithm failed to derive a
key of the specified length from the supplied password for use in the encryption
or decryption.  The last error message from libcrypto is also given.
.ie n .IP "Can't finalize cipher context: %s" 4
.el .IP "Can't finalize cipher context: \f(CW%s\fR" 4
.IX Item "Can't finalize cipher context: %s"
The cipher context structure used to perform the encryption or decryption could
not be finalized.  The last error message from libcrypto is also given.
.ie n .IP "Can't generate %d\-byte random salt: %s" 4
.el .IP "Can't generate \f(CW%d\fR\-byte random salt: \f(CW%s\fR" 4
.IX Item "Can't generate %d-byte random salt: %s"
libcrypto's random number generator failed to generate the specified number of
pseudo-random bytes for use as the salt when performing the key derivation prior
to encryption.  The last error message from libcrypto is also given.
.ie n .IP "Can't generate %d\-byte random \s-1IV:\s0 %s" 4
.el .IP "Can't generate \f(CW%d\fR\-byte random \s-1IV:\s0 \f(CW%s\fR" 4
.IX Item "Can't generate %d-byte random IV: %s"
libcrypto's random number generator failed to generate the specified number of
pseudo-random bytes for use as the initialization vector (\s-1IV\s0) in the encryption.
The last error message from libcrypto is also given.
.ie n .IP "Can't initialize cipher context in crypt mode '%d': %s" 4
.el .IP "Can't initialize cipher context in crypt mode '%d': \f(CW%s\fR" 4
.IX Item "Can't initialize cipher context in crypt mode '%d': %s"
The cipher context structure used to perform the encryption or decryption could
not be initialized in the specified crypt mode.  This is the first stage of the
cipher context structure initialization, performed before setting the key length
and modifying other cipher parameters.  The last error message from libcrypto is
also given.
.ie n .IP "Can't initialize cipher context in crypt mode '%d' using %d\-byte key: %s" 4
.el .IP "Can't initialize cipher context in crypt mode '%d' using \f(CW%d\fR\-byte key: \f(CW%s\fR" 4
.IX Item "Can't initialize cipher context in crypt mode '%d' using %d-byte key: %s"
The cipher context structure used to perform the encryption or decryption could
not be initialized in the specified crypt mode with the specified key length.
This is the final stage of the cipher context structure initialization,
performed after setting the key length and modifying other cipher parameters.
The last error message from libcrypto is also given.
.IP "Can't initialize \s-1PRNG\s0" 4
.IX Item "Can't initialize PRNG"
libcrypto's random number generator could not be seeded with enough entropy.
.ie n .IP "Can't open file '%s' for updating: %s" 4
.el .IP "Can't open file '%s' for updating: \f(CW%s\fR" 4
.IX Item "Can't open file '%s' for updating: %s"
The specified file could not be opened by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from
and writing data to when updating a file \*(L"in-place\*(R".  The system error message
corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't open input file '%s' for reading: %s" 4
.el .IP "Can't open input file '%s' for reading: \f(CW%s\fR" 4
.IX Item "Can't open input file '%s' for reading: %s"
The specified file from which to read data could not be opened for reading by
\&\f(CW\*(C`crypt_file()\*(C'\fR.  The system error message corresponding to the standard C
library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't open output file '%s' for writing: %s" 4
.el .IP "Can't open output file '%s' for writing: \f(CW%s\fR" 4
.IX Item "Can't open output file '%s' for writing: %s"
The specified file could not be opened by \f(CW\*(C`crypt_file()\*(C'\fR for writing data to.
The system error message corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR
variable is also given.
.ie n .IP "Can't read from input filehandle: %s" 4
.el .IP "Can't read from input filehandle: \f(CW%s\fR" 4
.IX Item "Can't read from input filehandle: %s"
There was an error reading data from the input filehandle.  The system error
message corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't set key length to %d: %s" 4
.el .IP "Can't set key length to \f(CW%d:\fR \f(CW%s\fR" 4
.IX Item "Can't set key length to %d: %s"
The specified key length could not be set for the cipher context structure used
to perform the encryption or decryption.  The last error message from libcrypto
is also given.
.ie n .IP "Can't set \s-1RC2\s0 effective key bits to %d: %s" 4
.el .IP "Can't set \s-1RC2\s0 effective key bits to \f(CW%d:\fR \f(CW%s\fR" 4
.IX Item "Can't set RC2 effective key bits to %d: %s"
The specified effective key bits could not be set for the cipher context
structure used to perform the encryption or decryption when using the \s-1RC2\s0
cipher.  The last error message from libcrypto is also given.
.ie n .IP "Can't set \s-1RC5\s0 number of rounds to %d: %s" 4
.el .IP "Can't set \s-1RC5\s0 number of rounds to \f(CW%d:\fR \f(CW%s\fR" 4
.IX Item "Can't set RC5 number of rounds to %d: %s"
The specified number of rounds could not be set for the cipher context structure
used to perform the encryption or decryption when using the \s-1RC5\s0 cipher.  The
last error message from libcrypto is also given.
.ie n .IP "Can't truncate filehandle: %s" 4
.el .IP "Can't truncate filehandle: \f(CW%s\fR" 4
.IX Item "Can't truncate filehandle: %s"
The filehandle used by \f(CW\*(C`crypt_file()\*(C'\fR for reading data from and writing data to
when updating a file \*(L"in-place\*(R" could not be truncated to zero size before
writing data to it.  The system error message corresponding to the standard C
library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't update cipher context with %d bytes of in-text: %s" 4
.el .IP "Can't update cipher context with \f(CW%d\fR bytes of in-text: \f(CW%s\fR" 4
.IX Item "Can't update cipher context with %d bytes of in-text: %s"
The cipher context structure used to perform the encryption or decryption could
not be updated with the specified number of bytes of input data.  The last error
message from libcrypto is also given.
.ie n .IP "Can't write header line to output filehandle: %s" 4
.el .IP "Can't write header line to output filehandle: \f(CW%s\fR" 4
.IX Item "Can't write header line to output filehandle: %s"
There was an error writing the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
to the output filehandle.  The system error message corresponding to the
standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't write to filehandle: %s" 4
.el .IP "Can't write to filehandle: \f(CW%s\fR" 4
.IX Item "Can't write to filehandle: %s"
There was an error writing data to the filehandle when updating a file
\&\*(L"in-place\*(R".  The system error message corresponding to the standard C library
\&\f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Can't write to output filehandle: %s" 4
.el .IP "Can't write to output filehandle: \f(CW%s\fR" 4
.IX Item "Can't write to output filehandle: %s"
There was an error writing data to the output filehandle.  The system error
message corresponding to the standard C library \f(CW\*(C`errno\*(C'\fR variable is also given.
.ie n .IP "Derived key length is wrong (%d, expected %d)" 4
.el .IP "Derived key length is wrong (%d, expected \f(CW%d\fR)" 4
.IX Item "Derived key length is wrong (%d, expected %d)"
libcrypto's PKCS#5 v1.5 compatible key derivation algorithm failed to derive a
key of the requested length from the supplied password for use in the encryption
or decryption.
.IP "Input data was already decrypted" 4
.IX Item "Input data was already decrypted"
The crypt mode was specified as \f(CW\*(C`CRYPT_MODE_DECRYPTED\*(C'\fR and data read from the
input filehandle does not begin with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
indicating that the data is probably already decrypted.  No action was taken,
and \f(CW\*(C`crypt_file()\*(C'\fR returned success.  Use the crypt mode \f(CW\*(C`CRYPT_MODE_DECRYPT\*(C'\fR
if you really want to force decryption in this case.
.IP "Input data was already encrypted" 4
.IX Item "Input data was already encrypted"
The crypt mode was specified as \f(CW\*(C`CRYPT_MODE_ENCRYPTED\*(C'\fR and data read from the
input filehandle already begins with the statement
.Sp
.Vb 1
\&    use Filter::Crypto::Decrypt;
.Ve
.Sp
indicating that the data is probably already encrypted.  No action was taken,
and \f(CW\*(C`crypt_file()\*(C'\fR returned success.  Use the crypt mode \f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR
if you really want to force encryption in this case.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the \fBcrypt_file\fR script for examples of the use of the \f(CW\*(C`crypt_file()\*(C'\fR
function.
.SH "EXPORTS"
.IX Header "EXPORTS"
The following symbols are, or can be, exported by this module:
.IP "Default Exports" 4
.IX Item "Default Exports"
\&\f(CW\*(C`crypt_file\*(C'\fR;
.Sp
\&\f(CW\*(C`CRYPT_MODE_AUTO\*(C'\fR,
\&\f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR,
\&\f(CW\*(C`CRYPT_MODE_DECRYPT\*(C'\fR,
\&\f(CW\*(C`CRYPT_MODE_ENCRYPTED\*(C'\fR,
\&\f(CW\*(C`CRYPT_MODE_DECRYPTED\*(C'\fR.
.IP "Optional Exports" 4
.IX Item "Optional Exports"
\&\f(CW$ErrStr\fR.
.IP "Export Tags" 4
.IX Item "Export Tags"
\&\fINone\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
Note that specifying the \*(L"crypt_mode\*(R" as \f(CW\*(C`CRYPT_MODE_AUTO\*(C'\fR, \f(CW\*(C`undef\*(C'\fR or the
null string can be used to resolve any ambiguity in the case where
\&\f(CW\*(C`crypt_file()\*(C'\fR is called with two arguments, namely, did the caller intend
\&\f(CW\*(C`crypt_file($in_file, $out_file)\*(C'\fR or \f(CW\*(C`crypt_file($in_out_file, $crypt_mode)\*(C'\fR?
.Sp
In such cases, \f(CW\*(C`crypt_file()\*(C'\fR checks if the second argument is a valid \*(L"crypt
mode\*(R" before considering if it is a file name, so it normally Does The Right
Thing.  However, if you wanted to write the output to a file called \fI1\fR (which
happens to be the value of the \f(CW\*(C`CRYPT_MODE_ENCRYPT\*(C'\fR flag) then calling
.Sp
.Vb 1
\&    crypt_file($in_file, \*(Aq1\*(Aq);
.Ve
.Sp
will not do what you want.  In this case, you can call
.Sp
.Vb 1
\&    crypt_file($in_file, \*(Aq1\*(Aq, CRYPT_MODE_AUTO);
.Ve
.Sp
instead to get the desired behaviour (without having to explicitly specify the
crypt mode).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Filter::Crypto.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The \f(CW\*(C`FilterCrypto_PRNGInit()\*(C'\fR and \f(CW\*(C`FilterCrypto_GetRandNum()\*(C'\fR functions used
by the \s-1XS\s0 code are based on code taken from the \f(CW\*(C`ssl_rand_seed()\*(C'\fR and
\&\f(CW\*(C`ssl_rand_choosenum()\*(C'\fR functions in Apache httpd (version 2.4.9).
.PP
Thanks to Steve Henson for help with performing \s-1PBE\s0 and PKCS#5 v2.0 key
derivation with arbitrary ciphers and non-default key lengths using the OpenSSL
libcrypto library.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Hay <shay@cpan.org <mailto:shay@cpan.org>>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004\-2009, 2012\-2014 Steve Hay.  All rights reserved.
.SH "LICENCE"
.IX Header "LICENCE"
This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, i.e. under the terms of either the \s-1GNU\s0 General Public
License or the Artistic License, as specified in the \fI\s-1LICENCE\s0\fR file.
.SH "VERSION"
.IX Header "VERSION"
Version 2.08
.SH "DATE"
.IX Header "DATE"
31 Jul 2018
.SH "HISTORY"
.IX Header "HISTORY"
See the \fIChanges\fR file.
