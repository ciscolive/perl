.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::Format 3"
.TH Spreadsheet::Reader::Format 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::Format \- Formatting for various spreadsheet readers
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 10
\&        #!/usr/bin/env perl
\&        use MooseX::ShortCut::BuildInstance \*(Aqbuild_instance\*(Aq;
\&        use Spreadsheet::Reader::Format;
\&        use Spreadsheet::Reader::Format::FmtDefault;
\&        use Spreadsheet::Reader::Format::ParseExcelFormatStrings;
\&        use Spreadsheet::Reader::ExcelXML;
\&        my $formatter = build_instance(
\&                package => \*(AqFormatInstance\*(Aq,
\&                # The base United State localization settings \- Inject your customized format class here
\&                superclasses => [ \*(AqSpreadsheet::Reader::Format::FmtDefault\*(Aq ],
\&                # ParseExcelFormatStrings => The Excel string parser generation engine
\&                # Format => The top level interface defining minimum compatability requirements
\&                add_roles_in_sequence =>[qw(
\&                        Spreadsheet::Reader::Format::ParseExcelFormatStrings
\&                        Spreadsheet::Reader::Format
\&                )],
\&                target_encoding => \*(Aqlatin1\*(Aq,# Adjust the string output encoding here
\&                datetime_dates  => 1,
\&        );
\&
\&        # Use in a standalone manner
\&        my      $date_string = \*(Aqyyyy\-mm\-dd\*(Aq;
\&        my      $time           = 55.0000102311;
\&        # Build a coercion with excel format string: $date_string
\&        my      $coercion       = $formatter\->parse_excel_format_string( $date_string );
\&        # Checking that a DateTime object was returned
\&        print ref( $coercion\->assert_coerce( $time ) ) . "\en";
\&        # Checking that the date and time are presented correctly: 1904\-02\-25T00:00:01
\&        print $coercion\->assert_coerce( $time ) . "\en";
\&
\&        # Set specific default custom formats here (for use in an excel parser)
\&        $formatter\->set_defined_excel_formats( 0x2C => \*(AqMyCoolFormatHere\*(Aq );
\&
\&        # Use the formatter like Spreadsheet::ParseExcel
\&        my $parser      = Spreadsheet::Reader::ExcelXML\->new;
\&        my $workbook = $parser\->parse( \*(Aq../t/test_files/TestBook.xlsx\*(Aq, $formatter );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In general a completly built formatter class as shown in the \s-1SYNOPSYS\s0 is already used
by the package Spreadsheet::Reader::ExcelXML to turn unformatted data into formatted
data.  The purpose is to allow the Excel equivalent of localization of the output.  The
general localization options are mostly found at the workbook level.  Individual cells
also contain information about how that cell data should be formatted.
.PP
It is possible to insert alternate roles in the Formatter build or use methods
to customize the defaults used by the formatter for use in the Spreadsheet reader.  It
is also possible to use the formatter to output custom format code for post processing
output..
.SS "Module Description"
.IX Subsection "Module Description"
This module is written to be an Interface
 <http://www.codeproject.com/Articles/22769/Introduction-to-Object-Oriented-Programming-Concep#Interface>
for the Formatter class used in Spreadsheet::Reader::ExcelXML so that the core
parsing engine and the
regional formatting settings for the
parser can easily be swapped.  This interface really only defines method requirements for
the undlerlying instance since the engine it uses was custom-built for
Spreadsheet::Reader::ExcelXML.  However, adding a shim to this package so it can
be used by Spreadsheet::ParseExcel (for example) should be easier because of the
abstraction.
.PP
This module does not provide unique methods.  It just requires methods and provides a
uniform interface for the workbook package.  Additional attributes and methods provided
by the sub modules may be available to the instance but are not in the strictest sence
required.
.SS "Methods"
.IX Subsection "Methods"
These are the methods required by this interface.  Links to the default implementation
of each method are provided but any customization of the formatter instance for Spreadsheet
parsing will as a minimum require these methods.
.PP
\fIparse_excel_format_string( \f(CI$string\fI, \f(CI$name\fI )\fR
.IX Subsection "parse_excel_format_string( $string, $name )"
.Sp
.RS 4
\&\fBDefinition:\fR This is the method to convert Excel format strings to code that will
translate raw data from the file to formatted output in the form defined by the string.
It is possible to pass a format name that will be incorperated so that the method
\&\f(CW$coercion\fR\->display_name returns \f(CW$name\fR.
.Sp
\&\fBDefault source:\fR \*(L"parse_excel_format_string( \f(CW$string\fR, \f(CW$name\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.PP
\fIget_defined_conversion( \f(CI$position\fI )\fR
.IX Subsection "get_defined_conversion( $position )"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the code for string conversion for a pre-defined
conversion by position.
.Sp
\&\fBDefault source:\fR \*(L"get_defined_conversion( \f(CW$position\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.PP
\fIset_target_encoding( \f(CI$encoding\fI )\fR
.IX Subsection "set_target_encoding( $encoding )"
.Sp
.RS 4
\&\fBDefinition:\fR This sets the output \f(CW$encoding\fR for strings.
.Sp
\&\fBDefault source:\fR \*(L"set_target_encoding( \f(CW$encoding\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIget_target_encoding\fR
.IX Subsection "get_target_encoding"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the output encoding definition for strings.
.Sp
\&\fBDefault source:\fR \*(L"get_target_encoding\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIhas_target_encoding\fR
.IX Subsection "has_target_encoding"
.Sp
.RS 4
\&\fBDefinition:\fR It is possible to not set a target encoding in which case any call to decode
data acts like a pass through.  This returns true if the target encoding is set.
.Sp
\&\fBDefault source:\fR \*(L"has_target_encoding\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIchange_output_encoding( \f(CI$string\fI )\fR
.IX Subsection "change_output_encoding( $string )"
.Sp
.RS 4
\&\fBDefinition:\fR This is the method call that implements the output encoding change for \f(CW$string\fR.
.Sp
\&\fBDefault source:\fR \*(L"change_output_encoding( \f(CW$string\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIget_excel_region\fR
.IX Subsection "get_excel_region"
.Sp
.RS 4
\&\fBDefinition:\fR It may be useful for this instance to self identify it's target output.
This method returns that value
.Sp
\&\fBDefault source:\fR \*(L"get_excel_region\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIset_defined_excel_formats( \f(CI%args\fI )\fR
.IX Subsection "set_defined_excel_formats( %args )"
.Sp
.RS 4
\&\fBDefinition:\fR This allows for adjustment and or addition to the output format lookup table.
The default implementation allows for multiple ways to do this so please review that documentation
for details.
.Sp
\&\fBDefault source:\fR \*(L"set_defined_excel_formats( \f(CW%args\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.RE
.PP
\fIset_cache_behavior( \f(CI$bool\fI )\fR
.IX Subsection "set_cache_behavior( $bool )"
.Sp
.RS 4
\&\fBDefinition:\fR This sets the flag that turns on caching of built format conversion code sets
.Sp
\&\fBDefault source:\fR \*(L"set_cache_behavior( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.PP
\fIset_date_behavior( \f(CI$bool\fI )\fR
.IX Subsection "set_date_behavior( $bool )"
.Sp
.RS 4
\&\fBDefinition:\fR This sets the flag that interrupts the date formatting to return a datetime object rather
than a date string
.Sp
\&\fBDefault source:\fR \*(L"set_date_behavior( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.PP
\fIset_european_first( \f(CI$bool\fI )\fR
.IX Subsection "set_european_first( $bool )"
.Sp
.RS 4
\&\fBDefinition:\fR This also sets a flag dealing with dates.  The date behavior that is affected here
involves parsing date strings (not excel date numbers) and checks the DD-MM-YY form before it
checkes the MM-DD-YY form when attempting to parse date strings.
.Sp
\&\fBDefault source:\fR \*(L"set_european_first( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.PP
\fIset_workbook_inst( \f(CI$instance\fI )\fR
.IX Subsection "set_workbook_inst( $instance )"
.Sp
.RS 4
\&\fBDefinition:\fR This sets the workbook instance in the Formatter instance.
Spreadsheet::Reader::ExcelXML should do this automatically and will overwrite this attribute
if the end-user sets it.  The purpose of this instance is for the formatter to see some of the
workbook level methods;
.Sp
\&\fBDelegates:\fR
.Sp
.RS 4
\&\*(L"set_error\*(R" in Spreadsheet::Reader::ExcelXML
.Sp
\&\*(L"get_epoch_year\*(R" in Spreadsheet::Reader::ExcelXML
.RE
.RE
.RS 4
.Sp
\&\fBDefault source:\fR \*(L"set_workbook_inst( \f(CW$instance\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::Format/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-format/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Nothing yet
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016, 2017 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
version \-  0.77
.Sp
perl 5.010
.Sp
Encode \- decode
.Sp
Moose 2.1213
.Sp
Carp \- confess
.Sp
Type::Tiny \- 1.000
.Sp
DateTimeX::Format::Excel \- 0.012
.Sp
DateTime::Format::Flexible
.Sp
Clone \- clone
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::ParseExcel \- Excel 2003 and earlier
.Sp
Spreadsheet::XLSX \- 2007+
.Sp
Spreadsheet::ParseXLSX \- 2007+
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
