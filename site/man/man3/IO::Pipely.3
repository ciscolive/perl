.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Pipely 3"
.TH IO::Pipely 3 "2013-08-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Pipely \- Portably create pipe() or pipe\-like handles, one way or another.
.SH "VERSION"
.IX Header "VERSION"
version 0.005
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Please read \s-1DESCRIPTION\s0 for detailed semantics and caveats.
.PP
.Vb 1
\&  use IO::Pipely qw(pipely socketpairly);
\&
\&  # Create a one\-directional pipe() or pipe\-like thing
\&  # the best conduit type available.
\&
\&  my ($read, $write) = pipely();
\&
\&  # Create a one\-directional pipe\-like thing using an
\&  # INET socket specifically.  Other types are available.
\&
\&  my ($read, $write) = pipely(type => \*(Aqinet\*(Aq);
\&
\&  # Create a bidirectional pipe\-like thing using
\&  # the best conduit type available.
\&
\&  my (
\&    $side_a_read,  $side_b_read,
\&    $side_a_write, $side_b_write,
\&  ) = socketpairly();
\&
\&  # Create a bidirectional pipe\-like thing using an INET socket
\&  # specifically.
\&
\&  my (
\&    $side_a_read,  $side_b_read,
\&    $side_a_write, $side_b_write,
\&  ) = socketpairly(type => \*(Aqinet\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pipes are troublesome beasts because there are a few different,
incompatible ways to create them.  Not all platforms support all ways,
and some platforms may have hidden difficulties like incomplete or
buggy support.
.PP
IO::Pipely provides a couple functions to portably create one\- and
two-way pipes and pipe-like socket pairs.  It acknowledges and works
around known platform issues so you don't have to.
.PP
On the other hand, it doesn't work around unknown issues, so please
report any problems early and often.
.PP
IO::Pipely currently understands \fBpipe()\fR, UNIX-domain \fBsocketpair()\fR and
regular IPv4 localhost sockets.  This covers every platform tested so
far, but it's hardly complete.  Please help support other mechanisms,
such as INET-domain \fBsocketpair()\fR and IPv6 localhost sockets.
.PP
IO::Pipely will use different kinds of pipes or sockets depending on
the operating system's capabilities and the number of directions
requested.  The autodetection may be overridden by specifying a
particular pipe type.
.SS "pipely"
.IX Subsection "pipely"
\&\fBpipely()\fR creates a one-directional \fBpipe()\fR or socket.  It's modeled
after Perl's built-in \fBpipe()\fR function, but it creates and returns
handles rather than opening ones given to it.
.PP
On success, \fBpipely()\fR returns two file handles, the first to read from
the pipe, and the second writes into the pipe.  It returns nothing on
failure.
.PP
.Vb 3
\&  use IO::Pipely qw(pipely);
\&  my ($a_read, $b_write) = pipely();
\&  die "pipely() failed: $!" unless $a_read;
.Ve
.PP
When given a choice, it will prefer to use leaner \fBpipe()\fR calls instead
of \fBsocketpair()\fR and \fBsocket()\fR.
.PP
\&\fBpipely()\fR's choice can be forced using an optional named \*(L"type\*(R"
parameter.  See \*(L"\s-1PIPE TYPES\*(R"\s0 for the types that can be used.
.PP
.Vb 3
\&  my ($a_read, $b_write) = pipely(
\&    type => \*(Aqpipe\*(Aq,
\&  );
.Ve
.PP
On most systems, \fBpipely()\fR will prefer to open a \fBpipe()\fR first.  It will
fall back to a \s-1UNIX\s0 \fBsocketpair()\fR or two localhost Internet sockets, in
that order.
.PP
On Windows (ActiveState and Strawberry Perl), \fBpipely()\fR prefers two
localhost Internet sockets.  It will fall back to \fBsocketpair()\fR and
\&\fBpipe()\fR, both of which will probably fail.
.PP
Cygwin Perl prefers \fBpipe()\fR first, localhost Internet sockets, and then
\&\fBsocketpair()\fR.  \fBsocketpair()\fR has been known to have problems on Cygwin.
.PP
MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.
.SS "socketpairly"
.IX Subsection "socketpairly"
\&\fBsocketpairly()\fR creates a two-directional socket pair.  It's modeled
after Perl's built-in \fBsocketpair()\fR, but it creates and returns handles
rather than opening ones given to it.
.PP
On success, \fBsocketpairly()\fR returns four file handles, read and write
for one end, and read and write for the other.  On failure, it returns
nothing.
.PP
.Vb 3
\&  use IO::Pipely qw(socketpairly);
\&  my ($a_read, $b_read, $a_write, $b_write) = socketpairly();
\&  die "socketpairly() failed: $!" unless $a_read;
.Ve
.PP
\&\fBsocketpairly()\fR returns two extra \*(L"writer\*(R" handles.  They exist for the
fallback case where two \fBpipe()\fR calls are needed instead of one socket
pair.  The extra handles can be ignored whenever \fBpipe()\fR will never be
used.  For example:
.PP
.Vb 3
\&  use IO::Pipely qw(socketpairly);
\&  my ($side_a, $side_b) = socketpairly( type => \*(Aqsocketpair\*(Aq );
\&  die "socketpairly() failed: $!" unless $side_a;
.Ve
.PP
When given a choice, it will prefer bidirectional sockets instead of
\&\fBpipe()\fR calls.
.PP
\&\fBsocketpairly()\fR's choice can be forced using an optional named \*(L"type\*(R"
parameter.  See \*(L"\s-1PIPE TYPES\*(R"\s0 for the types that can be used.  In
this example, two unidirectional pipes wil be used instead of a more
efficient pair of sockets:
.PP
.Vb 3
\&  my ($a_read, $a_write, $b_read, $b_write) = pipely(
\&    type => \*(Aqpipe\*(Aq,
\&  );
.Ve
.PP
On most systems, \fBsocketpairly()\fR will try to open a \s-1UNIX\s0 \fBsocketpair()\fR
first.  It will then fall back to a pair of localhost Internet
sockets, and finally it will try a pair of \fBpipe()\fR calls.
.PP
On Windows (ActiveState and Strawberry Perl), \fBsocketpairly()\fR prefers a
pair of localhost Internet sockets first.  It will then fall back to a
\&\s-1UNIX\s0 \fBsocketpair()\fR, and finally a couple of \fBpipe()\fR calls.  The fallback
options will probably fail, but the code remains hopeful.
.PP
Cygwin Perl prefers localhost Internet sockets first, followed by a
pair of \fBpipe()\fR calls, and finally a \s-1UNIX\s0 \fBsocketpair()\fR.  Those who know
may find this counter-intuitive, but it works around known issues in
some versions of Cygwin \fBsocketpair()\fR.
.PP
MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.
.SS "\s-1PIPE TYPES\s0"
.IX Subsection "PIPE TYPES"
IO::Pipely currently supports three types of pipe and socket.  Other
types are possible, but these three cover all known uses so far.
Please ask (or send patches) if additional types are needed.
.PP
\fIpipe\fR
.IX Subsection "pipe"
.PP
Attempt to establish a one-way pipe using one \fBpipe()\fR filehandle pair
(2 file descriptors), or a two-way pipe-like connection using two
\&\fBpipe()\fR pairs (4 file descriptors).
.PP
IO::Pipely prefers to use \fBpipe()\fR for one-way pipes and some form of
socket pair for two-way pipelike things.
.PP
\fIsocketpair\fR
.IX Subsection "socketpair"
.PP
Attempt to establish a one\- or two-way pipelike connection using a
single \fBsocketpair()\fR call.  This uses two file descriptors regardless
whether the connection is one\- or two-way.
.PP
IO::Pipely prefers \fBsocketpair()\fR for two-way connections, unless the
current platform has known issues with the \fBsocketpair()\fR call.
.PP
Socket pairs are \s-1UNIX\s0 domain only for now.  \s-1INET\s0 domain may be added
if it improves compatibility on some platform, or if someone
contributes the code.
.PP
\fIinet\fR
.IX Subsection "inet"
.PP
Attempt to establish a one\- or two-way pipelike connection using
localhost \fBsocket()\fR calls.  This uses two file descriptors regardless
whether the connection is one\- or two-way.
.PP
Localhost \s-1INET\s0 domain sockets are a last resort for platforms that
don't support something better.  They are the least secure method of
communication since tools like tcpdump and Wireshark can tap into
them.  On the other hand, this makes them easiest to debug.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
These are issues known to the developers at the time of this writing.
Things change, so check back now and then.
.SS "Cygwin"
.IX Subsection "Cygwin"
CygWin seems to have a problem with \fBsocketpair()\fR and \fBexec()\fR.  When
an exec'd process closes, any data on sockets created with
\&\fBsocketpair()\fR is not flushed.  From irc.perl.org channel #poe:
.PP
.Vb 11
\&  <dngnand>   Sounds like a lapse in cygwin\*(Aqs exec implementation.
\&              It works ok under Unix\-ish systems?
\&  <jdeluise2> yes, it works perfectly
\&  <jdeluise2> but, if we just use POE::Pipe::TwoWay\->new("pipe")
\&              it always works fine on cygwin
\&  <jdeluise2> by the way, it looks like the reason is that
\&              POE::Pipe::OneWay works because it tries to make a
\&              pipe first instead of a socketpair
\&  <jdeluise2> this socketpair problem seems like a long\-standing
\&              one with cygwin, according to searches on google,
\&              but never been fixed.
.Ve
.SS "MacOS 9"
.IX Subsection "MacOS 9"
IO::Pipely supports MacOS 9 for historical reasons.
It's unclear whether anyone still uses MacPerl, but the support is
cheap since pipes and sockets there have many of the same caveats as
they do on Windows.
.SS "Symbol::gensym"
.IX Subsection "Symbol::gensym"
IO::Pipely uses \fBSymbol::gensym()\fR instead of autovivifying file
handles.  The main reasons against \fBgensym()\fR have been stylistic ones
so far.  Meanwhile, \fBgensym()\fR is compatible farther back than handle
autovivification.
.SS "Windows"
.IX Subsection "Windows"
ActiveState and Strawberry Perl don't support \fBpipe()\fR or \s-1UNIX\s0
\&\fBsocketpair()\fR.  Localhost Internet sockets are used for everything
there, including one-way pipes.
.PP
For one-way pipes, the unused socket directions are shut down to avoid
sending data the wrong way through them.  Use \fBsocketpairly()\fR instead.
.SH "BUGS"
.IX Header "BUGS"
The functions implemented here die outright upon failure, requiring
eval{} around their calls.
.PP
The following conduit types are currently unsupported because nobody
has needed them so far.  Please submit a request (and/or a patch) if
any of these is needed:
.PP
.Vb 4
\&  UNIX socket()
\&  INET\-domain socketpair()
\&  IPv4\-specific localhost sockets
\&  IPv6\-specific localhost sockets
.Ve
.SH "AUTHOR & COPYRIGHT"
.IX Header "AUTHOR & COPYRIGHT"
IO::Pipely is copyright 2000\-2013 by Rocco Caputo.
All rights reserved.
IO::Pipely is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
.SH "HISTORY"
.IX Header "HISTORY"
IO::Pipely is a spin-off of the \s-1POE\s0 project's portable pipes.
Earlier versions of the code have been tested and used in production
systems for over a decade.
