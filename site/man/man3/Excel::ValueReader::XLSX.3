.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Excel::ValueReader::XLSX 3"
.TH Excel::ValueReader::XLSX 3 "2020-08-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Excel::ValueReader::XLSX \- extracting values from Excel workbooks in XLSX format, fast
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  my $reader = Excel::ValueReader::XLSX\->new(xlsx => $filename);
\&  # .. or with syntactic sugar :
\&  my $reader = Excel::ValueReader::XLSX\->new($filename);
\&  # .. or with LibXML backend :
\&  my $reader = Excel::ValueReader::XLSX\->new(xlsx => $filename,
\&                                             using => \*(AqLibXML\*(Aq);
\&  
\&  foreach my $sheet_name ($reader\->sheet_names) {
\&     my $grid = $reader\->values($sheet_name);
\&     my $n_rows = @$grid;
\&     print "sheet $sheet_name has $n_rows rows; ",
\&           "first cell contains : ", $grid\->[0][0];
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module reads the contents of an Excel file in \s-1XLSX\s0 format;
given a worksheet name it returns a bidimensional array of values
in that worksheet.
.PP
Unlike Spreadsheet::ParseXLSX or Spreadsheet::XLSX, there is no
support for reading formulas, formats or other Excel internal
information; all you get are plain values \*(-- but you get them much
faster !
.PP
This front module has two different backends for extracting values :
.IP "Regex (default)" 4
.IX Item "Regex (default)"
this backend uses regular expressions to parse the \s-1XML\s0 content.
.IP "LibXML" 4
.IX Item "LibXML"
this backend uses XML::LibXML::Reader to parse the \s-1XML\s0 content.
It is probably safer but about three times slower than the Regex backend
(but still much faster than Spreadsheet::ParseXLSX).
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&  my $reader = Excel::ValueReader::XLSX\->new(xlsx  => $filename,
\&                                             using => $backend);
.Ve
.PP
The \f(CW\*(C`xlsx\*(C'\fR argument is mandatory and points to the \f(CW\*(C`.xlsx\*(C'\fR file to be parsed.
The \f(CW\*(C`using\*(C'\fR argument is optional; it specifies the backend to be used for parsing; 
default is 'Regex'.
.PP
As syntactic sugar, a shorter form is admitted :
.PP
.Vb 1
\&  my $reader = Excel::ValueReader::XLSX\->new($filename);
.Ve
.SS "sheet_names"
.IX Subsection "sheet_names"
.Vb 1
\&  my @sheets = $reader\->sheet_names;
.Ve
.PP
Returns the list of worksheet names, in the same order as in the Excel file.
.SS "values"
.IX Subsection "values"
.Vb 1
\&  my $grid = $reader\->values($sheet);
.Ve
.PP
Returns a bidimensional array of scalars, corresponding to cell
values in the specified worksheet. The \f(CW$sheet\fR argument can be either
a sheet name or a sheet position (starting at 1).
.PP
Unlike the original Excel cells, positions in the grid are zero-based,
so for example the content of cell B3 is in \f(CW\*(C`$grid\->[1][2]\*(C'\fR.
The grid is sparse : the size of each row depends on the
position of the last non-empty cell in that row.
Thanks to Perl's auto-vivification mechanism, any attempt to access
a non-existent cell will automatically create the corresponding cell
within the grid. The number of rows and columns in the grid can be computed
like this :
.PP
.Vb 2
\&  my $nb_rows = @$grid;
\&  my $nb_cols = max map {scalar @$_} @$grid; # must import List::Util::max
.Ve
.SH "CAVEAT"
.IX Header "CAVEAT"
This module was optimized for speed, not for completeness of
OOXML-SpreadsheetML support; so there may be some edge cases where the
output is incorrect with respect to the original Excel data.
.PP
Excel dates are stored internally as numbers, so they will appear as
numbers in the output. To convert numbers to dates, use the
DateTime::Format::Excel module. Unfortunately the module has
currently no support for identifying which cells contain dates; this
would require to parse cell formats \*(-- maybe this will be implemented
in a future release.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The official reference for OOXML-SpreadsheetML format is in
<https://www.ecma\-international.org/publications/standards/Ecma\-376.htm>.
.PP
Introductory material on \s-1XLSX\s0 file structure can be found at
<http://officeopenxml.com/anatomyofOOXML\-xlsx.php>.
.PP
The \s-1CPAN\s0 module Data::XLSX::Parser is claimed to be in alpha stage;
it seems to be working but the documentation is insufficient \*(-- I had 
to inspect the test suite to understand how to use it.
.PP
Another unpublished but working module for parsing Excel files in Perl
can be found at <https://github.com/jmcnamara/excel\-reader\-xlsx>.
Some test cases were borrowed from that distribution.
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Below are some benchmarks computed with the program \f(CW\*(C`benchmark.pl\*(C'\fR in
this distribution. The task was to parse an Excel file of five worksheets
with about 62600 rows in total, and report the number of rows per sheet.
Reported figures are in seconds.
.PP
.Vb 5
\&  Excel::ValueReader::XLSX::Regex    11 elapsed,  10 cpu, 0 system
\&  Excel::ValueReader::XLSX::LibXML   35 elapsed,  34 cpu, 0 system
\&  [unpublished] Excel::Reader::XLSX  39 elapsed,  37 cpu, 0 system
\&  Spreadsheet::ParseXLSX            244 elapsed, 240 cpu, 1 system
\&  Data::XLSX::Parser                 37 elapsed,  35 cpu, 0 system
.Ve
.PP
These figures show that the regex version is about 3 times faster
than the LibXML version, and about 22 times faster than
Spreadsheet::ParseXLSX. Tests with a bigger file of about 90000 rows
showed similar ratios.
.PP
Modules
\&\f(CW\*(C`Excel::Reader::XLSX\*(C'\fR (unpublished) and Data::XLSX::Parser
are based on XML::LibXML like Excel::ValueReader::XLSX::LibXML;
execution times for those three modules are very close.
.SH "AUTHOR"
.IX Header "AUTHOR"
Laurent Dami, <dami at cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2020 by Laurent Dami.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
