.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Dispatch::Configurator::Any 3"
.TH Log::Dispatch::Configurator::Any 3 "2012-09-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatch::Configurator::Any \- Configurator implementation with Config::Any
.SH "VERSION"
.IX Header "VERSION"
version 1.122640
.SH "PURPOSE"
.IX Header "PURPOSE"
Use this module in combination with Log::Dispatch::Config to allow many
formats of configuration file to be loaded, via the Config::Any module.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In the traditional Log::Dispatch::Config way:
.PP
.Vb 2
\& use Log::Dispatch::Config; # loads Log::Dispatch
\& use Log::Dispatch::Configurator::Any;
\&  
\& my $config = Log::Dispatch::Configurator::Any\->new(\*(Aqlog.yml\*(Aq);
\& Log::Dispatch::Config\->configure($config);
\&  
\& # nearby piece of code
\& my $log = Log::Dispatch::Config\->instance;
\& $log\->alert(\*(AqHello, world!\*(Aq);
.Ve
.PP
Alternatively, without a config file on disk:
.PP
.Vb 2
\& use Log::Dispatch::Config; # loads Log::Dispatch
\& use Log::Dispatch::Configurator::Any;
\&  
\& my $confhash = {
\&     dispatchers => [\*(Aqscreen]\*(Aq,
\&     screen = {
\&         class => \*(AqLog::Dispatch::Screen\*(Aq,
\&         min_level => \*(Aqdebug\*(Aq,
\&     },
\& };
\&  
\& my $config = Log::Dispatch::Configurator::Any\->new($confhash);
\& Log::Dispatch::Config\->configure($config);
\&  
\& # nearby piece of code
\& my $log = Log::Dispatch::Config\->instance;
\& $log\->alert(\*(AqHello, world!\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Log::Dispatch::Config is a wrapper for Log::Dispatch and provides a way
to configure Log::Dispatch objects with configuration files. Somewhat like a
lite version of log4j and Log::Log4perl it allows multiple log
destinations. The standard configuration file format for Log::Dispatch::Config
is AppConfig.
.PP
This module plugs in to Log::Dispatch::Config and allows the use of other file
formats, in fact any format supported by the Config::Any module. As a bonus
you can also pass in a configuration data structure instead of a file name.
.SH "USAGE"
.IX Header "USAGE"
Follow the examples in the \*(L"\s-1SYNOPSIS\*(R"\s0. If you are using an external
configuration file, be aware that you are required to use a filename extension
(e.g.  \f(CW\*(C`.yml\*(C'\fR for \s-1YAML\s0).
.PP
Below are a couple of tips and tricks you may find useful.
.SS "Fall-back default config"
.IX Subsection "Fall-back default config"
Being able to use a configuration data structre instead of a file on disk is
handy when you want to provide application defaults which the user then
replaces with their own settings. For example you could have the following:
.PP
.Vb 7
\& my $defaults = {
\&     dispatchers => [\*(Aqscreen\*(Aq],
\&     screen => {
\&         class     => \*(AqLog::Dispatch::Screen\*(Aq,
\&         min_level => \*(Aqdebug\*(Aq,
\&     },
\& };
\&  
\& my $config_file = \*(Aq/etc/myapp_logging.conf\*(Aq;
\& my $config = $ENV{MYAPP_LOGGING_CONFIG} || $ARGV[0] ||
\&     ( \-e $config_file ? $config_file : $defaults);
\& 
\& Log::Dispatch::Config\->configure_and_watch(
\&     Log::Dispatch::Configurator::Any\->new($config) );
\& my $dispatcher = Log::Dispatch::Config\->instance;
.Ve
.PP
With the above code, your application will check for a filename in an
environment variable, then a filename as a command line argument, then check
for a file on disk, and finally use its built-in defaults.
.ie n .SS "Dealing with a ""dispatchers"" list"
.el .SS "Dealing with a \f(CWdispatchers\fP list"
.IX Subsection "Dealing with a dispatchers list"
Log::Dispatch::Config requires that a global setting \f(CW\*(C`dispatchers\*(C'\fR have a
list value (i.e. your list of dispatchers). A few config file formats do not
support list values at all, or list values at the global level (two examples
being Config::Tiny and Config::General).
.PP
This module allows you to have a small grace when there is only one dispatcher
in use. Write the configuration file normally, and the single-item
\&\f(CW\*(C`dispatchers\*(C'\fR value will automatically be promoted to a list. In other words:
.PP
.Vb 2
\& # myapp.ini
\& dispatchers = screen
\& 
\& # this becomes a config of:
\& $config = { dispatchers => \*(Aqscreen\*(Aq, ... };
\& 
\& # so this module promotes it to:
\& $config = { dispatchers => [\*(Aqscreen\*(Aq], ... };
.Ve
.PP
If you want more than one dispatcher, you then need to use a config file
format which supports these lists natively, I'm afraid. A good suggestion
might be \s-1YAML.\s0
.SH "THANKS"
.IX Header "THANKS"
My thanks to \f(CW\*(C`miyagawa\*(C'\fR for writing Log::Dispatch::Config, from where I also took
some tests. Also thanks to Florian Merges for his \s-1YAML\s0 Configurator, which was
a useful example and saved me much time.
.SH "AUTHOR"
.IX Header "AUTHOR"
Oliver Gorwits <oliver@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by University of Oxford.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
