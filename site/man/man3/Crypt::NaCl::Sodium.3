.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium 3"
.TH Crypt::NaCl::Sodium 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium \- NaCl compatible modern, easy\-to\-use library for  encryption, decryption, signatures, password hashing and more
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto = Crypt::NaCl::Sodium\->new();
\&
\&    ##########################
\&    ## Secret\-key cryptography
\&
\&    # Secret\-key authenticated encryption (XSalsa20/Poly1305 MAC)
\&    my $crypto_secretbox = $crypto\->secretbox();
\&
\&    # Secret\-key message authentication (HMAC\-SHA256, HMAC\-SHA512, HMAC\-SHA512/256 )
\&    my $crypto_auth = $crypto\->auth();
\&
\&    # Authenticated Encryption with Additional Data (ChaCha20/Poly1305 MAC, AES256\-GCM)
\&    my $crypto_aead = $crypto\->aead();
\&
\&    ##########################
\&    ## Public\-key cryptography
\&
\&    # Public\-key authenticated encryption (Curve25519/XSalsa20/Poly1305 MAC)
\&    my $crypto_box = $crypto\->box();
\&
\&    # Public\-key signatures (Ed25519)
\&    my $crypto_sign = $crypto\->sign();
\&
\&    ##########################
\&    ## Hashing
\&
\&    # Generic hashing (Blake2b)
\&    my $crypto_generichash = $crypto\->generichash();
\&
\&    # Short\-input hashing (SipHash\-2\-4)
\&    my $crypto_shorthash = $crypto\->shorthash();
\&
\&    ##########################
\&    ## Password hashing (yescrypt)
\&
\&    my $crypto_pwhash = $crypto\->pwhash();
\&
\&    ##########################
\&    ## Advanced
\&
\&    # SHA\-2 (SHA\-256, SHA\-512)
\&    my $crypto_hash = $crypto\->hash();
\&
\&    # One\-time authentication (Poly1305)
\&    my $crypto_onetimeauth = $crypto\->onetimeauth();
\&
\&    # Diffie\-Hellman (Curve25519)
\&    my $crypto_scalarmult = $crypto\->scalarmult();
\&
\&    # Stream ciphers (XSalsa20, ChaCha20, Salsa20, AES\-128\-CTR)
\&    my $crypto_stream = $crypto\->stream();
\&
\&    ##########################
\&    ## Utilities
\&
\&    # convert binary data to hexadecimal
\&    my $hex = bin2hex($bin);
\&
\&    # convert hexadecimal to binary
\&    my $bin = hex2bin($hex);
\&
\&    # constant time comparision of strings
\&    memcmp($a, $b, $length ) or die \*(Aq$a ne $b\*(Aq;
\&
\&    # constant time comparision of large numbers
\&    compare($x, $y, $length ) == \-1 and print \*(Aq$x < $y\*(Aq;
\&
\&    # overwrite with null bytes
\&    memzero($a, $b, ...);
\&
\&    # generate random number
\&    my $num = random_number($upper_bound);
\&
\&    # generate random bytes
\&    my $bytes = random_bytes($count);
\&
\&    ##########################
\&    ## Guarded data storage
\&
\&    my $locker = Data::BytesLocker\->new($password);
\&    ...
\&    $locker\->unlock();
\&    print $locker\->to_hex();
\&    $locker\->lock();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::NaCl::Sodium provides bindings to libsodium \- NaCl compatible modern,
easy-to-use library for  encryption, decryption, signatures, password hashing
and more.
.PP
It is a portable, cross-compilable, installable, packageable fork
of NaCl <http://nacl.cr.yp.to/>, with a compatible \s-1API,\s0 and an extended \s-1API\s0 to
improve usability even further.
.PP
Its goal is to provide all of the core operations needed to build
higher-level cryptographic tools.
.PP
The design choices emphasize security, and \*(L"magic constants\*(R" have
clear rationales.
.PP
And despite the emphasis on high security, primitives are faster
across-the-board than most implementations of the \s-1NIST\s0
standards.
.PP
Crypt::NaCl::Sodium uses Alien::Sodium that tracks the most current
releases of libsodium.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $crypto = Crypt::NaCl::Sodium\->new();
.Ve
.PP
Returns a proxy object for methods provided below.
.SS "secretbox"
.IX Subsection "secretbox"
.Vb 2
\&    # Secret\-key authenticated encryption (XSalsa20/Poly1305 MAC)
\&    my $crypto_secretbox = Crypt::NaCl::Sodium\->secretbox();
.Ve
.PP
Read Crypt::NaCl::Sodium::secretbox for more details.
.SS "auth"
.IX Subsection "auth"
.Vb 2
\&    # Secret\-key authentication (HMAC\-SHA512/256 and advanced usage of HMAC\-SHA\-2)
\&    my $crypto_auth = Crypt::NaCl::Sodium\->auth();
.Ve
.PP
Read Crypt::NaCl::Sodium::auth for more details.
.SS "aead"
.IX Subsection "aead"
.Vb 2
\&    # Authenticated Encryption with Additional Data (ChaCha20/Poly1305 MAC, AES256\-GCM)
\&    my $crypto_aead = Crypt::NaCl::Sodium\->aead();
.Ve
.PP
Read Crypt::NaCl::Sodium::aead for more details.
.SS "box"
.IX Subsection "box"
.Vb 2
\&    # Public\-key authenticated encryption (Curve25519/XSalsa20/Poly1305 MAC)
\&    my $crypto_box = Crypt::NaCl::Sodium\->box();
.Ve
.PP
Read Crypt::NaCl::Sodium::box for more details.
.SS "sign"
.IX Subsection "sign"
.Vb 2
\&    # Public\-key signatures (Ed25519)
\&    my $crypto_sign = Crypt::NaCl::Sodium\->sign();
.Ve
.PP
Read Crypt::NaCl::Sodium::sign for more details.
.SS "generichash"
.IX Subsection "generichash"
.Vb 2
\&    # Generic hashing (Blake2b)
\&    my $crypto_generichash = Crypt::NaCl::Sodium\->generichash();
.Ve
.PP
Read Crypt::NaCl::Sodium::generichash for more details.
.SS "shorthash"
.IX Subsection "shorthash"
.Vb 2
\&    # Short\-input hashing (SipHash\-2\-4)
\&    my $crypto_shorthash = Crypt::NaCl::Sodium\->shorthash();
.Ve
.PP
Read Crypt::NaCl::Sodium::shorthash for more details.
.SS "pwhash"
.IX Subsection "pwhash"
.Vb 2
\&    # Password hashing (yescrypt)
\&    my $crypto_pwhash = Crypt::NaCl::Sodium\->pwhash();
.Ve
.PP
Read Crypt::NaCl::Sodium::pwhash for more details.
.SS "hash"
.IX Subsection "hash"
.Vb 2
\&    # SHA\-2 (SHA\-256, SHA\-512)
\&    my $crypto_hash = Crypt::NaCl::Sodium\->hash();
.Ve
.PP
Read Crypt::NaCl::Sodium::hash for more details.
.SS "onetimeauth"
.IX Subsection "onetimeauth"
.Vb 2
\&    # One\-time authentication (Poly1305)
\&    my $crypto_onetimeauth = Crypt::NaCl::Sodium\->onetimeauth();
.Ve
.PP
Read Crypt::NaCl::Sodium::onetimeauth for more details.
.SS "scalarmult"
.IX Subsection "scalarmult"
.Vb 2
\&    # Diffie\-Hellman (Curve25519)
\&    my $crypto_scalarmult = Crypt::NaCl::Sodium\->scalarmult();
.Ve
.PP
Read Crypt::NaCl::Sodium::scalarmult for more details.
.SS "stream"
.IX Subsection "stream"
.Vb 2
\&    # Stream ciphers (XSalsa20, ChaCha20, Salsa20, AES\-128\-CTR)
\&    my $crypto_stream = Crypt::NaCl::Sodium\->stream();
.Ve
.PP
Read Crypt::NaCl::Sodium::stream for more details.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw(:utils);
.Ve
.PP
Imports all provided functions.
.SS "bin2hex"
.IX Subsection "bin2hex"
.Vb 1
\&    my $hex = bin2hex($bin);
.Ve
.PP
Returns converted \f(CW$bin\fR into a hexadecimal string.
.SS "hex2bin"
.IX Subsection "hex2bin"
.Vb 3
\&    my $hex = "41 : 42 : 43";
\&    my $bin = hex2bin($hex, ignore => ": ", max_len => 2 );
\&    print $bin; # AB
.Ve
.PP
Parses a hexadecimal string \f(CW$hex\fR and converts it to a byte sequence.
.PP
Optional arguments:
.IP "\(bu" 4
ignore
.Sp
A string of characters to skip. For example, the string \f(CW": "\fR allows columns
and spaces to be present at any locations in the hexadecimal string. These
characters will just be ignored.
.Sp
If unset any non-hexadecimal characters are disallowed.
.IP "\(bu" 4
max_len
.Sp
The maximum number of bytes to return.
.PP
The parser stops when a non-hexadecimal, non-ignored character is
found or when \f(CW\*(C`max_len\*(C'\fR bytes have been written.
.SS "memcmp"
.IX Subsection "memcmp"
.Vb 1
\&    memcmp($a, $b, $length ) or die "\e$a ne \e$b for length: $length";
.Ve
.PP
Compares strings in constant-time. Returns true if they match, false otherwise.
.PP
The argument \f(CW$length\fR is optional if variables are of the same length. Otherwise it is
required and cannot be greater then the length of the shorter of compared variables.
.PP
\&\fB\s-1NOTE:\s0\fR \*(L"memcmp\*(R" in Data::BytesLocker provides the same functionality.
.PP
.Vb 1
\&    $locker\->memcmp($b, $length) or die "\e$locker ne \e$b for length: $length";
.Ve
.SS "compare"
.IX Subsection "compare"
.Vb 1
\&    compare($x, $y, $length ) == \-1 and print \*(Aq$x < $y\*(Aq;
.Ve
.PP
A constant-time version of \*(L"memcmp\*(R", useful to compare nonces and counters
in little-endian format, that plays well with \*(L"increment\*(R".
.PP
Returns \f(CW\*(C`\-1\*(C'\fR if \f(CW$x\fR is lower then \f(CW$y\fR, \f(CW0\fR if \f(CW$x\fR and \f(CW$y\fR are
identical, or \f(CW1\fR if \f(CW$x\fR is greater then \f(CW$y\fR. Both \f(CW$x\fR and \f(CW$y\fR are
assumed to be numbers encoded in little-endian format.
.PP
The argument \f(CW$length\fR is optional if variables are of the same length. Otherwise it is
required and cannot be greater then the length of the shorter of compared variables.
.PP
\&\fB\s-1NOTE:\s0\fR \*(L"compare\*(R" in Data::BytesLocker provides the same functionality.
.PP
.Vb 1
\&    $locker\->compare($y, $length) == \-1 and print "\e$locker < \e$y for length: $length";
.Ve
.SS "memzero"
.IX Subsection "memzero"
.Vb 1
\&    memzero($a, $b, ...);
.Ve
.PP
Replaces the value of the provided stringified variables with \f(CW\*(C`null\*(C'\fR bytes. Length of the
zeroed variables is unchanged.
.SS "random_number"
.IX Subsection "random_number"
.Vb 1
\&    my $num = random_number($upper_bound);
.Ve
.PP
Returns an unpredictable number between 0 and optional \f(CW$upper_bound\fR
(excluded).
If \f(CW$upper_bound\fR is not specified the maximum value is \f(CW0xffffffff\fR
(included).
.SS "increment"
.IX Subsection "increment"
.Vb 1
\&    increment($nonce, ...);
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR This function is deprecated and will be removed in next version. Please
use \*(L"increment\*(R" in Data::BytesLocker.
.PP
Increments an arbitrary long unsigned number(s) (in place). Function runs in constant-time
for a given length of arguments and considers them to be encoded in
little-endian format.
.SS "random_bytes"
.IX Subsection "random_bytes"
.Vb 1
\&    my $bytes = random_bytes($num_of_bytes);
.Ve
.PP
Generates unpredictable sequence of \f(CW$num_of_bytes\fR bytes.
.PP
The length of the \f(CW$bytes\fR equals the value of \f(CW$num_of_bytes\fR.
.PP
Returns Data::BytesLocker object.
.SH "VARIABLES"
.IX Header "VARIABLES"
.ie n .SS "$Data::BytesLocker::DEFAULT_LOCKED"
.el .SS "\f(CW$Data::BytesLocker::DEFAULT_LOCKED\fP"
.IX Subsection "$Data::BytesLocker::DEFAULT_LOCKED"
.Vb 2
\&    use Crypt::NaCl::Sodium;
\&    $Data::BytesLocker::DEFAULT_LOCKED = 1;
.Ve
.PP
By default all values returned from the provided methods are
unlocked Data::BytesLocker objects. If this variable is set to true then
the returned objects are locked and require calling
\&\*(L"unlock\*(R" in Data::BytesLocker before accessing.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Crypt::NaCl::Sodium::secretbox \- Secret-key authenticated encryption (XSalsa20/Poly1305 \s-1MAC\s0)
.IP "\(bu" 4
Crypt::NaCl::Sodium::auth \- Secret-key message authentication (\s-1HMAC\-SHA256, HMAC\-SHA512, HMAC\-SHA512/256\s0 )
.IP "\(bu" 4
Crypt::NaCl::Sodium::aead \- Authenticated Encryption with Additional Data (ChaCha20/Poly1305 \s-1MAC, AES256\-GCM\s0)
.IP "\(bu" 4
Crypt::NaCl::Sodium::box \- Public-key authenticated encryption (Curve25519/XSalsa20/Poly1305 \s-1MAC\s0)
.IP "\(bu" 4
Crypt::NaCl::Sodium::sign \- Public-key signatures (Ed25519)
.IP "\(bu" 4
Crypt::NaCl::Sodium::generichash \- Generic hashing (Blake2b)
.IP "\(bu" 4
Crypt::NaCl::Sodium::shorthash \- Short-input hashing (SipHash\-2\-4)
.IP "\(bu" 4
Crypt::NaCl::Sodium::pwhash \- Password hashing (yescrypt)
.IP "\(bu" 4
Crypt::NaCl::Sodium::hash \- \s-1SHA\-2\s0 (\s-1SHA\-256, SHA\-512\s0)
.IP "\(bu" 4
Crypt::NaCl::Sodium::onetimeauth \- One-time authentication (Poly1305)
.IP "\(bu" 4
Crypt::NaCl::Sodium::scalarmult \- Diffie-Hellman (Curve25519)
.IP "\(bu" 4
Crypt::NaCl::Sodium::stream \- Stream ciphers (XSalsa20, ChaCha20, Salsa20, \s-1AES\-128\-CTR\s0)
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
libsodium <http://jedisct1.gitbooks.io/libsodium> \- libsodium
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
