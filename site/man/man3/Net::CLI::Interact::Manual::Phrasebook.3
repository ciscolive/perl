.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::CLI::Interact::Manual::Phrasebook 3"
.TH Net::CLI::Interact::Manual::Phrasebook 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::CLI::Interact::Manual::Phrasebook \- List of Supported CLIs
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The bundled phrasebook includes support for a variety of network device CLIs.
Many were contributed by users of the module. If you set up a new \s-1CLI\s0
dictionary, please consider contributing it back! The phrasebook specification
is given in Net::CLI::Interact::Phrasebook.
.PP
For each supported \s-1CLI,\s0 there is a name which must be passed in the
\&\f(CW\*(C`personality\*(C'\fR option to Net::CLI::Interact's \f(CW\*(C`new()\*(C'\fR method; this is the
same as the directory containing the phrasebook file.
.PP
After that, you can call the included Macros, and the module will use the
included Prompt to match the current state of the \s-1CLI.\s0 More information is
available in the Tutorial and
Cookbook.
.SH "PERSONALITIES"
.IX Header "PERSONALITIES"
See the files themselves at the following link for full details:
<https://github.com/ollyg/Net\-CLI\-Interact/tree/master/share/phrasebook>.
.IP "\(bu" 4
\&\s-1ASA\s0
.IP "\(bu" 4
Avaya
.IP "\(bu" 4
Bash
.IP "\(bu" 4
CatOS
.IP "\(bu" 4
Cisco (generic)
.IP "\(bu" 4
Csh
.IP "\(bu" 4
ExtremeOS
.IP "\(bu" 4
F5
.IP "\(bu" 4
Fortinet
.IP "\(bu" 4
Foundry / Brocade
.Sp
Before connecting to the device you probably want to set the output separator
to be:
.Sp
.Vb 1
\& $nci\->transport\->ors("\er\en");
.Ve
.Sp
For users of Net::Appliance::Session this should be:
.Sp
.Vb 1
\& $session_obj\->nci\->transport\->ors("\er\en");
.Ve
.IP "\(bu" 4
\&\s-1FWSM\s0
.IP "\(bu" 4
\&\s-1FWSM 3\s0
.IP "\(bu" 4
\&\s-1HP\s0
.IP "\(bu" 4
\&\s-1IOS\s0
.IP "\(bu" 4
JunOS
.IP "\(bu" 4
Mikrotik
.IP "\(bu" 4
Nortel
.IP "\(bu" 4
\&\s-1OVMCLI\s0
.IP "\(bu" 4
\&\s-1PIXOS\s0
.IP "\(bu" 4
\&\s-1PIXOS 7\s0
.IP "\(bu" 4
Qnap
.IP "\(bu" 4
RedBack
.IP "\(bu" 4
ScreenOS
.IP "\(bu" 4
\&\s-1WLC\s0
.IP "\(bu" 4
Zyxel
.SH "SUPPORTING A NEW DEVICE"
.IX Header "SUPPORTING A NEW DEVICE"
In order to support a new device, particularly for the
Net::Appliance::Session module, there is a basic set of prompts and macros
you must create.
.SS "Required Prompts"
.IX Subsection "Required Prompts"
With \s-1SSH,\s0 no \f(CW\*(C`user\*(C'\fR prompt is required, but for other transports you should
include a prompt named \f(CW\*(C`user\*(C'\fR which matches the "\f(CW\*(C`Username:\*(C'\fR" prompt
presented by the device.
.PP
.Vb 3
\& # example only!
\& prompt user
\&     match /[Uu]sername/
.Ve
.PP
With all transports you must provide a \f(CW\*(C`pass\*(C'\fR prompt which matches the
"\f(CW\*(C`password:\*(C'\fR" prompt presented by the device.
.PP
.Vb 3
\& # example only!
\& prompt pass
\&     match /[Pp]assword: ?$/
.Ve
.PP
The last essential prompt is of course a simple command line prompt match, and
this should be named \f(CW\*(C`generic\*(C'\fR.
.PP
.Vb 3
\& # example only!
\& prompt generic
\&     match /> ?$/
.Ve
.SS "Desirable Prompt and Macros"
.IX Subsection "Desirable Prompt and Macros"
To cleanly disconnect from your device session, you might want to include a
macro named \f(CW\*(C`disconnect\*(C'\fR with the relevant command. Note there is no need for
a \f(CW\*(C`match\*(C'\fR statement in this macro, as the device should have detached!
.PP
.Vb 3
\& # example only!
\& macro disconnect
\&     send exit
.Ve
.PP
For paging support, include either only a \f(CW\*(C`prompt\*(C'\fR macro, or two macros named
\&\f(CW\*(C`enable_paging\*(C'\fR and \f(CW\*(C`disable_paging\*(C'\fR, depending on what the device requires.
In all cases, there must be one substitution ("\f(CW%s\fR") which is where the
number of page lines will be inserted into the command.
.PP
.Vb 3
\& # example only!
\& macro paging
\&     send terminal length %s
.Ve
.PP
For privileged mode (super-user) support, include a prompt named \f(CW\*(C`privileged\*(C'\fR
first, and then include macros named \f(CW\*(C`begin_privileged\*(C'\fR and \f(CW\*(C`end_privileged\*(C'\fR
to enter and leave the mode, respectively. Note that both macros will require
explicit match statements, because the prompt encountered \fIafter\fR issuing the
command will be different to that encountered before.
.PP
.Vb 3
\& # example only!
\& prompt privileged
\&     match /# ?$/
\& 
\& macro begin_privileged
\&     send enable
\&     match user or pass or privileged
\& 
\& macro end_privileged
\&     send disable
\&     match generic
.Ve
.PP
Similarly for configure mode, include a prompt named \f(CW\*(C`configure\*(C'\fR first, and
then include macros named \f(CW\*(C`begin_configure\*(C'\fR and \f(CW\*(C`end_configure\*(C'\fR to enter and
leave the mode, respectively. Note that both macros will require explicit
match statements, because the prompt encountered \fIafter\fR issuing the command
will be different to that encountered before.
.PP
.Vb 3
\& # example only!
\& prompt configure
\&     match /\e(config[^)]*\e)# ?$/
\& 
\& macro begin_configure
\&     send configure terminal
\&     match configure
\& 
\& macro end_configure
\&     send exit
\&     match privileged
.Ve
