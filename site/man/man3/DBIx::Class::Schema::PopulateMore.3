.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::PopulateMore 3"
.TH DBIx::Class::Schema::PopulateMore 3 "2014-10-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Schema::PopulateMore \- An enhanced populate method
.SH "VERSION"
.IX Header "VERSION"
Version 0.19
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following is example usage for this component.
.PP
.Vb 2
\&        package Myapp::Schema;
\&        use base qw/DBIx::Class::Schema/;
\&        
\&        _\|_PACKAGE_\|_\->load_components(qw/Schema::PopulateMore/);
\&        _\|_PACKAGE_\|_\->load_namespaces();
\&        
\&        ## All the rest of your setup
.Ve
.PP
Then assuming you have ResultSources of Gender, Person and FriendList:
.PP
.Vb 1
\&        my $setup_rows = [
\&        
\&                {Gender => {
\&                        fields => \*(Aqlabel\*(Aq,
\&                        data => {
\&                                male => \*(Aqmale\*(Aq,
\&                                female => \*(Aqfemale\*(Aq,
\&                        }}},
\&                        
\&                {Person => {
\&                        fields => [\*(Aqname\*(Aq, \*(Aqage\*(Aq, \*(Aqgender\*(Aq],
\&                        data => {
\&                                john => [\*(Aqjohn\*(Aq, 38, "!Index:Gender.male"],
\&                                jane => [\*(Aqjane\*(Aq, 40, \*(Aq!Index:Gender.female\*(Aq],
\&                        }}},
\&                
\&                {FriendList => {
\&                        fields => [\*(Aqperson\*(Aq, \*(Aqfriend\*(Aq, \*(Aqcreated_date\*(Aq],
\&                        data => {
\&                                john_jane => [
\&                                        \*(Aq!Index:Person.john\*(Aq,
\&                                        \*(Aq!Index:Person.jane\*(Aq
\&                                        \*(Aq!Date: March 30, 1996\*(Aq,
\&                                ],
\&                        }}},
\&        ];
\&        
\&        $schema\->populate_more($setup_rows);
.Ve
.PP
Please see the test cases for more detailed examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a DBIx::Class::Schema component that provides an enhanced version
of the builtin method \*(L"populate\*(R" in DBIx::Class::Schema.  What it does is make it 
easier when you are doing a first time setup and need to insert a bunch of 
rows, like the first time you deploy a new database, or after you update it.
.PP
It's not as full featured as DBIx::Class::Fixtures but is targeted more 
directly at making it easier to just take a prewritten perl structure \-\-or one 
loaded from a configuration file\*(-- and setup your database.
.PP
Most of us using DBIx::CLass have written a version of this at one time or
another.  What is special to this component is the fact that unlike the normal
populate method you can insert to multiple result_sources in one go.  While 
doing this, we index the created rows so as to make it easy to reference them
in relationships. I did this because I think it's very ugly to have to type in 
all the primary keys by hand, particularly if your \s-1PK\s0 is multi column, or is
using some lengthy format such as uuid.  Also, we can embed expansion commands
in the row values to do inflation for us.  For example, any value starting with
\&\*(L"!Index:\*(R" will substitute it's value for that of the relating fields in the 
named row.
.PP
This distribution supplies three expansion commands:
.IP "Index" 4
.IX Item "Index"
Use for creating relationships.  This is a string in the form of \*(L"Source.Label\*(R"
where the Source is the name of the result source that you are creating rows in 
and Label is a key name from the key part of the data hash.
.IP "Env" 4
.IX Item "Env"
Get's it's value from \f(CW%ENV\fR.  Typically this will be setup in your shell or at
application runtime.  This is a string in the form of \*(L"!Env:MY_ENV_VAR\*(R"
.IP "Date" 4
.IX Item "Date"
converts it's value to a DateTime object.  Will use a various methods to try
and coerce a string, like \*(L"today\*(R", or \*(L"January 6, 1974\*(R".  Makes it easier to
insert dates into your database without knowing or caring about the expected
format.  For this to work correctly, you need to use the class component
DBIx::Class::InflateColumn::DateTime and mark your column data type as 
\&'datetime' or similar.
.IP "Find" 4
.IX Item "Find"
Used for when you want the value of something that you expect already exists
in the database (but for which you didn't just populatemore for, use 'Index'
for that case.) Use cases for this include lookup style tables, like 'Status'
or 'Gender', 'State', etc. which you may already have installed. This is a
string in the form of '!Find:Source.[key1=val1,key2=val2,...'.
.Sp
If your find doesn't return a single result, expect an error.
.Sp
It's trivial to write more; please feel free to post me your contributions.
.PP
Please note the when inserting rows, we are actually calling \*(L"create_or_update\*(R"
on each data item, so this will not be as fast as using \f(CW$schema\fR\->bulk_insert.
.SH "METHODS"
.IX Header "METHODS"
This module defines the following methods.
.SS "populate_more ($ArrayRef||@Array)"
.IX Subsection "populate_more ($ArrayRef||@Array)"
Given an arrayref formatted as in the \*(L"\s-1SYNOPSIS\*(R"\s0 example, populate a rows in
a database.  Confesses on errors.
.PP
We allow a few different inputs to make it less verbose to use under different
situations, as well as format nicely using your configuration format of choice.
.PP
The \f(CW$ArrayRef\fR contains one or more elements in the following pattern;
.PP
.Vb 12
\&        $schema\->populate_more([
\&                {Source1 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                }}},
\&                {Source2 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                }}},
\&        ]);
.Ve
.PP
The \f(CW@Array\fR version can be one of the following:
.PP
.Vb 10
\&        ## Option One
\&        $schema\->populate_more(
\&                {Source1 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                }}},
\&                {Source2 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                }}},
\&        );
\&
\&        ## Option Two
\&        $schema\->populate_more(
\&                Source1 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                        }
\&                },
\&                Source2 => {
\&                        fields => [qw/ column belongs_to has_many/],
\&                        data => {
\&                                key_1 => [\*(Aqvalue\*(Aq, $row, \e@rows ],
\&                        }
\&                },
\&        );
.Ve
.PP
The last option is probably your choice if you are building a Perl structure
directly, since it's the least verbose.
.PP
\&'SourceX' is the name of a \s-1DBIC\s0 source (as in \f(CW$schema\fR\->resultset($Source)\->...)
while fields is an arrayref of either columns or named relationships and data
is a hashref of rows that you will insert into the Source.
.PP
See \*(L"\s-1SYNOPSIS\*(R"\s0 for more.
.SH "ARGUMENT NOTES"
.IX Header "ARGUMENT NOTES"
The perl structure used in \*(L"populate_more\*(R" was designed to be reasonable
friendly to type in most of the popular configuration formats.  For example,
the above serialized to \s-1YAML\s0 would look like:
.PP
.Vb 10
\&        \- Gender:
\&                fields: label   
\&                data:
\&                  female: female
\&                  male: male
\&        \- Person:
\&                fields:
\&                  \- name
\&                  \- age
\&                  \- gender
\&                data:
\&                  jane:
\&                        \- jane
\&                        \- 40
\&                        \- \*(Aq!Index:Gender.female\*(Aq
\&                  john:
\&                        \- john
\&                        \- 38
\&                        \- !Index:Gender.male\*(Aq
\&        \- FriendList:
\&                fields:
\&                  \- person
\&                  \- friend      
\&                  \- created_date
\&                data:
\&                  john_jane:
\&                        \- \*(Aq!Index:Person.john\*(Aq
\&                        \- \*(Aq!Index:Person.jane\*(Aq
\&                        \- \*(Aq!Date: March 30, 1996\*(Aq
.Ve
.PP
Since the argument is an arrayref or an array, the same base result source can 
appear as many times as you like.  This could be useful when a second insert 
to a given source requires completion of other inserts.  The insert order 
follows the index of the arrayref you create.
.SH "AUTHOR"
.IX Header "AUTHOR"
John Napiorkowski, \f(CW\*(C`<jjnapiork@cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to:
.PP
.Vb 1
\&        C<bug\-DBIx\-Class\-Schema\-PopulateMore at rt.cpan.org>
.Ve
.PP
or through the web interface at:
.PP
.Vb 1
\&        L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DBIx\-Class\-Schema\-PopulateMore>
.Ve
.PP
I will be notified, and then you'll automatically be notified of progress on 
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBIx::Class::Schema::PopulateMore
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=DBIx\-Class\-Schema\-PopulateMore>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBIx\-Class\-Schema\-PopulateMore>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBIx\-Class\-Schema\-PopulateMore>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBIx\-Class\-Schema\-PopulateMore>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to the entire DBIx::Class team for providing such a useful and 
extensible \s-1ORM.\s0  Also thanks to the Moose developers for making it fun and
easy to write beautiful Perl.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2011, John Napiorkowski
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
