.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Array::Each::Tutorial 3"
.TH Array::Each::Tutorial 3 "2013-01-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Array::Each::Tutorial \- POD giving various examples how to use
Array::Each.
.SH "VERSION"
.IX Header "VERSION"
This document refers to version 0.02 of Array::Each.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& man Array::Each
\& man Array::Each::Tutorial
.Ve
.PP
or
.PP
.Vb 2
\& perldoc Array::Each
\& perldoc Array::Each::Tutorial
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
This tutorial contains only \s-1POD,\s0 so don't do this:
.PP
.Vb 1
\& use Array::Each::Tutorial;  # don\*(Aqt do this
.Ve
.PP
Rather, simply read the \s-1POD\s0 (as you are doing).  But first, please
read the docs for Array::Each, because the whole scoop is there.
.PP
This tutorial is intended to augment those docs with examples
showing situations where you might want to use Array::Each instead
of other techniques.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Parallel Arrays vs. Using a Hash"
.IX Subsection "Parallel Arrays vs. Using a Hash"
First of all, use a hash.  It's almost always the best solution if
you want to associate a \*(L"key\*(R" with a \*(L"value\*(R".  And there are modules
available that will let you do wonderful things with hashes, like
keeping the keys sorted or keeping them in the order they were
added.
.PP
So given a hash, you might at some point want to do this:
.PP
.Vb 4
\& my %h = ( a=>1, b=>2, c=>3, d=>4, e=>5 );
\& while( my( $k, $v ) = each %h ) {
\&     # ... do something with $k and $v ...
\& }
.Ve
.PP
On the other hand, if parallel arrays better implement your algorithm,
then you may find you want to do something like this:
.PP
.Vb 6
\& my @k = qw( a b c d e );
\& my @v = qw( 1 2 3 4 5 );
\& for my $i ( 0 .. $#k ) {
\&     my( $k, $v ) = ( $k[$i], $v[$i] );
\&     # ... do something with $k and $v (and maybe $i) ...
\& }
.Ve
.PP
Using Array::Each, you could do the same thing this way:
.PP
.Vb 7
\& use Array::Each;
\& my @k = qw( a b c d e );
\& my @v = qw( 1 2 3 4 5 );
\& my $obj = Array::Each\->new( \e@k, \e@v );
\& while( my( $k, $v, $i ) = $obj\->each ) {
\&     # ... do something with $k and $v (and maybe $i) ...
\& }
.Ve
.PP
If you don't need \f(CW$i\fR at all, you can leave it out, e.g.,
.PP
.Vb 3
\& while( my( $k, $v ) = $obj\->each ) {
\&     # ... do something with $k and $v ...
\& }
.Ve
.PP
If you have more than two parallel arrays, include them all in the
call to \fBnew()\fR and add as many \*(L"capture\*(R" variables as you need,
e.g.,
.PP
.Vb 7
\& my @k = qw( a b c d e );
\& my @v = qw( 1 2 3 4 5 );
\& my @p = qw( \- + ~ = : );
\& my $obj = Array::Each\->new( \e@k, \e@v, \e@p );
\& while( my( $k, $v, $p, $i ) = $obj\->each ) {
\&     # ... do something with $k, $v, and $p (and maybe $i) ...
\& }
.Ve
.SS "One Array vs. Using a Hash"
.IX Subsection "One Array vs. Using a Hash"
If you find that you can solve your problem with one array that
holds pairs of data (or triplets, or quadruplets ...), you could
do the following.  Note that we're passing the \fBset=>\fR, and
\&\fBgroup=>\fR named parameters to \fBnew()\fR.
.PP
.Vb 8
\& # pairs
\& my @a = ( a=>1, b=>2, c=>3, d=>4, e=>5 );
\& my $hash_like = Array::Each\->new( set=>[\e@a], group=>2 );
\& while( my( $k, $v, $i ) = $hash_like\->each ) {
\&     # ... do something with $k and $v ...
\&     # note that $i is successively, 0, 2, 4, 6, 8
\&     # (but see count below)
\& }
\&
\& # triplets
\& my @a = ( a=>1,\*(Aq\-\*(Aq, b=>2,\*(Aq+\*(Aq, c=>3,\*(Aq~\*(Aq, d=>4,\*(Aq=\*(Aq, e=>5,\*(Aq:\*(Aq );
\& my $tre = Array::Each\->new( set=>[\e@a], group=>3 );
\& while( my( $k, $v, $p, $i ) = $tre\->each ) {
\&     # ... do something with $k, $v, and $p ...
\&     # note that $i is successively, 0, 3, 6, 9, 12
\&     # (but see count below)
\& }
.Ve
.SS "Groups of Elements from an Array"
.IX Subsection "Groups of Elements from an Array"
Of course, you don't have to have a \*(L"hash-like\*(R" situation to want
to iterate over multiple elements.  For example, if you want to
list elements five at a time, following are two options using
splice:
.PP
.Vb 5
\& # destructive    
\& my @n = ( 1..100 );
\& while( my @a = splice( @n, 0, 5 ) ) {
\&     # ... do something with @a ...
\& }
\&
\& # non\-destructive    
\& my @n = ( 1..100 );
\& my @n2 = @n;  # sacrificial copy
\& while( my @a = splice( @n2, 0, 5 ) ) {
\&     # ... do something with @a ...
\& }
.Ve
.PP
With Array::Each (also non-destructive):
.PP
.Vb 6
\& my @n = ( 1..100 );
\& my $obj = Array::Each\->new( set=>[\e@n], group=>5 );
\& while( my @a = $obj\->each ) {
\&     my $i = pop @a;  # because each returns index, too
\&     # ... do something with @a ...
\& }
.Ve
.PP
Benchmarks show this to be considerably slower than using splice.
However, if making a sacrificial copy is untenable, e.g., if you
have a very large and/or tied array, then Array::Each may fit the
bill better.
.SH "SOME ATTRIBUTE COMBINATIONS"
.IX Header "SOME ATTRIBUTE COMBINATIONS"
This section shows how some attribute combinations will affect what
\&\fBeach()\fR returns.
.SS "Iterator and Rewind"
.IX Subsection "Iterator and Rewind"
Setting \f(CW\*(C`iterator\*(C'\fR will determine the starting point of the very
next iteration.  Setting \f(CW\*(C`rewind\*(C'\fR will determine where the \fBrewind()\fR
method (and internal rewind operations) will rewind to.  Setting
them both to the same value will cause successive iterations to
start at the same place as the first one.
.PP
In the following hypothetical situation, the first array element
has a special meaning, while the remaining ones are meaningful
pairs.  So we want to skip the first element when we print out the
pairs by setting both \f(CW\*(C`iterator\*(C'\fR and \f(CW\*(C`rewind\*(C'\fR to 1.
.PP
.Vb 12
\& my @a = ( [d=>4], a=>1, b=>2, c=>3, d=>4 );
\& my $obj = Array::Each\->new( set=>[\e@a],
\&     iterator=>1, rewind=>1, group=>2 );
\& # iterator affects where this starts
\& while( my( $k, $v ) = $obj\->each ) {
\&     print "$k => $v\en";
\& }
\& push @a, @{$a[0]} = ( e=>5 );
\& # rewind affects where this starts
\& while( my( $k, $v ) = $obj\->each ) {
\&     print "$k => $v\en";
\& }
.Ve
.SS "Group and Undef"
.IX Subsection "Group and Undef"
By default the \f(CW\*(C`bound\*(C'\fR attribute is true.  This means that iterations
will stop when the end of the shortest (or only) array is reached.
.PP
However, if \f(CW\*(C`group\*(C'\fR is set greater than 1, and the size of the
shortest array is not a multiple of the \f(CW\*(C`group\*(C'\fR value, then the
last iteration will \*(L"go beyond\*(R" the end of the shortest array.
When this happens, \fBeach()\fR will return the value of the \f(CW\*(C`undef\*(C'\fR
attribute for the \*(L"missing\*(R" array elements.
.PP
By default, the \f(CW\*(C`undef\*(C'\fR attribute is undefined.  So \fBeach()\fR will
return perl's undef for \*(L"missing\*(R" or \*(L"non-existent\*(R" array elements.
If this is acceptable, there is no need to set the \f(CW\*(C`undef\*(C'\fR attribute.
If not acceptable, setting \f(CW\*(C`undef\*(C'\fR lets you specify what you want.
.PP
The following example shows how you might generate a 3\-column \s-1HTML\s0
table from the contents of an array.  Note, \f(CW\*(C`count\*(C'\fR is being set,
so \fBeach()\fR will return a line count instead of the (in this case
useless) array index.
.PP
.Vb 9
\& my @a = ( \*(Aqa\*(Aq .. \*(Aqm\*(Aq );
\& my $obj = Array::Each\->new( set=>[\e@a],
\&    group=>3, undef=>\*(Aq&nbsp;\*(Aq, count=>1 );
\& print qq{<table border="1">\en};
\& while( my @row = $obj\->each ) {
\&     printf "<tr> <td>%d.</td> ", pop @row;
\&     print map( "<td>$_</td> ", @row ), "</tr>\en";
\& }
\& print "</table>\en";
.Ve
.SS "Bound and Undef"
.IX Subsection "Bound and Undef"
As stated above, \f(CW\*(C`bound\*(C'\fR is true by default.  If you set it to 0
(false), the iterations are no longer bound by the size of the
shortest array.  Instead they are bound by the size of the largest
array (but see \f(CW\*(C`stop\*(C'\fR to change that).
.PP
So if you have more than one array, and they are not the same size,
\&\fBeach()\fR will return the value of \f(CW\*(C`undef\*(C'\fR for the \*(L"missing\*(R" array
elements.  If the default value (perl's undef) is not acceptable,
setting \f(CW\*(C`undef\*(C'\fR lets you choose what you want.
.PP
The following example shows how you might create a text table giving
the sums of elements of three arrays.  Because the arrays are
different sizes, \f(CW\*(C`bound\*(C'\fR is set to 0.  Because we want to add
\&\*(L"missing\*(R" elements to the totals, \f(CW\*(C`undef\*(C'\fR is set to 0.  Again,
\&\f(CW\*(C`count\*(C'\fR is set to give us a line count.
.PP
.Vb 10
\& my @a = ( [ 1..5 ], [ 1..8 ], [ 7..18 ], );
\& my $cols = @a;
\& my $fmt = " %4d." .   " %5d" x $cols . "\en";
\& my $div = \*(Aq \*(Aqx6   . \*(Aq \-\-\-\-\-\*(Aq x $cols . "\en";
\& my $tot = \*(Aq \*(Aqx6   .   " %5d" x $cols . "\en";
\& my @totals;
\& my $obj = Array::Each\->new( set=>[@a],
\&     bound=>0, undef=>0, count=>1 );
\& while( my @row = $obj\->each ) {
\&     my $count = pop @row;
\&     printf $fmt, $count, @row;
\&     @totals = map { $totals[$_] += $row[$_] } ( 0 .. $#row )
\& }
\& print $div;
\& printf $tot, @totals;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Brad Baxter, bbaxter@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2004, Brad Baxter, All rights reserved.  This
module is free software.  It may be used, redistributed and/or
modified under the same terms as Perl itself.
.PP
.Vb 1
\& _\|_\|_\|_\|_\|_\|_\|_\|_\|_
.Ve
