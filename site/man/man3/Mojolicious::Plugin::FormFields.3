.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojolicious::Plugin::FormFields 3"
.TH Mojolicious::Plugin::FormFields 3 "2015-06-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Plugin::FormFields \- Lightweight form builder with validation and filtering
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $self\->plugin(\*(AqFormFields\*(Aq);
\&
\&  # In your controller
\&  sub edit
\&  {
\&      my $self = shift;
\&      my $user = $self\->users\->find($self\->param(\*(Aqid\*(Aq));
\&      $self\->stash(user => $user);
\&  }
\&
\&  sub update
\&  {
\&      my $self = shift;
\&      my $user = $self\->params(\*(Aquser\*(Aq);
\&
\&      $self\->field(\*(Aquser.name\*(Aq)\->is_required;
\&      $self\->field(\*(Aquser.password\*(Aq)\->is_required\->is_equal(\*(Aquser.confirm_password\*(Aq);
\&
\&      if($self\->valid) {
\&          $self\->users\->save($user);
\&          $self\->redirect_to(\*(Aq/profile\*(Aq);
\&          return;
\&      }
\&
\&      $self\->stash(user => $user);
\&  }
\&
\&  # In your view
\&  field(\*(Aquser.name\*(Aq)\->text
\&  field(\*(Aquser.name\*(Aq)\->error unless field(\*(Aquser.name\*(Aq)\->valid
\&
\&  field(\*(Aquser.password\*(Aq)\->password
\&  field(\*(Aquser.age\*(Aq)\->select([10,20,30])
\&  field(\*(Aquser.password\*(Aq)\->password
\&  field(\*(Aquser.taste\*(Aq)\->radio(\*(Aqme_gusta\*(Aq)
\&  field(\*(Aquser.taste\*(Aq)\->radio(\*(Aqestoy_harto_de\*(Aq)
\&  field(\*(Aquser.orders.0.id\*(Aq)\->hidden
\&
\&  # Fields for a collection
\&  my $kinfolk = field(\*(Aquser.kinfolk\*(Aq);
\&  for my $person (@$kinfolk) {
\&    $person\->hidden(\*(Aqid\*(Aq)
\&    $person\->text(\*(Aqname\*(Aq)
\&  }
\&
\&  # Or, scope it to the \*(Aquser\*(Aq param
\&  my $user = fields(\*(Aquser\*(Aq)
\&  $user\->hidden(\*(Aqid\*(Aq)
\&  $user\->text(\*(Aqname\*(Aq)
\&  $user\->error(\*(Aqname\*(Aq) unless $user\->valid(\*(Aqname\*(Aq)
\&  $user\->label(\*(Aqadmin\*(Aq)
\&  $user\->checkbox(\*(Aqadmin\*(Aq)
\&  $user\->password(\*(Aqpassword\*(Aq)
\&  $user\->select(\*(Aqage\*(Aq, [ [X => 10], [Dub => 20] ])
\&  $user\->file(\*(Aqavatar\*(Aq)
\&  $user\->textarea(\*(Aqbio\*(Aq, size => \*(Aq10x50\*(Aq)
\&
\&  my $kinfolk = $user\->fields(\*(Aqkinfolk\*(Aq)
\&  for my $person (@$kinfolk) {
\&    $person\->text(\*(Aqname\*(Aq)
\&    # ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mojolicious::Plugin::FormFields\*(C'\fR allows you to bind objects and data structures to form fields. It also performs validation and filtering via Validate::Tiny.
.SH "CREATING FIELDS"
.IX Header "CREATING FIELDS"
Fields can be bound to a hash, an array, something blessed, or any combination of the three.
They are created by calling the \f(CW"field"\fR helper with a path to the value you want to bind,
and then calling the desired \s-1HTML\s0 input method
.PP
.Vb 1
\&  field(\*(Aquser.name\*(Aq)\->text
.Ve
.PP
Is the same as
.PP
.Vb 1
\&  text_field \*(Aquser.name\*(Aq, $user\->name, id => \*(Aquser\-name\*(Aq
.Ve
.PP
(though \f(CW\*(C`Mojolicious::Plugin::FormFields\*(C'\fR sets \f(CW\*(C`type="text"\*(C'\fR).
.PP
Field names/paths are given in the form \f(CW\*(C`target.accessor1 [ .accessor2 [ .accessorN ] ]\*(C'\fR where \f(CW\*(C`target\*(C'\fR is an object or
data structure and \f(CW\*(C`accessor\*(C'\fR is a method, hash key, or array index. The target must be in the stash under the key \f(CW\*(C`target\*(C'\fR
or provided as an argument to \f(CW"field"\fR.
.PP
Some examples:
.PP
.Vb 1
\&  field(\*(Aqusers.0.name\*(Aq)\->text
.Ve
.PP
Is the same as
.PP
.Vb 1
\&  text_field \*(Aqusers.0.name\*(Aq, $users\->[0]\->name, id => \*(Aqusers\-0\-name\*(Aq
.Ve
.PP
And
.PP
.Vb 1
\&  field(\*(Aqitem.orders.0.XAJ123.quantity\*(Aq)\->text
.Ve
.PP
Is equivalent to
.PP
.Vb 1
\&  text_field \*(Aqitem.orders.0.XAJ123.quantity\*(Aq, $item\->orders\->[0]\->{XAJ123}\->quantity, id => \*(Aqitem\-orders\-0\-XAJ123\-quantity\*(Aq
.Ve
.PP
As you can see \s-1DOM\s0 IDs are always created.
.PP
Here the target key \f(CW\*(C`book\*(C'\fR does not exist in the stash so the target is supplied
.PP
.Vb 1
\&  field(\*(Aqbook.upc\*(Aq, $item)\->text
.Ve
.PP
If a value for the flattened representation exists (e.g., from a form submission) it will be used instead of
the value pointed at by the field name (desired behavior?). This is the same as Mojolicious' Tag Helpers.
.PP
Options can also be provided
.PP
.Vb 1
\&  field(\*(Aquser.name\*(Aq)\->text(class => \*(Aqinput\-text\*(Aq, data => { name => \*(Aqxxx\*(Aq })
.Ve
.PP
See \*(L"\s-1SUPPORTED FIELDS\*(R"\s0 for the list of \s-1HTML\s0 input creation methods.
.SS "\s-1STRUCTURED REQUEST PARAMETERS\s0"
.IX Subsection "STRUCTURED REQUEST PARAMETERS"
Structured request parameters for the bound object/data structure are available via
\&\f(CW\*(C`Mojolicious::Controller\*(C'\fR's param method.
They can not be accessed via \f(CW\*(C`Mojo::Message::Request\*(C'\fR.
.PP
A request with the parameters \f(CW\*(C`user.name=nameA&user.email=email&id=123\*(C'\fR can be accessed in your action like
.PP
.Vb 3
\&  my $user = $self\->param(\*(Aquser\*(Aq);
\&  $user\->{name};
\&  $user\->{email};
.Ve
.PP
Other parameters can be accessed as usual
.PP
.Vb 1
\&  $id = $self\->param(\*(Aqid\*(Aq);
.Ve
.PP
The flattened parameter can also be used
.PP
.Vb 1
\&  $name = $self\->param(\*(Aquser.name\*(Aq);
.Ve
.PP
See Mojolicious::Plugin::ParamExpand for more info.
.SS "\s-1SCOPING\s0"
.IX Subsection "SCOPING"
Fields can be scoped to a particular object/data structure via the \f(CW"fields"\fR helper
.PP
.Vb 3
\&  my $user = fields(\*(Aquser\*(Aq);
\&  $user\->text(\*(Aqname\*(Aq);
\&  $user\->hidden(\*(Aqid\*(Aq);
.Ve
.PP
When using \f(CW\*(C`fields\*(C'\fR you must supply the field's name to the \s-1HTML\s0 input and validation methods, otherwise
the calls are the same as they are with \f(CW\*(C`field\*(C'\fR.
.SS "\s-1COLLECTIONS\s0"
.IX Subsection "COLLECTIONS"
You can also create fields scoped to elements in a collection
.PP
.Vb 4
\&  my $addresses = field(\*(Aquser.addresses\*(Aq);
\&  for my $addr (@$addresses) {
\&    # field(\*(Aquser.addresses.N.id\*(Aq)\->hidden
\&    $addr\->hidden(\*(Aqid\*(Aq);
\&
\&    # field(\*(Aquser.addresses.N.street\*(Aq)\->text
\&    $addr\->text(\*(Aqstreet\*(Aq);
\&
\&    # field(\*(Aquser.addresses.N.city\*(Aq)\->select([qw|OAK PHL LAX|])
\&    $addr\->select(\*(Aqcity\*(Aq, [qw|OAK PHL LAX|]);
\&  }
.Ve
.PP
Or, for fields that are already scoped
.PP
.Vb 2
\&  my $user = fields(\*(Aquser\*(Aq)
\&  $user\->hidden(\*(Aqid\*(Aq);
\&
\&  my $addressess = $user\->fields(\*(Aqaddresses\*(Aq);
\&  for my $addr (@$addresses) {
\&    $addr\->hidden(\*(Aqid\*(Aq)
\&    # ...
\&  }
.Ve
.PP
You can also access the underlying object and its position within a collection
via the \f(CW\*(C`object\*(C'\fR and \f(CW\*(C`index\*(C'\fR methods.
.PP
.Vb 7
\&  <% for my $addr (@$addresses) {  %>
\&    <div id="<%= dom_id($addr\->object) %>">
\&      <h3>Address #<%= $addr\->index + 1 %></h3>
\&      <%= $addr\->hidden(\*(Aqid\*(Aq) %>
\&      ...
\&    </div>
\&  <% } %>
.Ve
.SH "VALIDATING & FILTERING"
.IX Header "VALIDATING & FILTERING"
Validation rules are created by calling validation and/or filter methods
on the field to be validated
.PP
.Vb 4
\&  # In your controller
\&  my $self = shift;
\&  $self\->field(\*(Aquser.name\*(Aq)\->is_required;
\&  $self\->field(\*(Aquser.name\*(Aq)\->filter(\*(Aqtrim\*(Aq);
.Ve
.PP
These methods can be chained
.PP
.Vb 1
\&  $self\->field(\*(Aquser.name\*(Aq)\->is_required\->filter(\*(Aqtrim\*(Aq);
.Ve
.PP
To perform validation on a field call its \f(CW\*(C`valid\*(C'\fR method
.PP
.Vb 4
\&  $field = $self\->field(\*(Aquser.name\*(Aq);
\&  $field\->is_required;
\&  $field\->valid;
\&  $field\->error;
.Ve
.PP
This will only validate and return the error for the \f(CW\*(C`user.name\*(C'\fR field. To validate all fields and retrieve all error messages call the controller's \f(CW\*(C`valid\*(C'\fR and \f(CW\*(C`errors\*(C'\fR methods
.PP
.Vb 3
\&  $self\->field(\*(Aquser.name\*(Aq)\->is_required;
\&  $self\->field(\*(Aquser.age\*(Aq)\->is_like(qr/^\ed+$/);
\&  $self\->valid;
\&
\&  my $errors = $self\->errors;
\&  $errors\->{\*(Aquser.name\*(Aq}
\&  # ...
.Ve
.PP
Of course the \f(CW\*(C`error\*(C'\fR/\f(CW\*(C`errors\*(C'\fR and \f(CW\*(C`valid\*(C'\fR methods can be used in your view too
.PP
.Vb 3
\&  <% unless(valid()) { %>
\&    <p>Hey, fix the below errors</p>
\&  <% } %>
\&
\&  <%= field(\*(Aqname\*(Aq)\->text %>
\&  <% unless(field(\*(Aqname\*(Aq)\->valid) { %>
\&    <span class="error"><%= field(\*(Aqname\*(Aq)\->error %></span>
\&  <% } %>
.Ve
.PP
When creating validation rules for \*(L"fields\*(R" you must pass the field name as the first argument
.PP
.Vb 4
\&  my $user = fields(\*(Aquser\*(Aq);
\&  $user\->is_required(\*(Aqpassword\*(Aq);
\&  $user\->is_equal(password => \*(Aqconfirm_password\*(Aq);
\&  $user\->is_long_at_least(password => 8, \*(AqMais longo caipira\*(Aq);
.Ve
.SS "\s-1AVAILABLE RULES & FILTERS\s0"
.IX Subsection "AVAILABLE RULES & FILTERS"
\&\f(CW\*(C`Mojolicious::Plugin::FormFields\*(C'\fR uses \f(CW\*(C`Validate::Tiny\*(C'\fR, see its docs for a list.
.SS "\s-1RENAMING THE VALIDATION METHODS\s0"
.IX Subsection "RENAMING THE VALIDATION METHODS"
In the event that the \f(CW\*(C`valid\*(C'\fR and/or \f(CW\*(C`errors\*(C'\fR methods clash with exiting methods/helpers
in your app you can rename them by specifying alternate names when loading the plugin
.PP
.Vb 2
\&  $self\->plugin(\*(AqFormFields\*(Aq, methods => { valid => \*(Aqform_valid\*(Aq, errors => \*(Aqform_errors\*(Aq });
\&  # ...
\&
\&  $self\->field(\*(Aquser.name\*(Aq)\->is_required;
\&  $self\->form_valid;
\&  $self\->form_errors;
.Ve
.PP
Note that this \fIonly\fR changes the methods \fBon the controller\fR and does not change the methods on the object returned by \f(CW\*(C`field\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "field"
.IX Subsection "field"
.Vb 2
\&  field($name)\->text
\&  field($name, $object)\->text
.Ve
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.PP
\&\f(CW$name\fR
.PP
The field's name, which can also be the path to its value in the stash. See \*(L"\s-1CREATING FIELDS\*(R"\s0.
.PP
\&\f(CW$object\fR
.PP
Optional. The object used to retrieve the value specified by \f(CW$name\fR. Must be a reference to a
hash, an array, or something blessed. If not given the value will be retrieved from
the stash or, for previously submitted forms, the request parameter \f(CW$name\fR.
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
An object than can be used to create \s-1HTML\s0 form fields, see \*(L"\s-1SUPPORTED FIELDS\*(R"\s0.
.PP
\fIErrors\fR
.IX Subsection "Errors"
.PP
An error will be raised if:
.IP "\(bu" 4
\&\f(CW$name\fR is not provided
.IP "\(bu" 4
\&\f(CW$name\fR cannot be retrieved from \f(CW$object\fR
.IP "\(bu" 4
\&\f(CW$object\fR cannot be found in the stash and no default was given
.PP
\fICollections\fR
.IX Subsection "Collections"
.PP
See \*(L"\s-1COLLECTIONS\*(R"\s0
.SS "fields"
.IX Subsection "fields"
.Vb 2
\&  $f = fields($name)
\&  $f\->text(\*(Aqaddress\*(Aq)
\&
\&  $f = fields($name, $object)
\&  $f\->text(\*(Aqaddress\*(Aq)
.Ve
.PP
Create form fields scoped to a parameter.
.PP
For example
.PP
.Vb 3
\&  % $f = fields(\*(Aquser\*(Aq)
\&  %= $f\->select(\*(Aqage\*(Aq, [10,20,30])
\&  %= $f\->textarea(\*(Aqbio\*(Aq)
.Ve
.PP
Is the same as
.PP
.Vb 2
\&  %= field(\*(Aquser.age\*(Aq)\->select([10,20,30])
\&  %= field(\*(Aquser.bio\*(Aq)\->textarea
.Ve
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.PP
Same as \*(L"field\*(R".
.PP
\fIReturns\fR
.IX Subsection "Returns"
.PP
An object than can be used to create \s-1HTML\s0 form fields scoped to the \f(CW$name\fR argument, see \*(L"\s-1SUPPORTED FIELDS\*(R"\s0.
.PP
\fIErrors\fR
.IX Subsection "Errors"
.PP
Same as \*(L"field\*(R".
.PP
\fICollections\fR
.IX Subsection "Collections"
.PP
See \*(L"\s-1COLLECTIONS\*(R"\s0
.SH "SUPPORTED FIELDS"
.IX Header "SUPPORTED FIELDS"
.SS "checkbox"
.IX Subsection "checkbox"
.Vb 2
\&  field(\*(Aquser.admin\*(Aq)\->checkbox(%options)
\&  field(\*(Aquser.admin\*(Aq)\->checkbox(\*(Aqyes\*(Aq, %options)
.Ve
.PP
Creates
.PP
.Vb 2
\&  <input type="checkbox" name="user.admin" id="user\-admin\-1" value="1"/>
\&  <input type="checkbox" name="user.admin" id="user\-admin\-yes" value="yes"/>
.Ve
.SS "file"
.IX Subsection "file"
.Vb 1
\&  field(\*(Aquser.avatar\*(Aq)\->file(%options);
.Ve
.PP
Creates
.PP
.Vb 1
\&  <input id="user\-avatar" name="user.avatar" type="file" />
.Ve
.SS "hidden"
.IX Subsection "hidden"
.Vb 1
\&  field(\*(Aquser.id\*(Aq)\->hidden(%options)
.Ve
.PP
Creates
.PP
.Vb 1
\&  <input id="user\-id" name="user.id" type="hidden" value="123123" />
.Ve
.SS "input"
.IX Subsection "input"
.Vb 1
\&  field(\*(Aquser.phone\*(Aq)\->input($type, %options)
.Ve
.PP
For example
.PP
.Vb 1
\&  field(\*(Aquser.phone\*(Aq)\->input(\*(Aqtel\*(Aq, pattern => \*(Aq\ed{3}\-\ed{4}\*(Aq)
.Ve
.PP
Creates
.PP
.Vb 1
\&  <input id="user\-phone" name="user.phone" type="tel" pattern="\ed{3}\-\ed{4}" />
.Ve
.SS "label"
.IX Subsection "label"
.Vb 2
\&  field(\*(Aquser.name\*(Aq)\->label
\&  field(\*(Aquser.name\*(Aq)\->label(\*(AqNombre\*(Aq, for => "tu_nombre_hyna")
.Ve
.PP
Creates
.PP
.Vb 2
\&  <label for="user\-name">Name</label>
\&  <label for="tu_nombre_hyna">Nombre</label>
.Ve
.SS "password"
.IX Subsection "password"
.Vb 1
\&  field(\*(Aquser.password\*(Aq)\->password(%options)
.Ve
.PP
Creates
.PP
.Vb 1
\&  <input id="user\-password" name="user.password" type="password" />
.Ve
.SS "select"
.IX Subsection "select"
.Vb 2
\&  field(\*(Aquser.age\*(Aq)\->select([10,20,30], %options)
\&  field(\*(Aquser.age\*(Aq)\->select([[Ten => 10], [Dub => 20], [Trenta => 30]], %options)
.Ve
.PP
Creates
.PP
.Vb 5
\&  <select id="user\-age" name="user.age">
\&    <option value="10">10</option>
\&    <option value="20">20</option>
\&    <option value="30">30</option>
\&  </select>
\&
\&  <select id="user\-age" name="user.age">
\&    <option value="10">Ten</option>
\&    <option value="20">Dub</option>
\&    <option value="30">Trenta</option>
\&  </select>
.Ve
.SS "radio"
.IX Subsection "radio"
.Vb 1
\&  field(\*(Aquser.age\*(Aq)\->radio(\*(Aqolder_than_21\*(Aq, %options)
.Ve
.PP
Creates
.PP
.Vb 1
\&  <input id="user\-age\-older_than_21" name="user.age" type="radio" value="older_than_21" />
.Ve
.SS "text"
.IX Subsection "text"
.Vb 2
\&  field(\*(Aquser.name\*(Aq)\->text(%options)
\&  field(\*(Aquser.name\*(Aq)\->text(size => 10, maxlength => 32)
.Ve
.PP
Creates
.PP
.Vb 2
\&  <input id="user\-name" name="user.name" value="sshaw" />
\&  <input id="user\-name" name="user.name" value="sshaw" size="10" maxlength="32" />
.Ve
.SS "textarea"
.IX Subsection "textarea"
.Vb 2
\&  field(\*(Aquser.bio\*(Aq)\->textarea(%options)
\&  field(\*(Aquser.bio\*(Aq)\->textarea(size => \*(Aq10x50\*(Aq)
.Ve
.PP
Creates
.PP
.Vb 2
\&  <textarea id="user\-bio" name="user.bio">Proprietary and confidential</textarea>
\&  <textarea cols="50" id="user\-bio" name="user.bio" rows="10">Proprietary and confidential</textarea>
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Skye Shaw (sshaw [\s-1AT\s0] gmail.com)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious::Plugin::TagHelpers, Mojolicious::Plugin::ParamExpand, Validate::Tiny, Mojolicious::Plugin::DomIdHelper
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2012\-2014 Skye Shaw.
.PP
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
