.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser::MGC 3"
.TH Parser::MGC 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Parser::MGC" \- build simple recursive\-descent parsers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& package My::Grammar::Parser
\& use base qw( Parser::MGC );
\&
\& sub parse
\& {
\&    my $self = shift;
\&
\&    $self\->sequence_of( sub {
\&       $self\->any_of(
\&          sub { $self\->token_int },
\&          sub { $self\->token_string },
\&          sub { \e$self\->token_ident },
\&          sub { $self\->scope_of( "(", \e&parse, ")" ) }
\&       );
\&    } );
\& }
\&
\& my $parser = My::Grammar::Parser\->new;
\&
\& my $tree = $parser\->from_file( $ARGV[0] );
\&
\& ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This base class provides a low-level framework for building recursive-descent
parsers that consume a given input string from left to right, returning a
parse structure. It takes its name from the \f(CW\*(C`m//gc\*(C'\fR regexps used to implement
the token parsing behaviour.
.PP
It provides a number of token-parsing methods, which each extract a
grammatical token from the string. It also provides wrapping methods that can
be used to build up a possibly-recursive grammar structure, by applying a
structure around other parts of parsing code.
.SS "Backtracking"
.IX Subsection "Backtracking"
Each method, both token and structural, atomically either consumes a prefix of
the string and returns its result, or fails and consumes nothing. This makes
it simple to implement grammars that require backtracking.
.PP
Several structure-forming methods have some form of \*(L"optional\*(R" behaviour; they
can optionally consume some amount of input or take some particular choice,
but if the code invoked inside that subsequently fails, the structure can
backtrack and take some different behaviour. This is usually what is required
when testing whether the structure of the input string matches some part of
the grammar that is optional, or has multiple choices.
.PP
However, once the choice of grammar has been made, it is often useful to be
able to fix on that one choice, thus making subsequent failures propagate up
rather than taking that alternative behaviour. Control of this backtracking
is given by the \f(CW\*(C`commit\*(C'\fR method; and careful use of this method is one of the
key advantages that \f(CW\*(C`Parser::MGC\*(C'\fR has over more simple parsing using single
regexps alone.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\&   $parser = Parser::MGC\->new( %args )
.Ve
.PP
Returns a new instance of a \f(CW\*(C`Parser::MGC\*(C'\fR object. This must be called on a
subclass that provides method of the name provided as \f(CW\*(C`toplevel\*(C'\fR, by default
called \f(CW\*(C`parse\*(C'\fR.
.PP
Takes the following named arguments
.IP "toplevel => \s-1STRING\s0" 8
.IX Item "toplevel => STRING"
Name of the toplevel method to use to start the parse from. If not supplied,
will try to use a method called \f(CW\*(C`parse\*(C'\fR.
.IP "patterns => \s-1HASH\s0" 8
.IX Item "patterns => HASH"
Keys in this hash should map to quoted regexp (\f(CW\*(C`qr//\*(C'\fR) references, to
override the default patterns used to match tokens. See \f(CW\*(C`PATTERNS\*(C'\fR below
.IP "accept_0o_oct => \s-1BOOL\s0" 8
.IX Item "accept_0o_oct => BOOL"
If true, the \f(CW\*(C`token_int\*(C'\fR method will also accept integers with a \f(CW\*(C`0o\*(C'\fR prefix
as octal.
.SH "PATTERNS"
.IX Header "PATTERNS"
The following pattern names are recognised. They may be passed to the
constructor in the \f(CW\*(C`patterns\*(C'\fR hash, or provided as a class method under the
name \f(CW\*(C`pattern_\f(CIname\f(CW\*(C'\fR.
.IP "\(bu" 4
ws
.Sp
Pattern used to skip whitespace between tokens. Defaults to \f(CW\*(C`/[\es\en\et]+/\*(C'\fR
.IP "\(bu" 4
comment
.Sp
Pattern used to skip comments between tokens. Undefined by default.
.IP "\(bu" 4
int
.Sp
Pattern used to parse an integer by \f(CW\*(C`token_int\*(C'\fR. Defaults to
\&\f(CW\*(C`/\-?(?:0x[[:xdigit:]]+|[[:digit:]]+)/\*(C'\fR. If \f(CW\*(C`accept_0o_oct\*(C'\fR is given, then
this will be expanded to match \f(CW\*(C`/0o[0\-7]+/\*(C'\fR as well.
.IP "\(bu" 4
float
.Sp
Pattern used to parse a floating-point number by \f(CW\*(C`token_float\*(C'\fR. Defaults to
\&\f(CW\*(C`/\-?(?:\ed*\e.\ed+|\ed+\e.)(?:e\-?\ed+)?|\-?\ed+e\-?\ed+/i\*(C'\fR.
.IP "\(bu" 4
ident
.Sp
Pattern used to parse an identifier by \f(CW\*(C`token_ident\*(C'\fR. Defaults to
\&\f(CW\*(C`/[[:alpha:]_]\ew*/\*(C'\fR
.IP "\(bu" 4
string_delim
.Sp
Pattern used to delimit a string by \f(CW\*(C`token_string\*(C'\fR. Defaults to \f(CW\*(C`/["\*(Aq]/\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "from_string"
.IX Subsection "from_string"
.Vb 1
\&   $result = $parser\->from_string( $str )
.Ve
.PP
Parse the given literal string and return the result from the toplevel method.
.SS "from_file"
.IX Subsection "from_file"
.Vb 1
\&   $result = $parser\->from_file( $file, %opts )
.Ve
.PP
Parse the given file, which may be a pathname in a string, or an opened \s-1IO\s0
handle, and return the result from the toplevel method.
.PP
The following options are recognised:
.IP "binmode => \s-1STRING\s0" 8
.IX Item "binmode => STRING"
If set, applies the given binmode to the filehandle before reading. Typically
this can be used to set the encoding of the file.
.Sp
.Vb 1
\& $parser\->from_file( $file, binmode => ":encoding(UTF\-8)" )
.Ve
.SS "from_reader"
.IX Subsection "from_reader"
.Vb 1
\&   $result = $parser\->from_reader( \e&reader )
.Ve
.PP
\&\fISince version 0.05.\fR
.PP
Parse the input which is read by the \f(CW\*(C`reader\*(C'\fR function. This function will be
called in scalar context to generate portions of string to parse, being passed
the \f(CW$parser\fR object. The function should return \f(CW\*(C`undef\*(C'\fR when it has no more
string to return.
.PP
.Vb 1
\& $reader\->( $parser )
.Ve
.PP
Note that because it is not generally possible to detect exactly when more
input may be required due to failed regexp parsing, the reader function is
only invoked during searching for skippable whitespace. This makes it suitable
for reading lines of a file in the common case where lines are considered as
skippable whitespace, or for reading lines of input interractively from a
user. It cannot be used in all cases (for example, reading fixed-size buffers
from a file) because two successive invocations may split a single token
across the buffer boundaries, and cause parse failures.
.SS "pos"
.IX Subsection "pos"
.Vb 1
\&   $pos = $parser\->pos
.Ve
.PP
\&\fISince version 0.09.\fR
.PP
Returns the current parse position, as a character offset from the beginning
of the file or string.
.SS "take"
.IX Subsection "take"
.Vb 1
\&   $str = $parser\->take( $len )
.Ve
.PP
\&\fISince version 0.16.\fR
.PP
Returns the next \f(CW$len\fR characters directly from the input, prior to any
whitespace or comment skipping. This does \fInot\fR take account of any pending
end-of-scope marker that may be pending. It is intended for use by parsers of
partially-binary protocols, or other situations in which it would be incorrect
for the end-of-scope marker to take effect at this time.
.SS "where"
.IX Subsection "where"
.Vb 1
\&   ( $lineno, $col, $text ) = $parser\->where
.Ve
.PP
Returns the current parse position, as a line and column number, and
the entire current line of text. The first line is numbered 1, and the first
column is numbered 0.
.SS "fail"
.IX Subsection "fail"
.SS "fail_from"
.IX Subsection "fail_from"
.Vb 1
\&   $parser\->fail( $message )
\&
\&   $parser\->fail_from( $pos, $message )
.Ve
.PP
\&\fI\f(CI\*(C`fail_from\*(C'\fI since version 0.09.\fR
.PP
Aborts the current parse attempt with the given message string. The failure
message will include the line and column position, and the line of input that
failed at the current parse position (\f(CW\*(C`fail\*(C'\fR), or a position earlier obtained
using the \f(CW\*(C`pos\*(C'\fR method (\f(CW\*(C`fail_from\*(C'\fR).
.PP
This failure will propagate up to the inner-most structure parsing method that
has not been committed; or will cause the entire parser to fail if there are
no further options to take.
.SS "at_eos"
.IX Subsection "at_eos"
.Vb 1
\&   $eos = $parser\->at_eos
.Ve
.PP
Returns true if the input string is at the end of the string.
.SS "scope_level"
.IX Subsection "scope_level"
.Vb 1
\&   $level = $parser\->scope_level
.Ve
.PP
\&\fISince version 0.05.\fR
.PP
Returns the number of nested \f(CW\*(C`scope_of\*(C'\fR calls that have been made.
.SH "STRUCTURE-FORMING METHODS"
.IX Header "STRUCTURE-FORMING METHODS"
The following methods may be used to build a grammatical structure out of the
defined basic token-parsing methods. Each takes at least one code reference,
which will be passed the actual \f(CW$parser\fR object as its first argument.
.SS "maybe"
.IX Subsection "maybe"
.Vb 1
\&   $ret = $parser\->maybe( $code )
.Ve
.PP
Attempts to execute the given \f(CW$code\fR in scalar context, and returns what it
returned, accepting that it might fail. \f(CW$code\fR may either be a \s-1CODE\s0
reference or a method name given as a string.
.PP
If the code fails (either by calling \f(CW\*(C`fail\*(C'\fR itself, or by propagating a
failure from another method it invoked) before it has invoked \f(CW\*(C`commit\*(C'\fR, then
none of the input string will be consumed; the current parsing position will
be restored. \f(CW\*(C`undef\*(C'\fR will be returned in this case.
.PP
If it calls \f(CW\*(C`commit\*(C'\fR then any subsequent failure will be propagated to the
caller, rather than returning \f(CW\*(C`undef\*(C'\fR.
.PP
This may be considered to be similar to the \f(CW\*(C`?\*(C'\fR regexp qualifier.
.PP
.Vb 3
\& sub parse_declaration
\& {
\&    my $self = shift;
\&
\&    [ $self\->parse_type,
\&      $self\->token_ident,
\&      $self\->maybe( sub {
\&         $self\->expect( "=" );
\&         $self\->parse_expression
\&      } ),
\&    ];
\& }
.Ve
.SS "scope_of"
.IX Subsection "scope_of"
.Vb 1
\&   $ret = $parser\->scope_of( $start, $code, $stop )
.Ve
.PP
Expects to find the \f(CW$start\fR pattern, then attempts to execute the given
\&\f(CW$code\fR, then expects to find the \f(CW$stop\fR pattern. Returns whatever the
code returned. \f(CW$code\fR may either be a \s-1CODE\s0 reference of a method name given
as a string.
.PP
While the code is being executed, the \f(CW$stop\fR pattern will be used by the
token parsing methods as an end-of-scope marker; causing them to raise a
failure if called at the end of a scope.
.PP
.Vb 3
\& sub parse_block
\& {
\&    my $self = shift;
\&
\&    $self\->scope_of( "{", sub { $self\->parse_statements }, "}" );
\& }
.Ve
.PP
If the \f(CW$start\fR pattern is undefined, it is presumed the caller has already
checked for this. This is useful when the stop pattern needs to be calculated
based on the start pattern.
.PP
.Vb 3
\& sub parse_bracketed
\& {
\&    my $self = shift;
\&
\&    my $delim = $self\->expect( qr/[\e(\e[\e<\e{]/ );
\&    $delim =~ tr/([<{/)]>}/;
\&
\&    $self\->scope_of( undef, sub { $self\->parse_body }, $delim );
\& }
.Ve
.PP
This method does not have any optional parts to it; any failures are
immediately propagated to the caller.
.SS "committed_scope_of"
.IX Subsection "committed_scope_of"
.Vb 1
\&   $ret = $parser\->committed_scope_of( $start, $code, $stop )
.Ve
.PP
\&\fISince version 0.16.\fR
.PP
A variant of \*(L"scope_of\*(R" that calls \*(L"commit\*(R" after a successful match of
the start pattern. This is usually what you want if using \f(CW\*(C`scope_of\*(C'\fR from
within an \f(CW\*(C`any_of\*(C'\fR choice, if no other alternative following this one could
possibly match if the start pattern has.
.SS "list_of"
.IX Subsection "list_of"
.Vb 1
\&   $ret = $parser\->list_of( $sep, $code )
.Ve
.PP
Expects to find a list of instances of something parsed by \f(CW$code\fR,
separated by the \f(CW$sep\fR pattern. Returns an \s-1ARRAY\s0 ref containing a list of
the return values from the \f(CW$code\fR. A single trailing delimiter is allowed,
and does not affect the return value. \f(CW$code\fR may either be a \s-1CODE\s0 reference
or a method name given as a string.
.PP
This method does not consider it an error if the returned list is empty; that
is, that the scope ended before any item instances were parsed from it.
.PP
.Vb 3
\& sub parse_numbers
\& {
\&    my $self = shift;
\&
\&    $self\->list_of( ",", sub { $self\->token_int } );
\& }
.Ve
.PP
If the code fails (either by invoking \f(CW\*(C`fail\*(C'\fR itself, or by propagating a
failure from another method it invoked) before it has invoked \f(CW\*(C`commit\*(C'\fR on a
particular item, then the item is aborted and the parsing position will be
restored to the beginning of that failed item. The list of results from
previous successful attempts will be returned.
.PP
If it calls \f(CW\*(C`commit\*(C'\fR within an item then any subsequent failure for that item
will cause the entire \f(CW\*(C`list_of\*(C'\fR to fail, propagating that to the caller.
.SS "sequence_of"
.IX Subsection "sequence_of"
.Vb 1
\&   $ret = $parser\->sequence_of( $code )
.Ve
.PP
A shortcut for calling \f(CW\*(C`list_of\*(C'\fR with an empty string as separator; expects
to find at least one instance of something parsed by \f(CW$code\fR, separated only
by skipped whitespace.
.PP
This may be considered to be similar to the \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`*\*(C'\fR regexp qualifiers.
.PP
.Vb 3
\& sub parse_statements
\& {
\&    my $self = shift;
\&
\&    $self\->sequence_of( sub { $self\->parse_statement } );
\& }
.Ve
.PP
The interaction of failures in the code and the \f(CW\*(C`commit\*(C'\fR method is identical
to that of \f(CW\*(C`list_of\*(C'\fR.
.SS "any_of"
.IX Subsection "any_of"
.Vb 1
\&   $ret = $parser\->any_of( @codes )
.Ve
.PP
\&\fISince version 0.06.\fR
.PP
Expects that one of the given code instances can parse something from the
input, returning what it returned. Each code instance may indicate a failure
to parse by calling the \f(CW\*(C`fail\*(C'\fR method or otherwise propagating a failure.
Each code instance may either be a \s-1CODE\s0 reference or a method name given as a
string.
.PP
This may be considered to be similar to the \f(CW\*(C`|\*(C'\fR regexp operator for forming
alternations of possible parse trees.
.PP
.Vb 3
\& sub parse_statement
\& {
\&    my $self = shift;
\&
\&    $self\->any_of(
\&       sub { $self\->parse_declaration; $self\->expect(";") },
\&       sub { $self\->parse_expression; $self\->expect(";") },
\&       sub { $self\->parse_block },
\&    );
\& }
.Ve
.PP
If the code for a given choice fails (either by invoking \f(CW\*(C`fail\*(C'\fR itself, or by
propagating a failure from another method it invoked) before it has invoked
\&\f(CW\*(C`commit\*(C'\fR itself, then the parsing position restored and the next choice will
be attempted.
.PP
If it calls \f(CW\*(C`commit\*(C'\fR then any subsequent failure for that choice will cause
the entire \f(CW\*(C`any_of\*(C'\fR to fail, propagating that to the caller and no further
choices will be attmepted.
.SS "commit"
.IX Subsection "commit"
.Vb 1
\&   $parser\->commit
.Ve
.PP
Calling this method will cancel the backtracking behaviour of the innermost
\&\f(CW\*(C`maybe\*(C'\fR, \f(CW\*(C`list_of\*(C'\fR, \f(CW\*(C`sequence_of\*(C'\fR, or \f(CW\*(C`any_of\*(C'\fR structure forming method.
That is, if later code then calls \f(CW\*(C`fail\*(C'\fR, the exception will be propagated
out of \f(CW\*(C`maybe\*(C'\fR, no further list items will be attempted by \f(CW\*(C`list_of\*(C'\fR or
\&\f(CW\*(C`sequence_of\*(C'\fR, and no further code blocks will be attempted by \f(CW\*(C`any_of\*(C'\fR.
.PP
Typically this will be called once the grammatical structure alter has been
determined, ensuring that any further failures are raised as real exceptions,
rather than by attempting other alternatives.
.PP
.Vb 3
\& sub parse_statement
\& {
\&    my $self = shift;
\&
\&    $self\->any_of(
\&       ...
\&       sub {
\&          $self\->scope_of( "{",
\&             sub { $self\->commit; $self\->parse_statements; },
\&          "}" ),
\&       },
\&    );
\& }
.Ve
.PP
Though in this common pattern, \*(L"committed_scope_of\*(R" may be used instead.
.SH "TOKEN PARSING METHODS"
.IX Header "TOKEN PARSING METHODS"
The following methods attempt to consume some part of the input string, to be
used as part of the parsing process.
.SS "expect"
.IX Subsection "expect"
.Vb 1
\&   $str = $parser\->expect( $literal )
\&
\&   $str = $parser\->expect( qr/pattern/ )
\&
\&   @groups = $parser\->expect( qr/pattern/ )
.Ve
.PP
Expects to find a literal string or regexp pattern match, and consumes it.
In scalar context, this method returns the string that was captured. In list
context it returns the matching substring and the contents of any subgroups
contained in the pattern.
.PP
This method will raise a parse error (by calling \f(CW\*(C`fail\*(C'\fR) if the regexp fails
to match. Note that if the pattern could match an empty string (such as for
example \f(CW\*(C`qr/\ed*/\*(C'\fR), the pattern will always match, even if it has to match an
empty string. This method will not consider a failure if the regexp matches
with zero-width.
.SS "maybe_expect"
.IX Subsection "maybe_expect"
.Vb 1
\&   $str = $parser\->maybe_expect( ... )
\&
\&   @groups = $parser\->maybe_expect( ... )
.Ve
.PP
\&\fISince version 0.10.\fR
.PP
A convenient shortcut equivalent to calling \f(CW\*(C`expect\*(C'\fR within \f(CW\*(C`maybe\*(C'\fR, but
implemented more efficiently, avoiding the exception-handling set up by
\&\f(CW\*(C`maybe\*(C'\fR. Returns \f(CW\*(C`undef\*(C'\fR or an empty list if the match fails.
.SS "substring_before"
.IX Subsection "substring_before"
.Vb 1
\&   $str = $parser\->substring_before( $literal )
\&
\&   $str = $parser\->substring_before( qr/pattern/ )
.Ve
.PP
\&\fISince version 0.06.\fR
.PP
Expects to possibly find a literal string or regexp pattern match. If it finds
such, consume all the input text before but excluding this match, and return
it. If it fails to find a match before the end of the current scope, consumes
all the input text until the end of scope and return it.
.PP
This method does not consume the part of input that matches, only the text
before it. It is not considered a failure if the substring before this match
is empty. If a non-empty match is required, use the \f(CW\*(C`fail\*(C'\fR method:
.PP
.Vb 3
\& sub token_nonempty_part
\& {
\&    my $self = shift;
\&
\&    my $str = $parser\->substring_before( "," );
\&    length $str or $self\->fail( "Expected a string fragment before ," );
\&
\&    return $str;
\& }
.Ve
.PP
Note that unlike most of the other token parsing methods, this method does not
consume either leading or trailing whitespace around the substring. It is
expected that this method would be used as part a parser to read quoted
strings, or similar cases where whitespace should be preserved.
.SS "generic_token"
.IX Subsection "generic_token"
.Vb 1
\&   $val = $parser\->generic_token( $name, $re, $convert )
.Ve
.PP
\&\fISince version 0.08.\fR
.PP
Expects to find a token matching the precompiled regexp \f(CW$re\fR. If provided,
the \f(CW$convert\fR \s-1CODE\s0 reference can be used to convert the string into a more
convenient form. \f(CW$name\fR is used in the failure message if the pattern fails
to match.
.PP
If provided, the \f(CW$convert\fR function will be passed the parser and the
matching substring; the value it returns is returned from \f(CW\*(C`generic_token\*(C'\fR.
.PP
.Vb 1
\& $convert\->( $parser, $substr )
.Ve
.PP
If not provided, the substring will be returned as it stands.
.PP
This method is mostly provided for subclasses to define their own token types.
For example:
.PP
.Vb 5
\& sub token_hex
\& {
\&    my $self = shift;
\&    $self\->generic_token( hex => qr/[0\-9A\-F]{2}h/, sub { hex $_[1] } );
\& }
.Ve
.SS "token_int"
.IX Subsection "token_int"
.Vb 1
\&   $int = $parser\->token_int
.Ve
.PP
Expects to find an integer in decimal, octal or hexadecimal notation, and
consumes it. Negative integers, preceeded by \f(CW\*(C`\-\*(C'\fR, are also recognised.
.SS "token_float"
.IX Subsection "token_float"
.Vb 1
\&   $float = $parser\->token_float
.Ve
.PP
\&\fISince version 0.04.\fR
.PP
Expects to find a number expressed in floating-point notation; a sequence of
digits possibly prefixed by \f(CW\*(C`\-\*(C'\fR, possibly containing a decimal point,
possibly followed by an exponent specified by \f(CW\*(C`e\*(C'\fR followed by an integer. The
numerical value is then returned.
.SS "token_number"
.IX Subsection "token_number"
.Vb 1
\&   $number = $parser\->token_number
.Ve
.PP
\&\fISince version 0.09.\fR
.PP
Expects to find a number expressed in either of the above forms.
.SS "token_string"
.IX Subsection "token_string"
.Vb 1
\&   $str = $parser\->token_string
.Ve
.PP
Expects to find a quoted string, and consumes it. The string should be quoted
using \f(CW\*(C`"\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR quote marks.
.PP
The content of the quoted string can contain character escapes similar to
those accepted by C or Perl. Specifically, the following forms are recognised:
.PP
.Vb 9
\& \ea               Bell ("alert")
\& \eb               Backspace
\& \ee               Escape
\& \ef               Form feed
\& \en               Newline
\& \er               Return
\& \et               Horizontal Tab
\& \e0, \e012         Octal character
\& \ex34, \ex{5678}   Hexadecimal character
.Ve
.PP
C's \f(CW\*(C`\ev\*(C'\fR for vertical tab is not supported as it is rarely used in practice
and it collides with Perl's \f(CW\*(C`\ev\*(C'\fR regexp escape. Perl's \f(CW\*(C`\ec\*(C'\fR for forming other
control characters is also not supported.
.SS "token_ident"
.IX Subsection "token_ident"
.Vb 1
\&   $ident = $parser\->token_ident
.Ve
.PP
Expects to find an identifier, and consumes it.
.SS "token_kw"
.IX Subsection "token_kw"
.Vb 1
\&   $keyword = $parser\->token_kw( @keywords )
.Ve
.PP
Expects to find a keyword, and consumes it. A keyword is defined as an
identifier which is exactly one of the literal values passed in.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Accumulating Results Using Variables"
.IX Subsection "Accumulating Results Using Variables"
Although the structure-forming methods all return a value, obtained from their
nested parsing code, it can sometimes be more convenient to use a variable to
accumulate a result in instead. For example, consider the following parser
method, designed to parse a set of \f(CW\*(C`name: "value"\*(C'\fR assignments, such as might
be found in a configuration file, or YAML/JSON\-style mapping value.
.PP
.Vb 3
\& sub parse_dict
\& {
\&    my $self = shift;
\& 
\&    my %ret;
\&    $self\->list_of( ",", sub {
\&       my $key = $self\->token_ident;
\&       exists $ret{$key} and $self\->fail( "Already have a mapping for \*(Aq$key\*(Aq" );
\& 
\&       $self\->expect( ":" );
\& 
\&       $ret{$key} = $self\->parse_value;
\&    } );
\& 
\&    return \e%ret
\& }
.Ve
.PP
Instead of using the return value from \f(CW\*(C`list_of\*(C'\fR, this method accumulates
values in the \f(CW%ret\fR hash, eventually returning a reference to it as its
result. Because of this, it can perform some error checking while it parses;
namely, rejecting duplicate keys.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Make unescaping of string constants more customisable. Possibly consider
instead a \f(CW\*(C`parse_string_generic\*(C'\fR using a loop over \f(CW\*(C`substring_before\*(C'\fR.
.IP "\(bu" 4
Easy ability for subclasses to define more token types as methods. Perhaps
provide a class method such as
.Sp
.Vb 1
\& _\|_PACKAGE_\|_\->has_token( hex => qr/[0\-9A\-F]+/i, sub { hex $_[1] } );
.Ve
.IP "\(bu" 4
Investigate how well \f(CW\*(C`from_reader\*(C'\fR can cope with buffer splitting across
other tokens than simply skippable whitespace
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
