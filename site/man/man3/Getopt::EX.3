.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::EX 3"
.TH Getopt::EX 3 "2020-10-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Getopt::EX \- Getopt Extender
.SH "VERSION"
.IX Header "VERSION"
Version v1.20.0
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Getopt::EX extends the basic function of Getopt family to
support user-definable option aliases, and dynamic module which works
together with the script through option interface.
.SH "INTERFACES"
.IX Header "INTERFACES"
There are two major interfaces to use Getopt::EX modules.
.PP
Easy one is Getopt::Long compatible module, Getopt::EX::Long.
You can simply replace module declaration and get the benefit of this
module to some extent.  It allows user to make start up \fIrc\fR file in
their home directory, which provide user-defined option aliases.
.PP
Use Getopt::EX::Loader to get full capabilities.  Then the user of
your script can make their own extension module which work together
with original command through command option interface.
.PP
Another module Getopt::EX::Colormap is made to produce colored text
on \s-1ANSI\s0 terminal, and to provide easy way to maintain labeled colormap
table and option handling.  It can be used just like
Term::ANSIColor but you'd better use standard module in that case.
.SS "Getopt::EX::Long"
.IX Subsection "Getopt::EX::Long"
This is the easiest way to get started with Getopt::EX.  This
module is almost compatible with Getopt::Long and replaceable.
.PP
In addition, if the command name is \fIexample\fR,
.PP
.Vb 1
\&    ~/.examplerc
.Ve
.PP
file is loaded by default.  In this rc file, user can define their own
option with macro processing.  This is useful when the command takes
complicated arguments.  User can also define default option which is
used always.  For example,
.PP
.Vb 1
\&    option default \-n
.Ve
.PP
gives option \fI\-n\fR always when the script executed.  See
Getopt::EX::Module document what you can do in this file.
.PP
If the rc file includes a section start with \f(CW\*(C`_\|_PERL_\|_\*(C'\fR, it is
evaluated as a perl program.  User can define any kind of functions
there, which can be invoked from command line option if the script is
aware of them.
.PP
Also, special command option preceded by \fB\-M\fR is taken and
corresponding perl module is loaded.  For example,
.PP
.Vb 1
\&    % example \-Mfoo
.Ve
.PP
will load \f(CW\*(C`App::example::foo\*(C'\fR module.
.PP
This module is normal perl module, so user can write anything they
want.  If the module option come with initial function call, it is
called at the beginning of command execution.  Suppose that the module
\&\fIfoo\fR is specified like this:
.PP
.Vb 1
\&    % example \-Mfoo::bar(buz=100) ...
.Ve
.PP
Then, after the module \fBfoo\fR is loaded, function \fIbar\fR is called
with the parameter \fIbuz\fR with value 100.
.PP
If the module includes \f(CW\*(C`_\|_DATA_\|_\*(C'\fR section, it is interpreted just
same as rc file.  So you can define arbitrary option there.  Combined
with startup function call described above, it is possible to control
module behavior by user defined option.
.SS "Getopt::EX::Loader"
.IX Subsection "Getopt::EX::Loader"
This module provides more primitive access to the underlying modules.
You should create loader object first:
.PP
.Vb 4
\&  use Getopt::EX::Loader;
\&  my $loader = Getopt::EX::Loader\->new(
\&      BASECLASS => \*(AqApp::example\*(Aq,
\&      );
.Ve
.PP
Then load rc file:
.PP
.Vb 1
\&  $loader\->load_file("$ENV{HOME}/.examplerc");
.Ve
.PP
And process command line options:
.PP
.Vb 1
\&  $loader\->deal_with(\e@ARGV);
.Ve
.PP
Finally gives built-in function declared in dynamically loaded modules
to option parser.
.PP
.Vb 2
\&  my $parser = Getopt::Long::Parser\->new;
\&  $parser\->getoptions( ... , $loader\->builtins )
.Ve
.PP
Actually, this is what Getopt::EX::Long module is doing
internally.
.SS "Getopt::EX::Func"
.IX Subsection "Getopt::EX::Func"
To make your script to communicate with user-defined subroutines, use
Getopt::EX::Func module, which provide \f(CW\*(C`parse_func\*(C'\fR interface.  If
your script has \fB\-\-begin\fR option which tells the script to call
specific function at the beginning of execution.  Write something
like:
.PP
.Vb 4
\&    use Getopt::EX::Func qw(parse_func);
\&    GetOptions("begin:s" => $opt_begin);
\&    my $func = parse_func($opt_begin);
\&    $func\->call;
.Ve
.PP
Then the script can be invoked like this:
.PP
.Vb 1
\&    % example \-Mfoo \-\-begin \*(Aqrepeat(debug,msg=hello,count=2)\*(Aq
.Ve
.PP
See Getopt::EX::Func for more detail.
.SS "Getopt::EX::Colormap"
.IX Subsection "Getopt::EX::Colormap"
This module is not so tightly coupled with other modules in
Getopt::EX.  It provides concise way to specify \s-1ANSI\s0 terminal 256
colors with various effects, and produce terminal sequences by color
specification or label parameter.
.PP
You can use this with normal Getopt::Long:
.PP
.Vb 3
\&    my @opt_colormap;
\&    use Getopt::Long;
\&    GetOptions("colormap|cm=s" => \e@opt_colormap);
\&    
\&    my %colormap = ( # default color map
\&        FILE => \*(AqR\*(Aq,
\&        LINE => \*(AqG\*(Aq,
\&        TEXT => \*(AqB\*(Aq,
\&        );
\&    my @colors;
\&    
\&    require Getopt::EX::Colormap;
\&    my $handler = Getopt::EX::Colormap\->new(
\&        HASH => \e%colormap,
\&        LIST => \e@colors,
\&        );
\&    
\&    $handler\->load_params(@opt_colormap);
.Ve
.PP
and then get colored string as follows.
.PP
.Vb 3
\&    print $handler\->color("FILE", "FILE in Red\en");
\&    print $handler\->color("LINE", "LINE in Blue\en");
\&    print $handler\->color("TEXT", "TEXT in Green\en");
.Ve
.PP
In this example, user can change these colors from command line option
like this:
.PP
.Vb 1
\&    % example \-\-colormap FILE=C,LINE=M,TEXT=Y
.Ve
.PP
or call arbitrary perl function like:
.PP
.Vb 1
\&    % example \-\-colormap FILE=\*(Aqsub{uc}\*(Aq
.Ve
.PP
Above example produces uppercase version of provided string instead of
\&\s-1ANSI\s0 color sequence.
.PP
If you only use coloring function, it's more simple:
.PP
.Vb 2
\&    require Getopt::EX::Colormap;
\&    my $handler = Getopt::EX::Colormap\->new;
\&
\&    print $handler\->color("R", "FILE in Red\en");
\&    print $handler\->color("G", "LINE in Blue\en");
\&    print $handler\->color("B", "TEXT in Green\en");
.Ve
.PP
or even simpler non-oo interface:
.PP
.Vb 1
\&    use Getopt::EX::Colormap qw(colorize);
\&
\&    print colorize("R", "FILE in Red\en");
\&    print colorize("G", "LINE in Blue\en");
\&    print colorize("B", "TEXT in Green\en");
.Ve
.SS "Getopt::EX::LabeledParam"
.IX Subsection "Getopt::EX::LabeledParam"
This is super-class of Getopt::EX::Colormap.  Getopt::Long
support parameter handling within hash,
.PP
.Vb 2
\&    my %defines;
\&    GetOptions ("define=s" => \e%defines);
.Ve
.PP
and the parameter can be given in \f(CW\*(C`key=value\*(C'\fR format.
.PP
.Vb 1
\&    \-\-define os=linux \-\-define vendor=redhat
.Ve
.PP
Using Getopt::EX::LabeledParam, this can be written as:
.PP
.Vb 6
\&    my @defines;
\&    my %defines;
\&    GetOptions ("defines=s" => \e@defines);
\&    Getopt::EX::LabeledParam
\&        \->new(HASH => \e%defines)
\&        \->load_params (@defines);
.Ve
.PP
and the parameter can be given mixed together.
.PP
.Vb 1
\&    \-\-define os=linux,vendor=redhat
.Ve
.SS "Getopt::EX::Numbers"
.IX Subsection "Getopt::EX::Numbers"
Parse number parameter description and produces number range list or
number sequence.  Number format is composed by four elements: \f(CW\*(C`start\*(C'\fR,
\&\f(CW\*(C`end\*(C'\fR, \f(CW\*(C`step\*(C'\fR and \f(CW\*(C`length\*(C'\fR, like this:
.PP
.Vb 4
\&    1           1
\&    1:3         1,2,3
\&    1:20:5      1,     6,     11,       16
\&    1:20:5:3    1,2,3, 6,7,8, 11,12,13, 16,17,18
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Kazumasa Utashiro
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The following copyright notice applies to all the files provided in
this distribution, including binary files, unless explicitly noted
otherwise.
.PP
Copyright 2015\-2020 Kazumasa Utashiro
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
