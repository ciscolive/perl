.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::MAC 3"
.TH NetAddr::MAC 3 "2020-09-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::MAC \- MAC hardware address functions and object (EUI48 and EUI64)
.SH "VERSION"
.IX Header "VERSION"
version 0.97
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use NetAddr::MAC;
\&
\& my $mac = NetAddr::MAC\->new( \*(Aq00:11:22:aa:bb:cc\*(Aq );
\& my $mac = NetAddr::MAC\->new( mac => \*(Aq0011.22AA.BBCC\*(Aq );
\&
\& print "MAC provided at object creation was: ", $mac\->original;
\&
\& print "EUI48\en" if $mac\->is_eui48;
\& print "EUI64\en" if $mac\->is_eui64;
\&
\& print "Unicast\en" if $mac\->is_unicast;
\& print "Multicast\en" if $mac\->is_multicast;
\& print "Broadcast\en" if $mac\->is_broadcast;
\&
\& print "Locally Administered\en" if $mac\->is_local;
\& print "Universally Administered\en" if $mac\->is_universal;
\&
\& print \*(AqBasic Format: \*(Aq,$mac\->as_basic,"\en";
\& print \*(AqBpr Format: \*(Aq,  $mac\->as_bpr,"\en";
\& print \*(AqCisco Format: \*(Aq,$mac\->as_cisco,"\en";
\& print \*(AqIEEE Format: \*(Aq, $mac\->as_ieee,"\en";
\& print \*(AqIPv6 Address: \*(Aq,$mac\->as_ipv6_suffix,"\en";
\& print \*(AqMicrosoft Format: \*(Aq,$mac\->as_microsoft,"\en";
\& print \*(AqSingle Dash Format: \*(Aq,$mac\->as_singledash,"\en";
\& print \*(AqSun Format: \*(Aq,  $mac\->as_sun,"\en";
\& print \*(AqToken Ring Format: \*(Aq, $mac\->as_tokenring,"\en";
\&
\&
\& use NetAddr::MAC qw( :all );
\&
\& my $mac = q/00.11.22.33.44.55/;
\&
\& print "EUI48\en" if mac_is_eui48($mac);
\& print "EUI64\en" if mac_is_eui64($mac);
\&
\& print "Unicast\en" if mac_is_unicast($mac);
\& print "Multicast\en" if mac_is_multicast($mac);
\& print "Broadcast\en" if mac_is_broadcast($mac);
\&
\& print "Locally Administerd\en" if mac_is_local($mac);
\& print "Universally Administered\en" if mac_is_universal($mac);
\&
\& print \*(AqBasic Format: \*(Aq,mac_as_basic($mac),"\en";
\& print \*(AqBpr Format: \*(Aq,  mac_as_bpr($mac),"\en";
\& print \*(AqCisco Format: \*(Aq,mac_as_cisco($mac),"\en";
\& print \*(AqIEEE Format: \*(Aq, mac_as_ieee($mac),"\en";
\& print \*(AqIPv6 Address: \*(Aq,mac_as_ipv6_suffix($mac),"\en";
\& print \*(AqMicrosoft Format: \*(Aq,mac_as_microsoft($mac),"\en";
\& print \*(AqSingle Dash Format: \*(Aq, mac_as_singledash($mac),"\en";
\& print \*(AqSun Format: \*(Aq,  mac_as_sun($mac),"\en";
\& print \*(AqToken Ring Format: \*(Aq,mac_as_tokenring($mac),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an \s-1OO\s0 and functional interface to deal with Media Access
Control (or \s-1MAC\s0) addresses. These are the addresses that uniquely identify a
device on various layer 2 networks. Although the most common case is hardware
addresses on Ethernet network cards, there are a variety of devices that use
this system of addressing.
.PP
Both Extended Unique Identifier 48 and 64 addresses are supported.
.PP
Some networks that use Extended Unique Identifier 48 (or \s-1MAC48\s0) addresses include:
.PP
.Vb 6
\& Ethernet
\& 802.11 wireless networks
\& Bluetooth
\& IEEE 802.5 token ring
\& FDDI
\& ATM
.Ve
.PP
Some networks that use Extended Unique Identifier 64 addresses include:
.PP
.Vb 3
\& Firewire
\& IPv6 (sort of)
\& ZigBee / 802.15.4 wireless personal\-area networks
.Ve
.SH "OO METHODS"
.IX Header "OO METHODS"
.SS "new"
.IX Subsection "new"
The \fBnew\fR method creates instances of this object. It can be called
in any of the following ways.
.PP
\fINetAddr::MAC\->new( mac => \f(CI$mac\fI )\fR
.IX Subsection "NetAddr::MAC->new( mac => $mac )"
.PP
Creates and returns a new NetAddr::MAC object.  The \s-1MAC\s0 value is required.
.PP
\fINetAddr::MAC\->new( mac => \f(CI$mac\fI, \f(CI%options\fI )\fR
.IX Subsection "NetAddr::MAC->new( mac => $mac, %options )"
.PP
As above, but \f(CW%options\fR may include any or none of the following
.IP "\(bu" 4
die_on_error
.Sp
If set to true, errors will result in a die (croak) rather than populating \fI\f(CI$errstr\fI\fR
.Sp
\&\fBTake care when using the mac_is_* functions!\fR they will return false in both
the case of an error and according to the properties of the \s-1MAC\s0 address. You will
therefore need to enable die_on_error or check \fI\f(CI$errstr\fI\fR when false is returned.
.IP "\(bu" 4
priority
.Sp
This is the bridge priority as an integer, which can also be set by providing a mac
address in the following format, where 60 is the priority.
.Sp
.Vb 1
\& 60#0011.22aa.bbcc
.Ve
.Sp
This is a cisco thing, so typically the above is the format you would see. But we
are flexible enough to handle formats like...
.Sp
.Vb 4
\& 60#00:11:22:aa:bb:cc
\& 60#001122aabbcc
\& 60#00\-11\-22\-aa\-bb\-cc
\& etc.
.Ve
.Sp
If priority is provided as an option and as part of the mac address string, an
error will occur only if they differ.
.Sp
Priority defaults to 0 if not provided.
.PP
\fINetAddr::MAC\->new( \f(CI$mac\fI )\fR
.IX Subsection "NetAddr::MAC->new( $mac )"
.PP
Simplified creation method
.PP
\fINetAddr::MAC\->new( \f(CI$mac\fI, \f(CI%options\fI )\fR
.IX Subsection "NetAddr::MAC->new( $mac, %options )"
.PP
As above but with \f(CW%options\fR
.SS "random"
.IX Subsection "random"
As an alternative to \*(L"new\*(R", a \*(L"random\*(R" mac access based upon the provided
\&\fBoui\fR argument.
.PP
Please consider the following information when selecting an \s-1OUI.\s0
.PP
If the first octal/digit/number is odd, then the \s-1MAC\s0 address \*(L"is_multicast\*(R"
.PP
\&\s-1OUI\s0's used by virtualization software:
.PP
Xen's prefix 00:16:3e
VMware's prefix 00:50:56
.PP
There are 4 sets of 'Locally Administered Address Ranges' that can be used
without fear of conflict (from actual hardware):
.PP
.Vb 4
\& x2\-xx\-xx\-xx\-xx\-xx
\& x6\-xx\-xx\-xx\-xx\-xx
\& xA\-xx\-xx\-xx\-xx\-xx
\& xE\-xx\-xx\-xx\-xx\-xx
.Ve
.SS "original"
.IX Subsection "original"
Returns the original \fBmac\fR string as used when creating the \s-1MAC\s0 object
.SS "oui"
.IX Subsection "oui"
Returns the mac address's Organizationally Unique Identifier (\s-1OUI\s0) with dashes
in Hexadecimal / Canonical format:
.PP
.Vb 1
\& AC\-DE\-48
.Ve
.SS "errstr"
.IX Subsection "errstr"
Returns the error (if one occurred).
.PP
This is intended for use with the object. Its not exported at all.
.PP
Note: this method is used once the NetAddr::MAC object is successfully
created. For now the to_eui48 method is the only method that will
return an error once the object is created.
.PP
When creating objects, you will need to catch errors with either the
\&\fIor\fR function, or the \fIeval\fR way.
.SH "OO PROPERTY METHODS"
.IX Header "OO PROPERTY METHODS"
.SS "is_eui48"
.IX Subsection "is_eui48"
Returns true if mac address is determined to be of the \s-1EUI48\s0 standard
.SS "is_eui64"
.IX Subsection "is_eui64"
Returns true if mac address is determined to be of the \s-1EUI64\s0 standard
.SS "is_multicast"
.IX Subsection "is_multicast"
Returns true if mac address is determined to be a multicast address
.SS "is_broadcast"
.IX Subsection "is_broadcast"
Returns true if mac address is determined to be a broadcast address
.SS "is_vrrp"
.IX Subsection "is_vrrp"
Returns true if mac address is determined to be a Virtual Router Redundancy (\s-1VRRP\s0) address
.PP
i.e. 00\-00\-5E\-00\-01\-XX
.PP
always returns false for eui64.
.PP
I'm not quite sure what to do with 01\-00\-5E\-00\-00\-12, suggestions welcomed.
.SS "is_hsrp"
.IX Subsection "is_hsrp"
Returns true if mac address is determined to be a Hot Standby Router (\s-1HSRP\s0) address
.PP
i.e. 00\-00\-0C\-07\-AC\-XX
.PP
always returns false for eui64.
.SS "is_hsrp2"
.IX Subsection "is_hsrp2"
Returns true if mac address is determined to be a Hot Standby Router Version 2 (HSRPv2) address
.PP
i.e. 00\-00\-0C\-9F\-FX\-XX
.PP
always returns false for eui64.
.SS "is_msnlb"
.IX Subsection "is_msnlb"
Returns true if mac address is determined to be a \s-1MS\s0 Network Load Balancing \s-1MAC\s0 address
.PP
i.e. 02\-BF\-1\-2\-3\-4 for unicast or 03\-BF\-1\-2\-3\-4 for multicast
.PP
where 1\-2\-3\-4 is the clusters primary \s-1IP\s0 address
.PP
for outbound packets, clusters members will send from 02\-n\-1\-2\-3\-4 where n is the node priority. this function does \s-1NOT\s0 return true for those addresses.
.PP
always returns false for eui64.
.SS "is_unicast"
.IX Subsection "is_unicast"
Returns true if mac address is determined to be a unicast address
.SS "is_local"
.IX Subsection "is_local"
Returns true if mac address is determined to be locally administered
.SS "is_universal"
.IX Subsection "is_universal"
Returns true if mac address is determined to be universally administered
.SH "OO NORMALIZATION METHODS"
.IX Header "OO NORMALIZATION METHODS"
.SS "as_basic"
.IX Subsection "as_basic"
Returns the mac address normalized as a hexadecimal string that is 0 padded and without delimiters
.PP
.Vb 1
\& 001122aabbcc
.Ve
.SS "as_bridge_id"
.IX Subsection "as_bridge_id"
Returns mac address with the priority, a hash, then the mac address normalized with \fIas_cisco\fR
.PP
.Vb 1
\& 45#0011.22aa.bbcc
.Ve
.SS "as_bpr"
.IX Subsection "as_bpr"
Returns the mac address normalized as a hexadecimal string that is 0 padded with \fB:\fR delimiters and with
\&\fB1,length\fR leading where \fIlength\fR is the number of hex pairs (i.e. 6 for \s-1EUI48\s0)
.PP
.Vb 1
\& 1,6,00:11:22:aa:bb:cc
.Ve
.SS "as_cisco"
.IX Subsection "as_cisco"
Returns the mac address normalized as a hexadecimal string that is 0 padded and with \fB.\fR delimiting every 2nd octet
(i.e. after every 4th character)
.PP
.Vb 1
\& 0011.22aa.bbcc
.Ve
.SS "as_ieee"
.IX Subsection "as_ieee"
Returns the mac address normalized as a hexadecimal string that is 0 padded and with \fB:\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 00:34:56:78:9a:bc
.Ve
.SS "as_ipv6_suffix"
.IX Subsection "as_ipv6_suffix"
Returns the \s-1EUI64\s0 address in the format used for an IPv6 autoconf address suffix
.SS "as_microsoft"
.IX Subsection "as_microsoft"
Returns the mac address normalized as a hexadecimal string that is 0 padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 00\-34\-56\-78\-9a\-bc
.Ve
.SS "as_pgsql"
.IX Subsection "as_pgsql"
Returns the mac address normalized as a hexadecimal string that is 0 padded and has a \fI:\fR in the middle of the hex string.
this appears in the pgsql documentation along with the single dash version
.PP
.Vb 1
\& 001122:334455
.Ve
.SS "as_singledash"
.IX Subsection "as_singledash"
Returns the mac address normalized as a hexadecimal string that is 0 padded and has a dash in the middle of the hex string.
this appears in the pgsql documentation.
.PP
.Vb 1
\& 001122\-334455
.Ve
.SS "as_sun"
.IX Subsection "as_sun"
Returns the mac address normalized as a hexadecimal string that is \fBnot\fR padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 0\-34\-56\-78\-9a\-bc
.Ve
.SS "as_tokenring"
.IX Subsection "as_tokenring"
Returns the mac address normalized as a hexadecimal string that is 0 padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character) and each octet is bit-reversed order. So 10 00 5A 4D \s-1BC 96\s0 becomes 08 00 5A B2 3D 69.
.PP
.Vb 1
\& 00\-2d\-6a\-1e\-59\-3d
.Ve
.SS "to_eui48"
.IX Subsection "to_eui48"
Converts to \s-1EUI48\s0 (if the \s-1EUI64\s0 was derived from \s-1EUI48\s0)
.PP
This function will fail if the mac was not derived from \s-1EUI48.\s0
you will need to catch it and inspect the error message.
.SS "to_eui64"
.IX Subsection "to_eui64"
Converts to \s-1EUI64,\s0 or in other words encapsulates \s-1EUI48\s0 to become \s-1EUI64\s0
if needed
.SH "PROCEDURAL PROPERTY FUNCTIONS"
.IX Header "PROCEDURAL PROPERTY FUNCTIONS"
.SS "mac_is_eui48($mac)"
.IX Subsection "mac_is_eui48($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be of the \s-1EUI48\s0 standard
.SS "mac_is_eui64($mac)"
.IX Subsection "mac_is_eui64($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be of the \s-1EUI64\s0 standard
.SS "mac_is_multicast($mac)"
.IX Subsection "mac_is_multicast($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be a multicast address
.SS "mac_is_broadcast($mac)"
.IX Subsection "mac_is_broadcast($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be a broadcast address
.SS "mac_is_unicast($mac)"
.IX Subsection "mac_is_unicast($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be a unicast address
.SS "mac_is_vrrp($mac)"
.IX Subsection "mac_is_vrrp($mac)"
Returns true if mac address is \f(CW$mac\fR is determined to be a Virtual Router Redundancy (\s-1VRRP\s0) address
.PP
i.e. 00\-00\-5E\-00\-01\-XX
.SS "mac_is_hsrp($mac)"
.IX Subsection "mac_is_hsrp($mac)"
Returns true if mac address is \f(CW$mac\fR is determined to be a Hot Standby Router (\s-1HSRP\s0) address
.PP
i.e. 00\-00\-0C\-07\-AC\-XX
.SS "mac_is_hsrp2($mac)"
.IX Subsection "mac_is_hsrp2($mac)"
Returns true if mac address is \f(CW$mac\fR is determined to be a Hot Standby Router Version 2 (HSRPv2) address
.PP
i.e. 00\-00\-0C\-9F\-FX\-XX
.SS "mac_is_msnlb($mac)"
.IX Subsection "mac_is_msnlb($mac)"
Returns true if mac address is \f(CW$mac\fR is determined to be a \s-1MS\s0 Network Load Balancing address
.PP
i.e. 02\-BF\-XX\-XX\-XX\-XX or 03\-BF\-XX\-XX\-XX\-XX
.SS "mac_is_local($mac)"
.IX Subsection "mac_is_local($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be locally administered
.SS "mac_is_universal($mac)"
.IX Subsection "mac_is_universal($mac)"
Returns true if mac address in \f(CW$mac\fR is determined to be universally administered
.SH "PROCEDURAL NORMALIZATION METHODS"
.IX Header "PROCEDURAL NORMALIZATION METHODS"
.SS "mac_as_basic($mac)"
.IX Subsection "mac_as_basic($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and without delimiters
.PP
.Vb 1
\& 001122aabbcc
.Ve
.SS "mac_as_bpr($mac)"
.IX Subsection "mac_as_bpr($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded, with \fB:\fR delimiting and
\&\fB1,length\fR leading. \fIlength\fR is the number of hex pairs (6 for \s-1EUI48\s0)
.PP
.Vb 1
\& 1,6,00:11:22:aa:bb:cc
.Ve
.SS "mac_as_cisco($mac)"
.IX Subsection "mac_as_cisco($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and with \fB.\fR delimiting every 2nd octet
(i.e. after every 4th character)
.PP
.Vb 1
\& 0011.22aa.bbcc
.Ve
.SS "mac_as_ieee($mac)"
.IX Subsection "mac_as_ieee($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and with \fB:\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 00:34:56:78:9a:bc
.Ve
.SS "mac_as_ipv6_suffix($mac)"
.IX Subsection "mac_as_ipv6_suffix($mac)"
Returns the mac address in \f(CW$mac\fR in the format used for an IPv6 autoconf address suffix
.PP
It will convert from eui48 or eui64 if needed
.SS "mac_as_microsoft($mac)"
.IX Subsection "mac_as_microsoft($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 00\-34\-56\-78\-9a\-bc
.Ve
.SS "mac_as_pgsql($mac)"
.IX Subsection "mac_as_pgsql($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and a single \fB:\fR delimiter
in the middle. this format appears in their documentation, along with single dash version
.PP
.Vb 1
\& 003456:789abc
.Ve
.SS "mac_as_singledash($mac)"
.IX Subsection "mac_as_singledash($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and has a dash in the middle of the hex string.
this appears in the pgsql documentation
.PP
.Vb 1
\& 001122\-334455
.Ve
.SS "mac_as_sun($mac)"
.IX Subsection "mac_as_sun($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is \fBnot\fR padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character)
.PP
.Vb 1
\& 0\-34\-56\-78\-9a\-bc
.Ve
.SS "mac_as_tokenring($mac)"
.IX Subsection "mac_as_tokenring($mac)"
Returns the mac address in \f(CW$mac\fR normalized as a hexadecimal string that is 0 padded and with \fB\-\fR delimiting every octet
(i.e. after every 2nd character) and each octet is bit-reversed order. So 10 00 5A 4D \s-1BC 96\s0 becomes 08 00 5A B2 3D 69.
.PP
.Vb 1
\& 00\-2d\-6a\-1e\-59\-3d
.Ve
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Prior to 0.8 every error resulted in a die (croak) which needed to be caught.
As I have used this module more, having to catch them all the time is tiresome.
So from 0.8 onward, errors result in an \fIundef\fR and something being set.
.PP
For objects, this something is accessible via \fB\f(CB$self\fB\->errstr\fR otherwise
the error is in \fB\f(CB$NetAddr::MAC::errstr\fB\fR;
.PP
If you would like to have die (croak) instead, you can either set the global
\&\fB\f(CB$NetAddr::MAC::die_on_error\fB\fR or set the \fBdie_on_error\fR option when creating
an object. When creating objects, the provided option takes priority over the
global. So if you set the global, then all objects will die \- unless you
specify otherwise.
.SS "Global examples"
.IX Subsection "Global examples"
Normal behaviour...
.PP
.Vb 3
\&  use NetAddr::MAC qw/mac_as_basic/;
\&  $mac = mac_as_basic(\*(Aqaaaa.bbbb.cccc\*(Aq)
\&      or die $NetAddr::MAC::errstr;
.Ve
.PP
If you want to catch exceptions (die/croak's)...
.PP
.Vb 2
\&  use NetAddr::MAC qw/mac_as_basic/;
\&  $NetAddr::MAC::die_on_error = 1; # (or ++ if you like)
\&
\&  eval { # or use Try::Tiny etc.
\&      $mac = mac_as_basic(\*(Aqaaaa.bbbb.cccc\*(Aq);
\&  };
\&  if ($@) {
\&      # something bad happened, so handle it
\&  }
\&  # all good, so do something
.Ve
.SS "Object examples"
.IX Subsection "Object examples"
Normal behaviour...
.PP
.Vb 3
\&  use NetAddr::MAC;
\&  my $obj = NetAddr::MAC\->new( mac => \*(Aqaabbcc112233\*(Aq)
\&      or die $NetAddr::MAC::errstr;
\&
\&  $mac = $obj\->to_eui48
\&      or die $obj\->errstr;
.Ve
.PP
If you want to catch exceptions (die/croak's)...
.PP
.Vb 2
\&  use NetAddr::MAC;
\&  my $obj = NetAddr::MAC\->new( mac => \*(Aqaabbcc112233\*(Aq, die_on_error => 1 );
\&
\&  eval { # or use Try::Tiny etc.
\&      $mac = $obj\->to_eui48
\&  };
\&  if ($@) {
\&      # something bad happened, so handle it
\&  }
\&  # all good, so do something
.Ve
.PP
Or do it globally
.PP
.Vb 3
\&  use NetAddr::MAC;
\&  $NetAddr::MAC::die_on_error = 1; # (or ++ if you like)
\&  my $obj = NetAddr::MAC\->new( mac => \*(Aqaabbcc112233\*(Aq);
\&
\&  eval { # or use Try::Tiny etc.
\&      $mac = $obj\->to_eui48
\&  };
\&  if ($@) {
\&      # something bad happened, so handle it
\&
\&  }
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
Stolen lots of ideas and some pod content from Device::MAC and Net::MAC
.SH "SEE ALSO"
.IX Header "SEE ALSO"
In some circumstances, the Regexp::Common::net might be a slimmer solution.
.PP
Net::MAC::Vendor is useful for doing vendor look up.
.PP
If you find Device::MAC or Net::MAC to be more suitable, please send
feedback so I can improve!
.SH "TODO"
.IX Header "TODO"
.Vb 3
\& \- moare tests!
\& \- find bugs, squash them
\& \- merge in your changes!
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Please use the \s-1RT\s0 system on \s-1CPAN\s0 to lodge bugs.
.PP
Many young people like to use Github, so by all means send me pull requests at
.PP
.Vb 1
\&  https://github.com/djzort/NetAddr\-MAC
.Ve
.SH "MOTIVATION"
.IX Header "MOTIVATION"
There are lots of systems at my (then) place of work which handle \s-1MAC\s0
addresses. There was lots of code validating and normalizing them all over
the place \- most of it was quirky and sloppy. So I set about creating a
reusable module to add to our \s-1SOE\s0 install so that \s-1MAC\s0 address handling
would become consistent, reliable, powerful and trivial.
.PP
Generally speaking this module fulfills that goal. It's very convenient
to be able to use \s-1MAC\s0 addresses in any format throughout those systems.
.PP
There are several other \s-1MAC\s0 address modules on \s-1CPAN. I\s0 didn't like the
interface on one, the other dragged in Moose. So I created this module,
taking the ideas I liked from the other two modules and adding in extra bits
that I needed (and a few features just for completeness) whilst avoiding
dependencies and avoiding anything that doesn't work on perl 5.6
.PP
I hope that the result is useful to others, the concept is to be able to create
an object representing a \s-1MAC\s0 address based on a string that only very vaguely
resembles a \s-1MAC\s0 address. From there, to be able to output normalized string
representations of the mac address in a variety of common formats.
.PP
A templating function is deliberately omitted, as very niche outputs can easily
be derived from the 'basic' format.
.PP
Feel free to send patches for features you add, I appreciate those who
have done so far and endeavour to incorporate new patches \s-1ASAP.\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Dean Hamstead <dean@bytefoundry.com.au>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Dean Hamstad.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
