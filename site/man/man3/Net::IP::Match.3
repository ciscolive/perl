.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::IP::Match 3"
.TH Net::IP::Match 3 "2010-06-19" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IP::Match \- Efficiently match IP addresses against IP ranges
.SH "VERSION"
.IX Header "VERSION"
version 1.101700
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::IP::Match;
\&
\&  if(_\|_MATCH_IP($_, qw{10.0.0.0/8 87.134.66.128
\&    87.134.87.0/24 145.97.0.0/16})) {
\&        # ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides you with an efficient way to match an \s-1IP\s0
address against one or more \s-1IP\s0 ranges. Speed is the key issue here.
If you have to check several million \s-1IP\s0 addresses, as can happen
with big logs, every millisecond counts. If your way to check an
address involves a method call and some temporary variables, a lot
of time is burnt. In such a time-critical loop you don't want to
make subroutine calls at all, as they involve stack operations.
.PP
So the approach we take here is that of a macro, preprocessed
through Perl's source filter mechanism.
.PP
You get a function (or at least something that looks like a function)
called \f(CW\*(C`_\|_MATCH_IP\*(C'\fR that takes a string that is to be matched
against one or more \s-1IP\s0 ranges which are specified as the remaining
args. The first argument can be a literal string or a variable;
the other args can only be literal strings.
.PP
The function returns a boolean value depending on whether there is
a match.
.PP
For example, the following are legal:
.PP
.Vb 3
\&  _\|_MATCH_IP(\*(Aq192.168.1.4\*(Aq, \*(Aq192.168.0.0/16\*(Aq)
\&  _\|_MATCH_IP(\*(Aq192.168.1.4\*(Aq, \*(Aq10.0.0.0/8\*(Aq, \*(Aq202.175.29.0/24\*(Aq)
\&  _\|_MATCH_IP($some_ip, qw{ 10.0.0.0/8 202.175.29.0/24 })
.Ve
.PP
The following won't work because the source filter doesn't handle
nested parentheses:
.PP
.Vb 1
\&  _\|_MATCH_IP(\*(Aq192.168.1.4\*(Aq, (\*(Aq10.0.0.0/8\*(Aq, \*(Aq202.175.29.0/24\*(Aq))
.Ve
.PP
The following won't work because the source filter is invoked at
compile-time, so the ranges to be transformed need to be known at
that time:
.PP
.Vb 1
\&  _\|_MATCH_IP($some_ip, @ranges)
.Ve
.SH "INTERNALS"
.IX Header "INTERNALS"
The source filter turns this function into a series of bit shift
and short-circuit logical \s-1OR\s0 operations. No subroutine calls are
involved. For example, the following call:
.PP
.Vb 1
\&  _\|_MATCH_IP(\*(Aq192.168.1.4\*(Aq, qw{ 10.0.0.0/8 192.168.0.0/16 })
.Ve
.PP
would be turned into:
.PP
.Vb 4
\&  do {
\&    my $_\|_tmp_match_ip = unpack("N", pack("C4", split(/\e./, \*(Aq192.168.1.4\*(Aq)));
\&    10 == $_\|_tmp_match_ip >> 24 || 49320 == $_\|_tmp_match_ip >> 16
\&  }
.Ve
.PP
As a special case, if you're matching against a specific \s-1IP\s0 address
(as opposed to a range), no bit shifts are involved:
.PP
.Vb 1
\&  _\|_MATCH_IP($some_ip, qw{ 10.0.0.0/8 192.168.1.4 })
.Ve
.PP
becomes
.PP
.Vb 4
\&  do {
\&    my $_\|_tmp_match_ip = unpack("N", pack("C4", split(/\e./, $some_ip)));
\&    10 == $_\|_tmp_match_ip >> 24 || 3232235780 == $_\|_tmp_match_ip
\&  }
.Ve
.PP
Furthermore, if there is only one \s-1IP\s0 range to match against, the
temporary variable and the do-block aren't necessary either:
.PP
.Vb 1
\&  _\|_MATCH_IP($some_ip, \*(Aq192.168.0.0/16\*(Aq)
.Ve
.PP
becomes:
.PP
.Vb 1
\&  (49320 == unpack("N", pack("C4", split(/\e./, $some_ip))) >> 16)
.Ve
.PP
and that's about as efficient as it gets.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you want to see the output of the source filter, set \f(CW$::debug\fR
to a true value by the time the source filter runs. One way to
achieve this is:
.PP
.Vb 1
\&  perl \-s my_program.pl \-debug
.Ve
.SH "ALTERNATIVE APPROACHES"
.IX Header "ALTERNATIVE APPROACHES"
Of course, a C implementation would have been even faster, but you
would have to call it as a function, which would add the stack
overhead. Richard Clamp had the interesting idea of optimizing the
generated opcode tree.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
See perlmodinstall for information and options on installing Perl modules.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests through the web interface at
<http://rt.cpan.org>.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
The latest version of this module is available from the Comprehensive Perl
Archive Network (\s-1CPAN\s0). Visit <http://www.perl.com/CPAN/> to find a \s-1CPAN\s0
site near you, or see
<http://search.cpan.org/dist/Net\-IP\-Match/>.
.PP
The development version lives at
<http://github.com/hanekomu/Net\-IP\-Match/>.
Instead of sending patches, please fork this project using the standard git
and github infrastructure.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  Marcel Gruenauer <marcel@cpan.org>
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2002 by Marcel Gruenauer.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
