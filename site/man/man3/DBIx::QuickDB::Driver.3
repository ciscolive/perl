.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::QuickDB::Driver 3"
.TH DBIx::QuickDB::Driver 3 "2020-08-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::QuickDB::Driver \- Base class for DBIx::QuickDB drivers.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Base class for DBIx::QuickDB drivers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package DBIx::QuickDB::Driver::MyDriver;
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqDBIx::QuickDB::Driver\*(Aq;
\&
\&    use DBIx::QuickDB::Util::HashBase qw{ ... };
\&
\&    sub viable { ... ? 1 : (0, "This driver will not work because ...") }
\&
\&    sub init {
\&        my $self = shift;
\&
\&        $self\->SUPER::init();
\&
\&        ...
\&    }
\&
\&    # Methods most drivers should implement
\&
\&    sub version_string { ... }
\&    sub socket         { ... }
\&    sub load_sql       { ... }
\&    sub bootstrap      { ... }
\&    sub connect_string { ... }
\&    sub start_command  { ... }
\&    sub shell_command  { ... }
\&
\&    # Implement if necessary
\&    sub write_config { ... }
\&    sub stop_sig { return $SIG }
\&
\&    1;
.Ve
.SH "METHODS PROVIDED HERE"
.IX Header "METHODS PROVIDED HERE"
.ie n .IP "$bool = $db\->autostart" 4
.el .IP "\f(CW$bool\fR = \f(CW$db\fR\->autostart" 4
.IX Item "$bool = $db->autostart"
True if this db was created with 'autostart' requested.
.ie n .IP "$bool = $db\->autostop" 4
.el .IP "\f(CW$bool\fR = \f(CW$db\fR\->autostop" 4
.IX Item "$bool = $db->autostop"
True if this db was created with 'autostop' requested.
.ie n .IP "$db\->cleanup" 4
.el .IP "\f(CW$db\fR\->cleanup" 4
.IX Item "$db->cleanup"
This will completely delete the database directory. \fB\s-1BE CAREFUL\s0\fR.
.ie n .IP "$dbh = $db\->\fBconnect()\fR" 4
.el .IP "\f(CW$dbh\fR = \f(CW$db\fR\->\fBconnect()\fR" 4
.IX Item "$dbh = $db->connect()"
.PD 0
.ie n .IP "$dbh = $db\->connect($db_name)" 4
.el .IP "\f(CW$dbh\fR = \f(CW$db\fR\->connect($db_name)" 4
.IX Item "$dbh = $db->connect($db_name)"
.ie n .IP "$dbh = $db\->connect($db_name, %connect_params)" 4
.el .IP "\f(CW$dbh\fR = \f(CW$db\fR\->connect($db_name, \f(CW%connect_params\fR)" 4
.IX Item "$dbh = $db->connect($db_name, %connect_params)"
.PD
Connect to the database server. If no \f(CW%connect_params\fR are specified then
\&\f(CW\*(C`(AutoCommit => 1)\*(C'\fR will be used.
.Sp
Behavior for an undef (or omitted) \f(CW$db_name\fR is driver specific.
.Sp
This will use the username in \f(CW\*(C`username()\*(C'\fR and the password in \f(CW\*(C`password()\*(C'\fR.
The connection string is defined by \f(CW\*(C`connect_string()\*(C'\fR which must be overriden
in each driver subclass.
.Sp
\&\fB\s-1NOTE:\s0\fR connect will hide all \s-1DBI\s0 and driver specific environment variables
when it establishes a connection. If you want any environment variables to be
used you must set them in the \f(CW\*(C`$db\->env_vars()\*(C'\fR hashref.
.ie n .IP "$path = $db\->dir" 4
.el .IP "\f(CW$path\fR = \f(CW$db\fR\->dir" 4
.IX Item "$path = $db->dir"
Get the path to the database directory.
.ie n .IP "$db\->init" 4
.el .IP "\f(CW$db\fR\->init" 4
.IX Item "$db->init"
This is called automatically during object construction. You \fB\s-1SHOULD NOT\s0\fR call
this directly, except in a subclass which overrides \f(CW\*(C`init()\*(C'\fR.
.ie n .IP "$path = $db\->log_file" 4
.el .IP "\f(CW$path\fR = \f(CW$db\fR\->log_file" 4
.IX Item "$path = $db->log_file"
If the database is running this will point to the log file. If the database is
not yet running, or has been stopped, this will be undef.
.ie n .IP "$driver_name = $db\->name" 4
.el .IP "\f(CW$driver_name\fR = \f(CW$db\fR\->name" 4
.IX Item "$driver_name = $db->name"
Get the short name of the driver ('DBIx::QuickDB::Driver::' has been stripped).
.ie n .IP "$pw = $db\->password" 4
.el .IP "\f(CW$pw\fR = \f(CW$db\fR\->password" 4
.IX Item "$pw = $db->password"
.PD 0
.ie n .IP "$db\->password($pw)" 4
.el .IP "\f(CW$db\fR\->password($pw)" 4
.IX Item "$db->password($pw)"
.PD
Get/Set the password to use when calling \f(CW\*(C`connect()\*(C'\fR.
.ie n .IP "$pid = $db\->pid" 4
.el .IP "\f(CW$pid\fR = \f(CW$db\fR\->pid" 4
.IX Item "$pid = $db->pid"
.PD 0
.ie n .IP "$db\->pid($pid)" 4
.el .IP "\f(CW$db\fR\->pid($pid)" 4
.IX Item "$db->pid($pid)"
.PD
If the server is running then this will have the pid. If the server is stopped
this will be undef.
.Sp
\&\fB\s-1NOTE:\s0\fR This will also be undef if the server is running independantly of this
object, if the server is running, but this is undef, it means another
object/process is in control of it.
.ie n .IP "$pid = $db\->root_pid" 4
.el .IP "\f(CW$pid\fR = \f(CW$db\fR\->root_pid" 4
.IX Item "$pid = $db->root_pid"
This should contain the original pid of the process in which the instance was
created.
.ie n .IP "$db\->run_command(\e@cmd)" 4
.el .IP "\f(CW$db\fR\->run_command(\e@cmd)" 4
.IX Item "$db->run_command(@cmd)"
.PD 0
.ie n .IP "$db\->run_command(\e@cmd, \e%params)" 4
.el .IP "\f(CW$db\fR\->run_command(\e@cmd, \e%params)" 4
.IX Item "$db->run_command(@cmd, %params)"
.ie n .IP "($pid, $logfile) = $db\->run_command(\e@cmd, {no_wait => 1})" 4
.el .IP "($pid, \f(CW$logfile\fR) = \f(CW$db\fR\->run_command(\e@cmd, {no_wait => 1})" 4
.IX Item "($pid, $logfile) = $db->run_command(@cmd, {no_wait => 1})"
.PD
This will execute the command specified in \f(CW@cmd\fR. If the command fails an
exception will be thrown. By default all output will be captured into log files
and ignored. If the command fails the output will be attached to the exception.
Normally this will block until the command exits. if \f(CW\*(C`verbose()\*(C'\fR is set then
all output is always shown.
.Sp
Normally there is no return value. If the 'no_wait' param is specified then
the command will be run non-blocking and the pid and log file will be returned.
.Sp
\&\fB\s-1NOTE:\s0\fR \f(CW\*(C`run_command()\*(C'\fR will clear any \s-1DBI\s0 and driver specific environment
variables before running any commands. If you want any of the vars to be set
then you must set them in the \f(CW\*(C`$db\->env_vars()\*(C'\fR hashref.
.Sp
Allowed params:
.RS 4
.IP "no_log => bool" 4
.IX Item "no_log => bool"
Show the output in realtime, do not redirect it.
.IP "no_wait => bool" 4
.IX Item "no_wait => bool"
Do not block, instead return the pid and log file to use later.
.IP "stdin => path_to_file" 4
.IX Item "stdin => path_to_file"
Run the command with the specified file is input.
.RE
.RS 4
.RE
.ie n .IP "$db\->shell" 4
.el .IP "\f(CW$db\fR\->shell" 4
.IX Item "$db->shell"
Launch a database shell. This depends on the \f(CW\*(C`shell_command\*(C'\fR method, which
drivers should provide. Not all driver may support this.
.ie n .IP "$bool = $db\->should_cleanup" 4
.el .IP "\f(CW$bool\fR = \f(CW$db\fR\->should_cleanup" 4
.IX Item "$bool = $db->should_cleanup"
True if the instance was created with the 'cleanup' specification. If this is
true then the database directory will be deleted when the program ends.
.ie n .IP "$db\->start" 4
.el .IP "\f(CW$db\fR\->start" 4
.IX Item "$db->start"
Start the database. Most drivers will make this a no-op if the db is already
running.
.ie n .IP "$db\->stop" 4
.el .IP "\f(CW$db\fR\->stop" 4
.IX Item "$db->stop"
Stop the database. Most drivers will make this a no-op if the db is already
stopped.
.ie n .IP "$user = $db\->username" 4
.el .IP "\f(CW$user\fR = \f(CW$db\fR\->username" 4
.IX Item "$user = $db->username"
.PD 0
.ie n .IP "$db\->username($user)" 4
.el .IP "\f(CW$db\fR\->username($user)" 4
.IX Item "$db->username($user)"
.PD
Get/set the username to use in \f(CW\*(C`connect()\*(C'\fR.
.ie n .IP "$bool = $db\->verbose" 4
.el .IP "\f(CW$bool\fR = \f(CW$db\fR\->verbose" 4
.IX Item "$bool = $db->verbose"
.PD 0
.ie n .IP "$db\->verbose($bool)" 4
.el .IP "\f(CW$db\fR\->verbose($bool)" 4
.IX Item "$db->verbose($bool)"
.PD
If this is true then all output from \f(CW\*(C`run_command\*(C'\fR will be shown at all times.
.ie n .IP "$clone = $db\->\fBclone()\fR" 4
.el .IP "\f(CW$clone\fR = \f(CW$db\fR\->\fBclone()\fR" 4
.IX Item "$clone = $db->clone()"
.PD 0
.ie n .IP "$clone = $db\->clone(%params)" 4
.el .IP "\f(CW$clone\fR = \f(CW$db\fR\->clone(%params)" 4
.IX Item "$clone = $db->clone(%params)"
.PD
Create a copy of the database. This database should be identical, except it
should not share any state changes moving forward, that means a new copy of all
data, etc.
.ie n .IP "%data = $db\->\fBclone_data()\fR" 4
.el .IP "\f(CW%data\fR = \f(CW$db\fR\->\fBclone_data()\fR" 4
.IX Item "%data = $db->clone_data()"
Data to use when cloning
.ie n .IP "$db\->\fBwrite_config()\fR" 4
.el .IP "\f(CW$db\fR\->\fBwrite_config()\fR" 4
.IX Item "$db->write_config()"
no-op on the base class, used in cloning.
.ie n .IP "$sig = $db\->\fBstop_sig()\fR" 4
.el .IP "\f(CW$sig\fR = \f(CW$db\fR\->\fBstop_sig()\fR" 4
.IX Item "$sig = $db->stop_sig()"
What signal to send to the database server to stop it. Default: \f(CW\*(AqTERM\*(Aq\fR.
.ie n .IP "$db\->\s-1DESTROY\s0" 4
.el .IP "\f(CW$db\fR\->\s-1DESTROY\s0" 4
.IX Item "$db->DESTROY"
Used to stop the server and delete the data dir (if desired) when the program
exits.
.SH "ENVIRONMENT VARIABLE HANDLING"
.IX Header "ENVIRONMENT VARIABLE HANDLING"
All \s-1DBI\s0 and driver specific environment variables will be hidden Whenever a
driver uses \f(CW\*(C`run_command()\*(C'\fR or when the \f(CW\*(C`connect()\*(C'\fR method is called. This is
to prevent you from accidentally connecting to a real/production database
unintentionally.
.PP
If there are \s-1DBI\s0 or driver specific env vars you want to be honored you must
add them to the hashref returned by \f(CW\*(C`$db\->env_vars\*(C'\fR. Any vars set in the
\&\f(CW\*(C`env_vars\*(C'\fR hashref will be set during \f(CW\*(C`connect()\*(C'\fR and \f(CW\*(C`run_command()\*(C'\fR.
.SS "\s-1ENVIRONMENT VARIABLE METHODS\s0"
.IX Subsection "ENVIRONMENT VARIABLE METHODS"
.ie n .IP "$hashref = $db\->\fBenv_vars()\fR" 4
.el .IP "\f(CW$hashref\fR = \f(CW$db\fR\->\fBenv_vars()\fR" 4
.IX Item "$hashref = $db->env_vars()"
Get the hashref of env vars to set whenever \f(CW\*(C`run_command()\*(C'\fR, \f(CW\*(C`connect()\*(C'\fR,
\&\f(CW\*(C`do_in_env()\*(C'\fR, or \f(CW\*(C`mask_env_vars()\*(C'\fR are called.
.Sp
You cannot replace te hashref, but you are free to add/remove keys.
.ie n .IP "@vars = $db\->list_env_vars" 4
.el .IP "\f(CW@vars\fR = \f(CW$db\fR\->list_env_vars" 4
.IX Item "@vars = $db->list_env_vars"
This will return a list of all \s-1DBI\s0 and driver-specific environment variables.
This is just a list of variable names, not their values.
.Sp
The base class provides the following list, drivers may add more:
.RS 4
.IP "\s-1DBI_USER\s0" 4
.IX Item "DBI_USER"
.PD 0
.IP "\s-1DBI_PASS\s0" 4
.IX Item "DBI_PASS"
.IP "\s-1DBI_DSN\s0" 4
.IX Item "DBI_DSN"
.RE
.RS 4
.RE
.ie n .IP "$db\->do_in_env(sub { ... })" 4
.el .IP "\f(CW$db\fR\->do_in_env(sub { ... })" 4
.IX Item "$db->do_in_env(sub { ... })"
.PD
This will execute the provided codeblock with the environment variables masked,
and any vars listed in \f(CW\*(C`env_vars()\*(C'\fR will be set. Once the codeblock is
complete the old environment vars will be unmaskd, even if an exception is
thrown.
.Sp
\&\fB\s-1NOTE:\s0\fR The return value of the codeblock is ignored.
.ie n .IP "$old = $db\->mask_env_vars" 4
.el .IP "\f(CW$old\fR = \f(CW$db\fR\->mask_env_vars" 4
.IX Item "$old = $db->mask_env_vars"
.PD 0
.ie n .IP "$db\->unmask_env_vars($old)" 4
.el .IP "\f(CW$db\fR\->unmask_env_vars($old)" 4
.IX Item "$db->unmask_env_vars($old)"
.PD
These methods are used to mask/unmask \s-1DBI\s0 and driver specific environment
variables.
.Sp
The first method will completely clear any DBI/driver environment variables,
then apply any variables in the \f(CW\*(C`env_vars()\*(C'\fR hash. The value returned is a
hashref needed to unmask/restore the original environment variables later.
.Sp
The second method will unmask/restore the original environment variables using
the hashref returned by the first.
.SH "METHODS SUBCLASSES SHOULD PROVIDE"
.IX Header "METHODS SUBCLASSES SHOULD PROVIDE"
Drivers may override \f(CW\*(C`clone()\*(C'\fR or \f(CW\*(C`clone_data()\*(C'\fR to control cloning.
.ie n .IP "($bool, $why) = $db\->\fBviable()\fR" 4
.el .IP "($bool, \f(CW$why\fR) = \f(CW$db\fR\->\fBviable()\fR" 4
.IX Item "($bool, $why) = $db->viable()"
.PD 0
.ie n .IP "($bool, $why) = $db\->viable(\e%spec)" 4
.el .IP "($bool, \f(CW$why\fR) = \f(CW$db\fR\->viable(\e%spec)" 4
.IX Item "($bool, $why) = $db->viable(%spec)"
.PD
This should check if it is possible to launch this db type on the current
system with the given spec.
.Sp
See \*(L"\s-1SPEC HASH\*(R"\s0 in DBIx::QuickDB for what might be in \f(CW%spec\fR.
.Sp
The first return value is a simple boolean, true if the driver is viable, false
if it is not. The second value should be an explanation as to why the driver is
not viable (in cases where it is not).
.ie n .IP "$string = \fBYour::Driver::version_string()\fR" 4
.el .IP "\f(CW$string\fR = \fBYour::Driver::version_string()\fR" 4
.IX Item "$string = Your::Driver::version_string()"
.PD 0
.ie n .IP "$string = Your::Driver::version_string(\e%PARAMS)" 4
.el .IP "\f(CW$string\fR = Your::Driver::version_string(\e%PARAMS)" 4
.IX Item "$string = Your::Driver::version_string(%PARAMS)"
.ie n .IP "$string = Your::Driver\->\fBversion_string()\fR" 4
.el .IP "\f(CW$string\fR = Your::Driver\->\fBversion_string()\fR" 4
.IX Item "$string = Your::Driver->version_string()"
.ie n .IP "$string = Your::Driver\->version_string(\e%PARAMS)" 4
.el .IP "\f(CW$string\fR = Your::Driver\->version_string(\e%PARAMS)" 4
.IX Item "$string = Your::Driver->version_string(%PARAMS)"
.ie n .IP "$string = $db\->\fBversion_string()\fR" 4
.el .IP "\f(CW$string\fR = \f(CW$db\fR\->\fBversion_string()\fR" 4
.IX Item "$string = $db->version_string()"
.ie n .IP "$string = $db\->version_string(\e%PARAMS)" 4
.el .IP "\f(CW$string\fR = \f(CW$db\fR\->version_string(\e%PARAMS)" 4
.IX Item "$string = $db->version_string(%PARAMS)"
.PD
The default implementation returns 'unknown'.
.Sp
This is complicated because it can be called as a function, a class method, or
an object method. It can also optionally be called with a hashref of \s-1PARAMS\s0
that \s-1MAY\s0 be later used to construct an instance.
.Sp
Lets assume your driver uses the \f(CW\*(C`start_my_db\*(C'\fR command to launch a database.
Normally you default to the \f(CW\*(C`start_my_db\*(C'\fR found in the \f(CW$PATH\fR environment
variable. Alternatively someone can pass in an alternative path to the binary
with the 'launcher' parameter. Here is a good implementation:
.Sp
.Vb 1
\&    use Scalar::Util qw/reftype/;
\&
\&    sub version_string {
\&        my $binary;
\&
\&        # Go in reverse order assuming the last param hash provided is most important
\&        for my $arg (reverse @_) {
\&            my $type = reftype($arg) or next; # skip if not a ref
\&            next $type eq \*(AqHASH\*(Aq; # We have a hashref, possibly blessed
\&
\&            # If we find a launcher we are done looping, we want to use this binary.
\&            $binary = $arg\->{launcher} and last;
\&        }
\&
\&        # If no args provided one to use we fallback to the default from $PATH
\&        $binary ||= DEFAULT_BINARY;
\&
\&        # Call the binary with \*(Aq\-V\*(Aq, capturing and returning the output using backticks.
\&        return \`$binary \-V\`;
\&    }
.Ve
.ie n .IP "$socket = $db\->\fBsocket()\fR" 4
.el .IP "\f(CW$socket\fR = \f(CW$db\fR\->\fBsocket()\fR" 4
.IX Item "$socket = $db->socket()"
Unix Socket used to communicate with the db. If the db type does not use
sockets (such as SQLite) then this can be skipped. \fB\s-1NOTE:\s0\fR If you skip this
you will need to override \f(CW\*(C`stop()\*(C'\fR and \f(CW\*(C`start()\*(C'\fR to account for it. See
DBIx::QuickDB::Driver::SQLite for an example.
.ie n .IP "$db\->load_sql($db_name, $file)" 4
.el .IP "\f(CW$db\fR\->load_sql($db_name, \f(CW$file\fR)" 4
.IX Item "$db->load_sql($db_name, $file)"
Load the specified sql file into the specified db. It is possible that
\&\f(CW$db_name\fR will be undef in some drivers.
.ie n .IP "$db\->\fBbootstrap()\fR" 4
.el .IP "\f(CW$db\fR\->\fBbootstrap()\fR" 4
.IX Item "$db->bootstrap()"
Initialize the database server and create the 'quickdb' database.
.ie n .IP "$string = $db\->\fBconnect_string()\fR" 4
.el .IP "\f(CW$string\fR = \f(CW$db\fR\->\fBconnect_string()\fR" 4
.IX Item "$string = $db->connect_string()"
.PD 0
.ie n .IP "$string $db\->connect_string($db_name)" 4
.el .IP "\f(CW$string\fR \f(CW$db\fR\->connect_string($db_name)" 4
.IX Item "$string $db->connect_string($db_name)"
.PD
String to pass into \f(CW\*(C`DBI\->connect\*(C'\fR.
.Sp
Example: \f(CW"dbi:Pg:dbname=$db_name;host=$socket"\fR
.ie n .IP "@cmd = $db\->\fBstart_command()\fR" 4
.el .IP "\f(CW@cmd\fR = \f(CW$db\fR\->\fBstart_command()\fR" 4
.IX Item "@cmd = $db->start_command()"
Command used to start the server.
.ie n .IP "@cmd = $db\->\fBshell_command()\fR" 4
.el .IP "\f(CW@cmd\fR = \f(CW$db\fR\->\fBshell_command()\fR" 4
.IX Item "@cmd = $db->shell_command()"
Command used to launch a shell into the database.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for DBIx-QuickDB can be found at
\&\fIhttps://github.com/exodist/DBIx\-QuickDB/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
