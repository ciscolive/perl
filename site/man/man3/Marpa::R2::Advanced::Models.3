.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Advanced::Models 3"
.TH Marpa::R2::Advanced::Models 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Advanced::Models \- Other input models
.SH "About this document"
.IX Header "About this document"
The alternative input models described in this document are an
advanced technique.
If you are starting out with Marpa, you
probably want to ignore this document.
If you are an experienced Marpa user,
it is still safe to ignore this document,
but you might find the possibilities it discusses
interesting.
.SH "Marpa has two different ideas of location"
.IX Header "Marpa has two different ideas of location"
In the other Marpa documentation,
we have spoken of \*(L"location\*(R",
and assumed the standard input model.
The locations actually in use by the methods
described for the standard input model were Earley set
ordinals.
(An Earley set's ordinal is also its \s-1ID.\s0)
.PP
Marpa actually has two different ideas of location \*(--
Earley set ordinal and earleme.
This is ignored in the other Marpa documents,
and it can be, because they
assume the standard input model.
Use of the standard input model
guarantees that earleme
and Earley set ordinal
will always be exactly the same.
.PP
This document introduces methods which make it
possible (and in fact likely) that earleme and 
Earley set ordinal will differ.
From here on,
the reader will need to pay careful attention
to the distinction.
.SH "What is an alternative input model?"
.IX Header "What is an alternative input model?"
An alternative input model
is anything that is not the default, token-stream model.
More helpfully, Marpa allows variable-length tokens and ambiguous tokens,
and an alternative input model is any input model which
.IP "\(bu" 4
Allows a token whose length is not exactly 1, or
.IP "\(bu" 4
Allows locations which have more than one token.
.PP
To do either of these things,
a user must use the recognizer's \f(CW\*(C`alternative\*(C'\fR
method.
In other words,
if an application is not directly
using the recognizer's \f(CW\*(C`alternative\*(C'\fR method call,
that application is not using an alternative input method.
.PP
Many concepts, such as parsing location,
parse exhaustion,
and the end of parsing,
are somewhat more complicated when alternative
input models are involved.
These concepts were explained in the main document for
the recognizer on the assumption
that the default input model was in use.
This document revises those explanations as necessary
to take into
account the alternative input models.
.SH "Token streams"
.IX Header "Token streams"
Marpa's default input model is the traditional one \*(--
a token stream.
Token streams are very standard in parsing applications \*(--
so much so
that most texts do not take the trouble
of defining the term.
A \fBtoken stream\fR is input structured as
a sequence of tokens,
where each token occupies one location
and every location has a token.
In the token stream model, all tokens are
of the same length.
.PP
Conventionally, all tokens are of length 1,
and the token stream starts at location 0.
Following this convention,
the \fIN\fRth token would start at
location \fIN\-1\fR and end
at location \fIN\fR.
For example,
the first token would start at location 0 and end at location 1.
The second token would start at location 1 and end at location 2.
.SH "Earlemes"
.IX Header "Earlemes"
For most parsers, position is location in a token stream.
To deal with variable-length and overlapping tokens,
Marpa needs a more flexible idea of location.
.PP
Marpa's tracks position in terms of \fBearlemes\fR.
\&\fBEarlemes\fR are named after Jay Earley,
the inventor of the first algorithm
in Marpa's lineage.
Every token has a start earleme and an end earleme.
.PP
The token stream model may also be called the token-per-earleme
model.
In the token stream model,
token location and earleme location
are exactly identical.
More formally, in the token stream model,
if the token location is \fIN\fR,
then the earleme location is also \fIN\fR.
If a user's application uses the token stream model,
the user can ignore the existence of earlemes,
and can think entirely in terms of
tokens and their position in a token stream.
Because of this, the main Marpa documents
often speak
simply of the \*(L"location\*(R" in the parse.
.SH "The furthest earleme"
.IX Header "The furthest earleme"
The \fBfurthest earleme\fR is the last earleme at which a token ends.
In the default input model,
the furthest earleme and the current earleme
are always the same.
As a result,
in the default input model, the furthest earleme is not an important
concept.
.PP
In alternative input models,
tokens may be longer than 1 earleme, and
the furthest earleme and the current earleme may be far apart.
This becomes an issue when
parsing is finished.
Alternative input models use
the recognizer's \f(CW\*(C`end_input\*(C'\fR method to ensure
that processing of input catches up to the furthest earleme.
.SH "The latest Earley set and latest earleme"
.IX Header "The latest Earley set and latest earleme"
The \fBlatest earleme\fR is the earleme location of the latest
Earley set.
In the default input model, the latest earleme is always the
same as the current earleme.
.PP
In alternative input models,
there may not be an Earley set at a given earleme location.
When that is the case for the current earleme,
then the latest Earley set is not at the current earleme,
and the latest earleme and current earlemes are different.
.SH "Methods"
.IX Header "Methods"
.SS "\fBalternative()\fP"
.IX Subsection "alternative()"
.Vb 1
\&    $recce\->alternative( \*(Aqa\*(Aq, \e42, 1 ) or return \*(AqFirst alternative failed\*(Aq;
.Ve
.PP
The \f(CW\*(C`alternative\*(C'\fR method is the most general method for reading
input, and is used in alternative input models.
It takes three arguments, only the first of which is required.
.PP
The first two arguments are 
the token type and a reference to the token value.
If the reference to the token value is omitted,
or is \f(CW\*(C`undef\*(C'\fR,
the value of the token will be a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
The third argument to the \f(CW\*(C`alternative\*(C'\fR method is a token
length.
If omitted, token length defaults to 1,
which is the correct value for the token stream model.
Its value can be any integer \fBgreater\fR than zero.
Marpa does not allow zero length tokens in any input model.
.PP
Unlike the \f(CW\*(C`read\*(C'\fR method, the \f(CW\*(C`alternative\*(C'\fR method does
\&\fBnot\fR advance the current location
(current earleme) on each call.
This allows the application to read several tokens
at the same earleme.
This is how ambiguous input is created.
To advance the current earleme when
input is read using the \f(CW\*(C`alternative\*(C'\fR method,
the \f(CW\*(C`complete_earleme\*(C'\fR method must be called.
.PP
On success, \f(CW\*(C`alternative\*(C'\fR returns a Perl true value.
If the token is rejected, \f(CW\*(C`alternative\*(C'\fR returns a Perl false.
On other failures, \f(CW\*(C`alternative\*(C'\fR throws an exception.
.SS "\fBcurrent_earleme()\fP"
.IX Subsection "current_earleme()"
.Vb 1
\&    $current_earleme = $recce\->current_earleme();
.Ve
.PP
Returns the current parse location,
also known as the current earleme.
Not often needed.
.SS "\fBearleme()\fP"
.IX Subsection "earleme()"
.Vb 1
\&      my $origin_earleme = $recce\->earleme($origin_earley_set_id);
.Ve
.PP
Given an Earley set \s-1ID\s0 as its argument,
the \f(CW\*(C`earleme()\*(C'\fR recognizer method
returns the corresponding earleme.
Every integer in the range from 0
to the \s-1ID\s0 of the latest Earley
is a valid Earley set \s-1ID,\s0
and every valid Earley set \s-1ID\s0 corresponds to an
earleme.
If the argument of \f(CW\*(C`earleme()\*(C'\fR is
greater than the latest Earley set \s-1ID,\s0
\&\f(CW\*(C`earleme()\*(C'\fR returns Perl \f(CW\*(C`undef\*(C'\fR.
.PP
There is currently no method that translates from
earleme to Earley set.
Earley set to earleme translation is a well-behaved
one-to-one function
in all input models \*(-- for every Earley set there is
a earleme,
and every earleme is mapped to by at most one Earley set.
Earleme to Earley set translation is far less well-behaved.
In many input models, it is a partial function \*(-- there
are some earlemes that are
in the valid range of earlemes
but do not map to any Earley set.
.PP
Earleme to Earley set translation is often not needed.
When it is, it can be implemented at the application
level, with the application taking advantage of what
it knows about its choice of input model.
.SS "\fBearleme_complete()\fP"
.IX Subsection "earleme_complete()"
.Vb 1
\&    $recce\->earleme_complete();
.Ve
.PP
Processes all tokens at the current earleme and advances the current
earleme by 1.
If the earleme cannot be completed,
an exception is thrown.
Otherwise, an \*(L"event\*(R" count is returned.
If zero is returned, the earleme was completed without event.
In this context,
an \*(L"event\*(R" is one of a list of occurrences of special interest during
the successful completion of an earleme,
as described for
the recognizer's \f(CW\*(C`read\*(C'\fR method.
.PP
All tokens read using the \f(CW\*(C`alternative\*(C'\fR method start at one
location \*(-- the current earleme.
When reading input using the \f(CW\*(C`alternative\*(C'\fR method,
\&\f(CW\*(C`earleme_complete\*(C'\fR is used to complete processing
at the current earleme and move
forward in
the input stream.
.PP
\&\f(CW\*(C`earleme_complete\*(C'\fR may be called even if the \f(CW\*(C`alternative\*(C'\fR
method has been not called since the last
call to \f(CW\*(C`earleme_complete\*(C'\fR.
This will create an earleme with no tokens.
In certain input models,
such as the character-per-earleme model,
this can be useful.
.SS "\fBend_input()\fP"
.IX Subsection "end_input()"
.Vb 1
\&    $recce\->end_input();
.Ve
.PP
Indicates that input is finished.
Calling \f(CW\*(C`end_input\*(C'\fR is not necessary
or useful
in the default input model,
because in the default input model no token
has a length greater than 1.
.PP
The \f(CW\*(C`end_input\*(C'\fR method takes no arguments.
The \f(CW\*(C`end_input\*(C'\fR method returns a Perl true value on success.
On failure, it throws an exception.
.PP
In alternative input models, calling the \f(CW\*(C`earleme_complete\*(C'\fR method
once input is finished does not
ensure that all input has been processed.
The \f(CW\*(C`earleme_complete\*(C'\fR method completes the current earleme,
but in alternative models, tokens may extend well past the current earleme.
The \f(CW\*(C`end_input\*(C'\fR method ensures that all input is processed.
.PP
Calling \f(CW\*(C`end_input\*(C'\fR multiple times on the same recognizer object
is harmless,
but useless.
The second and subsequent calls will
return a Perl true,
but will have no effect.
.ie n .SH "Alternative models and ""read()"""
.el .SH "Alternative models and \f(CWread()\fP"
.IX Header "Alternative models and read()"
A recognizer can mix
calls to
its \f(CW\*(C`read\*(C'\fR
method with calls to its \f(CW\*(C`alternative\*(C'\fR
method.
The \f(CW\*(C`read\*(C'\fR method has the same effect as a single call
to the \f(CW\*(C`alternative\*(C'\fR method, followed immediately
by a call of the \f(CW\*(C`earleme_complete\*(C'\fR method.
.SH "Ambiguous lexing"
.IX Header "Ambiguous lexing"
Marpa allows ambiguous tokens.
Several Marpa tokens can start at a single parsing location.
Ambiguous tokens can be of various lengths.
Tokens can also overlap.
.PP
\&\fBPotentially
ambiguous lexing\fR
occurs when more than one token starts
at a single earleme.
When potentially ambiguous lexing occurs,
it becomes possible for there to be more
than one sequence of tokens.
.PP
An \fBactual lexical ambiguity\fR only occurs if
more than one of the potential token sequences is consistent with
the grammar.
If there is no actual lexical ambiguity,
Marpa will use the only token choice that is
consistent with the grammar.
.PP
When lexing is \fBactually ambiguous\fR, Marpa
will use all the alternatives
consistent with the grammar.
When the lexing in a parse is actually ambiguous,
the parse will be ambiguous.
From the point of view of Marpa's semantics,
ambiguities caused by lexing look the
same as ambiguities caused by an ambiguous grammar.
.PP
In the standard
terminology,
if a grammar produces more than one parse tree
for any input,
then that grammar must be ambiguous.
In Marpa this is not strictly true.
In Marpa,
if the input is ambiguous,
even an unambiguous grammar can produce more than one parse.
.SH "Duplicate tokens"
.IX Header "Duplicate tokens"
A duplicate token is a token of the same type
and the same length as another
that was read at the same earleme.
Duplicate tokens are impossible in the default, token-stream,
model.
This is because in the token-stream model only one token can be
read at each earleme.
.PP
In alternative models, more than one token may be read at
an earleme, and duplicates \fBare\fR possible.
Marpa detects duplicate tokens and treats them as
\&\*(L"hard errors\*(R" \*(--
Marpa throws an exception
when it sees a duplicate token.
Marpa's assumption is that
duplicate tokens indicate
an error at the application level.
.PP
An application can retry input after
a duplicate token, if it
catches the exception.
In the future, if recovery from duplicate tokens is found
to be a useful technique, Marpa may provide an option to change
its behavior, so that a soft failure is returned
when there is a duplicate token.
.SH "Earlemes: the details"
.IX Header "Earlemes: the details"
While scanning, Marpa keeps track of the \fBcurrent earleme\fR.
Earlemes in a parse start at earleme 0 and increase numerically.
The earleme immediately following earleme 0 is earleme 1,
the earleme immediately following earleme 1 is earleme 2,
and so on.
The earleme immediately following earleme \fIN\fR is always earleme \fIN+1\fR.
.PP
\&\fBDistance\fR in the earleme stream is
what you would intuitively expect it to be.
The distance between earleme \fIX\fR and earleme \fIY\fR is
the absolute value of the difference between \fIX\fR and \fIY\fR,
\&\fI|X\-Y|\fR.
The distance from earleme 3 to earleme 6,
for example, is 3 earlemes.
.PP
Whenever a token is given to Marpa to be scanned,
it starts at the current earleme.
In addition to the type and value of the token,
Marpa must be told the token's \fBlength\fR in earlemes.
The length of a Marpa token must be greater than zero.
.PP
This earleme length will become
the distance from the start of the
token to the end of the token.
If the length of the token is \fIL\fR,
and the current earleme is \fIC\fR,
the end of the token will be at earleme \fIC+L\fR.
.SH "The character-per-earleme model"
.IX Header "The character-per-earleme model"
Many different models of the relationship between tokens and earlemes
are possible, but two are particularly important.
One is the one-token-per-earleme model,
which is the default,
and which has already been described.
The other is the one-character-per-earleme model.
.PP
In the one-character-per-earleme model,
every character will be treated as being exactly one
earleme in length.
If a token is more than one character in length,
that token will span earlemes.
When the lexing is ambiguous, tokens may overlap.
.PP
When a one-character-per-earleme model of input is used,
there may be many earlemes at which no tokens start.
For example,
in a straightforward character-per-earleme implementation
of a grammar for a language that allows
comments,
no tokens will start at
any earlemes which correspond to character locations inside
a comment.
.SH "Other input models"
.IX Header "Other input models"
So far only the token-per-earleme and
character-per-earleme models have seen any
real use in Marpa programs.
But other models are certainly possible.
Using earlemes,
you can structure your input in almost any way you like.
.PP
There are only three restrictions:
.IP "1." 4
Scanning always starts at earleme 0.
.IP "2." 4
All tokens starting at
earleme \fIN\fR must be scanned before
any tokens starting at earleme \fIN+1\fR.
In other words, the tokens must be scanned in non-decreasing order
by start earleme.
.IP "3." 4
Every token must have a length, in earlemes,
which is greater than zero.
In other words,
token length can never
be zero or negative.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
