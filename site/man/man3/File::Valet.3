.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "File::Valet 3"
.TH File::Valet 3 "2020-10-10" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Valet \- Utilities for file slurping, locking, and finding.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use File::Valet;
\&
\&    # Simple slurp and unslurp with rd_f, wr_f, ap_f:
\&
\&    my $text = rd_f(\*(Aqsome/file.txt\*(Aq);
\&    die "slurp failure: $File::Valet::ERROR ($File::Valet::ERRNO)" unless ($File::Valet::OK eq \*(AqOK\*(Aq);
\&    # or, equivalently:
\&    die "slurp failure: $File::Valet::ERROR ($File::Valet::ERRNO)" unless (defined($text));
\&
\&    # Contents written will be same as that of "some/file.txt",
\&    # plus two lines appended at the end:
\&
\&    wr_f(\*(Aqanother/file.txt\*(Aq, $text);
\&    ap_f(\*(Aqanother/file.txt\*(Aq, "Oh, and another thing:\en");
\&    ap_f(\*(Aqanother/file.txt\*(Aq, "STOP BREATHING IN MY CUP\en");
\&
\&    # Find a place suited to temporary files:
\&    my $tmp = find_temp();  # Likely /var/tmp or /tmp or C:\eWindows\eTemp
\&
\&    # Find the full pathname of an executable:
\&    my $shell = find_bin(\*(Aqsh\*(Aq);  # Likely /bin/sh
\&
\&    # Use a lockfile for exclusive access to a shared resource:
\&    lockafile("$tmp/shared.txt") or die "cannot obtain lock: $File::Valet::ERROR ($File::Valet::ERRNO)";
\&    my $text = rd_f("$tmp/shared.txt");
\&    unlockafile("$tmp/shared.txt") or die "unlock error: $File::Valet::ERROR ($File::Valet::ERRNO)";
\&
\&    # Nested file locking:
\&    lockafile("shared.txt") or die "cannot obtain first lock";
\&    my $text = rd_f("$tmp/shared.txt");
\&    ...
\&    lockafile("shared.txt") or die "cannot obtain second lock";
\&    ap_f("$tmp/shared.txt", $data);
\&    unlockafile("$tmp/shared.txt");
\&    ...
\&    unlockafile("$tmp/shared.txt");
\&
\&    # Your code has bugs, resulting in leaving lockfiles behind, but
\&    # instead of debugging you\*(Aqd rather just remove all your locks:
\&    my ($n_errors, $n_locks, $n_files) = unlock_all_the_files();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBFile::Valet\fR contains a selection of easy-to-use subroutines for manipulating files and file content.  Some effort has been made to establish cross-platform portability, and to make their behavior as unsurprising as possible.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions are available through this module for use in other applications.  In keeping with the intent of minimizing user keystrokes, all of these functions are exported into the calling namespace.
.IP "\fBrd_f\fR" 4
.IX Item "rd_f"
.Vb 1
\& my $string = rd_f($filename);
.Ve
.Sp
\&\f(CW\*(C`rd_f()\*(C'\fR is similar to the well-known \f(CW\*(C`Slurp::to_scalar()\*(C'\fR, in that it reads the entire contents of the named file and returns it as a string.  Its principle differences are a slightly shorter name and the insertion of diagnostic information into \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR when the operation failed to complete.
.Sp
The return value is either the contents of the file \fBas a string of bytes\fR (an empty string if the file had no contents), or undef on any error.
.IP "\fBwr_f\fR" 4
.IX Item "wr_f"
.Vb 1
\& my $success = wr_f($filename, $string);
.Ve
.Sp
\&\f(CW\*(C`wr_f()\*(C'\fR is conceptually the opposite of \f(CW\*(C`rd_f()\*(C'\fR, in that it overwrites the named file's contents with the given \fBstring of bytes\fR.
.Sp
If the specified file does not exist, \f(CW\*(C`wr_f()\*(C'\fR will attempt to create it.
.Sp
Returns 1 on success, or 0 on any failure, and sets \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR appropriately.
.IP "\fBap_f\fR" 4
.IX Item "ap_f"
.Vb 1
\& my $success = ap_f($filename, $string);
.Ve
.Sp
\&\f(CW\*(C`ap_f()\*(C'\fR is similar to \f(CW\*(C`wr_f()\*(C'\fR, differing in that the specified \fBstring of bytes\fR is appended to the end of the file, rather than overwriting it.
.Sp
If the specified file does not exist, \f(CW\*(C`ap_f()\*(C'\fR will attempt to create it.
.Sp
Returns 1 on success, or 0 on any failure, and sets \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR appropriately.
.IP "\fBfind_home\fR" 4
.IX Item "find_home"
.Vb 2
\& my $path = find_home;
\& my $path = find_temp("/var/home", "/tmp/home");
.Ve
.Sp
\&\f(CW\*(C`find_home()\*(C'\fR performs a best-effort search for the effective user's home, returning a path-string or undef if none is found.
.Sp
If arguments are provided, it will return the first argument for which there is a directory for which the user has write permissions.
.Sp
if \f(CW$ENV{HOME}\fR is set, \f(CW\*(C`find_home()\*(C'\fR will check there for a writable directory after checking any arguments.
.Sp
Some effort has been made to make it cross-platform.
.IP "\fBfind_temp\fR" 4
.IX Item "find_temp"
.Vb 2
\& my $path = find_temp();
\& my $path = find_temp("/home/tmp", "/usr/tmp", ...);
.Ve
.Sp
Intended for easy cross-platform programming, \f(CW\*(C`find_temp()\*(C'\fR checks in a number of likely, common filesystem locations for a valid directory for temporary files.  It returns the first directory it finds for which the user has write permissions, or undef if none is found.
.Sp
If parameters are passed to \f(CW\*(C`find_temp()\*(C'\fR, it will check those locations first.
.Sp
If \f(CW$ENV{TEMPDIR}\fR, \f(CW$ENV{TEMP}\fR or \f(CW$ENV{TMP}\fR are defined, \f(CW\*(C`find_temp()\*(C'\fR will check those locations after checking the locations provided as parameters.
.Sp
\&\f(CW\*(C`find_temp()\*(C'\fR is Windows-savvy enough to check such locations as \*(L"C:\eWindows\eTemp\*(R", but might try to open locations on network-mounted drives if it is unable to find a local alternative.
.IP "\fBfind_home\fR" 4
.IX Item "find_home"
.Vb 2
\&  my $path = find_home();
\&  my $path = find_home("/var/home/fred");
.Ve
.Sp
Another function intended for easy cross-platform programming, \f(CW\*(C`find_home()\*(C'\fR will first check \f(CW$ENV\fR{\s-1HOME\s0} on *nix or \f(CW$ENV\fR{\s-1HOMEDIRVE\s0} and \f(CW$ENV\fR{\s-1HOMEPATH\s0 (on Windows) if defined, then in the system's passwd database, and then in a number of other likely locations, for a writable home directory for the effective user.
.Sp
It will return the full absolute path of the home directory on success, or undef on failure.
.IP "\fBfind_bin\fR" 4
.IX Item "find_bin"
.Vb 2
\& my $pathname = find_bin("ls");
\& my $pathname = find_bin("ls", "/home/ttk/bin", "/opt/bin", ...);
.Ve
.Sp
Another function intended for easy cross-platform programming, \f(CW\*(C`find_bin()\*(C'\fR will first check all of the directories in \f(CW$ENV\fR{\s-1PATH\s0} (if defined), and then in a number of other likely, common locations, for an executable file whose name matches the first parameter.  It will return the full absolute pathname of the executable file on success, or undef on failure.
.Sp
\&\f(CW\*(C`find_bin()\*(C'\fR is Windows-savvy, albeit does not search Windows systems as extensively as others.
.Sp
If directory paths are given as additional parameters, \f(CW\*(C`find_bin()\*(C'\fR will check those locations first.
.Sp
\&\f(CW\*(C`find_bin()\*(C'\fR is smart enough to only check any given directory once, even if it appears in the parameter list as well as in \f(CW$ENV\fR{\s-1PATH\s0}, or appears multiple times in either.
.Sp
\&\f(CW\*(C`find_bin()\*(C'\fR also sets \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR appropriately.
.IP "\fBlockafile\fR" 4
.IX Item "lockafile"
.Vb 6
\& my $success = lockafile("/tmp/foo", %options);
\& my $success = lockafile("/tmp/foo",
\&     limit => 2.0,  # keep retrying for 2.0 seconds before giving up
\&     msg   => \*(Aqin\-channel update\*(Aq,  # helpful message for troubleshooting
\&     nsec  => 0.5,  # we expect to hold the lock for less than 0.5 seconds
\& );
.Ve
.Sp
\&\f(CW\*(C`lockafile()\*(C'\fR applies an advisory lock on the named file, and attempts to be somewhat clever about it, automatically invalidating existing locks set by processes which no longer exist. or set a very long time ago.
.Sp
If the file is already locked by another process, \f(CW\*(C`lockafile()\*(C'\fR will linger and attempt to acquire the lock when the owner of the lock releases the file.  This linger time defaults to thirty seconds, and may be overridden with the \f(CW\*(C`limit\*(C'\fR parameter.
.Sp
The advisory lock takes the form of a file, which may be manually deleted to remove the lock, or may be inspected to learn something about the process which created the lock.  To facilitate this, a message may be embedded in the lock file describing the reason the file is being locked.  It defaults to \*(L"programmer is lazy\*(R", and may be set by passing the \f(CW\*(C`msg\*(C'\fR parameter.
.Sp
Advisory locks will be respected by other invocations of \f(CW\*(C`lockafile()\*(C'\fR for up to some time before being assumed stale and forceably removed.  This period may be increased by passing the \f(CW\*(C`nsec\*(C'\fR parameter (which becomes embedded in the lockfile).
.Sp
\&\f(CW\*(C`lockafile()\*(C'\fR attempts to manage nested advisory locks via \f(CW%File::Valet::LOCKS_HASH\fR.  \f(CW\*(C`lockafile()\*(C'\fR will keep track of which files the caller has locked, and how many times.  Thus if the caller locks the same file two or more times, and unlocks it an equal number of times, the lock file will only be created on the first invocation of \f(CW\*(C`lockafile()\*(C'\fR, and removed only on the last invocation of \f(CW\*(C`unlockafile()\*(C'\fR.  See \fB\s-1FURTHER DEVELOPMENT\s0\fR for caveats regarding this.
.Sp
Returns 1 on success, or 0 on any failure, and sets \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR appropriately.
.IP "\fBunlockafile\fR" 4
.IX Item "unlockafile"
.Vb 1
\& my $success = unlockafile("/tmp/foo", %options);
.Ve
.Sp
\&\f(CW\*(C`unlockafile()\*(C'\fR reverses the action of \f(CW\*(C`lockafile()\*(C'\fR, removing an advisory lock on a file (or reducing the count of locks on a multiply-locked file).
.Sp
\&\f(CW\*(C`unlockafile()\*(C'\fR will fail if invoked on a file which is not locked, or has been locked by a different process.
.Sp
\&\f(CW\*(C`unlockafile()\*(C'\fR returns 1 on success, and 0 on any failure, and sets \f(CW$File::Valet::OK\fR, \f(CW$File::Valet::ERROR\fR, \f(CW$File::Valet::ERRNO\fR appropriately.
.IP "\fBunlock_all_the_files\fR" 4
.IX Item "unlock_all_the_files"
\&\f(CW\*(C`unlock_all_the_files()\*(C'\fR is a convenience wrapper for walking \f(CW%File::Valet::LOCKS_HASH\fR and safely removing all lockfiles.
.Sp
If your code has bugs which cause it to leave lockfiles behind, then calling \f(CW\*(C`unlock_all_the_files()\*(C'\fR before exiting will help prevent that.
.Sp
Really, though, you should fix your bugs.
.Sp
Returns three values:  A count of errors returned by \f(CW\*(C`unlockafile()\*(C'\fR, a count of locks removed, and a count of lock files removed.
.Sp
The number of locks can differ from the number of lock files when locks are nested.  A file which is locked twice counts as two locks but has only one lock file.
.IP "\fB\s-1LOCKFILE FORMAT\s0\fR" 4
.IX Item "LOCKFILE FORMAT"
The lockfiles contain useful bits of information which help \f(CW\*(C`lockafile\*(C'\fR figure out if it should override someone else's lock, and is also useful for gaining insight about the system's behavior, for troubleshooting purposes.
.Sp
Its fields are tab-delimited, and the file terminates with a newline.  They appear in this order:
.Sp
.Vb 4
\&    * Process identifier of the process which created the lockfile (per "$$"),
\&    * The number of seconds the lock should be considered valid (per "nsec" parameter),
\&    * The helpful message provided by the programmer (per "msg" parameter),
\&    * The name of the program which created the lockfile (per "$0")
.Ve
.Sp
Example:
.Sp
.Vb 1
\&    "4873\et2.0\etThe programmer is lame\et/opt/simon/bin/simond\en"
.Ve
.Sp
These fields may change in future versions of this module.
.IP "\fB\s-1FURTHER DEVELOPMENT\s0\fR" 4
.IX Item "FURTHER DEVELOPMENT"
A recursive descent function similar to File::Find <https://metacpan.org/pod/File::Find> is planned, since \f(CW\*(C`File::Find\*(C'\fR is pretty horrible and unusable.
.Sp
The \f(CW\*(C`lockafile()\*(C'\fR implementation goes through considerable effort to avoid race conditions, but there is still a very short danger window where an overridden lock might get double-clobbered.  If a contended lock expires just when two or more other processes call \f(CW\*(C`lockafile()\*(C'\fR on it, it is possible for one process to unlink the lock file, the other process to create a new lock file, and then the first process to overwrite that lock file with its own lock file, leaving both processes under the impression they have acquired the lock.  Future implementations may remedy this.  In the meantime the possibility can be avoided by setting a sufficiently large \*(L"nsec\*(R" value when acquiring a lock that it will not expire before the owning process is ready to release it.
.Sp
The nested lock management \f(CW\*(C`lockafile()\*(C'\fR and \f(CW\*(C`unlockafile()\*(C'\fR implement is flawed, in that the lock on the file is only valid for as long specified by the first invocation of \f(CW\*(C`lockafile()\*(C'\fR.  Thus if a file is locked for 3 seconds, and then subsequently locked for 30 seconds, other processes contending for the locked file will forceably acquire the lock after 3 seconds after the first lock, not 30 seconds after the second lock.  Future implementations may overwrite the lockfile to reflect the parameters of subsequent (nested) locks.
.Sp
The file-slurping functions handle data explicitly as \fBbytes\fR and never as codepoints.  This is intentional and unlikely to change.  If codepoint handling (utf\-8, utf\-16, etc) is desired, see File::Slurper <https://metacpan.org/pod/File::Slurper>.
.IP "\fB\s-1SEE ALSO\s0\fR" 4
.IX Item "SEE ALSO"
File::Slurper <https://metacpan.org/pod/File::Slurper> is considered the likely successor to \f(CW\*(C`File::Slurp\*(C'\fR for \s-1CPAN\s0's primary file-slurping implementation, with proper handling of multibyte-encoded characters (which is broken <http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html> in \f(CW\*(C`File::Slurp\*(C'\fR).  If \f(CW\*(C`File::Slurper\*(C'\fR implemented an appending method, the slurp functions would likely be absent from \f(CW\*(C`File::Valet\*(C'\fR.  Until then, \f(CW\*(C`File::Valet\*(C'\fR's slurping functions provide a simple, robust alternative.
.Sp
Path::Tiny <https://metacpan.org/pod/Path::Tiny> \- a different style for file handling, which some people might prefer.
.Sp
File::Temp <https://metacpan.org/pod/File::Temp> \- returns name and handle of a temporary file.
.Sp
File::SearchPath <https://metacpan.org/pod/File::SearchPath> \- searches an environment path for a file.
.Sp
Lock::File <https://metacpan.org/pod/Lock::File> \- file locker with an automatic out-of-scope unlocking mechanism.
.Sp
NL::File::Lock <https://metacpan.org/pod/NL::File::Lock> \- file locker with timeout, but no lock expiration.
.Sp
File::Lock::Multi <https://metacpan.org/pod/File::Lock::Multi> \- file locker with support for nested locks.
.Sp
File::TinyLock <https://metacpan.org/pod/File::TinyLock> \- a very easy to use file locker.
.Sp
Data::Munge <https://metacpan.org/pod/Data::Munge> \- a gaggle of useful functions, including a simple \fBslurp()\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1TTK\s0 Ciar
.SH "LICENSE"
.IX Header "LICENSE"
You can use and distribute this module under the same terms as Perl itself.
