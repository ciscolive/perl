.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Handler::Output::File 3"
.TH Log::Handler::Output::File 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Handler::Output::File \- Log messages to a file.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Log::Handler::Output::File;
\&
\&    my $log = Log::Handler::Output::File\->new(
\&        filename    => "file.log",
\&        filelock    => 1,
\&        fileopen    => 1,
\&        reopen      => 1,
\&        mode        => "append",
\&        autoflush   => 1,
\&        permissions => "0664",
\&        utf8        => 0,
\&    );
\&
\&    $log\->log(message => $message);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Log messages to a file.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fBnew()\fP"
.IX Subsection "new()"
Call \f(CW\*(C`new()\*(C'\fR to create a new Log::Handler::Output::File object.
.PP
The following options are possible:
.IP "\fBfilename\fR" 4
.IX Item "filename"
With \f(CW\*(C`filename\*(C'\fR you can set a file name as a string or as a array reference.
If you set a array reference then the parts will be concat with \f(CW\*(C`catfile\*(C'\fR from
\&\f(CW\*(C`File::Spec\*(C'\fR.
.Sp
Set a file name:
.Sp
.Vb 1
\&    my $log = Log::Handler::Output::File\->new( filename => "file.log"  );
.Ve
.Sp
Set a array reference:
.Sp
.Vb 1
\&    my $log = Log::Handler::Output::File\->new(
\&
\&        # foo/bar/baz.log
\&        filename => [ "foo", "bar", "baz.log" ],
\&
\&        # /foo/bar/baz.log
\&        filename => [ "", "foo", "bar", "baz.log" ],
\&
\&    );
.Ve
.IP "\fBfilelock\fR" 4
.IX Item "filelock"
Maybe it's desirable to lock the log file by each write operation because a lot
of processes write at the same time to the log file. You can set the option
\&\f(CW\*(C`filelock\*(C'\fR to 0 or 1.
.Sp
.Vb 2
\&    0 \- no file lock
\&    1 \- exclusive lock (LOCK_EX) and unlock (LOCK_UN) by each write operation (default)
.Ve
.IP "\fBfileopen\fR" 4
.IX Item "fileopen"
Open a log file transient or permanent.
.Sp
.Vb 3
\&    0 \- open and close the logfile by each write operation
\&    1 \- open the logfile if C<new()> called and try to reopen the
\&        file if C<reopen> is set to 1 and the inode of the file has changed (default)
.Ve
.IP "\fBreopen\fR" 4
.IX Item "reopen"
This option works only if option \f(CW\*(C`fileopen\*(C'\fR is set to 1.
.Sp
.Vb 2
\&    0 \- deactivated
\&    1 \- try to reopen the log file if the inode changed (default)
.Ve
.IP "How to use \fBfileopen\fR and \fBreopen\fR" 4
.IX Item "How to use fileopen and reopen"
Please note that it's better to set \f(CW\*(C`reopen\*(C'\fR and \f(CW\*(C`fileopen\*(C'\fR to 0 on Windows
because Windows unfortunately haven't the faintest idea of inodes.
.Sp
To write your code independent you should control it:
.Sp
.Vb 1
\&    my $os_is_win = $^O =~ /win/i ? 0 : 1;
\&
\&    my $log = Log::Handler::Output::File\->new(
\&       filename => "file.log",
\&       mode     => "append",
\&       fileopen => $os_is_win
\&    );
.Ve
.Sp
If you set \f(CW\*(C`fileopen\*(C'\fR to 0 then it implies that \f(CW\*(C`reopen\*(C'\fR has no importance.
.IP "\fBmode\fR" 4
.IX Item "mode"
There are three possible modes to open a log file.
.Sp
.Vb 3
\&    append \- O_WRONLY | O_APPEND | O_CREAT (default)
\&    excl   \- O_WRONLY | O_EXCL   | O_CREAT
\&    trunc  \- O_WRONLY | O_TRUNC  | O_CREAT
.Ve
.Sp
\&\f(CW\*(C`append\*(C'\fR would open the log file in any case and appends the messages at
the end of the log file.
.Sp
\&\f(CW\*(C`excl\*(C'\fR would fail by open the log file if the log file already exists.
.Sp
\&\f(CW\*(C`trunc\*(C'\fR would truncate the complete log file if it exists. Please take care
to use this option.
.Sp
Take a look to the documentation of \f(CW\*(C`sysopen()\*(C'\fR to get more information.
.IP "\fBautoflush\fR" 4
.IX Item "autoflush"
.Vb 2
\&    0 \- autoflush off
\&    1 \- autoflush on (default)
.Ve
.IP "\fBpermissions\fR" 4
.IX Item "permissions"
The option \f(CW\*(C`permissions\*(C'\fR sets the permission of the file if it creates and
must be set as a octal value. The permission need to be in octal and are
modified by your process's current \*(L"umask\*(R".
.Sp
That means that you have to use the unix style permissions such as \f(CW\*(C`chmod\*(C'\fR.
\&\f(CW0640\fR is the default permission for this option. That means that the owner
got read and write permissions and users in the same group got only read
permissions. All other users got no access.
.Sp
Take a look to the documentation of \f(CW\*(C`sysopen()\*(C'\fR to get more information.
.IP "\fButf8\fR, \fButf\-8\fR" 4
.IX Item "utf8, utf-8"
.Vb 2
\&    utf8   =  binmode, $fh, ":utf8";
\&    utf\-8  =  binmode, $fh, "encoding(utf\-8)";
.Ve
.Sp
Yes, there is a difference.
.Sp
<http://perldoc.perl.org/perldiag.html#Malformed\-UTF\-8\-character\-(%25s)>
.Sp
<http://perldoc.perl.org/Encode.html#UTF\-8\-vs.\-utf8\-vs.\-UTF8>
.IP "\fBdateext\fR" 4
.IX Item "dateext"
It's possible to set a pattern in the filename that is replaced with a date.
If the date \- and the filename \- changed the file is closed and reopened with
the new filename. The filename is converted with \f(CW\*(C`POSIX::strftime\*(C'\fR.
.Sp
Example:
.Sp
.Vb 4
\&    my $log = Log::Handler::Output::File\->new(
\&        filename  => "file\-%Y\-%m\-%d.log",
\&        dateext => 1
\&    );
.Ve
.Sp
In this example the file \f(CW\*(C`file\-2015\-06\-12.log\*(C'\fR is created. At the next day the filename
changed, the log file \f(CW\*(C`file\-2015\-06\-12.log\*(C'\fR is closed and \f(CW\*(C`file\-2015\-06\-13.log\*(C'\fR is opened.
.Sp
This feature is a small improvement for systems where no logrotate is available like Windows
systems. On this way you have the chance to delete old log files without to stop/start a
daemon.
.SS "\fBlog()\fP"
.IX Subsection "log()"
Call \f(CW\*(C`log()\*(C'\fR if you want to log messages to the log file.
.PP
Example:
.PP
.Vb 1
\&    $log\->log(message => "this message goes to the logfile");
.Ve
.SS "\fBflush()\fP"
.IX Subsection "flush()"
Call \f(CW\*(C`flush()\*(C'\fR if you want to re-open the log file.
.PP
This is useful if you don't want to use option \*(L"reopen\*(R". As example
if a rotate mechanism moves the logfile and you want to re-open a new
one.
.SS "\fBvalidate()\fP"
.IX Subsection "validate()"
Validate a configuration.
.SS "\fBreload()\fP"
.IX Subsection "reload()"
Reload with a new configuration.
.SS "\fBerrstr()\fP"
.IX Subsection "errstr()"
Call \f(CW\*(C`errstr()\*(C'\fR to get the last error message.
.SS "\fBclose()\fP"
.IX Subsection "close()"
Call \f(CW\*(C`close()\*(C'\fR to close the log file yourself \- normally you don't need
to use it, because the log file will be opened and closed automatically.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.Vb 4
\&    Carp
\&    Fcntl
\&    File::Spec
\&    Params::Validate
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
No exports.
.SH "REPORT BUGS"
.IX Header "REPORT BUGS"
Please report all bugs to <jschulz.cpan(at)bloonix.de>.
.PP
If you send me a mail then add Log::Handler into the subject.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonny Schulz <jschulz.cpan(at)bloonix.de>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2007\-2009 by Jonny Schulz. All rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
