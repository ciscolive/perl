.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Glade 3"
.TH Marpa::R2::Glade 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Marpa::R2::Glade \- Low-level interface to Marpa's Abstract Syntax Forests (\s-1ASF\s0's)
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 11
\&  my $grammar = Marpa::R2::Scanless::G\->new(
\&      {   source => \e(<<\*(AqEND_OF_SOURCE\*(Aq),
\&  :start ::= pair
\&  pair ::= duple | item item
\&  duple ::= item item
\&  item ::= Hesperus | Phosphorus
\&  Hesperus ::= \*(Aqa\*(Aq
\&  Phosphorus ::= \*(Aqa\*(Aq
\&  END_OF_SOURCE
\&      }
\&  );
\&
\&  my $slr = Marpa::R2::Scanless::R\->new( { grammar => $grammar } );
\&  $slr\->read( \e\*(Aqaa\*(Aq );
\&  my $asf = Marpa::R2::ASF\->new( { slr => $slr } );
\&  die \*(AqNo ASF\*(Aq if not defined $asf;
\&  my $output_as_array = asf_to_basic_tree($asf);
\&  my $actual_output   = array_display($output_as_array);
.Ve
.PP
The code for \f(CW\*(C`asf_to_basic_tree()\*(C'\fR represents a user-supplied call
using the interface described below.  An full example of \f(CW\*(C`asf_to_basic_tree()\*(C'\fR,
which constructs a Perl array \*(L"tree\*(R",
is given
below.
\&\f(CW\*(C`array_display()\*(C'\fR displays the tree in a compact form.
The code for it is also given below.
The return value of \f(CW\*(C`array_display()\*(C'\fR is as follows:
.PP
.Vb 10
\&    Glade 2 has 2 symches
\&      Glade 2, Symch 0, pair ::= duple
\&          Glade 6, duple ::= item item
\&              Glade 8 has 2 symches
\&                Glade 8, Symch 0, item ::= Hesperus
\&                    Glade 13, Hesperus ::= \*(Aqa\*(Aq
\&                        Glade 15, Symbol \*(Aqa\*(Aq: "a"
\&                Glade 8, Symch 1, item ::= Phosphorus
\&                    Glade 1, Phosphorus ::= \*(Aqa\*(Aq
\&                        Glade 17, Symbol \*(Aqa\*(Aq: "a"
\&              Glade 7 has 2 symches
\&                Glade 7, Symch 0, item ::= Hesperus
\&                    Glade 22, Hesperus ::= \*(Aqa\*(Aq
\&                        Glade 24, Symbol \*(Aqa\*(Aq: "a"
\&                Glade 7, Symch 1, item ::= Phosphorus
\&                    Glade 9, Phosphorus ::= \*(Aqa\*(Aq
\&                        Glade 26, Symbol \*(Aqa\*(Aq: "a"
\&      Glade 2, Symch 1, pair ::= item item
\&          Glade 8 revisited
\&          Glade 7 revisited
.Ve
.SH "About this document"
.IX Header "About this document"
This document describes the low-level interface to Marpa's abstract syntax forests (\s-1ASF\s0's).
It assumes that you are already familiar with the high-level interface.
This low-level interface allows the maximum flexiblity in building the forest,
but requires the application to do much of the work.
.SH "Ambiguity: factoring versus symches"
.IX Header "Ambiguity: factoring versus symches"
An abstract syntax forest (\s-1ASF\s0) is similar to an abstract syntax tree (\s-1AST\s0), but it
has an additional ability \*(-- it can represent an ambiguous parse.
Ambiguity in a parse can come in two forms, and Marpa's \s-1ASF\s0's treat the
distinction as important.  An ambiguity can be a symbolic choice
(a symch), or a factoring.  Symbolic choices are the kind of ambiguity
that springs first to mind \*(-- a choice between rules, or a choice
between a rule and token.  Factorings involve only one rule,
but the \s-1RHS\s0 symbols of that rule divide the input up (\*(L"factor it\*(R") in different ways.
I'll give examples below.
.PP
Symches and factorings are treated separately,
because they behave very differently:
.IP "\(bu" 4
Symches are less common than factorings.
.IP "\(bu" 4
Factorings are frequently not of interest; symches are almost
always of major interest.
.IP "\(bu" 4
Symches usually have just a few alternatives; the
possible number of factorings easily grows into the thousands.
.IP "\(bu" 4
In the worst case, the number of symches is a constant
that depends on size of the grammar.
In the worst case,
the number of factorings
grows exponentially with the length of the string being factored.
.IP "\(bu" 4
The constant limiting the number of symches will
almost always be of manageable size.
The number of factorings can grow without limit.
.SS "An example of a symch"
.IX Subsection "An example of a symch"
Hesperus is Venus's traditional name as an evening star,
and Phosphorus (aka Lucifer) is its traditional name as a morning star.
For the grammar,
.PP
.Vb 6
\&    :start ::= planet
\&    planet ::= hesperus
\&    planet ::= phosphorus
\&    hesperus ::= venus
\&    phosphorus ::= venus
\&    venus ~ \*(Aqvenus\*(Aq
.Ve
.PP
and the input string '\f(CW\*(C`venus\*(C'\fR', the forest would look like
.PP
.Vb 9
\&    Symbol #0 planet has 2 symches
\&      Symch #0.0
\&      GL2 Rule 0: planet ::= hesperus
\&        GL3 Rule 2: hesperus ::= venus
\&          GL4 Symbol venus: "venus"
\&      Symch #0.1
\&      GL2 Rule 1: planet ::= phosphorus
\&        GL5 Rule 3: phosphorus ::= venus
\&          GL6 Symbol venus: "venus"
.Ve
.PP
Notice the tags of the form "\f(CW\*(C`GLn\*(C'\fR", where \fIn\fR is an integer.
These identify the glade.
Glades will be described in detail below.
.PP
The rules allow the string '\f(CW\*(C`venus\*(C'\fR' to be parsed
as either one of two planets: '\f(CW\*(C`hesperus\*(C'\fR'
or '\f(CW\*(C`phosphorus\*(C'\fR',
depending on whether rule 0 or rule 1 is used.
The choice, at glade 2, between rules 0 and 1,
is a symch.
.SS "An example of a factoring"
.IX Subsection "An example of a factoring"
For the grammar,
.PP
.Vb 5
\&    :start ::= top
\&    top ::= b b
\&    b ::= a a
\&    b ::= a
\&    a ~ \*(Aqa\*(Aq
.Ve
.PP
and the input '\f(CW\*(C`aaa\*(C'\fR',
a successful parse will always have two \f(CW\*(C`b\*(C'\fR's.
Of these two \f(CW\*(C`b\*(C'\fR's one will always be short, deriving
a string of length 1:
\&'\f(CW\*(C`a\*(C'\fR'.
The other will always be long, deriving a string of length 2:
\&'\f(CW\*(C`aa\*(C'\fR'.
But they can be in either order,
which means that the two \f(CW\*(C`b\*(C'\fR's can divide up the input stream in
two different ways: long string first; or short string first.
.PP
These two different ways of dividing the input stream using the rule
.PP
.Vb 1
\&    top ::= b b
.Ve
.PP
are called a \fBfactoring\fR.  Here's Marpa's dump of the forest:
.PP
.Vb 10
\&    GL2 Rule 0: top ::= b b
\&      Factoring #0
\&        GL3 Rule 2: b ::= a
\&          GL4 Symbol a: "a"
\&        GL5 Rule 1: b ::= a a
\&          GL6 Symbol a: "a"
\&          GL7 Symbol a: "a"
\&      Factoring #1
\&        GL8 Rule 1: b ::= a a
\&          GL9 Symbol a: "a"
\&          GL10 Symbol a: "a"
\&        GL11 Rule 2: b ::= a
\&          GL12 Symbol a: "a"
.Ve
.SH "The structure of a forest"
.IX Header "The structure of a forest"
The terminology I use for \s-1ASF\s0's pictures
an \s-1ASF\s0 as a forest on a mountain.
This mountain forest has glades,
and there are paths between the glades.
The term \*(L"glade\*(R" comes from the idea of a glade as a distinct place in a forest that is
open to light.
.PP
The paths between glades have a direction \*(-- they are always thought of
as running one-way: downhill.
If a path connects two glades, the one uphill is called an upglade and the
one downhill is called a downglade.
.PP
There is a glade at the top of mountain called the \*(L"peak\*(R".
The peak has no upglades.
.SH "The glade hierarchy"
.IX Header "The glade hierarchy"
The glade hierarchy is directed graph whose nodes are glades.
Internally,
glade nodes have an 3\-level internal structure
made up of
.IP "\(bu" 4
one or more symches, which contain
.IP "\(bu" 4
zero or more factorings, which contain
.IP "\(bu" 4
one or more downglades.
.PP
When discussing symches
and factorings inside the internal structure of a glade \fIG\fR,
\&\fIG\fR will be called the \fBcontaining glade\fR.
.PP
If \fIG\fR is a glade,
the downglades in the internal structure will be
the child nodes of \fIG\fR in the directed graph of
glades.
There may not be any downglades, in which
case \fIG\fR will be a terminal in
the directed graph of glades.
.SS "Glades"
.IX Subsection "Glades"
Each glade node represents an instance of a symbol in one of the possible parse trees.
This means that each glade has a symbol (called the \*(L"glade symbol\*(R"),
and an \*(L"input span\*(R".
An input span is an input start location, and a length in characters.
Because it has a start location and a length,
a span also specifies an end location in the input.
.SS "Symches"
.IX Subsection "Symches"
Every glade contains one or more symches.
If a glade has only one symch, that symch is said to be \fBunique\fR.
A symch is either a \fBtoken symch\fR
or a \fBrule symch\fR.
For a token symch, the glade symbol is the token symbol.
For a rule symch, the glade symbol is the \s-1LHS\s0 of the rule.
.SS "Token symches"
.IX Subsection "Token symches"
At most one of the symches in a glade can be a token symch.
Token symches have no children.
In the internal structure of a glade, they are terminals.
If a glade has a unique symch,
and that symch is a token symch,
that glade will be a terminal in the glade hierarchy.
.SS "Rule symches"
.IX Subsection "Rule symches"
There can be many rule symches in a glade \*(--
one for every rule with the glade symbol on its \s-1LHS.\s0
As the name suggests, every rule symch has a rule
associated with it.
In every rule symch,
the \s-1LHS\s0 of its rule will always be the same
as the glade symbol
of the glade that contains the rule symch.
.SS "Factorings"
.IX Subsection "Factorings"
Every rule symch has one or more \fBfactorings\fR,
or \fBfactors\fR, as children.
A rule symch is said to \fBcontain\fR
its child factorings.
Each factoring is the \s-1RHS\s0 of the parent symch's
rule, mapped to a unique set of G1 locations.
The term \*(L"factoring\*(R" is traditional in the literature
and is meant to suggest that
a factoring is a way of
\&\*(L"dividing up\*(R" the input span
of the containing glade among its \s-1RHS\s0 symbols.
.PP
If a rule symch has only one factoring, that factoring is said to be \fBunique\fR.
Because the number of factorings can get out of hand,
factorings may be omitted.
A symch which omits factorings is said to be \fBtruncated\fR.
By default, every symch is truncated down to its first 42 factorings.
.SS "Downglades"
.IX Subsection "Downglades"
Every factoring has one or more downglades as children.
The number of downglades will be \fIL\fR,
where \fIL\fR is the length of the \s-1RHS\s0
of the parent symch's rule.
(The parent symch will always be a rule symch.)
Each of \fIL\fR \s-1RHS\s0 symbols will be located at
a specific G1 span,
and will therefore be a \fBsymbol instance\fR.
This symbol instance will be the symbol instance
of a glade,
and that glade will be the downglade.
.PP
Within a glade,
symches, factorings and downglades
are tracked using zero-based indexes.
Since the internal structure of a glade has
a 3\-level structure,
within a given containing glade \fIG\fR,
any downglade can be uniquely
identified as \f(CW\*(C`($symch_ix, $factor_ix, $downglade_ix)\*(C'\fR,
where 
\&\f(CW$symch_ix\fR is a zero-based symch index,
\&\f(CW$factor_ix\fR is a zero-based factoring index, and
\&\f(CW$downglade_ix\fR is a zero-based downglade index.
.SH "The glade ID"
.IX Header "The glade ID"
Each glade has a glade \s-1ID.\s0
This can be relied on to be a non-negative integer.
A glade \s-1ID\s0 may be zero.
Glade \s-1ID\s0's are obtained from the \*(L"\fBpeak()\fR\*(R"
and \*(L"\fBfactoring_downglades()\fR\*(R" methods.
.SH "Techniques for traversing ASF's"
.IX Header "Techniques for traversing ASF's"
.SS "Memoization"
.IX Subsection "Memoization"
When traversing a forest, you should take steps to avoid
traversing the same glades twice.
You can do this by memoizing the result of each glade, perhaps
using its glade \s-1ID\s0 to index an array.
When a glade is visited, the array can be checked to see if its result has
been memoized.
If so, the memoized result should be used.
.PP
This memoization eliminates the need to revisit the downglades
of an already visited glade.
It does not eliminate multiple visits to a glade, but it does
eliminate retraversal of the glades downhill from it.
In practice, the improvement in speed can be stunning.
It will often be the difference between 
an program which is unuseably slow even for very small inputs,
and one which is extremely fast even for large inputs.
.PP
Repeated subtraversals happen when two glades share the same downglades,
something that occurs frequently in \s-1ASF\s0's.
Additionally, some day the \s-1SLIF\s0 may allow cycles.
Memoization will prevent a cycle from causing an infinite loop.
.PP
The example in this \s-1POD\s0 includes a memoization scheme which is very simple,
but adequate for most purposes.
The main logic of its memoization is shown here.
.PP
.Vb 4
\&        my ( $asf, $glade, $seen ) = @_;
\&        return bless ["Glade $glade revisited"], \*(AqMy_Revisit\*(Aq
\&            if $seen\->[$glade];
\&        $seen\->[$glade] = 1;
.Ve
.PP
Putting memoization in one of the very first drafts
of your code
will save you time and trouble.
.SH "Forest method"
.IX Header "Forest method"
.SS "\fBpeak()\fP"
.IX Subsection "peak()"
.Vb 1
\&    my $peak = $asf\->peak();
.Ve
.PP
Returns the glade \s-1ID\s0 of the peak.
This may be zero.
All failures are thrown as exceptions.
.SH "Glade methods"
.IX Header "Glade methods"
.SS "\fBglade_literal()\fP"
.IX Subsection "glade_literal()"
.Vb 1
\&        my $literal = $asf\->glade_literal($glade);
.Ve
.PP
Returns the literal substring of the input associated
with the glade.
Every glade is associated with a span \*(-- a start location in the input,
and a length.
On failure, throws an exception.
.PP
The literal is determined by the range.
This works as expected if your application reads the input characters 
one-by-one, in order
and without gaps except for characters
that are normally discarded,
such as whitespace.
(We will call applications which read in this fashion, \fBmonotonic\fR.)
Most applications are monotonic,
and yours is, unless you've taken special pains to make it otherwise.
Computation of literal substrings for non-monotonic applications
is addressed in \*(L"Literals and G1 spans\*(R" in Marpa::R2::Scanless::R.
.SS "\fBglade_span()\fP"
.IX Subsection "glade_span()"
.Vb 1
\&    my ( $glade_start, $glade_length ) = $asf\->glade_span($glade_id);
.Ve
.PP
Returns the span of the input associated
with the glade.
Every glade is associated with a span \*(-- a start location in the input,
and a length.
On failure, throws an exception.
.PP
The span will be as expected if your application reads the input characters 
one-by-one in order.
(We will call applications which read in this fashion, \fBmonotonic\fR.)
Most applications are monotonic,
and yours is, unless you've taken special pains to make it otherwise.
Computation of literal substrings for non-monotonic applications
is addressed in \*(L"Literals and G1 spans\*(R" in Marpa::R2::Scanless::R.
.SS "\fBglade_symch_count()\fP"
.IX Subsection "glade_symch_count()"
.Vb 1
\&    my $symch_count = $asf\->glade_symch_count($glade);
.Ve
.PP
Requires a glade \s-1ID\s0 as its only argument.
Returns the number of symches contained in the glade specified by the argument.
On failure, throws an exception.
.SS "\fBglade_symbol_id()\fP"
.IX Subsection "glade_symbol_id()"
.Vb 2
\&    my $symbol_id    = $asf\->glade_symbol_id($glade);
\&    my $display_form = $grammar\->symbol_display_form($symbol_id);
.Ve
.PP
Requires a glade \s-1ID\s0 as its only argument.
Returns the symbol \s-1ID\s0 of the \*(L"glade symbol\*(R" for the glade specified by the argument.
On failure, throws an exception.
.SH "Symch methods"
.IX Header "Symch methods"
.SS "\fBsymch_rule_id()\fP"
.IX Subsection "symch_rule_id()"
.Vb 1
\&    my $rule_id = $asf\->symch_rule_id( $glade, $symch_ix );
.Ve
.PP
Requires two arguments: a glade \s-1ID\s0 and a zero-based symch index.
These specify a symch.
If the symch specified is a rule symch, returns the rule \s-1ID.\s0
If it is a token symch, returns \-1.
.PP
Returns a Perl undef, if the glade exists, but the symch index is too high.
On other failure, throws an exception.
.SS "\fBsymch_is_truncated()\fP"
.IX Subsection "symch_is_truncated()"
[ To be written. ]
.SS "\fBsymch_factoring_count()\fP"
.IX Subsection "symch_factoring_count()"
.Vb 2
\&    my $factoring_count =
\&        $asf\->symch_factoring_count( $glade, $symch_ix );
.Ve
.PP
Requires two arguments: a glade \s-1ID\s0 and a zero-based symch index.
These specify a symch.
Returns the count of factorings if the specified symch is a rule symch.
This count will always be one or greater.
Returns zero if the specified symch is a token symch.
.PP
Returns a Perl undef, if the glade exists, but the symch index is too high.
On other failure, throws an exception.
.SH "Factoring methods"
.IX Header "Factoring methods"
.SS "\fBfactoring_downglades()\fP"
.IX Subsection "factoring_downglades()"
.Vb 3
\&    my $downglades =
\&        $asf\->factoring_downglades( $glade, $symch_ix,
\&        $factor_ix );
.Ve
.PP
Requires three arguments: a glade \s-1ID,\s0
the zero-based index of a symch
and the zero-based index of a factoring.
These specify a factoring.
On success, returns a reference to an array.
The array contains the glade IDs of
the downglades in
the factoring specified.
.PP
Returns a Perl undef, if the glade and symch exist, but the factoring index is too high.
On other failure, throws an exception.
In particular, exceptions are thrown if the symch is for a token;
and if the glade exists, but the symch index is too high.
.SH "Methods for reporting ambiguity"
.IX Header "Methods for reporting ambiguity"
.Vb 4
\&    if ( $recce\->ambiguity_metric() > 1 ) {
\&        my $asf = Marpa::R2::ASF\->new( { slr => $recce } );
\&        die \*(AqNo ASF\*(Aq if not defined $asf;
\&        my $ambiguities = Marpa::R2::Internal::ASF::ambiguities($asf);
\&
\&        # Only report the first two
\&        my @ambiguities = grep {defined} @{$ambiguities}[ 0 .. 1 ];
\&
\&        $actual_value = \*(AqApplication grammar is ambiguous\*(Aq;
\&        $actual_result =
\&            Marpa::R2::Internal::ASF::ambiguities_show( $asf, \e@ambiguities );
\&        last PROCESSING;
\&    } ## end if ( $recce\->ambiguity_metric() > 1 )
.Ve
.SS "\fBambiguities()\fP"
.IX Subsection "ambiguities()"
.Vb 1
\&    my $ambiguities = Marpa::R2::Internal::ASF::ambiguities($asf);
.Ve
.PP
Returns a reference to an array of ambiguity reports in the \s-1ASF.\s0
The first and only argument must be an \s-1ASF\s0 object.
The array returned will be be zero length if the parse was not ambiguous.
Ambiguity reports are as described below.
.PP
While the \f(CW\*(C`ambiguities()\*(C'\fR method can be called to determine whether
or not ambiguities exist, it is the more expensive way to do it.
The \f(CW$slr\fR\->\fBambiguity_metric()\fR method
tests an already-existing boolean and is therefore extremely fast.
If you are simply testing for ambiguity,
use the \f(CW\*(C`ambiguity_metric()\*(C'\fR method instead.
If you can save time when you know that a parse is unambiguous,
you may want to test for ambiguity with the \f(CW\*(C`ambiguity_metric()\*(C'\fR method
before calling the \f(CW\*(C`ambiguities()\*(C'\fR method.
.SS "\fBambiguities_show()\fP"
.IX Subsection "ambiguities_show()"
.Vb 2
\&  $actual_result =
\&    Marpa::R2::Internal::ASF::ambiguities_show( $asf, \e@ambiguities );
.Ve
.PP
Returns a string which contains a description of the ambiguities in its arguments.
Takes two arguments, both required.
The first is an \s-1ASF,\s0 and the second is a reference to an array of ambiguities,
in the format returned by the \fBambiguities()\fR method.
.PP
Major applications will often have their own 
customized ambiguity formatting routine, one which can formulate
error messages based, not just on the names of the rules and symbols,
but on knowledge of the role that
the rules and symbols play in
the application.
This method is intended for applications which do not have
their own customized ambiguity handling.
For those which do, it can be used
as a fallback for handling those reports that the customized method does not recognize
or that do not need special handling.
The format of the returned string
and is subject to change,
and is intended for reading by humans only.
.SH "Ambiguity reports"
.IX Header "Ambiguity reports"
The ambiguity reports returned by the \f(CW\*(C`ambiguities()\*(C'\fR method
are of two kinds: symch reports and factoring reports.
Only ambiguities uppermost on a path are reported \*(--
in other words, an ambiguity
is not reported if it is downhill
and does not have a higher altitude.
(Because of cycles,
it is possible for a downhill glade to be at a higher altitude.)
Within glade, all of the factorings are 
considered downhill from,
and of equal altitude to the symches,
so that if a glade has a symch ambiguity,
there will be no factoring ambiguity reports for that glade.
.PP
Typically, when there is more than one kind of ambiguity in an input span, only
one is of real interest,
and
symch ambiguities are usually of more interest than factorings.
And if one ambiguity is uphill from another, the downhill ambiguity is usually
a side effect of the uphill one and
of little interest.
.SS "Symch reports"
.IX Subsection "Symch reports"
A symch report is issued whenever, in a top-down traversal of the \s-1ASF,\s0
a glade is encountered which has more than one symch.
A symch report takes the form
.PP
.Vb 1
\&   [ \*(Aqsymch\*(Aq, $glade ]
.Ve
.PP
where \f(CW$glade\fR is the \s-1ID\s0 of the glade with the symch ambiguity.
With this and the accessor methods in this document, an application can report full
details of the symch ambiguity.
.SS "Factoring reports"
.IX Subsection "Factoring reports"
A factoring report identifies
a sequence of \s-1RHS\s0 symbols which has more than one factoring.
Factoring reports identify not just a rule,
but specific subsequences within the \s-1RHS\s0
which are multiply factored \*(-- \fBmultifactored stretches\fR.
Marpa goes down to the symbol level, because a Marpa \s-1RHS\s0 can be very long.
Marpa's sequence rules, especially,
can have long stretches where the symbols are in sync
with each other, broken by other stretches where they are out of sync.
(A detailed definition of multifactored stretches is below.)
.PP
A factoring report takes the form
.PP
.Vb 1
\&    [ \*(Aqfactoring\*(Aq, $glade, $symch_ix, $rhs_ix1, $factor_ix2, $rhs_ix2 ];
.Ve
.PP
where \f(CW$glade\fR is the \s-1ID\s0 of the glade with the factoring ambiguity,
and \f(CW$symch_ix\fR is the index of the symch involved.
The multifactored stretch is described by
two \*(L"identifying downglades\*(R".
Both downglades are at the beginning of the stretch,
and both will have the same input start location.
The identifying downglades will differ in length.
.PP
The first of the two identifying factors has a factoring index of 0,
and its downglade index is \f(CW$rhs_ix1\fR.
The second identifying factor has a factoring index of \f(CW$factor_ix2\fR,
and its downglade index is \f(CW$rhs_ix2\fR.
.PP
The identifying downglades will usually be enough
for error reporting, which is the usual application of these reports.
A multifactored stretch can be extremely large.
Full details of it
can be found by following up on the information in the factoring report
using the accessor methods described in this document.
.SH "The code for the synopsis"
.IX Header "The code for the synopsis"
.SS "The \fBasf_to_basic_tree()\fP code"
.IX Subsection "The asf_to_basic_tree() code"
.Vb 5
\&  sub asf_to_basic_tree {
\&      my ( $asf, $glade ) = @_;
\&      my $peak = $asf\->peak();
\&      return glade_to_basic_tree( $asf, $peak, [] );
\&  } ## end sub asf_to_basic_tree
\&
\&  sub glade_to_basic_tree {
\&      my ( $asf, $glade, $seen ) = @_;
\&      return bless ["Glade $glade revisited"], \*(AqMy_Revisit\*(Aq
\&          if $seen\->[$glade];
\&      $seen\->[$glade] = 1;
\&      my $grammar     = $asf\->grammar();
\&      my @symches     = ();
\&      my $symch_count = $asf\->glade_symch_count($glade);
\&      SYMCH: for ( my $symch_ix = 0; $symch_ix < $symch_count; $symch_ix++ ) {
\&          my $rule_id = $asf\->symch_rule_id( $glade, $symch_ix );
\&          if ( $rule_id < 0 ) {
\&              my $literal      = $asf\->glade_literal($glade);
\&              my $symbol_id    = $asf\->glade_symbol_id($glade);
\&              my $display_form = $grammar\->symbol_display_form($symbol_id);
\&              push @symches,
\&                  bless [qq{Glade $glade, Symbol $display_form: "$literal"}],
\&                  \*(AqMy_Token\*(Aq;
\&              next SYMCH;
\&          } ## end if ( $rule_id < 0 )
\&
\&          # ignore any truncation of the factorings
\&          my $factoring_count =
\&              $asf\->symch_factoring_count( $glade, $symch_ix );
\&          my @symch_description = ("Glade $glade");
\&          push @symch_description, "Symch $symch_ix" if $symch_count > 1;
\&          push @symch_description, $grammar\->rule_show($rule_id);
\&          my $symch_description = join q{, }, @symch_description;
\&
\&          my @factorings = ($symch_description);
\&          for (
\&              my $factor_ix = 0;
\&              $factor_ix < $factoring_count;
\&              $factor_ix++
\&              )
\&          {
\&              my $downglades =
\&                  $asf\->factoring_downglades( $glade, $symch_ix,
\&                  $factor_ix );
\&              push @factorings,
\&                  bless [ map { glade_to_basic_tree( $asf, $_, $seen ) }
\&                      @{$downglades} ], \*(AqMy_Rule\*(Aq;
\&          } ## end for ( my $factor_ix = 0; $factor_ix < $factoring_count...)
\&          if ( $factoring_count > 1 ) {
\&              push @symches,
\&                  bless [
\&                  "Glade $glade, symch $symch_ix has $factoring_count factorings",
\&                  @factorings
\&                  ],
\&                  \*(AqMy_Factorings\*(Aq;
\&              next SYMCH;
\&          } ## end if ( $factoring_count > 1 )
\&          push @symches, bless [ @factorings[ 0, 1 ] ], \*(AqMy_Factorings\*(Aq;
\&      } ## end SYMCH: for ( my $symch_ix = 0; $symch_ix < $symch_count; ...)
\&      return bless [ "Glade $glade has $symch_count symches", @symches ],
\&          \*(AqMy_Symches\*(Aq
\&          if $symch_count > 1;
\&      return $symches[0];
\&  } ## end sub glade_to_basic_tree
.Ve
.SS "The \fBarray_display()\fP code"
.IX Subsection "The array_display() code"
Because of the blessings in this example,
a standard dump of the output array is
too cluttered for comfortable reading.
The following code displays the output from
\&\f(CW\*(C`asf_to_basic_tree()\*(C'\fR in a more compact form.
Note that this code makes no use of Marpa, 
and works for all Perl arrays.
It is included for completeness,
and as a simple example of array traversal.
.PP
.Vb 11
\&    sub array_display {
\&        my ($array) = @_;
\&        my ( undef, @lines ) = @{ array_lines_display($array) };
\&        my $text = q{};
\&        for my $line (@lines) {
\&            my ( $indent, $body ) = @{$line};
\&            $indent \-= 6;
\&            $text .= ( q{ } x $indent ) . $body . "\en";
\&        }
\&        return $text;
\&    } ## end sub array_display
\&
\&    sub array_lines_display {
\&        my ($array) = @_;
\&        my $reftype = Scalar::Util::reftype($array) // \*(Aq!undef!\*(Aq;
\&        return [ [ 0, $array ] ] if $reftype ne \*(AqARRAY\*(Aq;
\&        my @lines = ();
\&        ELEMENT: for my $element ( @{$array} ) {
\&            for my $line ( @{ array_lines_display($element) } ) {
\&                my ( $indent, $body ) = @{$line};
\&                push @lines, [ $indent + 2, $body ];
\&            }
\&        } ## end ELEMENT: for my $element ( @{$array} )
\&        return \e@lines;
\&    } ## end sub array_lines_display
.Ve
.SH "Details"
.IX Header "Details"
This section contains details not essential to understanding
the main topic of this document.
These details include restatements of what is said above
in more formal terms,
and formal statements of concepts that have been left to
the intuition.
Some readers find these details helpful,
while others find them distracting.
Segregating these details here serves the needs of both.
.SS "An alternative way of defining glade terminology"
.IX Subsection "An alternative way of defining glade terminology"
Here's a way of defining some of the above terms which is less intuitive,
but more precise.
First, define the \fBglade length\fR from glades A to glade B in an \s-1ASF\s0 as 
the number of glades on the shortest path from A to B, not including glade A.
(Recall that paths are directional.)
If there is no path between glades A and B, the glade length is undefined.
Glade B is a \fBdownglade\fR of glade A,
and glade A is an \fBupglade\fR of glade B,
if and only if the glade length from A to B is 1.
.PP
A glade A is \fBuphill\fR with respect to glade B,
and a glade B is \fBdownhill\fR with respect to glade A,
if and only if the glade length from A to B is defined.
.PP
A \fBpeak\fR of an \s-1ASF\s0 is a node without upglades.
By construction of the \s-1ASF,\s0 there is only one peak.
The \fBdistance-to-peak\fR of a glade \f(CW\*(C`A\*(C'\fR is the glade length from the peak to glade \f(CW\*(C`A\*(C'\fR.
Glade \f(CW\*(C`A\*(C'\fR is said to have a higher \fBaltitude\fR than glade \f(CW\*(C`B\*(C'\fR if the distance-to-peak of glade \f(CW\*(C`A\*(C'\fR
is less than that of glade \f(CW\*(C`B\*(C'\fR.
Glade \f(CW\*(C`A\*(C'\fR has a lower \fBaltitude\fR than glade \f(CW\*(C`B\*(C'\fR if the distance-to-peak of glade \f(CW\*(C`A\*(C'\fR
is greater than that of glade \f(CW\*(C`B\*(C'\fR.
Glade \f(CW\*(C`A\*(C'\fR has the same \fBaltitude\fR as glade \f(CW\*(C`B\*(C'\fR if the distance-to-peak of glade \f(CW\*(C`A\*(C'\fR
is equal to that of glade \f(CW\*(C`B\*(C'\fR.
.SS "Cycles"
.IX Subsection "Cycles"
In the current \s-1SLIF\s0 implementation, a forest is a directed acyclic graph (\s-1DAG\s0).
(In the mathematical literature a \s-1DAG\s0 is also called a \*(L"tree\*(R", but that use is confusing
in the present context.)
The underlying Marpa algorithm allows parse trees with cycles,
and someday the \s-1SLIF\s0 probably will as well.
When that happens, \s-1ASF\s0's will no longer be \*(L"acyclic\*(R" and therefore will be directed graphs
(\s-1DG\s0's) but not \s-1DAG\s0's.
This document talks about \s-1ASF\s0's as if that day had already come \*(--
it assumes that the \s-1ASF\s0's might
contain cycles.
.PP
In an \s-1ASF\s0 that contains one or more cycles,
the concepts of uphill and downhill become much less useful
for describing the relative positions of glades.
For example, if glade A cycles back to itself through glade B, then
.IP "\(bu" 4
Glade A will be uphill from glade B, and
.IP "\(bu" 4
Glade B will be uphill from glade A; so that
.IP "\(bu" 4
Glade B will be downhill from glade A, and
.IP "\(bu" 4
Glade A will be downhill from glade B; and
.IP "\(bu" 4
Glade A will be both downhill and uphill from itself; and
.IP "\(bu" 4
Glade B will be both downhill and uphill from itself.
.PP
\&\s-1ASF\s0's will always be constructed so that the peak has no upglades.
Because of this, the peak can never be part of a cycle.
This means that altitude will always be well defined in the sense that,
for any two glades \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`B\*(C'\fR, one and only one of the following statements will be true:
.IP "\(bu" 4
Glade \f(CW\*(C`A\*(C'\fR is lower in altitude than glade \f(CW\*(C`B\*(C'\fR.
.IP "\(bu" 4
Glade \f(CW\*(C`A\*(C'\fR is higher in altitude than glade \f(CW\*(C`B\*(C'\fR.
.IP "\(bu" 4
Glade \f(CW\*(C`A\*(C'\fR is equal in altitude to glade \f(CW\*(C`b\*(C'\fR.
.SS "Token symches"
.IX Subsection "Token symches"
In the current \s-1SLIF\s0 implementation, a symbol is always either a token
or the \s-1LHS\s0 of a rule.
This means that any glade that contains a token symch
cannot contain any rule symches.
It also means that any glade that contains a rule symch will not
contain a token symch.
.PP
However, the underlying Marpa algorithm allows \s-1LHS\s0 terminals,
and someday the \s-1SLIF\s0 probably will as well.
This document is written as if that day has already come,
and describes
glades as if they could contain both rule symches and a token symch.
.SS "Maximum symches per glade"
.IX Subsection "Maximum symches per glade"
Above, the point is made that the number of symches in a glade,
even in the worst case, is a very manageable number.
For a particular case, it is not hard to work out the exact maximum.
Here are the details.
.PP
There can be at most one token symch.
There can be only rule symch for every rule.
In addition, all rules in a glade must have the glade symbol as their \s-1LHS.\s0
Let the number of rules with the glade symbol on their \s-1LHS\s0 be \f(CW\*(C`r\*(C'\fR.
The maximum number of symches in a glade is \f(CW\*(C`r+1\*(C'\fR.
.SS "Multifactored stretches"
.IX Subsection "Multifactored stretches"
Marpa locates factoring ambiguities, not just by rule,
but by subsequences of symbols within a \s-1RHS.\s0
It finds \fBmultifactored stretches\fR, input spans where the sequence of symbols
can have multiple factorings.
Sequence rules can have a very long \s-1RHS.\s0
If ambiguity reporting is to be precise,
it is necessary
to narrow down factoring ambiguities to the specific input spans
where they occur.
.PP
Marpa tries to break up each ambiguously factored \s-1RHS\s0
into as many multifactored stretches
as possible.
Nonetheless,
there will be cases in which
a multifactored stretch encompasses the entire \s-1RHS\s0 of a rule.
.PP
The main body of this document worked with an intuitive \*(L"know one when I see one\*(R"
idea of multifactored stretches.
In this section we will give an exact definition.
First, we will need some preliminary definitions.
.PP
Consider the case of a arbitrary, ambiguous rule symch.
The ambiguous rule symch can be seen as a set of factorings.
We need a way to identify individual downglades within
each factoring of the set.
Within a factoring,
there is a one-to-one correspondence between
downglade and locations in the string of symbols that
is the \s-1RHS.\s0
Therefore downglades can be identified uniquely as
\&\f(CW\*(C`glade_id, symch_ix, factor_ix, rhs_ix\*(C'\fR,
where \f(CW\*(C`glade_id\*(C'\fR is a unique identifier of the glade,
\&\f(CW\*(C`symch_ix\*(C'\fR is a zero-based symch index,
\&\f(CW\*(C`factor_ix\*(C'\fR is a zero-based factoring index, and
\&\f(CW\*(C`rhs_ix\*(C'\fR is a zero-based index identifying a
symbol location in the \s-1RHS\s0 string.
.PP
In much of what follows,
we will assume we are talking about a specific
glade and rule symch, which is understood in context,
so that we can take
\&\f(CW\*(C`factor_ix, rhs_ix\*(C'\fR as uniquely identifying a downglade.
We will call
\&\f(CW\*(C`factor_ix, rhs_ix\*(C'\fR a downglade duple.
.PP
Let \fIN\fR be the number of factorings in the rule symch of interest.
Since we are dealing with a specific rule symch, we also
have a specific rule that is of interest.
Call the length of the \s-1RHS\s0 of that rule, \f(CW\*(C`rhs_length\*(C'\fR.
For every \f(CW\*(C`factor_ix\*(C'\fR, the values of \f(CW\*(C`rhs_ix\*(C'\fR
will be in the range \f(CW\*(C`0 ... rhs_length\-1\*(C'\fR.
.PP
Each downglade \f(CW\*(C`factor_ix, rhs_ix\*(C'\fR
corresponds one-to-one to a G1 span.
This means that
there is a total function
\&\f(CW\*(C`G1_start(factor_ix, rhs_ix)\*(C'\fR from a downglade
to a G1 start location;
and that there is a total function
\&\f(CW\*(C`G1_length(factor_ix, rhs_ix)\*(C'\fR
from a downglade
to a G1 length.
.PP
A \fBsymch location set\fR
is a set of \fIN\fR downglade duples
such there is exactly one element
\&\f(CW\*(C`factor_ix, rhs_ix\*(C'\fR
in the set for each 
\&\f(CW\*(C`0 <= factor_ix < N\*(C'\fR.
In other words, a symch location set is
a total function from the factor indexes
to the \s-1RHS\s0 indexes.
.PP
A \fBsymch alignment\fR is a symch location set
whose elements shares a common G1 start location.
A symch alignment is synced if its elements share a common G1 length as well.
A symch alignment is unsynced if it is not synced.
.PP
More formally, if we represent the symch location set
function as \f(CW\*(C`SLS\*(C'\fR,
\&\f(CW\*(C`SLS\*(C'\fR is a symch alignment if and only if
there is some constant G1 location \fIpos\fR such
that, for all \f(CW\*(C`factor_ix\*(C'\fR
such that \f(CW\*(C`0 <= factor_ix < N\*(C'\fR,
\&\f(CW\*(C`G1_start(factor_ix, SLS(factor_ix)) = pos\*(C'\fR.
We say the \f(CW\*(C`pos\*(C'\fR is the location of the symch alignment.
\&\f(CW\*(C`SLS\*(C'\fR is a synced symch alignment if and only if
it is a symch aligment and
there is some constant number \fIL\fR such
\&\f(CW\*(C`G1_length(factor_ix, SLS(factor_ix)) = L\*(C'\fR.
.PP
Of special interest is the \fBinitial symch location set\fR.
The initial symch location set is the symch position all of whose \s-1RHS\s0 indexes
are 0.
Equivalently, it is the constant function \f(CW\*(C`ISLS\*(C'\fR
where \f(CW\*(C`ISLS(factor_ix)=0\*(C'\fR for all \f(CW\*(C`factor_ix\*(C'\fR
such that \f(CW\*(C`0 <= factor_ix < N\*(C'\fR.
The initial symch location set is always a symch alignment,
and is called the \fBinitial symch alignment\fR.
.PP
We are now in a position to define a \fBmultifactored stretch\fR
for a specific rule symch.
Call a G1 location an \fBanchor\fR if it is the location
of a synced symch alignment or,
as a special case,
if it is one past the last location of the G1 stream.
We say that a G1 span is \fBanchored\fR if its start
and end G1 locations are anchors.
A \fBmultifactored stretch\fR is an anchored G1 span
which contains only one anchored G1 location.
(Recall that, by the definition of a span,
the end location of a span 
is not contained in the span.)
.PP
As a consequence of its definition,
the start location of a multifactored stretch
will always be an anchor,
and the only anchored location in the multifactored
stretch will be its start location.
(Again, by definition,
the end location of the stretch is not
contained in the stretch.)
.PP
Multifactored stretches
are aligned and anchored in terms of G1 locations,
and \fBnot\fR in terms of input stream locations or \s-1RHS\s0 indexes.
It may be useful, however, to look at syncing and alignment
from other points of view.
This is done in the next two sections.
.PP
\fIAlignment and input stream locations\fR
.IX Subsection "Alignment and input stream locations"
.PP
Because G1 spans map to input stream spans,
symch location sets that are aligned or synced in
G1 terms will be aligned or synced from
the input stream point of view as well.
But, if the input is not monotonic,
the opposite is not necessarily the case.
Because several G1 locations
can share an input stream location, symch location sets that seem
aligned or synced from the input stream point of view
may not be considered aligned or synced from the G1 location
point.
.PP
\fIAlignment and \s-1RHS\s0 indexes\fR
.IX Subsection "Alignment and RHS indexes"
.PP
Symch location sets that are aligned
from the G1 location point will typically not be
aligned from the point of
the \s-1RHS\s0 indexes.
Non-aligned \s-1RHS\s0 indexes are particularly likely for
long sequence rules,
where the \s-1RHS\s0 is a long string containing
many repetitions of a single symbol.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
