.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::MethodMaker::Engine 3"
.TH Class::MethodMaker::Engine 3 "2015-03-31" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::MethodMaker::Engine \- The parameter passing, method installation &
non\-data\-structure methods of Class::MethodMaker.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This class is for internal implementation only.  It is not a public \s-1API.\s0
.PP
The non-data-structure methods do form part of the public \s-1API,\s0 but not called
directly: rather, called through the \f(CW\*(C`use\*(C'\fR/\f(CW\*(C`import\*(C'\fR interface, as for
data-structure methods.
.SH "The Class::MethodMaker Method Installation Engine"
.IX Header "The Class::MethodMaker Method Installation Engine"

.SS "import"
.IX Subsection "import"
This performs argument parsing ready for calling create_methods.  In
particular, this is the point at which v1 & v2 calls are distinguished.
.PP
This is implicitly called as part of a \f(CW\*(C`use\*(C'\fR statement:
.PP
.Vb 4
\&  use Class::MethodMaker
\&    [ scalar => [qw/ foo bar baz /],
\&      new    => [qw/ new /]        ,
\&    ];
.Ve
.PP
is equivalent to
.PP
.Vb 3
\&  Class::MethodMaker\->import([scalar => [qw/ foo bar baz /],
\&                              new    => [qw/ new /]        ,
\&                             ]);
.Ve
.PP
See perldoc \-f use for details of this equivalence.
.PP
The methods created are installed into the class calling the import \- or more
accurately, the first class up the calling stack that is not
\&\f(CW\*(C`Class::MethodMaker\*(C'\fR or a subclass thereof.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
.Vb 10
\&  Class::MethodMaker\->import([scalar => [+{ \-type   => \*(AqFile::Stat\*(Aq,
\&                                            \-forward => [qw/ mode size /],
\&                                            \*(Aq*_foo\*(Aq => \*(Aq*_fig\*(Aq,
\&                                            \*(Aq*_gop\*(Aq => undef,
\&                                            \*(Aq*_bar\*(Aq => \*(Aq*_bar\*(Aq,
\&                                            \*(Aq*_hal\*(Aq => \*(Aq*_sal\*(Aq,
\&                                           },
\&                                         qw/ \-static bob /,
\&                                        ]
\&                             ]);
.Ve
.SS "parse_options"
.IX Subsection "parse_options"
Parse the arguments given to import and call create_methods
appropriately.  See main text for options syntax.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
.Vb 12
\&  Class::MethodMaker\->parse_options(\*(AqTargetClass\*(Aq,
\&                                    [scalar =>
\&                                      [{ \-type => \*(AqFile::stat\*(Aq,
\&                                         \-forward => [qw/ mode
\&                                                          size /],
\&                                         \*(Aq*_foo\*(Aq => \*(Aq*_fig\*(Aq,
\&                                         \*(Aq*_gop\*(Aq => undef,
\&                                         \*(Aq*_bar\*(Aq => \*(Aq*_bar\*(Aq,
\&                                         \*(Aq*_hal\*(Aq => \*(Aq*_sal\*(Aq,
\&                                       },
\&                                       qw( \-static bob ),
\&                                      ]])},
\&
\&  Class::MethodMaker\->parse_options(\*(AqTargetClass2\*(Aq,
\&                                    [scalar =>
\&                                      [\*(Aqbaz\*(Aq,
\&                                       { \-type => \*(AqFile::stat\*(Aq,
\&                                         \-forward => [qw/ mode
\&                                                          size /],
\&                                         \*(Aq*_foo\*(Aq => \*(Aq*_fog\*(Aq,
\&                                         \*(Aq*_bar\*(Aq => \*(Aq*_bar\*(Aq,
\&                                         \*(Aq*_hal\*(Aq => \*(Aq*_sal\*(Aq,
\&                                       },
\&                                       qw( \-static bob ),
\&                                      ]],
\&                                    +{ \-type => \*(AqMath::BigInt\*(Aq, },
\&                                    +{\*(Aq*_foo\*(Aq => \*(Aq*_fig\*(Aq,
\&                                      \*(Aq*_gop\*(Aq => undef,},
\&                                   )},
.Ve
.IP "\s-1ARGUMENTS\s0" 4
.IX Item "ARGUMENTS"
.RS 4
.PD 0
.IP "target_class" 4
.IX Item "target_class"
.PD
The class into which to install components
.IP "args" 4
.IX Item "args"
The arguments to parse, as a single arrayref.
.IP "options" 4
.IX Item "options"
A hashref of options to apply to all components created by this call (subject
to overriding by explicit option calls).
.IP "renames" 4
.IX Item "renames"
A hashref of renames to apply to all components created by this call (subject
to overriding by explicit rename calls).
.RE
.RS 4
.RE
.SS "create_methods"
.IX Subsection "create_methods"
Add methods to a class.  Methods for multiple components may be added this
way, but create_methods handles only one set of options.
parse_options is responsible for sorting which options to
apply to which components, and calling create_methods appropriately.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
.Vb 10
\&  Class::MethodMaker\->create_methods($target_class,
\&                                     scalar => bob,
\&                                     +{ static => 1,
\&                                        type   => \*(AqFile::Stat\*(Aq,
\&                                        forward => [qw/ mode size /], },
\&                                     +{ \*(Aq*_foo\*(Aq => \*(Aq*_fig\*(Aq,
\&                                        \*(Aq*_gop\*(Aq => undef,
\&                                        \*(Aq*_bar\*(Aq => \*(Aq*_bar\*(Aq,
\&                                        \*(Aq*_hal\*(Aq => \*(Aq*_sal\*(Aq, }
\&                                    );
.Ve
.IP "\s-1ARGUMENTS\s0" 4
.IX Item "ARGUMENTS"
.RS 4
.PD 0
.IP "targetclass" 4
.IX Item "targetclass"
.PD
The class to add methods to.
.IP "type" 4
.IX Item "type"
The basic data structure to use for the component, e.g., \f(CW\*(C`scalar\*(C'\fR.
.IP "compname" 4
.IX Item "compname"
Component name.  The name must be a valid identifier, i.e., a continuous
non-empty string of word (\f(CW\*(C`\ew\*(C'\fR) characters, of which the first may not be a
digit.
.IP "options" 4
.IX Item "options"
A hashref.  Some options (\f(CW\*(C`static\*(C'\fR, \f(CW\*(C`type\*(C'\fR, \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`default_ctor\*(C'\fR) are
handled by the auto-extender.  These will be invoked if the name is present as
a key and the value is true.  Any other options are passed through to the
method in question.  The options should be named as-is; no leading hyphen
should be applied (i.e., use \f(CW\*(C`{static => 1}\*(C'\fR not \f(CW\*(C`{\-static => 1}\*(C'\fR).
.IP "renames" 4
.IX Item "renames"
A list of customer renames.  It is a hashref from method name to rename.  The
method name is the generic name (i.e., featuring a \f(CW\*(C`*\*(C'\fR to replace with the
component name).  The rename is the value to rename with.  It may itself
contain a \f(CW\*(C`*\*(C'\fR to replace with the component name.  If rename is undef, the
method is \fInot\fR installed.  For methods that would not be installed by default, use a rename value that is the same as the method name.
.Sp
So, if a type would normally install methods
.Sp
.Vb 1
\&  \*(Aq*_foo\*(Aq, \*(Aq*_gop\*(Aq, \*(Aq*_tom\*(Aq
.Ve
.Sp
and optionally installs (but not by default)
.Sp
.Vb 1
\&  \*(Aq*_bar\*(Aq, \*(Aq*_wiz\*(Aq, \*(Aq*_hal\*(Aq
.Ve
.Sp
using a renames value of
.Sp
.Vb 5
\&  { \*(Aq*_foo\*(Aq => \*(Aq*_fig\*(Aq,
\&    \*(Aq*_gop\*(Aq => undef,
\&    \*(Aq*_bar\*(Aq => \*(Aq*_bar\*(Aq,
\&    \*(Aq*_hal\*(Aq => \*(Aq*_sal\*(Aq,
\&  }
.Ve
.Sp
with a component name of \f(CW\*(C`xx\*(C'\fR, then \f(CW*_foo\fR is installed as \f(CW\*(C`xx_fig\*(C'\fR,
\&\f(CW*_bar\fR is installed as \f(CW\*(C`xx_bar\*(C'\fR, \f(CW*_wiz\fR is not installed, \f(CW*_hal\fR is
installed as \f(CW\*(C`xx_sal\*(C'\fR, \f(CW*_gop\fR is not installed, and \f(CW*_tom\fR is installed
as \f(CW\*(C`xx_tom\*(C'\fR.
.Sp
The value may actually be an arrayref, in which case the function may be
called by any of the multiple names specified.
.RE
.RS 4
.RE
.SS "install_methods"
.IX Subsection "install_methods"
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
.Vb 5
\&  Class::MethodMaker\->install_methods
\&    ($classname, { incr => sub { $i++ },
\&                   decr => sub { $i\-\- },
\&                 }
\&    );
.Ve
.IP "\s-1ARGUMENTS\s0" 4
.IX Item "ARGUMENTS"
.RS 4
.PD 0
.IP "target" 4
.IX Item "target"
.PD
The class into which the methods are to be installed
.IP "methods" 4
.IX Item "methods"
The methods to install, as a hashref.  Keys are the method names; values are
the methods themselves, as code refs.
.RE
.RS 4
.RE
.SH "Non-data-structure components"
.IX Header "Non-data-structure components"

.SS "new"
.IX Subsection "new"
.Vb 2
\&  use Class::MethodMaker
\&    [ new => \*(Aqnew\*(Aq ];
.Ve
.PP
Creates a basic constructor.
.PP
Takes a single string or a reference to an array of strings as its
argument.  For each string creates a simple method that creates and
returns an object of the appropriate class.
.PP
The generated method may be called as a class method, as usual, or as in
instance method, in which case a new object of the same class as the instance
will be created.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\-hash" 4
.IX Item "-hash"
The constructor will accept as arguments a list of pairs, from component name
to initial value.  For each pair, the named component is initialized by
calling the method of the same name with the given value.  E.g.,
.Sp
.Vb 5
\&  package MyClass;
\&  use Class::MethodMaker
\&    [ new    => [qw/ \-hash new /],
\&      scalar => [qw/ b c /],
\&    ];
\&
\&  sub d {
\&    my $self = shift;
\&    $self\->{d} = $_[0]
\&      if @_;
\&    return $self\->{d};
\&  }
\&
\&  package main;
\&  # The statement below implicitly calls
\&  # $m\->b(1); $m\->c(2); $m\->d(3)
\&  # on the newly constructed m.
\&  my $m = MyClass\->new(b => 1, c => 2, d => 3);
.Ve
.Sp
Note that this can also call user-supplied methods that have the name of the
component.
.Sp
Instead of a list of pairs, a single hashref may also be passed, which will be
expanded appropriately.  So the above is equivalent to:
.Sp
.Vb 1
\&  my $m = MyClass\->new({ b => 1, c => 2, d => 3 });
.Ve
.Sp
\&\fIAdvanced Users:\fR Class::MethodMaker method renaming is taken into account,
so even if the \f(CW\*(C`*\*(C'\fR method is renamed or removed, this will still work.
.IP "\-init" 4
.IX Item "-init"
This option causes the new method to call an initializer method.  The method
is called \f(CW\*(C`init\*(C'\fR (original, eh?) by default, but the option may be given an
alternative value.  The init method is passed any arguments that were passed
to the constructor, but the method is invoked on the newly constructed
instance.
.Sp
.Vb 2
\&  use Class::MethodMaker
\&    [ new => [qw/ \-init new1 /, { \-init => \*(Aqbob\*(Aq } => \*(Aqinit2\*(Aq ]];
.Ve
.Sp
Constructing with new1 involves an implicit call to \f(CW\*(C`init\*(C'\fR, whilst
constructing with new2 involves an implicit call to \f(CW\*(C`bob\*(C'\fR (\fIinstead\fR of
\&\f(CW\*(C`init\*(C'\fR).
.Sp
It is the responsibility of the user to ensure that an \f(CW\*(C`init\*(C'\fR method (or
whatever name) is defined.
.IP "\-singleton" 4
.IX Item "-singleton"
Creates a basic constructor which only ever returns a single instance of the
class: i.e., after the first call, repeated calls to this constructor return
the \fIsame\fR instance.  Note that the instance is instantiated at the time of
the first call, not before.
.SS "abstract"
.IX Subsection "abstract"
.Vb 2
\&  use Class::MethodMaker
\&    [ abstract => [ qw / foo bar baz / ] ];
.Ve
.PP
This creates a number of methods that will die if called.  This is intended to
support the use of abstract methods, that must be overridden in a useful
subclass.
.SS "copy"
.IX Subsection "copy"
.Vb 2
\&  use Class::MethodMaker
\&    [ copy => [qw/ shallow \-deep deep /] ];
.Ve
.PP
This creates method that produce a copy of self.  The copy is a by default a
\&\fIshallow\fR copy; any references will be shared by the instance upon which the
method is called and the returned newborn.  One option is taken, \f(CW\*(C`\-deep\*(C'\fR,
which causes the method to create \fIdeep\fR copies instead (i.e., references are
copied recursively).
.PP
\&\fBImplementation Note:\fR
.PP
Deep copies are performed using the \f(CW\*(C`Storable\*(C'\fR module if available, else
\&\f(CW\*(C`Data::Dumper\*(C'\fR.  The \f(CW\*(C`Storable\*(C'\fR module is liable to be much quicker.
However, this implementation note is not an \s-1API\s0 specification: the
implementation details are open to change in a future version as faster/better
ways of performing a deep copy become available.
.PP
Note that deep copying does not currently support the copying of coderefs,
ties or XS-based objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martyn J. Pearce <fluffy@cpan.org>
