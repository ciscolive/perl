.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector::Proxy::DBI 3"
.TH Connector::Proxy::DBI 3 "2019-06-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
Connector::Proxy::DBI
.PP
Use \s-1DBI\s0 to make a query to a database.
.SH "Usage"
.IX Header "Usage"
.SS "Configuration"
.IX Subsection "Configuration"
.Vb 9
\&    my $con = Connector::Proxy::DBI\->new({
\&        LOCATION => \*(AqDBI:mysql:database=openxpki;host=localhost\*(Aq,
\&        dbuser => \*(Aqqueryuser\*(Aq,
\&        password => \*(Aqverysecret\*(Aq,
\&        table => \*(Aqmytable\*(Aq,
\&        column => 1,
\&        condition => \*(Aqid = ?\*(Aq,
\&        ambiguous => \*(Aqdie\*(Aq,
\&    });
.Ve
.SS "Parameters"
.IX Subsection "Parameters"
.IP "dbuser" 4
.IX Item "dbuser"
.PD 0
.IP "password" 4
.IX Item "password"
.IP "table" 4
.IX Item "table"
.PD
The name of the table, can also be a \s-1JOIN\s0 clause (if supported by the driver).
.IP "column" 4
.IX Item "column"
For get/get_list the name of a single column to be returned.
.Sp
For get_hash a hash where the keys are the target keys of the resulting
hash and the values are the column names.
.IP "condition" 4
.IX Item "condition"
The condition using a question mark as placeholder. The placeholder(s) are
fed from the path components.
.IP "ambigous" 4
.IX Item "ambigous"
Controls the behaviour of the connector if more than one result is found
when a single one is expected (get/get_hash).
.RS 4
.IP "empty (default)" 4
.IX Item "empty (default)"
Return an empty result, will also die if \fIdie_on_undef\fR is set.
.IP "return" 4
.IX Item "return"
The potential ambiguity is ignored and the first row fetched is returned.
Note that depending on the database backend the actual result returned from
the is very likely undetermined.
.IP "die" 4
.IX Item "die"
Die with an error message.
.RE
.RS 4
.RE
.SH "Methods"
.IX Header "Methods"
.SS "get"
.IX Subsection "get"
Will return the value of the requested column of the matching row. If no row
is found, undef is returned (dies if die_on_undef is set).
.PP
If multiple rows are found, behaviour depends on the value of \fIambiguous\fR.
.SS "get_list"
.IX Subsection "get_list"
Will return the selected column of all matching lines as a list. If no match is
found undef is returned (dies if die_on_undef is set).
.SS "get_meta"
.IX Subsection "get_meta"
Will return scalar if the query has one result or list if the query has
multiple rows. Returns undef if no rows are found.
.SS "get_hash"
.IX Subsection "get_hash"
Return a single row as hashref, by default all columns are returned as
retrieved from the database. Pass a hashref to \fIcolumn\fR, where the key
is the target key and the value is the name of the column you need.
.PP
E.g. when your table has the columns id and name but you need the keys
index and title in your result.
.PP
.Vb 1
\&    $con\->column({ \*(Aqid\*(Aq => \*(Aqid\*(Aq, \*(Aq\`index\`\*(Aq => \*(Aqid\*(Aq, \*(Aqtitle\*(Aq => \*(Aqname\*(Aq });
.Ve
.PP
Note: The mapping is set directly on the sql layer and as escaping
reserved words is not standardized, we dont do it. You can add escape
characters yourself to the column map where required, as shown for the
word \*(L"index\*(R" in the given example.
.SS "get_keys"
.IX Subsection "get_keys"
not supported
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 268:" 4
.IX Item "Around line 268:"
Unknown directive: =head
.IP "Around line 272:" 4
.IX Item "Around line 272:"
Unknown directive: =head
