.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::Curl::Multi 3"
.TH Net::Curl::Multi 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Curl::Multi \- Perl interface for curl_multi_* functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Net::Curl::Multi qw(:constants);
\&
\& my $multi = Net::Curl::Multi\->new();
\& $multi\->add_handle( $easy );
\&
\& my $running = 0;
\& do {
\&     my ($r, $w, $e) = $multi\->fdset();
\&     my $timeout = $multi\->timeout();
\&     select $r, $w, $e, $timeout / 1000
\&         if $timeout > 0;
\&
\&     $running = $multi\->perform();
\&     while ( my ( $msg, $easy, $result ) = $multi\->info_read() ) {
\&         $multi\->remove_handle( $easy );
\&
\&         # process $easy
\&     }
\& } while ( $running );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module wraps multi handle from libcurl and all related functions and
constants. It does not export by default anything, but constants can be
exported upon request.
.PP
.Vb 1
\& use Net::Curl::Multi qw(:constants);
.Ve
.SS "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "new( [\s-1BASE\s0] )" 4
.IX Item "new( [BASE] )"
Creates new Net::Curl::Multi object. If \s-1BASE\s0 is specified it will be used
as object base, otherwise an empty hash will be used. \s-1BASE\s0 must be a valid
reference which has not been blessed already. It will not be used by the
object.
.Sp
.Vb 1
\& my $multi = Net::Curl::Multi\->new( [qw(my very private data)] );
.Ve
.Sp
Calls \fBcurl_multi_init\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_init.html> and presets some defaults.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "add_handle( \s-1EASY\s0 )" 4
.IX Item "add_handle( EASY )"
Add Net::Curl::Easy to this Net::Curl::Multi object.
.Sp
.Vb 1
\& $multi\->add_handle( $easy );
.Ve
.Sp
Calls \fBcurl_multi_add_handle\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_add_handle.html>.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "remove_handle( \s-1EASY\s0 )" 4
.IX Item "remove_handle( EASY )"
Remove Net::Curl::Easy from this Net::Curl::Multi object.
.Sp
.Vb 1
\& $multi\->remove_handle( $easy );
.Ve
.Sp
Calls \fBcurl_multi_remove_handle\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_remove_handle.html>.
Rethrows exceptions from callbacks.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "info_read( )" 4
.IX Item "info_read( )"
Read last message from this Multi.
.Sp
.Vb 1
\& my ( $msg, $easy, $result ) = $multi\->info_read();
.Ve
.Sp
\&\f(CW$msg\fR contains one of CURLMSG_* values, currently only \s-1CURLMSG_DONE\s0 is returned.
\&\f(CW$easy\fR is the Net::Curl::Easy object. Result is a
Net::Curl::Easy::Code dualvar object.
.Sp
Calls \fBcurl_multi_info_read\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_info_read.html>.
.IP "fdset( )" 4
.IX Item "fdset( )"
Returns read, write and exception vectors suitable for
\&\fBselect()\fR and \fBvec()\fR perl builtins.
.Sp
.Vb 1
\& my ( $rvec, $wvec, $evec ) = $multi\->fdset();
.Ve
.Sp
Calls \fBcurl_multi_fdset\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_fdset.html>.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "timeout( )" 4
.IX Item "timeout( )"
Returns timeout value in miliseconds.
.Sp
.Vb 1
\& my $timeout_ms = $multi\->timeout();
.Ve
.Sp
Calls \fBcurl_multi_timeout\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_timeout.html>.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "setopt( \s-1OPTION, VALUE\s0 )" 4
.IX Item "setopt( OPTION, VALUE )"
Set an option. \s-1OPTION\s0 is a numeric value, use one of CURLMOPT_* constants.
\&\s-1VALUE\s0 depends on whatever that option expects.
.Sp
.Vb 1
\& $multi\->setopt( CURLMOPT_MAXCONNECTS, 10 );
.Ve
.Sp
Calls \fBcurl_multi_setopt\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_setopt.html>.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "perform( )" 4
.IX Item "perform( )"
Perform. Call it if there is some activity on any fd used by multi interface
or timeout has just reached zero.
.Sp
.Vb 1
\& my $active = $multi\->perform();
.Ve
.Sp
Calls \fBcurl_multi_perform\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_perform.html>.
Rethrows exceptions from callbacks.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "wait( [\s-1OTHER_FDS\s0], \s-1TIMEOUT_MS\s0 )" 4
.IX Item "wait( [OTHER_FDS], TIMEOUT_MS )"
This method polls on all file descriptors used by the curl easy handles contained in the given multi handle set.
It will block until activity is detected on at least one of the handles or \s-1TIMEOUT_MS\s0 has passed.
.Sp
.Vb 1
\& my $active = $multi\->wait(1000);
.Ve
.Sp
It will also poll on all filehandles requested. Each event descriptor is a hash and requires keys: fd \- file number of the handle and events \- a bitmask of the events to wait for. On detected event it will return the data in revents key.
.Sp
.Vb 4
\& my $ev_read_stdin = {
\&   fd => fileno STDIN,
\&   events => CURL_WAIT_POLLIN,
\& };
\&
\& my $active = $multi\->wait( [ $ev_read_stdin ], 1000 );
\& if ( $active and $ev_read_stdin\->{revents} == CURL_WAIT_POLLIN )
\& {
\&   # STDIN is ready to read
\&   ...
\& }
.Ve
.Sp
Calls \fBcurl_multi_wait\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_wait.html>
(available since libcurl/7.28.0 <http://curl.haxx.se/libcurl/c/curl_multi_wait.html>).
Rethrows exceptions from callbacks.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "socket_action( [\s-1SOCKET\s0], [\s-1BITMASK\s0] )" 4
.IX Item "socket_action( [SOCKET], [BITMASK] )"
Signalize action on a socket.
.Sp
.Vb 1
\& my $active = $multi\->socket_action();
\&
\& # there is data to read on socket:
\& my $active = $multi\->socket_action( $socket, CURL_CSELECT_IN );
.Ve
.Sp
Calls \fBcurl_multi_socket_action\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html>.
Rethrows exceptions from callbacks.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "assign( \s-1SOCKET,\s0 [\s-1VALUE\s0] )" 4
.IX Item "assign( SOCKET, [VALUE] )"
Assigns some value to a socket file descriptor. Removes it if value is not
specified. The value is used only in socket callback.
.Sp
.Vb 1
\& my $socket = some_socket_open(...);
\&
\& # store socket object for socket callback
\& $multi\->assign( $socket\->fileno(), $socket );
.Ve
.Sp
Calls \fBcurl_multi_assign\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_assign.html>.
Throws \*(L"Net::Curl::Multi::Code\*(R" on error.
.IP "handles( )" 4
.IX Item "handles( )"
In list context returns easy handles attached to this multi.
In scalar context returns number of easy handles attached.
.Sp
There is no libcurl equivalent.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
None of those functions are exported, you must use fully qualified names.
.IP "strerror( [\s-1WHATEVER\s0], \s-1CODE\s0 )" 4
.IX Item "strerror( [WHATEVER], CODE )"
Return a string for error code \s-1CODE.\s0
.Sp
.Vb 1
\& my $message = $multi\->strerror( CURLM_BAD_EASY_HANDLE );
.Ve
.Sp
See \fBcurl_multi_strerror\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_strerror.html> for more info.
.SS "\s-1CONSTANTS\s0"
.IX Subsection "CONSTANTS"
.IP "CURLM_*" 4
.IX Item "CURLM_*"
If any method fails, it will return one of those values.
.IP "CURLMSG_*" 4
.IX Item "CURLMSG_*"
Message type from \fBinfo_read()\fR.
.IP "CURLMOPT_*" 4
.IX Item "CURLMOPT_*"
Option values for \fBsetopt()\fR.
.IP "CURL_POLL_*" 4
.IX Item "CURL_POLL_*"
Poll action information for socket callback.
.IP "CURL_CSELECT_*" 4
.IX Item "CURL_CSELECT_*"
Select bits for \fBsocket_action()\fR method.
.IP "\s-1CURL_SOCKET_TIMEOUT\s0" 4
.IX Item "CURL_SOCKET_TIMEOUT"
Special socket value for \fBsocket_action()\fR method.
.SS "\s-1CALLBACKS\s0"
.IX Subsection "CALLBACKS"
.IP "\s-1CURLMOPT_SOCKETFUNCTION\s0 ( \s-1CURLMOPT_SOCKETDATA\s0 )" 4
.IX Item "CURLMOPT_SOCKETFUNCTION ( CURLMOPT_SOCKETDATA )"
Socket callback will be called only if \fBsocket_action()\fR method is being used.
It receives 6 arguments: multi handle, easy handle, socket file number, poll
action, socket data (see assign), and \s-1CURLMOPT_SOCKETDATA\s0 value. It must
return 0.
For more information refer to \fBcurl_multi_socket_action\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html>.
.Sp
.Vb 5
\& sub cb_socket {
\&     my ( $multi, $easy, $socketfn, $action, $socketdata, $uservar ) = @_;
\&     # ... register or deregister socket actions ...
\&     return 0;
\& }
.Ve
.IP "\s-1CURLMOPT_TIMERFUNCTION\s0 ( \s-1CURLMOPT_TIMERDATA\s0 ) 7.16.0+" 4
.IX Item "CURLMOPT_TIMERFUNCTION ( CURLMOPT_TIMERDATA ) 7.16.0+"
Timer callback receives 3 arguments: multi object, timeout in ms, and
\&\s-1CURLMOPT_TIMERDATA\s0 value. Should return 0.
.Sp
.Vb 5
\& sub cb_timer {
\&     my ( $multi, $timeout_ms, $uservar ) = @_;
\&     # ... update timeout ...
\&     return 0;
\& }
.Ve
.SS "Net::Curl::Multi::Code"
.IX Subsection "Net::Curl::Multi::Code"
Most Net::Curl::Multi methods on failure throw a Net::Curl::Multi::Code error
object. It has both numeric value and, when used as string, it calls \fBstrerror()\fR
function to display a nice message.
.PP
.Vb 10
\& eval {
\&     $multi\->somemethod();
\& };
\& if ( ref $@ eq "Net::Curl::Easy::Code" ) {
\&     if ( $@ == CURLM_SOME_ERROR_WE_EXPECTED ) {
\&         warn "Expected multi error, continuing\en";
\&     } else {
\&         die "Unexpected curl multi error: $@\en";
\&     }
\& } else {
\&     # rethrow everyting else
\&     die $@;
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Curl
Net::Curl::Easy
Net::Curl::examples
\&\fBlibcurl\-multi\fR\|(3)
\&\fBlibcurl\-errors\fR\|(3)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2011\-2015 Przemyslaw Iskra <sparky at pld\-linux.org>.
.PP
You may opt to use, copy, modify, merge, publish, distribute and/or sell
copies of the Software, and permit persons to whom the Software is furnished
to do so, under the terms of the \s-1MPL\s0 or the MIT/X\-derivate licenses. You may
pick one of these licenses.
