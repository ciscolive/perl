.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Action::InputField 3"
.TH Workflow::Action::InputField 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Action::InputField \- Metadata about information required by an Action
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.09 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Declare the fields needed by your action in the configuration...
\&
\& <action name="CreateUser">
\&    <field name="username"
\&           is_required="yes"
\&           source_class="App::Field::ValidUsers" />
\&    <field name="email"
\&           is_required="yes" />
\&    <field name="office"
\&           source_list="Pittsburgh,Hong Kong,Moscow,Portland" />
\& ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A workflow Action can declare one or more input fields required to do
its job. Think of it as a way for the external world (your
application) to discover what information an action needs from it. The
application can request these fields from the workflow by action name
and present them to the user in whatever form appropriate for the
application. The sample command-line application shipped with this
distribution just cycles through them one at a time and presents a
query to the user for data entry.
.PP
For instance, in the above declaration there are three fields,
\&'username', 'email' and 'office'. So your application might do:
.PP
.Vb 10
\& my @action_fields = $wf\->get_action_fields( \*(AqCreateUser\*(Aq );
\& foreach my $field ( @action_fields ) {
\&     print "Field ", $field\->name, "\en",
\&           $field\->description, "\en",
\&           "Required? ", $field\->is_required, "\en";
\&     my @enum = $field\->get_possible_values;
\&     if ( scalar @enum ) {
\&         print "Possible values: \en";
\&         foreach my $val ( @enum ) {
\&             print "  $val\->{label} ($val\->{value})\en";
\&         }
\&     }
\&     print "Input? ";
\&     my $response = <STDIN>;
\&     chomp $response;
\&     $wf\->context\->param( $field\->name => $response );
\& }
\& $wf\->execute_action( \*(AqCreateUser\*(Aq );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Public Methods"
.IX Subsection "Public Methods"
\fInew( \e%params )\fR
.IX Subsection "new( %params )"
.PP
Typical constructor; will throw exception if 'name' is not defined or
if the property 'source_class' is defined but the class it specifies
is not available.
.PP
You will usually not need to use or override this method unless you
derive your own input field class (see \fIclass\fR in \*(L"Properties\*(R"
below). For example, suppose you need to add extra properties to all
your fields like \*(L"index\*(R", \*(L"disabled\*(R", etc.
.PP
In your actions definition \s-1XML\s0 file, you can just add them and the
parser will pick them up. Pay close attention the custom InputField
\&\*(L"class\*(R" property.
.PP
.Vb 7
\&  <actions>
\&    <type>foo</type>
\&    <action name="Bar"
\&      class="your::action::class">
\&      <field index="0" name="id" type="integer" disabled="yes"
\&        is_required="yes" class="your::custom::inputfieldclass"/>
\&    </action>
.Ve
.PP
But you need to give them life by creating the accessors for these
extra properties. Just derive your custom fields class like so:
.PP
.Vb 1
\&  package your::custom::inputfieldclass;
\&
\&  use warnings;
\&  use strict;
\&
\&  use base qw( Workflow::Action::InputField );
\&  use Workflow::Exception qw( workflow_error );
\&
\&  # extra action class properties
\&  my @EXTRA_PROPS = qw( index disabled );
\&  _\|_PACKAGE_\|_\->mk_accessors(@EXTRA_PROPS);
\&
\&  sub new {
\&    my ( $class, $params ) = @_;
\&    my $self = $class\->SUPER::new($params);
\&    # set only our extra properties
\&    foreach my $prop (@EXTRA_PROPS) {
\&      next if ( $self\->$prop );
\&      $self\->$prop( $params\->{$prop} );
\&    }
\&    warn "INDEX IS NOW WORKING:".$self\->index;
\&    warn "AND SO IS DISABLED:".$self\->disabled;
\&    return $self;
\&  }
\&
\&  1;
.Ve
.PP
\fI\f(BIis_required()\fI\fR
.IX Subsection "is_required()"
.PP
Returns 'yes' if field is required, 'no' if optional.
.PP
\fI\f(BIis_optional()\fI\fR
.IX Subsection "is_optional()"
.PP
Returns 'yes' if field is optional, 'no' if required.
.PP
\fI\f(BIget_possible_values()\fI\fR
.IX Subsection "get_possible_values()"
.PP
Returns list of possible values for this field. Each possible value is
represented by a hashref with the keys 'label' and 'value' which makes
it easy to create dropdown lists in templates and the like.
.PP
\fIadd_possible_values( \f(CI@values\fI )\fR
.IX Subsection "add_possible_values( @values )"
.PP
Adds possible values to be used for this field. Each item in
\&\f(CW@values\fR may be a simple scalar or a hashref with the keys 'label'
and 'value'.
.PP
\fIinit\fR
.IX Subsection "init"
.PP
Init is a \fIdummy\fR and just returns no special actions are taken
.SS "Properties"
.IX Subsection "Properties"
\&\fBname\fR (required)
.PP
Name of the field. This is what the action expects as the key in the
workflow context.
.PP
\&\fBlabel\fR (optional)
.PP
Label of the field. If not set the value for \f(CW\*(C`name\*(C'\fR is used.
.PP
\&\fBdescription\fR (optional)
.PP
What does the field mean? This is not required for operation but it is
\&\fBstrongly\fR encouraged so your clients can create front ends to feed
you the information without much fuss.
.PP
\&\fBtype\fR (optional)
.PP
Field types are implementation dependant are they should be
intrinsically implemented by validators. In other words, you can use
any mnemonic value for your convinience like \*(L"integer\*(R", \*(L"text\*(R",
etc. but it won't affect anything unless you use a validator to
validate your action data. By default it is set to 'basic'.
.PP
\&\fBrequirement\fR ('required'|'optional')
.PP
If field is required, 'required', otherwise 'optional'.
.PP
\&\fBsource_class\fR (optional)
.PP
If set the field will call '\fBget_possible_values()\fR' on the class when
the field is instantiated. This should return a list of either simple
scalars or a list of hashrefs with 'label' and 'value' keys.
.PP
\&\fBsource_list\fR (optional)
.PP
If set the field will use the specified comma-separated values as the
possible values for the field. The resulting list returned from
\&\f(CW\*(C`get_possible_values()\*(C'\fR will have the same value for both the 'label'
and 'value' keys.
.PP
\&\fBclass\fR (optional)
.PP
You may specify a custom InputField class. It should \f(CW\*(C`use base qw(
Workflow::Action );\*(C'\fR and probably override the \fBnew()\fR method which
should call SUPER::new($params). See \*(L"new( \e%params )\*(R" above for an
example.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Workflow::Action
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2007 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonas B. Nielsen (jonasbn) <jonasbn@cpan.org> is the current maintainer.
.PP
Chris Winters <chris@cwinters.com>, original author.
