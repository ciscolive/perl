.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "App::ElasticSearch::Utilities::QueryString 3"
.TH App::ElasticSearch::Utilities::QueryString 3 "2020-09-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::ElasticSearch::Utilities::QueryString \- CLI query string fixer
.SH "VERSION"
.IX Header "VERSION"
version 7.8
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This class provides a pluggable architecture to expand query strings on the
command-line into complex Elasticsearch queries.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "context"
.IX Subsection "context"
Defaults to 'query', but can also be set to 'filter' so the elements will be
added to the 'must' or 'filter' parameter.
.SS "search_path"
.IX Subsection "search_path"
An array reference of additional namespaces to search for loading the query string
processing plugins.  Example:
.PP
.Vb 1
\&    $qs\->search_path([qw(My::Company::QueryString)]);
.Ve
.PP
This will search:
.PP
.Vb 2
\&    App::ElasticSearch::Utilities::QueryString::*
\&    My::Company::QueryString::*
.Ve
.PP
For query processing plugins.
.SS "default_join"
.IX Subsection "default_join"
When fixing up the query string, if two tokens are found next to eachother
missing a joining token, join using this token.  Can be either \f(CW\*(C`AND\*(C'\fR or \f(CW\*(C`OR\*(C'\fR,
and defaults to \f(CW\*(C`AND\*(C'\fR.
.SS "plugins"
.IX Subsection "plugins"
Array reference of ordered query string processing plugins, lazily assembled.
.SS "fields_meta"
.IX Subsection "fields_meta"
A hash reference with the field data from App::ElasticSearch::Utilities::es_index_fields.
.SH "METHODS"
.IX Header "METHODS"
.SS "expand_query_string(@tokens)"
.IX Subsection "expand_query_string(@tokens)"
This function takes a list of tokens, often from the command line via \f(CW@ARGV\fR.  Uses
a plugin infrastructure to allow customization.
.PP
Returns: App::ElasticSearch::Utilities::Query object
.SH "TOKENS"
.IX Header "TOKENS"
The token expansion plugins can return undefined, which is basically a noop on the token.
The plugin can return a hash reference, which marks that token as handled and no other plugins
receive that token.  The hash reference may contain:
.IP "query_string" 2
.IX Item "query_string"
This is the rewritten bits that will be reassembled in to the final query string.
.IP "condition" 2
.IX Item "condition"
This is usually a hash reference representing the condition going into the bool query. For instance:
.Sp
.Vb 1
\&    { terms => { field => [qw(alice bob charlie)] } }
.Ve
.Sp
Or
.Sp
.Vb 1
\&    { prefix => { user_agent => \*(AqGo \*(Aq } }
.Ve
.Sp
These conditions will wind up in the \fBmust\fR or \fBmust_not\fR section of the \fBbool\fR query depending on the
state of the the invert flag.
.IP "invert" 2
.IX Item "invert"
This is used by the bareword \*(L"not\*(R" to track whether the token invoked a flip from the \fBmust\fR to the \fBmust_not\fR
state.  After each token is processed, if it didn't set this flag, the flag is reset.
.IP "dangles" 2
.IX Item "dangles"
This is used for bare words like \*(L"not\*(R", \*(L"or\*(R", and \*(L"and\*(R" to denote that these terms cannot dangle from the
beginning or end of the query_string.  This allows the final pass of the query_string builder to strip these
words to prevent syntax errors.
.SH "Extended Syntax"
.IX Header "Extended Syntax"
The search string is pre-analyzed before being sent to ElasticSearch.  The following plugins
work to manipulate the query string and provide richer, more complete syntax for \s-1CLI\s0 applications.
.SS "App::ElasticSearch::Utilities::QueryString::AutoEscape"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::AutoEscape"
Provide an '=' prefix to a query string parameter to promote that parameter to a \f(CW\*(C`term\*(C'\fR filter.
.PP
This allows for exact matches of a field without worrying about escaping Lucene special character filters.
.PP
E.g.:
.PP
.Vb 1
\&    user_agent:"Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1"
.Ve
.PP
Is evaluated into a weird query that doesn't do what you want.   However:
.PP
.Vb 1
\&    =user_agent:"Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1"
.Ve
.PP
Is translated into:
.PP
.Vb 1
\&    { term => { user_agent => "Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1" } }
.Ve
.PP
Which provides an exact match to the term in the query.
.SS "App::ElasticSearch::Utilities::QueryString::Barewords"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::Barewords"
The following barewords are transformed:
.PP
.Vb 3
\&    or => OR
\&    and => AND
\&    not => NOT
.Ve
.SS "App::ElasticSearch::Utilities::QueryString::IP"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::IP"
If a field is an \s-1IP\s0 address uses \s-1CIDR\s0 Notation, it's expanded to a range query.
.PP
.Vb 1
\&    src_ip:10.0/8 => src_ip:[10.0.0.0 TO 10.255.255.255]
.Ve
.SS "App::ElasticSearch::Utilities::QueryString::Ranges"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::Ranges"
This plugin translates some special comparison operators so you don't need to
remember them anymore.
.PP
Example:
.PP
.Vb 1
\&    price:<100
.Ve
.PP
Will translate into a:
.PP
.Vb 1
\&    { range: { price: { lt: 100 } } }
.Ve
.PP
And:
.PP
.Vb 1
\&    price:>50,<100
.Ve
.PP
Will translate to:
.PP
.Vb 1
\&    { range: { price: { gt: 50, lt: 100 } } }
.Ve
.PP
\fISupported Operators\fR
.IX Subsection "Supported Operators"
.PP
\&\fBgt\fR via >, \fBgte\fR via >=, \fBlt\fR via <, \fBlte\fR via <=
.SS "App::ElasticSearch::Utilities::QueryString::Underscored"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::Underscored"
This plugin translates some special underscore surrounded tokens into
the Elasticsearch Query \s-1DSL.\s0
.PP
Implemented:
.PP
\fI_prefix_\fR
.IX Subsection "_prefix_"
.PP
Example query string:
.PP
.Vb 1
\&    _prefix_:useragent:\*(AqGo \*(Aq
.Ve
.PP
Translates into:
.PP
.Vb 1
\&    { prefix => { useragent => \*(AqGo \*(Aq } }
.Ve
.SS "App::ElasticSearch::Utilities::QueryString::FileExpansion"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::FileExpansion"
If the match ends in .dat, .txt, .csv, or .json then we attempt to read a file with that name and \s-1OR\s0 the condition:
.PP
.Vb 5
\&    $ cat test.dat
\&    50  1.2.3.4
\&    40  1.2.3.5
\&    30  1.2.3.6
\&    20  1.2.3.7
.Ve
.PP
Or
.PP
.Vb 5
\&    $ cat test.csv
\&    50,1.2.3.4
\&    40,1.2.3.5
\&    30,1.2.3.6
\&    20,1.2.3.7
.Ve
.PP
Or
.PP
.Vb 5
\&    $ cat test.txt
\&    1.2.3.4
\&    1.2.3.5
\&    1.2.3.6
\&    1.2.3.7
.Ve
.PP
Or
.PP
.Vb 5
\&    $ cat test.json
\&    { "ip": "1.2.3.4" }
\&    { "ip": "1.2.3.5" }
\&    { "ip": "1.2.3.6" }
\&    { "ip": "1.2.3.7" }
.Ve
.PP
We can source that file:
.PP
.Vb 2
\&    src_ip:test.dat      => src_ip:(1.2.3.4 1.2.3.5 1.2.3.6 1.2.3.7)
\&    src_ip:test.json[ip] => src_ip:(1.2.3.4 1.2.3.5 1.2.3.6 1.2.3.7)
.Ve
.PP
This make it simple to use the \-\-data\-file output options and build queries
based off previous queries. For .txt and .dat file, the delimiter for columns
in the file must be either a tab or a null.  For files ending in
\&.csv, Text::CSV_XS is used to accurate parsing of the file format.  Files
ending in .json are considered to be newline-delimited \s-1JSON.\s0
.PP
You can also specify the column of the data file to use, the default being the last column or (\-1).  Columns are
\&\fBzero-based\fR indexing. This means the first column is index 0, second is 1, ..  The previous example can be rewritten
as:
.PP
.Vb 1
\&    src_ip:test.dat[1]
.Ve
.PP
or:
    src_ip:test.dat[\-1]
.PP
For newline delimited \s-1JSON\s0 files, you need to specify the key path you want to extract from the file.  If we have a
\&\s-1JSON\s0 source file with:
.PP
.Vb 3
\&    { "first": { "second": { "third": [ "bob", "alice" ] } } }
\&    { "first": { "second": { "third": "ginger" } } }
\&    { "first": { "second": { "nope":  "fred" } } }
.Ve
.PP
We could search using:
.PP
.Vb 1
\&    actor:test.json[first.second.third]
.Ve
.PP
Which would expand to:
.PP
.Vb 1
\&    { "terms": { "actor": [ "alice", "bob", "ginger" ] } }
.Ve
.PP
This option will iterate through the whole file and unique the elements of the list.  They will then be transformed into
an appropriate terms query <http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html>.
.SS "App::ElasticSearch::Utilities::QueryString::Nested"
.IX Subsection "App::ElasticSearch::Utilities::QueryString::Nested"
Implement the proposed nested query syntax early.  Example:
.PP
.Vb 1
\&    nested_path:"field:match AND string"
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Brad Lhotsky <brad@divisionbyzero.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Brad Lhotsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The (three\-clause) BSD License
.Ve
