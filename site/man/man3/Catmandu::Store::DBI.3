.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catmandu::Store::DBI 3"
.TH Catmandu::Store::DBI 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catmandu::Store::DBI \- A Catmandu::Store backed by DBI
.SH "VERSION"
.IX Header "VERSION"
Version 0.0424
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # From the command line
\&    $ catmandu import JSON to DBI \-\-data_source SQLite:mydb.sqlite < data.json
\&
\&    # Or via a configuration file
\&    $ cat catmandu.yml
\&    \-\-\-
\&    store:
\&       mydb:
\&         package: DBI
\&         options:
\&            data_source: "dbi:mysql:database=mydb"
\&            username: xyz
\&            password: xyz
\&    ...
\&    $ catmandu import JSON to mydb < data.json
\&    $ catmandu export mydb to YAML > data.yml
\&    $ catmandu export mydb \-\-id 012E929E\-FF44\-11E6\-B956\-AE2804ED5190 to JSON > record.json
\&    $ catmandu count mydb
\&    $ catmandy delete mydb
\&
\&    # From perl
\&    use Catmandu::Store::DBI;
\&
\&    my $store = Catmandu::Store::DBI\->new(
\&        data_source => \*(AqDBI:mysql:database=mydb\*(Aq, # prefix "DBI:" optional
\&        username => \*(Aqxyz\*(Aq, # optional
\&        password => \*(Aqxyz\*(Aq, # optional
\&    );
\&
\&    my $obj1 = $store\->bag\->add({ name => \*(AqPatrick\*(Aq });
\&
\&    printf "obj1 stored as %s\en" , $obj1\->{_id};
\&
\&    # Force an id in the store
\&    my $obj2 = $store\->bag\->add({ _id => \*(Aqtest123\*(Aq , name => \*(AqNicolas\*(Aq });
\&
\&    my $obj3 = $store\->bag\->get(\*(Aqtest123\*(Aq);
\&
\&    $store\->bag\->delete(\*(Aqtest123\*(Aq);
\&
\&    $store\->bag\->delete_all;
\&
\&    # All bags are iterators
\&    $store\->bag\->each(sub { ... });
\&    $store\->bag\->take(10)\->each(sub { ... });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Catmandu::Store::DBI is a Perl package that can store data into
\&\s-1DBI\s0 backed databases. The database as a whole is  a 'store'
Catmandu::Store. Databases tables are 'bags' (Catmandu::Bag).
.PP
Databases need to be preconfigured for accepting Catmandu data. When
no specialized Catmandu tables exist in a database then Catmandu will
create them automatically. See  \*(L"\s-1DATABASE CONFIGURATION\*(R"\s0 below.
.PP
\&\s-1DO NOT USE\s0 Catmandu::Store::DBI on an existing database! Tables and
data can be deleted and changed.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Currently only MySQL, Postgres and SQLite are supported. Text columns are also
assumed to be utf\-8.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.IP "data_source" 4
.IX Item "data_source"
Required. The connection parameters to the database. See \s-1DBI\s0 for more information.
.Sp
Examples:
.Sp
.Vb 4
\&      dbi:mysql:foobar   <= a local mysql database \*(Aqfoobar\*(Aq
\&      dbi:Pg:dbname=foobar;host=myserver.org;port=5432 <= a remote PostGres database
\&      dbi:SQLite:mydb.sqlite <= a local SQLLite file based database mydb.sqlite
\&      dbi:Oracle:host=myserver.org;sid=data01 <= a remote Oracle database
.Ve
.Sp
Drivers for each database need to be available on your computer. Install then with:
.Sp
.Vb 3
\&    cpanm DBD::mysql
\&    cpanm DBD::Pg
\&    cpanm DBD::SQLite
.Ve
.IP "user" 4
.IX Item "user"
Optional. A user name to connect to the database
.IP "password" 4
.IX Item "password"
Optional. A password for connecting to the database
.IP "timeout" 4
.IX Item "timeout"
Optional. Timeout for a inactive database handle. When timeout is reached, Catmandu
checks if the connection is still alive (by use of ping) or it recreates the connection.
See \s-1TIMEOUTS\s0 below for more information.
.IP "reconnect_after_timeout" 4
.IX Item "reconnect_after_timeout"
Optional. When a timeout is reached, Catmandu reconnects to the database. By
default set to '0'
.IP "default_order" 4
.IX Item "default_order"
Optional. Default the default sorting of results when returning an iterator.
Choose '\s-1ID\s0' to order on the configured identifier field, '\s-1NONE\s0' to skip all
ordering, or \*(L"$field\*(R" where \f(CW$field\fR is the name of a table column. By default
set to '\s-1ID\s0'.
.SH "DATABASE CONFIGURATION"
.IX Header "DATABASE CONFIGURATION"
When no tables exists for storing data in the database, then Catmandu
will create them. By default tables are created for each Catmandu::Bag
which contain an '_id' and 'data' column.
.PP
This behavior can be changed with mapping option:
.PP
.Vb 10
\&    my $store = Catmandu::Store::DBI\->new(
\&        data_source => \*(AqDBI:mysql:database=test\*(Aq,
\&        bags => {
\&            # books table
\&            books => {
\&                mapping => {
\&                    # these keys will be directly mapped to columns
\&                    # all other keys will be serialized in the data column
\&                    title => {type => \*(Aqstring\*(Aq, required => 1, column => \*(Aqbook_title\*(Aq},
\&                    isbn => {type => \*(Aqstring\*(Aq, unique => 1},
\&                    authors => {type => \*(Aqstring\*(Aq, array => 1}
\&                }
\&            }
\&        }
\&    );
.Ve
.PP
For keys that have a corresponding table column configured, the method 'select' of class Catmandu::Store::DBI::Bag provides
a more efficie\*:nt way to query records.
.PP
See Catmandu::Store::DBI::Bag for more information.
.SS "Column types"
.IX Subsection "Column types"
.IP "string" 4
.IX Item "string"
.PD 0
.IP "integer" 4
.IX Item "integer"
.IP "binary" 4
.IX Item "binary"
.IP "datetime" 4
.IX Item "datetime"
.PD
Only MySQL, PostgreSQL
.IP "datetime_milli" 4
.IX Item "datetime_milli"
Only MySQL, PostgreSQL
.IP "json" 4
.IX Item "json"
Only PostgreSQL
.SS "Column options"
.IX Subsection "Column options"
.IP "column" 4
.IX Item "column"
Name of the table column if it differs from the key in your data.
.IP "array" 4
.IX Item "array"
Boolean option, default is \f(CW0\fR. Note that this is only supported for PostgreSQL.
.IP "unique" 4
.IX Item "unique"
Boolean option, default is \f(CW0\fR.
.IP "index" 4
.IX Item "index"
Boolean option, default is \f(CW0\fR. Ignored if \f(CW\*(C`unique\*(C'\fR is true.
.IP "required" 4
.IX Item "required"
Boolean option, default is \f(CW0\fR.
.SH "TIMEOUT"
.IX Header "TIMEOUT"
It is a good practice to set the timeout high enough. When using transactions, one should avoid this situation:
.PP
.Vb 5
\&    $bag\->store\->transaction(sub{
\&        $bag\->add({ _id => "1" });
\&        sleep $timeout;
\&        $bag\->add({ _id => "2" });
\&    });
.Ve
.PP
The following warning appears:
.PP
.Vb 2
\&    commit ineffective with AutoCommit enabled at lib//Catmandu/Store/DBI.pm line 73.
\&    DBD::SQLite::db commit failed: attempt to commit on inactive database handle
.Ve
.PP
This has the following reasons:
.PP
.Vb 6
\&    1.  first record added
\&    2.  timeout is reached, the connection is recreated
\&    3.  the option AutoCommit is set. So the database handle commits the current transaction. The first record is committed.
\&    4.  this new connection handle is used now. We\*(Aqre still in the method "transaction", but there is no longer a real transaction at database level.
\&    5.  second record is added (committed)
\&    6.  commit is issued. But this unnecessary, so the database handle throws a warning.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catmandu::Bag, \s-1DBI\s0
