.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Devel::ebug 3"
.TH Devel::ebug 3 "2020-07-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::ebug \- A simple, extensible Perl debugger
.SH "VERSION"
.IX Header "VERSION"
version 0.63
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Devel::ebug;
\&  my $ebug = Devel::ebug\->new;
\&  $ebug\->program("calc.pl");
\&  $ebug\->load;
\& 
\&  print "At line: "       . $ebug\->line       . "\en";
\&  print "In subroutine: " . $ebug\->subroutine . "\en";
\&  print "In package: "    . $ebug\->package    . "\en";
\&  print "In filename: "   . $ebug\->filename   . "\en";
\&  print "Code: "          . $ebug\->codeline   . "\en";
\&  $ebug\->step;
\&  $ebug\->step;
\&  $ebug\->next;
\&  my($stdout, $stderr) = $ebug\->output;
\&  my $actual_line = $ebug\->break_point(6);
\&  $ebug\->break_point(6, \*(Aq$e == 4\*(Aq);
\&  $ebug\->break_point("t/Calc.pm", 29);
\&  $ebug\->break_point("t/Calc.pm", 29, \*(Aq$i == 2\*(Aq);
\&  $ebug\->break_on_load("t/Calc.pm");
\&  my $actual_line = $ebug\->break_point_subroutine("main::add");
\&  $ebug\->break_point_delete(29);
\&  $ebug\->break_point_delete("t/Calc.pm", 29);
\&  my @filenames    = $ebug\->filenames();
\&  my @break_points = $ebug\->break_points();
\&  my @break_points = $ebug\->break_points("t/Calc.pm");
\&  my @break_points = $ebug\->break_points_with_condition();
\&  my @break_points = $ebug\->break_points_with_condition("t/Calc.pm");
\&  my @break_points = $ebug\->all_break_points_with_condition();
\&  $ebug\->watch_point(\*(Aq$x > 100\*(Aq);
\&  my $codelines = $ebug\->codelines(@span);
\&  $ebug\->run;
\&  my $pad  = $ebug\->pad;
\&  foreach my $k (sort keys %$pad) {
\&    my $v = $pad\->{$k};
\&    print "Variable: $k = $v\en";
\&  }
\&  my $v = $ebug\->eval(\*(Aq2 ** $exp\*(Aq);
\&  my( $v, $is_exception ) = $ebug\->eval(\*(Aqdie 123\*(Aq);
\&  my $y = $ebug\->yaml(\*(Aq$z\*(Aq);
\&  my @frames = $ebug\->stack_trace;
\&  my @frames2 = $ebug\->stack_trace_human;
\&  $ebug\->undo;
\&  $ebug\->return;
\&  print "Finished!\en" if $ebug\->finished;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A debugger is a computer program that is used to debug other
programs. Devel::ebug is a simple, extensible Perl debugger with a
clean \s-1API.\s0 Using this module, you may easily write a Perl debugger to
debug your programs. Alternatively, it comes with an interactive
debugger, ebug.
.PP
perl5db.pl, Perl's current debugger is currently 2,600 lines of magic
and special cases. The code is nearly unreadable: fixing bugs and
adding new features is fraught with difficulties. The debugger has no
test suite which has caused breakage with changes that couldn't be
properly tested. It will also not debug regexes. Devel::ebug is
aimed at fixing these problems and delivering a replacement debugger
which provides a well-tested simple programmatic interface to
debugging programs. This makes it easier to build debuggers on top of
Devel::ebug, be they console\-, curses\-, \s-1GUI\-\s0 or Ajax-based.
.PP
There are currently two user interfaces to Devel::debug, ebug
and ebug_http. ebug is a console-based interface to debugging
programs, much like perl5db.pl. ebug_http is an innovative
web-based interface to debugging programs.
.PP
Note that if you're debugging a program, you can invoke the debugger
in the program itself by using the \s-1INT\s0 signal:
.PP
.Vb 1
\&  kill 2, $$ if $square > 100;
.Ve
.PP
Devel::ebug is a work in progress.
.PP
Internally, Devel::ebug consists of two parts. The frontend is
Devel::ebug, which you interact with. The frontend starts the code
you are debugging in the background under the backend (running it
under perl \-d:ebug code.pl). The backend starts a \s-1TCP\s0 server, which
the frontend then connects to, and uses this to drive the
backend. This adds some flexibility in the debugger. There is some
minor security in the client/server startup (a secret word), and a
random port is used from 3141\-4165 so that multiple debugging sessions
can happen concurrently.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
The constructor creats a Devel::ebug object:
.PP
.Vb 1
\&  my $ebug = Devel::ebug\->new;
.Ve
.SS "program"
.IX Subsection "program"
The program method selects which program to load:
.PP
.Vb 1
\&  $ebug\->program("calc.pl");
.Ve
.SS "load"
.IX Subsection "load"
The load method loads the program and gets ready to debug it:
.PP
.Vb 1
\&  $ebug\->load;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "break_point"
.IX Subsection "break_point"
The break_point method sets a break point in a program. If you are
running through a program, the execution will stop at a break point.
Break points can be set in a few ways.
.PP
A break point can be set at a line number in the current file:
.PP
.Vb 1
\&  my $actual_line = $ebug\->break_point(6);
.Ve
.PP
A break point can be set at a line number in the current file with a
condition that must be true for execution to stop at the break point:
.PP
.Vb 1
\&  my $actual_line = $ebug\->break_point(6, \*(Aq$e = 4\*(Aq);
.Ve
.PP
A break point can be set at a line number in a file:
.PP
.Vb 1
\&  my $actual_line = $ebug\->break_point("t/Calc.pm", 29);
.Ve
.PP
A break point can be set at a line number in a file with a condition
that must be true for execution to stop at the break point:
.PP
.Vb 1
\&  my $actual_line = $ebug\->break_point("t/Calc.pm", 29, \*(Aq$i == 2\*(Aq);
.Ve
.PP
Breakpoints can not be set on some lines (for example comments); in
this case a breakpoint will be set at the next breakable line, and the
line number will be returned. If no such line exists, no breakpoint is
set and the function returns \f(CW\*(C`undef\*(C'\fR.
.SS "break_on_load"
.IX Subsection "break_on_load"
Set a breakpoint on file loading, the file name can be relative or absolute.
.SS "break_point_delete"
.IX Subsection "break_point_delete"
The break_point_delete method deletes an existing break point. A break
point at a line number in the current file can be deleted:
.PP
.Vb 1
\&  $ebug\->break_point_delete(29);
.Ve
.PP
A break point at a line number in a file can be deleted:
.PP
.Vb 1
\&  $ebug\->break_point_delete("t/Calc.pm", 29);
.Ve
.SS "break_point_subroutine"
.IX Subsection "break_point_subroutine"
The break_point_subroutine method sets a break point in a program
right at the beginning of the subroutine. The subroutine is specified
with the full package name:
.PP
.Vb 2
\&  my $line = $ebug\->break_point_subroutine("main::add");
\&  $ebug\->break_point_subroutine("Calc::fib");
.Ve
.PP
The return value is the line at which the break point is set.
.SS "break_points"
.IX Subsection "break_points"
The break_points method returns a list of all the line numbers in a
given file that have a break point set.
.PP
Return the list of breakpoints in the current file:
.PP
.Vb 1
\&  my @break_points = $ebug\->break_points();
.Ve
.PP
Return the list of breakpoints in a given file:
.PP
.Vb 1
\&  my @break_points = $ebug\->break_points("t/Calc.pm");
.Ve
.SS "break_points_with_condition"
.IX Subsection "break_points_with_condition"
The break_points method returns a list of break points for a given file.
.PP
Return the list of breakpoints in the current file:
.PP
.Vb 1
\&  my @break_points = $ebug\->break_points_with_condition();
.Ve
.PP
Return the list of breakpoints in a given file:
.PP
.Vb 1
\&  my @break_points = $ebug\->break_points_with_condition("t/Calc.pm");
.Ve
.PP
Each element of the list has the form
.PP
.Vb 4
\&  { filename  => "t/Calc.pm",
\&    line      => 29,
\&    condition => "$foo > 12",
\&    }
.Ve
.PP
where \f(CW\*(C`condition\*(C'\fR might not be present.
.SS "all_break_points_with_condition"
.IX Subsection "all_break_points_with_condition"
Like \f(CW\*(C`break_points_with_condition\*(C'\fR but returns a list of break points
for the whole program.
.SS "codeline"
.IX Subsection "codeline"
The codeline method returns the line of code that is just about to be
executed:
.PP
.Vb 1
\&  print "Code: "          . $ebug\->codeline   . "\en";
.Ve
.SS "codelines"
.IX Subsection "codelines"
The codelines method returns lines of code.
.PP
It can return all the code lines in the current file:
.PP
.Vb 1
\&  my @codelines = $ebug\->codelines();
.Ve
.PP
It can return a span of code lines from the current file:
.PP
.Vb 1
\&  my @codelines = $ebug\->codelines(1, 3, 4, 5);
.Ve
.PP
It can return all the code lines in a file:
.PP
.Vb 1
\&  my @codelines = $ebug\->codelines("t/Calc.pm");
.Ve
.PP
It can return a span of code lines in a file:
.PP
.Vb 1
\&  my @codelines = $ebug\->codelines("t/Calc.pm", 5, 6);
.Ve
.SS "eval"
.IX Subsection "eval"
The eval method evaluates Perl code in the current program and returns
the result. If the evaluation results in an exception, \f(CW$@\fR is
returned.
.PP
.Vb 1
\&  my $v = $ebug\->eval(\*(Aq2 ** $exp\*(Aq);
.Ve
.PP
In list context, eval also returns a flag indicating if the evaluation
resulted in an exception.
.PP
.Vb 1
\&  my( $v, $is_exception ) = $ebug\->eval(\*(Aqdie 123\*(Aq);
.Ve
.SS "filename"
.IX Subsection "filename"
The filename method returns the filename of the currently running code:
.PP
.Vb 1
\&  print "In filename: "   . $ebug\->filename   . "\en";
.Ve
.SS "filenames"
.IX Subsection "filenames"
The filenames method returns a list of the filenames of all the files
currently loaded:
.PP
.Vb 1
\&  my @filenames = $ebug\->filenames();
.Ve
.SS "finished"
.IX Subsection "finished"
The finished method returns whether the program has finished running:
.PP
.Vb 1
\&  print "Finished!\en" if $ebug\->finished;
.Ve
.SS "line"
.IX Subsection "line"
The line method returns the line number of the statement about to be
executed:
.PP
.Vb 1
\&  print "At line: "       . $ebug\->line       . "\en";
.Ve
.SS "next"
.IX Subsection "next"
The next method steps onto the next line in the program. It executes
any subroutine calls but does not step through them.
.PP
.Vb 1
\&  $ebug\->next;
.Ve
.SS "output"
.IX Subsection "output"
The output method returns any content the program has output to either
standard output or standard error:
.PP
.Vb 1
\&  my($stdout, $stderr) = $ebug\->output;
.Ve
.SS "package"
.IX Subsection "package"
The package method returns the package of the currently running code:
.PP
.Vb 1
\&  print "In package: "    . $ebug\->package    . "\en";
.Ve
.SS "pad"
.IX Subsection "pad"
.Vb 5
\&  my $pad  = $ebug\->pad;
\&  foreach my $k (sort keys %$pad) {
\&    my $v = $pad\->{$k};
\&    print "Variable: $k = $v\en";
\&  }
.Ve
.SS "return"
.IX Subsection "return"
The return subroutine returns from a subroutine. It continues running
the subroutine, then single steps when the program flow has exited the
subroutine:
.PP
.Vb 1
\&  $ebug\->return;
.Ve
.PP
It can also return your own values from a subroutine, for testing
purposes:
.PP
.Vb 1
\&  $ebug\->return(3.141);
.Ve
.SS "run"
.IX Subsection "run"
The run subroutine starts executing the code. It will only stop on a
break point or watch point.
.PP
.Vb 1
\&  $ebug\->run;
.Ve
.SS "step"
.IX Subsection "step"
The step method steps onto the next line in the program. It steps
through into any subroutine calls.
.PP
.Vb 1
\&  $ebug\->step;
.Ve
.SS "subroutine"
.IX Subsection "subroutine"
The subroutine method returns the subroutine of the currently working
code:
.PP
.Vb 1
\&  print "In subroutine: " . $ebug\->subroutine . "\en";
.Ve
.SS "stack_trace"
.IX Subsection "stack_trace"
The stack_trace method returns the current stack trace, using
Devel::StackTrace. It returns a list of Devel::StackTraceFrame
methods:
.PP
.Vb 5
\&  my @traces = $ebug\->stack_trace;
\&  foreach my $trace (@traces) {
\&    print $trace\->package, "\->",$trace\->subroutine,
\&    "(", $trace\->filename, "#", $trace\->line, ")\en";
\&  }
.Ve
.SS "stack_trace_human"
.IX Subsection "stack_trace_human"
The stack_trace_human method returns the current stack trace in a human-readable format:
.PP
.Vb 4
\&  my @traces = $ebug\->stack_trace_human;
\&  foreach my $trace (@traces) {
\&    print "$trace\en";
\&  }
.Ve
.SS "undo"
.IX Subsection "undo"
The undo method undoes the last action. It accomplishes this by
restarting the process and passing (almost) all the previous commands
to it. Note that commands which do not change state are
ignored. Commands that change state are: break_point, break_point_delete,
break_point_subroutine, eval, next, step, return, run and watch_point.
.PP
.Vb 1
\&  $ebug\->undo;
.Ve
.PP
It can also undo multiple commands:
.PP
.Vb 1
\&  $ebug\->undo(3);
.Ve
.SS "watch_point"
.IX Subsection "watch_point"
The watch point method sets a watch point. A watch point has a
condition, and the debugger will stop running as soon as this
condition is true:
.PP
.Vb 1
\&  $ebug\->watch_point(\*(Aq$x > 100\*(Aq);
.Ve
.SS "yaml"
.IX Subsection "yaml"
The eval method evaluates Perl code in the current program and returns
the result of \s-1YAML\s0's \fBDump()\fR method:
.PP
.Vb 1
\&  my $y = $ebug\->yaml(\*(Aq$z\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perldebguts
.SH "BUGS"
.IX Header "BUGS"
Devel::ebug does not quite work under 5.8.0.
.PP
Devel::ebug does not handle signals under Windows.
.SH "AUTHOR"
.IX Header "AUTHOR"
Original author: Leon Brocard <acme@astray.com>
.PP
Current maintainer: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
Brock Wilcox <awwaiid@thelackthereof.org>
.PP
Taisuke Yamada
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2005\-2020 by Leon Brocard.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
