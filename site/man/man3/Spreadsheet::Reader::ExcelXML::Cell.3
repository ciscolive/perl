.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::ExcelXML::Cell 3"
.TH Spreadsheet::Reader::ExcelXML::Cell 3 "2017-04-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::ExcelXML::Cell \- ExcelXML Cell data class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        #!/usr/bin/env perl
\&        use Spreadsheet::Reader::ExcelXML::Cell;
\&        use Spreadsheet::Reader::ExcelXML::Error;
\&
\&        my      $cell_inputs = {
\&                        \*(Aqcell_hidden\*(Aq => 0,
\&                        \*(Aqr\*(Aq => \*(AqA2\*(Aq,
\&                        \*(Aqcell_row\*(Aq => 1,
\&                        \*(Aqcell_unformatted\*(Aq => \*(AqHello\*(Aq,
\&                        \*(Aqcell_col\*(Aq => 0,
\&                        \*(Aqcell_xml_value\*(Aq => \*(AqHello\*(Aq,
\&                        \*(Aqcell_type\*(Aq => \*(AqText\*(Aq,
\&                        \*(Aqerror_inst\*(Aq => Spreadsheet::Reader::ExcelXML::Error\->new,
\&                };
\&        my      $cell_instance = Spreadsheet::Reader::ExcelXML::Cell\->new( $cell_inputs );
\&        print "Cell value is: " . $cell_instance\->value . "\en";
\&
\&        ###########################
\&        # SYNOPSIS Output
\&        # Cell value is: Hello
\&        ###########################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the class that contains cell data.  There are no \s-1XML\s0 parsing actions taken in the
background of this class.  All data has been pre\-coalated/built from the Worksheet
 class.  In general the Worksheet class
will populate the attributes of this class when it is generated.  If you want to use it
as a standalone class just fill in the Attributes below.  It should be
noted that the Formatter class also pre-converts
 the
unformatted value.  Not much goes on here but access or excesize of code provided from
other places.
.SS "Primary Methods"
.IX Subsection "Primary Methods"
This is the method used to transform data stored in the Attributes
(not just return it directly).  The method is an object method and should be implemented
on the instance.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        my $value = $cell_intance\->value;
.Ve
.PP
\fIvalue\fR
.IX Subsection "value"
.Sp
.RS 4
\&\fBDefinition:\fR Returns the formatted value of the cell transformed from the
base xml string if it is available. In the weird case where the
cell_xml_value is not available but the unformatted value is
then this method will use the unformatted value.  This method then applies any
conversion stored in the cell_coercion attribute.  If there is
no format/conversion set then this will return the selected value. Any failures
to process this value can be retrieved with \f(CW$self\fR\->error.
.Sp
\&\fBAccepts:\fRNothing
.Sp
\&\fBReturns:\fR the cell 'value' processed by the set conversion
.RE
.SS "Attributes"
.IX Subsection "Attributes"
This class is just a storage of coallated information about the requested cell stored
in the following attributes. For more information on attributes see
Moose::Manual::Attributes.  Data about the cell can be retrieved from each
attribute using the 'attribute methods'.  'Delegated methods' are methods
available at the class or instance level directly delegated from that
specific attribute.
.PP
\fIerror_inst\fR
.IX Subsection "error_inst"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds an 'error' object instance.  In general
the package will share a reference for this instance accross the workbook with all
worksheets and all cells so any 'set' or 'get' action should be available at all
touch points for this error object.  If you wish to have a unique error instance
you can set it here.
.Sp
\&\fBDefault:\fR a Spreadsheet::Reader::ExcelXML::Error instance with the
attributes set as;
.Sp
.Vb 1
\&        ( should_warn => 0 )
.Ve
.Sp
\&\fBRange:\fR a 'Spreadsheet::Reader::ExcelXML::Error' instance.  To roll this on your
own, the minimum list of methods to implement for your own instance is;
.Sp
.Vb 1
\&        error set_error clear_error set_warnings if_warn
.Ve
.Sp
\&\fBDelegated methods\fR Links to default implementation and method name conversions
(if any) delegated from this attribute to the package.
.Sp
.RS 4
\&\*(L"error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"set_error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"clear_error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"set_warnings\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"if_warn\*(R" in Spreadsheet::Reader::ExcelXML::Error
.RE
.RE
.RS 4
.RE
.PP
\fIcell_xml_value\fR
.IX Subsection "cell_xml_value"
.Sp
.RS 4
\&\fBDefinition:\fR This contains the raw value stored in xml for this cell.  This
can be different than the 'cell_unformatted' value based on archane rules set
by Microsoft.
.Sp
\&\fBRange:\fRAny string or nothing
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBxml_value\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_xml_value\fR
.Sp
.RS 4
\&\fBDefinition:\fR predicate for this attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_unformatted\fR
.IX Subsection "cell_unformatted"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the unformatted value of the cell.  The unformatted
value of the cell as defined by this package is the value displayed in the
formula bar when selecting the cell.  This can be a bit squidgy where the cell
is actually populated with a formula.  In that case this should contain the
implied value based on my (or your) visibility to the excel value that would
normally be there.
.Sp
\&\fBRange:\fR a string
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBunformatted\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_unformatted\fR
.Sp
.RS 4
\&\fBDefinition:\fR a predicate method for the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIrich_text\fR
.IX Subsection "rich_text"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds a rich text data structure like
\&\*(L"\fBget_rich_text()\fR\*(R" in Spreadsheet::ParseExcel::Cell with the exception that it
doesn't bless each hashref into an object.  The hashref's are also organized
per the Excel xlsx information in the the sharedStrings.xml file.  In general
this is an arrayref of arrayrefs where the second level contains two positions.
The first position is the place (from zero) where the formatting is implemented.
The second position is a hashref of the formatting values.  The format is in
force until the next start place is identified.
.Sp
.RS 4
\&\fBnote:\fR It is important to understand that Excel can store two formats for the
same cell and often they don't agree.  For example using the attribute cell_font
 will not always contain the same value as specific fonts (or any font)
listed in the rich text array.
.RE
.RE
.RS 4
.Sp
\&\fBDefault:\fR undef = no rich text defined for this cell
.Sp
\&\fBRange:\fR an array ref of rich_text positions and definitions
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_rich_text\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_rich_text\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_font\fR
.IX Subsection "cell_font"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the font assigned to the cell
.Sp
\&\fBRange:\fR a hashref of definitions for the font
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_font\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute contents
.RE
.RE
.RS 4
.Sp
\&\fBhas_font\fR
.Sp
.RS 4
\&\fBDefinition:\fR Predicate for the attribute contentss
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_border\fR
.IX Subsection "cell_border"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the border settings assigned to the cell
.Sp
\&\fBRange:\fR a hashref of border definitions
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_border\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute contents
.RE
.RE
.RS 4
.Sp
\&\fBhas_border\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has any contents
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_style\fR
.IX Subsection "cell_style"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the style settings assigned to the cell
.Sp
\&\fBRange:\fR a hashref of style definitions
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_style\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute contents
.RE
.RE
.RS 4
.Sp
\&\fBhas_style\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_fill\fR
.IX Subsection "cell_fill"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the fill settings assigned to the cell
.Sp
\&\fBRange:\fR a hashref of style definitions
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_fill\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_fill\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_alignment\fR
.IX Subsection "cell_alignment"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the alignment settings assigned to the cell
.Sp
\&\fBRange:\fR The alignment definition
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_alignment\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_alignment\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_type\fR
.IX Subsection "cell_type"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the type of data stored in the cell.  In general it
follows the convention of ParseExcel
 (Date, Numeric,
or Text) however, since custom coercions will change data to some possible non excel
standard state this also allows a 'Custom' type representing any cell with a custom
conversion assigned to it (by you either at the worksheet level or here).
.Sp
\&\fBRange:\fR Text = Strings, Numeric = Real Numbers, Date = Real Numbers with an
assigned Date conversion or \s-1ISO\s0 dates, Custom = any stored value with a custom
conversion
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBtype\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_type\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_encoding\fR
.IX Subsection "cell_encoding"
.Sp
.RS 4
\&\fBDefinition:\fR This holds the byte encodeing of the data stored in the cell
.Sp
\&\fBDefault:\fR Unicode
.Sp
\&\fBRange:\fR Traditional encoding options
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBencoding\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_encoding\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_merge\fR
.IX Subsection "cell_merge"
.Sp
.RS 4
\&\fBDefinition:\fR if the cell is part of a group of merged cells this will
store the upper left and lower right cell \s-1ID\s0's in a string concatenated
with a ':'
.Sp
\&\fBDefault:\fR undef
.Sp
\&\fBRange:\fR two cell \s-1ID\s0's
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBmerge_range\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBis_merged\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_formula\fR
.IX Subsection "cell_formula"
.Sp
.RS 4
\&\fBDefinition:\fR if the cell value (raw xml) is calculated based on a
formula the Excel formula string is stored in this attribute.
.Sp
\&\fBDefault:\fR undef
.Sp
\&\fBRange:\fR Excel formula string
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBformula\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_formula\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_row\fR
.IX Subsection "cell_row"
.Sp
.RS 4
\&\fBDefinition:\fR This is the sheet row that the cell was read from.
The value is stored in the user context ( either count from zero
or count from one).
.Sp
\&\fBRange:\fR the minimum row to the maximum row
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBrow\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_row\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_col\fR
.IX Subsection "cell_col"
.Sp
.RS 4
\&\fBDefinition:\fR This is the sheet column that the cell was read from.
The value is stored in the user context ( either count from zero
or count from one).
.Sp
\&\fBRange:\fR the minimum column to the maximum column
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBcol\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIr\fR
.IX Subsection "r"
.Sp
.RS 4
\&\fBDefinition:\fR This is the cell \s-1ID\s0 of the cell
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBcell_id\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_cell_id\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_hyperlink\fR
.IX Subsection "cell_hyperlink"
.Sp
.RS 4
\&\fBDefinition:\fR This stores an arraryref of hyperlinks from the cell
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_hyperlink\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.Sp
\&\fBhas_hyperlink\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has anything stored
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcell_hidden\fR
.IX Subsection "cell_hidden"
.Sp
.RS 4
\&\fBDefinition:\fR This stores the hidden state of the cell.  The stored
value indicates which entity is controlling hiddeness.
.Sp
\&\fBRange:\fR (sheet|column|row|0)
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBis_hidden\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
has cell_coercion =>(
		isa			=> HasMethods[ 'assert_coerce', 'display_name' ],
		reader		=> 'get_coercion',
		writer		=> 'set_coercion',
		predicate	=> 'has_coercion',
		clearer		=> 'clear_coercion',
		handles		=>{
			coercion_name => 'display_name',#
		},
	);
.PP
\fIcell_coercion\fR
.IX Subsection "cell_coercion"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds the tranformation code to turn an
unformatted  value into a formatted value.
.Sp
\&\fBDefault:\fR a Type::Tiny instance with sub types set to assign different
inbound data types to different coercions for the target outcome of formatted
data.
.Sp
\&\fBRange:\fR If you wish to set this with your own code it must have two
methods.  First, 'assert_coerce' which will be applied when transforming
the unformatted value.  Second, 'display_name' which will be used to self
identify.  For an example of how to build a custom format see
\&\*(L"custom_formats\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_coercion\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the contents of the attribute
.RE
.RE
.RS 4
.Sp
\&\fBclear_coercion\fR
.Sp
.RS 4
\&\fBDefinition:\fR used to clear this attribute
.RE
.RE
.RS 4
.Sp
\&\fBset_coercion\fR
.Sp
.RS 4
\&\fBDefinition:\fR used to set a new coercion instance.  Implementation
of this method will also switch the cell type to 'Custom'.
.RE
.RE
.RS 4
.Sp
\&\fBhas_coercion\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicate if any coecion code is applied
.RE
.RE
.RS 4
.Sp
\&\fBDelegated method:\fR Methods delegated from the instance for conversion
type checking.  The name delegated to is listed next to a link for the
default method delegated from.
.Sp
.RS 4
\&\fBcoercion_name\fR => \*(L"display_name\*(R" in Type::Tiny
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::ExcelXML/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-excelxml/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Return the merge range in array and hash formats
.Sp
\&\fB2.\fR Add calc chain values
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.RS 4
Jed Lund
.Sp
jandrew@cpan.org
.RE
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016 by Jed
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
Spreadsheet::Reader::ExcelXML \- the package
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::Read \- generic Spreadsheet reader
.Sp
Spreadsheet::ParseExcel \- Excel binary version 2003 and earlier (.xls files)
.Sp
Spreadsheet::XLSX \- Excel version 2007 and later
.Sp
Spreadsheet::ParseXLSX \- Excel version 2007 and later
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
