.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojolicious::Plugin::OpenAPI::Guides::OpenAPIv3 3"
.TH Mojolicious::Plugin::OpenAPI::Guides::OpenAPIv3 3 "2020-10-06" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojolicious::Plugin::OpenAPI::Guides::OpenAPIv3 \- Mojolicious <3 OpenAPI v3
.SH "OVERVIEW"
.IX Header "OVERVIEW"
This guide will give you an introduction on how to use
Mojolicious::Plugin::OpenAPI with OpenAPI version v3.x.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
.SS "Specification"
.IX Subsection "Specification"
This plugin reads an OpenAPI specification <https://openapis.org/specification>
and generates routes and input/output rules from it. See JSON::Validator for
supported schema file formats.
.PP
.Vb 10
\&  {
\&    "openapi": "3.0.2",
\&    "info": {
\&      "version": "1.0",
\&      "title": "Some awesome API"
\&    },
\&    "paths": {
\&      "/pets": {
\&        "get": {
\&          "operationId": "getPets",
\&          "x\-mojo\-name": "get_pets",
\&          "x\-mojo\-to": "pet#list",
\&          "summary": "Finds pets in the system",
\&          "parameters": [
\&            {
\&              "in": "query",
\&              "name": "age",
\&              "schema": {
\&                "type": "integer"
\&              }
\&            }
\&          ],
\&          "requestBody": {
\&            "content": {
\&              "application/json": {
\&                "schema": {
\&                  "type": "object"
\&                }
\&              }
\&            }
\&          },
\&          "responses": {
\&            "200": {
\&              "description": "Pet response",
\&              "content": {
\&                "application/json": {
\&                  "schema": {
\&                    "type": "object",
\&                    "properties": {
\&                      "pets": {
\&                        "type": "array",
\&                        "items": {
\&                          "type": "object"
\&                        }
\&                      }
\&                    }
\&                  }
\&                }
\&              }
\&            }
\&          }
\&        }
\&      }
\&    },
\&    "servers": [
\&      {
\&        "url": "/api"
\&      }
\&    ]
\&  }
.Ve
.PP
The complete \s-1HTTP\s0 request for getting the \*(L"pet list\*(R" will be \f(CW\*(C`GET /api/pets\*(C'\fR
The first part of the path (\*(L"/api\*(R") comes from \f(CW\*(C`servers\*(C'\fR, the second part
comes from the keys under \f(CW\*(C`paths\*(C'\fR, and the \s-1HTTP\s0 method comes from the keys
under \f(CW\*(C`/pets\*(C'\fR.
.PP
The different parts of the specification can also be retrieved as \s-1JSON\s0 using
the \*(L"\s-1OPTIONS\*(R" HTTP\s0 method. Example:
.PP
.Vb 2
\&  OPTIONS /api/pets
\&  OPTIONS /api/pets?method=get
.Ve
.PP
Note that the use of \*(L"\s-1OPTIONS\*(R"\s0 is \s-1EXPERIMENTAL,\s0 and subject to change.
.PP
Here are some more details about the different keys:
.IP "\(bu" 2
openapi, info and paths
.Sp
These three sections are required to make the specification valid. Check out
<https://github.com/OAI/OpenAPI\-Specification/blob/master/versions/3.0.2.md>
for a complete reference to the specification.
.IP "\(bu" 2
parameters, requestBody and responses
.Sp
\&\f(CW\*(C`parameters\*(C'\fR, \f(CW\*(C`requestBody\*(C'\fR and \f(CW\*(C`responses\*(C'\fR will be used to define input and output
validation rules, which is used by \*(L"openapi.input\*(R" in Mojolicious::Plugin::OpenAPI
and when rendering the response back to the client, using \f(CW\*(C`render(openapi => ...)\*(C'\fR.
.Sp
Here OpenAPIv3 input differs from the v2 spec, where \f(CW\*(C`parameters\*(C'\fR is used for input in the
path or query of the request. The \f(CW\*(C`requestBody\*(C'\fR is used for input passed in the body.
.Sp
Have a look at \*(L"\s-1RENDERER\*(R"\s0 in Mojolicious::Plugin::OpenAPI for more details about
output rendering.
.IP "\(bu" 2
operationId and x\-mojo-name
.Sp
See \*(L"Route names\*(R".
.IP "\(bu" 2
x\-mojo-placeholder
.Sp
\&\f(CW\*(C`x\-mojo\-placeholder\*(C'\fR can be used inside a parameter definition to instruct
Mojolicious to parse a path part in a certain way. Example:
.Sp
.Vb 8
\&  "parameters": [
\&    {
\&      "x\-mojo\-placeholder": "#",
\&      "in": "path",
\&      "name": "email",
\&      "type": "string"
\&    }
\&  ]
.Ve
.Sp
See Mojolicious::Guides::Routing for more information about \*(L"standard\*(R",
\&\*(L"relaxed\*(R" and \*(L"wildcard\*(R" placeholders. The default is to use the \*(L"standard\*(R"
(\*(L"/:foo\*(R") placeholder.
.IP "\(bu" 2
x\-mojo-to
.Sp
The non-standard part in the spec above is \*(L"x\-mojo-to\*(R". The \*(L"x\-mojo-to\*(R" key
can be either a plain string, object (hash) or an array. The string and hash
will be passed directly to \*(L"to\*(R" in Mojolicious::Routes::Route, while the array
ref will be flattened. Examples:
.Sp
.Vb 2
\&  "x\-mojo\-to": "pet#list"
\&  $route\->to("pet#list");
\&
\&  "x\-mojo\-to": {"controller": "pet", "action": "list", "foo": 123}
\&  $route\->to({controller => "pet", action => "list", foo => 123);
\&
\&  "x\-mojo\-to": ["pet#list", {"foo": 123}]
\&  $route\->to("pet#list", {foo => 123});
.Ve
.IP "\(bu" 2
security and securitySchemes
.Sp
The securityScheme is added under components, where one way is to have the client
place an apiKey in the header of the request
.Sp
.Vb 12
\&  {
\&    ...
\&    "components": {
\&      "securitySchemes": {
\&        "apiKey": {
\&          "name": "X\-Api\-Key",
\&          "in": "header",
\&          "type": "apiKey"
\&        }
\&      }
\&    }
\&  }
.Ve
.Sp
It is then referenced under the path object as security like this
.Sp
.Vb 10
\&  {
\&    ...
\&    "paths": {
\&      "/pets": {
\&        "get": {
\&          "operationId": "getPets",
\&          ...
\&          "security": [
\&            {
\&              "apiKey": []
\&            }
\&          ]
\&        }
\&      }
\&    }
\&  }
.Ve
.Sp
You can then utilize security, by adding a security callback when loading
the plugin
.Sp
.Vb 10
\&  $self\->plugin(
\&    OpenAPI => {
\&      spec     => $self\->static\->file("openapi.json")\->path,
\&      schema   => \*(Aqv3\*(Aq,
\&      security => {
\&        apiKey => sub {
\&          my ($c, $definition, $scopes, $cb) = @_;
\&          if (my $key = $c\->tx\->req\->content\->headers\->header(\*(AqX\-Api\-Key\*(Aq)) {
\&            if (got_valid_api_key()) {
\&              return $c\->$cb();
\&            }
\&            else {
\&              return $c\->$cb(\*(AqApi Key not valid\*(Aq);
\&            }
\&          }
\&          else {
\&            return $c\->$cb(\*(AqApi Key header not present\*(Aq);
\&          }
\&        }
\&      }
\&    }
\&  );
.Ve
.PP
\fIReferences with files\fR
.IX Subsection "References with files"
.PP
Only a file reference like
.PP
.Vb 1
\&  "$ref": "my\-other\-cool\-component.json#/components/schemas/inputSchema"
.Ve
.PP
Is supported, though a valid path must be used for both the reference and in the
referenced file, in order to produce a valid spec output.
.PP
See \*(L"File references\*(R" in Known Issues for unsupported file references
.SS "Application"
.IX Subsection "Application"
.Vb 2
\&  package Myapp;
\&  use Mojo::Base "Mojolicious";
\&
\&  sub startup {
\&    my $app = shift;
\&    $app\->plugin("OpenAPI" => {url => $app\->home\->rel_file("myapi.json"), schema => \*(Aqv3\*(Aq});
\&  }
\&
\&  1;
.Ve
.PP
The first thing in your code that you need to do is to load this plugin and the
\&\*(L"Specification\*(R". See \*(L"register\*(R" in Mojolicious::Plugin::OpenAPI for information
about what the plugin config can be.
.PP
See also \*(L"\s-1SYNOPSIS\*(R"\s0 in Mojolicious::Plugin::OpenAPI for example
Mojolicious::Lite application.
.SS "Controller"
.IX Subsection "Controller"
.Vb 2
\&  package Myapp::Controller::Pet;
\&  use Mojo::Base "Mojolicious::Controller";
\&
\&  sub list {
\&
\&    # Do not continue on invalid input and render a default 400
\&    # error document.
\&    my $c = shift\->openapi\->valid_input or return;
\&
\&    # You might want to introspect the specification for the current route
\&    my $spec = $c\->openapi\->spec;
\&    unless ($spec\->{\*(Aqx\-opening\-hour\*(Aq} == (localtime)[2]) {
\&      return $c\->render(openapi => [], status => 498);
\&    }
\&
\&    my $age  = $c\->param("age");
\&    my $body = $c\->req\->json;
\&
\&    # $output will be validated by the OpenAPI spec before rendered
\&    my $output = {pets => [{name => "kit\-e\-cat"}]};
\&    $c\->render(openapi => $output);
\&  }
\&
\&  1;
.Ve
.PP
The input will be validated using
\&\*(L"openapi.valid_input\*(R" in Mojolicious::Plugin::OpenAPI while the output is
validated through then openapi
handler.
.SS "Route names"
.IX Subsection "Route names"
Routes will get its name from either \*(L"x\-mojo-name\*(R" or from \*(L"operationId\*(R" if
defined in the specification.
.PP
The route name can also be used the other way around, to find already defined
routes. This is especially useful for Mojolicious::Lite apps.
.PP
Note that if spec_route_name is 
used then all the route names will have that value as prefix:
.PP
.Vb 3
\&  spec_route_name            = "my_cool_api"
\&  operationId or x\-mojo\-name = "Foo"
\&  Route name                 = "my_cool_api.Foo"
.Ve
.PP
You can also set \*(L"x\-mojo-name\*(R" in the spec, instead of passing
spec_route_name
to \fBplugin()\fR:
.PP
.Vb 5
\&  {
\&    "openapi": "3.0.2",
\&    "info": { "version": "1.0", "title": "Some awesome API" },
\&    "x\-mojo\-name": "my_cool_api"
\&  }
.Ve
.SS "Default response schema"
.IX Subsection "Default response schema"
A default response definition will be added to the \s-1API\s0 spec, unless it's
already defined. This schema will at least be used for invalid input (400 \- Bad Request) and
invalid output (500 \- Internal Server Error), but can also be used in other cases.
.PP
See \*(L"default_response_codes\*(R" in Mojolicious::Plugin::OpenAPI and
\&\*(L"default_response_name\*(R" in Mojolicious::Plugin::OpenAPI for more details on how
to configure these settings.
.PP
The response schema will be added to your spec like this, unless already defined:
.PP
.Vb 10
\&  {
\&    ...
\&    "components": {
\&      ...
\&      "schemas": {
\&        ...
\&        "DefaultResponse": {
\&          "type":     "object",
\&          "required": ["errors"],
\&          "properties": {
\&            "errors": {
\&              "type":  "array",
\&              "items": {
\&                "type":       "object",
\&                "required":   ["message"],
\&                "properties": {"message": {"type": "string"}, "path": {"type": "string"}}
\&              }
\&            }
\&          }
\&        }
\&      }
\&    }
\&  }
.Ve
.PP
The \*(L"errors\*(R" key will contain one element for all the invalid data, and not
just the first one. The useful part for a client is mostly the \*(L"path\*(R", while
the \*(L"message\*(R" is just to add some human readable debug information for why this
request/response failed.
.SS "Rendering binary data"
.IX Subsection "Rendering binary data"
Rendering assets and binary data should be accomplished by using the standard
Mojolicious tools:
.PP
.Vb 3
\&  sub get_image {
\&    my $c = shift\->openapi\->valid_input or return;
\&    my $asset = Mojo::Asset::File\->new(path => "image.jpeg");
\&
\&    $c\->res\->headers\->content_type("image/jpeg");
\&    $c\->reply\->asset($asset);
\&  }
.Ve
.SH "OpenAPIv2 to OpenAPIv3 conversion"
.IX Header "OpenAPIv2 to OpenAPIv3 conversion"
Both online and offline tools are available. One example is of this is
<https://github.com/mermade/openapi\-webconverter>
.SH "Known issues"
.IX Header "Known issues"
.SS "File references"
.IX Subsection "File references"
Relative file references like the following
.PP
.Vb 2
\&  "$ref": "my\-cool\-component.json#"
\&  "$ref": "my\-cool\-component.json"
.Ve
.PP
Will also be placed under '#/definitions/...', again producing a spec output
which will not pass validation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious::Plugin::OpenAPI,
<https://openapis.org/specification>.
