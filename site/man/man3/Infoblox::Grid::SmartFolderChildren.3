.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Infoblox::Grid::SmartFolderChildren 3"
.TH Infoblox::Grid::SmartFolderChildren 3 "2018-06-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Infoblox::Grid::SmartFolderChildren \- Smart Folder retrieval item.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module helps read the objects that are associated with either a smart folder (global or personal) or a set of queries that users can make without saving a smart folder object on the appliance.
.PP
This interface can be used for both \*(L"filtering\*(R" and \*(L"grouping\*(R" the results of smart folder associated objects.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The object cannot be constructed. It can only be returned as part of a search.
.SH "SESSION METHODS"
.IX Header "SESSION METHODS"
This section describes all the methods in the Infoblox::Session module that you can apply to a personal smart folder object.
.SS "Infoblox::Session\->search( )"
.IX Subsection "Infoblox::Session->search( )"
.RS 4
Use this method to search for SmartFolderChildren objects in the Infoblox appliance. See Infoblox::Session\->\fBsearch()\fR for parameters and return values.
.IP "\fBKey References\fR" 4
.IX Item "Key References"
.Vb 1
\& Apply the following attributes to search for a specific SmartFolderChildren object:
\&
\&  query_items                  \- Required. A list of Infoblox::Grid::SmartFolder::QueryItem objects.
\&  smart_folder_name            \- Required. PersonalSmartFolder/GlobalSmartFolder name in string format.
\&  smart_folder_type            \- Optional. "Global" / "Personal", "Global" if not specified.
\&  smart_folder_group_bys       \- Optional. A list of Infoblox::Grid::SmartFolder::GroupBy objects.
\&  smart_folder_group_by_values \- Optional. A list of Infoblox::Grid::SmartFolder::GroupByValue objects.
\&
\& Both "smart_folder_name" and "query_items" are marked "Required" but they cannot be specified together. Note the following guidelines:
\&
\& \- "query_items" cannot be specified when "smart_folder_name" is specified because if "smart_folder_name" is specified, all the properties of a query can be derived from that smart folder.
\&
\& \- "query_items" can be specified with "smart_folder_group_bys". In this case, the results are grouped by specified group_bys attribute and a list of intermediate objects are returned.
\&
\& \- When only "smart_folder_name" is specified, it runs like a query using all properties from this folder and returning the results accordingly.
\&
\& \- When "smart_folder_group_bys" is specified with "smart_folder_name", the query is used from the specified smart folder; however, the results are shown from the level listed in "smart_folder_group_bys".
\&
\& \- "smart_folder_group_bys" by itself cannot be an argument since it does not provide sufficient input.
\&
\& \- "smart_folder_group_by_values" by itself cannot be an argument since it does not provide sufficient input.
\&
\& \- For the non\-saved smart folder query, the "smart_folder_group_by_values" can be used to specify the level of results to return. "smart_folder_group_bys" must also be specified in this case.
.Ve
.IP "\fBExample\fR" 4
.IX Item "Example"
.Vb 1
\&  Please see the \*(AqSAMPLE CODE\*(Aq section below.
.Ve
.RE
.RS 4
.RE
.SH "METHODS"
.IX Header "METHODS"
This section describes all the methods that you can use to retrieve the attribute values of a SmartFolderChildren object.
.SS "is_matching_object( )"
.IX Subsection "is_matching_object( )"
.RS 4
Use this method to retrieve the is_matching_object flag.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
The flag will be \*(L"true\*(R" if a matching object is returned inside the \fBvalue()\fR; if not, the attribute \fBvalue()\fR will contain the name of the intermediate object.
.RE
.RS 4
.RE
.SS "value( )"
.IX Subsection "value( )"
.RS 4
Use this method to retrieve the value of the object.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
This attribute will contain either an actual object matching the query (if is_matching_object is \*(L"true\*(R") or a string describing the name of the intermediate object.
.Sp
Intermediate objects are the extensible attribute value objects for which the grouping was requested. Matching objects are the \s-1DB\s0 objects that matched the query specified.
.RE
.RS 4
.RE
.SS "value_type( )"
.IX Subsection "value_type( )"
.RS 4
Use this method to retrieve the type of the returned value.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
If is_matching_object is \*(L"false\*(R", this will contain one of: \*(L"\s-1STRING\*(R" / \*(L"INTEGER\*(R" / \*(L"DATE\*(R" / \*(L"BOOLEAN\*(R".\s0
.RE
.RS 4
.RE
.SS "comment( )"
.IX Subsection "comment( )"
.RS 4
Use this method to retrieve the comment.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
This attribute will return the value of the \fBcomment()\fR attribute of the associated object, if \fBis_matching_object()\fR is \*(L"true\*(R". It will return undef if is_matching_object is \*(L"false\*(R".
.RE
.RS 4
.RE
.SS "extattrs( )"
.IX Subsection "extattrs( )"
.RS 4
Use this method to retrieve the extensible attributes. This attribute is read-only and cannot be set.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
This attribute will return the value of the \fBextattrs()\fR attribute of the associated object (if \fBis_matching_object()\fR is \*(L"true\*(R"). It will return undef if is_matching_object is \*(L"true\*(R"). It will return undef if is_matching_object is \*(L"false\*(R".
.RE
.RS 4
.RE
.SS "extensible_attributes( )"
.IX Subsection "extensible_attributes( )"
.RS 4
Use this method to retrieve the extensible attributes.
.IP "\fBParameter\fR" 4
.IX Item "Parameter"
This attribute will return the value of the \fBextensible_attributes()\fR attribute of the associated object (if \fBis_matching_object()\fR is \*(L"true\*(R"). It will return undef if is_matching_object is \*(L"false\*(R".
.RE
.RS 4
.RE
.SH "SAMPLE CODE"
.IX Header "SAMPLE CODE"
.Vb 1
\& USE\-CASES & EXAMPLES:
\&
\& ##########################################################################
\& # Case 1 : Fetching objects based on the query defined for an existing folder
\& ##########################################################################
\&
\& my @retrieved_objs = $session\->search(
\&             object =>"Infoblox::Grid::SmartFolderChildren" ,
\&             smart_folder_name => "global_smart_folder_1"
\&          );
\&
\& my $object = $retrieved_objs[0];
\&
\& if ($object\->is_matching_object())
\& {
\&    print $object\->comment();
\&    # $object\->extensible_attributes() will contain the object\*(Aqs
\&    # extensible attributes
\&    #
\&    # This will be the actual matching object
\&    # $object\->value();
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    # This will be "USA", "Canada" etc
\&    # if the grouping was on "Country" for example
\&    print $object\->value();
\&    print $object\->value_type();
\& }
\&
\& ##########################################################################
\& # Case 2 : Fetching objects based on the smart folder and a given group_by_values
\& ##########################################################################
\&
\& my $groupbyvalue1 = Infoblox::Grid::SmartFolder::GroupByValue\->new(
\&          name => "Country",
\&          value => "USA",
\& );
\& my $groupbyvalue2 = Infoblox::Grid::SmartFolder::GroupByValue\->new(
\&          name => "State",
\&          value => "CA",
\& );
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       smart_folder_name => "global_smart_folder_1",
\&       smart_folder_group_by_values => [$groupbyvalue1, $groupbyvalue2],
\&          );
\&
\& my $object = $retrieved_objs[0];
\& if ($object\->is_matching_object())
\& {
\&    print $object\->comment();
\&    # $object\->extensible_attributes() will contain the object\*(Aqs
\&    # extensible attributes
\&    #
\&    # This will be the actual matching object
\&    # $object\->value();
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    print $object\->value();
\&    print $object\->value_type();
\& }
\&
\& ##########################################################################
\& # Case 3 : Fetching objects based on the not\-saved smart folder query, no grouping
\& ##########################################################################
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       #This query will only return intermediate objects
\&       query_items => [queryitem1, queryitem2],
\&          );
\&
\& my $object = $retrieved_objs[0];
\& if ($object\->is_matching_object())
\& {
\&    print $object\->comment();
\&    # $object\->extensible_attributes() will contain the object\*(Aqs
\&    # extensible attributes
\&    #
\&    # This will be the actual matching object
\&    # $object\->value();
\&
\& }
\& else
\& {
\&    # This shall never happen
\& }
\&
\& ##########################################################################
\& # Case 4 : Fetching objects based on the not\-saved smart folder query & with top level grouping
\& ##########################################################################
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       query_items => [queryitem1, queryitem2],
\&       smart_folder_group_bys => [$groupby1, $groupby2],
\&          );
\&
\& my $object = $retrieved_objs[0];
\& if ($object\->is_matching_object())
\& {
\&    # This shall never happen
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    print $object\->value();
\&    print $object\->value_type();
\& }
\&
\& ##########################################################################
\& # Case 5 : Fetching objects based on the not\-saved smart folder query & with second level grouping
\& ##########################################################################
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       query_items => [$queryitem1, $queryitem2],
\&       smart_folder_group_bys => [$groupby1, $groupby2],
\&       smart_folder_group_by_values => [$groupbyvalue1],
\&          );
\&
\& my $object = $retrieved_objs[0];
\& if ($object\->is_matching_object())
\& {
\&    # This shall never happen
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    # The intermediate objects grouped by $groupby2 are returned in this case
\&    print $object\->value();
\&    print $object\->value_type();
\& }
\&
\& ##########################################################################
\& # Case 6 : Fetching objects based on the defined SF query & grouping by a given rule "value"
\& ##########################################################################
\&
\& my $groupbyvalue1 = Infoblox::Grid::SmartFolder::GroupByValue\->new(
\&          name => "Country",
\&          value => "USA",
\& );
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       smart_folder_name => "global_smart_folder_1"
\&       smart_folder_group_by_values => [$groupbyvalue1],
\&    );
\&
\& my $object = $retrieved_objs[0];
\&
\& if ($object\->is_matching_object())
\& {
\&    print $object\->comment();
\&    # $object\->extensible_attributes() will contain the object\*(Aqs
\&    # extensible attributes
\&    #
\&    # This will be the actual matching object
\&    # $object\->value();
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    print $object\->value();
\&    print $object\->value_type();
\& }
\&
\& ##########################################################################
\& # Case 7 : Fetching next levels of data from result of previous one (NESTED example)
\& ##########################################################################
\&
\& # EXAMPLE: Get objects for Country USA\-> State CA\-> DB Objects.
\&
\& #Add Personal Smart Folder with 2 levels of grouping
\& #Use this smart folder to fetch intermediate objects from first level (groups)
\& #Use the result of this first level and fetch second level of intermediate objects (groups)
\& #Use the result of this second level and fetch the final / third level of DB protocol objects
\&
\& my $groupby1 = Infoblox::Grid::SmartFolder::GroupBy\->new(
\&             enable_grouping => True,
\&             value => "Country",
\&             value_type => "EXTATTR",
\& );
\& my $groupby2 = Infoblox::Grid::SmartFolder::GroupBy\->new(
\&             enable_grouping => True,
\&             value => "State",
\&             value_type => "EXTATTR",
\& );
\&
\& my  $smartfolder = Infoblox::Grid::PersonalSmartFolder\->new(
\&              name => "personal_smart_folder_1",
\&              comment => "personal smart folder 1 comment",
\&              enable_grouping => True,
\&              group_bys => [$groupby1, $groupby2],
\&              query_items => [],
\&               );
\& my $response = $session\->add($smartfolder)
\&
\& my  @retrieved_objs = $session\->search(
\&       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&       smart_folder_name => "personal_smart_folder_1",
\&       smart_folder_type => "Personal",
\&    );
\&
\& my $object = $retrieved_objs[0];
\&
\& if ($object\->is_matching_object())
\& {
\&         # This will not happen since intermediate objects are returned in this case
\& }
\& else
\& {
\&    # Name of the intermediate group, use this to fetch another level if needed
\&    my $intermediate_group_value = $object\->value();
\&         if ($intermediate_group_value eq "USA")
\&         {
\&             my $groupbyvalue_usa = Infoblox::Grid::SmartFolder::GroupByValue\->new(
\&                 name => "Country",
\&                 value => "USA",
\&             );
\&             my  @retrieved_objs = $session\->search(
\&                 object =>"Infoblox::Grid::SmartFolderChildren" ,
\&                 smart_folder_name => "personal_smart_folder_1"
\&                 smart_folder_group_by_values => [$groupbyvalue_usa],
\&             );
\&
\&             my $object = $retrieved_objs[0];
\&
\&             my $intermediate2_group_value = $object\->value();
\&             if ($intermediate2_group_value eq "CA")
\&             {
\&                   my $groupbyvalue_ca = Infoblox::Grid::SmartFolder::GroupByValue\->new(
\&                       name => "State",
\&                       value => "CA",
\&                   );
\&                   my  @retrieved_objs = $session\->search(
\&                       object =>"Infoblox::Grid::SmartFolderChildren" ,
\&                       smart_folder_name => "personal_smart_folder_1"
\&                       smart_folder_type => "Personal",
\&                       smart_folder_group_by_values => [$groupbyvalue_ca],
\&                   );
\&
\&                   my $object = $retrieved_objs[0];
\&
\&                    if ($object\->comment() eq "I am a network object")
\&                    {
\&                        # $object here represents the Database object
\&                    }
\&             }
\& }
\&
\& ####PROGRAM ENDS####
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Infoblox Inc. <http://www.infoblox.com/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Infoblox::Grid::PersonalSmartFolder, Infoblox::Session\->\fBadd()\fR, Infoblox::Session\->\fBfetch_smart_folder_objects()\fR, Infoblox::Session\->\fBget()\fR, Infoblox::Session\->\fBmodify()\fR, Infoblox::Session\->\fBremove()\fR, Infoblox::Session\->\fBsearch()\fR,Infoblox::Session
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2017 Infoblox Inc.
