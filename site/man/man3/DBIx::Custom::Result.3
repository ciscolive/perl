.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Custom::Result 3"
.TH DBIx::Custom::Result 3 "2020-04-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Custom::Result \- Result of select statement
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Result
\&  my $result = $dbi\->select(table => \*(Aqbook\*(Aq);
\&
\&  # Fetch a row and put it into array reference
\&  while (my $row = $result\->fetch) {
\&    my $author = $row\->[0];
\&    my $title  = $row\->[1];
\&  }
\&  
\&  # Fetch only a first row and put it into array reference
\&  my $row = $result\->fetch_one;
\&  
\&  # Fetch all rows and put them into array of array reference
\&  my $rows = $result\->fetch_all;
\&
\&  # Fetch a row and put it into hash reference
\&  while (my $row = $result\->fetch_hash) {
\&    my $title  = $row\->{title};
\&    my $author = $row\->{author};
\&  }
\&  
\&  # Fetch only a first row and put it into hash reference
\&  my $row = $result\->fetch_hash_one;
\&  my $row = $result\->one; # Alias for "fetch_hash_one"
\&  
\&  # Fetch all rows and put them into array of hash reference
\&  my $rows = $result\->fetch_hash_all;
\&  my $rows = $result\->all; # Alias for "fetch_hash_all"
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "dbi"
.IX Subsection "dbi"
.Vb 2
\&  my $dbi = $result\->dbi;
\&  $result = $result\->dbi($dbi);
.Ve
.PP
DBIx::Custom object.
.SS "sth"
.IX Subsection "sth"
.Vb 2
\&  my $sth = $reuslt\->sth
\&  $result = $result\->sth($sth);
.Ve
.PP
Statement handle of \s-1DBI\s0.
.SH "METHODS"
.IX Header "METHODS"
DBIx::Custom::Result inherits all methods from Object::Simple
and implements the following new ones.
.SS "all"
.IX Subsection "all"
.Vb 1
\&  my $rows = $result\->all;
.Ve
.PP
Same as fetch_hash_all.
.SS "fetch"
.IX Subsection "fetch"
.Vb 1
\&  my $row = $result\->fetch;
.Ve
.PP
Fetch a row and put it into array reference.
.SS "fetch_all"
.IX Subsection "fetch_all"
.Vb 1
\&  my $rows = $result\->fetch_all;
.Ve
.PP
Fetch all rows and put them into array of array reference.
.SS "fetch_one"
.IX Subsection "fetch_one"
.Vb 1
\&  my $row = $result\->fetch_one;
.Ve
.PP
Fetch only a first row and put it into array reference,
and finish statement handle.
.SS "fetch_hash"
.IX Subsection "fetch_hash"
.Vb 1
\&  my $row = $result\->fetch_hash;
.Ve
.PP
Fetch a row and put it into hash reference.
.SS "fetch_hash_all"
.IX Subsection "fetch_hash_all"
.Vb 1
\&  my $rows = $result\->fetch_hash_all;
.Ve
.PP
Fetch all rows and put them into array of hash reference.
.SS "fetch_hash_one"
.IX Subsection "fetch_hash_one"
.Vb 1
\&  my $row = $result\->fetch_hash_one;
.Ve
.PP
Fetch only a first row and put it into hash reference,
and finish statement handle.
.SS "fetch_hash_multi"
.IX Subsection "fetch_hash_multi"
.Vb 1
\&  my $rows = $result\->fetch_hash_multi(5);
.Ve
.PP
Fetch multiple rows and put them into array of hash reference.
.SS "fetch_multi"
.IX Subsection "fetch_multi"
.Vb 1
\&  my $rows = $result\->fetch_multi(5);
.Ve
.PP
Fetch multiple rows and put them into array of array reference.
.SS "filter"
.IX Subsection "filter"
.Vb 2
\&  $result\->filter(title  => sub { uc $_[0] }, author => \*(Aqto_upper\*(Aq);
\&  $result\->filter([qw/title author/] => \*(Aqto_upper\*(Aq);
.Ve
.PP
Set filter for column.
You can use subroutine or filter name as filter.
This filter is executed after \f(CW\*(C`type_rule\*(C'\fR filter.
.SS "flat"
.IX Subsection "flat"
.Vb 1
\&  my @list = $result\->flat;
.Ve
.PP
All values is added to flatten list.
.PP
.Vb 1
\&  my @list = $dbi\->select([\*(Aqid\*(Aq, \*(Aqtitle\*(Aq])\->flat;
.Ve
.PP
\&\f(CW\*(C`flat\*(C'\fR method return the following data.
.PP
.Vb 1
\&  (1, \*(AqPerl\*(Aq, 2, \*(AqRuby\*(Aq)
.Ve
.PP
You can create key-value pair easily.
.PP
.Vb 1
\&  my %titles = $dbi\->select([\*(Aqid\*(Aq, \*(Aqtitle\*(Aq])\->flat;
.Ve
.SS "kv"
.IX Subsection "kv"
.Vb 1
\&  my $key_value = $result\->kv;
.Ve
.PP
Get key-value pairs.
.PP
.Vb 1
\&  my $books = $dbi\->select([\*(Aqid\*(Aq, \*(Aqtitle\*(Aq, \*(Aqauthor\*(Aq])\->kv;
.Ve
.PP
If \f(CW\*(C`all\*(C'\fR method return the following data:
.PP
.Vb 4
\&  [
\&    {id => 1, title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq},
\&    {id => 2, title => \*(AqRuby\*(Aq, author => \*(AqTaro\*(Aq}
\&  ]
.Ve
.PP
\&\f(CW\*(C`kv\*(C'\fR method return the following data.
.PP
.Vb 4
\&  {
\&    1 => {title => \*(AqPerl\*(Aq, author => \*(AqKen\*(Aq},
\&    2 => {title => \*(AqRuby\*(Aq, author => \*(AqTaro\*(Aq}
\&  }
.Ve
.PP
First column value become key.
.SS "kvs"
.IX Subsection "kvs"
.Vb 1
\&  my $key_values = $result\->kvs;
.Ve
.PP
Get key-values pairs.
.PP
.Vb 1
\&  my $books = $dbi\->select([\*(Aqauthor\*(Aq, \*(Aqtitle\*(Aq, \*(Aqprice\*(Aq])\->kvs;
.Ve
.PP
If \f(CW\*(C`all\*(C'\fR method return the following data:
.PP
.Vb 6
\&  [
\&    {author => \*(AqKen\*(Aq, title => \*(AqPerl\*(Aq, price => 1000},
\&    {author => \*(AqKen\*(Aq, title => \*(AqGood\*(Aq, price => 2000},
\&    {author => \*(AqTaro\*(Aq, title => \*(AqRuby\*(Aq, price => 3000}
\&    {author => \*(AqTaro\*(Aq, title => \*(AqSky\*(Aq, price => 4000}
\&  ]
.Ve
.PP
\&\f(CW\*(C`kvs\*(C'\fR method return the following data.
.PP
.Vb 10
\&  {
\&    Ken => [
\&      {title => \*(AqPerl\*(Aq, price => 1000},
\&      {title => \*(AqGood\*(Aq, price => 2000}
\&    ],
\&    Taro => [
\&      {title => \*(AqRuby\*(Aq, price => 3000},
\&      {title => \*(AqSky\*(Aq, price => 4000}
\&    ]
\&  }
.Ve
.SS "header"
.IX Subsection "header"
.Vb 1
\&  my $header = $result\->header;
.Ve
.PP
Get header column names.
.SS "one"
.IX Subsection "one"
.Vb 1
\&  my $row = $result\->one;
.Ve
.PP
Alias for \f(CW\*(C`fetch_hash_one\*(C'\fR.
.SS "stash"
.IX Subsection "stash"
.Vb 3
\&  my $stash = $result\->stash;
\&  my $foo = $result\->stash\->{foo};
\&  $result\->stash\->{foo} = $foo;
.Ve
.PP
Stash is hash reference to save some data.
.SS "type_rule"
.IX Subsection "type_rule"
.Vb 7
\&  # Merge type rule
\&  $result\->type_rule(
\&    # DATE
\&    9 => sub { ... },
\&    # DATETIME or TIMESTAMP
\&    11 => sub { ... }
\&  );
\&
\&  # Replace type rule(by reference)
\&  $result\->type_rule([
\&    # DATE
\&    9 => sub { ... },
\&    # DATETIME or TIMESTAMP
\&    11 => sub { ... }
\&  ]);
.Ve
.PP
This is same as DBIx::Custom's \f(CW\*(C`type_rule\*(C'\fR's <from>.
.SS "type_rule_off"
.IX Subsection "type_rule_off"
.Vb 1
\&  $result = $result\->type_rule_off;
.Ve
.PP
Turn \f(CW\*(C`from1\*(C'\fR and \f(CW\*(C`from2\*(C'\fR type rule off.
By default, type rule is on.
.SS "type_rule_on"
.IX Subsection "type_rule_on"
.Vb 1
\&  $result = $result\->type_rule_on;
.Ve
.PP
Turn \f(CW\*(C`from1\*(C'\fR and \f(CW\*(C`from2\*(C'\fR type rule on.
By default, type rule is on.
.SS "type_rule1_off"
.IX Subsection "type_rule1_off"
.Vb 1
\&  $result = $result\->type_rule1_off;
.Ve
.PP
Turn \f(CW\*(C`from1\*(C'\fR type rule off.
By default, type rule is on.
.SS "type_rule1_on"
.IX Subsection "type_rule1_on"
.Vb 1
\&  $result = $result\->type_rule1_on;
.Ve
.PP
Turn \f(CW\*(C`from1\*(C'\fR type rule on.
By default, type rule is on.
.SS "type_rule2_off"
.IX Subsection "type_rule2_off"
.Vb 1
\&  $result = $result\->type_rule2_off;
.Ve
.PP
Turn \f(CW\*(C`from2\*(C'\fR type rule off.
By default, type rule is on.
.SS "type_rule2_on"
.IX Subsection "type_rule2_on"
.Vb 1
\&  $result = $result\->type_rule2_on;
.Ve
.PP
Turn \f(CW\*(C`from2\*(C'\fR type rule on.
By default, type rule is on.
.SS "value"
.IX Subsection "value"
.Vb 1
\&  my $value = $result\->value;
.Ve
.PP
Get first column's first value.
.PP
.Vb 1
\&  my $count = $dbi\->select(\*(Aqcount(*)\*(Aq, table => \*(Aqbook\*(Aq)\->value;
.Ve
.PP
This is almost same as the following one.
.PP
.Vb 1
\&  my $count = $dbi\->select(\*(Aqcount(*)\*(Aq)\->fetch_one\->[0];
.Ve
.SS "values"
.IX Subsection "values"
.Vb 1
\&  my $values = $result\->values;
.Ve
.PP
Get first column's values.
.PP
.Vb 1
\&  my $tables = $dbi\->select(\*(Aqshow tables\*(Aq)\->values;
.Ve
.PP
This is same as the following one.
.PP
.Vb 2
\&  my $rows = $dbi\->select(\*(Aqshow tables\*(Aq)\->fetch_all;
\&  my $tables = [map { $_\->[0] } @$rows];
.Ve
