.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Rex::Commands::Gather 3"
.TH Rex::Commands::Gather 3 "2020-10-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rex::Commands::Gather \- Hardware and Information gathering
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
With this module you can gather hardware and software information.
.PP
All these functions will not be reported. These functions don't modify anything.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& operating_system_is("SuSE");
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "get_operating_system"
.IX Subsection "get_operating_system"
Will return the current operating system name.
.PP
.Vb 3
\& task "get\-os", "server01", sub {
\&   say get_operating_system();
\& };
.Ve
.PP
Aliased by \fBoperating_system()\fR.
.SS "operating_system"
.IX Subsection "operating_system"
Alias for \fBget_operating_system()\fR
.SS "get_system_information"
.IX Subsection "get_system_information"
Will return a hash of all system information. These Information will be also used by the template function.
.SS "kernelname"
.IX Subsection "kernelname"
Will return the kernel name of the operating system. For example on a linux system it will return \fILinux\fR.
.SS "dump_system_information"
.IX Subsection "dump_system_information"
This function dumps all known system information on stdout.
.SS "operating_system_is($string)"
.IX Subsection "operating_system_is($string)"
Will return 1 if the operating system is \f(CW$string\fR.
.PP
.Vb 5
\& task "is_it_suse", "server01", sub {
\&   if( operating_system_is("SuSE") ) {
\&     say "This is a SuSE system.";
\&   }
\& };
.Ve
.SS "\fBoperating_system_version()\fP"
.IX Subsection "operating_system_version()"
Will return the os release number as an integer. For example, it will convert 5.10 to 510, 10.04 to 1004 or 6.0.3 to 603.
.PP
.Vb 5
\& task "prepare", "server01", sub {
\&   if( operating_system_version() >= 510 ) {
\&     say "OS Release is higher or equal to 510";
\&   }
\& };
.Ve
.SS "\fBoperating_system_release()\fP"
.IX Subsection "operating_system_release()"
Will return the os release number as is.
.SS "network_interfaces"
.IX Subsection "network_interfaces"
Return an HashRef of all the networkinterfaces and their configuration.
.PP
.Vb 3
\& task "get_network_information", "server01", sub {
\&   my $net_info = network_interfaces();
\& };
.Ve
.PP
You can iterate over the devices as follow
.PP
.Vb 4
\& my $net_info = network_interfaces();
\& for my $dev ( keys %{ $net_info } ) {
\&   say "$dev has the ip: " . $net_info\->{$dev}\->{"ip"} . " and the netmask: " . $net_info\->{$dev}\->{"netmask"};
\& }
.Ve
.SS "memory"
.IX Subsection "memory"
Return an HashRef of all memory information.
.PP
.Vb 2
\& task "get_memory_information", "server01", sub {
\&   my $memory = memory();
\&
\&   say "Total:  " . $memory\->{"total"};
\&   say "Free:   " . $memory\->{"free"};
\&   say "Used:   " . $memory\->{"used"};
\&   say "Cached:  " . $memory\->{"cached"};
\&   say "Buffers: " . $memory\->{"buffers"};
\& };
.Ve
.SS "is_freebsd"
.IX Subsection "is_freebsd"
Returns true if the target system is a FreeBSD.
.PP
.Vb 8
\& task "foo", "server1", "server2", sub {
\&   if(is_freebsd) {
\&     say "This is a freebsd system...";
\&   }
\&   else {
\&     say "This is not a freebsd system...";
\&   }
\& };
.Ve
.SS "is_redhat"
.IX Subsection "is_redhat"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_redhat) {
\&     # do something on a redhat system (like RHEL, Fedora, CentOS, Scientific Linux
\&   }
\& };
.Ve
.SS "is_fedora"
.IX Subsection "is_fedora"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_fedora) {
\&     # do something on a fedora system
\&   }
\& };
.Ve
.SS "is_suse"
.IX Subsection "is_suse"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_suse) {
\&     # do something on a suse system
\&   }
\& };
.Ve
.SS "is_mageia"
.IX Subsection "is_mageia"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_mageia) {
\&     # do something on a mageia system (or other Mandriva followers)
\&   }
\& };
.Ve
.SS "is_debian"
.IX Subsection "is_debian"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_debian) {
\&     # do something on a debian system
\&   }
\& };
.Ve
.SS "is_alt"
.IX Subsection "is_alt"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_alt) {
\&     # do something on a ALT Linux system
\&   }
\& };
.Ve
.SS "is_netbsd"
.IX Subsection "is_netbsd"
Returns true if the target system is a NetBSD.
.PP
.Vb 8
\& task "foo", "server1", "server2", sub {
\&   if(is_netbsd) {
\&     say "This is a netbsd system...";
\&   }
\&   else {
\&     say "This is not a netbsd system...";
\&   }
\& };
.Ve
.SS "is_openbsd"
.IX Subsection "is_openbsd"
Returns true if the target system is an OpenBSD.
.PP
.Vb 8
\& task "foo", "server1", "server2", sub {
\&   if(is_openbsd) {
\&     say "This is an openbsd system...";
\&   }
\&   else {
\&     say "This is not an openbsd system...";
\&   }
\& };
.Ve
.SS "is_linux"
.IX Subsection "is_linux"
Returns true if the target system is a Linux System.
.PP
.Vb 8
\& task "prepare", "server1", "server2", sub {
\&   if(is_linux) {
\&    say "This is a linux system...";
\&   }
\&   else {
\&    say "This is not a linux system...";
\&   }
\& };
.Ve
.SS "is_bsd"
.IX Subsection "is_bsd"
Returns true if the target system is a \s-1BSD\s0 System.
.PP
.Vb 8
\& task "prepare", "server1", "server2", sub {
\&   if(is_bsd) {
\&    say "This is a BSD system...";
\&   }
\&   else {
\&    say "This is not a BSD system...";
\&   }
\& };
.Ve
.SS "is_solaris"
.IX Subsection "is_solaris"
Returns true if the target system is a Solaris System.
.PP
.Vb 8
\& task "prepare", "server1", "server2", sub {
\&   if(is_solaris) {
\&    say "This is a Solaris system...";
\&   }
\&   else {
\&    say "This is not a Solaris system...";
\&   }
\& };
.Ve
.SS "is_windows"
.IX Subsection "is_windows"
Returns true if the target system is a Windows System.
.SS "is_openwrt"
.IX Subsection "is_openwrt"
Returns true if the target system is an OpenWrt System.
.SS "is_gentoo"
.IX Subsection "is_gentoo"
Returns true if the target system is a Gentoo System.
.SS "is_arch"
.IX Subsection "is_arch"
.Vb 5
\& task "foo", "server1", sub {
\&   if(is_arch) {
\&     # do something on a arch system
\&   }
\& };
.Ve
.SS "is_void"
.IX Subsection "is_void"
Returns true if the target system is a Void Linux system.
