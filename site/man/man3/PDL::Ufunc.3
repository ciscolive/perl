.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Ufunc 3"
.TH Ufunc 3 "2020-09-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Ufunc \- primitive ufunc operations for pdl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides some primitive and useful functions defined
using \s-1PDL::PP\s0 based on functionality of what are sometimes called
\&\fIufuncs\fR (for example NumPY and Mathematica talk about these).
It collects all the functions generally used to \f(CW\*(C`reduce\*(C'\fR or
\&\f(CW\*(C`accumulate\*(C'\fR along a dimension. These all do their job across the
first dimension but by using the slicing functions you can do it
on any dimension.
.PP
The PDL::Reduce module provides an alternative interface
to many of the functions in this module.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Ufunc;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "prodover"
.IX Subsection "prodover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via product to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the product along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = prodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = prodover $image\->xchg(0,1)
.Ve
.PP
prodover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "dprodover"
.IX Subsection "dprodover"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via product to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the product along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = dprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dprodover $image\->xchg(0,1)
.Ve
.PP
Unlike prodover, the calculations are performed in double
precision.
.PP
dprodover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "cumuprodover"
.IX Subsection "cumuprodover"
.Vb 1
\&  Signature: (a(n); int+ [o]b(n))
.Ve
.PP
Cumulative product
.PP
This function calculates the cumulative product
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative product
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumuprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumuprodover $image\->xchg(0,1)
.Ve
.PP
cumuprodover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "dcumuprodover"
.IX Subsection "dcumuprodover"
.Vb 1
\&  Signature: (a(n); double [o]b(n))
.Ve
.PP
Cumulative product
.PP
This function calculates the cumulative product
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative product
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumuprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumuprodover $image\->xchg(0,1)
.Ve
.PP
Unlike cumuprodover, the calculations are performed in double
precision.
.PP
dcumuprodover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "sumover"
.IX Subsection "sumover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via sum to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the sum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = sumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = sumover $image\->xchg(0,1)
.Ve
.PP
sumover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "dsumover"
.IX Subsection "dsumover"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via sum to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the sum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = dsumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dsumover $image\->xchg(0,1)
.Ve
.PP
Unlike sumover, the calculations are performed in double
precision.
.PP
dsumover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "cumusumover"
.IX Subsection "cumusumover"
.Vb 1
\&  Signature: (a(n); int+ [o]b(n))
.Ve
.PP
Cumulative sum
.PP
This function calculates the cumulative sum
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative sum
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumusumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumusumover $image\->xchg(0,1)
.Ve
.PP
cumusumover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "dcumusumover"
.IX Subsection "dcumusumover"
.Vb 1
\&  Signature: (a(n); double [o]b(n))
.Ve
.PP
Cumulative sum
.PP
This function calculates the cumulative sum
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative sum
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumusumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumusumover $image\->xchg(0,1)
.Ve
.PP
Unlike cumusumover, the calculations are performed in double
precision.
.PP
dcumusumover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "andover"
.IX Subsection "andover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via and to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the and along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = andover($x);
.Ve
.PP
.Vb 1
\& $spectrum = andover $image\->xchg(0,1)
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "bandover"
.IX Subsection "bandover"
.Vb 1
\&  Signature: (a(n);  [o]b())
.Ve
.PP
Project via bitwise and to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the bitwise and along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = bandover($x);
.Ve
.PP
.Vb 1
\& $spectrum = bandover $image\->xchg(0,1)
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "borover"
.IX Subsection "borover"
.Vb 1
\&  Signature: (a(n);  [o]b())
.Ve
.PP
Project via bitwise or to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the bitwise or along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = borover($x);
.Ve
.PP
.Vb 1
\& $spectrum = borover $image\->xchg(0,1)
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "orover"
.IX Subsection "orover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via or to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the or along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = orover($x);
.Ve
.PP
.Vb 1
\& $spectrum = orover $image\->xchg(0,1)
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "zcover"
.IX Subsection "zcover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via == 0 to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the == 0 along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = zcover($x);
.Ve
.PP
.Vb 1
\& $spectrum = zcover $image\->xchg(0,1)
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "intover"
.IX Subsection "intover"
.Vb 1
\&  Signature: (a(n); float+ [o]b())
.Ve
.PP
Project via integral to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the integral along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = intover($x);
.Ve
.PP
.Vb 1
\& $spectrum = intover $image\->xchg(0,1)
.Ve
.PP
Notes:
.PP
\&\f(CW\*(C`intover\*(C'\fR uses a point spacing of one (i.e., delta\-h==1).  You will
need to scale the result to correct for the true point delta).
.PP
For \f(CW\*(C`n > 3\*(C'\fR, these are all \f(CW\*(C`O(h^4)\*(C'\fR (like Simpson's rule), but are
integrals between the end points assuming the pdl gives values just at
these centres: for such `functions', sumover is correct to \f(CWO(h)\fR, but
is the natural (and correct) choice for binned data, of course.
.PP
intover ignores the bad-value flag of the input piddles.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "average"
.IX Subsection "average"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via average to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the average along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = average($x);
.Ve
.PP
.Vb 1
\& $spectrum = average $image\->xchg(0,1)
.Ve
.PP
average processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "avgover"
.IX Subsection "avgover"
.Vb 1
\&  Synonym for average.
.Ve
.SS "daverage"
.IX Subsection "daverage"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via average to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the average along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = daverage($x);
.Ve
.PP
.Vb 1
\& $spectrum = daverage $image\->xchg(0,1)
.Ve
.PP
Unlike average, the calculation is performed in double
precision.
.PP
daverage processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "davgover"
.IX Subsection "davgover"
.Vb 1
\&  Synonym for daverage.
.Ve
.SS "medover"
.IX Subsection "medover"
.Vb 1
\&  Signature: (a(n); [o]b(); [t]tmp(n))
.Ve
.PP
Project via median to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the median along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = medover($x);
.Ve
.PP
.Vb 1
\& $spectrum = medover $image\->xchg(0,1)
.Ve
.PP
medover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "oddmedover"
.IX Subsection "oddmedover"
.Vb 1
\&  Signature: (a(n); [o]b(); [t]tmp(n))
.Ve
.PP
Project via oddmedian to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the oddmedian along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = oddmedover($x);
.Ve
.PP
.Vb 1
\& $spectrum = oddmedover $image\->xchg(0,1)
.Ve
.PP
The median is sometimes not a good choice as if the array has
an even number of elements it lies half-way between the two
middle values \- thus it does not always correspond to a data
value. The lower-odd median is just the lower of these two values
and so it \s-1ALWAYS\s0 sits on an actual data value which is useful in
some circumstances.
.PP
oddmedover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "modeover"
.IX Subsection "modeover"
.Vb 1
\&  Signature: (data(n); [o]out(); [t]sorted(n))
.Ve
.PP
Project via mode to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the mode along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = modeover($x);
.Ve
.PP
.Vb 1
\& $spectrum = modeover $image\->xchg(0,1)
.Ve
.PP
The mode is the single element most frequently found in a 
discrete data set.
.PP
It \fIonly\fR makes sense for integer data types, since
floating-point types are demoted to integer before the
mode is calculated.
.PP
\&\f(CW\*(C`modeover\*(C'\fR treats \s-1BAD\s0 the same as any other value:  if
\&\s-1BAD\s0 is the most common element, the returned value is also \s-1BAD.\s0
.PP
modeover does not process bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pctover"
.IX Subsection "pctover"
.Vb 1
\&  Signature: (a(n); p(); [o]b(); [t]tmp(n))
.Ve
.PP
Project via percentile to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle by one by finding
the specified percentile (p) along the 1st dimension.  The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between data points, the result is interpolated.  Values outside
the allowed range are clipped to 0.0 or 1.0 respectively.  The algorithm
implemented here is based on the interpolation variant described at
<http://en.wikipedia.org/wiki/Percentile> as used by Microsoft Excel
and recommended by \s-1NIST.\s0
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = pctover($x, $p);
.Ve
.PP
.Vb 1
\& $spectrum = pctover $image\->xchg(0,1), $p
.Ve
.PP
pctover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "oddpctover"
.IX Subsection "oddpctover"
.Vb 1
\&  Signature: (a(n); p(); [o]b(); [t]tmp(n))
.Ve
.PP
Project via percentile to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle by one by finding
the specified percentile along the 1st dimension.  The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between two values, the nearest data value is the result.
The algorithm implemented is from the textbook version described
first at <http://en.wikipedia.org/wiki/Percentile>.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = oddpctover($x, $p);
.Ve
.PP
.Vb 1
\& $spectrum = oddpctover $image\->xchg(0,1), $p
.Ve
.PP
oddpctover processes bad values.
It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.
.SS "pct"
.IX Subsection "pct"
Return the specified percentile of all elements in a piddle. The
specified percentile (p) must be between 0.0 and 1.0.  When the
specified percentile falls between data points, the result is
interpolated.
.PP
.Vb 1
\& $x = pct($data, $pct);
.Ve
.SS "oddpct"
.IX Subsection "oddpct"
Return the specified percentile of all elements in a piddle. The
specified percentile must be between 0.0 and 1.0.  When the specified
percentile falls between two values, the nearest data value is the
result.
.PP
.Vb 1
\& $x = oddpct($data, $pct);
.Ve
.SS "avg"
.IX Subsection "avg"
Return the average of all elements in a piddle.
.PP
See the documentation for average for more information.
.PP
.Vb 1
\& $x = avg($data);
.Ve
.PP
This routine handles bad values.
.SS "sum"
.IX Subsection "sum"
Return the sum of all elements in a piddle.
.PP
See the documentation for sumover for more information.
.PP
.Vb 1
\& $x = sum($data);
.Ve
.PP
This routine handles bad values.
.SS "prod"
.IX Subsection "prod"
Return the product of all elements in a piddle.
.PP
See the documentation for prodover for more information.
.PP
.Vb 1
\& $x = prod($data);
.Ve
.PP
This routine handles bad values.
.SS "davg"
.IX Subsection "davg"
Return the average (in double precision) of all elements in a piddle.
.PP
See the documentation for daverage for more information.
.PP
.Vb 1
\& $x = davg($data);
.Ve
.PP
This routine handles bad values.
.SS "dsum"
.IX Subsection "dsum"
Return the sum (in double precision) of all elements in a piddle.
.PP
See the documentation for dsumover for more information.
.PP
.Vb 1
\& $x = dsum($data);
.Ve
.PP
This routine handles bad values.
.SS "dprod"
.IX Subsection "dprod"
Return the product (in double precision) of all elements in a piddle.
.PP
See the documentation for dprodover for more information.
.PP
.Vb 1
\& $x = dprod($data);
.Ve
.PP
This routine handles bad values.
.SS "zcheck"
.IX Subsection "zcheck"
Return the check for zero of all elements in a piddle.
.PP
See the documentation for zcover for more information.
.PP
.Vb 1
\& $x = zcheck($data);
.Ve
.PP
This routine handles bad values.
.SS "and"
.IX Subsection "and"
Return the logical and of all elements in a piddle.
.PP
See the documentation for andover for more information.
.PP
.Vb 1
\& $x = and($data);
.Ve
.PP
This routine handles bad values.
.SS "band"
.IX Subsection "band"
Return the bitwise and of all elements in a piddle.
.PP
See the documentation for bandover for more information.
.PP
.Vb 1
\& $x = band($data);
.Ve
.PP
This routine handles bad values.
.SS "or"
.IX Subsection "or"
Return the logical or of all elements in a piddle.
.PP
See the documentation for orover for more information.
.PP
.Vb 1
\& $x = or($data);
.Ve
.PP
This routine handles bad values.
.SS "bor"
.IX Subsection "bor"
Return the bitwise or of all elements in a piddle.
.PP
See the documentation for borover for more information.
.PP
.Vb 1
\& $x = bor($data);
.Ve
.PP
This routine handles bad values.
.SS "min"
.IX Subsection "min"
Return the minimum of all elements in a piddle.
.PP
See the documentation for minimum for more information.
.PP
.Vb 1
\& $x = min($data);
.Ve
.PP
This routine handles bad values.
.SS "max"
.IX Subsection "max"
Return the maximum of all elements in a piddle.
.PP
See the documentation for maximum for more information.
.PP
.Vb 1
\& $x = max($data);
.Ve
.PP
This routine handles bad values.
.SS "median"
.IX Subsection "median"
Return the median of all elements in a piddle.
.PP
See the documentation for medover for more information.
.PP
.Vb 1
\& $x = median($data);
.Ve
.PP
This routine handles bad values.
.SS "mode"
.IX Subsection "mode"
Return the mode of all elements in a piddle.
.PP
See the documentation for modeover for more information.
.PP
.Vb 1
\& $x = mode($data);
.Ve
.PP
This routine handles bad values.
.SS "oddmedian"
.IX Subsection "oddmedian"
Return the oddmedian of all elements in a piddle.
.PP
See the documentation for oddmedover for more information.
.PP
.Vb 1
\& $x = oddmedian($data);
.Ve
.PP
This routine handles bad values.
.SS "any"
.IX Subsection "any"
Return true if any element in piddle set
.PP
Useful in conditional expressions:
.PP
.Vb 1
\& if (any $x>15) { print "some values are greater than 15\en" }
.Ve
.PP
See or for comments on what happens when all elements
in the check are bad.
.SS "all"
.IX Subsection "all"
Return true if all elements in piddle set
.PP
Useful in conditional expressions:
.PP
.Vb 1
\& if (all $x>15) { print "all values are greater than 15\en" }
.Ve
.PP
See and for comments on what happens when all elements
in the check are bad.
.SS "minmax"
.IX Subsection "minmax"
Returns an array with minimum and maximum values of a piddle.
.PP
.Vb 1
\& ($mn, $mx) = minmax($pdl);
.Ve
.PP
This routine does \fInot\fR thread over the dimensions of \f(CW$pdl\fR; 
it returns the minimum and maximum values of the whole array.
See minmaximum if this is not what is required.
The two values are returned as Perl scalars similar to min/max.
.PP
.Vb 4
\& pdl> $x = pdl [1,\-2,3,5,0]
\& pdl> ($min, $max) = minmax($x);
\& pdl> p "$min $max\en";
\& \-2 5
.Ve
.SS "qsort"
.IX Subsection "qsort"
.Vb 1
\&  Signature: (a(n); [o]b(n))
.Ve
.PP
Quicksort a vector into ascending order.
.PP
.Vb 1
\& print qsort random(10);
.Ve
.PP
Bad values are moved to the end of the array:
.PP
.Vb 4
\& pdl> p $y
\& [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
\& pdl> p qsort($y)
\& [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]
.Ve
.SS "qsorti"
.IX Subsection "qsorti"
.Vb 1
\&  Signature: (a(n); indx [o]indx(n))
.Ve
.PP
Quicksort a vector and return index of elements in ascending order.
.PP
.Vb 2
\& $ix = qsorti $x;
\& print $x\->index($ix); # Sorted list
.Ve
.PP
Bad elements are moved to the end of the array:
.PP
.Vb 4
\& pdl> p $y
\& [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
\& pdl> p $y\->index( qsorti($y) )
\& [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]
.Ve
.SS "qsortvec"
.IX Subsection "qsortvec"
.Vb 1
\&  Signature: (a(n,m); [o]b(n,m))
.Ve
.PP
Sort a list of vectors lexicographically.
.PP
The 0th dimension of the source piddle is dimension in the vector;
the 1st dimension is list order.  Higher dimensions are threaded over.
.PP
.Vb 9
\& print qsortvec pdl([[1,2],[0,500],[2,3],[4,2],[3,4],[3,5]]);
\& [
\&  [  0 500]
\&  [  1   2]
\&  [  2   3]
\&  [  3   4]
\&  [  3   5]
\&  [  4   2]
\& ]
.Ve
.PP
Vectors with bad components should be moved to the end of the array:
.SS "qsortveci"
.IX Subsection "qsortveci"
.Vb 1
\&  Signature: (a(n,m); indx [o]indx(m))
.Ve
.PP
Sort a list of vectors lexicographically, returning the indices of the
sorted vectors rather than the sorted list itself.
.PP
As with \f(CW\*(C`qsortvec\*(C'\fR, the input \s-1PDL\s0 should be an NxM array containing M
separate N\-dimensional vectors.  The return value is an integer M\-PDL 
containing the M\-indices of original array rows, in sorted order.
.PP
As with \f(CW\*(C`qsortvec\*(C'\fR, the zeroth element of the vectors runs slowest in the
sorted list.
.PP
Additional dimensions are threaded over: each plane is sorted separately,
so qsortveci may be thought of as a collapse operator of sorts (groan).
.PP
Vectors with bad components should be moved to the end of the array:
.SS "minimum"
.IX Subsection "minimum"
.Vb 1
\&  Signature: (a(n); [o]c())
.Ve
.PP
Project via minimum to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the minimum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = minimum($x);
.Ve
.PP
.Vb 1
\& $spectrum = minimum $image\->xchg(0,1)
.Ve
.PP
Output is set bad if all elements of the input are bad,
otherwise the bad flag is cleared for the output piddle.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values;
see isfinite and badmask
for ways of masking NaNs.
.SS "minimum_ind"
.IX Subsection "minimum_ind"
.Vb 1
\&  Signature: (a(n); indx [o] c())
.Ve
.PP
Like minimum but returns the index rather than the value
.PP
Output is set bad if all elements of the input are bad,
otherwise the bad flag is cleared for the output piddle.
.SS "minimum_n_ind"
.IX Subsection "minimum_n_ind"
.Vb 1
\&  Signature: (a(n); indx [o]c(m))
.Ve
.PP
Returns the index of \f(CW\*(C`m\*(C'\fR minimum elements
.PP
Not yet been converted to ignore bad values
.SS "maximum"
.IX Subsection "maximum"
.Vb 1
\&  Signature: (a(n); [o]c())
.Ve
.PP
Project via maximum to N\-1 dimensions
.PP
This function reduces the dimensionality of a piddle
by one by taking the maximum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = maximum($x);
.Ve
.PP
.Vb 1
\& $spectrum = maximum $image\->xchg(0,1)
.Ve
.PP
Output is set bad if all elements of the input are bad,
otherwise the bad flag is cleared for the output piddle.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values;
see isfinite and badmask
for ways of masking NaNs.
.SS "maximum_ind"
.IX Subsection "maximum_ind"
.Vb 1
\&  Signature: (a(n); indx [o] c())
.Ve
.PP
Like maximum but returns the index rather than the value
.PP
Output is set bad if all elements of the input are bad,
otherwise the bad flag is cleared for the output piddle.
.SS "maximum_n_ind"
.IX Subsection "maximum_n_ind"
.Vb 1
\&  Signature: (a(n); indx [o]c(m))
.Ve
.PP
Returns the index of \f(CW\*(C`m\*(C'\fR maximum elements
.PP
Not yet been converted to ignore bad values
.SS "maxover"
.IX Subsection "maxover"
.Vb 1
\&  Synonym for maximum.
.Ve
.SS "maxover_ind"
.IX Subsection "maxover_ind"
.Vb 1
\&  Synonym for maximum_ind.
.Ve
.SS "maxover_n_ind"
.IX Subsection "maxover_n_ind"
.Vb 1
\&  Synonym for maximum_n_ind.
.Ve
.SS "minover"
.IX Subsection "minover"
.Vb 1
\&  Synonym for minimum.
.Ve
.SS "minover_ind"
.IX Subsection "minover_ind"
.Vb 1
\&  Synonym for minimum_ind.
.Ve
.SS "minover_n_ind"
.IX Subsection "minover_n_ind"
.Vb 1
\&  Synonym for minimum_n_ind
.Ve
.SS "minmaximum"
.IX Subsection "minmaximum"
.Vb 1
\&  Signature: (a(n); [o]cmin(); [o] cmax(); indx [o]cmin_ind(); indx [o]cmax_ind())
.Ve
.PP
Find minimum and maximum and their indices for a given piddle;
.PP
.Vb 4
\& pdl> $x=pdl [[\-2,3,4],[1,0,3]]
\& pdl> ($min, $max, $min_ind, $max_ind)=minmaximum($x)
\& pdl> p $min, $max, $min_ind, $max_ind
\& [\-2 0] [4 3] [0 1] [2 2]
.Ve
.PP
See also minmax, which clumps the piddle together.
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data, then the output piddles will
be set bad, along with their bad flag.
Otherwise they will have their bad flags cleared,
since they will not contain any bad values.
.SS "minmaxover"
.IX Subsection "minmaxover"
.Vb 1
\&  Synonym for minmaximum.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu).
Contributions by Christian Soeller (c.soeller@auckland.ac.nz)
and Karl Glazebrook (kgb@aaoepp.aao.gov.au).  All rights
reserved. There is no warranty. You are allowed to redistribute this
software / documentation under certain conditions. For details, see
the file \s-1COPYING\s0 in the \s-1PDL\s0 distribution. If this file is separated
from the \s-1PDL\s0 distribution, the copyright notice should be included in
the file.
