.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sort::DataTypes 3"
.TH Sort::DataTypes 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sort::DataTypes \- Sort a list of data using methods relevant to the type of data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Sort::DataTypes qw(:all);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to sort a list of data elements using methods
that are relevant to the type of data contained in the list. This
modules does not attempt to be the fastest sorter on the block. If you
are sorting thousands of elements and need a lot of speed, you should
refer to a module specializing in the specific type of sort you will
be doing. However, to do smaller sorts of different types of data,
this is the module to use.
.SH "TYPES OF SORT METHODS"
.IX Header "TYPES OF SORT METHODS"
When sorting a list of elements, the elements are taken two at a time
and compared using some comparison function or operator. For example,
if you are comparing two strings alphabetically, the perl 'cmp'
operator is used to compare two strings.  The power of this module is
that the comparison can be done in a way that is relevant to the type
of data (for example, when comparing dates, it can determine which is
earlier, or when sorting a list of \s-1IP\s0 numbers, it knows how to compare
two different IPs).
.PP
There are serveral types of sort methods which determine how the
comparison will be done:
.IP "\fBUnambiguous Methods\fR" 4
.IX Item "Unambiguous Methods"
Unambiguous sort methods are those which unambiguously determine the
order of two elements in all cases.
.Sp
As an example, an alphabetic sort is unambiguous. It takes the entire
string of both elements and compares them and the order is well
defined.
.IP "\fBAmbiguous Methods\fR" 4
.IX Item "Ambiguous Methods"
Ambiguous methods are methods which compare the content of the two
elements but are not able to determine the relative order in all
situations.  In these situations, additional sort methods may be used
to refine the comparison.
.Sp
As an example, if you sort strings by length, there is an unambiguous
order when comparing a string of length 3 to one of length 4, but if
you have two strings of the same length, a secondary sort method may
be used to determine the order of these elements.
.IP "\fBSplit-Element Methods\fR" 4
.IX Item "Split-Element Methods"
Split-element methods are used to split an element into pieces, and
two different elements are compared by comparing the individual
pieces.
.Sp
As an example, if you are sorting domain names, you would first split
the domain name into a list of subdomains (i.e. foo.bar.com contains
the subdomains foo, bar, and com) and then each subdomain is sorted
separately.
.Sp
These elements require at least three pieces of information.  1) They
need information on how to split the element into pieces.  2) They
need to know whether the pieces are left most significant (\s-1LMS\s0) or
right most significant (\s-1RMS\s0).  In other words, whether to sort the
pieces from left to right or right to left.  3) They need sorting
information about how to compare individual pieces of two elements.
.IP "\fBPartial-Element Methods\fR" 4
.IX Item "Partial-Element Methods"
Partial-element methods are methods which work with only a portion of
the element. These require two types of information. 1) They require
some information about what portion of the element to sort on. 2) They
requires information about how to compare those subelements.
.Sp
As an example, you might sort a list of lines of text based on the Nth
field in each line.  So the first information required will be used to
determine how to find the Nth field. The second information will be
the actual sort method to use for ordering those fields.
.SH "USING SORT ROUTINES"
.IX Header "USING SORT ROUTINES"
All sort routines are named sort_METHOD where \s-1METHOD\s0 is the name of
the method. All sort_METHOD have both a forward and reverse sort:
.PP
.Vb 2
\&   $flag = sort_METHOD(\e@list [,@args]);
\&   $flag = sort_rev_METHOD(\e@list [,@args]);
.Ve
.PP
where \fB\f(CB@args\fB\fR are any additional arguments used for the sort.  These
will be described below.
.PP
Corresponding to every sort_METHOD routine is a cmp_METHOD routine
which takes two elements and returns a \-1, 0, or 1 (similar to
the cmp or <=> operators).
.PP
.Vb 2
\&   $flag = cmp_METHOD($x,$y [,@args]);
\&   $flag = cmp_rev_METHOD($x,$y [,@args]);
.Ve
.PP
Finally, there is an alternate way to do the sort/comparison:
.PP
.Vb 2
\&   $flag = sort_by_method(\*(AqMETHOD\*(Aq,    \e@list [,@args]);
\&   $flag = sort_by_method(\*(Aqrev_METHOD\*(Aq,\e@list [,@args]);
\&
\&   $flag = cmp_by_method(\*(AqMETHOD\*(Aq,    \e@list [,@args]);
\&   $flag = cmp_by_method(\*(Aqrev_METHOD\*(Aq,\e@list [,@args]);
.Ve
.PP
As an example, the following two calls are identical:
.PP
.Vb 2
\&   $flag = sort_alphabetic(\e@list);
\&   $flag = sort_by_method(\*(Aqalphabetic\*(Aq,\e@list);
.Ve
.PP
The value of \fB\f(CB$flag\fB\fR for a sort method is undef (if there is an
error) or 1 if the sort succeeds (and in this case, \fB\f(CB@list\fB\fR has been
reordered to be in the sorted order).  The value of \fB\f(CB$flag\fB\fR for a cmp
method is undef (if there is an error) or \-1, 0, or 1.
.PP
The contents of \fB\f(CB@args\fB\fR depends on the type of sort method and
are described in the sections below.
.SH "UNAMBIGUOUS METHODS"
.IX Header "UNAMBIGUOUS METHODS"
As described above, unambiguous methods do not use any secondary sort
methods.  For each of these sort methods, the contents of \fB\f(CB@args\fB\fR
are:
.PP
.Vb 1
\&   @args = (@method_args, $hash)
.Ve
.PP
and for cmp methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = (@method_args)
.Ve
.PP
\&\fB\f(CB@method_args\fB\fR is a list of arguments that will be passed to the
method.  Most unambiguous methods do not require any additional
arguments, but if they do, they would be here.  The list of possible
arguments are described in the documentation for each method.
.PP
\&\fB\f(CB$hash\fB\fR is an optional hash reference.  All sort_METHOD functions can
be used to sort a list using a hash.  For example, in the following
case:
.PP
.Vb 2
\&   @list = qw(foo bar ick);
\&   %hash = ( foo => 3, bar => 5, ick => 1 );
\&
\&   sort_numerical(\e@list,\e%hash);
.Ve
.PP
would result in \fB\f(CB@list\fB\fR containing:
.PP
.Vb 1
\&   (ick, foo, bar)
.Ve
.PP
since those correspond to numerical values of (1,3,5) respectively.
.PP
Each element in \fB\f(CB@list\fB\fR must be a key in \fB\f(CB%hash\fB\fR, and the value of
that key must be of the appropriate type.
.PP
The following methods are supported:
.IP "\fBsort_numerical\fR" 4
.IX Item "sort_numerical"
.PD 0
.IP "\fBsort_rev_numerical\fR" 4
.IX Item "sort_rev_numerical"
.IP "\fBcmp_numerical\fR" 4
.IX Item "cmp_numerical"
.IP "\fBcmp_rev_numerical\fR" 4
.IX Item "cmp_rev_numerical"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_numerical(\e@list [,@args]);
\&   $flag = sort_rev_numerical(\e@list [,@args]);
\&
\&   $flag = cmp_numerical($x,$y [,@args]);
\&   $flag = cmp_rev_numerical($x,$y [,@args]);
.Ve
.Sp
These sort/compare numbers.  There is little reason to use any of these
routines since it would be more efficient to simply call sort as:
.Sp
.Vb 1
\&   sort { $a <=> $b } @list
.Ve
.Sp
but they are included for the sake of completeness, and to make them
available for use by the sort_by_method and cmp_by_method
routines.
.IP "\fBsort_alphabetic\fR" 4
.IX Item "sort_alphabetic"
.PD 0
.IP "\fBsort_rev_alphabetic\fR" 4
.IX Item "sort_rev_alphabetic"
.IP "\fBcmp_alphabetic\fR" 4
.IX Item "cmp_alphabetic"
.IP "\fBcmp_rev_alphabetic\fR" 4
.IX Item "cmp_rev_alphabetic"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_alphabetic(\e@list [,@args]);
\&   $flag = sort_rev_alphabetic(\e@list [,@args]);
\&
\&   $flag = cmp_alphabetic($x,$y [,@args]);
\&   $flag = cmp_rev_alphabetic($x,$y [,@args]);
.Ve
.Sp
These sort/compare strings alphabetically. As with numerical sorts,
there is little reason to call these, and they are included for the
sake of completeness.
.IP "\fBsort_alphanum\fR" 4
.IX Item "sort_alphanum"
.PD 0
.IP "\fBsort_rev_alphanum\fR" 4
.IX Item "sort_rev_alphanum"
.IP "\fBcmp_alphanum\fR" 4
.IX Item "cmp_alphanum"
.IP "\fBcmp_rev_alphanum\fR" 4
.IX Item "cmp_rev_alphanum"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_alphanum(\e@list [,@args]);
\&   $flag = sort_rev_alphanum(\e@list [,@args]);
\&
\&   $flag = cmp_alphanum($x,$y [,@args]);
\&   $flag = cmp_rev_alphanum($x,$y [,@args]);
.Ve
.Sp
These do numeric sort/comparison if two elements are numeric (integer or real)
and alphabetic sorts otherwise.
.IP "\fBsort_random\fR" 4
.IX Item "sort_random"
.PD 0
.IP "\fBsort_rev_random\fR" 4
.IX Item "sort_rev_random"
.IP "\fBcmp_random\fR" 4
.IX Item "cmp_random"
.IP "\fBcmp_rev_random\fR" 4
.IX Item "cmp_rev_random"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_random(\e@list [,@args]);
\&   $flag = sort_rev_random(\e@list [,@args]);
\&
\&   $flag = cmp_random($x,$y [,@args]);
\&   $flag = cmp_rev_random($x,$y [,@args]);
.Ve
.Sp
This randomly shuffles an array in place.
.Sp
The sort_random and sort_rev_random routines are identical, and are
included simply for the situation where the sort routines are being
called in some automatically generated code that may add the 'rev_'
prefix.
.Sp
The cmp_random and cmp_rev_random routines simply returns a random \-1,
0, or 1.
.IP "\fBsort_version\fR" 4
.IX Item "sort_version"
.PD 0
.IP "\fBsort_rev_version\fR" 4
.IX Item "sort_rev_version"
.IP "\fBcmp_version\fR" 4
.IX Item "cmp_version"
.IP "\fBcmp_rev_version\fR" 4
.IX Item "cmp_rev_version"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_version(\e@list [,@args]);
\&   $flag = sort_rev_version(\e@list [,@args]);
\&
\&   $flag = cmp_version($x,$y [,@args]);
\&   $flag = cmp_rev_version($x,$y [,@args]);
.Ve
.Sp
These sort a list of version numbers of the form \s-1MAJOR.MINOR.SUBMINOR ...\s0
(any number of levels are allowed). The following examples should illustrate
the ordering:
.Sp
.Vb 10
\&   1.1.x < 1.2 < 1.2.x  Numerical versions are compared first at
\&                        the highest level, then at the next highest,
\&                        etc. The first non\-equal compare sets the
\&                        order.
\&   1.a < 1.b            Alphanumeric levels that start with a letter
\&                        are compared alphabetically.
\&   1.2a < 1.2 < 1.03a   Alphanumeric levels that start with a number
\&                        are first compared numerically with only the
\&                        numeric part. If they are equal, alphanumeric
\&                        levels come before purely numerical levels.
\&                        Otherwise, they are compared alphabetically.
\&   1.a < 1.2a           An alphanumeric level that starts with a letter
\&                        comes before one that starts with a number.
\&   1.01a < 1.1a         Two alphanumeric levels that are numerically
\&                        equal in the number part and equal in the
\&                        remaining part are compared alphabetically.
.Ve
.IP "\fBsort_date\fR" 4
.IX Item "sort_date"
.PD 0
.IP "\fBsort_rev_date\fR" 4
.IX Item "sort_rev_date"
.IP "\fBcmp_date\fR" 4
.IX Item "cmp_date"
.IP "\fBcmp_rev_date\fR" 4
.IX Item "cmp_rev_date"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_date(\e@list [,@args]);
\&   $flag = sort_rev_date(\e@list [,@args]);
\&
\&   $flag = cmp_date($x,$y [,@args]);
\&   $flag = cmp_rev_date($x,$y [,@args]);
.Ve
.Sp
These sort/compare a list of dates. Dates are anything that can be parsed
with Date::Manip.
.Sp
It should be noted that the dates will only be parsed a single time,
so it is not necessary to pre-parse them for performance reasons.
.IP "\fBsort_ip\fR" 4
.IX Item "sort_ip"
.PD 0
.IP "\fBsort_rev_ip\fR" 4
.IX Item "sort_rev_ip"
.IP "\fBcmp_ip\fR" 4
.IX Item "cmp_ip"
.IP "\fBcmp_rev_ip\fR" 4
.IX Item "cmp_rev_ip"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_ip(\e@list [,@args]);
\&   $flag = sort_rev_ip(\e@list [,@args]);
\&
\&   $flag = cmp_ip($x,$y [,@args]);
\&   $flag = cmp_rev_ip($x,$y [,@args]);
.Ve
.Sp
These sort/compare \s-1IP\s0 numbers. Each value can be a pure \s-1IP\s0 (in the form A.B.C.D)
or a \s-1CIDR\s0 notation which includes the netmask (A.B.C.D/MASK).
.Sp
When comparing \s-1CIDR\s0 representations, if the \s-1IP\s0 part of two elements is identical,
the following two rules are used:
.Sp
.Vb 1
\&   an element without a mask comes before one that has a mask
\&
\&   two elements with masks are sorted by mask
.Ve
.Sp
So the following elements are in sorted order:
.Sp
.Vb 1
\&   10.20.30.40 < 10.20.30.40/4 < 10.20.30.40/16
.Ve
.IP "\fBsort_nosort\fR" 4
.IX Item "sort_nosort"
.PD 0
.IP "\fBsort_rev_nosort\fR" 4
.IX Item "sort_rev_nosort"
.IP "\fBcmp_nosort\fR" 4
.IX Item "cmp_nosort"
.IP "\fBcmp_rev_nosort\fR" 4
.IX Item "cmp_rev_nosort"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_nosort(\e@list [,@args]);
\&   $flag = sort_rev_nosort(\e@list [,@args]);
\&
\&   $flag = cmp_nosort($x,$y [,@args]);
\&   $flag = cmp_rev_nosort($x,$y [,@args]);
.Ve
.Sp
These leave the list unchanged.  This primarily useful as an alternative sort method
if you do not wish to sort beyond a method that is ambiguous.
.IP "\fBsort_function\fR" 4
.IX Item "sort_function"
.PD 0
.IP "\fBsort_rev_function\fR" 4
.IX Item "sort_rev_function"
.IP "\fBcmp_function\fR" 4
.IX Item "cmp_function"
.IP "\fBcmp_rev_function\fR" 4
.IX Item "cmp_rev_function"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_function(\e@list [,@args]);
\&   $flag = sort_rev_function(\e@list [,@args]);
\&
\&   $flag = cmp_function($x,$y [,@args]);
\&   $flag = cmp_rev_function($x,$y [,@args]);
.Ve
.Sp
This is a catch-all sort function. \fB\f(CB@method_args\fB\fR contains a single
argument.  It is either a coderef or the name of a function suitable
to compar two elements and return \-1, 0, or 1 depending on the order
of the elements.
.Sp
The following both work:
.Sp
.Vb 2
\&   $flag = sort_function(\e@list,\e&somefunc);
\&   $flag = sort_function(\e@list,"somefunc");
.Ve
.Sp
If the function is passed in by name, it must be in the calling programs
namespace \s-1OR\s0 it must be passed in as a fully specified function name including
package (i.e. \*(L"package::functionname\*(R").
.SH "AMBIGUOUS METHODS"
.IX Header "AMBIGUOUS METHODS"
As described above, ambiguous methods do use a secondary sort methods.
For these sort methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = (@method_args, $hash, @extra_cmp_info)
.Ve
.PP
and for cmp methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = (@method_args, @extra_cmp_info)
.Ve
.PP
\&\fB\f(CB@method_args\fB\fR and \fB\f(CB$hash\fB\fR are similar to those described above for
unambiguous methods.
.PP
The contents of \fB\f(CB@extra_cmp_info\fB\fR are:
.PP
.Vb 4
\&   @extra_cmp_info  = ( [$method, @method_args],
\&                        [$method, @method_args],
\&                        ...
\&                      )
.Ve
.PP
Since an ambiguous method cannot always determine the order of two
elements, a backup method (or methods) may be specified.  The backup
sort method contains a method name (\fB\f(CB$method\fB\fR) and any arguments
required for that method.  The method must be either ambiguous or
unambiguous.  If it is ambiguous, an additional backup method may be
used.  If a method is unambiguous, no additional sort methods should
be included.
.PP
If a backup method is not supplied for an ambiguous method, a default
method will be used (typically alphabetic).
.PP
For the example where you sort strings by length, if you want to sort
all elements of the same length randomnly, you could use the following
sort:
.PP
.Vb 1
\&   sort_length(\e@list, [\*(Aqrandom\*(Aq]);
.Ve
.PP
The following methods are supported:
.IP "\fBsort_length\fR" 4
.IX Item "sort_length"
.PD 0
.IP "\fBsort_rev_length\fR" 4
.IX Item "sort_rev_length"
.IP "\fBcmp_length\fR" 4
.IX Item "cmp_length"
.IP "\fBcmp_rev_length\fR" 4
.IX Item "cmp_rev_length"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_length(\e@list [,@args]);
\&   $flag = sort_rev_length(\e@list [,@args]);
\&
\&   $flag = cmp_length($x,$y [,@args]);
\&   $flag = cmp_rev_length($x,$y [,@args]);
.Ve
.Sp
These take strings and compare them by length. If they are the same length, it sorts them
by a secondary method (which defaults to 'alphabetic').
.SH "SPLIT-ELEMENT METHODS"
.IX Header "SPLIT-ELEMENT METHODS"
As described above, split-element methods split an element into
pieces, and each of the pieces are compared separately using a
secondary sort method.
.PP
For these sort methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = (@method_args, $hash, @extra_sort_info)
.Ve
.PP
and for cmp methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = (@method_args, @extra_cmp_info)
.Ve
.PP
\&\fB\f(CB@method_args\fB\fR and \fB\f(CB$hash\fB\fR are similar to those described for
unambiguous methods.
.PP
A split-element method is not truly a sort method.  It is simply
a method for splitting an element into parts.  Then, every part
must be sorted.
.PP
As such, every split-element method will use other sort methods
for actually sorting the pieces.  If no \fB\f(CB@extra_sort_info\fB\fR or
\&\fB\f(CB@extra_cmp_info\fB\fR is supplied, it will typically default to
alphabetic sort.
.PP
If other sort methods are supplied, any other ambiguous, or
unambiguous method may be supplied.
.PP
It should be understood that all pieces are compared using the same
sort methods.  In other words, you cannot split an element into pieces
and compare the first set alphabetically, the second numerically, and
the third as dates.  To do this, you have to use the partial-element
methods described next.
.PP
Another note is that if a piece is empty in one element and not in the
other, the empty one will sort before the filled one (unless a reverse
sort is being done).
.PP
Once the element is split into pieces, they may be compared starting
at the leftmost piece:
.PP
.Vb 1
\&  a:b:c < a:c:d
.Ve
.PP
or starting at the rightmost piece:
.PP
.Vb 1
\&  c:b:a < a:b:c
.Ve
.PP
It should be noted that if an element is missing a piece, it will
always come \s-1BEFORE\s0 an element that has the piece (unless it's a
reverse sort in which case it will come after.
.PP
As an example, if you are sorting strings containing colon separated
pieces, the following order will be used:
.PP
.Vb 1
\&   a::c < a:c:d
.Ve
.PP
since the second piece is missing in the first element.  Likewise:
.PP
.Vb 1
\&   a:b < a:b:c
.Ve
.PP
since the third piece is missing in the first element.
.PP
The following split-element methods exist:
.IP "\fBsort_split\fR" 4
.IX Item "sort_split"
.PD 0
.IP "\fBsort_rev_split\fR" 4
.IX Item "sort_rev_split"
.IP "\fBcmp_split\fR" 4
.IX Item "cmp_split"
.IP "\fBcmp_rev_split\fR" 4
.IX Item "cmp_rev_split"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_split(\e@list [,@args]);
\&   $flag = sort_rev_split(\e@list [,@args]);
\&
\&   $flag = cmp_split($x,$y [,@args]);
\&   $flag = cmp_rev_split($x,$y [,@args]);
.Ve
.Sp
The \fB\f(CB@method_args\fB\fR segments of the arguments contain two optional
arguments.
.Sp
The first argument is either 'lms' or 'rms' (all options are case
sensitive, so they must be entered lowercase).  If 'lms' is given,
pieces are sorted starting at the left.  If 'rms' is given, they are
sorted from the right.  'lms' is the default.
.Sp
The second argument is a regexp.  It can be passed in as a string that
will be turned into a regular expression, or as an actaul
regexp, so one argument could be either of:
.Sp
.Vb 2
\&   \es+
\&   qr/\es+/
.Ve
.Sp
If no regexp is passed in, it defaults to
.Sp
.Vb 1
\&   qr/\es+/
.Ve
.PP
The following functions are also included for backward compatibility with
previous versions of this module.
.PP
These are deprecated, and may be removed at some point in the
future.
.PP
These can all be done trivially with the \fBsplit\fR functions listed
above (and all are coded as wrappers around those functions), so
slightly better performance can be obtained by using the \fBsplit\fR
functions directly.
.IP "\fBsort_domain\fR" 4
.IX Item "sort_domain"
.PD 0
.IP "\fBsort_rev_domain\fR" 4
.IX Item "sort_rev_domain"
.IP "\fBcmp_domain\fR" 4
.IX Item "cmp_domain"
.IP "\fBcmp_rev_domain\fR" 4
.IX Item "cmp_rev_domain"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_domain(\e@list [,@args]);
\&   $flag = sort_rev_domain(\e@list [,@args]);
\&
\&   $flag = cmp_domain($x,$y [,@args]);
\&   $flag = cmp_rev_domain($x,$y [,@args]);
.Ve
.Sp
Domain sorting is equivalent to split-element sorting with the priority of 'rms'
and a regular expression of qr/\e./ .  In other words, the following are equivalent:
.Sp
.Vb 2
\&   $flag = sort_domain(\e@list);
\&   $flag = sort_split(\e@list,\*(Aqrms\*(Aq,qr/\e./);
.Ve
.Sp
A single argument can be passed in in \fB\f(CB@method_args\fB\fR containing an alternate
regular expression if the elements should be split on something other than dots,
but the priority will always be 'rms'.
.Sp
Since the most significant subvalue in the domain is at the right, any
domain ending with \*(L".com\*(R" would come before any domain ending in \*(L".edu\*(R".
.Sp
.Vb 1
\&   a.b < z.b < a.bb < z.bb < a.c
.Ve
.IP "\fBsort_numdomain\fR" 4
.IX Item "sort_numdomain"
.PD 0
.IP "\fBsort_rev_numdomain\fR" 4
.IX Item "sort_rev_numdomain"
.IP "\fBcmp_numdomain\fR" 4
.IX Item "cmp_numdomain"
.IP "\fBcmp_rev_numdomain\fR" 4
.IX Item "cmp_rev_numdomain"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_numdomain(\e@list [,@args]);
\&   $flag = sort_rev_numdomain(\e@list [,@args]);
\&
\&   $flag = cmp_numdomain($x,$y [,@args]);
\&   $flag = cmp_rev_numdomain($x,$y [,@args]);
.Ve
.Sp
A related type of sorting is numdomain sorting. This is identical to
domain sorting except that if two elements in the domain are numerical,
numerical sorts will be done. So:
.Sp
.Vb 1
\&  a.2.c < a.11.c
.Ve
.Sp
It should be noted that if a field may be either numeric or alphanumeric,
sorting with this method may yield unexpected results. For example, sorting
the three elements:
.Sp
.Vb 3
\&  a.1.b
\&  a.2.b
\&  a.X.b
.Ve
.Sp
will use numeric comparisons when comparing the 2nd field of the first
and second elements, but it will use alphabetic comparisons when
comparing the first and third elements (or the second and third
elements).
.IP "\fBsort_path\fR" 4
.IX Item "sort_path"
.PD 0
.IP "\fBsort_rev_path\fR" 4
.IX Item "sort_rev_path"
.IP "\fBcmp_path\fR" 4
.IX Item "cmp_path"
.IP "\fBcmp_rev_path\fR" 4
.IX Item "cmp_rev_path"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_path(\e@list [,@args]);
\&   $flag = sort_rev_path(\e@list [,@args]);
\&
\&   $flag = cmp_path($x,$y [,@args]);
\&   $flag = cmp_rev_path($x,$y [,@args]);
.Ve
.Sp
Path sorting is equivalent to split-element sorting with the priority of 'lms'
and a regular expression of qr/\e// .  In other words, the following are equivalent:
.Sp
.Vb 2
\&   $flag = sort_path(\e@list);
\&   $flag = sort_split(\e@list,\*(Aqlms\*(Aq,qr/\e//);
.Ve
.Sp
A single argument can be passed in in \fB\f(CB@method_args\fB\fR containing an alternate
regular expression if the elements should be split on something other than slashes,
but the priority will always be 'lms'.
.Sp
Since the most significant element in the domain is at the left, you
get the following behavior:
.Sp
.Vb 1
\&   a/b < a/z < aa/b < aa/z < b/b
.Ve
.Sp
When sorting lists that have a mixture of relative paths and
explicit paths, the explicit paths will come first. So:
.Sp
.Vb 1
\&   /b/c < a/b
.Ve
.IP "\fBsort_numpath\fR" 4
.IX Item "sort_numpath"
.PD 0
.IP "\fBsort_rev_numpath\fR" 4
.IX Item "sort_rev_numpath"
.IP "\fBcmp_numpath\fR" 4
.IX Item "cmp_numpath"
.IP "\fBcmp_rev_numpath\fR" 4
.IX Item "cmp_rev_numpath"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_numpath(\e@list [,@args]);
\&   $flag = sort_rev_numpath(\e@list [,@args]);
\&
\&   $flag = cmp_numpath($x,$y [,@args]);
\&   $flag = cmp_rev_numpath($x,$y [,@args]);
.Ve
.Sp
A related type of sorting is numpath sorting. This is identical to
path sorting except that if two elements in the path are numbers,
numerical sorts will be done. So:
.Sp
.Vb 1
\&   a/2/c < a/11/c
.Ve
.SH "PARTIAL-ELEMENT METHODS"
.IX Header "PARTIAL-ELEMENT METHODS"
Partial-element sorting is, as described above, to split the element into fields
and then compare based on the Nth field.  In addition, you are allowed to sort
one field in one way, and a second field in an entirely different way.
.PP
For example, you could sort lines of the format:
.PP
.Vb 2
\&   2010\-01\-30  Smith  John
\&   2010\-01\-30  Smith  Adam
.Ve
.PP
first by date (the 1st field), alphabetically by last name (2nd field), and
alphabetically by first name (3rd field).
.PP
For these sort/cmp methods, the contents of \fB\f(CB@args\fB\fR are:
.PP
.Vb 1
\&   @args = ( $sep, [@field_args], [@field_args], ...)
.Ve
.PP
\&\fB\f(CB$sep\fB\fR is a regular expression used to split an element into fields.  It can
be entered as either a regular expression or a string that is turned into a regular
expression:
.PP
.Vb 2
\&   qr/\es+/
\&   \es+
.Ve
.PP
It is optional, and defaults to qr/\es+/ (i.e. split on whitespace).
.PP
\&\fB\f(CB@field_args\fB\fR describes how to sort one of the fields.  It is of the
form:
.PP
.Vb 1
\&   @field_args = ( $n, $hash, @extra_cmp_info )
.Ve
.PP
where \fB\f(CB$n\fB\fR is an integer and tells which field to sort (fields start
at 0), \f(CW$hash\fR is an optional hashref to use for this field (it's keys
are the values of the field, \s-1NOT\s0 the values of the element), and
\&\fB\f(CB@extra_cmp_info\fB\fR is described in the ambiguous methods section
above:
.PP
.Vb 5
\&   @extra_cmp_info  = ( [$method, @method_args],
\&                        [$method, @method_args],
\&                        ...
\&                      )
\&Sort methods must be either ambiguous or unambiguous.
.Ve
.PP
To sort the above example (by date, last name, and first name), you could use:
.PP
.Vb 3
\&   $flag = sort_partial(\e@list, qr/\es+/, [1, [\*(Aqdate\*(Aq]],
\&                                         [2, [\*(Aqalphabetic\*(Aq]],
\&                                         [3, [\*(Aqalphabetic\*(Aq]]);
.Ve
.IP "\fBsort_partial\fR" 4
.IX Item "sort_partial"
.PD 0
.IP "\fBsort_rev_partial\fR" 4
.IX Item "sort_rev_partial"
.IP "\fBcmp_partial\fR" 4
.IX Item "cmp_partial"
.IP "\fBcmp_rev_partial\fR" 4
.IX Item "cmp_rev_partial"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_partial(\e@list [,@args]);
\&   $flag = sort_rev_partial(\e@list [,@args]);
\&
\&   $flag = cmp_partial($x,$y [,@args]);
\&   $flag = cmp_rev_partial($x,$y [,@args]);
.Ve
.Sp
This is the basic partial-element sort routine.
.PP
The following functions are also included for backward compatibility with
previous versions of this module.
.PP
These are deprecated, and may be removed at some point in the
future.
.PP
These can all be done trivially with the \fBpartial\fR functions listed above (and
all are coded as wrappers around those functions), so slightly better performance
can be obtained by using the \fBsplit\fR functions directly.
.IP "\fBsort_line\fR" 4
.IX Item "sort_line"
.PD 0
.IP "\fBsort_rev_line\fR" 4
.IX Item "sort_rev_line"
.IP "\fBcmp_line\fR" 4
.IX Item "cmp_line"
.IP "\fBcmp_rev_line\fR" 4
.IX Item "cmp_rev_line"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_line(\e@list,$n [,$sep,] [,\e%hash]);
\&   $flag = sort_rev_line(\e@list,$n [,$sep] [,\e%hash]);
\&
\&   $flag = cmp_line($x,$y,$n [,$sep]);
\&   $flag = cmp_rev_line($x,$y,$n [,$sep]);
.Ve
.Sp
These take a list of lines and sort on the Nth field using \f(CW$sep\fR as the
regular expression splitting the lines into fields. Fields are
numbered starting at 0.  If no \f(CW$sep\fR is given, it defaults to white
space.
.Sp
This is included for backward compatibility only and does not allow sorting
on more than one field, or specifying the sort method for that field.
It is recommended that you use the \fBpartial\fR methods above.
.IP "\fBsort_numline\fR" 4
.IX Item "sort_numline"
.PD 0
.IP "\fBsort_rev_numline\fR" 4
.IX Item "sort_rev_numline"
.IP "\fBcmp_numline\fR" 4
.IX Item "cmp_numline"
.IP "\fBcmp_rev_numline\fR" 4
.IX Item "cmp_rev_numline"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_numline(\e@list,$n [,$sep,] [,\e%hash]);
\&   $flag = sort_rev_numline(\e@list,$n [,$sep] [,\e%hash]);
\&
\&   $flag = cmp_numline($x,$y,$n [,$sep]);
\&   $flag = cmp_rev_numline($x,$y,$n [,$sep]);
.Ve
.Sp
These are similar but will sort numerically if the Nth field is
numerical, and alphabetically otherwise.
.SH "MISC. ROUTINES"
.IX Header "MISC. ROUTINES"
.IP "\fBsort_valid_method\fR" 4
.IX Item "sort_valid_method"
.PD 0
.IP "\fBcmp_valid_method\fR" 4
.IX Item "cmp_valid_method"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_valid_method($string);
\&   $flag = cmp_valid_method($string);
.Ve
.Sp
These are identical and return 1 if there is a valid sort method named
\&\f(CW$string\fR in the module. For example, there is a function
\&\*(L"sort_numerical\*(R" defined in this modules, but there is no function
\&\*(L"sort_foobar\*(R", so the following would occur:
.Sp
.Vb 2
\&   sort_valid_method("numerical")
\&      => 1
\&
\&   sort_valid_method("rev_numerical")
\&      => 1
\&
\&   sort_valid_method("foobar")
\&      => 0
.Ve
.Sp
Note that the methods must \s-1NOT\s0 include the \*(L"sort_\*(R" or \*(L"cmp_\*(R" prefix, but
the \*(L"rev_\*(R" prefix is allowed as shown in the example.
.IP "\fBsort_by_method\fR" 4
.IX Item "sort_by_method"
.PD 0
.IP "\fBcmp_by_method\fR" 4
.IX Item "cmp_by_method"
.PD
.Vb 1
\&   use Sort::DataTypes qw(:all)
\&
\&   $flag = sort_by_method($method,\e@list [,@args]);
\&   $flag = cmp_by_method ($method,$ele1,$ele2 [,@args]);
.Ve
.Sp
These sort a list, or compare two elements, using the given method
(which is any string which returns 1 when passed to
sort_valid_method).
.Sp
If the method is not valid, the list is left untouched.
.SH "BACKWARDS INCOMPATIBILITIES"
.IX Header "BACKWARDS INCOMPATIBILITIES"
The following are a list of backwards incompatibilities.
.IP "\fBVersion 2.00 handling of hashes\fR" 4
.IX Item "Version 2.00 handling of hashes"
In version 1.xx, when sorting by hash, the hash was passed in
as the hash. As of 2.00, it is passed in by reference to avoid
any confusion with optional arguments.
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
None at this point.
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
