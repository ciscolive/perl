.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Search::Elasticsearch::Client::6_0::Direct 3"
.TH Search::Elasticsearch::Client::6_0::Direct 3 "2020-06-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Search::Elasticsearch::Client::6_0::Direct \- Thin client with full support for Elasticsearch 6.x APIs
.SH "VERSION"
.IX Header "VERSION"
version 6.81
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Create a client:
.PP
.Vb 4
\&    use Search::Elasticsearch;
\&    my $e = Search::Elasticsearch\->new(
\&        client => \*(Aq6_0::Direct\*(Aq
\&    );
.Ve
.PP
Index a doc:
.PP
.Vb 10
\&    $e\->index(
\&        index   => \*(Aqmy_index\*(Aq,
\&        type    => \*(Aqblog_post\*(Aq,
\&        id      => 123,
\&        body    => {
\&            title   => "Elasticsearch clients",
\&            content => "Interesting content...",
\&            date    => "2013\-09\-23"
\&        }
\&    );
.Ve
.PP
Get a doc:
.PP
.Vb 5
\&    $e\->get(
\&        index   => \*(Aqmy_index\*(Aq,
\&        type    => \*(Aqmy_type\*(Aq,
\&        id      => 123
\&    );
.Ve
.PP
Search for docs:
.PP
.Vb 10
\&    $results = $e\->search(
\&        index   => \*(Aqmy_index\*(Aq,
\&        body    => {
\&            query => {
\&                match => {
\&                    title => "elasticsearch"
\&                }
\&            }
\&        }
\&    );
.Ve
.PP
Index-level requests:
.PP
.Vb 2
\&    $e\->indices\->create( index => \*(Aqmy_index\*(Aq );
\&    $e\->indices\->delete( index => \*(Aqmy_index\*(Aq )
.Ve
.PP
Ingest pipeline requests:
.PP
.Vb 1
\&    $e\->ingest\->get_pipeline( id => \*(Aqapache\-logs\*(Aq );
.Ve
.PP
Cluster-level requests:
.PP
.Vb 1
\&    $health = $e\->cluster\->health;
.Ve
.PP
Node-level requests:
.PP
.Vb 2
\&    $info  = $e\->nodes\->info;
\&    $stats = $e\->nodes\->stats;
.Ve
.PP
Snapshot and restore:
.PP
.Vb 7
\&    $e\->snapshot\->create_repository(
\&        repository => \*(Aqmy_backups\*(Aq,
\&        type       => \*(Aqfs\*(Aq,
\&        settings   => {
\&            location => \*(Aq/mnt/backups\*(Aq
\&        }
\&    );
\&
\&    $e\->snapshot\->create(
\&        repository => \*(Aqmy_backups\*(Aq,
\&        snapshot   => \*(Aqbackup_2014\*(Aq
\&    );
.Ve
.PP
Task management:
.PP
.Vb 1
\&    $e\->tasks\->list;
.Ve
.PP
`cat` debugging:
.PP
.Vb 2
\&    say $e\->cat\->allocation;
\&    say $e\->cat\->health;
.Ve
.PP
Cross-cluster replication requests:
.PP
.Vb 1
\&    say $e\->ccr\->follow;
.Ve
.PP
Index lifecycle management requests:
.PP
.Vb 1
\&    say $e\->ilm\->put_lifecycle;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Search::Elasticsearch::Client::6_0::Direct class provides the
Elasticsearch 6.x compatible client returned by:
.PP
.Vb 3
\&    $e = Search::Elasticsearch\->new(
\&        client => "6_0::Direct"  # default
\&    );
.Ve
.PP
It is intended to be as close as possible to the native \s-1REST API\s0 that
Elasticsearch uses, so that it is easy to translate the
Elasticsearch reference documentation <http://www.elasticsearch/guide>
for an \s-1API\s0 to the equivalent in this client.
.PP
This class provides the methods for document \s-1CRUD\s0,
bulk document \s-1CRUD\s0 and search.
It also provides access to clients for managing indices
and the cluster.
.SH "PREVIOUS VERSIONS OF ELASTICSEARCH"
.IX Header "PREVIOUS VERSIONS OF ELASTICSEARCH"
This version of the client supports the Elasticsearch 6.0 branch,
which is not backwards compatible with earlier branches.
.PP
If you need to talk to a version of Elasticsearch before 6.0.0, please
install one of the following modules:
.IP "\(bu" 4
Search::Elasticsearch::Client::5_0
.IP "\(bu" 4
Search::Elasticsearch::Client::2_0
.IP "\(bu" 4
Search::Elasticsearch::Client::1_0
.IP "\(bu" 4
Search::Elasticsearch::Client::0_90
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
.SS "Parameter passing"
.IX Subsection "Parameter passing"
Parameters can be passed to any request method as a list or as a hash
reference. The following two statements are equivalent:
.PP
.Vb 2
\&    $e\->search( size => 10 );
\&    $e\->search({size => 10});
.Ve
.SS "Path parameters"
.IX Subsection "Path parameters"
Any values that should be included in the \s-1URL\s0 path, eg \f(CW\*(C`/{index}/{type}\*(C'\fR
should be passed as top level parameters:
.PP
.Vb 1
\&    $e\->search( index => \*(Aqmy_index\*(Aq, type => \*(Aqmy_type\*(Aq );
.Ve
.PP
Alternatively, you can specify a \f(CW\*(C`path\*(C'\fR parameter directly:
.PP
.Vb 1
\&    $e\->search( path => \*(Aq/my_index/my_type\*(Aq );
.Ve
.SS "Query-string parameters"
.IX Subsection "Query-string parameters"
Any values that should be included in the query string should be passed
as top level parameters:
.PP
.Vb 1
\&    $e\->search( size => 10 );
.Ve
.PP
If you pass in a \f(CW\*(C`\e%params\*(C'\fR hash, then it will be included in the
query string parameters without any error checking. The following:
.PP
.Vb 1
\&    $e\->search( size => 10, params => { from => 6, size => 6 })
.Ve
.PP
would result in this query string:
.PP
.Vb 1
\&    ?from=6&size=10
.Ve
.SS "Body parameter"
.IX Subsection "Body parameter"
The request body should be passed in the \f(CW\*(C`body\*(C'\fR key:
.PP
.Vb 5
\&    $e\->search(
\&        body => {
\&            query => {...}
\&        }
\&    );
.Ve
.PP
The body can also be a UTF8\-decoded string, which will be converted into
\&\s-1UTF\-8\s0 bytes and passed as is:
.PP
.Vb 1
\&    $e\->indices\->analyze( body => "The quick brown fox");
.Ve
.SS "Boolean parameters"
.IX Subsection "Boolean parameters"
Elasticsearch 6.0.0 and above no longer accepts truthy and falsey values for booleans.  Instead,
it will accept only a \s-1JSON\s0 \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR, or the string equivalents \f(CW"true"\fR or \f(CW"false"\fR.
.PP
In the Perl client, you can use the following values:
.IP "\(bu" 4
True: \f(CW\*(C`true\*(C'\fR, \f(CW\*(C`\e1\*(C'\fR, or a JSON::PP::Boolean object.
.IP "\(bu" 4
False: \f(CW\*(C`false\*(C'\fR, \f(CW\*(C`\e0\*(C'\fR, or a JSON::PP::Boolean object.
.SS "Filter path parameter"
.IX Subsection "Filter path parameter"
Any \s-1API\s0 which returns a \s-1JSON\s0 body accepts a \f(CW\*(C`filter_path\*(C'\fR parameter
which will filter the \s-1JSON\s0 down to only the specified paths.  For instance,
if you are running a search request and only want the \f(CW\*(C`total\*(C'\fR hits and
the \f(CW\*(C`_source\*(C'\fR field for each hit (without the \f(CW\*(C`_id\*(C'\fR, \f(CW\*(C`_index\*(C'\fR etc),
you can do:
.PP
.Vb 4
\&    $e\->search(
\&        query => {...},
\&        filter_paths => [ \*(Aqhits.total\*(Aq, \*(Aqhits.hits._source\*(Aq ]
\&    );
.Ve
.SS "Ignore parameter"
.IX Subsection "Ignore parameter"
Normally, any \s-1HTTP\s0 status code outside the 200\-299 range will result in
an error being thrown.  To suppress these errors, you can specify which
status codes to ignore in the \f(CW\*(C`ignore\*(C'\fR parameter.
.PP
.Vb 4
\&    $e\->indices\->delete(
\&        index  => \*(Aqmy_index\*(Aq,
\&        ignore => 404
\&    );
.Ve
.PP
This is most useful for
Missing errors, which
are triggered by a \f(CW404\fR status code when some requested resource does
not exist.
.PP
Multiple error codes can be specified with an array:
.PP
.Vb 4
\&    $e\->indices\->delete(
\&        index  => \*(Aqmy_index\*(Aq,
\&        ignore => [404,409]
\&    );
.Ve
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.ie n .SS """bulk_helper_class"""
.el .SS "\f(CWbulk_helper_class\fP"
.IX Subsection "bulk_helper_class"
The class to use for the \*(L"\fBbulk_helper()\fR\*(R" method. Defaults to
Search::Elasticsearch::Client::6_0::Bulk.
.ie n .SS """scroll_helper_class"""
.el .SS "\f(CWscroll_helper_class\fP"
.IX Subsection "scroll_helper_class"
The class to use for the \*(L"\fBscroll_helper()\fR\*(R" method. Defaults to
Search::Elasticsearch::Client::6_0::Scroll.
.SH "GENERAL METHODS"
.IX Header "GENERAL METHODS"
.ie n .SS """info()"""
.el .SS "\f(CWinfo()\fP"
.IX Subsection "info()"
.Vb 1
\&    $info = $e\->info
.Ve
.PP
Returns information about the version of Elasticsearch that the responding node
is running.
.ie n .SS """ping()"""
.el .SS "\f(CWping()\fP"
.IX Subsection "ping()"
.Vb 1
\&    $e\->ping
.Ve
.PP
Pings a node in the cluster and returns \f(CW1\fR if it receives a \f(CW200\fR
response, otherwise it throws an error.
.ie n .SS """indices()"""
.el .SS "\f(CWindices()\fP"
.IX Subsection "indices()"
.Vb 1
\&    $indices_client = $e\->indices;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Indices object which can be used
for managing indices, eg creating, deleting indices, managing mapping,
index settings etc.
.ie n .SS """ingest()"""
.el .SS "\f(CWingest()\fP"
.IX Subsection "ingest()"
.Vb 1
\&    $ingest_client = $e\->ingest;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Ingest object which can be used
for managing ingest pipelines.
.ie n .SS """cluster()"""
.el .SS "\f(CWcluster()\fP"
.IX Subsection "cluster()"
.Vb 1
\&    $cluster_client = $e\->cluster;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Cluster object which can be used
for managing the cluster, eg cluster-wide settings and cluster health.
.ie n .SS """nodes()"""
.el .SS "\f(CWnodes()\fP"
.IX Subsection "nodes()"
.Vb 1
\&    $node_client = $e\->nodes;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Nodes object which can be used
to retrieve node info and stats.
.ie n .SS """snapshot()"""
.el .SS "\f(CWsnapshot()\fP"
.IX Subsection "snapshot()"
.Vb 1
\&    $snapshot_client = $e\->snapshot;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Snapshot object which
is used for managing backup repositories and creating and restoring
snapshots.
.ie n .SS """tasks()"""
.el .SS "\f(CWtasks()\fP"
.IX Subsection "tasks()"
.Vb 1
\&    $tasks_client = $e\->tasks;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Tasks object which
is used for accessing the task management \s-1API.\s0
.ie n .SS """cat()"""
.el .SS "\f(CWcat()\fP"
.IX Subsection "cat()"
.Vb 1
\&    $cat_client = $e\->cat;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::Cat object which can be used
to retrieve simple to read text info for debugging and monitoring an
Elasticsearch cluster.
.ie n .SS """ccr()"""
.el .SS "\f(CWccr()\fP"
.IX Subsection "ccr()"
.Vb 1
\&    $ccr_client = $e\->ccr;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::CCR object which can be used
to handle cross-cluster replication requests.
.ie n .SS """ilm()"""
.el .SS "\f(CWilm()\fP"
.IX Subsection "ilm()"
.Vb 1
\&    $ilm_client = $e\->ilm;
.Ve
.PP
Returns a Search::Elasticsearch::Client::6_0::Direct::ILM object which can be used
to handle index lifecycle management requests.
.SH "DOCUMENT CRUD METHODS"
.IX Header "DOCUMENT CRUD METHODS"
These methods allow you to perform create, index, update and delete requests
for single documents:
.ie n .SS """index()"""
.el .SS "\f(CWindex()\fP"
.IX Subsection "index()"
.Vb 4
\&    $response = $e\->index(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # optional, otherwise auto\-generated
\&
\&        body    => { document }         # required
\&    );
.Ve
.PP
The \f(CW\*(C`index()\*(C'\fR method is used to index a new document or to reindex
an existing document.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`if_primary_term\*(C'\fR,
    \f(CW\*(C`if_seq_no\*(C'\fR,
    \f(CW\*(C`op_type\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`pipeline\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html>
for more information.
.ie n .SS """create()"""
.el .SS "\f(CWcreate()\fP"
.IX Subsection "create()"
.Vb 4
\&    $response = $e\->create(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&
\&        body    => { document }         # required
\&    );
.Ve
.PP
The \f(CW\*(C`create()\*(C'\fR method works exactly like the \*(L"\fBindex()\fR\*(R" method, except
that it will throw a \f(CW\*(C`Conflict\*(C'\fR error if a document with the same
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`id\*(C'\fR already exists.
.PP
Query string parameters:
    \f(CW\*(C`consistency\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`op_type\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the create docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-create.html>
for more information.
.ie n .SS """get()"""
.el .SS "\f(CWget()\fP"
.IX Subsection "get()"
.Vb 5
\&    $response = $e\->get(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&    );
.Ve
.PP
The \f(CW\*(C`get()\*(C'\fR method will retrieve the document with the specified
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`id\*(C'\fR, or will throw a \f(CW\*(C`Missing\*(C'\fR error.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`stored_fields\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the get docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html>
for more information.
.ie n .SS """get_source()"""
.el .SS "\f(CWget_source()\fP"
.IX Subsection "get_source()"
.Vb 5
\&    $response = $e\->get_source(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&    );
.Ve
.PP
The \f(CW\*(C`get_source()\*(C'\fR method works just like the \*(L"\fBget()\fR\*(R" method except that
it returns just the \f(CW\*(C`_source\*(C'\fR field (the value of the \f(CW\*(C`body\*(C'\fR parameter
in the \*(L"\fBindex()\fR\*(R" method) instead of returning the \f(CW\*(C`_source\*(C'\fR field
plus the document metadata, ie the \f(CW\*(C`_index\*(C'\fR, \f(CW\*(C`_type\*(C'\fR etc.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the get_source docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html>
for more information.
.ie n .SS """exists()"""
.el .SS "\f(CWexists()\fP"
.IX Subsection "exists()"
.Vb 5
\&    $response = $e\->exists(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&    );
.Ve
.PP
The \f(CW\*(C`exists()\*(C'\fR method returns \f(CW1\fR if a document with the specified
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`id\*(C'\fR exists, or an empty string if it doesn't.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the exists docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html>
for more information.
.ie n .SS """delete()"""
.el .SS "\f(CWdelete()\fP"
.IX Subsection "delete()"
.Vb 5
\&    $response = $e\->delete(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&    );
.Ve
.PP
The \f(CW\*(C`delete()\*(C'\fR method will delete the document with the specified
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`id\*(C'\fR, or will throw a \f(CW\*(C`Missing\*(C'\fR error.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`if_primary_term\*(C'\fR,
    \f(CW\*(C`if_seq_no\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the delete docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html>
for more information.
.ie n .SS """update()"""
.el .SS "\f(CWupdate()\fP"
.IX Subsection "update()"
.Vb 4
\&    $response = $e\->update(
\&        index   => \*(Aqindex_name\*(Aq,        # required
\&        type    => \*(Aqtype_name\*(Aq,         # required
\&        id      => \*(Aqdoc_id\*(Aq,            # required
\&
\&        body    => { update }           # required
\&    );
.Ve
.PP
The \f(CW\*(C`update()\*(C'\fR method updates a document with the corresponding
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`id\*(C'\fR if it exists. Updates can be performed either by:
.IP "\(bu" 4
providing a partial document to be merged in to the existing document:
.Sp
.Vb 6
\&    $response = $e\->update(
\&        ...,
\&        body => {
\&            doc => { new_field => \*(Aqnew_value\*(Aq},
\&        }
\&    );
.Ve
.IP "\(bu" 4
with an inline script:
.Sp
.Vb 9
\&    $response = $e\->update(
\&        ...,
\&        body => {
\&            script => {
\&                source => "ctx._source.counter += incr",
\&                params => { incr => 6 }
\&            }
\&        }
\&    );
.Ve
.IP "\(bu" 4
with an indexed script:
.Sp
.Vb 10
\&    $response = $e\->update(
\&        ...,
\&        body => {
\&            script => {
\&                id     => $id,
\&                lang   => \*(Aqpainless\*(Aq,
\&                params => { incr => 6 }
\&            }
\&        }
\&    );
.Ve
.Sp
See indexed scripts <https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_indexed_scripts>
for more information.
.IP "\(bu" 4
with a script stored as a file:
.Sp
.Vb 10
\&    $response = $e\->update(
\&        ...,
\&        body => {
\&            script => {
\&                file   => \*(Aqcounter\*(Aq,
\&                lang   => \*(Aqpainless\*(Aq,
\&                params => { incr => 6 }
\&            }
\&        }
\&    );
.Ve
.Sp
See scripting docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html>
for more information.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`if_primary_term\*(C'\fR,
    \f(CW\*(C`if_seq_no\*(C'\fR,
    \f(CW\*(C`lang\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`retry_on_conflict\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the update docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html>
for more information.
.ie n .SS """termvectors()"""
.el .SS "\f(CWtermvectors()\fP"
.IX Subsection "termvectors()"
.Vb 3
\&    $results = $e\->termvectors(
\&        index   => $index,          # required
\&        type    => $type,           # required
\&
\&        id      => $id,             # optional
\&        body    => {...}            # optional
\&    )
.Ve
.PP
The \f(CW\*(C`termvectors()\*(C'\fR method retrieves term and field statistics, positions,
offsets and payloads for the specified document, assuming that termvectors
have been enabled.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`field_statistics\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`offsets\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`payloads\*(C'\fR,
    \f(CW\*(C`positions\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`term_statistics\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the termvector docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html>
for more information.
.SH "BULK DOCUMENT CRUD METHODS"
.IX Header "BULK DOCUMENT CRUD METHODS"
The bulk document \s-1CRUD\s0 methods are used for running multiple \s-1CRUD\s0 actions
within a single request.  By reducing the number of network requests
that need to be made, bulk requests greatly improve performance.
.ie n .SS """bulk()"""
.el .SS "\f(CWbulk()\fP"
.IX Subsection "bulk()"
.Vb 3
\&    $response = $e\->bulk(
\&        index   => \*(Aqindex_name\*(Aq,        # required if type specified
\&        type    => \*(Aqtype_name\*(Aq,         # optional
\&
\&        body    => [ actions ]          # required
\&    );
.Ve
.PP
See Search::Elasticsearch::Client::6_0::Bulk and \*(L"\fBbulk_helper()\fR\*(R" for a helper module that makes
bulk indexing simpler to use.
.PP
The \f(CW\*(C`bulk()\*(C'\fR method can perform multiple \*(L"\fBindex()\fR\*(R", \*(L"\fBcreate()\fR\*(R",
\&\*(L"\fBdelete()\fR\*(R" or \*(L"\fBupdate()\fR\*(R" actions with a single request. The \f(CW\*(C`body\*(C'\fR
parameter expects an array containing the list of actions to perform.
.PP
An \fIaction\fR consists of an initial metadata hash ref containing the action
type, plus the associated metadata, eg :
.PP
.Vb 1
\&    { delete => { _index => \*(Aqindex\*(Aq, _type => \*(Aqtype\*(Aq, _id => 123 }}
.Ve
.PP
The \f(CW\*(C`index\*(C'\fR and \f(CW\*(C`create\*(C'\fR actions then expect a hashref containing
the document itself:
.PP
.Vb 2
\&    { create => { _index => \*(Aqindex\*(Aq, _type => \*(Aqtype\*(Aq, _id => 123 }},
\&    { title => "A newly created document" }
.Ve
.PP
And the \f(CW\*(C`update\*(C'\fR action expects a hashref containing the update commands,
eg:
.PP
.Vb 2
\&    { update => { _index => \*(Aqindex\*(Aq, _type => \*(Aqtype\*(Aq, _id => 123 }},
\&    { script => "ctx._source.counter+=1" }
.Ve
.PP
Each action can include the same parameters that you would pass to
the equivalent \*(L"\fBindex()\fR\*(R", \*(L"\fBcreate()\fR\*(R", \*(L"\fBdelete()\fR\*(R" or \*(L"\fBupdate()\fR\*(R"
request, except that \f(CW\*(C`_index\*(C'\fR, \f(CW\*(C`_type\*(C'\fR and \f(CW\*(C`_id\*(C'\fR must be specified with
the preceding underscore. All other parameters can be specified with or
without the underscore.
.PP
For instance:
.PP
.Vb 4
\&    $response = $e\->bulk(
\&        index   => \*(Aqindex_name\*(Aq,        # default index name
\&        type    => \*(Aqtype_name\*(Aq,         # default type name
\&        body    => [
\&
\&            # create action
\&            { create => {
\&                _index => \*(Aqnot_the_default_index\*(Aq,
\&                _type  => \*(Aqnot_the_default_type\*(Aq,
\&                _id    => 123
\&            }},
\&            { title => \*(AqFoo\*(Aq },
\&
\&            # index action
\&            { index => { _id => 124 }},
\&            { title => \*(AqFoo\*(Aq },
\&
\&            # delete action
\&            { delete => { _id => 126 }},
\&
\&            # update action
\&            { update => { _id => 126 }},
\&            { script => "ctx._source.counter+1" }
\&        ]
\&    );
.Ve
.PP
Each action is performed separately. One failed action will not
cause the others to fail as well.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`pipeline\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the bulk docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html>
for more information.
.ie n .SS """bulk_helper()"""
.el .SS "\f(CWbulk_helper()\fP"
.IX Subsection "bulk_helper()"
.Vb 1
\&    $bulk_helper = $e\->bulk_helper( @args );
.Ve
.PP
Returns a new instance of the class specified in the \*(L"bulk_helper_class\*(R",
which defaults to Search::Elasticsearch::Client::6_0::Bulk.
.ie n .SS """mget()"""
.el .SS "\f(CWmget()\fP"
.IX Subsection "mget()"
.Vb 3
\&    $results = $e\->mget(
\&        index   => \*(Aqdefault_index\*(Aq,     # optional, required when type specified
\&        type    => \*(Aqdefault_type\*(Aq,      # optional
\&
\&        body    => { docs or ids }      # required
\&    );
.Ve
.PP
The \f(CW\*(C`mget()\*(C'\fR method will retrieve multiple documents with a single request.
The \f(CW\*(C`body\*(C'\fR consists of an array of documents to retrieve:
.PP
.Vb 10
\&    $results = $e\->mget(
\&        index   => \*(Aqdefault_index\*(Aq,
\&        type    => \*(Aqdefault_type\*(Aq,
\&        body    => {
\&            docs => [
\&                { _id => 1},
\&                { _id => 2, _type => \*(Aqnot_the_default_type\*(Aq }
\&            ]
\&        }
\&    );
.Ve
.PP
You can also pass any of the other parameters that the \*(L"\fBget()\fR\*(R" request
accepts.
.PP
If you have specified an \f(CW\*(C`index\*(C'\fR and \f(CW\*(C`type\*(C'\fR, you can just include the
\&\f(CW\*(C`ids\*(C'\fR of the documents to retrieve:
.PP
.Vb 7
\&    $results = $e\->mget(
\&        index   => \*(Aqdefault_index\*(Aq,
\&        type    => \*(Aqdefault_type\*(Aq,
\&        body    => {
\&            ids => [ 1, 2, 3]
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`stored_fields\*(C'\fR
.PP
See the mget docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html>
for more information.
.ie n .SS """mtermvectors()"""
.el .SS "\f(CWmtermvectors()\fP"
.IX Subsection "mtermvectors()"
.Vb 3
\&    $results = $e\->mtermvectors(
\&        index   => $index,          # required if type specified
\&        type    => $type,           # optional
\&
\&        body    => { }              # optional
\&    )
.Ve
.PP
Runs multiple \*(L"\fBtermvector()\fR\*(R" requests in a single request, eg:
.PP
.Vb 9
\&    $results = $e\->mtermvectors(
\&        index   => \*(Aqtest\*(Aq,
\&        body    => {
\&            docs => [
\&                { _type => \*(Aqtest\*(Aq, _id => 1, fields => [\*(Aqtext\*(Aq] },
\&                { _type => \*(Aqtest\*(Aq, _id => 2, payloads => 1 },
\&            ]
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`field_statistics\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ids\*(C'\fR,
    \f(CW\*(C`offsets\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`payloads\*(C'\fR,
    \f(CW\*(C`positions\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`realtime\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`term_statistics\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the mtermvectors docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html>
for more information.
.SH "SEARCH METHODS"
.IX Header "SEARCH METHODS"
The search methods are used for querying documents in one, more or all indices
and of one, more or all types:
.ie n .SS """search()"""
.el .SS "\f(CWsearch()\fP"
.IX Subsection "search()"
.Vb 3
\&    $results = $e\->search(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional
\&
\&        body    => { search params }        # optional
\&    );
.Ve
.PP
The \f(CW\*(C`search()\*(C'\fR method searches for matching documents in one or more
indices.  It is just as easy to search a single index as it is to search
all the indices in your cluster.  It can also return
aggregations <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html>
highlighted snippets <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-highlighting.html>
and did-you-mean <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html>
or search-as-you-type <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html>
suggestions.
.PP
The \fIlite\fR version of search <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-uri-request.html>
allows you to specify a query string in the \f(CW\*(C`q\*(C'\fR parameter, using the
Lucene query string syntax:
.PP
.Vb 1
\&    $results = $e\->search( q => \*(Aqtitle:(elasticsearch clients)\*(Aq);
.Ve
.PP
However, the preferred way to search is by using the
Query \s-1DSL\s0 <http://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html>
to create a query, and passing that \f(CW\*(C`query\*(C'\fR in the
request body <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html>:
.PP
.Vb 7
\&    $results = $e\->search(
\&        body => {
\&            query => {
\&                match => { title => \*(AqElasticsearch clients\*(Aq}
\&            }
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`allow_partial_search_results\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`batched_reduce_size\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`docvalue_fields\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`explain\*(C'\fR,
    \f(CW\*(C`from\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_throttled\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`max_concurrent_shard_requests\*(C'\fR,
    \f(CW\*(C`pre_filter_shard_size\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`request_cache\*(C'\fR,
    \f(CW\*(C`rest_total_hits_as_int\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`scroll\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`seq_no_primary_term\*(C'\fR,
    \f(CW\*(C`size\*(C'\fR,
    \f(CW\*(C`sort\*(C'\fR,
    \f(CW\*(C`stats\*(C'\fR,
    \f(CW\*(C`stored_fields\*(C'\fR,
    \f(CW\*(C`suggest_field\*(C'\fR,
    \f(CW\*(C`suggest_mode\*(C'\fR,
    \f(CW\*(C`suggest_size\*(C'\fR,
    \f(CW\*(C`suggest_text\*(C'\fR,
    \f(CW\*(C`terminate_after\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`track_scores\*(C'\fR,
    \f(CW\*(C`track_total_hits\*(C'\fR,
    \f(CW\*(C`typed_keys\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR
.PP
See the search reference <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html>
for more information.
.PP
Also see \*(L"send_get_body_as\*(R" in Search::Elasticsearch::Transport.
.ie n .SS """count()"""
.el .SS "\f(CWcount()\fP"
.IX Subsection "count()"
.Vb 3
\&    $results = $e\->count(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional
\&
\&        body    => { query }                # optional
\&    )
.Ve
.PP
The \f(CW\*(C`count()\*(C'\fR method returns the total count of all documents matching the
query:
.PP
.Vb 7
\&    $results = $e\->count(
\&        body => {
\&            query => {
\&                match => { title => \*(AqElasticsearch clients\*(Aq }
\&            }
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_throttled\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`lowercase_expanded_terms\*(C'\fR
    \f(CW\*(C`min_score\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`terminate_after\*(C'\fR
.PP
See the count docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html>
for more information.
.ie n .SS """search_template()"""
.el .SS "\f(CWsearch_template()\fP"
.IX Subsection "search_template()"
.Vb 3
\&    $results = $e\->search_template(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional
\&
\&        body    => { search params }        # required
\&    );
.Ve
.PP
Perform a search by specifying a template (either predefined or defined
within the \f(CW\*(C`body\*(C'\fR) and parameters to use with the template, eg:
.PP
.Vb 10
\&    $results = $e\->search_template(
\&        body => {
\&            source => {
\&                query => {
\&                    match => {
\&                        "{{my_field}}" => "{{my_value}}"
\&                    }
\&                },
\&                size => "{{my_size}}"
\&            },
\&            params => {
\&                my_field => \*(Aqfoo\*(Aq,
\&                my_value => \*(Aqbar\*(Aq,
\&                my_size  => 6
\&            }
\&        }
\&    );
.Ve
.PP
See the search template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html>
for more information.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`explain\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_throttled\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`profile\*(C'\fR,
    \f(CW\*(C`rest_total_hits_as_int\*(C'\fR,
    \f(CW\*(C`scroll\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`typed_keys\*(C'\fR
.ie n .SS """render_search_template()"""
.el .SS "\f(CWrender_search_template()\fP"
.IX Subsection "render_search_template()"
.Vb 4
\&    $response = $e\->render_search_template(
\&        id   => \*(Aqid\*(Aq,           # optional
\&        body => { template }    # optional
\&    );
.Ve
.PP
Renders the template, filling in the passed-in parameters and returns the resulting \s-1JSON,\s0 eg:
.PP
.Vb 10
\&    $results = $e\->render_search_template(
\&        body => {
\&            source => {
\&                query => {
\&                    match => {
\&                        "{{my_field}}" => "{{my_value}}"
\&                    }
\&                },
\&                size => "{{my_size}}"
\&            },
\&            params => {
\&                my_field => \*(Aqfoo\*(Aq,
\&                my_value => \*(Aqbar\*(Aq,
\&                my_size  => 6
\&            }
\&        }
\&    );
.Ve
.PP
See the search template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html>
for more information.
.ie n .SS """scroll()"""
.el .SS "\f(CWscroll()\fP"
.IX Subsection "scroll()"
.Vb 6
\&    $results = $e\->scroll(
\&        scroll      => \*(Aq1m\*(Aq,
\&        body => {
\&            scroll_id   => $id
\&        }
\&    );
.Ve
.PP
When a \*(L"\fBsearch()\fR\*(R" has been performed with the
\&\f(CW\*(C`scroll\*(C'\fR parameter, the \f(CW\*(C`scroll()\*(C'\fR
method allows you to keep pulling more results until the results
are exhausted.
.PP
See \*(L"\fBscroll_helper()\fR\*(R" and Search::Elasticsearch::Client::6_0::Scroll for a helper utility
which makes managing scroll requests much easier.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`rest_total_hits_as_int\*(C'\fR,
    \f(CW\*(C`scroll\*(C'\fR,
    \f(CW\*(C`scroll_id\*(C'\fR
.PP
See the scroll docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html>
and the search_type docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search.html/search-request-search-type.html>
for more information.
.ie n .SS """clear_scroll()"""
.el .SS "\f(CWclear_scroll()\fP"
.IX Subsection "clear_scroll()"
.Vb 5
\&    $response = $e\->clear_scroll(
\&        body => {
\&            scroll_id => $id | \e@ids    # required
\&        }
\&    );
.Ve
.PP
The \f(CW\*(C`clear_scroll()\*(C'\fR method can clear unfinished scroll requests, freeing
up resources on the server.
.ie n .SS """scroll_helper()"""
.el .SS "\f(CWscroll_helper()\fP"
.IX Subsection "scroll_helper()"
.Vb 1
\&    $scroll_helper = $e\->scroll_helper( @args );
.Ve
.PP
Returns a new instance of the class specified in the \*(L"scroll_helper_class\*(R",
which defaults to Search::Elasticsearch::Client::6_0::Scroll.
.ie n .SS """msearch()"""
.el .SS "\f(CWmsearch()\fP"
.IX Subsection "msearch()"
.Vb 3
\&    $results = $e\->msearch(
\&        index   => \*(Aqdefault_index\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqdefault_type\*(Aq  | \e@types,       # optional
\&
\&        body    => [ searches ]                     # required
\&    );
.Ve
.PP
The \f(CW\*(C`msearch()\*(C'\fR method allows you to perform multiple searches in a single
request.  Similar to the \*(L"\fBbulk()\fR\*(R" request, each search request in the
\&\f(CW\*(C`body\*(C'\fR consists of two hashes: the metadata hash then the search request
hash (the same data that you'd specify in the \f(CW\*(C`body\*(C'\fR of a \*(L"\fBsearch()\fR\*(R"
request).  For instance:
.PP
.Vb 7
\&    $results = $e\->msearch(
\&        index   => \*(Aqdefault_index\*(Aq,
\&        type    => [\*(Aqdefault_type_1\*(Aq, \*(Aqdefault_type_2\*(Aq],
\&        body => [
\&            # uses defaults
\&            {},
\&            { query => { match_all => {} }},
\&
\&            # uses a custom index
\&            { index => \*(Aqnot_the_default_index\*(Aq },
\&            { query => { match_all => {} }}
\&        ]
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`max_concurrent_searches\*(C'\fR,
    \f(CW\*(C`max_\|_concurrent_shard_requests\*(C'\fR,
    \f(CW\*(C`pre_filter_shard_size\*(C'\fR,
    \f(CW\*(C`rest_total_hits_as_int\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`typed_keys\*(C'\fR
.PP
See the msearch docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html>
for more information.
.ie n .SS """msearch_template()"""
.el .SS "\f(CWmsearch_template()\fP"
.IX Subsection "msearch_template()"
.Vb 3
\&    $results = $e\->msearch_template(
\&        index   => \*(Aqdefault_index\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqdefault_type\*(Aq  | \e@types,       # optional
\&
\&        body    => [ search_templates ]             # required
\&    );
.Ve
.PP
The \f(CW\*(C`msearch_template()\*(C'\fR method allows you to perform multiple searches in a single
request using search templates.  Similar to the \*(L"\fBbulk()\fR\*(R" request, each search
request in the \f(CW\*(C`body\*(C'\fR consists of two hashes: the metadata hash then the search request
hash (the same data that you'd specify in the \f(CW\*(C`body\*(C'\fR of a \*(L"\fBsearch()\fR\*(R"
request).  For instance:
.PP
.Vb 7
\&    $results = $e\->msearch(
\&        index   => \*(Aqdefault_index\*(Aq,
\&        type    => [\*(Aqdefault_type_1\*(Aq, \*(Aqdefault_type_2\*(Aq],
\&        body => [
\&            # uses defaults
\&            {},
\&            { source => { query => { match => { user => "{{user}}" }}} params => { user => \*(Aqjoe\*(Aq }},
\&
\&            # uses a custom index
\&            { index => \*(Aqnot_the_default_index\*(Aq },
\&            { source => { query => { match => { user => "{{user}}" }}} params => { user => \*(Aqjoe\*(Aq }},
\&        ]
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`max_concurrent_searches\*(C'\fR,
    \f(CW\*(C`rest_total_hits_as_int\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`typed_keys\*(C'\fR
.PP
See the msearch-template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html>
for more information.
.ie n .SS """explain()"""
.el .SS "\f(CWexplain()\fP"
.IX Subsection "explain()"
.Vb 4
\&    $response = $e\->explain(
\&        index   => \*(Aqmy_index\*(Aq,  # required
\&        type    => \*(Aqmy_type\*(Aq,   # required
\&        id      => 123,         # required
\&
\&        body    => { search }   # required
\&    );
.Ve
.PP
The \f(CW\*(C`explain()\*(C'\fR method explains why the specified document did or
did not match a query, and how the relevance score was calculated.
For instance:
.PP
.Vb 10
\&    $response = $e\->explain(
\&        index   => \*(Aqmy_index\*(Aq,
\&        type    => \*(Aqmy_type\*(Aq,
\&        id      => 123,
\&        body    => {
\&            query => {
\&                match => { title => \*(AqElasticsearch clients\*(Aq }
\&            }
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`parent\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`stored_fields\*(C'\fR
.PP
See the explain docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html>
for more information.
.ie n .SS """field_caps()"""
.el .SS "\f(CWfield_caps()\fP"
.IX Subsection "field_caps()"
.Vb 4
\&    $response = $e\->field_caps(
\&        index   => \*(Aqindex\*(Aq   | \e@indices,   # optional
\&        body    => { filters }              # optional
\&    );
.Ve
.PP
The \f(CW\*(C`field\-caps\*(C'\fR \s-1API\s0 returns field types and abilities, merged across indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
.PP
See the field-caps docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html>
for more information.
.ie n .SS """search_shards()"""
.el .SS "\f(CWsearch_shards()\fP"
.IX Subsection "search_shards()"
.Vb 3
\&    $response = $e\->search_shards(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&    )
.Ve
.PP
The \f(CW\*(C`search_shards()\*(C'\fR method returns information about which shards on
which nodes will execute a search request.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR
.PP
See the search-shards docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html>
for more information.
.ie n .SS """rank_eval()"""
.el .SS "\f(CWrank_eval()\fP"
.IX Subsection "rank_eval()"
.Vb 4
\&    $result = $e\->rank_eval(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        body    => {...}                    # required
\&    );
.Ve
.PP
The ranking evaluation \s-1API\s0 provides a way to execute test cases to determine whether search results
are improving or worsening.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
.PP
See the rank-eval docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/search-rank-eval.html>
for more information.
.SH "CRUD-BY-QUERY METHODS"
.IX Header "CRUD-BY-QUERY METHODS"
.ie n .SS """delete_by_query()"""
.el .SS "\f(CWdelete_by_query()\fP"
.IX Subsection "delete_by_query()"
.Vb 5
\&    $response = $e\->delete_by_query(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional,
\&        body    => { delete\-by\-query }      # required
\&    );
.Ve
.PP
The \f(CW\*(C`delete_by_query()\*(C'\fR method deletes all documents which match the specified query.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`conflicts\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`from\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`request_cache\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`scroll\*(C'\fR,
    \f(CW\*(C`scroll_size\*(C'\fR,
    \f(CW\*(C`search_timeout\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`size\*(C'\fR,
    \f(CW\*(C`slices\*(C'\fR,
    \f(CW\*(C`sort\*(C'\fR,
    \f(CW\*(C`stats\*(C'\fR,
    \f(CW\*(C`terminate_after\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR,
    \f(CW\*(C`wait_for_completion\*(C'\fR
.PP
See the delete-by-query docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html>
for more information.
.ie n .SS """delete_by_query_rethrottle()"""
.el .SS "\f(CWdelete_by_query_rethrottle()\fP"
.IX Subsection "delete_by_query_rethrottle()"
.Vb 4
\&    $response = $e\->delete_by_query_rethrottle(
\&        task_id             => \*(Aqid\*(Aq         # required
\&        requests_per_second => num
\&    );
.Ve
.PP
The \f(CW\*(C`delete_by_query_rethrottle()\*(C'\fR \s-1API\s0 is used to dynamically update the throtting
of an existing delete-by-query request, identified by \f(CW\*(C`task_id\*(C'\fR.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR
.PP
See the delete-by-query-rethrottle docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html>
for more information.
.ie n .SS """reindex()"""
.el .SS "\f(CWreindex()\fP"
.IX Subsection "reindex()"
.Vb 3
\&    $response = $e\->reindex(
\&        body => { reindex }     # required
\&    );
.Ve
.PP
The \f(CW\*(C`reindex()\*(C'\fR \s-1API\s0 is used to index documents from one index or multiple indices
to a new index.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR,
    \f(CW\*(C`slices\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR,
    \f(CW\*(C`wait_for_completion\*(C'\fR
.PP
See the reindex docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html>
for more information.
.ie n .SS """reindex_rethrottle()"""
.el .SS "\f(CWreindex_rethrottle()\fP"
.IX Subsection "reindex_rethrottle()"
.Vb 4
\&    $response = $e\->delete_by_query_rethrottle(
\&        task_id => \*(Aqid\*(Aq,            # required
\&        requests_per_second => num
\&    );
.Ve
.PP
The \f(CW\*(C`reindex_rethrottle()\*(C'\fR \s-1API\s0 is used to dynamically update the throtting
of an existing reindex request, identified by \f(CW\*(C`task_id\*(C'\fR.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR
.PP
See the reindex-rethrottle docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html>
for more information.
.ie n .SS """update_by_query()"""
.el .SS "\f(CWupdate_by_query()\fP"
.IX Subsection "update_by_query()"
.Vb 5
\&    $response = $e\->update_by_query(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional,
\&        body    => { update\-by\-query }      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`update_by_query()\*(C'\fR \s-1API\s0 is used to bulk update documents from one index or
multiple indices using a script.
.PP
Query string parameters:
    \f(CW\*(C`_source\*(C'\fR,
    \f(CW\*(C`_source_excludes\*(C'\fR,
    \f(CW\*(C`_source_includes\*(C'\fR,
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`conflicts\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`from\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`pipeline\*(C'\fR,
    \f(CW\*(C`preference\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`request_cache\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR,
    \f(CW\*(C`routing\*(C'\fR,
    \f(CW\*(C`scroll\*(C'\fR,
    \f(CW\*(C`scroll_size\*(C'\fR,
    \f(CW\*(C`search_timeout\*(C'\fR,
    \f(CW\*(C`search_type\*(C'\fR,
    \f(CW\*(C`size\*(C'\fR,
    \f(CW\*(C`slices\*(C'\fR,
    \f(CW\*(C`sort\*(C'\fR,
    \f(CW\*(C`stats\*(C'\fR,
    \f(CW\*(C`terminate_after\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR,
    \f(CW\*(C`wait_for_completion\*(C'\fR
.PP
See the update_by_query docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html>
for more information.
.ie n .SS """update_by_query_rethrottle()"""
.el .SS "\f(CWupdate_by_query_rethrottle()\fP"
.IX Subsection "update_by_query_rethrottle()"
.Vb 4
\&    $response = $e\->update_by_query_rethrottle(
\&        task_id             => \*(Aqid\*(Aq         # required
\&        requests_per_second => num
\&    );
.Ve
.PP
The \f(CW\*(C`update_by_query_rethrottle()\*(C'\fR \s-1API\s0 is used to dynamically update the throtting
of an existing update-by-query request, identified by \f(CW\*(C`task_id\*(C'\fR.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`requests_per_second\*(C'\fR
.PP
See the update-by-query-rethrottle docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html>
for more information.
.SH "INDEXED SCRIPT METHODS"
.IX Header "INDEXED SCRIPT METHODS"
Elasticsearch allows you to store scripts in the cluster state
and reference them by id. The methods to manage indexed scripts are as follows:
.ie n .SS """put_script()"""
.el .SS "\f(CWput_script()\fP"
.IX Subsection "put_script()"
.Vb 5
\&    $result  = $e\->put_script(
\&        id      => \*(Aqid\*(Aq,       # required
\&        context => $context,   # optional
\&        body    => { script }  # required
\&    );
.Ve
.PP
The \f(CW\*(C`put_script()\*(C'\fR method is used to store a script in the cluster state. For instance:
.PP
.Vb 9
\&    $result  = $e\->put_scripts(
\&        id   => \*(Aqhello_world\*(Aq,
\&        body => {
\&          script => {
\&            lang   => \*(Aqpainless\*(Aq,
\&            source => q(return "hello world")
\&          }
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR
.PP
See the indexed scripts docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_indexed_scripts> for more.
.ie n .SS """get_script()"""
.el .SS "\f(CWget_script()\fP"
.IX Subsection "get_script()"
.Vb 3
\&    $script = $e\->get_script(
\&        id   => \*(Aqid\*(Aq,       # required
\&    );
.Ve
.PP
Retrieve the indexed script from the cluster state.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.PP
See the indexed scripts docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_indexed_scripts> for more.
.ie n .SS """delete_script()"""
.el .SS "\f(CWdelete_script()\fP"
.IX Subsection "delete_script()"
.Vb 3
\&    $script = $e\->delete_script(
\&        id   => \*(Aqid\*(Aq,       # required
\&    );
.Ve
.PP
Delete the indexed script from the cluster state.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the indexed scripts docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_indexed_scripts> for more.
.ie n .SS """scripts_painless_execute()"""
.el .SS "\f(CWscripts_painless_execute()\fP"
.IX Subsection "scripts_painless_execute()"
.Vb 3
\&    $result = $e\->scripts_painless_execute(
\&        body => {...}   # required
\&    );
.Ve
.PP
The Painless execute \s-1API\s0 allows an arbitrary script to be executed and a result to be returned.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR
.PP
See the painless execution docs <https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-execute-api.html> for more.
.SH "AUTHOR"
.IX Header "AUTHOR"
Enrico Zimuel <enrico.zimuel@elastic.co>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Elasticsearch \s-1BV.\s0
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
