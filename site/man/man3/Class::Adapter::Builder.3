.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::Adapter::Builder 3"
.TH Class::Adapter::Builder 3 "2018-04-10" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Class::Adapter::Builder \- Generate Class::Adapter classes
.SH "VERSION"
.IX Header "VERSION"
version 1.09
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::Adapter;
\&  
\&  use strict;
\&  use Class::Adapter::Builder
\&      ISA     => \*(AqSpecific::API\*(Aq,
\&      METHODS => [ qw{foo bar baz} ],
\&      method  => \*(Aqdifferent_method\*(Aq;
\&  
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Class::Adapter::Builder\*(C'\fR is another mechanism for letting you create
\&\fIAdapter\fR classes of your own.
.PP
It is intended to act as a toolkit for generating the guts of many varied
and different types of \fIAdapter\fR classes.
.PP
For a simple base class you can inherit from and change a specific method,
see Class::Adapter::Clear.
.SS "The Pragma Interface"
.IX Subsection "The Pragma Interface"
The most common method for defining \fIAdapter\fR classes, as shown in the
synopsis, is the pragma interface.
.PP
This consists of a set of key/value pairs provided when you load the module.
.PP
.Vb 2
\&  # The format for building Adapter classes
\&  use Class::Adapter::Builder PARAM => VALUE, ...
.Ve
.IP "\s-1ISA\s0" 4
.IX Item "ISA"
The \f(CW\*(C`ISA\*(C'\fR param is provided as either a single value, or a reference
to an \f(CW\*(C`ARRAY\*(C'\fR containing is list of classes.
.Sp
Normally this is just a straight list of classes. However, if the value
for \f(CW\*(C`ISA\*(C'\fR is set to \f(CW\*(Aq_OBJECT_\*(Aq\fR the object will identify itself as
whatever is contained in it when the \f(CW\*(C`\->isa\*(C'\fR and \f(CW\*(C`\->can\*(C'\fR method
are called on it.
.IP "\s-1NEW\s0" 4
.IX Item "NEW"
Normally, you need to create your \f(CW\*(C`Class::Adapter\*(C'\fR objects separately:
.Sp
.Vb 2
\&  # Create the object
\&  my $query = CGI\->new( \*(Aqparam1\*(Aq, \*(Aqparam2\*(Aq );
\&  
\&  # Create the Decorator
\&  my $object = My::Adapter\->new( $query );
.Ve
.Sp
If you provide a class name as the \f(CW\*(C`NEW\*(C'\fR param, the Decorator will
do this for you, passing on any constructor arguments.
.Sp
.Vb 2
\&  # Assume we provided the following
\&  # NEW => \*(AqCGI\*(Aq,
\&  
\&  # We can now do the above in one step
\&  my $object = My::Adapter\->new( \*(Aqparam1\*(Aq, \*(Aqparam2\*(Aq );
.Ve
.IP "\s-1AUTOLOAD\s0" 4
.IX Item "AUTOLOAD"
By default, a \f(CW\*(C`Class::Adapter\*(C'\fR does not pass on any methods, with the
methods to be passed on specified explicitly with the \f(CW\*(AqMETHODS\*(Aq\fR
param.
.Sp
By setting \f(CW\*(C`AUTOLOAD\*(C'\fR to true, the \f(CW\*(C`Adapter\*(C'\fR will be given the
standard \f(CW\*(C`AUTOLOAD\*(C'\fR function to to pass through all unspecified
methods to the parent object.
.Sp
By default the \s-1AUTOLOAD\s0 will pass through any and all calls, including
calls to private methods.
.Sp
If the \s-1AUTOLOAD\s0 is specifically set to '\s-1PUBLIC\s0', the \s-1AUTOLOAD\s0 setting
will \s-1ONLY\s0 apply to public methods, and any private methods will not
be passed through.
.IP "\s-1METHODS\s0" 4
.IX Item "METHODS"
The \f(CW\*(C`METHODS\*(C'\fR param is provided as a reference to an array of all
the methods that are to be passed through to the parent object as is.
.PP
Any params other than the ones specified above are taken as translated
methods.
.PP
.Vb 2
\&  # If you provide the following
\&  # foo => bar
\&  
\&  # It the following are equivalent
\&  $decorator\->foo;
\&  $decorator\->_OBJECT_\->bar;
.Ve
.PP
This capability is provided primarily because in Perl one of the main
situations in which you hit the limits of Perl's inheritance model is
when your class needs to inherit from multiple different classes that
containing clashing methods.
.PP
For example:
.PP
.Vb 2
\&  # If your class is like this
\&  package Foo;
\&  
\&  use base \*(AqThis\*(Aq, \*(AqThat\*(Aq;
\&  
\&  1;
.Ve
.PP
If both \f(CW\*(C`This\->method\*(C'\fR exists and \f(CW\*(C`That\->method\*(C'\fR exists,
and both mean different things, then \f(CW\*(C`Foo\->method\*(C'\fR becomes
ambiguous.
.PP
A \f(CW\*(C`Class::Adapter\*(C'\fR could be used to wrap your \f(CW\*(C`Foo\*(C'\fR object, with
the \f(CW\*(C`Class::Adapter\*(C'\fR becoming the \f(CW\*(C`That\*(C'\fR sub-class, and passing
\&\f(CW\*(C`$decorator\->method\*(C'\fR through to \f(CW\*(C`$object\->that_method\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
Yes, \f(CW\*(C`Class::Adapter::Builder\*(C'\fR has public methods and later on you will
be able to access them directly, but for now they are remaining
undocumented, so that I can shuffle things around for another few
versions.
.PP
Just stick to the pragma interface for now.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Class::Adapter, Class::Adapter::Clear
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=Class-Adapter>
(or bug\-Class\-Adapter@rt.cpan.org <mailto:bug-Class-Adapter@rt.cpan.org>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2005 by Adam Kennedy.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
