.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Keyword::Declare 3"
.TH Keyword::Declare 3 "2020-02-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Keyword::Declare \- Declare new Perl keywords...via a keyword...named "keyword"
.SH "VERSION"
.IX Header "VERSION"
This document describes Keyword::Declare version 0.001017
.SH "STATUS"
.IX Header "STATUS"
This module is an alpha release.
Aspects of its behaviour may still change in future releases.
They have already done so in past releases.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Keyword::Declare;
\&
\&    # Declare something matchable within a keyword\*(Aqs syntax...
\&    keytype UntilOrWhile is /until|while/;
\&
\&    # Declare a keyword and its syntax...
\&    keyword repeat (UntilOrWhile $type, List $condition, Block $code) {
\&        # Return new source code as a string (which replaces any parsed syntax)
\&        return qq{
\&            while (1) {
\&                $code;
\&                redo $type $condition;
\&                last;
\&            }
\&        };
\&    }
\&
\&    # Implement method declarator...
\&    keyword method (Ident $name, List $params?, /:\ew+/ @attrs?, Block $body) {
\&        return build_method_source_code($name, $params//\*(Aq()\*(Aq, \e@attrs, $body);
\&    }
\&
\&    # Keywords can have two or more definitions (distinguished by syntax)...
\&    keyword test (String $desc, Comma, Expr $test) {
\&        return "use Test::More; ok $test => $desc"
\&    }
\&
\&    keyword test (Expr $test) {
\&        my $desc = "q{$test at line }._\|_LINE_\|_";
\&        return "use Test::More; ok $test => $desc"
\&    }
\&
\&    keyword test (String $desc, Block $subtests) {
\&        return "use Test::More; subtest $desc => sub $subtests;"
\&    }
\&
\&    # Keywords can be removed from the remainder of the lexical scope...
\&    unkeyword test;
\&
\&    # Keywords declared in an import() or unimport() are automatically exported...
\&    sub import {
\&
\&        keyword debug (Expr $expr) {
\&            return "" if !$ENV{DEBUG};
\&            return "use Data::Dump \*(Aqddx\*(Aq; ddx $expr";
\&        }
\&
\&    }
\&
\&    # Keywords removals in an unimport() or import() are also automatically exported...
\&    sub unimport {
\&
\&        unkeyword debug;
\&
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a new Perl keyword: \f(CW\*(C`keyword\*(C'\fR, which you can
use to specify other new keywords.
.PP
Normally, to define new keywords in Perl, you either have to write them
in \s-1XS\s0 (shiver!) or use a module like Keyword::Simple or
Keyword::API. Using any of these approaches requires you to grab all
the source code after the keyword, manually parse out the components of
the keyword's syntax, construct the replacement source code, and then
substitute it for the original source code you just parsed.
.PP
Using Keyword::Declare, you define a new keyword by specifying its name
and a parameter list corresponding to the syntactic components that must
follow the keyword. You then use those parameters to construct and
return the replacement source code. The module takes care of setting up
the keyword, and of the associated syntax parsing, and of inserting the
replacement source code in the correct place.
.PP
For example, to create a new keyword (say: \f(CW\*(C`loop\*(C'\fR) that takes an optional
count and a block, you could write:
.PP
.Vb 1
\&    use Keyword::Declare;
\&
\&    keyword loop (Int $count?, Block $block) {
\&        if (length $count) {
\&            return "for (1..$count) $block";
\&        }
\&        else {
\&            return "while (1) $block";
\&        }
\&    }
.Ve
.PP
At compile time, when the parser subsequently encounters source
code such as:
.PP
.Vb 4
\&    loop 10 {
\&        $cmd = readline;
\&        last if valid_cmd($cmd);
\&    }
.Ve
.PP
then the keyword's \f(CW$count\fR parameter would be assigned the value \f(CW"10"\fR
and its \f(CW$code\fR parameter would be assigned the value
\&\f(CW"{\en$cmd = readline;\enlast if valid_cmd($cmd);\en}"\fR. Then the \*(L"body\*(R" of
the keyword definition would be executed and its return value would be used as the
replacement source code:
.PP
.Vb 4
\&    for (1..10) {
\&        $cmd = readline;
\&        last if valid_cmd($cmd);
\&    }
.Ve
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "Declaring a new lexical keyword"
.IX Subsection "Declaring a new lexical keyword"
The general syntax for declaring new keywords is:
.PP
.Vb 1
\&    keyword NAME (PARAM, PARAM, PARAM...) ATTRS { REPLACEMENT }
.Ve
.PP
The name of the new keyword can be any identifier, including the name of
an existing Perl keyword. However, using the name of an existing keyword
usually creates an infinite loop of keyword expansion, so it rarely does
what you actually wanted. In particular, the module will not allow you
to declare a new keyword named \f(CW\*(C`keyword\*(C'\fR, as that way lies madness.
.SS "Specifying keyword parameters"
.IX Subsection "Specifying keyword parameters"
The parameters of the keyword tell it how to parse the source code that
follows it. The general syntax for each parameter is:
.PP
.Vb 1
\&                         TYPE  [?*+][?+]  [$@]NAME  :sep(TYPE)  = \*(AqDEFAULT\*(Aq
\&
\&                         \e_\|_/  \e_\|_\|_\|_\|_\|_\|_/  \e_\|_\|_\|_\|_\|_/  \e_\|_\|_\|_\|_\|_\|_\|_/  \e_\|_\|_\|_\|_\|_\|_\|_\|_/
\&    Parameter type.........:       :          :          :           :
\&    Repetition specifier...........:          :          :           :
\&    Parameter variable........................:          :           :
\&    Separator specifier..................................:           :
\&    Default source code (if argument is missing).....................:
.Ve
.PP
The type specifier is required, but the other four components
are optional. Each component is described in the following sections.
.PP
\fIKeyword parameter types\fR
.IX Subsection "Keyword parameter types"
.PP
The type of each keyword parameter specifies how to parse the
corresponding item in the source code after the keyword.
.PP
The type of each keyword parameter may be specified as either a type
name, a regex, or a literal string...
.PP
Named types
.IX Subsection "Named types"
.PP
A named type is simply a convenient label for some standard or
user-defined regex or string. Most of the available named types are
drawn from the \s-1PPR\s0 module, and are named with just the post\-\*(L"Perl...\*(R"
component of the \s-1PPR\s0 name.
.PP
For example, the \f(CW\*(C`Expression\*(C'\fR type is the same as the \s-1PPR\s0 named
subpattern \f(CW\*(C`(?&PerlExpression\*(C'\fR) and the \f(CW\*(C`Variable\*(C'\fR type is identical
to the \s-1PPR\s0 named subpattern \f(CW\*(C`(?&PerlVariable)\*(C'\fR.
.PP
The standard named types that are available are:
.PP
.Vb 10
\&    ArrayIndexer .................................. An expression or list in square brackets
\&    AssignmentOperator ............................ A \*(Aq=\*(Aq or any operator assignment: \*(Aq+=\*(Aq, \*(Aq*=\*(Aq, etc.
\&    Attributes .................................... Subroutine or variable :attr(ributes) :with : colons
\&    Comma ......................................... A \*(Aq,\*(Aq or \*(Aq=>\*(Aq
\&    Document ...................................... Perl code and optional _\|_END_\|_ block
\&    HashIndexer ................................... An expression or list in curly brackets
\&    InfixBinaryOperator ........................... An infix operator of precedence from \*(Aq**\*(Aq down to \*(Aq..\*(Aq
\&    LowPrecedenceInfixOperator .................... An \*(Aqand\*(Aq, \*(Aqor\*(Aq, or \*(Aqxor
\&    OWS ........................................... Optional whitespace (including comments or POD)
\&    PostfixUnaryOperator .......................... A high\-precedence postfix operator like \*(Aq++\*(Aq or \*(Aq\-\-\*(Aq
\&    PrefixUnaryOperator ........................... A high\-precedence prefix operator like \*(Aq+\*(Aq or \*(Aq\-\-\*(Aq
\&    StatementModifier ............................. A postfix \*(Aqif\*(Aq, \*(Aqwhile\*(Aq, \*(Aqfor\*(Aq, etc.
\&    NWS or Whitespace ............................. Non\-optional whitespace (including comments or POD)
\&    Statement ..................................... Any single valid Perl statement
\&    Block ......................................... A curly bracket delimited block of statements
\&    Comment ....................................... A #\-to\-newline comment
\&    ControlBlock .................................. An if, while, for, unless, or until and its block
\&    Expression or Expr ............................ An expression involving operators of any precedence
\&    Format ........................................ A format declaration
\&    Keyword ....................................... Any user\-defined keyword and its arguments
\&    Label ......................................... A statement label
\&    PackageDeclaration ............................ A package declaration or definition
\&    Pod ........................................... Documentation terminated by a =cut
\&    SubroutineDeclaration ......................... A named subroutine declaration or definition
\&    UseStatement .................................. A use <module> or use <version> statement
\&    LowPrecedenceNotExpression .................... An expression at the precedence of not
\&    List .......................................... An list of comma\-separated expressions
\&    CommaList ..................................... An unparenthesized list of comma\-separated expressions
\&    Assignment .................................... One or more chained assignments
\&    ConditionalExpression or Ternary or ListElem... An expression involving the ?: operator;
\&                                                    also matches a single element of a comma\-separated list
\&    BinaryExpression .............................. An expression involving infix operators
\&    PrefixPostfixTerm ............................. A term with optional unary operator(s)
\&    Term .......................................... An expression not involving operators
\&    AnonymousArray or AnonArray ................... An anonymous array constructor
\&    AnonymousHash or AnonHash ..................... An anonymous hash constructor
\&    AnonymousSubroutine ........................... An unnamed subroutine definition
\&    Call .......................................... A call to a built\-in function or user\-defined subroutine
\&    DiamondOperator ............................... A <readline> or <shell glob>
\&    DoBlock ....................................... A do block
\&    EvalBlock ..................................... An eval block
\&    Literal ....................................... Any literal compile\-time value
\&    Lvalue ........................................ Anything that can be assigned to
\&    ParenthesesList or ParensList ................. A parenthesized list of zero\-or\-more elements
\&    Quotelike ..................................... Any quotelike term
\&    ReturnStatement ............................... A return statement in a subroutine
\&    Typeglob ...................................... A typeglob lookup
\&    VariableDeclaration or VarDecl ................ A my, our, or state declaration
\&    Variable or Var ............................... A variable of any species
\&    ArrayAccess ................................... An array lookup or a slice
\&    Bareword ...................................... A bareword
\&    BuiltinFunction ............................... A call to a builtin\-in function
\&    HashAccess .................................... A hash lookup or key/value slice
\&    Number or Num ................................. Any number
\&    QuotelikeQW ................................... A qw/.../
\&    QuotelikeQX ................................... A \`...\` or qx/.../
\&    Regex or Regexp ............................... A /.../, m/.../, or qr/.../
\&    ScalarAccess .................................. A scalar variable or lookup
\&    String or Str ................................. Any single\- or double\-quoted string
\&    Substitution or QuotelikeS .................... An s/.../.../
\&    Transliteration or QuotelikeTR ................ A tr/.../.../
\&    ContextualRegex ............................... A /.../, m/.../, or qr/.../ where it\*(Aqs valid in Perl
\&    Heredoc ....................................... A heredoc marker (but not the contents)
\&    Integer or Int ................................ An integer
\&    Match or QuotelikeM ........................... A /.../ or m/.../
\&    NullaryBuiltinFunction ........................ A call to a built\-in function that takes no arguments
\&    OldQualifiedIdentifier ........................ An identifier optionally qualified with :: or \*(Aq
\&    QuotelikeQ .................................... A single\-quoted string
\&    QuotelikeQQ ................................... A double\-quoted string
\&    QuotelikeQR ................................... A qr/.../
\&    VString ....................................... A v\-string
\&    VariableArray or VarArray or ArrayVar ......... An array variable
\&    VariableHash or VarHash or HashVar ............ A hash variable
\&    VariableScalar or VarScalar or ScalarVar ...... A scalar variable
\&    VersionNumber ................................. A version number allowed after use
\&    ContextualMatch or ContextualQuotelikeM ....... A /.../ or m/.../ where it\*(Aqs valid in Perl
\&    PositiveInteger or PosInt ..................... A non\-negative integer
\&    QualifiedIdentifier or QualIdent .............. An identifier optionally qualified with ::
\&    QuotelikeQR ................................... A qr/.../
\&    VString ....................................... A v\-string
\&    Identifier or Ident ........................... An unqualified identifier
.Ve
.PP
Which Perl construct each of these will match after a keyword is
intended to be self-evident; see the documentation of the \s-1PPR\s0 module
for more detail on any of them that aren't.
.PP
Regex and literal parameter types
.IX Subsection "Regex and literal parameter types"
.PP
In addition to the standard named types listed in the previous section,
a keyword parameter can have its type specified as either a regex or a
string, in which case the corresponding component in the trailing source
code is expected to match that pattern or literal.
.PP
For example:
.PP
.Vb 1
\&    keyword fail (\*(Aqall\*(Aq? $all, /hard|soft/ $fail_mode, Block $code) {...}
.Ve
.PP
would accept:
.PP
.Vb 3
\&    fail hard {...}
\&    fail all soft {...}
\&    # etc.
.Ve
.PP
If a literal or pattern is only parsing a static part of the syntax, there
may not be a need to give it an actual parameter variable. For example:
.PP
.Vb 1
\&    keyword list (/keys|values|pairs/ $what, \*(Aqin\*(Aq, HashVar $hash) {
\&
\&        my $EXTRACTOR = $what eq \*(Aqvalues\*(Aq ? \*(Aqvalues\*(Aq : \*(Aqkeys\*(Aq;
\&        my $REPORTER  = $what eq \*(Aqpairs\*(Aq ? $hash.\*(Aq{$data}\*(Aq : \*(Aq$data\*(Aq;
\&
\&        return qq{for my \e$data ($EXTRACTOR $hash) { say join \*(Aq: \*(Aq,$REPORTER }
\&    }
.Ve
.PP
Here the \f(CW\*(Aqin\*(Aq\fR parameter type just parses a fixed syntactic component of the
keyword, so there's no need to capture it into a parameter variable.
.PP
Note that types specified as regexes can be given any of the following
trailing modifiers: \f(CW\*(C`/imnsxadlup\*(C'\fR. For example:
.PP
.Vb 2
\&    keyword list (/ keys | values | pairs /xiaa $what, \*(Aqin\*(Aq, HashVar $hash) {...}
\&                                           ^^^^
.Ve
.PP
\fINaming literal and regex types via \f(CI\*(C`keytype\*(C'\fI\fR
.IX Subsection "Naming literal and regex types via keytype"
.PP
Literal and regex parameter types are useful for matching non-standard
syntax that \s-1PPR\s0 cannot recognize. However, using a regex or a literal
as a type specifier does tend to muddy a keyword definition with large
amounts of line noise (especially the regexes).
.PP
So the module allows you to declare a named type that matches whatever
a given literal or regex would have matched in the same place...via the
\&\f(CW\*(C`keytype\*(C'\fR keyword.
.PP
For example, instead of explicit regexes and string literals:
.PP
.Vb 1
\&    keyword fail (\*(Aqall\*(Aq? $all, /hard|soft/ $fail_mode, Block $code) {...}
\&
\&    keyword list (/keys|values|pairs/ $what, \*(Aqin\*(Aq, HashVar $hash) {
.Ve
.PP
\&...you could predeclare named types that work the same:
.PP
.Vb 2
\&    keytype All       is  \*(Aqall\*(Aq       ;
\&    keytype FailMode  is  /hard|soft/ ;
\&
\&    keytype ListMode  is  /keys|values|pairs/ ;
\&    keytype In        is  \*(AqIn\*(Aq                ;
.Ve
.PP
and then declare the keywords like so:
.PP
.Vb 1
\&    keyword fail (All? $all, FailMode $fail_mode, Block $code) {...}
\&
\&    keyword list (ListMode $what, In, HashVar $hash) {
.Ve
.PP
A \f(CW\*(C`keytype\*(C'\fR can also be used to rename an existing named type
(including other \f(CW\*(C`keytype\*(C'\fR'd names) more meaningfully.
For example:
.PP
.Vb 4
\&    keytype Name      is  Ident  ;
\&    keytype ParamList is  List   ;
\&    keytype Attr      is  /:\ew+/ ;
\&    keytype Body      is  Block  ;
\&
\&    keyword method (Name $name, ParamList? $params, Attr? @attrs, Body $body)
\&    {...}
.Ve
.PP
When you define a new compile-time keytype from a string or regex,
you can also request the module to create a variable of the same name
with the same content, by prefixing the keytype name with a \f(CW\*(C`$\*(C'\fR
sigil. For example:
.PP
.Vb 2
\&    keytype $ListMode  is  /keys|values|pairs/ ;
\&    keytype $In        is  \*(AqIn\*(Aq                ;
.Ve
.PP
would create two new keytypes (\f(CW\*(C`ListMode\*(C'\fR and \f(CW\*(C`In\*(C'\fR) and also
two new variables (\f(CW$ListMode\fR and \f(CW$In\fR) that contain the
regex adnd string respectively. Note that you would still use
the \fIsigilless\fR forms in the parameter list of a keyword:
.PP
.Vb 3
\&    keyword list (ListMode $what, In, HashVar $hash) {
\&        ...
\&    }
.Ve
.PP
but could then use the sigilled forms in the body of the keyword:
.PP
.Vb 6
\&    keyword list (ListMode $what, In, HashVar $hash) {
\&        if ($hash =~ $Listmode || $hash eq $In) {
\&            warn \*(AqBad name for hash\*(Aq;
\&        }
\&        ...
\&    }
.Ve
.PP
or anywhere else in the same lexical scope as the \f(CW\*(C`keytype\*(C'\fR declaration.
.PP
\fIJunctive named types\fR
.IX Subsection "Junctive named types"
.PP
Sometimes a keyword may need to take two or more different types of arguments
in the same syntactic slot. For example, you might wish to create a keyword
that accepts either a block or an expression as its argument:
.PP
.Vb 1
\&    try { for (1..10) { say foo() } }
\&
\&    try say foo();
.Ve
.PP
\&...or a block or regex:
.PP
.Vb 2
\&    filter { $_ < 10 } @list;
\&    filter /important/ @list;
.Ve
.PP
When specifying the a keyword parameter, you can specify two or more
named types for it, by conjoining them with a vertical bar (\f(CW\*(C`|\*(C'\fR) like so:
.PP
.Vb 3
\&    keyword try (Block|Expression $trial) {{{
\&        eval «$trial =~ /^\e{/ ? $trial : "{$trial}"»
\&    }}}
\&
\&    keyword filter (Regex|Block $selector, ArrayVar $var) {{{
\&        «$var» = grep «$selector» «$var»;
\&    }}}
.Ve
.PP
This is known as a \fIdisjunctive type\fR.
.PP
Disjunctive types can only be constructed from named types (either built-in
or defined by a \f(CW\*(C`keytype\*(C'\fR); they cannot include regex or literal types.
However, this is not an onerous restriction, as it is always possible to
convert a non-named type to a named type using \f(CW\*(C`keytype\*(C'\fR:
.PP
.Vb 2
\&    keytype In   is /(?:with)?in/;
\&    keytype From is \*(Aqfrom\*(Aq;
\&
\&    keyword list (Regex $rx, From|In, Expression $list) {{{
\&        say for grep «$rx» «$list»;
\&    }}}
\&
\&    list /fluffy/ within cats();
\&    list /rex/ from dogs();
.Ve
.SS "Capturing parameter components"
.IX Subsection "Capturing parameter components"
Normally, when a keyword parameter matches part of the source code,
the text of that source code fragment becomes the string value of
the corresponding parameter variable. For example:
.PP
.Vb 2
\&    keytype Mode     is / first | last | any | all /x;
\&    keytype NumBlock is / \ed+ (?&PerlOWS) (?&PerlBlock) /;
\&
\&    keyword choose (Mode $choosemode, NumBlock @numblocks) {...}
\&
\&    # And later...
\&
\&    choose any
\&        1 {x==1}
\&        2 {sqrt 4}
\&        3 {"Many"}
\&
\&    # Parameter $choosemode gets: \*(Aqany\*(Aq
\&    # Parameter @numblocks  gets: ( \*(Aq1 {x==1}\*(Aq, \*(Aq2 {sqrt 4}\*(Aq, \*(Aq3 {"Many"}\*(Aq )
.Ve
.PP
However, if a parameter's type regex includes one or more named captures
(i.e. via the \f(CW\*(C`(?<name> ... )\*(C'\fR syntax), then the corresponding
parameter variable is no longer bound to a simple string.
.PP
Instead, it is bound to a hash-based object of the class
\&\f(CW\*(C`Keyword::Declare::Arg\*(C'\fR.
.PP
This object still stringifies to the original source code fragment,
so the parameter can still be interpolated into a replacement source
code string.
.PP
However, the object can also be treated as a hash...whose keys are the
names of the named captures in the type regex, and whose values are the
substrings those named captures matched.
.PP
In addition, the \f(CW\*(C`Keyword::Declare::Arg\*(C'\fR object always has an extra key
(namely: the empty string), whose value stores the entire original source
code fragment.
.PP
So, for example, if the two parameter types from the previous example,
had included named captures:
.PP
.Vb 1
\&    keytype Mode     is / (?<one> first | last | any ) | (?<many> all ) /x;
\&
\&    keytype NumBlock is / (?<num> \ed+ ) (?&PerlOWS) (?<block> (?&PerlBlock) ) /;
\&
\&    keyword choose (Mode $choosemode, NumBlock @numblocks) {...}
\&
\&    # And later...
\&
\&    choose any
\&        1 {x==1}
\&        2 {sqrt 4}
\&        3 {"Many"}
\&
\&    # $choosemode stringifies to:     \*(Aqany\*(Aq
\&    # $choosemode\->{\*(Aq\*(Aq}     returns:  \*(Aqany\*(Aq
\&    # $choosemode\->{\*(Aqone\*(Aq}  returns:  \*(Aqany\*(Aq
\&    # $choosemode\->{\*(Aqmany\*(Aq} returns:  undef
\&
\&    # $numblocks[0] stringifies to:    \*(Aq1 {x==1}\*(Aq
\&    # $numblocks[0]{\*(Aq\*(Aq}      returns:  \*(Aq1 {x==1}\*(Aq
\&    # $numblocks[0]{\*(Aqnum\*(Aq}   returns:  \*(Aq1\*(Aq
\&    # $numblocks[0]{\*(Aqblock\*(Aq} returns:  \*(Aq{x==1}\*(Aq
\&
\&    # et cetera...
.Ve
.PP
This feature is most often used to define keywords whose arguments
consist of a repeated sequence of components, especially when those
components are either inherently complex (as in the previous example)
or they are unavoidably heterogeneous in nature (as below).
.PP
For example, to declare an \f(CW\*(C`assert\*(C'\fR keyword that can take and test
a series of blocks and/or expressions:
.PP
.Vb 3
\&    keytype BlockOrExpr is / (?<block> (?&PerlBlock) )
\&                           | (?<expr>  (?&PerlExpression)  )
\&                           /x;
\&
\&    keyword assert (BlockOrExpr @test_sequence) {
\&
\&        # Accumulate transformed tests in this variable
\&        my @assertions;
\&
\&        # Build assertion code from sequence of test components
\&        for my $test (@test_sequence) {
\&
\&            # Is the next component a block?
\&            push @assertions, "do $test" if $test\->{block};
\&
\&            # Is the next component a raw expression?
\&            push @assertions, "($test)"  if $test\->{expr};
\&        }
\&
\&        # Generate replacement code...
\&        return "die \*(AqAssertion failed\*(Aq unless "
\&             . join \*(Aq && \*(Aq, @assertions;
\&    }
.Ve
.SS "Scalar vs array keyword parameters"
.IX Subsection "Scalar vs array keyword parameters"
Declaring a keyword's parameter as a scalar (the usual approach) causes
the source code parser to match the corresponding type of component
exactly once in the trailing source. For example:
.PP
.Vb 2
\&    # try takes exactly one trailing block
\&    keyword try (Block $block) {...}
.Ve
.PP
Declaring a keyword's parameter as an array causes the source code
parser to match the corresponding type of component as many times as it
appears (but at least once) in the trailing source, with each matching
occurrence becoming one element of the array.
.PP
.Vb 2
\&    # tryall takes one or more trailing blocks
\&    keyword tryall (Block @blocks) {...}
.Ve
.PP
\fIChanging the number of expected parameter matches\fR
.IX Subsection "Changing the number of expected parameter matches"
.PP
An explicit quantifier can be appended to any parameter type to change the
number of repetitions that parameter type will match.
For example:
.PP
.Vb 2
\&    # The forpair keyword takes an optional iterator variable
\&    keyword forpair ( Var? $itervar, \*(Aq(\*(Aq, HashVar $hash, \*(Aq)\*(Aq, Block $block) {...}
\&
\&    # The checkpoint keyword can be followed by zero or more trailing strings
\&    keyword checkpoint (Str* @identifier) {...}
.Ve
.PP
The available quantifiers are:
.ie n .IP """?""" 4
.el .IP "\f(CW?\fR" 4
.IX Item "?"
to indicate zero-or-one times, as many times as possible, with backtracking
.ie n .IP """*""" 4
.el .IP "\f(CW*\fR" 4
.IX Item "*"
to indicate zero-or-more times, as many times as possible, with backtracking
.ie n .IP """+""" 4
.el .IP "\f(CW+\fR" 4
.IX Item "+"
to explicitly indicate one-or-more times, as many times as possible, with backtracking
(This is also the default quantifier if the parameter variable is declared as an array.)
.ie n .IP """??""" 4
.el .IP "\f(CW??\fR" 4
.IX Item "??"
to indicate zero-or-one times, as \fIfew\fR times as possible, with backtracking
.ie n .IP """*?""" 4
.el .IP "\f(CW*?\fR" 4
.IX Item "*?"
to indicate zero-or-more times, as \fIfew\fR times as possible, with backtracking
.ie n .IP """+?""" 4
.el .IP "\f(CW+?\fR" 4
.IX Item "+?"
to indicate one-or-more times, as \fIfew\fR times as possible, with backtracking
.ie n .IP """?+""" 4
.el .IP "\f(CW?+\fR" 4
.IX Item "?+"
to indicate zero-or-one times, as many times as possible, \fIwithout\fR backtracking
.ie n .IP """*+""" 4
.el .IP "\f(CW*+\fR" 4
.IX Item "*+"
to indicate zero-or-more times, as many times as possible, \fIwithout\fR backtracking
.ie n .IP """++""" 4
.el .IP "\f(CW++\fR" 4
.IX Item "++"
to indicate one-or-more times, as many times as possible, \fIwithout\fR backtracking
.PP
For example:
.PP
.Vb 4
\&    # The watch keyword takes as many statements as possible, and at least one...
\&    keyword watch ( Statement++ @statements) {
\&        return join "\en", map { "say q{$_}; $_;" } @statements;
\&    }
\&
\&    # The begin...end keyword takes as few statements as possible, including none...
\&    keyword begin ( Statement*? $statements, \*(Aqend\*(Aq) {
\&        return "{ $statements }";
\&    }
.Ve
.PP
Note that any repetition quantifier is appended to the parameter's type, \fBnot\fR after
its variable. As the previous example indicates, any quantifier may be applied to
either a scalar or an array parameter: the quantifier tells the type how often to
match; the kind of parameter determines how that match is made available inside
the keyword body: as a single string or object for scalar parameters, or as a list of
individual strings or objects for array parameters.
.PP
Checking whether optional parameters are present
.IX Subsection "Checking whether optional parameters are present"
.PP
If an array parameter has a quantifier that makes it \fIoptional\fR
(e.g. \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`?+\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, etc.), then the parameter array
will be empty (and hence false) whenever the corresponding
syntactic component is missing.
.PP
In the same situation, an optional scalar parameter will contain
an empty string (which is also false, of course).
.PP
However, it is recommended that the presence or absence of optional
scalar parameters should be tested using the built-in \f(CW\*(C`length()\*(C'\fR
function, not just via a boolean test, because in some cases the
parameter could also have an explicit value of \f(CW"0"\fR, which is false,
but not \*(L"missing\*(R".
.PP
For example:
.PP
.Vb 1
\&    keyword save (Int? $count, List $data) {
\&
\&        # If optional count omitted, then $count will contain an empty string
\&        if ( !length($count) ) {
\&            return "save_all($data);";
\&        }
\&        else {
\&            return "save_first($count, $data);";
\&        }
\&    }
.Ve
.PP
If the test had been:
.PP
.Vb 3
\&        if (!$count) {
\&            return "save_all($data);";
\&        }
.Ve
.PP
then a keyword invocation such as:
.PP
.Vb 1
\&    save 0 ($foo, $bar, $baz);
.Ve
.PP
would be translated to a call to \f(CW\*(C`save_all(...)\*(C'\fR,
instead of a call to \f(CW\*(C`save_multiple(0,...)\*(C'\fR.
.PP
\fISeparated repetitions\fR
.IX Subsection "Separated repetitions"
.PP
Parameters can be marked as repeating either by being declared as arrays
or by being declared with a type quantifier such as \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, etc.)
Any repeating parameter may match multiple repetitions of the same
component. For example:
.PP
.Vb 2
\&    # tryall takes zero or more trailing blocks
\&    keyword tryall (Block* @blocks) {...}
.Ve
.PP
\&...will match zero-or-more code blocks after the keyword.
.PP
You can also specify that such parameters should match repeated
components that are explicitly \fBseparated\fR by some other interstitial
syntactic element: such as a comma or a colon or a newline or a special
string like '+' or '&&' or 'then'.
.PP
Such separators are specified by adding a \f(CW\*(C`:sep(...)\*(C'\fR attribute after
the variable name (but before any default value).
.PP
For example, if the \f(CW\*(C`tryall\*(C'\fR blocks should be separated by
commas, you could specify that like so:
.PP
.Vb 3
\&    # tryall takes zero or more trailing comma\-separated blocks
\&    keyword tryall (Block* @blocks :sep(\*(Aq,\*(Aq)) {...}
\&                                 # ^^^^^^^^^
.Ve
.PP
Separators can be specified using any valid parameter type:
string, regex, named type, or junctive. For example:
.PP
.Vb 3
\&    # tryall takes zero or more trailing (fat\-)comma\-separated blocks
\&    keyword tryall (Block* @blocks :sep( /,|=>/ )) {...}
\&                                 #       ^^^^^^
\&
\&    # tryall takes zero or more trailing Comma\-separated blocks
\&    keyword tryall (Block* @blocks :sep( Comma )) {...}
\&                                 #       ^^^^^
\&
\&    # tryall takes zero or more trailing Comma\-or\-colon\-separated blocks
\&    keytype Colon is \*(Aq:\*(Aq;
\&    keyword tryall (Block* @blocks :sep( Comma|Colon )) {...}
\&                                 #       ^^^^^^^^^^^
.Ve
.PP
Accessing separators
.IX Subsection "Accessing separators"
.PP
Whenever an array parameter is specified with a \f(CW\*(C`:sep\*(C'\fR attribute, the
actual separators found between instances of a repeated component can be
retrieved via the Keyword::Declare::Arg objects that are returned in the
array.
.PP
Each such object stores the separator that occurred immediately \fIafter\fR
the corresponding component, and each such trailing separator can be
accessed via the object's special \f(CW\*(Aq:sep\*(Aq\fR key. For example:
.PP
.Vb 6
\&    # tryall takes zero or more trailing Comma\-separated blocks
\&    keyword tryall (Block* @blocks :sep(Comma)) {
\&        warn "Separators are: ",
\&             map { $_\->{\*(Aq:sep\*(Aq} } @blocks;
\&        ...
\&    }
\&
\&    # and later...
\&
\&    tryall {say 1} , {say 2} => {say 3} , {say 4};
\&    # Warns: Separators are: ,=>,
.Ve
.PP
\fIProviding a default for optional parameters\fR
.IX Subsection "Providing a default for optional parameters"
.PP
If a parameter is optional (i.e. it has a <?>, \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`?+\*(C'\fR, <*>, <*?>,
or \f(CW\*(C`*+\*(C'\fR quantifier), you can specify a string to be placed in the
parameter variable in cases where the parameter matches zero times.
.PP
For example to use \f(CW$_\fR as the iterator variable, if no explicit variable
is supplied:
.PP
.Vb 2
\&    # The forpair keyword takes an optional iterator variable (or defaults to $_)
\&    keyword forpair ( Var? $itervar = \*(Aq$_\*(Aq, \*(Aq(\*(Aq, HashVar $hash, \*(Aq)\*(Aq, Block $block) {...}
.Ve
.PP
Another common use for defaults is to force optional arguments to default to an
empty string, rather than to \f(CW\*(C`undef\*(C'\fR, so it's easier to interpolate:
.PP
.Vb 3
\&    keyword display ( Str? $label = \*(Aq\*(Aq, ScalarVar $var) {{{
\&        say \*(Aq«$label»«$var»=\*(Aq, «$var»
\&    }}}
.Ve
.PP
Note that the default value represents an alternative piece of source
code to be generated at compile-time, so it must be specified as an
uninterpolated single-quoted string (either \f(CW\*(Aq...\*(Aq\fR or \f(CW\*(C`q{...}\*(C'\fR).
.PP
Array parameters can also have a default value specified. However, as
for scalar parameters, the default must still be a single single-quoted
string (not a list or array). For example:
.PP
.Vb 2
\&    # The checkpoint keyword defaults to check\-pointing CHECKPOINT...
\&    keyword checkpoint (Str* @identifier = \*(AqCHECKPOINT\*(Aq) {...}
.Ve
.PP
If you provide a default for an unquantified parameter, the module will infer
that you intended the parameter to be optional and will quietly provide a
suitable implicit quantifier (\f(CW\*(C`?\*(C'\fR for scalars, \f(CW\*(C`*\*(C'\fR for arrays). So the
previous examples could also have been written:
.PP
.Vb 2
\&    # The forpair keyword takes an optional iterator variable (or defaults to $_)
\&    keyword forpair ( Var $itervar = \*(Aq$_\*(Aq, \*(Aq(\*(Aq, HashVar $hash, \*(Aq)\*(Aq, Block $block) {...}
\&
\&    # The checkpoint keyword defaults to check\-pointing CHECKPOINT...
\&    keyword checkpoint (Str @identifier = \*(AqCHECKPOINT\*(Aq) {...}
.Ve
.SS "Handling whitespace between arguments"
.IX Subsection "Handling whitespace between arguments"
Normally, a keyword parses and discards any Perl whitespaces (spaces,
tabs, newlines, comments, \s-1POD,\s0 etc.) between its arguments. Each
parameter receives the appropriate matching code component with its
leading whitespace removed (unless, of course, that component itself
explicitly matches whitespace, in which case it's preserved).
.PP
Occasionally, however, leading whitespace may be significant.
For example, you may wish to implement a \f(CW\*(C`note\*(C'\fR keyword that
differentiates between:
.PP
.Vb 1
\&    note (1..3)  \-\-> $filename;
.Ve
.PP
and:
.PP
.Vb 1
\&    note( 1..3 ) \-\-> $filename;
.Ve
.PP
You could achieve that by explicitly matching the optional whitespace before the
opening paranthesis:
.PP
.Vb 4
\&    keyword note (OWS $ws, ParenList $list, /\-\->[^;]*/ $comment) {
\&        return \*(Aqsay \*(Aq
\&             . (length($ws) ? "\*(Aq(\*(Aq, $list, \*(Aq)\*(Aq" : $list);
\&    }
.Ve
.PP
However, this approach can quickly get tedious and unwieldy when
multiple parameters all need to preserve leading whitespace:
.PP
.Vb 6
\&    keyword note (OWS $ws1, ParenList $list, OWS $ws2, /\-\->[^;]*/ $comment)
\&    {
\&        return \*(Aqsay \*(Aq
\&             . (length($ws1) ? "\*(Aq(\*(Aq, $list, \*(Aq)\*(Aq" : $list)
\&             . ("\*(Aq$ws2$comment\*(Aq");
\&    }
.Ve
.PP
So the module provides an attribute, \f(CW\*(C`:keepspace\*(C'\fR, that causes a keyword to
simply keep any leading whitespace at the start of each parameter:
.PP
.Vb 6
\&    keyword note (ParenList $list, /\-\->[^;]*/ $comment) :keepspace {...}
\&    {
\&        return \*(Aqsay \*(Aq
\&             . ($list !~ /^\e(/  ? "\*(Aq(\*(Aq, $list, \*(Aq)\*(Aq" : $list)
\&             . $comment;
\&    }
.Ve
.PP
When using the :keepspace attribute, be aware that the leading whitespace
preserved at the start of each attribute is Perl's concept of whitespace
(which includes comments, \s-1POD,\s0 and possibly even heredoc contents), so if
your keyword later needs to strip it out, then:
.PP
.Vb 1
\&    $list =~ s{ ^ \es* }{}x;
.Ve
.PP
will not suffice. At a minimum, you'll need to cater for comments as
well:
.PP
.Vb 1
\&    $list =~ s{ ^ \es*+ (?: [#].*+\en \es*+)*+ }{}x
.Ve
.PP
and, to be really safe, you need to handle every other Perlish
\&\*(L"whitespace\*(R" as well:
.PP
.Vb 1
\&    $list =~ s{ ^ (?PerlOWS) $PPR::GRAMMAR }{}x;
.Ve
.SS "Keywords with trailing context"
.IX Subsection "Keywords with trailing context"
Sometimes a keyword implementation needs to modify more of the source
code than just its own arguments. For example, a \f(CW\*(C`let\*(C'\fR keyword might
need to install some code after the end of the surrounding block:
.PP
.Vb 6
\&    keyword let (Var $var, \*(Aq=\*(Aq, Expr $value, Statement* $trailing_code, \*(Aq}\*(Aq)
\&    {{{
\&            «trailing_code»
\&        }
\&        «$var» = «$value»;
\&    }}}
.Ve
.PP
But you can't create a keyword like that, because it can't be
successfully parsed as part of a larger Perl code block...because it
\&\*(L"eats\*(R" the right-curly that surrounding block needs to close itself.
.PP
What's needed here is a way to have a keyword operate on trailing
code, but then not consider that trailing code to be part of its
\&\*(L"official\*(R" argument list, so that subsequent parsing doesn't
prematurely consume it.
.PP
The module supports this via the \f(CW\*(C`:then\*(C'\fR attribute. You could, for example,
successfully implement the \f(CW\*(C`let\*(C'\fR keyword like so:
.PP
.Vb 6
\&    keyword let (Var $var, \*(Aq=\*(Aq, Expr $value) :then(Statement* $trailing_code, \*(Aq}\*(Aq)
\&    {{{
\&            «trailing_code»
\&        }
\&        «$var» = «$value»;
\&    }}}
.Ve
.PP
The parentheses of the \f(CW\*(C`:then\*(C'\fR act like a second parameter list, which
must match when the keyword is encountered and expanded within the
source, but which is treated like mere \*(L"lookahead\*(R" when the keyword is
parsed as part of the processing of other keywords.
.PP
The \f(CW\*(C`:then\*(C'\fR attribute must come immediately after the keyword's normal
parameter list (i.e. before any other attribute the keyword might have),
and uses exactly the name parameter specification syntax as the normal
parameter list.
.PP
Moreover, any arguments the \f(CW\*(C`:then\*(C'\fR parameters match are removed from the
source, and must be replaced or amended as part of the new source code
returned by the keyword body. For example: the new source returned by
the body of \f(CW\*(C`let\*(C'\fR starts with reinstating both the trailing code and
the closing curly:
.PP
.Vb 6
\&    keyword let (Var $var, \*(Aq=\*(Aq, Expr $value) :then(Statement* $trailing_code, \*(Aq}\*(Aq)
\&    {{{
\&            «trailing_code»
\&        }
\&        «$var» = «$value»;
\&    }}}
.Ve
.SS "Specifying a keyword description"
.IX Subsection "Specifying a keyword description"
Normally the error messages the module generates refer to the
keyword by name. For example, an error detected in parsing a
\&\f(CW\*(C`repeat\*(C'\fR keyword with:
.PP
.Vb 2
\&    keyword repeat (\*(Aqwhile\*(Aq, List $condition, Block $code)
\&    {...}
.Ve
.PP
might produce the error message:
.PP
.Vb 1
\&    Invalid repeat at demo.pl line 28.
.Ve
.PP
which is a reasonable message, but would be slightly better if it was:
.PP
.Vb 1
\&    Invalid repeat\-while loop at demo.pl line 28.
.Ve
.PP
You can request that a particular keyword be referred to in error
messages using a specific description, by adding the \f(CW\*(C`:desc\*(C'\fR
modifier to the keyword definition. For example:
.PP
.Vb 3
\&    keyword repeat (\*(Aqwhile\*(Aq, List $condition, Block $code)
\&    :desc(repeat\-while loop)
\&    {...}
.Ve
.SS "Simplifying keyword generation with an interpolator"
.IX Subsection "Simplifying keyword generation with an interpolator"
Frequently, the code block that generates the replacement syntax for a
keyword will consist of something like:
.PP
.Vb 4
\&    {
\&        my $code_interpolation = some_expr_involving_a($param);
\&        return qq{ REPLACEMENT $code_interpolation HERE };
\&    }
.Ve
.PP
in which the block does some manipulation of one or more of its
parameters, then interpolates the results into a single string,
which it returns as the replacement source code.
.PP
So the module provides a shortcut for that structure: the \*(L"triple
curly\*(R" block. If a keyword's block is delimited by three contiguous
curly brackets, then the entire block is taken to be a single
uninterpolated string that specifies the replacement source code.
Within that single string anything in \f(CW\*(C`«...»\*(C'\fR is treated as a piece
of code to be executed and its result interpolated at that point in
the replacement code.
.PP
In other words, a triple-curly block is a literal code template, with
special \f(CW\*(C`«...»\*(C'\fR interpolators.
.PP
For example, instead of writing:
.PP
.Vb 10
\&    keyword forall (List $list, \*(Aq\->\*(Aq, Params @params, Block $code_block)
\&    {
\&        $list =~ s{\e)\eZ}{,\e\e\e$_\|_acc_\|_)};
\&        substr $code_block, 1, \-1, q{};
\&        return qq[
\&            {
\&                state \e$_\|_acc_\|_ = [];
\&                foreach my \e$_\|_nary_\|_ $list {
\&                    if (!ref(\e$_\|_nary_\|_) || \e$_\|_nary_\|_ != \e\e\e$_\|_acc_\|_) {
\&                        push \e@{\e$_\|_acc_\|_}, \e$_\|_nary_\|_;
\&                        next if \e@{\e$_\|_acc_\|_} <= $#parameters;
\&                    }
\&                    next if !\e@{\e$_\|_acc_\|_};
\&                    my ( @parameters ) = \e@{\e$_\|_acc_\|_};
\&                    \e@{\e$_\|_acc_\|_} = ();
\&
\&                    $code_block
\&                }
\&            }
\&        ]
\&    }
.Ve
.PP
\&...you could write:
.PP
.Vb 10
\&    keyword forall (List $list, \*(Aq\->\*(Aq, Params @params, Block $code_block)
\&    {{{
\&        {
\&            state $_\|_acc_\|_ = [];
\&            foreach my $_\|_nary_\|_  « $list =~ s{\e)\eZ}{,\e\e\e$_\|_acc_\|_)}r »
\&            {
\&                if (!ref($_\|_nary_\|_) || $_\|_nary_\|_ != \e$_\|_acc_\|_) {
\&                    push @{$_\|_acc_\|_}, $_\|_nary_\|_;
\&                    next if @{$_\|_acc_\|_} <= «$#params»;
\&                }
\&                next if !@{$_\|_acc_\|_};
\&                my ( «"@params"» ) = @{$_\|_acc_\|_};
\&                @{$_\|_acc_\|_} = ();
\&
\&                « substr $code_block, 1, \-1 »
\&            }
\&        }
\&    }}}
.Ve
.PP
\&...with a significant reduction in the number of sigils that have to be
escaped (and hence a significant decrease in the likelihood of bugs
creeping in).
.PP
Note: for those living without the blessings of Unicode, you can also
      use the pure \s-1ASCII\s0 \f(CW\*(C`<{...}>\*(C'\fR to delimit interpolations,
      instead of \f(CW\*(C`«...»\*(C'\fR.
.SS "Declaring multiple variants of a single keyword"
.IX Subsection "Declaring multiple variants of a single keyword"
You can declare two (or more) keywords with the same name, provided they
all have distinct parameter lists. In other words, keyword definitions
are treated as multimethods, with each variant parsing the following
source code and then the variant which matches best being selected to
provide the replacement code.
.PP
For example, you might specify three syntaxes for a \f(CW\*(C`repeat\*(C'\fR loop:
.PP
.Vb 3
\&    keyword repeat (\*(Aqwhile\*(Aq, List $condition, Block $block) {{{
\&        while (1) { do «$block»; last if !(«$condition»); }
\&    }}}
\&
\&    keyword repeat (\*(Aquntil\*(Aq, List $condition, Block $block) {{{
\&        while (1) { do «$block»; last if «$condition»; }
\&    }}}
\&
\&    keyword repeat (Num $count, Block $block) {{{
\&        for (1..«$count») «$block»
\&    }}}
.Ve
.PP
When it encounters a keyword, the module now attempts to (re)parse the
trailing code with each of the definitions of that keyword in the
current lexical scope, collecting every definition that successfuly
parses the source at that point.
.PP
If more than one definition was successful, the module first selects the
definition(s) with the most parameters. If more than one definition had
the maximal number of parameters, the module then selects the one whose
parameters matched most specifically. For example, if you had two keywords:
.PP
.Vb 3
\&    keyword wait (Int $how_long, Str $msg) {{{
\&        { sleep «$how_long»; warn «$msg»; }
\&    }}}
\&
\&    keyword wait (Num $how_long, Str $msg) {{{
\&        { use Time::HiRes \*(Aqsleep\*(Aq; sleep «$how_long»; warn «$msg»; }
\&    }}}
.Ve
.PP
\&...and wrote:
.PP
.Vb 1
\&    wait 1, \*(AqDone\*(Aq;
.Ve
.PP
\&...then the first keyword would be selected over the second,
because \f(CW\*(C`Int\*(C'\fR is more specific than \f(CW\*(C`Num\*(C'\fR and \f(CW\*(C`Str\*(C'\fR is just
as specific as \f(CW\*(C`Str\*(C'\fR.
.PP
If two or more definitions matched equally specifically, the module
looks for one that is marked with a \f(CW\*(C`:prefer\*(C'\fR attribute. If there is no
\&\f(CW\*(C`:prefer\*(C'\fR indicated (or more than one), the module gives up and reports
a syntax ambiguity.
.PP
The order of specificity for a parameter match is determined by the relationships
between the various components of a Perl program, as illustrated in the following
tree (where a child type is more specific that its parent or higher ancestors,
and less specific than its children or deeper descendants):
.PP
.Vb 1
\&    ArrayIndexer
\&
\&    InfixBinaryOperator
\&
\&    StatementModifier
\&
\&    HashIndexer
\&
\&    OWS
\&     \e..NWS or Whitespace
\&       |...Pod
\&        \e..Comment
\&
\&    PostfixUnaryOperator
\&
\&    Attributes
\&
\&    LowPrecedenceInfixOperator
\&
\&    PrefixUnaryOperator
\&
\&    Document
\&     \e..Statement
\&       |...Block
\&       |...PackageDeclaration
\&       |...Label
\&       |...UseStatement
\&       |...Format
\&       |...Expression or Expr
\&       |    \e..LowPrecedenceNotExpression
\&       |       \e..List
\&       |          \e..CommaList
\&       |             \e..Assignment
\&       |                \e..ConditionalExpression or Ternary or ListElem
\&       |                   \e..BinaryExpression
\&       |                      \e..PrefixPostfixTerm
\&       |                         \e..Term
\&       |                           |...AnonymousHash or AnonHash
\&       |                           |...VariableDeclaration or VarDecl
\&       |                           |...Literal
\&       |                           |   |...Number or Num
\&       |                           |   |   |...Integer or Int
\&       |                           |   |   |    \e..PositiveInteger or PosInt
\&       |                           |   |    \e..VersionNumber
\&       |                           |   |       \e..VString
\&       |                           |   |...Bareword
\&       |                           |   |    \e..OldQualifiedIdentifier
\&       |                           |   |       \e..QualifiedIdentifier or QualIdent
\&       |                           |   |          \e..Identifier or Ident
\&       |                           |    \e..String or Str
\&       |                           |      |...VString
\&       |                           |      |...QuotelikeQ
\&       |                           |      |...QuotelikeQQ
\&       |                           |       \e..Heredoc
\&       |                           |...Lvalue
\&       |                           |...AnonymousSubroutine
\&       |                           |...AnonymousArray or AnonArray
\&       |                           |...DoBlock
\&       |                           |...DiamondOperator
\&       |                           |...Variable or Var
\&       |                           |   |...ScalarAccess
\&       |                           |   |    \e..VariableScalar or VarScalar or ScalarVar
\&       |                           |   |...ArrayAccess
\&       |                           |   |    \e..VariableArray or VarArray or ArrayVar
\&       |                           |    \e..HashAccess
\&       |                           |       \e..VariableHash or VarHash or HashVar
\&       |                           |...Typeglob
\&       |                           |...Call
\&       |                           |    \e..BuiltinFunction
\&       |                           |       \e..NullaryBuiltinFunction
\&       |                           |...ParenthesesList or ParensList
\&       |                           |...ReturnStatement
\&       |                           |...EvalBlock
\&       |                            \e..Quotelike
\&       |                              |...Regex or Regexp
\&       |                              |   |...QuotelikeQR
\&       |                              |   |...ContextualRegex
\&       |                              |   |   |...ContextualMatch or ContextualQuotelikeM
\&       |                              |   |    \e..QuotelikeQR
\&       |                              |    \e..Match or QuotelikeM
\&       |                              |       \e..ContextualMatch or ContextualQuotelikeM
\&       |                              |...QuotelikeQW
\&       |                              |...QuotelikeQX
\&       |                              |...Substitution or QuotelikeS
\&       |                              |...Transliteration or QuotelikeTR
\&       |                               \e..String or Str
\&       |                                 |...QuotelikeQQ
\&       |                                  \e..QuotelikeQ
\&       |...SubroutineDeclaration
\&       |...Keyword
\&        \e..ControlBlock
\&
\&    Comma
\&
\&    AssignmentOperator
.Ve
.PP
User-defined named types (declared via the \f(CW\*(C`keytype\*(C'\fR mechanism)
are treated as being more specific than the type they rename.
.PP
Junctive types are treated as being less specific than any one of their
components, and exactly as specific as any other junctive type.
.PP
Regex and string types are treated as being more specific than
any named or junctive type.
.PP
Generally speaking, the mechanism should just do the right thing,
without your having to think about it too much...and will warn you at
compile-time when it can't work out the right thing to do, in which
case you'll need to think about it some more.
.SS "Removing a lexical keyword"
.IX Subsection "Removing a lexical keyword"
The syntax for removing an existing keyword from the remaining lines
in the current scope is:
.PP
.Vb 1
\&    unkeyword NAME;
.Ve
.PP
Any attempts to remove non-existent keywords are silently ignored (in the
same way that removing a non-existing hash key doesn't trigger a warning).
.SS "Exporting keywords"
.IX Subsection "Exporting keywords"
Normally a keyword definition takes effect from the statement after
the \f(CW\*(C`keyword\*(C'\fR declaration, to the end of the enclosing lexical block.
.PP
However, if you declare a keyword inside a subroutine named \f(CW\*(C`import\*(C'\fR
(i.e. inside the import method of a class or module), then the keyword
is also exported to the caller of that import method.
.PP
In other words, simply placing a keyword definition in a module's
\&\f(CW\*(C`import\*(C'\fR exports that keyword to the lexical scope in which the
module is used.
.PP
You can also define new keywords in a module's \f(CW\*(C`unimport\*(C'\fR method,
and they are exported in exactly the same way.
.PP
Likewise, if you place an \f(CW\*(C`unkeyword\*(C'\fR declaration in an \f(CW\*(C`import\*(C'\fR
or \f(CW\*(C`unimport\*(C'\fR subroutine, then the specified keyword is removed from
the lexical scope in which the module is \f(CW\*(C`use\*(C'\fR'd or \f(CW\*(C`no\*(C'\fR'd.
.SS "Debugging keywords"
.IX Subsection "Debugging keywords"
If you load the module with the \f(CW\*(Aqdebug\*(Aq\fR option:
.PP
.Vb 1
\&    use Keyword::Declare {debug=>1};
.Ve
.PP
then keywords and keytypes and unkeywords declared in that lexical scope
will report their own declarations, and will subsequently report how
they transform the source following them. For example:
.PP
.Vb 1
\&    use Keyword::Declare {debug=>1};
\&
\&    keyword list (/keys|values|pairs/ $what, \*(Aqin\*(Aq, HashVar $hash) {
\&        my $EXTRACTOR = $what eq \*(Aqvalues\*(Aq ? \*(Aqvalues\*(Aq : \*(Aqkeys\*(Aq;
\&        my $REPORTER  = $what eq \*(Aqpairs\*(Aq ? $hash.\*(Aq{$data}\*(Aq : \*(Aq$data\*(Aq;
\&
\&        return qq{for my \e$data ($EXTRACTOR $hash) { say join "\e\en", ${REPORTER}_from($hash) }};
\&    }
\&
\&    # And later...
\&
\&    list pairs in %foo;
.Ve
.PP
\&...would print to \s-1STDERR:\s0
.PP
.Vb 10
\&    #####################################################
\&    ### Installed keyword macro at demo.pl line 10:
\&    ###
\&    ###list  <what>  in  <hash>
\&    ###
\&    #####################################################
\&    #####################################################
\&    ### Keyword macro defined at demo.pl line 10:
\&    ###
\&    ###    list  <what>  in  <hash>
\&    ###
\&    ### Converted code at demo.pl line 19:
\&    ###
\&    ###    list  pairs in %foo
\&    ###
\&    ### Into:
\&    ###
\&    ###    for my $data (keys %foo) { say join "\en", keys_from(\e%foo) }
\&    ###
\&    #####################################################
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Invalid option for: use Keyword::Declare""" 4
.el .IP "\f(CWInvalid option for: use Keyword::Declare\fR" 4
.IX Item "Invalid option for: use Keyword::Declare"
Currently the module takes only a simple argument when loaded: a hash
of configuration options. You passed something else to \f(CW\*(C`use Keyword::Declare;\*(C'\fR
.Sp
A common mistake is to load the module with:
.Sp
.Vb 1
\&    use Keyword::Declare  debug=>1;
.Ve
.Sp
instead of:
.Sp
.Vb 1
\&    use Keyword::Declare {debug=>1};
.Ve
.ie n .IP """Can\*(Aqt redefine/undefine \*(Aqkeyword\*(Aq keyword""" 4
.el .IP "\f(CWCan\*(Aqt redefine/undefine \*(Aqkeyword\*(Aq keyword\fR" 4
.IX Item "Cant redefine/undefine keyword keyword"
You attempted to use the \f(CW\*(C`keyword\*(C'\fR keyword to define a new keyword
named \f(CW\*(C`keyword\*(C'\fR. Or you attempted to use the \f(CW\*(C`unkeyword\*(C'\fR keyword
to remove \f(CW\*(C`keyword\*(C'\fR.
.Sp
Isn't your life hard enough without attempting to inject that amount of
meta into it???
.Sp
Future versions of this module may well allow you to overload the
\&\f(CW\*(C`keyword\*(C'\fR keyword, but this version doesn't. You could always use
\&\f(CW\*(C`Keyword\*(C'\fR (with a capital 'K') instead.
.ie n .IP """Can\*(Aqt redefine/undefine \*(Aqkeytype\*(Aq keyword""" 4
.el .IP "\f(CWCan\*(Aqt redefine/undefine \*(Aqkeytype\*(Aq keyword\fR" 4
.IX Item "Cant redefine/undefine keytype keyword"
No, you can't mess with the \f(CW\*(C`keytype\*(C'\fR keyword either.
.ie n .IP """Unknown type (%s) for keyword parameter. Did you mean: %s"",""" 4
.el .IP "\f(CWUnknown type (%s) for keyword parameter. Did you mean: %s"",\fR" 4
.IX Item "Unknown type (%s) for keyword parameter. Did you mean: %s"","
You used a type for a keyword parameter that the module did not
recognize. See earlier in this document for a list of the types that the
module knows. You may also have misspelled a type.
Alternatively, did you declare a \f(CW\*(C`keytype\*(C'\fR but then use it in the
wrong lexical scope?
.ie n .IP """:then attribute specified too late""" 4
.el .IP "\f(CW:then attribute specified too late\fR" 4
.IX Item ":then attribute specified too late"
A \f(CW\*(C`:then\*(C'\fR attribute must be specified immediately after the closing
parenthesis of the keyword's main parameter list, without any other
attributes between the two. You placed the \f(CW\*(C`:then\*(C'\fR attribute after
some other attribute. Move it so that it follows the parameter list
directly.
.ie n .IP """Invalid attribute: %s""" 4
.el .IP "\f(CWInvalid attribute: %s\fR" 4
.IX Item "Invalid attribute: %s"
Keywords may only be specified with four attributes:
\&\f(CW\*(C`:then\*(C'\fR, \f(CW\*(C`:desc\*(C'\fR, \f(CW\*(C`:prefer\*(C'\fR, and \f(CW\*(C`:keepspace\*(C'\fR.
.Sp
You specified some other attribute that the module doesn't know how to
handle (or possibly misspelled one of the valid attribute names).
.ie n .IP """Missing » on interpolation «%s...""" 4
.el .IP "\f(CWMissing » on interpolation «%s...\fR" 4
.IX Item "Missing » on interpolation «%s..."
.PD 0
.ie n .IP """Missing }> on interpolation <{%s...""" 4
.el .IP "\f(CWMissing }> on interpolation <{%s...\fR" 4
.IX Item "Missing }> on interpolation <{%s..."
.PD
You created a \f(CW\*(C`keyword\*(C'\fR definition with a \f(CW\*(C`{{{...}}}\*(C'\fR interpolator,
within which there was an interpolation that extended to the end of the
interpolator without supplying a closing \f(CW\*(C`»\*(C'\fR or \f(CW\*(C`}>\*(C'\fR. Did you
accidentally use just a \f(CW\*(C`>\*(C'\fR or a \f(CW\*(C`}\*(C'\fR instead?
.ie n .IP """Invalid %s at %s. Expected: %s but found: %s""" 4
.el .IP "\f(CWInvalid %s at %s. Expected: %s but found: %s\fR" 4
.IX Item "Invalid %s at %s. Expected: %s but found: %s"
You used a defined keyword, but with the wrong syntax after it.
The error message lists what the valid possibilities were.
.ie n .IP """Ambiguous %s at %s. Could be: %s""" 4
.el .IP "\f(CWAmbiguous %s at %s. Could be: %s\fR" 4
.IX Item "Ambiguous %s at %s. Could be: %s"
You used a keyword, but the syntax after it was ambiguous
(i.e. it matched two or more variants of the keyword equally well).
.Sp
You either need to change the syntax you used (so that it matches only
one variant of the keyword syntax) or else change the definition of one
or more of the keywords (to ensure their syntaxes are no longer ambiguous).
.ie n .IP """Invalid keyword definition. Expected %s but found: %s""" 4
.el .IP "\f(CWInvalid keyword definition. Expected %s but found: %s\fR" 4
.IX Item "Invalid keyword definition. Expected %s but found: %s"
You attempted to define a keyword, but used the wrong syntax.
The parameter specification is the usual suspect, or else a
syntax error in the block.
.ie n .IP """Likely keyword substitution cycle: %s""" 4
.el .IP "\f(CWLikely keyword substitution cycle: %s\fR" 4
.IX Item "Likely keyword substitution cycle: %s"
The module replaced a keyword with some code that contained another
keyword, which the module replaced with some code that contained another
keyword, which the module replaced with...et cetera, et cetera.
.Sp
If the module detects itself rewriting the same section of code many
times, and with the same keyword being recursively expanded more than
once, then it infers that the expansion process is never going to
end...and simply gives up.
.Sp
To avoid this problem, don't create a keyword A that generates code that
includes keyword B, where keyword B generates code that includes keyword
C, where keyword C generates code that includes keyword A.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Keyword::Declare requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
The module is an interface to Perl's pluggable keyword mechanism, which
was introduced in Perl 5.12. Hence it will never work under earlier
versions of Perl.
.PP
Currently requires both the Keyword::Simple module and the \s-1PPR\s0 module.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.PP
But Keyword::Declare probably won't get along well with source filters
or Devel::Declare.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
The module currently relies on Keyword::Simple, so it is subject to all
the limitations of that module. Most significantly, it can only create
keywords that appear at the beginning of a statement (though you can
almost always code around that limitation by wrapping the keyword in
a \f(CW\*(C`do{...}\*(C'\fR block.
.PP
Moreover, there is a issue with Keyword::Simple v0.04 which sometimes
causes that module to fail when used by Keyword::Declare under Perl 5.14
and 5.16. Consequently, Keyword::Declare may be unreliable under Perls
before 5.18 if Keyword::Simple v0.04 or later is installed. The current
workaround is to downgrade to Keyword::Simple v0.03 under those early
Perl versions.
.PP
Even with the \s-1PPR\s0 module, parsing Perl code is tricky, and parsing Perl
code to build Perl code that parses other Perl code is even more so.
Hence, there are likely to be cases where this module gets it
spectacularly wrong.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-keyword\-declare.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2015\-2017, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
