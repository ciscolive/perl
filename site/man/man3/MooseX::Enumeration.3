.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MooseX::Enumeration 3"
.TH MooseX::Enumeration 3 "2019-11-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::Enumeration \- a native attribute trait for enums
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Given this class:
.PP
.Vb 8
\&   package MyApp::Result {
\&      use Moose;
\&      use Types::Standard qw(Enum);
\&      has status => (
\&         is        => "rw",
\&         isa       => Enum[qw/ pass fail /],
\&      );
\&   }
.Ve
.PP
It's quite common to do this kind of thing:
.PP
.Vb 1
\&   if ( $result\->status eq "pass" ) { ... }
.Ve
.PP
But if you're throwing strings around, it can be quite easy to mistype
them:
.PP
.Vb 1
\&   if ( $result\->status eq "apss" ) { ... }
.Ve
.PP
And the comparison silently fails. Instead, let's define the class like
this:
.PP
.Vb 10
\&   package MyApp::Result {
\&      use Moose;
\&      use Types::Standard qw(Enum);
\&      has status => (
\&         traits    => ["Enumeration"],
\&         is        => "rw",
\&         isa       => Enum[qw/ pass fail /],
\&         handles   => [qw/ is_pass is_fail /],
\&      );
\&   }
.Ve
.PP
So you can use the class like this:
.PP
.Vb 1
\&   if ( $result\->is_pass ) { ... }
.Ve
.PP
Yay!
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This attribute trait makes it easier to work with enumerated types in
Moose.
.PP
It will only work on attributes which have an enum type constraint.
This may be a Type::Tiny::Enum or may be a type constraint defined
using Moose's built-in enum types.
.SS "Type Constraint Shortcut"
.IX Subsection "Type Constraint Shortcut"
This trait gives you a shortcut for specifying an enum type constraint:
.PP
.Vb 5
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],   # instead of isa
\&   );
.Ve
.SS "Delegation"
.IX Subsection "Delegation"
.ie n .IP """is""" 4
.el .IP "\f(CWis\fR" 4
.IX Item "is"
The trait also allows you to delegate \*(L"is\*(R" to the attribute value.
.Sp
.Vb 11
\&   # the most longhanded form...
\&   #
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],
\&      handles   => {
\&         is_pass  => ["is", "pass"],
\&         is_fail  => ["is", "fail"],
\&      }
\&   );
.Ve
.Sp
Note that above, we might have called the delegated method
\&\f(CW"did_pass"\fR instead of \f(CW"is_pass"\fR. You can call it what you
like.
.Sp
.Vb 9
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],
\&      handles   => {
\&         did_pass    => ["is", "pass"],
\&         didnt_pass  => ["is", "fail"],
\&      }
\&   );
.Ve
.Sp
To save typing, we offer some shorthands for common patterns.
.Sp
.Vb 9
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],
\&      handles   => {
\&         is_pass  => "is_pass",
\&         is_fail  => "is_fail",
\&      }
\&   );
.Ve
.Sp
In the hashref values, we implicitly split on the first underscore, so
\&\f(CW"is_pass"\fR is equivalent to \f(CW\*(C`["is", "pass"]\*(C'\fR.
.Sp
This is still repetitive, so how about...
.Sp
.Vb 6
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],
\&      handles   => [ "is_pass", "is_fail" ],
\&   );
.Ve
.Sp
If an arrayref of delegates is given, it mapped like this:
.Sp
.Vb 1
\&   my %delegate_hash = map { $_ => $_ } @delegate_array;
.Ve
.Sp
We can still go one better...
.Sp
.Vb 6
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail /],
\&      handles   => 1,
\&   );
.Ve
.Sp
This will create a delegated method for each value in the enumeration.
.Sp
\&\f(CW\*(C`handles => 1\*(C'\fR will create methods like \f(CW\*(C`$object\->is_pass\*(C'\fR while 
\&\f(CW\*(C`handles => 2\*(C'\fR will create methods like \f(CW\*(C`$object\->status_is_pass\*(C'\fR.
.Sp
As a slightly more advanced option, which will only work for the
long-hand version, you may match the value against a regular expression
or any other value that may serve as a right-hand side for a
match::simple match operation:
.Sp
.Vb 10
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "rw",
\&      enum      => [qw/ pass fail skip todo /],
\&      handles   => {
\&         is_pass  => [ "is", qr{^pass$} ],
\&         is_fail  => [ "is", "fail" ],
\&         is_other => [ "is", [qw(skip todo)] ],
\&      }
\&   );
.Ve
.ie n .IP """assign""" 4
.el .IP "\f(CWassign\fR" 4
.IX Item "assign"
The Enumeration trait allows you to delegate to \*(L"assign\*(R":
.Sp
.Vb 10
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "ro",
\&      enum      => [qw/ pass fail unknown /],
\&      handles   => {
\&         "set_status_pass"  => [ "assign", "pass" ],
\&         "set_status_fail"  => [ "assign", "fail" ],
\&         "clear_status"     => [ "assign", "unknown" ],
\&      }
\&   );
\&   
\&   ...;
\&   $obj\->set_status_pass;   # sets the object\*(Aqs status to "pass"
.Ve
.Sp
It is possible to restrict allowed transitions by adding an extra
parameter. In the following example you can only set the status to
\&\*(L"pass\*(R" if the current status is \*(L"unknown\*(R", and you can only set the
status to \*(L"fail\*(R" if the current status begins with \*(L"u\*(R" (effectively
the same thing).
.Sp
.Vb 10
\&   has status => (
\&      traits    => ["Enumeration"],
\&      is        => "ro",
\&      enum      => [qw/ pass fail unknown /],
\&      handles   => {
\&         "set_status_pass"  => [ "assign", "pass", "unknown" ],
\&         "set_status_fail"  => [ "assign", "fail", qr{^u} ],
\&         "clear_status"     => [ "assign", "unknown" ],
\&      }
\&   );
.Ve
.Sp
Calling \f(CW\*(C`set_status_pass\*(C'\fR if the status is already \*(L"pass\*(R" is
conceptually a no-op, so is always allowed.
.Sp
Methods delegated to \f(CW\*(C`assign\*(C'\fR always return \f(CW$self\fR so are
suitable for chaining.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
As of version 0.003, \f(CW\*(C`$obj\->is_pass\*(C'\fR actually benchmarks \fIfaster\fR
than \f(CW\*(C`$obj\->status eq "pass"\*(C'\fR. The latter comparison can be
accelerated using MooseX::XSAccessor but this module can not (yet)
provide an \s-1XS\s0 version for \f(CW\*(C`is_pass\*(C'\fR. :\-(
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=MooseX\-Enumeration>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MooX::Enumeration â€” implementation of this for Moo.
.PP
Moose::Meta::TypeConstraint::Enum,
Type::Tiny::Enum,
Moose::Meta::Attribute::Native.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2014, 2018 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
