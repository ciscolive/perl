.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Validate 3"
.TH Validate 3 "2014-07-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Validate \- common data validation methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Data::Validate qw(:math);
\&  
\&  if(defined(is_integer($suspect))){
\&        print "Looks like an integer\en";
\&  }
\&  
\&  my $name = is_alphanumeric($suspect);
\&  if(defined($name)){
\&        print "$name is alphanumeric, and has been untainted\en";
\&  } else {
\&        print "$suspect was not alphanumeric"
\&  }
\&  
\&  # or as an object
\&  my $v = Data::Validate\->new();
\&  
\&  die "\*(Aqfoo\*(Aq is not an integer" unless defined($v\->is_integer(\*(Aqfoo\*(Aq));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module collects common validation routines to make input validation,
and untainting easier and more readable.  Most of the functions are not much
shorter than their direct perl equivalent (and are much longer in some cases),
but their names make it clear what you're trying to test for.
.PP
Almost all functions return an untainted value if the test passes, and undef if
it fails.  This means that you should always check for a defined status explicitly.
Don't assume the return will be true. (e.g. \fBis_integer\fR\|(0))
.PP
The value to test is always the first (and often only) argument.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.RS 4
\&\fBnew\fR \- constructor for \s-1OO\s0 usage
.Sp
.Vb 1
\&  new();
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns a Data::Validator object.  This lets you access all the validator function
calls as methods without importing them into your namespace or using the clumsy
\&\fBData::Validate::function_name()\fR format.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
None
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns a Data::Validate object
.RE
.RS 4
.Sp
\&\fBis_integer\fR \- is the value an integer?
.Sp
.Vb 1
\&  is_integer($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is an integer, or can be cast to
one without a loss of precision.  (i.e. 1.0 is considered an integer, but 1.0001 is not.)
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential integer to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted integer on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.IP "\fINotes, Exceptions, & Bugs\fR" 4
.IX Item "Notes, Exceptions, & Bugs"
Number translation is done by \s-1POSIX\s0 casting tools (strtol).
.RE
.RS 4
.Sp
\&\fBis_numeric\fR \- is the value numeric?
.Sp
.Vb 1
\&  is_numeric($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is numeric according to
Perl's own internal rules.  (actually a wrapper on Scalar::Util::looks_like_number)
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.IP "\fINotes, Exceptions, & Bugs\fR" 4
.IX Item "Notes, Exceptions, & Bugs"
Number translation is done by \s-1POSIX\s0 casting tools (strtol).
.RE
.RS 4
.Sp
\&\fBis_hex\fR \- is the value a hex number?
.Sp
.Vb 1
\&  is_hex($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is a hex number.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.IP "\fINotes, Exceptions, & Bugs\fR" 4
.IX Item "Notes, Exceptions, & Bugs"
None
.RE
.RS 4
.Sp
\&\fBis_oct\fR \- is the value an octal number?
.Sp
.Vb 1
\&  is_oct($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is a octal number.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.IP "\fINotes, Exceptions, & Bugs\fR" 4
.IX Item "Notes, Exceptions, & Bugs"
None
.RE
.RS 4
.Sp
\&\fBis_between\fR \- is the value between two numbers?
.Sp
.Vb 1
\&  is_between($value, $min, $max);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is numeric, and falls between
\&\f(CW$min\fR and \f(CW$max\fR inclusive.  Note that either \f(CW$min\fR or \f(CW$max\fR can be undef, which 
means 'unlimited'.  i.e. is_between($val, 0, undef) would pass for any number
zero or larger.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.ie n .IP "$min" 4
.el .IP "\f(CW$min\fR" 4
.IX Item "$min"
The minimum valid value.  Unlimited if set to undef
.ie n .IP "$max" 4
.el .IP "\f(CW$max\fR" 4
.IX Item "$max"
The maximum valid value.  Unlimited if set to undef
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.RE
.RS 4
.Sp
\&\fBis_greater_than\fR \- is the value greater than a threshold?
.Sp
.Vb 1
\&  is_greater_than($value, $threshold);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is numeric, and is greater than
\&\f(CW$threshold\fR. (not inclusive)
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.ie n .IP "$threshold" 4
.el .IP "\f(CW$threshold\fR" 4
.IX Item "$threshold"
The minimum value (non-inclusive)
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.RE
.RS 4
.Sp
\&\fBis_less_than\fR \- is the value less than a threshold?
.Sp
.Vb 1
\&  is_less_than($value, $threshold);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted number if the test value is numeric, and is less than
\&\f(CW$threshold\fR. (not inclusive)
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The potential number to test.
.ie n .IP "$threshold" 4
.el .IP "\f(CW$threshold\fR" 4
.IX Item "$threshold"
The maximum value (non-inclusive)
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns the untainted number on success, undef on failure.  Note that the return
can be 0, so always check with \fBdefined()\fR
.RE
.RS 4
.Sp
\&\fBis_equal_to\fR \- do a string/number neutral ==
.Sp
.Vb 1
\&  is_equal_to($value, $target);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the target if \f(CW$value\fR is equal to it.  Does a math comparison if
both \f(CW$value\fR and \f(CW$target\fR are numeric, or a string comparison otherwise. 
Both the \f(CW$value\fR and \f(CW$target\fR must be defined to get a true return.  (i.e.
undef != undef)
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The  value to test.
.ie n .IP "$target" 4
.el .IP "\f(CW$target\fR" 4
.IX Item "$target"
The value to test against
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Unlike most validator routines, this one does not necessarily untaint its return value,
it just returns \f(CW$target\fR.  This has the effect of untainting if the target is a constant or
other clean value.  (i.e. is_equal_to($bar, 'foo')).  Note that the return
can be 0, so always check with \fBdefined()\fR
.RE
.RS 4
.Sp
\&\fBis_even\fR \- is a number even?
.Sp
.Vb 1
\&  is_even($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted \f(CW$value\fR if it's numeric, an integer, and even.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The  value to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns \f(CW$value\fR (untainted). Note that the return can be 0, so always
check with \fBdefined()\fR.
.RE
.RS 4
.Sp
\&\fBis_odd\fR \- is a number odd?
.Sp
.Vb 1
\&  is_odd($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted \f(CW$value\fR if it's numeric, an integer, and odd.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The value to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns \f(CW$value\fR (untainted). Note that the return can be 0, so always
check with \fBdefined()\fR.
.RE
.RS 4
.Sp
\&\fBis_alphanumeric\fR \- does it only contain letters and numbers?
.Sp
.Vb 1
\&  is_alphanumeric($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted \f(CW$value\fR if it is defined and only contains letters (upper
or lower case) and numbers.  Also allows an empty string \- ''.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The value to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns \f(CW$value\fR (untainted). Note that the return can be 0, so always
check with \fBdefined()\fR.
.RE
.RS 4
.Sp
\&\fBis_printable\fR \- does it only contain printable characters?
.Sp
.Vb 1
\&  is_alphanumeric($value);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns the untainted \f(CW$value\fR if it is defined and only contains printable characters
as defined by the composite \s-1POSIX\s0 character class [[:print:][:space:]].  Also allows an empty string \- ''.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The value to test.
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns \f(CW$value\fR (untainted). Note that the return can be 0, so always
check with \fBdefined()\fR.
.RE
.RS 4
.Sp
\&\fBlength_is_between\fR \- is the string length between two limits?
.Sp
.Vb 1
\&  length_is_between($value, $min, $max);
.Ve
.IP "\fIDescription\fR" 4
.IX Item "Description"
Returns \f(CW$value\fR if it is defined and its length
is between \f(CW$min\fR and \f(CW$max\fR inclusive.  Note that this function does not
untaint the value.
.Sp
If either \f(CW$min\fR or \f(CW$max\fR are undefined they are treated as no-limit.
.IP "\fIArguments\fR" 4
.IX Item "Arguments"
.RS 4
.PD 0
.ie n .IP "$value" 4
.el .IP "\f(CW$value\fR" 4
.IX Item "$value"
.PD
The value to test.
.ie n .IP "$min" 4
.el .IP "\f(CW$min\fR" 4
.IX Item "$min"
The minimum length of the string (inclusive).
.ie n .IP "$max" 4
.el .IP "\f(CW$max\fR" 4
.IX Item "$max"
The maximum length of the string (inclusive).
.RE
.RS 4
.RE
.IP "\fIReturns\fR" 4
.IX Item "Returns"
Returns \f(CW$value\fR.  Note that the return can be 0, so always check with
\&\fBdefined()\fR.  The value is not automatically untainted.
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Sonnen <\fIsonnen@richardsonnen.com\fR>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 Richard Sonnen. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 89:" 4
.IX Item "Around line 89:"
You can't have =items (as at line 97) unless the first thing after the =over is an =item
