.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Object::Simple 3"
.TH Object::Simple 3 "2017-01-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Simple \- Simplest class builder, Mojo::Base porting, fast and less memory
.IP "\(bu" 4
\&\fBSimplest class builder\fR. All you learn is only \f(CW\*(C`has\*(C'\fR function!
.IP "\(bu" 4
\&\fBMojo::Base porting\fR. Do you like Mojolicious? If so, this is good choices!
.IP "\(bu" 4
\&\fBFast and less memory\fR. Fast \f(CW\*(C`new\*(C'\fR and accessor method. Memory saving implementation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package SomeClass;
\&  use Object::Simple \-base;
\&  
\&  # Create accessor
\&  has \*(Aqfoo\*(Aq;
\&  
\&  # Create accessor with default value
\&  has foo => 1;
\&  has foo => sub { [] };
\&  has foo => sub { {} };
\&  has foo => sub { OtherClass\->new };
\&  
\&  # Create accessors at once
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq];
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq] => 0;
.Ve
.PP
Create object.
.PP
.Vb 4
\&  # Create a new object
\&  my $obj = SomeClass\->new;
\&  my $obj = SomeClass\->new(foo => 1, bar => 2);
\&  my $obj = SomeClass\->new({foo => 1, bar => 2});
\&  
\&  # Set and get value
\&  my $foo = $obj\->foo;
\&  $obj\->foo(1);
\&  
\&  # Setter can be chained
\&  $obj\->foo(1)\->bar(2);
.Ve
.PP
Inheritance
.PP
.Vb 2
\&  package Foo;
\&  use Object::Simple \-base;
\&  
\&  # Bar inherit Foo
\&  package Bar;
\&  use Object::Simple \*(AqFoo\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Object::Simple is \fBSimplest\fR class builder. All you learn is only \f(CW\*(C`has\*(C'\fR function.
You can learn all features of Object::Simple in \fBan hour\fR. There is nothing difficult.
.PP
Do you like Mojolicious? In fact, Object::Simple is Mojo::Base porting. Mojo::Base is basic class builder in Mojolicious project.
If you like Mojolicious, this is good choice. If you have known Mojo::Base, you learn nothing.
.PP
\&\f(CW\*(C`new\*(C'\fR and accessor method is \fBfast\fR. Implementation is pure perl and plain old hash-base object.
Memory is saved. Extra objects is not created at all. Very light-weight object-oriented module.
.PP
Comparison with Class::Accessor::Fast
.PP
Class::Accessor::Fast is simple, but lack often used features.
\&\f(CW\*(C`new\*(C'\fR method can't receive hash arguments.
Default value can't be specified.
If multiple values is set through the accessor,
its value is converted to array reference without warnings.
.PP
Comparison with Moose
.PP
Moose has very complex syntax and depend on much many modules.
You have to learn many things to do object-oriented programing.
Understanding source code is difficult.
Compile-time is very slow and memory usage is very large.
Execution speed is not fast.
For simple \s-1OO,\s0 Moose is overkill.
Moo is improved in this point.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
.SS "1. Create class and accessor"
.IX Subsection "1. Create class and accessor"
At first, you create class.
.PP
.Vb 2
\&  package SomeClass;
\&  use Object::Simple \-base;
.Ve
.PP
By using \f(CW\*(C`\-base\*(C'\fR option, SomeClass inherit Object::Simple and import \f(CW\*(C`has\*(C'\fR method.
.PP
Object::Simple have \f(CW\*(C`new\*(C'\fR method. \f(CW\*(C`new\*(C'\fR method is constructor.
\&\f(CW\*(C`new\*(C'\fR method can receive hash or hash reference.
.PP
.Vb 3
\&  my $obj = SomeClass\->new;
\&  my $obj = SomeClass\->new(foo => 1, bar => 2);
\&  my $obj = SomeClass\->new({foo => 1, bar => 2});
.Ve
.PP
Create accessor by using \f(CW\*(C`has\*(C'\fR function.
.PP
.Vb 1
\&  has \*(Aqfoo\*(Aq;
.Ve
.PP
If you create accessor, you can set or get value
.PP
.Vb 2
\&  # Set value
\&  $obj\->foo(1);
\&  
\&  # Get value
\&  my $foo = $obj\->foo;
.Ve
.PP
Setter can be chained.
.PP
.Vb 1
\&  $obj\->foo(1)\->bar(2);
.Ve
.PP
You can define default value.
.PP
.Vb 1
\&  has foo => 1;
.Ve
.PP
If \f(CW\*(C`foo\*(C'\fR value is not exists, default value is used.
.PP
.Vb 1
\&  my $foo_default = $obj\->foo;
.Ve
.PP
If you want to use reference or object as default value,
default value must be surrounded by code reference.
the return value become default value.
.PP
.Vb 3
\&  has foo => sub { [] };
\&  has foo => sub { {} };
\&  has foo => sub { SomeClass\->new };
.Ve
.PP
You can create multiple accessors at once.
.PP
.Vb 2
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq];
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq] => 0;
.Ve
.SS "2. Override method"
.IX Subsection "2. Override method"
Method can be overridden.
.PP
\&\fBExample:\fR
.PP
Initialize the object
.PP
.Vb 2
\&  sub new {
\&    my $self = shift\->SUPER::new(@_);
\&    
\&    # Initialization
\&    
\&    return $self;
\&  }
.Ve
.PP
\&\fBExample:\fR
.PP
Change arguments of \f(CW\*(C`new\*(C'\fR.
.PP
.Vb 2
\&  sub new {
\&    my $self = shift;
\&    
\&    $self\->SUPER::new(x => $_[0], y => $_[1]);
\&    
\&    return $self;
\&  }
.Ve
.PP
You can pass array to \f(CW\*(C`new\*(C'\fR method.
.PP
.Vb 1
\&  my $point = Point\->new(4, 5);
.Ve
.SS "3. Examples \- class, accessor, inheritance and method overriding"
.IX Subsection "3. Examples - class, accessor, inheritance and method overriding"
I introduce Object::Simple example.
.PP
Point class: two accessor \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR,
and \f(CW\*(C`clear\*(C'\fR method to set \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR to 0.
.PP
.Vb 2
\&  package Point;
\&  use Object::Simple \-base;
\&
\&  has x => 0;
\&  has y => 0;
\&  
\&  sub clear {
\&    my $self = shift;
\&    
\&    $self\->x(0);
\&    $self\->y(0);
\&  }
.Ve
.PP
Use Point class.
.PP
.Vb 5
\&  use Point;
\&  my $point = Point\->new(x => 3, y => 5);
\&  print $point\->x;
\&  $point\->y(9);
\&  $point\->clear;
.Ve
.PP
Point3D class: Point3D inherit Point class.
Point3D class has \f(CW\*(C`z\*(C'\fR accessor in addition to \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`y\*(C'\fR.
\&\f(CW\*(C`clear\*(C'\fR method is overridden to clear \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`y\*(C'\fR and \f(CW\*(C`z\*(C'\fR.
.PP
.Vb 2
\&  package Point3D;
\&  use Object::Simple \*(AqPoint\*(Aq;
\&  
\&  has z => 0;
\&  
\&  sub clear {
\&    my $self = shift;
\&    
\&    $self\->SUPER::clear;
\&    
\&    $self\->z(0);
\&  }
.Ve
.PP
Use Point3D class.
.PP
.Vb 5
\&  use Point3D;
\&  my $point = Point\->new(x => 3, y => 5, z => 8);
\&  print $point\->z;
\&  $point\->z(9);
\&  $point\->clear;
.Ve
.SH "WHAT IS OBJECT-ORIENTED PROGRAMING?"
.IX Header "WHAT IS OBJECT-ORIENTED PROGRAMING?"
I introduce essence of Object-Oriented programing.
.SS "1. Inheritance"
.IX Subsection "1. Inheritance"
First concept is inheritance.
Inheritance means that
if Class Q inherit Class P, Class Q call all methods of class P.
.PP
.Vb 7
\&  +\-\-\-+
\&  | P | Base class
\&  +\-\-\-+   have method1 and method2
\&    |
\&  +\-\-\-+
\&  | Q | Sub class
\&  +\-\-\-+   have method3
.Ve
.PP
Class Q inherits Class P,
Q can call all methods of P in addition to methods of Q.
.PP
In other words, Q can call
\&\f(CW\*(C`method1\*(C'\fR, \f(CW\*(C`method2\*(C'\fR, and \f(CW\*(C`method3\*(C'\fR
.PP
You can inherit other class by the following way.
.PP
.Vb 3
\&  # P.pm
\&  package P;
\&  use Object::Simple \-base;
\&  
\&  sub method1 { ... }
\&  sub method2 { ... }
\&  
\&  # Q.pm
\&  package Q;
\&  use Object::Simple \*(AqP\*(Aq;
\&  
\&  sub method3 { ... }
.Ve
.PP
Perl have useful functions and methods to help Object-Oriented programing.
.PP
If you know what class the object is belonged to, use \f(CW\*(C`ref\*(C'\fR function.
.PP
.Vb 1
\&  my $class = ref $obj;
.Ve
.PP
If you know what class the object inherits, use \f(CW\*(C`isa\*(C'\fR method.
.PP
.Vb 1
\&  $obj\->isa(\*(AqSomeClass\*(Aq);
.Ve
.PP
If you know what method the object(or class) can use, use \f(CW\*(C`can\*(C'\fR method
.PP
.Vb 2
\&  SomeClass\->can(\*(Aqmethod1\*(Aq);
\&  $obj\->can(\*(Aqmethod1\*(Aq);
.Ve
.SS "2. Encapsulation"
.IX Subsection "2. Encapsulation"
Second concept is encapsulation.
Encapsulation means that
you don't touch internal data directory.
You must use public method when you access internal data.
.PP
Create accessor and use it to keep this rule.
.PP
.Vb 2
\&  my $value = $obj\->foo;
\&  $obj\->foo(1);
.Ve
.SS "3. Polymorphism"
.IX Subsection "3. Polymorphism"
Third concept is polymorphism.
Polymorphism is divided into two concepts,
overload and override
.PP
Perl programmer don't need to care overload.
Perl is dynamic type language.
Subroutine can receive any value.
.PP
Override means that you can change method behavior in sub class.
.PP
.Vb 3
\&  # P.pm
\&  package P;
\&  use Object::Simple \-base;
\&  
\&  sub method1 { return 1 }
\&  
\&  # Q.pm
\&  package Q;
\&  use Object::Simple \*(AqP\*(Aq;
\&  
\&  sub method1 { return 2 }
.Ve
.PP
P \f(CW\*(C`method1\*(C'\fR return 1. Q \f(CW\*(C`method1\*(C'\fR return 2.
Q \f(CW\*(C`method1\*(C'\fR override P \f(CW\*(C`method1\*(C'\fR.
.PP
.Vb 3
\&  # P method1 return 1
\&  my $obj_a = P\->new;
\&  $obj_p\->method1; 
\&  
\&  # Q method1 return 2
\&  my $obj_b = Q\->new;
\&  $obj_q\->method1;
.Ve
.PP
If you want to call super class method from sub class,
use \s-1SUPER\s0 pseudo-class.
.PP
.Vb 2
\&  package Q;
\&  use Object::Simple \*(AqP\*(Aq;
\&  
\&  sub method1 {
\&    my $self = shift;
\&    
\&    # Call supper class P method1
\&    my $value = $self\->SUPER::method1;
\&    
\&    return 2 + $value;
\&  }
.Ve
.PP
If you understand three concepts,
you have learned Object-Oriented programming primary parts.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "has"
.IX Subsection "has"
Create accessor.
.PP
.Vb 4
\&  has \*(Aqfoo\*(Aq;
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq];
\&  has foo => 1;
\&  has foo => sub { {} };
\&
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq];
\&  has [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq] => 0;
.Ve
.PP
\&\f(CW\*(C`has\*(C'\fR function receive
accessor name and default value.
Default value is optional.
If you want to create multiple accessors at once,
specify accessor names as array reference at first argument.
.PP
If you want to specify reference or object as default value,
it must be code reference
not to share the value with other objects.
.PP
Get and set a value.
.PP
.Vb 2
\&  my $foo = $obj\->foo;
\&  $obj\->foo(1);
.Ve
.PP
If a default value is specified and the value is not exists,
you can get default value.
.PP
Setter return invocant. so you can do chained call.
.PP
.Vb 1
\&  $obj\->foo(1)\->bar(2);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 3
\&  my $obj = Object::Simple\->new;
\&  my $obj = Object::Simple\->new(foo => 1, bar => 2);
\&  my $obj = Object::Simple\->new({foo => 1, bar => 2});
.Ve
.PP
Create a new object. \f(CW\*(C`new\*(C'\fR receive
hash or hash reference as arguments.
.SS "attr"
.IX Subsection "attr"
.Vb 4
\&  _\|_PACKAGE_\|_\->attr(\*(Aqfoo\*(Aq);
\&  _\|_PACKAGE_\|_\->attr([\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq]);
\&  _\|_PACKAGE_\|_\->attr(foo => 1);
\&  _\|_PACKAGE_\|_\->attr(foo => sub { {} });
\&
\&  _\|_PACKAGE_\|_\->attr([\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq]);
\&  _\|_PACKAGE_\|_\->attr([\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq] => 0);
.Ve
.PP
Create accessor.
\&\f(CW\*(C`attr\*(C'\fR method usage is equal to \f(CW\*(C`has\*(C'\fR function.
.SH "OPTIONS"
.IX Header "OPTIONS"
.SS "\-base"
.IX Subsection "-base"
By using \f(CW\*(C`\-base\*(C'\fR option, the class inherit Object::Simple
and import \f(CW\*(C`has\*(C'\fR function.
.PP
.Vb 2
\&  package Foo;
\&  use Object::Simple \-base;
\&  
\&  has x => 1;
\&  has y => 2;
.Ve
.PP
strict and warnings is automatically enabled.
.PP
If you want to inherit class, let's write the following way.
.PP
.Vb 3
\&  # Bar inherit Foo
\&  package Bar;
\&  use Object::Simple \*(AqFoo\*(Aq;
.Ve
.PP
You can also use the following syntax. This is Object::Simple only.
.PP
.Vb 3
\&  # Same as above
\&  package Bar;
\&  use Object::Simple \-base => \*(AqFoo\*(Aq;
.Ve
.PP
You can also use \f(CW\*(C`\-base\*(C'\fR option in sub class
to inherit other class. This is Object::Simple only.
.PP
.Vb 3
\&  # Same as above
\&  package Bar;
\&  use Foo \-base;
.Ve
.SH "FAQ"
.IX Header "FAQ"
.SS "Really enough object-oriented programing with this few features?"
.IX Subsection "Really enough object-oriented programing with this few features?"
Yes, for example, Mojolicious is very big project, but in fact, source code is clean only using single inheritance.
Generally speaking, readable source code is build on simple concepts, not complex features.
.PP
\&\f(CW\*(C`BUILD\*(C'\fR, \f(CW\*(C`BUILDARGS\*(C'\fR and \f(CW\*(C`DEMOLISH\*(C'\fR methods in Moo are needed for good object-oriented programming?
If you want to use multiple inheritance or role, these methods is needed.
.PP
But I strongly recommend you use only single inheritance in object-oriented programming. Single inheritance is clean and readable.
.PP
If you use only single inheritance,
You can create custom constructor and call constructors in correct order.
and You can create custom destructor and call destructors in correct order,
.PP
Creating custom constructor is very very easy. There is nothing difficult.
.PP
.Vb 4
\&  # Custom constructor
\&  sub new {
\&    # At first Call super class constructor. Next do what you want
\&    my $self = shift\->SUPER::new(@_);
\&    
\&    # What you want
\&    
\&    return $self;
\&  }
\&  
\&  # Custom destructor
\&  sub DESTROY {
\&    my $self = shift;
\&    
\&    # What you want
\&
\&    # At first, do what you want, Next call super class destructor
\&    $selft\->SUPER::DESTROY;
\&    
\&    return $self;
\&  }
.Ve
.SS "Object::Simple is fastest \s-1OO\s0 module?"
.IX Subsection "Object::Simple is fastest OO module?"
No, Object::Simple is \fBnot\fR fastest module, but enough fast. If you really need performance, you can access hash value directory.
.PP
.Vb 3
\&  # I want performance in some places. Let\*(Aqs access hash value directory!
\&  # Object::Simple is plain old hash\-based object
\&  $self\->{x};
.Ve
.SS "What is benefits comparing with Mojo::Base?"
.IX Subsection "What is benefits comparing with Mojo::Base?"
.IP "\(bu" 4
Support Perl 5.8
.IP "\(bu" 4
Installation is very fast because there are a few files.
.IP "\(bu" 4
Some people think that my module want not to depend on whole Mojolicious to use Mojo::Base only. Object::Simple satisfy the demand.
.SS "Why Object::Simple is different from Mojo::Base in some points?"
.IX Subsection "Why Object::Simple is different from Mojo::Base in some points?"
In old days, Object::Simple wasn't Mojo::Base porting. I tried different things.
.PP
Now, I want Object::Simple to be same as Mojo::Base completely except supporting Perl 5.8.
.SH "BACKWARDS COMPATIBILITY POLICY"
.IX Header "BACKWARDS COMPATIBILITY POLICY"
If a functionality is \s-1DEPRECATED,\s0 you can know it by \s-1DEPRECATED\s0 warnings.
You can check all \s-1DEPRECATED\s0 functionalities by document.
\&\s-1DEPRECATED\s0 functionality is removed after five years,
but if at least one person use the functionality and tell me that thing
I extend one year each time he tell me it.
.PP
\&\s-1EXPERIMENTAL\s0 functionality will be changed without warnings.
.PP
(This policy was changed at 2011/10/22)
.SH "DEPRECATED"
.IX Header "DEPRECATED"
.Vb 1
\&  function exporting of C<new> and C<attr> method # Will be removed 2021/6/1
\&  
\&  The syntax of multiple key\-value arguments 
\&    has x => 1, y => 2;      
\&    _\|_PACAKGE_\|_\->attr(x => 1, y => 2);
\&  # Will be removed 2021/6/1
.Ve
.SH "BUGS"
.IX Header "BUGS"
Tell me the bugs
by mail(\f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR) or github <http://github.com/yuki\-kimoto/Object\-Simple>
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have any questions the documentation might not yet answer, don't hesitate to ask on the mailing list or the official \s-1IRC\s0 channel
#object\-simple on irc.perl.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto(\f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR)
.PP
I'm pleasure if you send message for cheer. I can get power by only your messages!
.SH "USERS"
.IX Header "USERS"
Projects using Object::Simple.
.IP "\(bu" 4
GitPrep \- Portable GitHub system into your own server. <https://github.com/yuki\-kimoto/gitprep>
.IP "\(bu" 4
DBIx::Custom \- \s-1DBI\s0 extension to execute insert, update, delete, and select easily
.IP "\(bu" 4
Validator::Custom \- \s-1HTML\s0 form Validation, simple and good flexibility
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1CPAN\s0 have various class builders. Let's compare it with Object::Simple.
.PP
Mojo::Base, Class::Accessor, Class::Accessor::Fast, Moose, Moo, Class::Tiny.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008\-2017 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Artistic v2.
.PP
This is same as Mojolicious licence.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 664:" 4
.IX Item "Around line 664:"
You forgot a '=back' before '=head2'
.IP "Around line 670:" 4
.IX Item "Around line 670:"
=back without =over
