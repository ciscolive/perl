.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Selenium::Remote::Mock::RemoteConnection 3"
.TH Selenium::Remote::Mock::RemoteConnection 3 "2020-10-19" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Selenium::Remote::Mock::RemoteConnection \- utility class to mock the responses from Selenium server
.SH "VERSION"
.IX Header "VERSION"
version 1.38
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Record interactions"
.IX Subsection "Record interactions"
.Vb 4
\&    use strict;
\&    use warnings;
\&    use Selenium::Remote::Driver;
\&    use Selenium::Remote::Mock::RemoteConnection;
\&
\&    # create a new Mock object to record the interactions with Selenium
\&    # Server
\&    my $mock_connection = Selenium::Remote::Mock::RemoteConnection\->new( record => 1 );
\&
\&    # the Mock object is passed to the driver in place of what would be
\&    # a regular Selenium::Remote::RemoteConnection object
\&    my $driver = Selenium::Remote::Driver\->new( remote_conn => $mock_connection );
\&
\&    # always store the session id, as it will become undef once
\&    # $driver\->quit is called
\&    my $session_id = $driver\->session_id;
\&
\&    # do all the selenium things and quit
\&    $driver\->get(\*(Aqhttp://www.google.com\*(Aq);
\&    $driver\->get(\*(Aqhttp://www.wikipedia.com\*(Aq);
\&    $driver\->quit;
\&
\&    # dump the session to a file
\&    $mock_connection\->dump_session_store( \*(Aqmy_record.json\*(Aq );
.Ve
.PP
This code, above doing some basic Selenium interactions, will end up generating a \s-1JSON\s0 file containing all the requests and their responses for your Selenium session.
The \s-1JSON\s0 file looks like this :
.PP
.Vb 4
\&    \*(Aq{
\&        "HTTP_REQUEST_URL {request_parameters}":[response1,response2,...],
\&        ...
\&    }\*(Aq
.Ve
.PP
The reason why we store array of responses is that the exact same request can be made more than once during a session, so we have to store every response to the same requests.
.SS "Replay interactions"
.IX Subsection "Replay interactions"
.Vb 10
\&    #!perl
\&    use strict;
\&    use warnings;
\&    use Test::More;
\&    use Test::Selenium::Remote::Driver;
\&    use Selenium::Remote::Mock::RemoteConnection;
\&    my $mock_connection_2 =
\&      Selenium::Remote::Mock::RemoteConnection\->new( replay => 1,
\&        replay_file => \*(Aqmy_record.json\*(Aq );
\&    # javascript + version parameters added or else it will not work
\&    my $driver =
\&      Test::Selenium::Remote::Driver\->new( remote_conn => $mock_connection_2, javascript => 1, version => \*(Aq\*(Aq );
\&    $driver\->get_ok(\*(Aqhttp://www.google.com\*(Aq);
\&    $driver\->get_ok(\*(Aqhttp://www.wikipedia.com\*(Aq);
\&    $driver\->quit;
\&    done_testing;
.Ve
.PP
Using the file generated with the recording snippet from the section before, we are able to mock the responses.
.PP
Note that there is one small limitation (that I hope to remove in future versions), is that a record generated with Selenium::Remote::Driver is not directly useable with Test::Selenium::Remote::Driver.
This is mainly because the way the two instances are created are a bit different, which leads to different requests made, for creating a session for instance.
For now, what works for sure is recording and replaying from the same class.
.SS "Mock responses"
.IX Subsection "Mock responses"
.Vb 6
\&    #!perl
\&    use Test::More;
\&    use Test::Selenium::Remote::Driver;
\&    use Selenium::Remote::WebElement;
\&    use Selenium::Remote::Mock::Commands;
\&    use Selenium::Remote::Mock::RemoteConnection;
\&
\&    my $spec = {
\&        findElement => sub {
\&            my (undef,$searched_item) = @_;
\&            return { status => \*(AqOK\*(Aq, return => { ELEMENT => \*(Aq123456\*(Aq } }
\&              if ( $searched_item\->{value} eq \*(Aqq\*(Aq );
\&            return { status => \*(AqNOK\*(Aq, return => 0, error => \*(Aqelement not found\*(Aq };
\&        },
\&        getPageSource => sub { return \*(Aqthis output matches regex\*(Aq},
\&    };
\&    my $mock_commands = Selenium::Remote::Mock::Commands\->new;
\&
\&    my $successful_driver =
\&      Test::Selenium::Remote::Driver\->new(
\&        remote_conn => Selenium::Remote::Mock::RemoteConnection\->new( spec => $spec, mock_cmds => $mock_commands ),
\&        commands => $mock_commands,
\&    );
\&    $successful_driver\->find_element_ok(\*(Aqq\*(Aq,\*(Aqfind_element_ok works\*(Aq);
\&    dies_ok { $successful_driver\->find_element_ok(\*(Aqnotq\*(Aq) } \*(Aqfind_element_ok dies if element not found\*(Aq;
\&    $successful_driver\->find_no_element_ok(\*(Aqnotq\*(Aq,\*(Aqfind_no_element_ok works\*(Aq);
\&    $successful_driver\->content_like( qr/matches/, \*(Aqcontent_like works\*(Aq);
\&    $successful_driver\->content_unlike( qr/nomatch/, \*(Aqcontent_unlike works\*(Aq);
\&
\&    done_testing();
.Ve
.PP
Mocking responses by hand requires a more advanced knowledge of the underlying implementation of Selenium::Remote::Driver.
What we mock here is the processed response that will be returned by Selenium::Remote::RemoteConnection to '_execute_command' call.
To accomplish this we need :
.IP "\(bu" 4
a spec: a \s-1HASHREF\s0 which keys are the name of the methods we want to mock. Note that those keys should also be valid keys from the _cmds attribute in Selenium::Remote::Commands.
The value of each key is a sub which will be given two parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW$url_params\fR : the values that should have been replaced in the \s-1URL\s0
For instance, on the example above, it would have been:
    { session_id => 'some_session_id'}
.IP "\(bu" 4
\&\f(CW$params\fR : the original parameters of the request.
On the example above it would have been:
    { value => 'q', using => 'xpath'}
.RE
.RS 4
.Sp
The sub used as a value in the spec is not expected to return anything, so you have to craft very carefully what you return so that it will produce the expected result.
.RE
.IP "\(bu" 4
a mock_cmd: a Selenium::Remote::Mock::Commands object. This is used mainly to hijack the normal commands so that placeholders do not get replaced in the URLs.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Selenium::Remote::Mock::RemoteConnection is a class to act as a short-circuit or a pass through to the connection to a Selenium Server.
Using this class in place of Selenium::Remote::RemoteConnection allows to:
.IP "\(bu" 4
record interactions with the Selenium Server into a \s-1JSON\s0 file
.IP "\(bu" 4
replay recorded interactions from a \s-1JSON\s0 file to mock answers from the Selenium Server
.IP "\(bu" 4
mock responses to specific functions
.SH "BUGS"
.IX Header "BUGS"
This code is really early alpha, so its \s-1API\s0 might change. Use with caution !
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see those modules/websites for more information related to this module.
.IP "\(bu" 4
Selenium::Remote::Driver
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://github.com/teodesian/Selenium\-Remote\-Driver/issues>
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHORS"
.IX Header "AUTHORS"
Current Maintainers:
.IP "\(bu" 4
Daniel Gempesaw <gempesaw@gmail.com>
.IP "\(bu" 4
Emmanuel Peroumalna√Øk <peroumalnaik.emmanuel@gmail.com>
.PP
Previous maintainers:
.IP "\(bu" 4
Luke Closs <cpan@5thplane.com>
.IP "\(bu" 4
Mark Stosberg <mark@stosberg.com>
.PP
Original authors:
.IP "\(bu" 4
Aditya Ivaturi <ivaturi@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2010\-2011 Aditya Ivaturi, Gordon Child
.PP
Copyright (c) 2014\-2017 Daniel Gempesaw
.PP
Licensed under the Apache License, Version 2.0 (the \*(L"License\*(R");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
.PP
http://www.apache.org/licenses/LICENSE\-2.0
.PP
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \*(L"\s-1AS IS\*(R" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\s0 either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
