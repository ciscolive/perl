.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "exact 3"
.TH exact 3 "2020-07-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
exact \- Perl pseudo pragma to enable strict, warnings, features, mro, filehandle methods
.SH "VERSION"
.IX Header "VERSION"
version 1.13
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Instead of this:
.PP
.Vb 12
\&    use strict;
\&    use warnings;
\&    use utf8;
\&    use open \*(Aq:std\*(Aq, \*(Aq:utf8\*(Aq;
\&    use feature \*(Aq:5.23\*(Aq;
\&    use feature qw( signatures refaliasing bitwise );
\&    use mro \*(Aqc3\*(Aq;
\&    use IO::File;
\&    use IO::Handle;
\&    use namespace::autoclean;
\&    use Carp qw( croak carp confess cluck );
\&    use Try::Tiny;
\&
\&    no warnings "experimental::signatures";
\&    no warnings "experimental::refaliasing";
\&    no warnings "experimental::bitwise";
.Ve
.PP
Type this:
.PP
.Vb 1
\&    use exact;
.Ve
.PP
Or for finer control, add some trailing modifiers like a line of the following:
.PP
.Vb 3
\&    use exact \-noexperiments, \-fc, \-signatures;
\&    use exact 5.16, \-nostrict, \-nowarnings, \-noc3, \-noutf8, \-noautoclean;
\&    use exact \*(Aq5.20\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
exact is a Perl pseudo pragma to enable strict, warnings, features, mro,
and filehandle methods along with a lot of other things, plus allow for easy
extension via \f(CW\*(C`exact::*\*(C'\fR classes. The goal is to reduce header boilerplate,
assuming defaults that seem to make sense but allowing overrides easily.
.PP
By default, exact will:
.IP "\(bu" 4
enable strictures (version 2)
.IP "\(bu" 4
load the latest feature bundle supported by the current Perl version
.IP "\(bu" 4
load all experimental features and switch off experimental warnings
.IP "\(bu" 4
set C3 style of mro
.IP "\(bu" 4
use utf8 in the source code context and set \s-1STDIN, STROUT,\s0 and \s-1STRERR\s0 to handle \s-1UTF8\s0
.IP "\(bu" 4
enable methods on filehandles
.IP "\(bu" 4
import Carp's 4 methods
.IP "\(bu" 4
import Try::Tiny (kinda)
.SH "IMPORT FLAGS"
.IX Header "IMPORT FLAGS"
exact supports the following import flags:
.ie n .SS """nostrict"""
.el .SS "\f(CWnostrict\fP"
.IX Subsection "nostrict"
This skips turning on the strict pragma.
.ie n .SS """nowarnings"""
.el .SS "\f(CWnowarnings\fP"
.IX Subsection "nowarnings"
This skips turning on the warnings pragma.
.ie n .SS """noutf8"""
.el .SS "\f(CWnoutf8\fP"
.IX Subsection "noutf8"
This skips turning on \s-1UTF8\s0 in the source code context. Also skips setting
\&\s-1STDIN, STDOUT,\s0 and \s-1STDERR\s0 to expect \s-1UTF8.\s0
.ie n .SS """noc3"""
.el .SS "\f(CWnoc3\fP"
.IX Subsection "noc3"
This skips setting C3 mro.
.ie n .SS """nobundle"""
.el .SS "\f(CWnobundle\fP"
.IX Subsection "nobundle"
Normally, exact will look at your current version and find the highest
supported feature bundle and enable it. Applying \f(CW\*(C`nobundle\*(C'\fR causes this
behavior to be skipped. You can still explicitly set bundles yourself.
.ie n .SS """noexperiments"""
.el .SS "\f(CWnoexperiments\fP"
.IX Subsection "noexperiments"
This skips enabling all features currently labled experimental by feature.
.ie n .SS """noskipexperimentalwarnings"""
.el .SS "\f(CWnoskipexperimentalwarnings\fP"
.IX Subsection "noskipexperimentalwarnings"
Normally, exact will disable experimental warnings. This skips that
disabling step.
.ie n .SS """noautoclean"""
.el .SS "\f(CWnoautoclean\fP"
.IX Subsection "noautoclean"
This skips using namespace::autoclean.
.ie n .SS """nocarp"""
.el .SS "\f(CWnocarp\fP"
.IX Subsection "nocarp"
This skips importing the 4 Carp methods: \f(CW\*(C`croak\*(C'\fR, \f(CW\*(C`carp\*(C'\fR, \f(CW\*(C`confess\*(C'\fR,
\&\f(CW\*(C`cluck\*(C'\fR.
.ie n .SS """notry"""
.el .SS "\f(CWnotry\fP"
.IX Subsection "notry"
This skips importing the functionality of Try::Tiny.
.SH "BUNDLES"
.IX Header "BUNDLES"
You can always provide a list of explicit features and bundles from feature.
If provided, these will be enabled regardless of the other import flags set.
.PP
.Vb 1
\&    use exact \-noexperiments, \-fc, \-signatures;
.Ve
.PP
Bundles provided can be exactly like those described in feature or in a
variety of obvious forms:
.IP "\(bu" 4
:5.26
.IP "\(bu" 4
5.26
.IP "\(bu" 4
v5.26
.IP "\(bu" 4
26
.SH "EXTENSIONS"
.IX Header "EXTENSIONS"
It's possible to write extensions or plugins for exact to provide
context-specific behavior, provided you are using Perl version 5.14 or newer.
To activate these extensions, you need to provide their named suffix as a
parameter to the \f(CW\*(C`use\*(C'\fR of exact.
.PP
.Vb 2
\&    # will load "exact" and "exact::class";
\&    use exact \-class;
\&
\&    # will load "exact" and "exact::role" and turn off UTF8 features;
\&    use exact \-role, \-noutf8;
.Ve
.PP
It's possible to provide parameters to the \f(CW\*(C`import\*(C'\fR method of the extension.
.PP
.Vb 2
\&    # will load "exact" and "exact::answer" and pass "42" to the import method
\&    use exact \*(Aqanswer(42)\*(Aq;
.Ve
.SS "Writing Extensions"
.IX Subsection "Writing Extensions"
An extension may but is not required to have an \f(CW\*(C`import\*(C'\fR method. If such a
method does exist, it will be passed: the package name, the name of the caller
of exact, and any parameters passed.
.PP
.Vb 2
\&    package exact::example;
\&    use exact;
\&
\&    sub import {
\&        my ( $self, $caller, $params ) = @_;
\&        exact\->monkey_patch( $caller, \*(Aqexample\*(Aq => \e&example );
\&    }
\&
\&    sub example {
\&        say 42;
\&    }
\&
\&    1;
.Ve
.SH "PARENTS"
.IX Header "PARENTS"
You can use \f(CW\*(C`exact\*(C'\fR to setup inheritance as follows:
.PP
.Vb 1
\&    use exact \*(AqSomeModule\*(Aq, \*(AqSomeOtherModule\*(Aq;
.Ve
.PP
This is roughly equivalent to:
.PP
.Vb 2
\&    use exact;
\&    use parent \*(AqSomeModule\*(Aq, \*(AqSomeOtherModule\*(Aq;
.Ve
.PP
See also the \f(CW\*(C`no_parent\*(C'\fR method.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """monkey_patch"""
.el .SS "\f(CWmonkey_patch\fP"
.IX Subsection "monkey_patch"
Monkey patch functions into a given package.
.PP
.Vb 7
\&    exact\->monkey_patch( \*(AqPackageName\*(Aq, add => sub { return $_[0] + $_[1] } );
\&    exact\->monkey_patch(
\&        \*(AqPackageName\*(Aq,
\&        one   => sub { return 1 },
\&        two   => sub { return 2 },
\&        three => sub { return 3 },
\&    );
.Ve
.ie n .SS """add_isa"""
.el .SS "\f(CWadd_isa\fP"
.IX Subsection "add_isa"
This method will add a given parent to the \f(CW@ISA\fR of a given child.
.PP
.Vb 1
\&    exact\->add_isa( \*(AqSuperClassParent\*(Aq, \*(AqSubClassChild\*(Aq );
.Ve
.ie n .SS """no_parent"""
.el .SS "\f(CWno_parent\fP"
.IX Subsection "no_parent"
Normally, if you specify a parent, it'll be added as a parent by inclusion in
\&\f(CW@INC\fR. If you don't want to skip \f(CW@INC\fR inclusion, you can call \f(CW\*(C`no_parent\*(C'\fR
in the \f(CW\*(C`import\*(C'\fR of the module being specified as a parent.
.PP
.Vb 3
\&    sub import {
\&        exact\->no_parent;
\&    }
.Ve
.ie n .SS """late_parent"""
.el .SS "\f(CWlate_parent\fP"
.IX Subsection "late_parent"
There may be a situation where you need an included parent to be listed last in
\&\f(CW@INC\fR (at least relative to other parents). Normally, you'd do this by putting
the name last in the list of modules. However, if for some reason you can't do
that, you can call \f(CW\*(C`late_parent\*(C'\fR from the \f(CW\*(C`import\*(C'\fR of the parent that should
be delayed in \f(CW@INC\fR inclusion.
.PP
.Vb 3
\&    sub import {
\&        exact\->late_parent;
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
You can look for additional information at:
.IP "\(bu" 4
GitHub <https://github.com/gryphonshafer/exact>
.IP "\(bu" 4
MetaCPAN <https://metacpan.org/pod/exact>
.IP "\(bu" 4
Travis \s-1CI\s0 <https://travis-ci.org/gryphonshafer/exact>
.IP "\(bu" 4
Coveralls <https://coveralls.io/r/gryphonshafer/exact>
.IP "\(bu" 4
\&\s-1CPANTS\s0 <http://cpants.cpanauthors.org/dist/exact>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers <http://www.cpantesters.org/distro/T/exact.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Gryphon Shafer <gryphon@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Gryphon Shafer.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
