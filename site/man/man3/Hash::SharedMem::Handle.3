.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::SharedMem::Handle 3"
.TH Hash::SharedMem::Handle 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::SharedMem::Handle \- handle for efficient shared mutable hash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Hash::SharedMem::Handle;
\&
\&    if(Hash::SharedMem::Handle\->referential_handle) { ...
\&
\&    $shash = Hash::SharedMem::Handle\->open($filename, "rwc");
\&
\&    if($shash\->is_readable) { ...
\&    if($shash\->is_writable) { ...
\&    $mode = $shash\->mode;
\&
\&    if($shash\->exists($key)) { ...
\&    $length = $shash\->length($key);
\&    $value = $shash\->get($key);
\&    $shash\->set($key, $newvalue);
\&    $oldvalue = $shash\->gset($key, $newvalue);
\&    if($shash\->cset($key, $chkvalue, $newvalue)) { ...
\&
\&    if($shash\->occupied) { ...
\&    $count = $shash\->count;
\&    $size = $shash\->size;
\&    $key = $shash\->key_min;
\&    $key = $shash\->key_max;
\&    $key = $shash\->key_ge($key);
\&    $key = $shash\->key_gt($key);
\&    $key = $shash\->key_le($key);
\&    $key = $shash\->key_lt($key);
\&    $keys = $shash\->keys_array;
\&    $keys = $shash\->keys_hash;
\&    $group = $shash\->group_get_hash;
\&
\&    $snap_shash = $shash\->snapshot;
\&    if($shash\->is_snapshot) { ...
\&
\&    $shash\->idle;
\&    $shash\->tidy;
\&
\&    $tally = $shash\->tally_get;
\&    $shash\->tally_zero;
\&    $tally = $shash\->tally_gzero;
\&
\&    tie %shash, "Hash::SharedMem::Handle", $shash;
\&    tie %shash, "Hash::SharedMem::Handle", $filename, "rwc";
\&
\&    $shash = tied(%shash);
\&    if(exists($shash{$key})) { ...
\&    $value = $shash{$key};
\&    $shash{$key} = $newvalue;
\&    $oldvalue = delete($shash{$key});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class is a handle referring to a memory-mapped shared
hash object of the kind described in Hash::SharedMem.  It can be
passed to the functions of that module, or the same operations can be
performed by calling the methods described below.  Uses of the function
and method interfaces may be intermixed arbitrarily; they are completely
equivalent in function.  They are not equivalent in performance, however,
with the method interface being somewhat slower.
.PP
This class also supplies a tied-hash interface to shared hashes.  The tied
interface is much slower than the function and method interfaces.
The behaviour of a tied hash more resembles the function and method
interfaces to shared hashes than it resembles the syntactically-similar
use of ordinary Perl hashes.  Using a non-string as a key will result
in an exception, rather than stringification of the key.  Using a
string containing a non-octet codepoint as a key will also result in an
exception, rather than merely referring to an absent hash element.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "Hash::SharedMem::Handle\->referential_handle" 4
.IX Item "Hash::SharedMem::Handle->referential_handle"
Returns a truth value indicating whether each shared hash handle
contains a first-class reference to the shared hash to which it refers.
See \*(L"Filesystem referential integrity\*(R" in Hash::SharedMem for discussion
of the significance of this.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Hash::SharedMem::Handle\->open(\s-1FILENAME, MODE\s0)" 4
.IX Item "Hash::SharedMem::Handle->open(FILENAME, MODE)"
Opens and returns a handle referring to a shared hash object,
or \f(CW\*(C`die\*(C'\fRs if the shared hash can't be opened as specified.
See \*(L"shash_open\*(R" in Hash::SharedMem for details.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$shash\->is_readable" 4
.el .IP "\f(CW$shash\fR\->is_readable" 4
.IX Item "$shash->is_readable"
.PD 0
.ie n .IP "$shash\->is_writable" 4
.el .IP "\f(CW$shash\fR\->is_writable" 4
.IX Item "$shash->is_writable"
.ie n .IP "$shash\->mode" 4
.el .IP "\f(CW$shash\fR\->mode" 4
.IX Item "$shash->mode"
.ie n .IP "$shash\->exists(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->exists(\s-1KEY\s0)" 4
.IX Item "$shash->exists(KEY)"
.ie n .IP "$shash\->getd(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->getd(\s-1KEY\s0)" 4
.IX Item "$shash->getd(KEY)"
.ie n .IP "$shash\->length(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->length(\s-1KEY\s0)" 4
.IX Item "$shash->length(KEY)"
.ie n .IP "$shash\->get(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->get(\s-1KEY\s0)" 4
.IX Item "$shash->get(KEY)"
.ie n .IP "$shash\->set(\s-1KEY, NEWVALUE\s0)" 4
.el .IP "\f(CW$shash\fR\->set(\s-1KEY, NEWVALUE\s0)" 4
.IX Item "$shash->set(KEY, NEWVALUE)"
.ie n .IP "$shash\->gset(\s-1KEY, NEWVALUE\s0)" 4
.el .IP "\f(CW$shash\fR\->gset(\s-1KEY, NEWVALUE\s0)" 4
.IX Item "$shash->gset(KEY, NEWVALUE)"
.ie n .IP "$shash\->cset(\s-1KEY, CHKVALUE, NEWVALUE\s0)" 4
.el .IP "\f(CW$shash\fR\->cset(\s-1KEY, CHKVALUE, NEWVALUE\s0)" 4
.IX Item "$shash->cset(KEY, CHKVALUE, NEWVALUE)"
.ie n .IP "$shash\->occupied" 4
.el .IP "\f(CW$shash\fR\->occupied" 4
.IX Item "$shash->occupied"
.ie n .IP "$shash\->count" 4
.el .IP "\f(CW$shash\fR\->count" 4
.IX Item "$shash->count"
.ie n .IP "$shash\->size" 4
.el .IP "\f(CW$shash\fR\->size" 4
.IX Item "$shash->size"
.ie n .IP "$shash\->key_min" 4
.el .IP "\f(CW$shash\fR\->key_min" 4
.IX Item "$shash->key_min"
.ie n .IP "$shash\->key_max" 4
.el .IP "\f(CW$shash\fR\->key_max" 4
.IX Item "$shash->key_max"
.ie n .IP "$shash\->key_ge(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->key_ge(\s-1KEY\s0)" 4
.IX Item "$shash->key_ge(KEY)"
.ie n .IP "$shash\->key_gt(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->key_gt(\s-1KEY\s0)" 4
.IX Item "$shash->key_gt(KEY)"
.ie n .IP "$shash\->key_le(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->key_le(\s-1KEY\s0)" 4
.IX Item "$shash->key_le(KEY)"
.ie n .IP "$shash\->key_lt(\s-1KEY\s0)" 4
.el .IP "\f(CW$shash\fR\->key_lt(\s-1KEY\s0)" 4
.IX Item "$shash->key_lt(KEY)"
.ie n .IP "$shash\->keys_array" 4
.el .IP "\f(CW$shash\fR\->keys_array" 4
.IX Item "$shash->keys_array"
.ie n .IP "$shash\->keys_hash" 4
.el .IP "\f(CW$shash\fR\->keys_hash" 4
.IX Item "$shash->keys_hash"
.ie n .IP "$shash\->group_get_hash" 4
.el .IP "\f(CW$shash\fR\->group_get_hash" 4
.IX Item "$shash->group_get_hash"
.ie n .IP "$shash\->snapshot" 4
.el .IP "\f(CW$shash\fR\->snapshot" 4
.IX Item "$shash->snapshot"
.ie n .IP "$shash\->is_snapshot" 4
.el .IP "\f(CW$shash\fR\->is_snapshot" 4
.IX Item "$shash->is_snapshot"
.ie n .IP "$shash\->idle" 4
.el .IP "\f(CW$shash\fR\->idle" 4
.IX Item "$shash->idle"
.ie n .IP "$shash\->tidy" 4
.el .IP "\f(CW$shash\fR\->tidy" 4
.IX Item "$shash->tidy"
.ie n .IP "$shash\->tally_get" 4
.el .IP "\f(CW$shash\fR\->tally_get" 4
.IX Item "$shash->tally_get"
.ie n .IP "$shash\->tally_zero" 4
.el .IP "\f(CW$shash\fR\->tally_zero" 4
.IX Item "$shash->tally_zero"
.ie n .IP "$shash\->tally_gzero" 4
.el .IP "\f(CW$shash\fR\->tally_gzero" 4
.IX Item "$shash->tally_gzero"
.PD
These methods are each equivalent to the corresponding
"\f(CW\*(C`shash_\*(C'\fR"\-prefixed function in Hash::SharedMem.  See that document
for details.
.SH "TIE CONSTRUCTORS"
.IX Header "TIE CONSTRUCTORS"
.ie n .IP "tie(\s-1VARIABLE,\s0 ""Hash::SharedMem::Handle"", \s-1SHASH\s0)" 4
.el .IP "tie(\s-1VARIABLE,\s0 ``Hash::SharedMem::Handle'', \s-1SHASH\s0)" 4
.IX Item "tie(VARIABLE, Hash::SharedMem::Handle, SHASH)"
\&\fI\s-1VARIABLE\s0\fR must be a hash variable, and \fI\s-1SHASH\s0\fR must be a handle
referring to a shared hash object.  The call binds the variable to the
shared hash, so that the variable provides a view of the shared hash
that resembles an ordinary Perl hash.  The shared hash handle is returned.
.ie n .IP "tie(\s-1VARIABLE,\s0 ""Hash::SharedMem::Handle"", \s-1FILENAME, MODE\s0)" 4
.el .IP "tie(\s-1VARIABLE,\s0 ``Hash::SharedMem::Handle'', \s-1FILENAME, MODE\s0)" 4
.IX Item "tie(VARIABLE, Hash::SharedMem::Handle, FILENAME, MODE)"
\&\fI\s-1VARIABLE\s0\fR must be a hash variable.  The call opens a handle referring
to a shared hash object, as described in \*(L"shash_open\*(R" in Hash::SharedMem,
and binds the variable to the shared hash, so that the variable provides a
view of the shared hash that resembles an ordinary Perl hash.  The shared
hash handle is returned.
.SH "TIED OPERATORS"
.IX Header "TIED OPERATORS"
For all of these operators, the key of interest (\fI\s-1KEY\s0\fR parameter)
and values can each be any octet (Latin\-1) string.  Strings containing
non-octets (Unicode characters above U+FF) and items other than strings
cannot be used as keys or values.  If a dualvar (scalar with independent
string and numeric values) is supplied, only its string value will
be used.
.IP "tied(%SHASH)" 4
.IX Item "tied(%SHASH)"
Returns the handle via which \fI\f(CI%SHASH\fI\fR is bound to the shared hash.
This is a shared hash handle that can be used by calling the methods
described above or by passing it to the functions of Hash::SharedMem.
.IP "exists($SHASH{\s-1KEY\s0})" 4
.IX Item "exists($SHASH{KEY})"
Returns a truth value indicating whether the specified key is currently
present in the shared hash.
.ie n .IP "$SHASH{\s-1KEY\s0}" 4
.el .IP "\f(CW$SHASH\fR{\s-1KEY\s0}" 4
.IX Item "$SHASH{KEY}"
Returns the value currently referenced by the specified key in the shared
hash, or \f(CW\*(C`undef\*(C'\fR if the key is absent.
.ie n .IP "$SHASH{\s-1KEY\s0} = \s-1NEWVALUE\s0" 4
.el .IP "\f(CW$SHASH\fR{\s-1KEY\s0} = \s-1NEWVALUE\s0" 4
.IX Item "$SHASH{KEY} = NEWVALUE"
Modifies the shared hash so that the specified key henceforth references
the specified value.  The new value must be a string.
.IP "delete($SHASH{\s-1KEY\s0})" 4
.IX Item "delete($SHASH{KEY})"
Modifies the shared hash so that the specified key is henceforth absent,
and returns the value that the key previously referenced, or \f(CW\*(C`undef\*(C'\fR
if the key was already absent.  This swap is performed atomically.
.IP "scalar(%SHASH)" 4
.IX Item "scalar(%SHASH)"
From Perl 5.25.3 onwards, returns the number of items that are currently
in the shared hash.  This matches the behaviour of untied hashes on
these Perl versions.  Prior to Perl 5.25.3, from Perl 5.8.3 onwards,
returns a truth value indicating whether
there are currently any items in the shared hash.  Does not supply any
additional information corresponding to the hash bucket usage information
that untied hashes supply in this situation.  Prior to Perl 5.8.3,
returns a meaningless value, due to a limitation of the tying system.
.Sp
If the hash is evaluated in a truth value context, with the expectation of
this testing whether the shared hash is occupied, there is a performance
concern.  Prior to Perl 5.25.3 only the truth value would be determined,
quite cheaply.  From Perl 5.25.3 onwards, a more expensive operation is
performed, counting all the keys.  If this is a problem, one can evaluate
\&\f(CW\*(C`tied(%SHASH)\->occupied\*(C'\fR to explicitly invoke the truth-value-only
operation.  However, if performance is a concern then the tied interface
is best entirely avoided.
.IP "scalar(keys(%SHASH))" 4
.IX Item "scalar(keys(%SHASH))"
.PD 0
.IP "scalar(values(%SHASH))" 4
.IX Item "scalar(values(%SHASH))"
.PD
Returns the number of items that are currently in the shared hash.
.Sp
Due to a limitation of the tying system, the item count is not extracted
atomically, but is derived by means equivalent to a loop using \f(CW\*(C`each\*(C'\fR.
If the set of keys in the shared hash changes during this process,
the count of keys visited (which is what is actually returned) does not
necessarily match any state that the shared hash has ever been in.
.IP "each(%SHASH)" 4
.IX Item "each(%SHASH)"
Iterates over the shared hash.  On each call, returns either the next key
(in scalar context) or the next key and the value that it references
(in list context).  The iterator state, preserved between calls, is
attached to \f(CW%SHASH\fR.
.Sp
The iteration process always visits the keys in lexicographical order.
Unlike iteration of untied hashes, it is safe to make any changes at all
to the shared hash content between calls to \f(CW\*(C`each\*(C'\fR.  Subsequent calls
see the new content, and the iteration process resumes with whatever key
(in the new content) follows the key most recently visited (from the
old content).
.Sp
When using \f(CW\*(C`each\*(C'\fR in list context, the fetching of the next key and its
corresponding value is not an atomic operation, due to a limitation of the
tying system.  The key and value are fetched as two separate operations
(each one individually atomic), and it is possible for the shared hash
content to change between them.  This is noticeable if the key that was
fetched gets deleted before the value is fetched: it will appear that
the value is \f(CW\*(C`undef\*(C'\fR, which is not a permitted value in a shared hash.
.IP "keys(%SHASH)" 4
.IX Item "keys(%SHASH)"
.PD 0
.IP "values(%SHASH)" 4
.IX Item "values(%SHASH)"
.ie n .IP "%SHASH" 4
.el .IP "\f(CW%SHASH\fR" 4
.IX Item "%SHASH"
.PD
Enumerates the shared hash's content (keys alone, values alone, or
keys with values), and as a side effect resets the iterator state used
by \f(CW\*(C`each\*(C'\fR.  Always returns the content in lexicographical order of key.
.Sp
Due to a limitation of the tying system, the content is not extracted
atomically, and so the content returned as a whole does not necessarily
match any state that the shared hash has ever been in.  The content
is extracted by means equivalent to a loop using \f(CW\*(C`each\*(C'\fR, and the
inconsistencies that may be seen follow therefrom.
.ie n .IP "%SHASH = \s-1LIST\s0" 4
.el .IP "\f(CW%SHASH\fR = \s-1LIST\s0" 4
.IX Item "%SHASH = LIST"
Setting the entire content of the shared hash (throwing away the previous
content) is not supported.
.SH "BUGS"
.IX Header "BUGS"
Due to details of the Perl implementation, this object-oriented interface
to the shared hash mechanism is somewhat slower than the function
interface, and the tied interface is much slower.  The functions in
Hash::SharedMem are the recommended interface.
.PP
Limitations of the tying system mean that whole-hash operations (including
iteration and enumeration) performed on shared hashes via the tied
interface are not as atomic as they appear.  If it is necessary to see
a consistent state of a shared hash, one must create and use a snapshot
handle.  A snapshot may be iterated over or enumerated at leisure via
any of the interfaces.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Hash::SharedMem
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2014, 2015 PhotoBox Ltd
.PP
Copyright (C) 2014, 2015, 2017 Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
