.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tree::File 3"
.TH Tree::File 3 "2013-01-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tree::File \- (DEPRECATED) store a data structure in a file tree
.SH "VERSION"
.IX Header "VERSION"
version 0.112
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tree::File::Subclass;
\&
\& my $tree = Tree::File::Subclass\->new($treerot);
\&
\& die "death mandated" if $tree\->get("/master/die")
\&
\& print "Hello, ", $tree\->get("/login/user/name");
\&
\& $tree\->set("/login/user/lastlogin", time);
\& $tree\->write;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module stores configuration in a series of files spread across a directory
tree, and provides uniform access to the data structure.
.PP
It can load a single file or a directory tree containing files as leaves.  The
tree's branches can be returned as data structures, and the tree can be
modified and rewritten.  Directory-based branches can be collapsed back into
files and file-based branches can be exploded into directories.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """Tree::File\->new($treeroot, \e%arg)"""
.el .SS "\f(CWTree::File\->new($treeroot, \e%arg)\fP"
.IX Subsection "Tree::File->new($treeroot, %arg)"
This loads the tree at the named root, which may be a file or a directory.  The
\&\f(CW%arg\fR hash is optional, the following options are recognized:
.PP
.Vb 9
\&  readonly  \- if true, set and delete methods croak (default: false)
\&  preload   \- the number of levels of directories to preload (default: none)
\&              pass \-1 to preload as deep as required
\&  found     \- a closure called when a node or value is found; it is passed the
\&              Tree::File object, the id requested, and the data retrieved; it
\&              should apply any transformations and return the \*(Aqreal\*(Aq value desired.
\&  not_found \- a closure called if a node cannot be found; it is passed the id
\&              requested and the root of the last node reached; by default,
\&              Tree::File will return undef in this situation
.Ve
.ie n .SS """$tree\->load_file($filename)"""
.el .SS "\f(CW$tree\->load_file($filename)\fP"
.IX Subsection "$tree->load_file($filename)"
This method is used internally by Tree::File subclasses, which must implement
it.  Given the name of a file on disk, this method returns the data structure
contained in the file.
.ie n .SS """$tree\->get($id)"""
.el .SS "\f(CW$tree\->get($id)\fP"
.IX Subsection "$tree->get($id)"
This returns the branch with the given name.  If the name contains slashes,
they indicate recursive fetches, so that these two calls are identical:
.PP
.Vb 1
\&  $tree\->get("foo")\->get("bar")\->get("baz");
\&
\&  $tree\->get("foo/bar/baz");
.Ve
.PP
Leading slashes are ignored.
.PP
If a second, true argument is passed to \f(CW\*(C`get\*(C'\fR, any missing data structures
will be autovivified as needed to get to the leaf.
.ie n .SS """$tree\->set($id, $value)"""
.el .SS "\f(CW$tree\->set($id, $value)\fP"
.IX Subsection "$tree->set($id, $value)"
This sets the identified branch's value to the given value.  Hash references
are automatically expanded into trees.
.ie n .SS """$tree\->delete($id)"""
.el .SS "\f(CW$tree\->delete($id)\fP"
.IX Subsection "$tree->delete($id)"
This method deletes the identified branch (and returns the deleted value).
.ie n .SS """$tree\->move($old_id, $new_id)"""
.el .SS "\f(CW$tree\->move($old_id, $new_id)\fP"
.IX Subsection "$tree->move($old_id, $new_id)"
This method deletes the value at the old id and places it at the new id.
.ie n .SS """$tree\->path()"""
.el .SS "\f(CW$tree\->path()\fP"
.IX Subsection "$tree->path()"
This method returns the path to this node from the root.
.ie n .SS """$tree\->basename()"""
.el .SS "\f(CW$tree\->basename()\fP"
.IX Subsection "$tree->basename()"
This method retuns the base name of the node.  (If, for example, the path to
the node is \*(L"/things/good/all\*(R" then its base name is \*(L"all\*(R".)
.ie n .SS """$tree\->node_names()"""
.el .SS "\f(CW$tree\->node_names()\fP"
.IX Subsection "$tree->node_names()"
This method returns the names of all the nodes beneath this branch.
.ie n .SS """$tree\->nodes()"""
.el .SS "\f(CW$tree\->nodes()\fP"
.IX Subsection "$tree->nodes()"
This method returns each node beneath this branch.
.ie n .SS """$tree\->branch_names"""
.el .SS "\f(CW$tree\->branch_names\fP"
.IX Subsection "$tree->branch_names"
.ie n .SS """$tree\->branches"""
.el .SS "\f(CW$tree\->branches\fP"
.IX Subsection "$tree->branches"
This method returns all the nodes on this branch which are also branches (that
is, are also Tree::File objects).
.ie n .SS """$tree\->data()"""
.el .SS "\f(CW$tree\->data()\fP"
.IX Subsection "$tree->data()"
This method returns the entire tree of data as an unblessed Perl data
structure.
.ie n .SS """$tree\->write($basedir)"""
.el .SS "\f(CW$tree\->write($basedir)\fP"
.IX Subsection "$tree->write($basedir)"
This method forces the object to write itself out to disk.  It will write out
branches to directories if a directory for the branch already exists, or if it
was orginally loaded as a directory.
.ie n .SS """$tree\->write_file($filename)"""
.el .SS "\f(CW$tree\->write_file($filename)\fP"
.IX Subsection "$tree->write_file($filename)"
This method is used by Tree::File's \f(CW\*(C`write\*(C'\fR method.  It must be implement in
subclasses of Tree::File.  Given the name of a file on disk and a data
structure, this method writes the data structure to the file.
.ie n .SS """$tree\->type($type)"""
.el .SS "\f(CW$tree\->type($type)\fP"
.IX Subsection "$tree->type($type)"
This method returns the branch type for the given branch.  If \f(CW$type\fR is
defined and one of \*(L"dir\*(R" or \*(L"file\*(R" it will set the type and return the new
value.
.ie n .SS """$tree\->explode()"""
.el .SS "\f(CW$tree\->explode()\fP"
.IX Subsection "$tree->explode()"
.ie n .SS """$tree\->collapse()"""
.el .SS "\f(CW$tree\->collapse()\fP"
.IX Subsection "$tree->collapse()"
These methods set the type of the branch to \*(L"dir\*(R" and \*(L"file\*(R" respectively.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
symlinks and references
.IP "\(bu" 4
serialization through delegation, not inheritance
.IP "\(bu" 4
make locking methods pluggable
.IP "\(bu" 4
callback for determining which files to skip
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo \s-1SIGNES,\s0 \f(CW\*(C`<rjbs@cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-tree\-file@rt.cpan.org\*(C'\fR, or
through the web interface at <http://rt.cpan.org>.  I will be notified, and
then you'll automatically be notified of progress on your bug as I make
changes.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 Ricardo Signes, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
