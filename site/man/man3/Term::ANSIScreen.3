.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Term::ANSIScreen 3"
.TH Term::ANSIScreen 3 "2012-01-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ANSIScreen \- Terminal control using ANSI escape sequences
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # qw/:color/ is exported by default, i.e. color() & colored()
\&
\&    use Term::ANSIScreen qw/:color :cursor :screen :keyboard/;
\&
\&    print setmode(1), setkey(\*(Aqa\*(Aq,\*(Aqb\*(Aq);
\&    print "40x25 mode now, with \*(Aqa\*(Aq mapped to \*(Aqb\*(Aq.";
\&    <STDIN>; resetkey; setmode 3; cls;
\&
\&    locate 1, 1; print "@ This is (1,1)", savepos;
\&    print locate(24,60), "@ This is (24,60)"; loadpos;
\&    print down(2), clline, "@ This is (3,15)\en";
\&
\&    setscroll 1, 20;
\&
\&    color \*(Aqblack on white\*(Aq; clline;
\&    print "This line is black on white.\en";
\&    print color \*(Aqreset\*(Aq; print "This text is normal.\en";
\&
\&    print colored ("This text is bold blue.\en", \*(Aqbold blue\*(Aq);
\&    print "This text is normal.\en";
\&    print colored [\*(Aqbold blue\*(Aq], "This text is bold blue.\en";
\&    print "This text is normal.\en";
\&
\&    use Term::ANSIScreen qw/:constants/; # constants mode
\&    print BLUE ON GREEN . "Blue on green.\en";
\&
\&    $Term::ANSIScreen::AUTORESET = 1;
\&    print BOLD GREEN . ON_BLUE "Bold green on blue.", CLEAR;
\&    print "\enThis text is normal.\en";
\&
\&    # Win32::Console emulation mode
\&    # this returns a Win32::Console object on a Win32 platform
\&    my $console = Term::ANSIScreen\->new;
\&    $console\->Cls;      # also works on non\-Win32 platform
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ANSIScreen is a superset of \fBTerm::ANSIColor\fR (as of version 1.04
of that module).  In addition to color-sequence generating subroutines
exported by \f(CW\*(C`:color\*(C'\fR and \f(CW\*(C`:constants\*(C'\fR, this module also features
\&\f(CW\*(C`:cursor\*(C'\fR for cursor positioning, \f(CW\*(C`:screen\*(C'\fR for screen control, as
well as \f(CW\*(C`:keyboard\*(C'\fR for key mapping.
.SS "\s-1NOTES\s0"
.IX Subsection "NOTES"
.IP "\(bu" 4
All subroutines in \fBTerm::ANSIScreen\fR will print its return value if
called under a void context.
.IP "\(bu" 4
The cursor position, current color, screen mode and keyboard
mappings affected by \fBTerm::ANSIScreen\fR will last after the program
terminates. You might want to reset them before the end of
your program.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\fBWin32::Console\fP emulation mode"
.IX Subsection "Win32::Console emulation mode"
When used in a object-oriented fashion, \fBTerm::ANSIScreen\fR acts as a
\&\fBWin32::Console\fR clone:
.PP
.Vb 5
\&    use Term::ANSIScreen;
\&    my $console = Term::ANSIScreen\->new;
\&    $console\->Cls();            # unbuffered
\&    $console\->Cursor(0, 0);     # same as locate(1, 1)
\&    $console\->Display();        # really a no\-op
.Ve
.PP
On the Win32 platform, the \f(CW\*(C`new\*(C'\fR constructor simply returns a geniune
\&\fBWin32::Console\fR object, if that module exists in the system.
.PP
This feature is intended for people who has to port Win32 console
applications to other platforms, or to write cross-platform application
that needs terminal controls.
.ie n .SS "The "":color"" function set (exported by default)"
.el .SS "The \f(CW:color\fP function set (exported by default)"
.IX Subsection "The :color function set (exported by default)"
\&\fBTerm::ANSIScreen\fR recognizes (case-insensitively) following color
attributes: clear, reset, bold, underline, underscore, blink,
reverse, concealed, black, red, green, blue, white, yellow, magenta,
cyan, on_black, on_red, on_green, on_blue, on_white, on_yellow,
on_magenta, and on_cyan.
.PP
The color alone sets the foreground color, and on_color sets
the background color. You may also use on_color without the
underscore, e.g. \*(L"black on white\*(R".
.IP "color \s-1LIST\s0" 4
.IX Item "color LIST"
Takes any number of strings as arguments and considers them
to be space-separated lists of attributes.  It then forms
and returns the escape sequence to set those attributes.
.IP "colored \s-1EXPR, LIST\s0" 4
.IX Item "colored EXPR, LIST"
Takes a scalar as the first argument and any number of
attribute strings as the second argument, then returns the
scalar wrapped in escape codes so that the attributes will
be set as requested before the string and reset to normal
after the string.
.Sp
Alternately, you can pass a reference to an array as the
first argument, and then the contents of that array will
be taken as attributes and color codes and the remainder
of the arguments as text to colorize.
.Sp
Normally, this function just puts attribute codes at the
beginning and end of the string, but if you set
\&\f(CW$Term::ANSIScreen::EACHLINE\fR to some string, that string will
be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset
at the end of each line.  This is often desirable if the
output is being sent to a program like a pager, which can
be confused by attributes that span lines.
.Sp
Normally you'll want to set \f(CW$Term::ANSIScreen::EACHLINE\fR to
\&\f(CW"\en"\fR to use this feature.
.ie n .SS "The "":constants"" function set"
.el .SS "The \f(CW:constants\fP function set"
.IX Subsection "The :constants function set"
If you import \f(CW\*(C`:constants\*(C'\fR you can use the constants \s-1CLEAR,
RESET, BOLD, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED,
ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN,\s0 and \s-1ON_WHITE\s0
directly.  These are the same as color('attribute') and can be
used if you prefer typing:
.PP
.Vb 2
\&    print BOLD BLUE ON_WHITE "Text\en", RESET;
\&    print BOLD BLUE ON WHITE "Text\en", RESET; # _ is optional
.Ve
.PP
to
    print colored (\*(L"Text\en\*(R", 'bold blue on_white');
.PP
When using the constants, if you don't want to have to remember
to add the \f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIScreen::AUTORESET\fR to a true value.  Then, the display
mode will automatically be reset if there is no comma after the
constant.  In other words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
.PP
will reset the display mode afterwards, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
.PP
will not.
.ie n .SS "The "":cursor"" function set"
.el .SS "The \f(CW:cursor\fP function set"
.IX Subsection "The :cursor function set"
.IP "locate [\s-1EXPR, EXPR\s0]" 4
.IX Item "locate [EXPR, EXPR]"
Sets the cursor position. The first argument is its row number,
and the second one its column number.  If omitted, the cursor
will be located at (1,1).
.IP "up    [\s-1EXPR\s0]" 4
.IX Item "up [EXPR]"
.PD 0
.IP "down  [\s-1EXPR\s0]" 4
.IX Item "down [EXPR]"
.IP "left  [\s-1EXPR\s0]" 4
.IX Item "left [EXPR]"
.IP "right [\s-1EXPR\s0]" 4
.IX Item "right [EXPR]"
.PD
Moves the cursor toward any direction for \s-1EXPR\s0 characters. If
omitted, \s-1EXPR\s0 is 1.
.IP "savepos" 4
.IX Item "savepos"
.PD 0
.IP "loadpos" 4
.IX Item "loadpos"
.PD
Saves/restores the current cursor position.
.ie n .SS "The "":screen"" function set"
.el .SS "The \f(CW:screen\fP function set"
.IX Subsection "The :screen function set"
.IP "cls" 4
.IX Item "cls"
Clears the screen with the current background color, and set
cursor to (1,1).
.IP "clline" 4
.IX Item "clline"
Clears the current row with the current background color, and
set cursor to the 1st column.
.IP "clup" 4
.IX Item "clup"
Clears everything above the cursor.
.IP "cldown" 4
.IX Item "cldown"
Clears everything below the cursor.
.IP "setmode \s-1EXPR\s0" 4
.IX Item "setmode EXPR"
Sets the screen mode to \s-1EXPR.\s0 Under \s-1DOS, ANSI.SYS\s0 recognizes
following values:
.Sp
.Vb 8
\&     0:  40 x  25 x   2 (text)   1:  40 x  25 x 16 (text)
\&     2:  80 x  25 x   2 (text)   3:  80 x  25 x 16 (text)
\&     4: 320 x 200 x   4          5: 320 x 200 x  2
\&     6: 640 x 200 x   2          7: Enables line wrapping
\&    13: 320 x 200 x   4         14: 640 x 200 x 16
\&    15: 640 x 350 x   2         16: 640 x 350 x 16
\&    17: 640 x 480 x   2         18: 640 x 480 x 16
\&    19: 320 x 200 x 256
.Ve
.IP "wrapon" 4
.IX Item "wrapon"
.PD 0
.IP "wrapoff" 4
.IX Item "wrapoff"
.PD
Enables/disables the line-wraping mode.
.IP "setscroll \s-1EXPR, EXPR\s0" 4
.IX Item "setscroll EXPR, EXPR"
Causes scrolling to occur only on the lines numbered between
the first and second arguments, inclusive.
.ie n .SS "The "":keyboard"" function set"
.el .SS "The \f(CW:keyboard\fP function set"
.IX Subsection "The :keyboard function set"
.IP "setkey \s-1EXPR, EXPR\s0" 4
.IX Item "setkey EXPR, EXPR"
Takes a scalar representing a single keystroke as the first
argument (either a character or an escape sequence in the
form of \f(CW"num1;num2"\fR), and maps it to a string defined by
the second argument.  Afterwards, when the user presses the
mapped key, the string will get outputed instead.
.IP "resetkey [\s-1LIST\s0]" 4
.IX Item "resetkey [LIST]"
Resets each keys in the argument list to its original mapping.
If called without an argument, resets all previously mapped
keys.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Invalid attribute name %s" 4
.el .IP "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
You passed an invalid attribute name to either \fBcolor()\fR or
\&\fBcolored()\fR.
.ie n .IP "Identifier %s used only once: possible typo" 4
.el .IP "Identifier \f(CW%s\fR used only once: possible typo" 4
.IX Item "Identifier %s used only once: possible typo"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
.Sp
It's probably better to always use commas after constant names
in order to force the next error.
.IP "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
.Sp
Generating this fatal compile error is one of the main advantages
of using the constants interface, since you'll immediately know
if you mistype a color name.
.ie n .IP "Bareword %s not allowed while ""strict subs"" in use" 4
.el .IP "Bareword \f(CW%s\fR not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while strict subs in use"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
.Sp
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
.Sp
This will only show up under use strict (another good reason
to run under use strict).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Term::ANSIColor, Win32::Console
.SH "AUTHORS"
.IX Header "AUTHORS"
唐鳳 <cpan@audreyt.org>
.SH "CC0 1.0 Universal"
.IX Header "CC0 1.0 Universal"
To the extent possible under law, 唐鳳 has waived all copyright and related
or neighboring rights to Term-ANSIScreen.
.PP
This work is published from Taiwan.
.PP
<http://creativecommons.org/publicdomain/zero/1.0>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 589:" 4
.IX Item "Around line 589:"
Non-ASCII character seen before =encoding in '唐鳳'. Assuming \s-1UTF\-8\s0
