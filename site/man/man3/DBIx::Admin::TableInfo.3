.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Admin::TableInfo 3"
.TH DBIx::Admin::TableInfo 3 "2016-09-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Admin::TableInfo \- A wrapper for all of table_info(), column_info(), *_key_info()
.SH "Synopsis"
.IX Header "Synopsis"
This is scripts/synopsis.pl:
.PP
.Vb 1
\&        #!/usr/bin/env perl
\&
\&        use strict;
\&        use warnings;
\&
\&        use DBI;
\&        use DBIx::Admin::TableInfo 3.02;
\&
\&        use Lingua::EN::PluralToSingular \*(Aqto_singular\*(Aq;
\&
\&        use Text::Table::Manifold \*(Aq:constants\*(Aq;
\&
\&        # \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        my($attr)              = {};
\&        $$attr{sqlite_unicode} = 1 if ($ENV{DBI_DSN} =~ /SQLite/i);
\&        my($dbh)               = DBI \-> connect($ENV{DBI_DSN}, $ENV{DBI_USER}, $ENV{DBI_PASS}, $attr);
\&        my($vendor_name)       = uc $dbh \-> get_info(17);
\&        my($info)              = DBIx::Admin::TableInfo \-> new(dbh => $dbh) \-> info;
\&
\&        $dbh \-> do(\*(Aqpragma foreign_keys = on\*(Aq) if ($ENV{DBI_DSN} =~ /SQLite/i);
\&
\&        my($temp_1, $temp_2, $temp_3);
\&
\&        if ($vendor_name eq \*(AqMYSQL\*(Aq)
\&        {
\&                $temp_1 = \*(AqPKTABLE_NAME\*(Aq;
\&                $temp_2 = \*(AqFKTABLE_NAME\*(Aq;
\&                $temp_3 = \*(AqFKCOLUMN_NAME\*(Aq;
\&        }
\&        else # ORACLE && POSTGRESQL && SQLITE (at least).
\&        {
\&                $temp_1 = \*(AqUK_TABLE_NAME\*(Aq;
\&                $temp_2 = \*(AqFK_TABLE_NAME\*(Aq;
\&                $temp_3 = \*(AqFK_COLUMN_NAME\*(Aq;
\&        }
\&
\&        my(%special_fk_column) =
\&        (
\&                spouse_id => \*(Aqperson_id\*(Aq,
\&        );
\&
\&        my($destination_port);
\&        my($fk_column_name, $fk_table_name, %foreign_key);
\&        my($pk_table_name, $primary_key_name);
\&        my($singular_name, $source_port);
\&
\&        for my $table_name (sort keys %$info)
\&        {
\&                for my $item (@{$$info{$table_name}{foreign_keys} })
\&                {
\&                        $pk_table_name  = $$item{$temp_1};
\&                        $fk_table_name  = $$item{$temp_2};
\&                        $fk_column_name = $$item{$temp_3};
\&
\&                        if ($pk_table_name)
\&                        {
\&                                $singular_name = to_singular($pk_table_name);
\&
\&                                if ($special_fk_column{$fk_column_name})
\&                                {
\&                                        $primary_key_name = $special_fk_column{$fk_column_name};
\&                                }
\&                                elsif (defined($$info{$table_name}{columns}{$fk_column_name}) )
\&                                {
\&                                        $primary_key_name = $fk_column_name;
\&                                }
\&                                elsif (defined($$info{$table_name}{columns}{id}) )
\&                                {
\&                                        $primary_key_name = \*(Aqid\*(Aq;
\&                                }
\&                                else
\&                                {
\&                                        die "Primary table \*(Aq$pk_table_name\*(Aq. Foreign table \*(Aq$fk_table_name\*(Aq. Unable to find primary key name for foreign key \*(Aq$fk_column_name\*(Aq\en"
\&                                }
\&
\&                                $foreign_key{$fk_table_name}                               = {} if (! $foreign_key{$fk_table_name});
\&                                $foreign_key{$fk_table_name}{$fk_column_name}              = {} if (! $foreign_key{$fk_table_name}{$fk_column_name});
\&                                $primary_key_name                                          =~ s/${singular_name}_//;
\&                                $foreign_key{$fk_table_name}{$fk_column_name}{$table_name} = $primary_key_name;
\&                        }
\&                }
\&        }
\&
\&        my(@header) =
\&        (
\&                \*(AqName\*(Aq,
\&                \*(AqType\*(Aq,
\&                \*(AqNull\*(Aq,
\&                \*(AqKey\*(Aq,
\&                \*(AqAuto\-increment\*(Aq,
\&        );
\&
\&        my($table) = Text::Table::Manifold \-> new
\&        (
\&                alignment =>
\&                [
\&                        align_left,
\&                        align_left,
\&                        align_left,
\&                        align_left,
\&                        align_left,
\&                ],
\&                format => format_text_unicodebox_table,
\&                headers => \e@header,
\&                join   => "\en",
\&        );
\&        my(%type) =
\&        (
\&                \*(Aqcharacter varying\*(Aq => \*(Aqvarchar\*(Aq,
\&                \*(Aqint(11)\*(Aq           => \*(Aqinteger\*(Aq,
\&                \*(Aq"timestamp"\*(Aq       => \*(Aqtimestamp\*(Aq,
\&        );
\&
\&        my($auto_increment);
\&        my(@data);
\&        my($index);
\&        my($nullable);
\&        my($primary_key);
\&        my($type);
\&
\&        for my $table_name (sort keys %$info)
\&        {
\&                print "Table: $table_name.\en\en";
\&
\&                @data  = ();
\&                $index = undef;
\&
\&                for my $column_name (keys %{$$info{$table_name}{columns} })
\&                {
\&                        $type           = $$info{$table_name}{columns}{$column_name}{TYPE_NAME};
\&                        $type           = $type{$type} ? $type{$type} : $type;
\&                        $nullable       = $$info{$table_name}{columns}{$column_name}{IS_NULLABLE} eq \*(AqNO\*(Aq;
\&                        $primary_key    = $$info{$table_name}{primary_keys}{$column_name};
\&                        $auto_increment = $primary_key; # Database server\-independent kludge :\-(.
\&
\&                        push @data,
\&                        [
\&                                $column_name,
\&                                $type,
\&                                $nullable       ? \*(Aqnot null\*(Aq       : \*(Aq\*(Aq,
\&                                $primary_key    ? \*(Aqprimary key\*(Aq    : \*(Aq\*(Aq,
\&                                $auto_increment ? \*(Aqauto_increment\*(Aq : \*(Aq\*(Aq,
\&                        ];
\&
\&                        $index = pop @data if ($column_name eq \*(Aqid\*(Aq);
\&                }
\&
\&                @data = sort{$$a[0] cmp $$b[0]} @data;
\&
\&                unshift @data, $index if ($index);
\&
\&                $table \-> data(\e@data);
\&
\&                print $table \-> render_as_string, "\en\en";
\&        }
.Ve
.PP
If the environment vaiables \s-1DBI_DSN, DBI_USER\s0 and \s-1DBI_PASS\s0 are set (the latter 2 are optional [e.g.
for SQLite), then this demonstrates extracting a lot of information from a database schema.
.PP
Also, for Postgres, you can set \s-1DBI_SCHEMA\s0 to a list of schemas, e.g. when processing the
MusicBrainz database.
.PP
For details, see <http://blogs.perl.org/users/ron_savage/2013/03/graphviz2\-and\-the\-dread\-musicbrainz\-db.html>.
.PP
See also xt/author/fk.t, xt/author/mysql.fk.pl and xt/author/person.spouse.t.
.SH "Description"
.IX Header "Description"
\&\f(CW\*(C`DBIx::Admin::TableInfo\*(C'\fR is a pure Perl module.
.PP
It is a convenient wrapper around all of these \s-1DBI\s0 methods:
.IP "o \fBtable_info()\fR" 4
.IX Item "o table_info()"
.PD 0
.IP "o \fBcolumn_info()\fR" 4
.IX Item "o column_info()"
.IP "o \fBprimary_key_info()\fR" 4
.IX Item "o primary_key_info()"
.IP "o \fBforeign_key_info()\fR" 4
.IX Item "o foreign_key_info()"
.IP "o MySQL" 4
.IX Item "o MySQL"
.PD
Warning:
.Sp
To get foreign key information in the output, the create table statement has to:
.RS 4
.IP "o Include an index clause" 4
.IX Item "o Include an index clause"
.PD 0
.IP "o Include a foreign key clause" 4
.IX Item "o Include a foreign key clause"
.IP "o Include an engine clause" 4
.IX Item "o Include an engine clause"
.PD
As an example, a column definition for Postgres and SQLite, which looks like:
.Sp
.Vb 1
\&        site_id integer not null references sites(id),
.Ve
.Sp
has to, for MySql, look like:
.Sp
.Vb 1
\&        site_id integer not null, index (site_id), foreign key (site_id) references sites(id),
.Ve
.Sp
Further, the create table statement, which for Postgres and SQLite looks like:
.Sp
.Vb 1
\&        create table designs (...)
.Ve
.Sp
has to, for MySql, look like:
.Sp
.Vb 1
\&        create table designs (...) engine=innodb
.Ve
.RE
.RS 4
.RE
.IP "o Oracle" 4
.IX Item "o Oracle"
See the \*(L"\s-1FAQ\*(R"\s0 for which tables are ignored under Oracle.
.IP "o Postgres" 4
.IX Item "o Postgres"
The latter now takes '%' as the value of the 'table' parameter to \fBnew()\fR, whereas
older versions of DBD::Pg required 'table' to be set to 'table'.
.Sp
See the \*(L"\s-1FAQ\*(R"\s0 for which tables are ignored under Postgres.
.IP "o SQLite" 4
.IX Item "o SQLite"
See the \*(L"\s-1FAQ\*(R"\s0 for which tables are ignored under SQLite.
.SH "Distributions"
.IX Header "Distributions"
This module is available both as a Unix-style distro (*.tgz) and an
ActiveState-style distro (*.ppd). The latter is shipped in a *.zip file.
.PP
See http://savage.net.au/Perl\-modules.html for details.
.PP
See http://savage.net.au/Perl\-modules/html/installing\-a\-module.html for
help on unpacking and installing each type of distro.
.SH "Constructor and initialization"
.IX Header "Constructor and initialization"
new(...) returns a \f(CW\*(C`DBIx::Admin::TableInfo\*(C'\fR object.
.PP
This is the class contructor.
.PP
Usage: DBIx::Admin::TableInfo \-> \fBnew()\fR.
.PP
This method takes a set of parameters. Only the dbh parameter is mandatory.
.PP
For each parameter you wish to use, call new as new(param_1 => value_1, ...).
.IP "o catalog" 4
.IX Item "o catalog"
This is the value passed in as the catalog parameter to \fBtable_info()\fR and \fBcolumn_info()\fR.
.Sp
The default value is undef.
.Sp
undef was chosen because it given the best results with MySQL.
.Sp
Note: The MySQL driver DBD::mysql V 2.9002 has a bug in it, in that it aborts if an empty string is
used here, even though the \s-1DBI\s0 docs say an empty string can be used for the catalog parameter to
\&\f(CW\*(C`table_info()\*(C'\fR.
.Sp
This parameter is optional.
.IP "o dbh" 4
.IX Item "o dbh"
This is a database handle.
.Sp
This parameter is mandatory.
.IP "o schema" 4
.IX Item "o schema"
This is the value passed in as the schema parameter to \fBtable_info()\fR and \fBcolumn_info()\fR.
.Sp
The default value is undef.
.Sp
Note: If you are using Oracle, call \f(CW\*(C`new()\*(C'\fR with schema set to uc \f(CW$user_name\fR.
.Sp
Note: If you are using Postgres, call \f(CW\*(C`new()\*(C'\fR with schema set to 'public'.
.Sp
Note: If you are using SQLite, call \f(CW\*(C`new()\*(C'\fR with schema set to 'main'.
.Sp
This parameter is optional.
.IP "o table" 4
.IX Item "o table"
This is the value passed in as the table parameter to \fBtable_info()\fR.
.Sp
The default value is '%'.
.Sp
Note: If you are using an 'old' version of DBD::Pg, call \f(CW\*(C`new()\*(C'\fR with table set to 'table'.
.Sp
Sorry \- I cannot tell you exactly what 'old' means. As stated above, the default value (%)
works fine with DBD::Pg V 2.17.1.
.Sp
This parameter is optional.
.IP "o type" 4
.IX Item "o type"
This is the value passed in as the type parameter to \fBtable_info()\fR.
.Sp
The default value is '\s-1TABLE\s0'.
.Sp
This parameter is optional.
.SH "Methods"
.IX Header "Methods"
.ie n .SS "columns($table_name, $by_position)"
.el .SS "columns($table_name, \f(CW$by_position\fP)"
.IX Subsection "columns($table_name, $by_position)"
Returns an array ref of column names.
.PP
By default they are sorted by name.
.PP
However, if you pass in a true value for \f(CW$by_position\fR, they are sorted by the column attribute
\&\s-1ORDINAL_POSITION.\s0 This is Postgres-specific.
.SS "dbh2schema($dbh)"
.IX Subsection "dbh2schema($dbh)"
Warning: This is a function, not a method. It is called like this:
.PP
.Vb 1
\&        my($schema) = DBIx::Admin::TableInfo::dbh2schema($dbh);
.Ve
.PP
The code is just:
.PP
.Vb 9
\&        my($dbh)    = @_;
\&        my($vendor) = uc $dbh \-> get_info(17); # SQL_DBMS_NAME.
\&        my(%schema) =
\&        (
\&                MYSQL      => undef,
\&                ORACLE     => uc $$dbh{Username},
\&                POSTGRESQL => \*(Aqpublic\*(Aq,
\&                SQLITE     => \*(Aqmain\*(Aq,
\&        );
\&
\&        return $schema{$vendor};
.Ve
.SS "\fBinfo()\fP"
.IX Subsection "info()"
Returns a hash ref of all available data.
.PP
The structure of this hash is described next:
.IP "o First level: The keys are the names of the tables" 4
.IX Item "o First level: The keys are the names of the tables"
.Vb 2
\&        my($info)       = $obj \-> info();
\&        my(@table_name) = sort keys %$info;
.Ve
.Sp
I use singular names for my arrays, hence \f(CW@table_name\fR rather than \f(CW@table_names\fR.
.IP "o Second level: The keys are 'attributes', 'columns', 'foreign_keys' and 'primary_keys'" 4
.IX Item "o Second level: The keys are 'attributes', 'columns', 'foreign_keys' and 'primary_keys'"
.Vb 1
\&        my($table_attributes) = $$info{$table_name}{attributes};
.Ve
.Sp
This is a hash ref of the attributes of the table.
The keys of this hash ref are determined by the database server.
.Sp
.Vb 1
\&        my($columns) = $$info{$table_name}{columns};
.Ve
.Sp
This is a hash ref of the columns of the table. The keys of this hash ref are the names of the
columns.
.Sp
.Vb 1
\&        my($foreign_keys) = $$info{$table_name}{foreign_keys};
.Ve
.Sp
This is a hash ref of the foreign keys of the table. The keys of this hash ref are the names of the
tables which contain foreign keys pointing to \f(CW$table_name\fR.
.Sp
For MySQL, \f(CW$foreign_keys\fR will be the empty hash ref {}, as explained above.
.Sp
.Vb 1
\&        my($primary_keys) = $$info{$table_name}{primary_keys};
.Ve
.Sp
This is a hash ref of the primary keys of the table. The keys of this hash ref are the names of the
columns which make up the primary key of \f(CW$table_name\fR.
.Sp
For any database server, if there is more than 1 column in the primary key, they will be numbered
(ordered) according to the hash key '\s-1KEY_SEQ\s0'.
.Sp
For MySQL, if there is more than 1 column in the primary key, they will be artificially numbered
according to the order in which they are returned by \f(CW\*(C`column_info()\*(C'\fR, as explained above.
.IP "o Third level, after 'attributes': Table attributes" 4
.IX Item "o Third level, after 'attributes': Table attributes"
.Vb 1
\&        my($table_attributes) = $$info{$table_name}{attributes};
\&
\&        while ( ($name, $value) = each(%$table_attributes) )
\&        {
\&                Use...
\&        }
.Ve
.Sp
For the attributes of the tables, there are no more levels in the hash ref.
.IP "o Third level, after 'columns': The keys are the names of the columns." 4
.IX Item "o Third level, after 'columns': The keys are the names of the columns."
.Vb 1
\&        my($columns) = $$info{$table_name}{columns};
\&
\&        my(@column_name) = sort keys %$columns;
.Ve
.RS 4
.IP "o Fourth level: Column attributes" 4
.IX Item "o Fourth level: Column attributes"
.Vb 7
\&        for $column_name (@column_name)
\&        {
\&            while ( ($name, $value) = each(%{$columns{$column_name} }) )
\&            {
\&                    Use...
\&            }
\&        }
.Ve
.RE
.RS 4
.RE
.IP "o Third level, after 'foreign_keys': An arrayref contains the details (if any)" 4
.IX Item "o Third level, after 'foreign_keys': An arrayref contains the details (if any)"
But beware slightly differing spellings depending on the database server. This is documented in
<https://metacpan.org/pod/DBI#foreign_key_info>. Look closely at the usage of the '_' character.
.Sp
.Vb 1
\&        my($vendor) = uc $dbh \-> get_info(17); # SQL_DBMS_NAME.
\&
\&        for $item (@{$$info{$table_name}{foreign_keys} })
\&        {
\&                # Get the name of the table pointed to.
\&
\&                $primary_table = ($vendor eq \*(AqMYSQL\*(Aq) ? $$item{PKTABLE_NAME} : $$item{UK_TABLE_NAME};
\&        }
.Ve
.IP "o Third level, after 'primary_keys': The keys are the names of columns" 4
.IX Item "o Third level, after 'primary_keys': The keys are the names of columns"
These columns make up the primary key of the current table.
.Sp
.Vb 1
\&        my($primary_keys) = $$info{$table_name}{primary_keys};
\&
\&        for $primary_key (sort{$$a{KEY_SEQ} <=> $$b{KEY_SEQ} } keys %$primary_keys)
\&        {
\&                $primary = $$primary_keys{$primary_key};
\&
\&                for $attribute (sort keys %$primary)
\&                {
\&                        Use...
\&                }
\&        }
.Ve
.SS "\fBrefresh()\fP"
.IX Subsection "refresh()"
Returns the same hash ref as \fBinfo()\fR.
.PP
Use this after changing the database schema, when you want this module to re-interrogate
the database server.
.SS "\fBtables()\fP"
.IX Subsection "tables()"
Returns an array ref of table names.
.PP
They are sorted by name.
.PP
See the \*(L"\s-1FAQ\*(R"\s0 for which tables are ignored under which databases.
.SH "Example code"
.IX Header "Example code"
Here are tested parameter values for various database vendors:
.IP "o \s-1MS\s0 Access" 4
.IX Item "o MS Access"
.Vb 1
\&        my($admin) = DBIx::Admin::TableInfo \-> new(dbh => $dbh);
\&
\&        In other words, the default values for catalog, schema, table and type will Just Work.
.Ve
.IP "o MySQL" 4
.IX Item "o MySQL"
.Vb 1
\&        my($admin) = DBIx::Admin::TableInfo \-> new(dbh => $dbh);
\&
\&        In other words, the default values for catalog, schema, table and type will Just Work.
.Ve
.IP "o Oracle" 4
.IX Item "o Oracle"
.Vb 6
\&        my($dbh)   = DBI \-> connect($dsn, $username, $password);
\&        my($admin) = DBIx::Admin::TableInfo \-> new
\&        (
\&                dbh    => $dbh,
\&                schema => uc $username, # Yep, upper case.
\&        );
\&
\&        See the FAQ for which tables are ignored under Oracle.
.Ve
.IP "o PostgreSQL" 4
.IX Item "o PostgreSQL"
.Vb 5
\&        my($admin) = DBIx::Admin::TableInfo \-> new
\&        (
\&                dbh    => $dbh,
\&                schema => \*(Aqpublic\*(Aq,
\&        );
\&
\&        For PostgreSQL, you probably want to ignore table names matching /^(pg_|sql_)/.
\&
\&        As stated above, for \*(Aqold\*(Aq versions of DBD::Pg, use:
\&
\&        my($admin) = DBIx::Admin::TableInfo \-> new
\&        (
\&                dbh    => $dbh,
\&                schema => \*(Aqpublic\*(Aq,
\&                table  => \*(Aqtable\*(Aq, # Yep, lower case.
\&        );
\&
\&        See the FAQ for which tables are ignored under Postgres.
.Ve
.IP "o SQLite" 4
.IX Item "o SQLite"
.Vb 5
\&        my($admin) = DBIx::Admin::TableInfo \-> new
\&        (
\&                dbh    => $dbh,
\&                schema => \*(Aqmain\*(Aq,
\&        );
\&
\&        In other words, the default values for catalog, table and type will Just Work.
\&
\&        See the FAQ for which tables are ignored under SQLite.
.Ve
.PP
See the examples/ directory in the distro.
.SH "FAQ"
.IX Header "FAQ"
.SS "Which versions of the servers did you test?"
.IX Subsection "Which versions of the servers did you test?"
.Vb 12
\&        Versions as at 2014\-08\-06:
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  Vendor  |      V      |
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  MariaDB |   5.5.38    |
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  Oracle  | 10.2.0.1.0  | (Not tested for years)
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        | Postgres |    9.1.3    |
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        |  SQLite  |   3.8.4.1   |
\&        +\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
But see these warnings <https://metacpan.org/pod/DBIx::Admin::TableInfo#Description> when using
MySQL/MariaDB.
.SS "Which tables are ignored for which databases?"
.IX Subsection "Which tables are ignored for which databases?"
Here is the code which skips some tables:
.PP
.Vb 3
\&        next if ( ($vendor eq \*(AqORACLE\*(Aq)     && ($table_name =~ /^BIN\e$.+\e$./) );
\&        next if ( ($vendor eq \*(AqPOSTGRESQL\*(Aq) && ($table_name =~ /^(?:pg_|sql_)/) );
\&        next if ( ($vendor eq \*(AqSQLITE\*(Aq)     && ($table_name eq \*(Aqsqlite_sequence\*(Aq) );
.Ve
.SS "How do I identify foreign keys?"
.IX Subsection "How do I identify foreign keys?"
Note: The table names here come from xt/author/person.spouse.t.
.PP
See \*(L"\s-1FAQ\*(R"\s0 in DBIx::Admin::CreateTable for database server-specific create statements to activate
foreign keys.
.PP
Then try:
.PP
.Vb 1
\&        my($info) = DBIx::Admin::TableInfo \-> new(dbh => $dbh) \-> info;
\&
\&        print Data::Dumper::Concise::Dumper($$info{people}{foreign_keys}), "\en";
.Ve
.PP
Output follows.
.PP
But beware slightly differing spellings depending on the database server. This is documented in
<https://metacpan.org/pod/DBI#foreign_key_info>. Look closely at the usage of the '_' character.
.IP "o MySQL" 4
.IX Item "o MySQL"
.Vb 10
\&        [
\&          {
\&            DEFERABILITY => undef,
\&            DELETE_RULE => undef,
\&            FKCOLUMN_NAME => "spouse_id",
\&            FKTABLE_CAT => "def",
\&            FKTABLE_NAME => "spouses",
\&            FKTABLE_SCHEM => "testdb",
\&            FK_NAME => "spouses_ibfk_2",
\&            KEY_SEQ => 1,
\&            PKCOLUMN_NAME => "id",
\&            PKTABLE_CAT => undef,
\&            PKTABLE_NAME => "people",
\&            PKTABLE_SCHEM => "testdb",
\&            PK_NAME => undef,
\&            UNIQUE_OR_PRIMARY => undef,
\&            UPDATE_RULE => undef
\&          }
\&        ]
.Ve
.Sp
Yes, there is just 1 element in this arrayref. MySQL can sliently drop an index if another index
can be used.
.IP "o Postgres" 4
.IX Item "o Postgres"
.Vb 10
\&        [
\&          {
\&            DEFERABILITY => 7,
\&            DELETE_RULE => 3,
\&            FK_COLUMN_NAME => "person_id",
\&            FK_DATA_TYPE => "int4",
\&            FK_NAME => "spouses_person_id_fkey",
\&            FK_TABLE_CAT => undef,
\&            FK_TABLE_NAME => "spouses",
\&            FK_TABLE_SCHEM => "public",
\&            ORDINAL_POSITION => 1,
\&            UK_COLUMN_NAME => "id",
\&            UK_DATA_TYPE => "int4",
\&            UK_NAME => "people_pkey",
\&            UK_TABLE_CAT => undef,
\&            UK_TABLE_NAME => "people",
\&            UK_TABLE_SCHEM => "public",
\&            UNIQUE_OR_PRIMARY => "PRIMARY",
\&            UPDATE_RULE => 3
\&          },
\&          {
\&            DEFERABILITY => 7,
\&            DELETE_RULE => 3,
\&            FK_COLUMN_NAME => "spouse_id",
\&            FK_DATA_TYPE => "int4",
\&            FK_NAME => "spouses_spouse_id_fkey",
\&            FK_TABLE_CAT => undef,
\&            FK_TABLE_NAME => "spouses",
\&            FK_TABLE_SCHEM => "public",
\&            ORDINAL_POSITION => 1,
\&            UK_COLUMN_NAME => "id",
\&            UK_DATA_TYPE => "int4",
\&            UK_NAME => "people_pkey",
\&            UK_TABLE_CAT => undef,
\&            UK_TABLE_NAME => "people",
\&            UK_TABLE_SCHEM => "public",
\&            UNIQUE_OR_PRIMARY => "PRIMARY",
\&            UPDATE_RULE => 3
\&          }
\&        ]
.Ve
.IP "o SQLite" 4
.IX Item "o SQLite"
.Vb 10
\&        [
\&          {
\&            DEFERABILITY => undef,
\&            DELETE_RULE => 3,
\&            FK_COLUMN_NAME => "spouse_id",
\&            FK_DATA_TYPE => undef,
\&            FK_NAME => undef,
\&            FK_TABLE_CAT => undef,
\&            FK_TABLE_NAME => "spouses",
\&            FK_TABLE_SCHEM => undef,
\&            ORDINAL_POSITION => 0,
\&            UK_COLUMN_NAME => "id",
\&            UK_DATA_TYPE => undef,
\&            UK_NAME => undef,
\&            UK_TABLE_CAT => undef,
\&            UK_TABLE_NAME => "people",
\&            UK_TABLE_SCHEM => undef,
\&            UNIQUE_OR_PRIMARY => undef,
\&            UPDATE_RULE => 3
\&          },
\&          {
\&            DEFERABILITY => undef,
\&            DELETE_RULE => 3,
\&            FK_COLUMN_NAME => "person_id",
\&            FK_DATA_TYPE => undef,
\&            FK_NAME => undef,
\&            FK_TABLE_CAT => undef,
\&            FK_TABLE_NAME => "spouses",
\&            FK_TABLE_SCHEM => undef,
\&            ORDINAL_POSITION => 0,
\&            UK_COLUMN_NAME => "id",
\&            UK_DATA_TYPE => undef,
\&            UK_NAME => undef,
\&            UK_TABLE_CAT => undef,
\&            UK_TABLE_NAME => "people",
\&            UK_TABLE_SCHEM => undef,
\&            UNIQUE_OR_PRIMARY => undef,
\&            UPDATE_RULE => 3
\&          }
\&        ]
.Ve
.PP
You can also play with xt/author/fk.t and xt/author/dsn.ini (especially the 'active' option).
.PP
fk.t does not delete the tables as it exits. This is so xt/author/mysql.fk.pl has something to play
with.
.PP
See also xt/author/person.spouse.t.
.SS "Does DBIx::Admin::TableInfo work with SQLite databases?"
.IX Subsection "Does DBIx::Admin::TableInfo work with SQLite databases?"
Yes. As of V 2.08, this module uses the SQLite code \*(L"pragma foreign_key_list($table_name)\*(R" to
emulate the \s-1DBI\s0 call to foreign_key_info(...).
.ie n .SS "What is returned by the SQLite ""pragma foreign_key_list($table_name)"" call?"
.el .SS "What is returned by the SQLite ``pragma foreign_key_list($table_name)'' call?"
.IX Subsection "What is returned by the SQLite pragma foreign_key_list($table_name) call?"
An arrayref is returned. Indexes and their interpretations:
.PP
.Vb 8
\&        0: COUNT   (0, 1, ...)
\&        1: KEY_SEQ (0, or column # (1, 2, ...) within multi\-column key)
\&        2: PK_TABLE_NAME
\&        3: FK_COLUMN_NAME
\&        4: PK_COLUMN_NAME
\&        5: UPDATE_RULE
\&        6: DELETE_RULE
\&        7: \*(AqNONE\*(Aq (Constant string)
.Ve
.PP
As these are stored in an arrayref, I use $$row[$i] just below to refer to the elements of the
array.
.SS "How are these values mapped into the output?"
.IX Subsection "How are these values mapped into the output?"
See also the next point.
.PP
.Vb 8
\&        my(%referential_action) =
\&        (
\&                \*(AqCASCADE\*(Aq     => 0,
\&                \*(AqRESTRICT\*(Aq    => 1,
\&                \*(AqSET NULL\*(Aq    => 2,
\&                \*(AqNO ACTION\*(Aq   => 3,
\&                \*(AqSET DEFAULT\*(Aq => 4,
\&        );
.Ve
.PP
The hashref returned for foreign keys contains these key-value pairs:
.PP
.Vb 10
\&        {
\&                DEFERABILITY      => undef,
\&                DELETE_RULE       => $referential_action{$$row[6]},
\&                FK_COLUMN_NAME    => $$row[3],
\&                FK_DATA_TYPE      => undef,
\&                FK_NAME           => undef,
\&                FK_TABLE_CAT      => undef,
\&                FK_TABLE_NAME     => $table_name,
\&                FK_TABLE_SCHEM    => undef,
\&                ORDINAL_POSITION  => $$row[1],
\&                UK_COLUMN_NAME    => $$row[4],
\&                UK_DATA_TYPE      => undef,
\&                UK_NAME           => undef,
\&                UK_TABLE_CAT      => undef,
\&                UK_TABLE_NAME     => $$row[2],
\&                UK_TABLE_SCHEM    => undef,
\&                UNIQUE_OR_PRIMARY => undef,
\&                UPDATE_RULE       => $referential_action{$$row[5]},
\&        }
.Ve
.PP
This list of keys matches what is returned when processing a Postgres database.
.SS "Have you got \s-1FK\s0 and \s-1PK\s0 backwards?"
.IX Subsection "Have you got FK and PK backwards?"
I certainly hope not. To me the \s-1FK_TABLE_NAME\s0 points to the \s-1UK_TABLE_NAME.\s0
.PP
The \*(L"pragma foreign_key_list($table_name)\*(R" call for SQLite returns data from the create statement,
and thus it reports what the given table points to. The \s-1DBI\s0 call to foreign_key_info(...) returns
data about foreign keys referencing (pointing to) the given table. This can be confusing.
.PP
Here is a method from the module App::Office::Contacts::Util::Create, part of
App::Office::Contacts.
.PP
.Vb 10
\&        sub create_organizations_table
\&        {
\&                my($self)        = @_;
\&                my($table_name)  = \*(Aqorganizations\*(Aq;
\&                my($primary_key) = $self \-> creator \-> generate_primary_key_sql($table_name);
\&                my($engine)      = $self \-> engine;
\&                my($result)      = $self \-> creator \-> create_table(<<SQL);
\&create table $table_name
\&(
\&        id $primary_key,
\&        visibility_id integer not null references visibilities(id),
\&        communication_type_id integer not null references communication_types(id),
\&        creator_id integer not null,
\&        role_id integer not null references roles(id),
\&        deleted integer not null,
\&        facebook_tag varchar(255) not null,
\&        homepage varchar(255) not null,
\&        name varchar(255) not null,
\&        timestamp timestamp not null default localtimestamp,
\&        twitter_tag varchar(255) not null,
\&        upper_name varchar(255) not null
\&) $engine
\&SQL
\&
\&                $self \-> dbh \-> do("create index ${table_name}_upper_name on $table_name (upper_name)");
\&
\&                $self \-> report($table_name, \*(Aqcreated\*(Aq, $result);
\&
\&        }       # End of create_organizations_table.
.Ve
.PP
Consider this line:
.PP
.Vb 1
\&        visibility_id integer not null references visibilities(id),
.Ve
.PP
That means, for the 'visibilities' table, the \fBinfo()\fR method in the current module will return a
hashref like:
.PP
.Vb 10
\&        {
\&                visibilities =>
\&                {
\&                        ...
\&                        foreign_keys =>
\&                        {
\&                                ...
\&                                organizations =>
\&                                {
\&                                        UK_COLUMN_NAME    => \*(Aqid\*(Aq,
\&                                        DEFERABILITY      => undef,
\&                                        ORDINAL_POSITION  => 0,
\&                                        FK_TABLE_CAT      => undef,
\&                                        UK_NAME           => undef,
\&                                        UK_DATA_TYPE      => undef,
\&                                        UNIQUE_OR_PRIMARY => undef,
\&                                        UK_TABLE_SCHEM    => undef,
\&                                        UK_TABLE_CAT      => undef,
\&                                        FK_COLUMN_NAME    => \*(Aqvisibility_id\*(Aq,
\&                                        FK_TABLE_NAME     => \*(Aqorganizations\*(Aq,
\&                                        FK_TABLE_SCHEM    => undef,
\&                                        FK_DATA_TYPE      => undef,
\&                                        UK_TABLE_NAME     => \*(Aqvisibilities\*(Aq,
\&                                        DELETE_RULE       => 3,
\&                                        FK_NAME           => undef,
\&                                        UPDATE_RULE       => 3
\&                                },
\&                        },
\&        }
.Ve
.PP
This is saying that for the table 'visibilities', there is a foreign key in the 'organizations'
table. That foreign key is called 'visibility_id', and it points to the key called 'id' in the
\&'visibilities' table.
.SS "How do I use schemas in Postgres?"
.IX Subsection "How do I use schemas in Postgres?"
You may need to do something like this:
.PP
.Vb 1
\&        $dbh \-> do("set search_path to $ENV{DBI_SCHEMA}") if ($ENV{DBI_SCHEMA});
.Ve
.PP
\&\f(CW$ENV\fR{\s-1DBI_SCHEMA\s0} can be a comma-separated list, as in:
.PP
.Vb 1
\&        $dbh \-> do("set search_path to my_schema, public");
.Ve
.PP
See DBD::Pg for details.
.SS "See Also"
.IX Subsection "See Also"
DBIx::Admin::CreateTable.
.PP
DBIx::Admin::DSNManager.
.SH "Version Numbers"
.IX Header "Version Numbers"
Version numbers < 1.00 represent development versions. From 1.00 up, they are production versions.
.SH "Repository"
.IX Header "Repository"
<https://github.com/ronsavage/DBIx\-Admin\-TableInfo>
.SH "Support"
.IX Header "Support"
Log a bug on \s-1RT:\s0 <https://rt.cpan.org/Public/Dist/Display.html?Name=DBIx\-Admin\-TableInfo>.
.SH "Author"
.IX Header "Author"
\&\f(CW\*(C`DBIx::Admin::TableInfo\*(C'\fR was written by Ron Savage \fI<ron@savage.net.au>\fR in 2004.
.PP
Home page: http://savage.net.au/index.html
.SH "Copyright"
.IX Header "Copyright"
Australian copyright (c) 2004, Ron Savage.
.PP
.Vb 4
\&        All Programs of mine are \*(AqOSI Certified Open Source Software\*(Aq;
\&        you can redistribute them and/or modify them under the terms of
\&        The Perl License, a copy of which is available at:
\&        http://www.opensource.org/licenses/index.html
.Ve
