.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Syntax::Keyword::Try 3"
.TH Syntax::Keyword::Try 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Syntax::Keyword::Try" \- a "try/catch/finally" syntax for perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Syntax::Keyword::Try;
\&
\&   sub foo {
\&      try {
\&         attempt_a_thing();
\&         return "success";
\&      }
\&      catch ($e) {
\&         warn "It failed \- $e";
\&         return "failure";
\&      }
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a syntax plugin that implements exception-handling
semantics in a form familiar to users of other languages, being built on a
block labeled with the \f(CW\*(C`try\*(C'\fR keyword, followed by at least one of a \f(CW\*(C`catch\*(C'\fR
or \f(CW\*(C`finally\*(C'\fR block.
.PP
As well as providing a handy syntax for this useful behaviour, this module
also serves to contain a number of code examples for how to implement parser
plugins and manipulate optrees to provide new syntax and behaviours for perl
code.
.SH "Experimental Features"
.IX Header "Experimental Features"
Some of the features of this module are currently marked as experimental. They
will provoke warnings in the \f(CW\*(C`experimental\*(C'\fR category, unless silenced.
.PP
You can silence this with \f(CW\*(C`no warnings \*(Aqexperimental\*(Aq\*(C'\fR but then that will
silence every experimental warning, which may hide others unintentionally. For
a more fine-grained approach you can instead use the import line for this
module to only silence this module's warnings selectively:
.PP
.Vb 1
\&   use Syntax::Keyword::Try qw( try :experimental(typed) );
\&
\&   use Syntax::Keyword::Try qw( try :experimental );  # all of the above
.Ve
.PP
Don't forget to import the main \f(CW\*(C`try\*(C'\fR symbol itself, to activate the syntax.
.SH "KEYWORDS"
.IX Header "KEYWORDS"
.SS "try"
.IX Subsection "try"
.Vb 4
\&   try {
\&      STATEMENTS...
\&   }
\&   ...
.Ve
.PP
A \f(CW\*(C`try\*(C'\fR statement provides the main body of code that will be invoked, and
must be followed by either a \f(CW\*(C`catch\*(C'\fR statement, a \f(CW\*(C`finally\*(C'\fR statement, or
both.
.PP
Execution of the \f(CW\*(C`try\*(C'\fR statement itself begins from the block given to the
statement and continues until either it throws an exception, or completes
successfully by reaching the end of the block. What will happen next depends
on the presence of a \f(CW\*(C`catch\*(C'\fR or \f(CW\*(C`finally\*(C'\fR statement immediately following
it.
.PP
The body of a \f(CW\*(C`try {}\*(C'\fR block may contain a \f(CW\*(C`return\*(C'\fR expression. If executed,
such an expression will cause the entire containing function to return with
the value provided. This is different from a plain \f(CW\*(C`eval {}\*(C'\fR block, in which
circumstance only the \f(CW\*(C`eval\*(C'\fR itself would return, not the entire function.
.PP
The body of a \f(CW\*(C`try {}\*(C'\fR block may contain loop control expressions (\f(CW\*(C`redo\*(C'\fR,
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR) which will have their usual effect on any loops that the
\&\f(CW\*(C`try {}\*(C'\fR block is contained by.
.PP
The parsing rules for the set of statements (the \f(CW\*(C`try\*(C'\fR block and its
associated \f(CW\*(C`catch\*(C'\fR and \f(CW\*(C`finally\*(C'\fR) are such that they are parsed as a self\-
contained statement. Because of this, there is no need to end with a
terminating semicolon.
.PP
Note (especially to users of Try::Tiny and similar) that the \f(CW\*(C`try {}\*(C'\fR
block itself does not necessarily stop exceptions thrown inside it from
propagating outside. It is the presence of a later \f(CW\*(C`catch {}\*(C'\fR block which
causes this to happen. A \f(CW\*(C`try\*(C'\fR with only a \f(CW\*(C`finally\*(C'\fR and no \f(CW\*(C`catch\*(C'\fR will
still propagate exceptions up to callers as normal.
.SS "catch"
.IX Subsection "catch"
.Vb 4
\&   ...
\&   catch ($var) {
\&      STATEMENTS...
\&   }
.Ve
.PP
or
.PP
.Vb 4
\&   ...
\&   catch {
\&      STATEMENTS...
\&   }
.Ve
.PP
A \f(CW\*(C`catch\*(C'\fR statement provides a block of code to the preceding \f(CW\*(C`try\*(C'\fR
statement that will be invoked in the case that the main block of code throws
an exception. Optionally a new lexical variable can be provided to store the
exception in. If not provided, the \f(CW\*(C`catch\*(C'\fR block can inspect the raised
exception by looking in \f(CW$@\fR instead.
.PP
Presence of this \f(CW\*(C`catch\*(C'\fR statement causes any exception thrown by the
preceding \f(CW\*(C`try\*(C'\fR block to be non-fatal to the surrounding code. If the
\&\f(CW\*(C`catch\*(C'\fR block wishes to optionally handle some exceptions but not others, it
can re-raise it (or another exception) by calling \f(CW\*(C`die\*(C'\fR in the usual manner.
.PP
As with \f(CW\*(C`try\*(C'\fR, the body of a \f(CW\*(C`catch {}\*(C'\fR block may also contain a \f(CW\*(C`return\*(C'\fR
expression, which as before, has its usual meaning, causing the entire
containing function to return with the given value. The body may also contain
loop control expressions (\f(CW\*(C`redo\*(C'\fR, \f(CW\*(C`next\*(C'\fR or \f(CW\*(C`last\*(C'\fR) which also have their
usual effect.
.PP
If a \f(CW\*(C`catch\*(C'\fR statement is not given, then any exceptions raised by the \f(CW\*(C`try\*(C'\fR
block are raised to the caller in the usual way.
.SS "catch (Typed)"
.IX Subsection "catch (Typed)"
.Vb 2
\&   ...
\&   catch ($var isa Class) { ... }
\&
\&   ...
\&   catch ($var =~ m/^Regexp match/) { ... }
.Ve
.PP
\&\fIExperimental; since version 0.15.\fR
.PP
Optionally, multiple catch statements can be provided, where each block is
given a guarding condition, to control whether or not it will catch particular
exception values. Use of this syntax will provoke an \f(CW\*(C`experimental\*(C'\fR category
warning on supporting perl versions, unless silenced by importing the
\&\f(CW\*(C`:experimental(typed)\*(C'\fR tag (see above).
.PP
Two kinds of condition are supported:
.IP "\(bu" 4

.Sp
.Vb 1
\&   catch ($var isa Class)
.Ve
.Sp
The block is invoked only if the caught exception is a blessed object, and
derives from the given package name.
.Sp
On Perl version 5.32 onwards, this condition test is implemented using the
same op type that the core \f(CW\*(C`$var isa Class\*(C'\fR syntax is provided by and works
in exactly the same way.
.Sp
On older perl versions it is emulated by a compatibility function. Currently
this function does not respect a \f(CW\*(C`\->isa\*(C'\fR method overload on the exception
instance. Usually this should not be a problem, as exception class types
rarely provide such a method.
.IP "\(bu" 4

.Sp
.Vb 1
\&   catch ($var =~ m/regexp/)
.Ve
.Sp
The block is invoked only if the caught exception is a string that matches
the given regexp.
.PP
When an exception is caught, each condition is tested in the order they are
written in, until a matching case is found. If such a case is found the
corresponding block is invoked, and no further condition is tested. If no
contional block matched and there is a default (unconditional) block at the
end then that is invoked instead. If no such block exists, then the exception
is propagated up to the calling scope.
.SS "finally"
.IX Subsection "finally"
.Vb 4
\&   ...
\&   finally {
\&      STATEMENTS...
\&   }
.Ve
.PP
A \f(CW\*(C`finally\*(C'\fR statement provides a block of code to the preceding \f(CW\*(C`try\*(C'\fR
statement (or \f(CW\*(C`try/catch\*(C'\fR pair) which is executed afterwards, both in the
case of a normal execution or a thrown exception. This code block may be used
to provide whatever clean-up operations might be required by preceding code.
.PP
Because it is executed during a stack cleanup operation, a \f(CW\*(C`finally {}\*(C'\fR block
may not cause the containing function to return, or to alter the return value
of it. It also cannot see the containing function's \f(CW@_\fR arguments array
(though as it is block scoped within the function, it will continue to share
any normal lexical variables declared up until that point). It is protected
from disturbing the value of \f(CW$@\fR. If the \f(CW\*(C`finally {}\*(C'\fR block code throws an
exception, this will be printed as a warning and discarded, leaving \f(CW$@\fR
containing the original exception, if one existed.
.SH "VALUE SEMANTICS"
.IX Header "VALUE SEMANTICS"
.RS 4
\&\fBWarning:\fR the feature described in this section is experimental. This
experiment may be stablised in a later version, or may be altered or removed
without further notice. It is present here for testing and evaluation
purposes.
.Sp
Additionally, on \fIperl\fR versions 5.18 and later, it will produce a warning
in the \f(CW\*(C`experimental\*(C'\fR category.
.RE
.PP
The syntax provided by this module may be used as a value-yielding expression.
Because this syntax is new, experimental, and somewhat surprising, it must be
specifically requested by name \f(CW\*(C`try_value\*(C'\fR:
.PP
.Vb 1
\&   use Syntax::Keyword::Try qw( try try_value );
\&
\&   my $result = try do { ... } catch { ... };
.Ve
.PP
Also, on Perl versions 5.24 and later:
.PP
.Vb 1
\&   my $result = try do { ... } finally { ... };
\&
\&   my $result = try do { ... } catch { ... } finally { ... };
.Ve
.PP
Specifically, note that the expression must be spelled as \f(CW\*(C`try do { ... }\*(C'\fR so
that the syntax is distinct from that used by control-flow statements. The
interposed \f(CW\*(C`do\*(C'\fR keyword reminds the reader, and instructs the syntax parser,
that this will be an expression, not a statement. It is not necessary to
similarly notate the \f(CW\*(C`catch\*(C'\fR or \f(CW\*(C`finally\*(C'\fR blocks.
.PP
In this case, the syntax behaves syntactically like an expression, and may
appear anywhere a normal expression is allowed. It follows similar semantics
to the purely control-flow case; if the code in the \f(CW\*(C`try\*(C'\fR block does not
throw an exception, then the expression as a whole yields whatever value the
\&\f(CW\*(C`try\*(C'\fR expression did. If it fails, then the \f(CW\*(C`catch\*(C'\fR block is executed and
the expression yields its resulting value instead. A \f(CW\*(C`finally\*(C'\fR block, if
present, will be evaluated for side-effects before the rest of the expression
returns.
.PP
Remember that, as in the control-flow case, the \f(CW\*(C`return\*(C'\fR keyword will cause
the entire containing function to return, not just the \f(CW\*(C`try\*(C'\fR block.
.SH "OTHER MODULES"
.IX Header "OTHER MODULES"
There are already quite a number of modules on \s-1CPAN\s0 that provide a
\&\f(CW\*(C`try/catch\*(C'\fR\-like syntax for Perl.
.IP "\(bu" 2
Try
.IP "\(bu" 2
TryCatch
.IP "\(bu" 2
Try::Tiny
.IP "\(bu" 2
Syntax::Feature::Try
.PP
They are compared here, by feature:
.SS "True syntax plugin"
.IX Subsection "True syntax plugin"
Like Try and Syntax::Feature::Try, this module is implemented as a true
syntax plugin, allowing it to provide new parsing rules not available to
simple functions. Most notably here it means that the resulting combination
does not need to end in a semicolon.
.PP
In comparison, Try::Tiny is plain perl and provides its functionality using
regular perl functions; as such its syntax requires the trailing semicolon.
.PP
TryCatch is a hybrid that uses Devel::Declare to parse the syntax tree.
.ie n .SS "@_ in a try or catch block"
.el .SS "\f(CW@_\fP in a try or catch block"
.IX Subsection "@_ in a try or catch block"
Because the \f(CW\*(C`try\*(C'\fR and \f(CW\*(C`catch\*(C'\fR block code is contained in a true block rather
than an entire anonymous subroutine, invoking it does not interfere with the
\&\f(CW@_\fR arguments array. Code inside these blocks can interact with the
containing function's array as before.
.PP
This feature is unique among these modules; none of the others listed have
this ability.
.ie n .SS """return"" in a try or catch block"
.el .SS "\f(CWreturn\fP in a try or catch block"
.IX Subsection "return in a try or catch block"
Like TryCatch and Syntax::Feature::Try, the \f(CW\*(C`return\*(C'\fR statement has its
usual effect within a subroutine containing syntax provided by this module.
Namely, it causes the containing \f(CW\*(C`sub\*(C'\fR itself to return.
.PP
In comparison, using Try or Try::Tiny mean that a \f(CW\*(C`return\*(C'\fR statement
will only exit from the \f(CW\*(C`try\*(C'\fR block.
.ie n .SS """next""/""last""/""redo"" in a try or catch block"
.el .SS "\f(CWnext\fP/\f(CWlast\fP/\f(CWredo\fP in a try or catch block"
.IX Subsection "next/last/redo in a try or catch block"
The loop control keywords of \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR and \f(CW\*(C`redo\*(C'\fR have their usual
effect on dynamically contained loops.
.PP
Syntax::Feature::Try documents that these do not work there. The other
modules make no statement either way.
.SS "Value Semantics"
.IX Subsection "Value Semantics"
Like Try and Syntax::Feature::Try, the syntax provided by this module
only works as a syntax-level statement and not an expression when the
experimental \f(CW\*(C`try_value\*(C'\fR feature described above has not been enabled. You
cannot assign from the result of a \f(CW\*(C`try\*(C'\fR block. Additionally,
final-expression value semantics do not work, so it cannot be contained by a
\&\f(CW\*(C`do\*(C'\fR block to yield this value.
.PP
In comparison, the behaviour implemented by Try::Tiny can be used as a
valued expression, such as assigned to a variable or returned to the caller of
its containing function. Such ability is provided by this module if the
experimental \f(CW\*(C`try_value\*(C'\fR feature is enabled, though it must be spelled
differently as \f(CW\*(C`try do { ... }\*(C'\fR.
.ie n .SS """try"" without ""catch"""
.el .SS "\f(CWtry\fP without \f(CWcatch\fP"
.IX Subsection "try without catch"
Like Syntax::Feature::Try, the syntax provided by this module allows a
\&\f(CW\*(C`try\*(C'\fR block to be followed by only a \f(CW\*(C`finally\*(C'\fR block, with no \f(CW\*(C`catch\*(C'\fR. In
this case, exceptions thrown by code contained by the \f(CW\*(C`try\*(C'\fR are not
suppressed, instead they propagate as normal to callers. This matches the
behaviour familiar to Java or \*(C+ programmers.
.PP
In comparison, the code provided by Try and Try::Tiny always suppress
exception propagation even without an actual \f(CW\*(C`catch\*(C'\fR block.
.PP
The TryCatch module does not allow a \f(CW\*(C`try\*(C'\fR block not followed by \f(CW\*(C`catch\*(C'\fR.
.ie n .SS "Typed ""catch"""
.el .SS "Typed \f(CWcatch\fP"
.IX Subsection "Typed catch"
Try and Try::Tiny make no attempt to perform any kind of typed dispatch
to distinguish kinds of exception caught by \f(CW\*(C`catch\*(C'\fR blocks.
.PP
TryCatch and Syntax::Feature::Try both attempt to provide a kind of
typed dispatch where different classes of exception are caught by different
blocks of code, or propagated up entirely to callers.
.PP
This module provides such an ability, via the currently-experimental
\&\f(CW\*(C`catch (VAR cond...)\*(C'\fR syntax.
.PP
The design thoughts continue on the \s-1RT\s0 ticket
<https://rt.cpan.org/Ticket/Display.html?id=123918>.
.SH "WITH OTHER MODULES"
.IX Header "WITH OTHER MODULES"
.SS "Future::AsyncAwait"
.IX Subsection "Future::AsyncAwait"
As of \f(CW\*(C`Future::AsyncAwait\*(C'\fR version 0.10 and Syntax::Keyword::Try version
0.07, cross-module integration tests assert that basic \f(CW\*(C`try/catch\*(C'\fR blocks
inside an \f(CW\*(C`async sub\*(C'\fR work correctly, including those that attempt to
\&\f(CW\*(C`return\*(C'\fR from inside \f(CW\*(C`try\*(C'\fR.
.PP
.Vb 2
\&   use Future::AsyncAwait;
\&   use Syntax::Keyword::Try;
\&
\&   async sub attempt
\&   {
\&      try {
\&         await func();
\&         return "success";
\&      }
\&      catch {
\&         return "failed";
\&      }
\&   }
.Ve
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
.SS "Thread-safety at load time cannot be assured before perl 5.16"
.IX Subsection "Thread-safety at load time cannot be assured before perl 5.16"
On \fIperl\fR versions 5.16 and above this module is thread-safe.
.PP
On \fIperl\fR version 5.14 this module is thread-safe provided that it is
\&\f(CW\*(C`use\*(C'\fRd before any additional threads are created.
.PP
However, when using 5.14 there is a race condition if this module is loaded
late in the program startup, after additional threads have been created. This
leads to the potential for it to be started up multiple times concurrently,
which creates data races when modifying internal structures and likely leads
to a segmentation fault, either during load or soon after when more code is
compiled.
.PP
As a workaround, for any such program that creates multiple threads, loads
additional code (such as dynamically-discovered plugins), and has to run on
5.14, it should make sure to
.PP
.Vb 1
\&   use Syntax::Keyword::Try;
.Ve
.PP
early on in startup, before it spins out any additional threads.
.PP
(See also <https://rt.cpan.org/Public/Bug/Display.html?id=123547>)
.ie n .SS "$@ is not local'ised by ""try do"" before perl 5.24"
.el .SS "$@ is not local'ised by \f(CWtry do\fP before perl 5.24"
.IX Subsection "$@ is not local'ised by try do before perl 5.24"
On \fIperl\fR versions 5.24 and above, or when using only control-flow statement
syntax, \f(CW$@\fR is always correctly \f(CW\*(C`local\*(C'\fRised.
.PP
However, when using the experimental value-yielding expression version
\&\f(CW\*(C`try do {...}\*(C'\fR on perl versions 5.22 or older, the \f(CW\*(C`local\*(C'\fRisation of \f(CW$@\fR
does not correctly apply around the expression. After such an expression, the
value of \f(CW$@\fR will leak out if a failure happened and the \f(CW\*(C`catch\*(C'\fR block was
invoked, overwriting any previous value that was visible there.
.PP
(See also <https://rt.cpan.org/Public/Bug/Display.html?id=124366>)
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
With thanks to \f(CW\*(C`Zefram\*(C'\fR, \f(CW\*(C`ilmari\*(C'\fR and others from \f(CW\*(C`irc.perl.org/#p5p\*(C'\fR for
assisting with trickier bits of \s-1XS\s0 logic.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
