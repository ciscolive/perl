.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MCE::Step 3"
.TH MCE::Step 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MCE::Step \- Parallel step model for building creative steps
.SH "VERSION"
.IX Header "VERSION"
This document describes MCE::Step version 1.874
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
MCE::Step is similar to MCE::Flow for writing custom apps. The main
difference comes from the transparent use of queues between sub-tasks.
\&\s-1MCE 1.7\s0 adds mce_enq, mce_enqp, and mce_await methods described under
QUEUE-LIKE \s-1FEATURES\s0 below.
.PP
It is trivial to parallelize with mce_stream shown below.
.PP
.Vb 2
\& ## Native map function
\& my @a = map { $_ * 4 } map { $_ * 3 } map { $_ * 2 } 1..10000;
\&
\& ## Same as with MCE::Stream (processing from right to left)
\& @a = mce_stream
\&      sub { $_ * 4 }, sub { $_ * 3 }, sub { $_ * 2 }, 1..10000;
\&
\& ## Pass an array reference to have writes occur simultaneously
\& mce_stream \e@a,
\&      sub { $_ * 4 }, sub { $_ * 3 }, sub { $_ * 2 }, 1..10000;
.Ve
.PP
However, let's have MCE::Step compute the same in parallel. Unlike the example
in MCE::Flow, the use of MCE::Queue is totally transparent. This calls for
preserving output order provided by MCE::Candy.
.PP
.Vb 2
\& use MCE::Step;
\& use MCE::Candy;
.Ve
.PP
Next are the 3 sub-tasks. Compare these 3 sub-tasks with the same as described
in MCE::Flow. The call to \s-1MCE\-\s0>step simplifies the passing of data to
subsequent sub-task.
.PP
.Vb 5
\& sub task_a {
\&    my @ans; my ($mce, $chunk_ref, $chunk_id) = @_;
\&    push @ans, map { $_ * 2 } @{ $chunk_ref };
\&    MCE\->step(\e@ans, $chunk_id);
\& }
\&
\& sub task_b {
\&    my @ans; my ($mce, $chunk_ref, $chunk_id) = @_;
\&    push @ans, map { $_ * 3 } @{ $chunk_ref };
\&    MCE\->step(\e@ans, $chunk_id);
\& }
\&
\& sub task_c {
\&    my @ans; my ($mce, $chunk_ref, $chunk_id) = @_;
\&    push @ans, map { $_ * 4 } @{ $chunk_ref };
\&    MCE\->gather($chunk_id, \e@ans);
\& }
.Ve
.PP
In summary, MCE::Step builds out a \s-1MCE\s0 instance behind the scene and starts
running. The task_name (shown), max_workers, and use_threads options can take
an anonymous array for specifying the values uniquely per each sub-task.
.PP
The task_name option is required to use \->enq, \->enqp, and \->await.
.PP
.Vb 1
\& my @a;
\&
\& mce_step {
\&    task_name => [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq ],
\&    gather => MCE::Candy::out_iter_array(\e@a)
\&
\& }, \e&task_a, \e&task_b, \e&task_c, 1..10000;
\&
\& print "@a\en";
.Ve
.SH "STEP DEMO"
.IX Header "STEP DEMO"
In the demonstration below, one may call \->gather or \->step any number of times
although \->step is not allowed in the last sub-block. Data is gathered to \f(CW@arr\fR
which may likely be out-of-order. Gathering data is optional. All sub-blocks
receive \f(CW$mce\fR as the first argument.
.PP
First, defining 3 sub-tasks.
.PP
.Vb 1
\& use MCE::Step;
\&
\& sub task_a {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&
\&    if ($_ % 2 == 0) {
\&       MCE\->gather($_);
\&     # MCE\->gather($_ * 4);        ## Ok to gather multiple times
\&    }
\&    else {
\&       MCE\->print("a step: $_, $_ * $_\en");
\&       MCE\->step($_, $_ * $_);
\&     # MCE\->step($_, $_ * 4 );     ## Ok to step multiple times
\&    }
\& }
\&
\& sub task_b {
\&    my ($mce, $arg1, $arg2) = @_;
\&
\&    MCE\->print("b args: $arg1, $arg2\en");
\&
\&    if ($_ % 3 == 0) {             ## $_ is the same as $arg1
\&       MCE\->gather($_);
\&    }
\&    else {
\&       MCE\->print("b step: $_ * $_\en");
\&       MCE\->step($_ * $_);
\&    }
\& }
\&
\& sub task_c {
\&    my ($mce, $arg1) = @_;
\&
\&    MCE\->print("c: $_\en");
\&    MCE\->gather($_);
\& }
.Ve
.PP
Next, pass \s-1MCE\s0 options, using chunk_size 1, and run all 3 tasks in parallel.
Notice how max_workers and use_threads can take an anonymous array, similarly
to task_name.
.PP
.Vb 5
\& my @arr = mce_step {
\&    task_name   => [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq ],
\&    max_workers => [  2,   2,   2  ],
\&    use_threads => [  0,   0,   0  ],
\&    chunk_size  => 1
\&
\& }, \e&task_a, \e&task_b, \e&task_c, 1..10;
.Ve
.PP
Finally, sort the array and display its contents.
.PP
.Vb 1
\& @arr = sort { $a <=> $b } @arr;
\&
\& print "\en@arr\en\en";
\&
\& \-\- Output
\&
\& a step: 1, 1 * 1
\& a step: 3, 3 * 3
\& a step: 5, 5 * 5
\& a step: 7, 7 * 7
\& a step: 9, 9 * 9
\& b args: 1, 1
\& b step: 1 * 1
\& b args: 3, 9
\& b args: 7, 49
\& b step: 7 * 7
\& b args: 5, 25
\& b step: 5 * 5
\& b args: 9, 81
\& c: 1
\& c: 49
\& c: 25
\&
\& 1 2 3 4 6 8 9 10 25 49
.Ve
.SH "SYNOPSIS when CHUNK_SIZE EQUALS 1"
.IX Header "SYNOPSIS when CHUNK_SIZE EQUALS 1"
Although MCE::Loop may be preferred for running using a single code block,
the text below also applies to this module, particularly for the first block.
.PP
All models in \s-1MCE\s0 default to 'auto' for chunk_size. The arguments for the block
are the same as writing a user_func block using the Core \s-1API.\s0
.PP
Beginning with \s-1MCE 1.5,\s0 the next input item is placed into the input scalar
variable \f(CW$_\fR when chunk_size equals 1. Otherwise, \f(CW$_\fR points to \f(CW$chunk_ref\fR
containing many items. Basically, line 2 below may be omitted from your code
when using \f(CW$_\fR. One can call \s-1MCE\-\s0>chunk_id to obtain the current chunk id.
.PP
.Vb 9
\& line 1:  user_func => sub {
\& line 2:     my ($mce, $chunk_ref, $chunk_id) = @_;
\& line 3:
\& line 4:     $_ points to $chunk_ref\->[0]
\& line 5:        in MCE 1.5 when chunk_size == 1
\& line 6:
\& line 7:     $_ points to $chunk_ref
\& line 8:        in MCE 1.5 when chunk_size  > 1
\& line 9:  }
.Ve
.PP
Follow this synopsis when chunk_size equals one. Looping is not required from
inside the first block. Hence, the block is called once per each item.
.PP
.Vb 2
\& ## Exports mce_step, mce_step_f, and mce_step_s
\& use MCE::Step;
\&
\& MCE::Step\->init(
\&    chunk_size => 1
\& );
\&
\& ## Array or array_ref
\& mce_step sub { do_work($_) }, 1..10000;
\& mce_step sub { do_work($_) }, \e@list;
\&
\& ## Important; pass an array_ref for deeply input data
\& mce_step sub { do_work($_) }, [ [ 0, 1 ], [ 0, 2 ], ... ];
\& mce_step sub { do_work($_) }, \e@deeply_list;
\&
\& ## File path, glob ref, IO::All::{ File, Pipe, STDIO } obj, or scalar ref
\& ## Workers read directly and not involve the manager process
\& mce_step_f sub { chomp; do_work($_) }, "/path/to/file"; # efficient
\&
\& ## Involves the manager process, therefore slower
\& mce_step_f sub { chomp; do_work($_) }, $file_handle;
\& mce_step_f sub { chomp; do_work($_) }, $io;
\& mce_step_f sub { chomp; do_work($_) }, \e$scalar;
\&
\& ## Sequence of numbers (begin, end [, step, format])
\& mce_step_s sub { do_work($_) }, 1, 10000, 5;
\& mce_step_s sub { do_work($_) }, [ 1, 10000, 5 ];
\&
\& mce_step_s sub { do_work($_) }, {
\&    begin => 1, end => 10000, step => 5, format => undef
\& };
.Ve
.SH "SYNOPSIS when CHUNK_SIZE is GREATER THAN 1"
.IX Header "SYNOPSIS when CHUNK_SIZE is GREATER THAN 1"
Follow this synopsis when chunk_size equals 'auto' or greater than 1.
This means having to loop through the chunk from inside the first block.
.PP
.Vb 1
\& use MCE::Step;
\&
\& MCE::Step\->init(           ## Chunk_size defaults to \*(Aqauto\*(Aq when
\&    chunk_size => \*(Aqauto\*(Aq    ## not specified. Therefore, the init
\& );                         ## function may be omitted.
\&
\& ## Syntax is shown for mce_step for demonstration purposes.
\& ## Looping inside the block is the same for mce_step_f and
\& ## mce_step_s.
\&
\& ## Array or array_ref
\& mce_step sub { do_work($_) for (@{ $_ }) }, 1..10000;
\& mce_step sub { do_work($_) for (@{ $_ }) }, \e@list;
\&
\& ## Important; pass an array_ref for deeply input data
\& mce_step sub { do_work($_) for (@{ $_ }) }, [ [ 0, 1 ], [ 0, 2 ], ... ];
\& mce_step sub { do_work($_) for (@{ $_ }) }, \e@deeply_list;
\&
\& ## Resembles code using the core MCE API
\& mce_step sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&
\&    for (@{ $chunk_ref }) {
\&       do_work($_);
\&    }
\&
\& }, 1..10000;
.Ve
.PP
Chunking reduces the number of \s-1IPC\s0 calls behind the scene. Think in terms of
chunks whenever processing a large amount of data. For relatively small data,
choosing 1 for chunk_size is fine.
.SH "OVERRIDING DEFAULTS"
.IX Header "OVERRIDING DEFAULTS"
The following list options which may be overridden when loading the module.
The fast option is obsolete in 1.867 onwards; ignored if specified.
.PP
.Vb 3
\& use Sereal qw( encode_sereal decode_sereal );
\& use CBOR::XS qw( encode_cbor decode_cbor );
\& use JSON::XS qw( encode_json decode_json );
\&
\& use MCE::Step
\&     max_workers => 8,                # Default \*(Aqauto\*(Aq
\&     chunk_size => 500,               # Default \*(Aqauto\*(Aq
\&     tmp_dir => "/path/to/app/tmp",   # $MCE::Signal::tmp_dir
\&     freeze => \e&encode_sereal,       # \e&Storable::freeze
\&     thaw => \e&decode_sereal,         # \e&Storable::thaw
\&     fast => 1                        # Default 0 (fast dequeue)
\& ;
.Ve
.PP
From \s-1MCE 1.8\s0 onwards, Sereal 3.015+ is loaded automatically if available.
Specify \f(CW\*(C`Sereal => 0\*(C'\fR to use Storable instead.
.PP
.Vb 1
\& use MCE::Step Sereal => 0;
.Ve
.SH "CUSTOMIZING MCE"
.IX Header "CUSTOMIZING MCE"
.IP "MCE::Step\->init ( options )" 3
.IX Item "MCE::Step->init ( options )"
.PD 0
.IP "MCE::Step::init { options }" 3
.IX Item "MCE::Step::init { options }"
.PD
.PP
The init function accepts a hash of \s-1MCE\s0 options. Unlike with MCE::Stream,
both gather and bounds_only options may be specified when calling init
(not shown below).
.PP
.Vb 1
\& use MCE::Step;
\&
\& MCE::Step\->init(
\&    chunk_size => 1, max_workers => 4,
\&
\&    user_begin => sub {
\&       print "## ", MCE\->wid, " started\en";
\&    },
\&
\&    user_end => sub {
\&       print "## ", MCE\->wid, " completed\en";
\&    }
\& );
\&
\& my %a = mce_step sub { MCE\->gather($_, $_ * $_) }, 1..100;
\&
\& print "\en", "@a{1..100}", "\en";
\&
\& \-\- Output
\&
\& ## 3 started
\& ## 1 started
\& ## 4 started
\& ## 2 started
\& ## 3 completed
\& ## 4 completed
\& ## 1 completed
\& ## 2 completed
\&
\& 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361
\& 400 441 484 529 576 625 676 729 784 841 900 961 1024 1089 1156
\& 1225 1296 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209
\& 2304 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600
\& 3721 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 5329
\& 5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 7225 7396
\& 7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 9409 9604 9801
\& 10000
.Ve
.PP
Like with MCE::Step\->init above, \s-1MCE\s0 options may be specified using an
anonymous hash for the first argument. Notice how task_name, max_workers,
and use_threads can take an anonymous array for setting uniquely per
each code block.
.PP
Unlike MCE::Stream which processes from right-to-left, MCE::Step begins
with the first code block, thus processing from left-to-right.
.PP
The following takes 9 seconds to complete. The 9 seconds is from having
only 2 workers assigned for the last sub-task and waiting 1 or 2 seconds
initially before calling \s-1MCE\-\s0>step.
.PP
Removing both calls to \s-1MCE\-\s0>step will cause the script to complete in just
1 second. The reason is due to the 2nd and subsequent sub-tasks awaiting
data from an internal queue. Workers terminate upon receiving an undef.
.PP
.Vb 2
\& use threads;
\& use MCE::Step;
\&
\& my @a = mce_step {
\&    task_name   => [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq ],
\&    max_workers => [  3,   4,   2, ],
\&    use_threads => [  1,   0,   0, ],
\&
\&    user_end => sub {
\&       my ($mce, $task_id, $task_name) = @_;
\&       MCE\->print("$task_id \- $task_name completed\en");
\&    },
\&
\&    task_end => sub {
\&       my ($mce, $task_id, $task_name) = @_;
\&       MCE\->print("$task_id \- $task_name ended\en");
\&    }
\& },
\& sub { sleep 1; MCE\->step(""); },   ## 3 workers, named a
\& sub { sleep 2; MCE\->step(""); },   ## 4 workers, named b
\& sub { sleep 3;                };   ## 2 workers, named c
\&
\& \-\- Output
\&
\& 0 \- a completed
\& 0 \- a completed
\& 0 \- a completed
\& 0 \- a ended
\& 1 \- b completed
\& 1 \- b completed
\& 1 \- b completed
\& 1 \- b completed
\& 1 \- b ended
\& 2 \- c completed
\& 2 \- c completed
\& 2 \- c ended
.Ve
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
Although input data is optional for MCE::Step, the following assumes chunk_size
equals 1 in order to demonstrate all the possibilities for providing input data.
.IP "MCE::Step\->run ( sub { code }, list )" 3
.IX Item "MCE::Step->run ( sub { code }, list )"
.PD 0
.IP "mce_step sub { code }, list" 3
.IX Item "mce_step sub { code }, list"
.PD
.PP
Input data may be defined using a list, an array ref, or a hash ref.
.PP
Unlike MCE::Loop, Map, and Grep which take a block as \f(CW\*(C`{ ... }\*(C'\fR, Step takes a
\&\f(CW\*(C`sub { ... }\*(C'\fR or a code reference. The other difference is that the comma is
needed after the block.
.PP
.Vb 1
\& # $_ contains the item when chunk_size => 1
\&
\& mce_step sub { do_work($_) }, 1..1000;
\& mce_step sub { do_work($_) }, \e@list;
\&
\& # Important; pass an array_ref for deeply input data
\&
\& mce_step sub { do_work($_) }, [ [ 0, 1 ], [ 0, 2 ], ... ];
\& mce_step sub { do_work($_) }, \e@deeply_list;
\&
\& # Chunking; any chunk_size => 1 or greater
\&
\& my %res = mce_step sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my %ret;
\&    for my $item (@{ $chunk_ref }) {
\&       $ret{$item} = $item * 2;
\&    }
\&    MCE\->gather(%ret);
\& },
\& \e@list;
\&
\& # Input hash; current API available since 1.828
\&
\& my %res = mce_step sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my %ret;
\&    for my $key (keys %{ $chunk_ref }) {
\&       $ret{$key} = $chunk_ref\->{$key} * 2;
\&    }
\&    MCE\->gather(%ret);
\& },
\& \e%hash;
\&
\& # Unlike MCE::Loop, MCE::Step doesn\*(Aqt need input to run
\&
\& mce_step { max_workers => 4 }, sub {
\&    MCE\->say( MCE\->wid );
\& };
\&
\& # ... and can run multiple tasks
\&
\& mce_step {
\&    max_workers => [  1,   3  ],
\&    task_name   => [ \*(Aqp\*(Aq, \*(Aqc\*(Aq ]
\& },
\& sub {
\&    # 1 producer
\&    MCE\->say( "producer: ", MCE\->wid );
\& },
\& sub {
\&    # 3 consumers
\&    MCE\->say( "consumer: ", MCE\->wid );
\& };
\&
\& # Here, options are specified via init
\&
\& MCE::Step\->init(
\&    max_workers => [  1,   3  ],
\&    task_name   => [ \*(Aqp\*(Aq, \*(Aqc\*(Aq ]
\& );
\&
\& mce_step \e&producer, \e&consumers;
.Ve
.IP "MCE::Step\->run_file ( sub { code }, file )" 3
.IX Item "MCE::Step->run_file ( sub { code }, file )"
.PD 0
.IP "mce_step_f sub { code }, file" 3
.IX Item "mce_step_f sub { code }, file"
.PD
.PP
The fastest of these is the /path/to/file. Workers communicate the next offset
position among themselves with zero interaction by the manager process.
.PP
\&\f(CW\*(C`IO::All\*(C'\fR { File, Pipe, \s-1STDIO\s0 } is supported since \s-1MCE 1.845.\s0
.PP
.Vb 1
\& # $_ contains the line when chunk_size => 1
\&
\& mce_step_f sub { $_ }, "/path/to/file";  # faster
\& mce_step_f sub { $_ }, $file_handle;
\& mce_step_f sub { $_ }, $io;              # IO::All
\& mce_step_f sub { $_ }, \e$scalar;
\&
\& # chunking, any chunk_size => 1 or greater
\&
\& my %res = mce_step_f sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my $buf = \*(Aq\*(Aq;
\&    for my $line (@{ $chunk_ref }) {
\&       $buf .= $line;
\&    }
\&    MCE\->gather($chunk_id, $buf);
\& },
\& "/path/to/file";
.Ve
.ie n .IP "MCE::Step\->run_seq ( sub { code }, $beg, $end [, $step, $fmt ] )" 3
.el .IP "MCE::Step\->run_seq ( sub { code }, \f(CW$beg\fR, \f(CW$end\fR [, \f(CW$step\fR, \f(CW$fmt\fR ] )" 3
.IX Item "MCE::Step->run_seq ( sub { code }, $beg, $end [, $step, $fmt ] )"
.PD 0
.ie n .IP "mce_step_s sub { code }, $beg, $end [, $step, $fmt ]" 3
.el .IP "mce_step_s sub { code }, \f(CW$beg\fR, \f(CW$end\fR [, \f(CW$step\fR, \f(CW$fmt\fR ]" 3
.IX Item "mce_step_s sub { code }, $beg, $end [, $step, $fmt ]"
.PD
.PP
Sequence may be defined as a list, an array reference, or a hash reference.
The functions require both begin and end values to run. Step and format are
optional. The format is passed to sprintf (% may be omitted below).
.PP
.Vb 1
\& my ($beg, $end, $step, $fmt) = (10, 20, 0.1, "%4.1f");
\&
\& # $_ contains the sequence number when chunk_size => 1
\&
\& mce_step_s sub { $_ }, $beg, $end, $step, $fmt;
\& mce_step_s sub { $_ }, [ $beg, $end, $step, $fmt ];
\&
\& mce_step_s sub { $_ }, {
\&    begin => $beg, end => $end,
\&    step => $step, format => $fmt
\& };
\&
\& # chunking, any chunk_size => 1 or greater
\&
\& my %res = mce_step_s sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&    my $buf = \*(Aq\*(Aq;
\&    for my $seq (@{ $chunk_ref }) {
\&       $buf .= "$seq\en";
\&    }
\&    MCE\->gather($chunk_id, $buf);
\& },
\& [ $beg, $end ];
.Ve
.PP
The sequence engine can compute 'begin' and 'end' items only, for the chunk,
and not the items in between (hence boundaries only). This option applies
to sequence only and has no effect when chunk_size equals 1.
.PP
The time to run is 0.006s below. This becomes 0.827s without the bounds_only
option due to computing all items in between, thus creating a very large
array. Basically, specify bounds_only => 1 when boundaries is all you need
for looping inside the block; e.g. Monte Carlo simulations.
.PP
Time was measured using 1 worker to emphasize the difference.
.PP
.Vb 1
\& use MCE::Step;
\&
\& MCE::Step\->init(
\&    max_workers => 1, chunk_size => 1_250_000,
\&    bounds_only => 1
\& );
\&
\& # Typically, the input scalar $_ contains the sequence number
\& # when chunk_size => 1, unless the bounds_only option is set
\& # which is the case here. Thus, $_ points to $chunk_ref.
\&
\& mce_step_s sub {
\&    my ($mce, $chunk_ref, $chunk_id) = @_;
\&
\&    # $chunk_ref contains 2 items, not 1_250_000
\&    # my ( $begin, $end ) = ( $_\->[0], $_\->[1] );
\&
\&    my $begin = $chunk_ref\->[0];
\&    my $end   = $chunk_ref\->[1];
\&
\&    # for my $seq ( $begin .. $end ) {
\&    #    ...
\&    # }
\&
\&    MCE\->printf("%7d .. %8d\en", $begin, $end);
\& },
\& [ 1, 10_000_000 ];
\&
\& \-\- Output
\&
\&       1 ..  1250000
\& 1250001 ..  2500000
\& 2500001 ..  3750000
\& 3750001 ..  5000000
\& 5000001 ..  6250000
\& 6250001 ..  7500000
\& 7500001 ..  8750000
\& 8750001 .. 10000000
.Ve
.IP "MCE::Step\->run ( { input_data => iterator }, sub { code } )" 3
.IX Item "MCE::Step->run ( { input_data => iterator }, sub { code } )"
.PD 0
.IP "mce_step { input_data => iterator }, sub { code }" 3
.IX Item "mce_step { input_data => iterator }, sub { code }"
.PD
.PP
An iterator reference may be specified for input_data. The only other way
is to specify input_data via MCE::Step\->init. This prevents MCE::Step from
configuring the iterator reference as another user task which will not work.
.PP
Iterators are described under section \*(L"\s-1SYNTAX\s0 for \s-1INPUT_DATA\*(R"\s0 at MCE::Core.
.PP
.Vb 3
\& MCE::Step\->init(
\&    input_data => iterator
\& );
\&
\& mce_step sub { $_ };
.Ve
.SH "QUEUE-LIKE FEATURES"
.IX Header "QUEUE-LIKE FEATURES"
.IP "\s-1MCE\-\s0>step ( item )" 3
.IX Item "MCE->step ( item )"
.PD 0
.IP "\s-1MCE\-\s0>step ( arg1, arg2, argN )" 3
.IX Item "MCE->step ( arg1, arg2, argN )"
.PD
.PP
The \->step method is the simplest form for passing elements into the next
sub-task.
.PP
.Vb 1
\& use MCE::Step;
\&
\& sub provider {
\&    MCE\->step( $_, rand ) for 10 .. 19;
\& }
\&
\& sub consumer {
\&    my ( $mce, @args ) = @_;
\&    MCE\->printf( "%d: %d, %03.06f\en", MCE\->wid, $args[0], $args[1] );
\& }
\&
\& MCE::Step\->init(
\&    task_name   => [ \*(Aqp\*(Aq, \*(Aqc\*(Aq ],
\&    max_workers => [  1 ,  4  ]
\& );
\&
\& mce_step \e&provider, \e&consumer;
\&
\& \-\- Output
\&
\& 2: 10, 0.583551
\& 4: 11, 0.175319
\& 3: 12, 0.843662
\& 4: 15, 0.748302
\& 2: 14, 0.591752
\& 3: 16, 0.357858
\& 5: 13, 0.953528
\& 4: 17, 0.698907
\& 2: 18, 0.985448
\& 3: 19, 0.146548
.Ve
.IP "\s-1MCE\-\s0>enq ( task_name, item )" 3
.IX Item "MCE->enq ( task_name, item )"
.PD 0
.IP "\s-1MCE\-\s0>enq ( task_name, [ arg1, arg2, argN ] )" 3
.IX Item "MCE->enq ( task_name, [ arg1, arg2, argN ] )"
.IP "\s-1MCE\-\s0>enq ( task_name, [ arg1, arg2 ], [ arg1, arg2 ] )" 3
.IX Item "MCE->enq ( task_name, [ arg1, arg2 ], [ arg1, arg2 ] )"
.IP "\s-1MCE\-\s0>enqp ( task_name, priority, item )" 3
.IX Item "MCE->enqp ( task_name, priority, item )"
.IP "\s-1MCE\-\s0>enqp ( task_name, priority, [ arg1, arg2, argN ] )" 3
.IX Item "MCE->enqp ( task_name, priority, [ arg1, arg2, argN ] )"
.IP "\s-1MCE\-\s0>enqp ( task_name, priority, [ arg1, arg2 ], [ arg1, arg2 ] )" 3
.IX Item "MCE->enqp ( task_name, priority, [ arg1, arg2 ], [ arg1, arg2 ] )"
.PD
.PP
The \s-1MCE 1.7\s0 release enables finer control. Unlike \->step, which take multiple
arguments, the \->enq and \->enqp methods push items at the end of the array
internally. Passing multiple arguments is possible by enclosing the arguments
inside an anonymous array.
.PP
The direction of flow is forward only. Thus, stepping to itself or backwards
will cause an error.
.PP
.Vb 1
\& use MCE::Step;
\&
\& sub provider {
\&    if ( MCE\->wid % 2 == 0 ) {
\&       MCE\->enq( \*(Aqc\*(Aq, [ $_, rand ] ) for 10 .. 19;
\&    } else {
\&       MCE\->enq( \*(Aqd\*(Aq, [ $_, rand ] ) for 20 .. 29;
\&    }
\& }
\&
\& sub consumer_c {
\&    my ( $mce, $args ) = @_;
\&    MCE\->printf( "C%d: %d, %03.06f\en", MCE\->wid, $args\->[0], $args\->[1] );
\& }
\&
\& sub consumer_d {
\&    my ( $mce, $args ) = @_;
\&    MCE\->printf( "D%d: %d, %03.06f\en", MCE\->wid, $args\->[0], $args\->[1] );
\& }
\&
\& MCE::Step\->init(
\&    task_name   => [ \*(Aqp\*(Aq, \*(Aqc\*(Aq, \*(Aqd\*(Aq ],
\&    max_workers => [  2 ,  3 ,  3  ]
\& );
\&
\& mce_step \e&provider, \e&consumer_c, \e&consumer_d;
\&
\& \-\- Output
\&
\& C4: 10, 0.527531
\& D6: 20, 0.420108
\& C5: 11, 0.839770
\& D8: 21, 0.386414
\& C3: 12, 0.834645
\& C4: 13, 0.191014
\& D6: 23, 0.924027
\& C5: 14, 0.899357
\& D8: 24, 0.706186
\& C4: 15, 0.083823
\& D7: 22, 0.479708
\& D6: 25, 0.073882
\& C3: 16, 0.207446
\& D8: 26, 0.560755
\& C5: 17, 0.198157
\& D7: 27, 0.324909
\& C4: 18, 0.147505
\& C5: 19, 0.318371
\& D6: 28, 0.220465
\& D8: 29, 0.630111
.Ve
.IP "\s-1MCE\-\s0>await ( task_name, pending_threshold )" 3
.IX Item "MCE->await ( task_name, pending_threshold )"
.PP
Providers may sometime run faster than consumers. Thus, increasing memory
consumption. \s-1MCE 1.7\s0 adds the \->await method for pausing momentarily until
the receiving sub-task reaches the minimum threshold for the number of
items pending in its queue.
.PP
.Vb 2
\& use MCE::Step;
\& use Time::HiRes \*(Aqsleep\*(Aq;
\&
\& sub provider {
\&    for ( 10 .. 29 ) {
\&       # wait until 10 or less items pending
\&       MCE\->await( \*(Aqc\*(Aq, 10 );
\&       # forward item to a later sub\-task ( \*(Aqc\*(Aq comes after \*(Aqp\*(Aq )
\&       MCE\->enq( \*(Aqc\*(Aq, [ $_, rand ] );
\&    }
\& }
\&
\& sub consumer {
\&    my ($mce, $args) = @_;
\&    MCE\->printf( "%d: %d, %03.06f\en", MCE\->wid, $args\->[0], $args\->[1] );
\&    sleep 0.05;
\& }
\&
\& MCE::Step\->init(
\&    task_name   => [ \*(Aqp\*(Aq, \*(Aqc\*(Aq ],
\&    max_workers => [  1 ,  4  ]
\& );
\&
\& mce_step \e&provider, \e&consumer;
\&
\& \-\- Output
\&
\& 3: 10, 0.527307
\& 2: 11, 0.036193
\& 5: 12, 0.987168
\& 4: 13, 0.998140
\& 5: 14, 0.219526
\& 4: 15, 0.061609
\& 2: 16, 0.557664
\& 3: 17, 0.658684
\& 4: 18, 0.240932
\& 3: 19, 0.241042
\& 5: 20, 0.884830
\& 2: 21, 0.902223
\& 4: 22, 0.699223
\& 3: 23, 0.208270
\& 5: 24, 0.438919
\& 2: 25, 0.268854
\& 4: 26, 0.596425
\& 5: 27, 0.979818
\& 2: 28, 0.918173
\& 3: 29, 0.358266
.Ve
.SH "GATHERING DATA"
.IX Header "GATHERING DATA"
Unlike MCE::Map where gather and output order are done for you automatically,
the gather method is used to have results sent back to the manager process.
.PP
.Vb 1
\& use MCE::Step chunk_size => 1;
\&
\& ## Output order is not guaranteed.
\& my @a = mce_step sub { MCE\->gather($_ * 2) }, 1..100;
\& print "@a\en\en";
\&
\& ## Outputs to a hash instead (key, value).
\& my %h1 = mce_step sub { MCE\->gather($_, $_ * 2) }, 1..100;
\& print "@h1{1..100}\en\en";
\&
\& ## This does the same thing due to chunk_id starting at one.
\& my %h2 = mce_step sub { MCE\->gather(MCE\->chunk_id, $_ * 2) }, 1..100;
\& print "@h2{1..100}\en\en";
.Ve
.PP
The gather method may be called multiple times within the block unlike return
which would leave the block. Therefore, think of gather as yielding results
immediately to the manager process without actually leaving the block.
.PP
.Vb 1
\& use MCE::Step chunk_size => 1, max_workers => 3;
\&
\& my @hosts = qw(
\&    hosta hostb hostc hostd hoste
\& );
\&
\& my %h3 = mce_step sub {
\&    my ($output, $error, $status); my $host = $_;
\&
\&    ## Do something with $host;
\&    $output = "Worker ". MCE\->wid .": Hello from $host";
\&
\&    if (MCE\->chunk_id % 3 == 0) {
\&       ## Simulating an error condition
\&       local $? = 1; $status = $?;
\&       $error = "Error from $host"
\&    }
\&    else {
\&       $status = 0;
\&    }
\&
\&    ## Ensure unique keys (key, value) when gathering to
\&    ## a hash.
\&    MCE\->gather("$host.out", $output);
\&    MCE\->gather("$host.err", $error) if (defined $error);
\&    MCE\->gather("$host.sta", $status);
\&
\& }, @hosts;
\&
\& foreach my $host (@hosts) {
\&    print $h3{"$host.out"}, "\en";
\&    print $h3{"$host.err"}, "\en" if (exists $h3{"$host.err"});
\&    print "Exit status: ", $h3{"$host.sta"}, "\en\en";
\& }
\&
\& \-\- Output
\&
\& Worker 3: Hello from hosta
\& Exit status: 0
\&
\& Worker 2: Hello from hostb
\& Exit status: 0
\&
\& Worker 1: Hello from hostc
\& Error from hostc
\& Exit status: 1
\&
\& Worker 3: Hello from hostd
\& Exit status: 0
\&
\& Worker 2: Hello from hoste
\& Exit status: 0
.Ve
.PP
The following uses an anonymous array containing 3 elements when gathering
data. Serialization is automatic behind the scene.
.PP
.Vb 2
\& my %h3 = mce_step sub {
\&    ...
\&
\&    MCE\->gather($host, [$output, $error, $status]);
\&
\& }, @hosts;
\&
\& foreach my $host (@hosts) {
\&    print $h3{$host}\->[0], "\en";
\&    print $h3{$host}\->[1], "\en" if (defined $h3{$host}\->[1]);
\&    print "Exit status: ", $h3{$host}\->[2], "\en\en";
\& }
.Ve
.PP
Although MCE::Map comes to mind, one may want additional control when
gathering data such as retaining output order.
.PP
.Vb 1
\& use MCE::Step;
\&
\& sub preserve_order {
\&    my %tmp; my $order_id = 1; my $gather_ref = $_[0];
\&
\&    return sub {
\&       $tmp{ (shift) } = \e@_;
\&
\&       while (1) {
\&          last unless exists $tmp{$order_id};
\&          push @{ $gather_ref }, @{ delete $tmp{$order_id++} };
\&       }
\&
\&       return;
\&    };
\& }
\&
\& ## Workers persist for the most part after running. Though, not always
\& ## the case and depends on Perl. Pass a reference to a subroutine if
\& ## workers must persist; e.g. mce_step { ... }, \e&foo, 1..100000.
\&
\& MCE::Step\->init(
\&    chunk_size => \*(Aqauto\*(Aq, max_workers => \*(Aqauto\*(Aq
\& );
\&
\& for (1..2) {
\&    my @m2;
\&
\&    mce_step {
\&       gather => preserve_order(\e@m2)
\&    },
\&    sub {
\&       my @a; my ($mce, $chunk_ref, $chunk_id) = @_;
\&
\&       ## Compute the entire chunk data at once.
\&       push @a, map { $_ * 2 } @{ $chunk_ref };
\&
\&       ## Afterwards, invoke the gather feature, which
\&       ## will direct the data to the callback function.
\&       MCE\->gather(MCE\->chunk_id, @a);
\&
\&    }, 1..100000;
\&
\&    print scalar @m2, "\en";
\& }
\&
\& MCE::Step\->finish;
.Ve
.PP
All 6 models support 'auto' for chunk_size unlike the Core \s-1API.\s0 Think of the
models as the basis for providing \s-1JIT\s0 for \s-1MCE.\s0 They create the instance, tune
max_workers, and tune chunk_size automatically regardless of the hardware.
.PP
The following does the same thing using the Core \s-1API.\s0 Workers persist after
running.
.PP
.Vb 1
\& use MCE;
\&
\& sub preserve_order {
\&    ...
\& }
\&
\& my $mce = MCE\->new(
\&    max_workers => \*(Aqauto\*(Aq, chunk_size => 8000,
\&
\&    user_func => sub {
\&       my @a; my ($mce, $chunk_ref, $chunk_id) = @_;
\&
\&       ## Compute the entire chunk data at once.
\&       push @a, map { $_ * 2 } @{ $chunk_ref };
\&
\&       ## Afterwards, invoke the gather feature, which
\&       ## will direct the data to the callback function.
\&       MCE\->gather(MCE\->chunk_id, @a);
\&    }
\& );
\&
\& for (1..2) {
\&    my @m2;
\&
\&    $mce\->process({ gather => preserve_order(\e@m2) }, [1..100000]);
\&
\&    print scalar @m2, "\en";
\& }
\&
\& $mce\->shutdown;
.Ve
.SH "MANUAL SHUTDOWN"
.IX Header "MANUAL SHUTDOWN"
.IP "MCE::Step\->finish" 3
.IX Item "MCE::Step->finish"
.PD 0
.IP "MCE::Step::finish" 3
.IX Item "MCE::Step::finish"
.PD
.PP
Workers remain persistent as much as possible after running. Shutdown occurs
automatically when the script terminates. Call finish when workers are no
longer needed.
.PP
.Vb 1
\& use MCE::Step;
\&
\& MCE::Step\->init(
\&    chunk_size => 20, max_workers => \*(Aqauto\*(Aq
\& );
\&
\& mce_step sub { ... }, 1..100;
\&
\& MCE::Step\->finish;
.Ve
.SH "INDEX"
.IX Header "INDEX"
\&\s-1MCE\s0, MCE::Core
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario E. Roy, <marioeroy AT gmail DOT com>
