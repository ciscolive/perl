.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::box 3"
.TH Crypt::NaCl::Sodium::box 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::box \- Public\-key authenticated encryption (Curve25519/XSalsa20/Poly1305 MAC)
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_box = Crypt::NaCl::Sodium\->box();
\&
\&    my ($a_skey, $a_pkey, $a_key, $b_skey,
\&        $b_pkey, $b_key,
\&        $a_precal_key, $b_precal_key,
\&        $nonce, $decrypted_msg, $msg, $secret);
\&
\&    ## Alice
\&    ########
\&
\&    # Alice generates secret keypair
\&    ($a_pkey, $a_skey) = $crypto_box\->keypair();
\&
\&    # ... and shares the public key with Bob
\&    send_to( Bob => { public_key => $a_pkey } );
\&
\&    ## Bob
\&    ########
\&
\&    # Bob generates his secret keypair
\&    ($b_pkey, $b_skey) = $crypto_box\->keypair();
\&
\&    # Bob receives the public key from Alice
\&    $a_key = receive_for( Bob => \*(Aqpublic_key\*(Aq );
\&
\&    # ... and shares his public key with Alice
\&    send_to( Alice => { public_key => $b_pkey } );
\&
\&    # now Alice and Bob can start communicating
\&
\&    ## Alice
\&    ########
\&
\&    # Alice receives the public key from Bob
\&    $b_key = receive_for( Alice => \*(Aqpublic_key\*(Aq );
\&
\&    # Alice generates random nonce
\&    $nonce = $crypto_box\->nonce();
\&
\&    send_to( Bob => { nonce => $nonce } );
\&
\&    # Alice\*(Aqs message to Bob
\&    $msg = "Hi Bob!";
\&
\&    # encrypts using combined mode
\&    $secret = $crypto_box\->encrypt( $msg, $nonce, $b_key, $a_skey );
\&
\&    # message is ready for Bob
\&    send_to( Bob => { secret => $secret } );
\&
\&    ## Bob
\&    ########
\&
\&    # Bob receives the random nonce
\&    $nonce = receive_for( Bob => \*(Aqnonce\*(Aq );
\&
\&    # and is now ready to receive first message from Alice
\&    $secret = receive_for( Bob => \*(Aqsecret\*(Aq );
\&
\&    # since Bob already has Alice\*(Aqs public key we have all information required to decrypt message
\&    $decrypted_msg = $crypto_box\->decrypt( $secret, $nonce, $a_key, $b_skey );
\&
\&    # Bob is going to send a lot of messages to Alice, so we speed up the
\&    # encryption and decryption by pre\-calculating the shared key
\&    $b_precal_key = $crypto_box\->beforenm( $a_key, $b_skey );
\&
\&    # now it is time to reply
\&    $msg = "Hello Alice!";
\&
\&    # generates new nonce
\&    $nonce = $crypto_box\->nonce();
\&
\&    # this time we use detached mode using precalculated key
\&    ($mac, $secret) = $crypto_box\->encrypt_afternm( $msg, $nonce, $b_precal_key );
\&
\&    # Alice needs all pieces to verify and decrypt Bob\*(Aqs message
\&    send_to( Alice => { nonce => $nonce } );
\&    send_to( Alice => { mac => $mac } );
\&    send_to( Alice => { secret => $secret } );
\&
\&    ## Alice
\&    ########
\&
\&    # Bob used the detached mode
\&    $nonce  = receive_for( Alice => \*(Aqnonce\*(Aq );
\&    $mac    = receive_for( Alice => \*(Aqmac\*(Aq );
\&    $secret = receive_for( Alice => \*(Aqsecret\*(Aq );
\&
\&    # Alice also pre\-calculates the shared key
\&    $a_precal_key = $crypto_box\->beforenm( $b_key, $a_skey );
\&
\&    # we have now all information required to decrypt message
\&    $decrypted_msg = $crypto_box\->decrypt_detached_afternm( $mac, $secret, $nonce, $a_precal_key );
\&
\&    # NOTE: send_to() and receive_for() and user functions providing transport of
\&    # messages
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`crypto_box\*(C'\fR function is designed to meet the standard notions of privacy and
third-party unforgeability for a public-key authenticated-encryption scheme
using nonces.
.PP
The \f(CW\*(C`crypto_box\*(C'\fR function is not meant to provide non-repudiation. On the
contrary: the crypto_box function guarantees repudiability. A receiver can
freely modify a boxed message, and therefore cannot convince third parties that
this particular message came from the sender. The sender and receiver are
nevertheless protected against forgeries by other parties. \f(CW\*(C`crypto_box\*(C'\fR uses
\&\fIpublic-key authenticators\fR rather than \fIpublic-key signatures\fR.
.PP
Users who want public verifiability (or receiver-assisted public verifiability)
should instead use Crypt::NaCl::Sodium::sign.
.PP
Using public-key authenticated encryption, parties involved can encrypt a
confidential message using their public keys, while keeping their secret keys
confidential.
.PP
Using the sender's public key, only the receiver can verify that the encrypted
message was actually created by the sender and was not tampered
with, before eventually decrypting it. This bidirectional guarantee around
identity is known as mutual authentication.
.PP
The same keypair can be used with multiple other users, without the need of
generating a distinct set of keys.
.PP
Nonce (number used once) does not have to be protected, but it is crucial that
the same nonce has not been ever reused with the same \f(CW\*(C`{sender, receiver}\*(C'\fR set.
.SH "METHODS"
.IX Header "METHODS"
.SS "keypair"
.IX Subsection "keypair"
.Vb 1
\&    my ($public_key, $secret_key) = $crypto_box\->keypair();
\&
\&    # or deterministically derived from a single key seed
\&    my ($public_key, $secret_key) = $crypto_box\->keypair( $seed );
.Ve
.PP
Helper method to generate a random secret key and corresponding public key
to be used by \f(CW$crypto_box\fR.
.PP
See \*(L"seed\*(R" for more details when generating key pair using given \f(CW$seed\fR.
.PP
The length of the \f(CW$public_key\fR equals \*(L"\s-1PUBLICKEYBYTES\*(R"\s0.
.PP
The length of the \f(CW$secret_key\fR equals \*(L"\s-1SECRETKEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the secret key confidential.
.PP
Returns Data::BytesLocker objects.
.SS "public_key"
.IX Subsection "public_key"
.Vb 1
\&    my $public_key = $crypto_box\->public_key( $secret_key );
.Ve
.PP
Computes the public key for given secret key.
.PP
The length of the \f(CW$public_key\fR equals \*(L"\s-1PUBLICKEYBYTES\*(R"\s0.
.PP
Returns Data::BytesLocker objects.
.SS "seed"
.IX Subsection "seed"
.Vb 1
\&    my $seed = $crypto_box\->seed();
\&
\&    my ($public_key, $secret_key) = $crypto_box\->keypair( $seed );
.Ve
.PP
Helper method to generate a random seed, that can be used to deterministically
compute the key pair derived from it.
.PP
The length of the \f(CW$seed\fR equals \*(L"\s-1SEEDBYTES\*(R"\s0.
.PP
Returns Data::BytesLocker objects.
.SS "beforenm"
.IX Subsection "beforenm"
.Vb 1
\&    my $shared_key = $crypto_box\->beforenm( $public_key, $secret_key );
.Ve
.PP
Applications that send several messages to the same receiver
or receive several messages from the same sender can gain
speed by calculating the shared key only once, and reusing it in
subsequent operations.
.PP
The length of the \f(CW$shared_key\fR equals \*(L"\s-1BEFORENMBYTES\*(R"\s0.
.PP
Returns Data::BytesLocker objects.
.SS "nonce"
.IX Subsection "nonce"
.Vb 1
\&    my $nonce = $crypto_box\->nonce();
.Ve
.PP
Helper method to generate a random nonce to be used by \f(CW$crypto_box\fR.
.PP
The length of the nonce equals \*(L"\s-1NONCEBYTES\*(R"\s0.
.PP
If initial value has been passed as the argument, it will then padded with
\&\f(CW\*(C`null\*(C'\fR bytes.
.PP
.Vb 3
\&    my $counter = 121;
\&    my $nonce = $crypto_box\->nonce($counter);
\&    $nonce =~ /^121\e0+$/ or die;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR nonce does not have to be random nor confidential, but it must never
be reused with the same \f(CW\*(C`{sender, receiver}\*(C'\fR set.
.PP
If random nonce is being used it needs to be provided to the other party to
allow decryption.
.PP
If counter is being used store it alongside the recipient's public key to avoid
accidental reuse on the next session. In connection-oriented protocols
counter-based nonce could help rejecting duplicate messages.
.PP
Returns Data::BytesLocker object.
.SS "encrypt"
.IX Subsection "encrypt"
.Vb 3
\&    # combined mode \- MAC and encrypted message stored together
\&    my $secret = $crypto_box\->encrypt($msg, $nonce,
\&        $recipient_public_key, $sender_secret_key);
\&
\&    # detached mode \- MAC and encrypted message returned separate
\&    my ($mac, $ciphertext) = $crypto_box\->encrypt($msg, $nonce,
\&        $recipient_public_key, $sender_secret_key);
.Ve
.PP
Encrypts the plaintext message using given \f(CW$nonce\fR, \f(CW$recipient_public_key\fR
and \f(CW$sender_secret_key\fR.
.PP
In scalar context works in combined mode, where \s-1MAC\s0 and encrypted message are stored
together.
The length of the \f(CW$secret\fR equals the length of \f(CW$msg\fR + \*(L"\s-1MACBYTES\*(R"\s0.
.PP
In list context the \f(CW$mac\fR and \f(CW$ciphertext\fR are returned separately.
The length of the \f(CW$ciphertext\fR equals the length of \f(CW$msg\fR, while length
of \f(CW$mac\fR is \*(L"\s-1MACBYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\fIencrypt_afternm\fR
.IX Subsection "encrypt_afternm"
.PP
.Vb 3
\&    # combined mode \- MAC and encrypted message stored together
\&    my $secret = $crypto_box\->encrypt_afternm($msg, $nonce,
\&        $shared_key);
\&
\&    # detached mode \- MAC and encrypted message returned separate
\&    my ($mac, $ciphertext) = $crypto_box\->encrypt_afternm($msg, $nonce,
\&        $shared_key);
.Ve
.PP
Same as above but encrypts using pre-calculated \f(CW$shared_key\fR (as returned by \*(L"beforenm\*(R").
.SS "decrypt"
.IX Subsection "decrypt"
.Vb 10
\&    my $msg;
\&    eval {
\&        $msg = $crypto_box\->decrypt($secret, $nonce,
\&            $sender_public_key, $recipient_secret_key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Verify and decrypt the secret message using given \f(CW$nonce\fR,
\&\f(CW$sender_public_key\fR and \f(CW$recipient_secret_key\fR.
.PP
Function croaks if the verification fails. Otherwise returns the decrypted message.
.PP
The length of the \f(CW$msg\fR equals the length of \f(CW$secret\fR \- \*(L"\s-1MACBYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\fIdecrypt_afternm\fR
.IX Subsection "decrypt_afternm"
.PP
.Vb 10
\&    my $msg;
\&    eval {
\&        $msg = $crypto_box\->decrypt_afternm($secret, $nonce,
\&            $shared_key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Same as above but decrypts using pre-calculated \f(CW$shared_key\fR (as returned by \*(L"beforenm\*(R").
.SS "decrypt_detached"
.IX Subsection "decrypt_detached"
.Vb 10
\&    my $msg;
\&    eval {
\&        $msg = $crypto_box\->decrypt_detached($mac, $ciphertext, $nonce,
\&            $sender_public_key, $recipient_secret_key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Verify and decrypt the secret message \f(CW$ciphertext\fR authenticated with \f(CW$mac\fR
using given \f(CW$nonce\fR, \f(CW$sender_public_key\fR and \f(CW$recipient_secret_key\fR.
.PP
Function croaks if the verification fails. Otherwise returns the decrypted message.
.PP
The length of the \f(CW$msg\fR equals the length of \f(CW$ciphertext\fR.
.PP
Returns Data::BytesLocker object.
.PP
\fIdecrypt_detached_afternm\fR
.IX Subsection "decrypt_detached_afternm"
.PP
.Vb 10
\&    my $msg;
\&    eval {
\&        $msg = $crypto_box\->decrypt_detached_afternm($mac, $ciphertext, $nonce,
\&            $shared_key);
\&    };
\&    if ( $@ ) {
\&        warn "Message forged!";
\&    } else {
\&        print "Decrypted message: $msg\en";
\&    }
.Ve
.PP
Same as above but decrypts using pre-calculated \f(CW$shared_key\fR (as returned by \*(L"beforenm\*(R").
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1NONCEBYTES\s0"
.IX Subsection "NONCEBYTES"
.Vb 1
\&    my $nonce_length = $crypto_box\->NONCEBYTES;
.Ve
.PP
Returns the length of nonce.
.SS "\s-1SECRETKEYBYTES\s0"
.IX Subsection "SECRETKEYBYTES"
.Vb 1
\&    my $skey_length = $crypto_box\->SECRETKEYBYTES;
.Ve
.PP
Returns the length of secret key.
.SS "\s-1PUBLICKEYBYTES\s0"
.IX Subsection "PUBLICKEYBYTES"
.Vb 1
\&    my $pkey_length = $crypto_box\->PUBLICKEYBYTES;
.Ve
.PP
Returns the length of public key.
.SS "\s-1SEEDBYTES\s0"
.IX Subsection "SEEDBYTES"
.Vb 1
\&    my $seed_length = $crypto_box\->SEEDBYTES;
.Ve
.PP
Returns the length of seed key.
.SS "\s-1BEFORENMBYTES\s0"
.IX Subsection "BEFORENMBYTES"
.Vb 1
\&    my $shared_key_length = $crypto_box\->BEFORENMBYTES;
.Ve
.PP
Returns the length of pre-calculated shared key.
.SS "\s-1MACBYTES\s0"
.IX Subsection "MACBYTES"
.Vb 1
\&    my $mac_length = $crypto_box\->MACBYTES;
.Ve
.PP
Returns the length of \s-1MAC.\s0
.SH "ALGORITHM DETAILS"
.IX Header "ALGORITHM DETAILS"
\&\f(CW\*(C`crypto_box\*(C'\fR for encryption uses XSalsa20 stream cipher (which is based
on Salsa20, but with much longer nonce) and Poly1305 \s-1MAC\s0 for authentication,
for key exchange Curve25519 is used.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
Crypt::Curve25519
.IP "\(bu" 4
Terminology of public-key authenticators <http://groups.google.com/group/sci.crypt/msg/ec5c18b23b11d82c>
.IP "\(bu" 4
Cryptography in NaCl <http://cr.yp.to/highspeed/naclcrypto-20090310.pdf>
.IP "\(bu" 4
A state-of-the-art Diffie-Hellman function <http://cr.yp.to/ecdh.html>
\&\- Curve25519
.IP "\(bu" 4
Extending the Salsa20 nonce <http://cr.yp.to/snuffle/xsalsa-20110204.pdf>
\&\- the paper introducing XSalsa20
.IP "\(bu" 4
The Poly1305\-AES message-authentication code <http://cr.yp.to/mac/poly1305-20050329.pdf>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
