.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::IPAM::Tree 3"
.TH Net::IPAM::Tree 3 "2020-07-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IPAM::Tree \- A CIDR/Block tree library for fast IP lookup with longest\-prefix\-match.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A module for fast IP-routing-table lookups and IP-ACLs (Access Control Lists).
.PP
It is \fB\s-1NOT\s0\fR a standard patricia-trie implementation.
This isn't possible for general blocks not represented by bitmasks, every tree item is a Net::IPAM::Block.
.PP
The complexity for tree operations is in worst case O(h * log n) with h <= 128 (IPv6) or h <=32 (IPv4).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::IPAM::Tree;
\&
\&  my $t = Net::IPAM::Tree\->new();
\&
\&  $t\->insert(@blocks) || die("duplicate block...");
\&  $t\->remove($block)  || warn("block not in tree...");
\&
\&  my $block = $t\->lookup($ip_or_block)
\&    && printf( "longest\-prefix\-match in tree for %s is %s\en", $ip_or_block, $block );
\&
\&  $t\->contains($ip_or_block)
\&    && printf( "ip or block %s is contained in tree\en", $ip_or_block );
\&
\&  say $t\->to_string;
\&
\&  X
\&  XX ::/8
\&  XX 100::/8
\&  XX 2000::/3
\&  X  XX 2000::/4
\&  X  XX 3000::/4
\&  XX 4000::/3
\&  ...
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new([$error_cb])"
.IX Subsection "new([$error_cb])"
Create Net::IPAM::Tree object.
.PP
.Vb 1
\&  my $t = Net::IPAM::Tree\->new;
.Ve
.PP
The only optional argument is a coderef for an error handler.
With no error callback \*(L"insert\*(R" just calls \f(CW\*(C`carp()\*(C'\fR on duplicate items.
.PP
The error callback gets the duplicate block as argument.
.SS "insert"
.IX Subsection "insert"
Insert block(s) into the tree. Inserting a bulk of blocks is much faster
than inserting unsorted single blocks in a loop.
.PP
Returns the tree object on success for method chaining.
.PP
.Vb 1
\&  my $t = Net::IPAM::Tree\->new\->insert(@blocks) // die("one or more blocks are duplicate");
.Ve
.PP
Returns undef on duplicate blocks in the tree and generate warnings.
To shut up the warnings on duplicate items, define your own error callback in the constructor.
.PP
.Vb 2
\&  my $t = Net::IPAM::Tree\->new(sub{});
\&  $t\->insert(@blocks) // die("one or more blocks are duplicate");
.Ve
.SS "contains($thing)"
.IX Subsection "contains($thing)"
Returns the outermost block if the given \f(CW$thing\fR (Net::IPAM::IP or Net::IPAM::Block)
is contained in the tree or undef.
.PP
This is much faster than a full \*(L"lookup\*(R" for the longest-prefix-match.
.PP
This can be used for fast \s-1ACL\s0 lookups.
.PP
.Vb 2
\&  # make blocks
\&  my @deny = map { Net::IPAM::Block\->new($_) } qw(2001:db8::\-2001:db8::1234:ffea fe80::/10);
\&
\&  # make tree
\&  my $deny = Net::IPAM::Tree\->new\->insert(@deny) or die;
\&
\&  my $ip = Net::IPAM::IP\->new( get_ip_from($some_request) );
\&  say "request forbidden for $ip" if $deny\->contains($ip);
.Ve
.SS "lookup($thing)"
.IX Subsection "lookup($thing)"
Returns Net::IPAM::Block with longest prefix match for \f(CW$thing\fR (Net::IPAM::IP or Net::IPAM::Block)
in the tree, undef if not found.
.PP
This can be used for fast routing table lookups.
.PP
.Vb 2
\&  # make blocks
\&  my @priv = map { Net::IPAM::Block\->new($_) } qw(10.0.0.0/8 172.16.0.0/12 192.168.0.0 fc00::/7);
\&
\&  # make tree
\&  my $priv = Net::IPAM::Tree\->new\->insert(@priv) or die;
\&
\&  my $b = Net::IPAM::Block\->new(\*(Aqfdcd:aa59:8bce::/48\*(Aq) or die;
\&
\&  my $lpm = $priv\->lookup($b)
\&    && say "longest\-prefix\-match for $b is $lpm";
.Ve
.SS "remove"
.IX Subsection "remove"
Remove one block from tree, relink parent/child relation at the gap.
.PP
.Vb 1
\&  $t\->remove($block) // warn("block not found");
.Ve
.PP
Returns undef if \f(CW$block\fR is not found.
.SS "remove_branch"
.IX Subsection "remove_branch"
Remove \f(CW$block\fR and the branch below from tree.
.PP
.Vb 1
\&  $t\->remove_branch($block) // warn("block not found");
.Ve
.PP
Returns undef if \f(CW$block\fR is not found.
.SS "to_string"
.IX Subsection "to_string"
Returns the tree as ordered graph or undef on empty trees.
.PP
.Vb 1
\&  $t\->to_string($callback);
.Ve
.PP
The optional callback is called on every block. Returns the decorated string for block.
.PP
.Vb 1
\&  $t\->to_string( sub { my $block = shift; return decorate($block) } );
.Ve
.PP
example (without callback):
.PP
.Vb 7
\&  X
\&  XX ::/8
\&  XX 100::/8
\&  XX 2000::/3
\&  X  XX 2000::/4
\&  X  XX 3000::/4
\&  XX 6000::/3
.Ve
.PP
possible example (with callback):
.PP
.Vb 7
\&  X
\&  XX ::/8.................   "Reserved by IETF     [RFC3513][RFC4291]"
\&  XX 100::/8..............   "Reserved by IETF     [RFC3513][RFC4291]"
\&  XX 2000::/3.............   "Global Unicast       [RFC3513][RFC4291]"
\&  X  XX 2000::/4.............  "Test"
\&  X  XX 3000::/4.............  "FREE"
\&  XX 6000::/3.............   "Reserved by IETF     [RFC3513][RFC4291]"
.Ve
.SS "walk"
.IX Subsection "walk"
Walks the tree, starting at root node in depth first order.
.PP
.Vb 1
\&  my $err_string = $t\->walk($callback);
.Ve
.PP
For every node Net::IPAM::Tree::Node the callback function is called with the node
and the current depth (counting from 0) as arguments.
.PP
.Vb 1
\&        my $err_string = $callback\->($node, $depth);
.Ve
.PP
The callback must return undef if there is no error!
On error, the walk is stopped and the error is returned to the caller.
.PP
Example, get some tree statistics:
.PP
.Vb 1
\&  my ( $n, $max_d, $max_c ) = ( 0, 0, 0 );
\&
\&  my $cb = sub {
\&    my ( $node, $depth ) = @_;
\&
\&    $n++;
\&    $max_c = $node\->childs if $max_c < $node\->childs;
\&    $max_d = $depth + 1    if $max_d < $depth + 1;
\&
\&    return;    # explicit return (undef) if there is no error!
\&  };
\&
\&  my $err = $t\->walk($cb);
\&  say "tree has $n nodes and is $max_d levels deep, the number of max childs/node is $max_c" unless $err;
.Ve
.SS "len"
.IX Subsection "len"
Just for convenience, \*(L"len\*(R" returns the number of blocks in the tree,
implemented as a simple \*(L"walk\*(R" callback.
.SH "AUTHOR"
.IX Header "AUTHOR"
Karl Gaissmaier, \f(CW\*(C`<karl.gaissmaier(at)uni\-ulm.de>\*(C'\fR
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Net::IPAM::Tree
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
on github
.Sp
\&\s-1TODO\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::IPAM::Tree::Node
Net::IPAM::IP
Net::IPAM::Block
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This software is copyright (c) 2020 by Karl Gaissmaier.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
