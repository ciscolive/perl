.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SNMP::Info::Bridge 3"
.TH SNMP::Info::Bridge 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SNMP::Info::Bridge \- SNMP Interface to SNMP data available through the
BRIDGE\-MIB (RFC1493)
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Baker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& my $bridge = new SNMP::Info (
\&                             AutoSpecify => 1,
\&                             Debug       => 1,
\&                             DestHost    => \*(Aqswitch\*(Aq,
\&                             Community   => \*(Aqpublic\*(Aq,
\&                             Version     => 2
\&                             );
\&
\& my $class = $bridge\->class();
\& print " Using device sub class : $class\en";
\&
\& # Grab Forwarding Tables
\& my $interfaces = $bridge\->interfaces();
\& my $fw_mac     = $bridge\->fw_mac();
\& my $fw_port    = $bridge\->fw_port();
\& my $bp_index   = $bridge\->bp_index();
\&
\& foreach my $fw_index (keys %$fw_mac){
\&    my $mac   = $fw_mac\->{$fw_index};
\&    my $bp_id = $fw_port\->{$fw_index};
\&    my $iid   = $bp_index\->{$bp_id};
\&    my $port  = $interfaces\->{$iid};
\&
\&    print "Port:$port forwarding to $mac\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIBRIDGE-MIB\fR is used by most Layer 2 devices, and holds information like the
\&\s-1MAC\s0 Forwarding Table and Spanning Tree Protocol info.
.PP
\&\fIQ\-BRIDGE-MIB\fR holds 802.1q information \*(-- VLANs and Trunking.  Cisco tends
not to use this \s-1MIB,\s0 but some proprietary ones.  \s-1HP\s0 and some nicer vendors use
this.  This is from \f(CW\*(C`RFC2674_q\*(C'\fR.
.PP
Create or use a subclass of SNMP::Info that inherits this class.  Do not use
directly.
.PP
For debugging you can call \fBnew()\fR directly as you would in SNMP::Info
.PP
.Vb 1
\& my $bridge = new SNMP::Info::Bridge(...);
.Ve
.SS "Inherited Classes"
.IX Subsection "Inherited Classes"
None.
.SS "Required MIBs"
.IX Subsection "Required MIBs"
.IP "\fIBRIDGE-MIB\fR" 4
.IX Item "BRIDGE-MIB"
.PD 0
.IP "\fIQ\-BRIDGE-MIB\fR" 4
.IX Item "Q-BRIDGE-MIB"
.IP "\fIRSTP-MIB\fR" 4
.IX Item "RSTP-MIB"
.PD
.SH "GLOBALS"
.IX Header "GLOBALS"
These are methods that return scalar values from \s-1SNMP\s0
.ie n .IP "$bridge\->\fBb_mac()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBb_mac()\fR" 4
.IX Item "$bridge->b_mac()"
Returns the \s-1MAC\s0 Address of the root bridge port
.Sp
(\f(CW\*(C`dot1dBaseBridgeAddress\*(C'\fR)
.ie n .IP "$bridge\->\fBb_ports()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBb_ports()\fR" 4
.IX Item "$bridge->b_ports()"
Returns the number of ports in device
.Sp
(\f(CW\*(C`dot1dBaseNumPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBb_type()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBb_type()\fR" 4
.IX Item "$bridge->b_type()"
Returns the type of bridging this bridge can perform, transparent and/or
source route.
.Sp
(\f(CW\*(C`dot1dBaseType\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_ver()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_ver()\fR" 4
.IX Item "$bridge->stp_ver()"
Returns what version of \s-1STP\s0 the device is running.
.Sp
(\f(CW\*(C`dot1dStpProtocolSpecification\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_time()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_time()\fR" 4
.IX Item "$bridge->stp_time()"
Returns time since last topology change detected. (100ths/second)
.Sp
(\f(CW\*(C`dot1dStpTimeSinceTopologyChange\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_root()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_root()\fR" 4
.IX Item "$bridge->stp_root()"
Returns root of \s-1STP.\s0
.Sp
(\f(CW\*(C`dot1dStpDesignatedRoot\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_vlans_max()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_vlans_max()\fR" 4
.IX Item "$bridge->qb_vlans_max()"
Maximum number of \s-1VLANS\s0 supported on this device.
.Sp
(\f(CW\*(C`dot1qMaxSupportedVlans\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_vlans()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_vlans()\fR" 4
.IX Item "$bridge->qb_vlans()"
Current number of VLANs that are configured in this device.
.Sp
(\f(CW\*(C`dot1qNumVlans\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_next_vlan_index()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_next_vlan_index()\fR" 4
.IX Item "$bridge->qb_next_vlan_index()"
The next available value for \f(CW\*(C`dot1qVlanIndex\*(C'\fR of a local \s-1VLAN\s0 entry in
\&\f(CW\*(C`dot1qVlanStaticTable\*(C'\fR
.Sp
(\f(CW\*(C`dot1qNextFreeLocalVlanIndex\*(C'\fR)
.SH "TABLE METHODS"
.IX Header "TABLE METHODS"
These are methods that return tables of information in the form of a reference
to a hash.
.ie n .IP "$bridge\->\fBi_vlan()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_vlan()\fR" 4
.IX Item "$bridge->i_vlan()"
Returns a mapping between \f(CW\*(C`ifIndex\*(C'\fR and the \s-1PVID\s0 or default \s-1VLAN.\s0
.ie n .IP "$vtp\->\fBi_untagged()\fR" 4
.el .IP "\f(CW$vtp\fR\->\fBi_untagged()\fR" 4
.IX Item "$vtp->i_untagged()"
An alias for \f(CW\*(C`i_vlan\*(C'\fR.
.ie n .IP "$bridge\->\fBi_vlan_membership()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_vlan_membership()\fR" 4
.IX Item "$bridge->i_vlan_membership()"
Returns reference to hash of arrays: key = \f(CW\*(C`ifIndex\*(C'\fR, value = array of \s-1VLAN\s0
IDs.  These are the VLANs which are members of the egress list for the port.
.Sp
.Vb 3
\&  Example:
\&  my $interfaces = $bridge\->interfaces();
\&  my $vlans      = $bridge\->i_vlan_membership();
\&
\&  foreach my $iid (sort keys %$interfaces) {
\&    my $port = $interfaces\->{$iid};
\&    my $vlan = join(\*(Aq,\*(Aq, sort(@{$vlans\->{$iid}}));
\&    print "Port: $port VLAN: $vlan\en";
\&  }
.Ve
.ie n .IP "$bridge\->\fBi_vlan_membership_untagged()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_vlan_membership_untagged()\fR" 4
.IX Item "$bridge->i_vlan_membership_untagged()"
Returns reference to hash of arrays: key = \f(CW\*(C`ifIndex\*(C'\fR, value = array of \s-1VLAN\s0
IDs.  These are the VLANs which are members of the untagged egress list for
the port.
.ie n .IP "$bridge\->\fBqb_i_vlan_t()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_i_vlan_t()\fR" 4
.IX Item "$bridge->qb_i_vlan_t()"
Returns reference to hash: key = \f(CW\*(C`dot1dBasePort\*(C'\fR, value = either 'trunk' for
tagged ports or the \s-1VLAN ID.\s0
.ie n .IP "$bridge\->\fBqb_fdb_index()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_fdb_index()\fR" 4
.IX Item "$bridge->qb_fdb_index()"
Returns reference to hash: key = \s-1FDB ID,\s0 value = \s-1VLAN ID.\s0
.ie n .IP "$bridge\->\fBv_index()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBv_index()\fR" 4
.IX Item "$bridge->v_index()"
Returns \s-1VLAN\s0 IDs
.ie n .SS "Forwarding Table (""dot1dTpFdbEntry"")"
.el .SS "Forwarding Table (\f(CWdot1dTpFdbEntry\fP)"
.IX Subsection "Forwarding Table (dot1dTpFdbEntry)"
.ie n .IP "$bridge\->\fBfw_mac()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBfw_mac()\fR" 4
.IX Item "$bridge->fw_mac()"
Returns reference to hash of forwarding table \s-1MAC\s0 Addresses
.Sp
(\f(CW\*(C`dot1dTpFdbAddress\*(C'\fR)
.ie n .IP "$bridge\->\fBfw_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBfw_port()\fR" 4
.IX Item "$bridge->fw_port()"
Returns reference to hash of forwarding table entries port interface
identifier (iid)
.Sp
(\f(CW\*(C`dot1dTpFdbPort\*(C'\fR)
.ie n .IP "$bridge\->\fBfw_status()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBfw_status()\fR" 4
.IX Item "$bridge->fw_status()"
Returns reference to hash of forwarding table entries status
.Sp
(\f(CW\*(C`dot1dTpFdbStatus\*(C'\fR)
.ie n .SS "Bridge Port Table (""dot1dBasePortEntry"")"
.el .SS "Bridge Port Table (\f(CWdot1dBasePortEntry\fP)"
.IX Subsection "Bridge Port Table (dot1dBasePortEntry)"
.ie n .IP "$bridge\->\fBbp_index()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBbp_index()\fR" 4
.IX Item "$bridge->bp_index()"
Returns reference to hash of bridge port table entries map back to interface
identifier (iid)
.Sp
(\f(CW\*(C`dot1dBasePortIfIndex\*(C'\fR)
.ie n .IP "$bridge\->\fBbp_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBbp_port()\fR" 4
.IX Item "$bridge->bp_port()"
Returns reference to hash of bridge port table entries for a port which
(potentially) has the same value of \f(CW\*(C`dot1dBasePortIfIndex\*(C'\fR as another port
on the same bridge, this object contains the name of an	object instance unique
to this port.
.Sp
(\f(CW\*(C`dot1dBasePortCircuit\*(C'\fR)
.SS "Spanning Tree Instance Globals"
.IX Subsection "Spanning Tree Instance Globals"
These are not part of a table, but return a hash reference to ease \s-1API\s0
compatibility with \s-1MST\s0 and \s-1PVST\s0 implementations indexed by a spanning tree
instance id.
.ie n .IP "$bridge\->\fBstp_i_time()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_i_time()\fR" 4
.IX Item "$bridge->stp_i_time()"
Returns time since last topology change detected. (100ths/second)
.Sp
(\f(CW\*(C`dot1dStpTimeSinceTopologyChange\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_i_time()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_i_time()\fR" 4
.IX Item "$bridge->stp_i_time()"
Returns the total number of topology changes detected.
.Sp
(\f(CW\*(C`dot1dStpTopChanges\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_i_root()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_i_root()\fR" 4
.IX Item "$bridge->stp_i_root()"
Returns root of \s-1STP.\s0
.Sp
(\f(CW\*(C`dot1dStpDesignatedRoot\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_i_root_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_i_root_port()\fR" 4
.IX Item "$bridge->stp_i_root_port()"
Returns the port number of the port that offers the lowest cost path
to the root bridge.
.Sp
(\f(CW\*(C`dot1dStpRootPort\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_i_priority()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_i_priority()\fR" 4
.IX Item "$bridge->stp_i_priority()"
Returns the port number of the port that offers the lowest cost path
to the root bridge.
.Sp
(\f(CW\*(C`dot1dStpPriority\*(C'\fR)
.ie n .SS "Spanning Tree Protocol Table (""dot1dStpPortTable"")"
.el .SS "Spanning Tree Protocol Table (\f(CWdot1dStpPortTable\fP)"
.IX Subsection "Spanning Tree Protocol Table (dot1dStpPortTable)"
Descriptions are straight from \fI\s-1BRIDGE\-MIB\s0.my\fR
.ie n .IP "$bridge\->\fBstp_p_id()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_id()\fR" 4
.IX Item "$bridge->stp_p_id()"
\&\*(L"The port number of the port for which this entry contains Spanning Tree
Protocol management information.\*(R"
.Sp
(\f(CW\*(C`dot1dStpPort\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_priority()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_priority()\fR" 4
.IX Item "$bridge->stp_p_priority()"
"The value of the priority field which is contained in the first
(in network byte order) octet of the (2 octet long) Port \s-1ID.\s0  The other octet
of the Port \s-1ID\s0 is given by the value of \f(CW\*(C`dot1dStpPort\*(C'\fR."
.Sp
(\f(CW\*(C`dot1dStpPortPriority\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_state()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_state()\fR" 4
.IX Item "$bridge->stp_p_state()"
"The port's current state as defined by application of the Spanning Tree
Protocol.  This state controls what action a port takes on reception of a
frame.  If the bridge has detected a port that is malfunctioning it will place
that port into the \fBbroken\fR\|(6) state.  For ports which are disabled
(see \f(CW\*(C`dot1dStpPortEnable\*(C'\fR), this object will have a value of \fBdisabled\fR\|(1)."
.Sp
.Vb 6
\& disabled(1)
\& blocking(2)
\& listening(3)
\& learning(4)
\& forwarding(5)
\& broken(6)
.Ve
.Sp
(\f(CW\*(C`dot1dStpPortState\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_cost()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_cost()\fR" 4
.IX Item "$bridge->stp_p_cost()"
\&\*(L"The contribution of this port to the path cost of paths towards the spanning
tree root which include this port.  802.1D\-1990 recommends that the default
value of this parameter be in inverse proportion to the speed of the attached
\&\s-1LAN.\*(R"\s0
.Sp
(\f(CW\*(C`dot1dStpPortPathCost\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_root()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_root()\fR" 4
.IX Item "$bridge->stp_p_root()"
\&\*(L"The unique Bridge Identifier of the Bridge recorded as the Root in the
Configuration BPDUs transmitted by the Designated Bridge for the segment to
which the port is attached.\*(R"
.Sp
(\f(CW\*(C`dot1dStpPortDesignatedRoot\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_bridge()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_bridge()\fR" 4
.IX Item "$bridge->stp_p_bridge()"
\&\*(L"The Bridge Identifier of the bridge which this port considers to be the
Designated Bridge for this port's segment.\*(R"
.Sp
(\f(CW\*(C`dot1dStpPortDesignatedBridge\*(C'\fR)
.ie n .IP "$bridge\->\fBstp_p_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBstp_p_port()\fR" 4
.IX Item "$bridge->stp_p_port()"
(\f(CW\*(C`dot1dStpPortDesignatedPort\*(C'\fR)
.Sp
\&\*(L"The Port Identifier of the port on the Designated Bridge for this port's
segment.\*(R"
.ie n .IP "$bridge\->\fBi_stp_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_stp_port()\fR" 4
.IX Item "$bridge->i_stp_port()"
Returns the mapping of (\f(CW\*(C`dot1dStpPortDesignatedPort\*(C'\fR) to the interface
index (iid).
.ie n .IP "$bridge\->\fBi_stp_state()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_stp_state()\fR" 4
.IX Item "$bridge->i_stp_state()"
Returns the mapping of (\f(CW\*(C`dot1dStpPortState\*(C'\fR) to the interface
index (iid).
.ie n .IP "$bridge\->\fBi_stp_id()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_stp_id()\fR" 4
.IX Item "$bridge->i_stp_id()"
Returns the mapping of (\f(CW\*(C`dot1dStpPort\*(C'\fR) to the interface index (iid).
.ie n .IP "$bridge\->\fBi_stp_bridge()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBi_stp_bridge()\fR" 4
.IX Item "$bridge->i_stp_bridge()"
Returns the mapping of (\f(CW\*(C`dot1dStpPortDesignatedBridge\*(C'\fR) to the interface
index (iid).
.ie n .SS "Q\-BRIDGE Port \s-1VLAN\s0 Table (""dot1qPortVlanTable"")"
.el .SS "Q\-BRIDGE Port \s-1VLAN\s0 Table (\f(CWdot1qPortVlanTable\fP)"
.IX Subsection "Q-BRIDGE Port VLAN Table (dot1qPortVlanTable)"
.ie n .IP "$bridge\->\fBqb_i_vlan()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_i_vlan()\fR" 4
.IX Item "$bridge->qb_i_vlan()"
The \s-1PVID,\s0 the \s-1VLAN ID\s0 assigned to untagged frames or Priority-Tagged frames
received on this port.
.Sp
(\f(CW\*(C`dot1qPvid\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_i_vlan_type()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_i_vlan_type()\fR" 4
.IX Item "$bridge->qb_i_vlan_type()"
Either \f(CW\*(C`admitAll\*(C'\fR or \f(CW\*(C`admitOnlyVlanTagged\*(C'\fR.  This is a good spot to find
trunk ports.
.Sp
(\f(CW\*(C`dot1qPortAcceptableFrameTypes\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_i_vlan_in_flt()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_i_vlan_in_flt()\fR" 4
.IX Item "$bridge->qb_i_vlan_in_flt()"
When this is \f(CW\*(C`true\*(C'\fR the device will discard incoming frames for VLANs which
do not include this Port in its Member set.  When \f(CW\*(C`false\*(C'\fR, the port will
accept all incoming frames.
.Sp
(\f(CW\*(C`dot1qPortIngressFiltering\*(C'\fR)
.ie n .SS "Q\-BRIDGE \s-1VLAN\s0 Current Table (""dot1qVlanCurrentTable"")"
.el .SS "Q\-BRIDGE \s-1VLAN\s0 Current Table (\f(CWdot1qVlanCurrentTable\fP)"
.IX Subsection "Q-BRIDGE VLAN Current Table (dot1qVlanCurrentTable)"
.ie n .IP "$bridge\->\fBqb_cv_egress()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_cv_egress()\fR" 4
.IX Item "$bridge->qb_cv_egress()"
The set of ports which are assigned to the egress list for this \s-1VLAN.\s0
.Sp
(\f(CW\*(C`dot1qVlanCurrentEgressPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_cv_untagged()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_cv_untagged()\fR" 4
.IX Item "$bridge->qb_cv_untagged()"
The set of ports which should transmit egress packets for this \s-1VLAN\s0 as
untagged.
.Sp
(\f(CW\*(C`dot1qVlanCurrentUntaggedPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_cv_stat()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_cv_stat()\fR" 4
.IX Item "$bridge->qb_cv_stat()"
Status of the \s-1VLAN,\s0 other, permanent, or dynamicGvrp.
.Sp
(\f(CW\*(C`dot1qVlanStatus\*(C'\fR)
.ie n .SS "Q\-BRIDGE \s-1VLAN\s0 Static Table (""dot1qVlanStaticTable"")"
.el .SS "Q\-BRIDGE \s-1VLAN\s0 Static Table (\f(CWdot1qVlanStaticTable\fP)"
.IX Subsection "Q-BRIDGE VLAN Static Table (dot1qVlanStaticTable)"
.ie n .IP "$bridge\->\fBqb_v_name()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_v_name()\fR" 4
.IX Item "$bridge->qb_v_name()"
Human-entered name for vlans.
.Sp
(\f(CW\*(C`dot1qVlanStaticName\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_v_egress()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_v_egress()\fR" 4
.IX Item "$bridge->qb_v_egress()"
The set of ports which are assigned to the egress list for this \s-1VLAN.\s0
.Sp
(\f(CW\*(C`dot1qVlanStaticEgressPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_v_fbdn_egress()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_v_fbdn_egress()\fR" 4
.IX Item "$bridge->qb_v_fbdn_egress()"
The set of ports which are prohibited from being included in the egress list
for this \s-1VLAN.\s0
.Sp
(\f(CW\*(C`dot1qVlanForbiddenEgressPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_v_untagged()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_v_untagged()\fR" 4
.IX Item "$bridge->qb_v_untagged()"
The set of ports which should transmit egress packets for this \s-1VLAN\s0 as
untagged.
.Sp
(\f(CW\*(C`dot1qVlanStaticUntaggedPorts\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_v_stat()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_v_stat()\fR" 4
.IX Item "$bridge->qb_v_stat()"
\&\f(CW\*(C`active\*(C'\fR !
.Sp
(\f(CW\*(C`dot1qVlanStaticRowStatus\*(C'\fR)
.ie n .SS "Q\-BRIDGE Filtering Database Table (""dot1qFdbTable"")"
.el .SS "Q\-BRIDGE Filtering Database Table (\f(CWdot1qFdbTable\fP)"
.IX Subsection "Q-BRIDGE Filtering Database Table (dot1qFdbTable)"
.ie n .IP "$bridge\->\fBqb_fw_mac()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_fw_mac()\fR" 4
.IX Item "$bridge->qb_fw_mac()"
Returns reference to hash of forwarding table \s-1MAC\s0 Addresses
.Sp
(\f(CW\*(C`dot1qTpFdbAddress\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_fw_port()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_fw_port()\fR" 4
.IX Item "$bridge->qb_fw_port()"
Returns reference to hash of forwarding table entries port interface
identifier (iid)
.Sp
(\f(CW\*(C`dot1qTpFdbPort\*(C'\fR)
.ie n .IP "$bridge\->\fBqb_fw_vlan()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_fw_vlan()\fR" 4
.IX Item "$bridge->qb_fw_vlan()"
Returns reference to hash of forwarding table entries \s-1VLAN ID\s0
.ie n .IP "$bridge\->\fBqb_fw_status()\fR" 4
.el .IP "\f(CW$bridge\fR\->\fBqb_fw_status()\fR" 4
.IX Item "$bridge->qb_fw_status()"
Returns reference to hash of forwarding table entries status
.Sp
(\f(CW\*(C`dot1qTpFdbStatus\*(C'\fR)
.SH "SET METHODS"
.IX Header "SET METHODS"
These are methods that provide \s-1SNMP\s0 set functionality for overridden methods
or provide a simpler interface to complex set operations.  See
\&\*(L"\s-1SETTING DATA VIA SNMP\*(R"\s0 in SNMP::Info for general information on set
operations.
.ie n .IP "$bridge\->set_i_vlan(vlan, ifIndex)" 4
.el .IP "\f(CW$bridge\fR\->set_i_vlan(vlan, ifIndex)" 4
.IX Item "$bridge->set_i_vlan(vlan, ifIndex)"
Currently unsupported.  Throws an error and returns.
.ie n .IP "$bridge\->set_i_untagged(vlan, ifIndex)" 4
.el .IP "\f(CW$bridge\fR\->set_i_untagged(vlan, ifIndex)" 4
.IX Item "$bridge->set_i_untagged(vlan, ifIndex)"
An alias for \f(CW\*(C`set_i_vlan\*(C'\fR.
.ie n .IP "$bridge\->set_i_pvid(pvid, ifIndex)" 4
.el .IP "\f(CW$bridge\fR\->set_i_pvid(pvid, ifIndex)" 4
.IX Item "$bridge->set_i_pvid(pvid, ifIndex)"
Currently unsupported.  Throws an error and returns.
.ie n .IP "$bridge\->set_add_i_vlan_tagged(vlan, ifIndex)" 4
.el .IP "\f(CW$bridge\fR\->set_add_i_vlan_tagged(vlan, ifIndex)" 4
.IX Item "$bridge->set_add_i_vlan_tagged(vlan, ifIndex)"
Currently unsupported.  Throws an error and returns.
.ie n .IP "$bridge\->set_remove_i_vlan_tagged(vlan, ifIndex)" 4
.el .IP "\f(CW$bridge\fR\->set_remove_i_vlan_tagged(vlan, ifIndex)" 4
.IX Item "$bridge->set_remove_i_vlan_tagged(vlan, ifIndex)"
Currently unsupported.  Throws an error and returns.
