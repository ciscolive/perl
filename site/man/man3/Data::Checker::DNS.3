.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Checker::DNS 3"
.TH Data::Checker::DNS 3 "2020-08-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Checker::DNS \- check data to see if it is valid in DNS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Data::Checker;
\&   $obj = new Data::Checker;
\&
\&   $obj\->check($data,"DNS",$check_opts);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is meant to be used by the Data::Checker module.
.PP
One set of checks that is often done on sets of hostnames or IPs is to
check that they are defined in \s-1DNS.\s0  This module provides several \s-1DNS\s0
related checks that can be performed.  It uses the Net::DNS module
to actually do the checks.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBcheck\fR" 4
.IX Item "check"
This is the only function provided by this module, and it is
intended to be used by the Data::Checker module.
.SH "CHECKS OPTIONS"
.IX Header "CHECKS OPTIONS"
The \f(CW$check_opts\fR hashref defines exactly what \s-1DNS\s0 checks to perform,
and some options used by those checks.  Known keys that specify the
checks are:
.IP "qualified" 4
.IX Item "qualified"
If this keys is present, the hostname is tested to see if it
is fully qualified or not.  This check will fail on on \s-1IP.\s0
.Sp
This check does not actually do a \s-1DNS\s0 lookup.  Instead, it looks at the
hostname to see if is fully qualified or not.
.Sp
If this is given, the host must be fully qualifed to pass (or
unqualifed if the 'negate' option is given).
.IP "dns" 4
.IX Item "dns"
If this key is present, the hostname or \s-1IP\s0 is tested to see if it is
in \s-1DNS.\s0  If it is defined in \s-1DNS,\s0 it passes.
.Sp
This is the default check done, and if \f(CW$check_opts\fR is not passed
in, this check will be performed.
.IP "expected_ip, expected_domain, expected_hostname" 4
.IX Item "expected_ip, expected_domain, expected_hostname"
If any of these keys are present, the information in \s-1DNS\s0 is tested
to make sure that the values are as expected.
.Sp
The expected value should be stored in the description passed to the check
function (see Data::Checker for more information), or in the 'value' option
in \f(CW$check_opts\fR.
.Sp
If the description is a hashref and there are keys 'ip', 'domain', or
\&'hostname' respectively, the values are either a string or a listref
of strings, and the value in \s-1DNS\s0 must match one of those strings.
.Sp
Alternately, if the description does not exist or does not contain
those keys, the 'value' option in \f(CW$check_opts\fR will be used.
.Sp
If the 'negate' option is included, the values are restricted value
which cannot be used in \s-1DNS.\s0
.PP
The following keys can also be present to specify additional options:
.IP "nameservers" 4
.IX Item "nameservers"
This is a whitespace separated list of nameservers to use.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
All examples include the following lines:
.PP
.Vb 2
\&   use Data::Checker;
\&   $obj = new Data::Checker;
\&
\&   $data = ...
\&   $opts = ...
\&
\&   ($pass,$fail,$info,$warn) = $obj\->check($data,"DNS",$opts);
.Ve
.PP
The value of \f(CW$data\fR and \f(CW$opts\fR is listed below in the examples.
.IP "To check if a hostname is fully qualified" 4
.IX Item "To check if a hostname is fully qualified"
.Vb 2
\&   $data = [ \*(Aqfoo\*(Aq, \*(Aqbar.com\*(Aq ];
\&   $opts = { \*(Aqqualified\*(Aq  => undef };
.Ve
.Sp
This yields:
.Sp
.Vb 2
\&   $pass = [ \*(Aqbar.com\*(Aq ]
\&   $fail = { \*(Aqfoo\*(Aq => [ \*(AqHost is not fully qualified\*(Aq ] }
.Ve
.IP "To check if a hostname is \s-1NOT\s0 fully qualified:" 4
.IX Item "To check if a hostname is NOT fully qualified:"
.Vb 2
\&   $data = [ \*(Aqfoo\*(Aq, \*(Aqbar.com\*(Aq ];
\&   $opts = { \*(Aqqualified\*(Aq => { \*(Aqnegate\*(Aq => 1 } };
.Ve
.Sp
This yields:
.Sp
.Vb 2
\&   $pass = [ \*(Aqfoo\*(Aq ]
\&   $fail = { \*(Aqbar.com\*(Aq => [ \*(AqHost is fully qualified\*(Aq ] }
.Ve
.IP "To check that a host is in \s-1DNS:\s0" 4
.IX Item "To check that a host is in DNS:"
.Vb 2
\&   $data = [ \*(Aqcpan.org\*(Aq, \*(Aqaaa.bbb.ccc\*(Aq ];
\&   $opts = { \*(Aqdns\*(Aq => undef };
.Ve
.IP "To check that a host has the expected \s-1IP\s0 in \s-1DNS\s0" 4
.IX Item "To check that a host has the expected IP in DNS"
Current \s-1DNS\s0 shows:
.Sp
.Vb 2
\&   cpan.org        = 207.171.7.91
\&   blogs.perl.org  = 188.40.132.3
.Ve
.Sp
The test:
.Sp
.Vb 5
\&   $data = { \*(Aqcpan.org\*(Aq       => { \*(Aqip\*(Aq  => \*(Aq207.171.7.91\*(Aq },
\&             \*(Aqblogs.perl.org\*(Aq => { \*(Aqip\*(Aq  => \*(Aq100.101.102.103\*(Aq }
\&           };
\&   $opts = { \*(Aqdns\*(Aq => undef,
\&             \*(Aqexpected_ip\*(Aq => undef };
.Ve
.Sp
Yields:
.Sp
.Vb 2
\&   $pass = { \*(Aqcpan.org\*(Aq       => { \*(Aqip\*(Aq  => \*(Aq207.171.7.91\*(Aq } }
\&   $fail = { \*(Aqblogs.perl.org\*(Aq => [ \*(AqDNS IP value does not match expected value\*(Aq ] }
.Ve
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
None known.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Checker, Net::DNS
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
