.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::mysql::Database 3"
.TH Mojo::mysql::Database 3 "2020-04-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::mysql::Database \- Database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::mysql::Database;
\&
\&  my $db = Mojo::mysql::Database\->new(mysql => $mysql, dbh => $dbh);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::mysql::Database is a container for database handles used by Mojo::mysql.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Mojo::mysql::Database implements the following attributes.
.SS "dbh"
.IX Subsection "dbh"
.Vb 2
\&  my $dbh = $db\->dbh;
\&  $db     = $db\->dbh(DBI\->new);
.Ve
.PP
Database handle used for all queries.
.SS "mysql"
.IX Subsection "mysql"
.Vb 2
\&  my $mysql = $db\->mysql;
\&  $db       = $db\->mysql(Mojo::mysql\->new);
.Ve
.PP
Mojo::mysql object this database belongs to.
.SS "results_class"
.IX Subsection "results_class"
.Vb 2
\&  $class = $db\->results_class;
\&  $db    = $db\->results_class("MyApp::Results");
.Ve
.PP
Class to be used by \*(L"query\*(R", defaults to Mojo::mysql::Results. Note that
this class needs to have already been loaded before \*(L"query\*(R" is called.
.SH "METHODS"
.IX Header "METHODS"
Mojo::mysql::Database inherits all methods from Mojo::EventEmitter and
implements the following new ones.
.SS "backlog"
.IX Subsection "backlog"
.Vb 1
\&  my $num = $db\->backlog;
.Ve
.PP
Number of waiting non-blocking queries.
.SS "begin"
.IX Subsection "begin"
.Vb 1
\&  my $tx = $db\->begin;
.Ve
.PP
Begin transaction and return Mojo::mysql::Transaction object, which will
automatically roll back the transaction unless
\&\*(L"commit\*(R" in Mojo::mysql::Transaction bas been called before it is destroyed.
.PP
.Vb 8
\&  # Add names in a transaction
\&  eval {
\&    my $tx = $db\->begin;
\&    $db\->query(\*(Aqinsert into names values (?)\*(Aq, \*(AqBaerbel\*(Aq);
\&    $db\->query(\*(Aqinsert into names values (?)\*(Aq, \*(AqWolfgang\*(Aq);
\&    $tx\->commit;
\&  };
\&  say $@ if $@;
.Ve
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  my $results = $db\->delete($table, \e%where);
.Ve
.PP
Generate a \f(CW\*(C`DELETE\*(C'\fR statement with \*(L"abstract\*(R" in Mojo::mysql (usually an
SQL::Abstract object) and execute it with \*(L"query\*(R". You can also append a
callback to perform operations non-blocking.
.PP
.Vb 5
\&  $db\->delete(some_table => sub {
\&    my ($db, $err, $results) = @_;
\&    ...
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "delete_p"
.IX Subsection "delete_p"
.Vb 1
\&  my $promise = $db\->delete_p($table, \e%where, \e%options);
\&
\&  Same as L</"delete">, but performs all operations non\-blocking and returns a
\&  L<Mojo::Promise> object instead of accepting a callback.
\&
\&  $db\->delete_p(\*(Aqsome_table\*(Aq)\->then(sub {
\&    my $results = shift;
\&    ...
\&  })\->catch(sub {
\&    my $err = shift;
\&    ...
\&  })\->wait;
.Ve
.SS "disconnect"
.IX Subsection "disconnect"
.Vb 1
\&  $db\->disconnect;
.Ve
.PP
Disconnect database handle and prevent it from getting cached again.
.SS "insert"
.IX Subsection "insert"
.Vb 1
\&  my $results = $db\->insert($table, \e@values || \e%fieldvals, \e%options);
.Ve
.PP
Generate an \f(CW\*(C`INSERT\*(C'\fR statement with \*(L"abstract\*(R" in Mojo::mysql (usually an
SQL::Abstract object) and execute it with \*(L"query\*(R". You can also append a
callback to perform operations non-blocking.
.PP
.Vb 5
\&  $db\->insert(some_table => {foo => \*(Aqbar\*(Aq} => sub {
\&    my ($db, $err, $results) = @_;
\&    ...
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "insert_p"
.IX Subsection "insert_p"
.Vb 1
\&  my $promise = $db\->insert_p($table, \e@values || \e%fieldvals, \e%options);
.Ve
.PP
Same as \*(L"insert\*(R", but performs all operations non-blocking and returns a
Mojo::Promise object instead of accepting a callback.
.PP
.Vb 7
\&  $db\->insert_p(some_table => {foo => \*(Aqbar\*(Aq})\->then(sub {
\&    my $results = shift;
\&    ...
\&  })\->catch(sub {
\&    my $err = shift;
\&    ...
\&  })\->wait;
.Ve
.SS "pid"
.IX Subsection "pid"
.Vb 1
\&  my $pid = $db\->pid;
.Ve
.PP
Return the connection id of the backend server process.
.SS "ping"
.IX Subsection "ping"
.Vb 1
\&  my $bool = $db\->ping;
.Ve
.PP
Check database connection.
.SS "query"
.IX Subsection "query"
.Vb 4
\&  my $results = $db\->query(\*(Aqselect * from foo\*(Aq);
\&  my $results = $db\->query(\*(Aqinsert into foo values (?, ?, ?)\*(Aq, @values);
\&  my $results = $db\->query(\*(Aqinsert into foo values (?)\*(Aq, {json => {bar => \*(Aqbaz\*(Aq}});
\&  my $results = $db\->query(\*(Aqinsert into foo values (?)\*(Aq, {type => SQL_INTEGER, value => 42});
.Ve
.PP
Execute a blocking statement and return a Mojo::mysql::Results object with the
results. You can also append a callback to perform operation non-blocking.
.PP
.Vb 5
\&  $db\->query(\*(Aqselect * from foo\*(Aq => sub {
\&    my ($db, $err, $results) = @_;
\&    ...
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.PP
Hash reference arguments containing a value named \f(CW\*(C`json\*(C'\fR, will be encoded to
\&\s-1JSON\s0 text with \*(L"to_json\*(R" in Mojo::JSON. To accomplish the reverse, you can use
the method \*(L"expand\*(R" in Mojo::mysql::Results, which automatically decodes data back
to Perl data structures.
.PP
.Vb 2
\&  $db\->query(\*(Aqinsert into foo values (x) values (?)\*(Aq, {json => {bar => \*(Aqbaz\*(Aq}});
\&  $db\->query(\*(Aqselect * from foo\*(Aq)\->expand\->hash\->{x}{bar}; # baz
.Ve
.PP
Hash reference arguments containing values named \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`value\*(C'\fR can be
used to bind specific \s-1DBI\s0 data types (see \*(L"\s-1DBI\s0 Constants\*(R" in \s-1DBI\s0) to
placeholders. This is needed to pass binary data in parameters; see
\&\*(L"mysql_enable_utf8\*(R" in DBD::mysql for more information.
.PP
.Vb 3
\&  # Insert binary data
\&  use DBI \*(Aq:sql_types\*(Aq;
\&  $db\->query(\*(Aqinsert into bar values (?)\*(Aq, {type => SQL_BLOB, value => $bytes});
.Ve
.SS "query_p"
.IX Subsection "query_p"
.Vb 1
\&  my $promise = $db\->query_p(\*(Aqselect * from foo\*(Aq);
.Ve
.PP
Same as \*(L"query\*(R", but performs all operations non-blocking and returns a
Mojo::Promise object instead of accepting a callback.
.PP
.Vb 7
\&  $db\->query_p(\*(Aqinsert into foo values (?, ?, ?)\*(Aq => @values)\->then(sub {
\&    my $results = shift;
\&    ...
\&  })\->catch(sub {
\&    my $err = shift;
\&    ...
\&  })\->wait;
.Ve
.SS "quote"
.IX Subsection "quote"
.Vb 1
\&  my $escaped = $db\->quote($str);
.Ve
.PP
Quote a string literal for use as a literal value in an \s-1SQL\s0 statement.
.SS "quote_id"
.IX Subsection "quote_id"
.Vb 1
\&  my $escaped = $db\->quote_id($id);
.Ve
.PP
Quote an identifier (table name etc.) for use in an \s-1SQL\s0 statement.
.SS "select"
.IX Subsection "select"
.Vb 1
\&  my $results = $db\->select($source, $fields, $where, $order);
.Ve
.PP
Generate a \f(CW\*(C`SELECT\*(C'\fR statement with \*(L"abstract\*(R" in Mojo::mysql (usually an
SQL::Abstract object) and execute it with \*(L"query\*(R". You can also append a
callback to perform operations non-blocking.
.PP
.Vb 5
\&  $db\->select(some_table => [\*(Aqfoo\*(Aq] => sub {
\&    my ($db, $err, $results) = @_;
\&    ...
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "select_p"
.IX Subsection "select_p"
.Vb 1
\&  my $promise = $db\->select_p($source, $fields, $where, $order);
.Ve
.PP
Same as \*(L"select\*(R", but performs all operations non-blocking and returns a
Mojo::Promise object instead of accepting a callback.
.PP
.Vb 7
\&  $db\->select_p(some_table => [\*(Aqfoo\*(Aq] => {bar => \*(Aqyada\*(Aq})\->then(sub {
\&    my $results = shift;
\&    ...
\&  })\->catch(sub {
\&    my $err = shift;
\&    ...
\&  })\->wait;
.Ve
.SS "update"
.IX Subsection "update"
.Vb 1
\&  my $results = $db\->update($table, \e%fieldvals, \e%where);
.Ve
.PP
Generate an \f(CW\*(C`UPDATE\*(C'\fR statement with \*(L"abstract\*(R" in Mojo::mysql (usually an
SQL::Abstract object) and execute it with \*(L"query\*(R". You can also append a
callback to perform operations non-blocking.
.PP
.Vb 5
\&  $db\->update(some_table => {foo => \*(Aqbaz\*(Aq} => {foo => \*(Aqbar\*(Aq} => sub {
\&    my ($db, $err, $results) = @_;
\&    ...
\&  });
\&  Mojo::IOLoop\->start unless Mojo::IOLoop\->is_running;
.Ve
.SS "update_p"
.IX Subsection "update_p"
.Vb 1
\&  my $promise = $db\->update_p($table, \e%fieldvals, \e%where, \e%options);
.Ve
.PP
Same as \*(L"update\*(R", but performs all operations non-blocking and returns a
Mojo::Promise object instead of accepting a callback.
.PP
.Vb 7
\&  $db\->update_p(some_table => {foo => \*(Aqbaz\*(Aq} => {foo => \*(Aqbar\*(Aq})\->then(sub {
\&    my $results = shift;
\&    ...
\&  })\->catch(sub {
\&    my $err = shift;
\&    ...
\&  })\->wait;
.Ve
.SS "tables"
.IX Subsection "tables"
.Vb 1
\&  my $tables = $db\->tables;
.Ve
.PP
Return an array reference with table names for this database.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojo::mysql.
