.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Walk::Print 3"
.TH Data::Walk::Print 3 "2016-08-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Walk::Print \- A data printing function
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        #!perl
\&        use MooseX::ShortCut::BuildInstance qw( build_instance );
\&        use YAML::Any;
\&        use Data::Walk::Extracted;
\&        use Data::Walk::Print;
\&
\&        #Use YAML to compress writing the data ref
\&        my  $firstref = Load(
\&                \*(Aq\-\-\-
\&                Someotherkey:
\&                        value
\&                Parsing:
\&                        HashRef:
\&                                LOGGER:
\&                                        run: INFO
\&                Helping:
\&                        \- Somelevel
\&                        \- MyKey:
\&                                MiddleKey:
\&                                        LowerKey1: lvalue1
\&                                        LowerKey2:
\&                                                BottomKey1: 12345
\&                                                BottomKey2:
\&                                                \- bavalue1
\&                                                \- bavalue2
\&                                                \- bavalue3\*(Aq
\&        );
\&        my  $secondref = Load(
\&                \*(Aq\-\-\-
\&                Someotherkey:
\&                        value
\&                Helping:
\&                        \- Somelevel
\&                        \- MyKey:
\&                                MiddleKey:
\&                                        LowerKey1: lvalue1
\&                                        LowerKey2:
\&                                                BottomKey2:
\&                                                \- bavalue1
\&                                                \- bavalue3
\&                                                BottomKey1: 12354\*(Aq
\&        );
\&        my $AT_ST = build_instance( 
\&                        package => \*(AqGutenberg\*(Aq,
\&                        superclasses =>[\*(AqData::Walk::Extracted\*(Aq],
\&                        roles =>[qw( Data::Walk::Print )],
\&                        match_highlighting => 1,#This is the default
\&                );
\&        $AT_ST\->print_data(
\&                print_ref       =>  $firstref,
\&                match_ref       =>  $secondref,
\&                sorted_nodes =>{
\&                        HASH => 1, #To force order for demo purposes
\&                }
\&        );
\&
\&        #################################################################################
\&        #     Output of SYNOPSIS
\&        # 01:{#<\-\-\- Ref Type Match
\&        # 02:   Helping => [#<\-\-\- Secondary Key Match \- Ref Type Match
\&        # 03:           \*(AqSomelevel\*(Aq,#<\-\-\- Secondary Position Exists \- Secondary Value Matches
\&        # 04:           {#<\-\-\- Secondary Position Exists \- Ref Type Match
\&        # 05:                   MyKey => {#<\-\-\- Secondary Key Match \- Ref Type Match
\&        # 06:                           MiddleKey => {#<\-\-\- Secondary Key Match \- Ref Type Match
\&        # 07:                                   LowerKey1 => \*(Aqlvalue1\*(Aq,#<\-\-\- Secondary Key Match \- Secondary Value Matches
\&        # 08:                                   LowerKey2 => {#<\-\-\- Secondary Key Match \- Ref Type Match
\&        # 09:                                           BottomKey1 => \*(Aq12345\*(Aq,#<\-\-\- Secondary Key Match \- Secondary Value Does NOT Match
\&        # 10:                                           BottomKey2 => [#<\-\-\- Secondary Key Match \- Ref Type Match
\&        # 11:                                                   \*(Aqbavalue1\*(Aq,#<\-\-\- Secondary Position Exists \- Secondary Value Matches
\&        # 12:                                                   \*(Aqbavalue2\*(Aq,#<\-\-\- Secondary Position Exists \- Secondary Value Does NOT Match
\&        # 13:                                                   \*(Aqbavalue3\*(Aq,#<\-\-\- Secondary Position Does NOT Exist \- Secondary Value Does NOT Match
\&        # 14:                                           ],
\&        # 15:                                   },
\&        # 16:                           },
\&        # 17:                   },
\&        # 18:           },
\&        # 19:   ],
\&        # 20:   Parsing => {#<\-\-\- Secondary Key Mismatch \- Ref Type Mismatch
\&        # 21:           HashRef => {#<\-\-\- Secondary Key Mismatch \- Ref Type Mismatch
\&        # 22:                   LOGGER => {#<\-\-\- Secondary Key Mismatch \- Ref Type Mismatch
\&        # 23:                           run => \*(AqINFO\*(Aq,#<\-\-\- Secondary Key Mismatch \- Secondary Value Does NOT Match
\&        # 24:                   },
\&        # 25:           },
\&        # 26:   },
\&        # 27:   Someotherkey => \*(Aqvalue\*(Aq,#<\-\-\- Secondary Key Match \- Secondary Value Matches
\&        # 28:},
\&        #################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose::Role <https://metacpan.org/module/Moose::Manual::Roles> is mostly written
as a demonstration module for Data::Walk::Extracted. 
Both Data::Dumper \- Dumper and \s-1YAML\s0 
\&\- Dump functions are more mature than the printing function included here.
.SS "\s-1USE\s0"
.IX Subsection "USE"
This is a Moose::Role specifically
designed to be used with Data::Walk::Extracted
 It can be combined traditionaly 
to the ~::Extracted class using Moose::Roles or for information on how to join
this role to Data::Walk::Extracted at run time see Moose::Util or 
MooseX::ShortCut::BuildInstance for more information.
.SH "Attributes"
.IX Header "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes
see Methods.  The \->new function will either accept fat comma lists or a
complete hash ref that has the possible attributes as the top keys.  Additionally
some attributes that have all the following methods; get_$attribute, set_$attribute,
has_$attribute, and clear_$attribute, can be passed to print_data
 and will be adjusted for just the run of that
method call.  These are called 'one shot' attributes.  The class and each role (where
applicable) in this package have a list of supported one shot attributes
\&.
.SS "match_highlighting"
.IX Subsection "match_highlighting"
.RS 4
\&\fBDefinition:\fR this determines if a comments string is added after each printed
row that indicates how the 'print_ref' matches the 'match_ref'.
.Sp
\&\fBDefault\fR True (1)
.Sp
\&\fBRange\fR This is a Boolean data type and generally accepts 1 or 0
.RE
.SS "to_string"
.IX Subsection "to_string"
.RS 4
\&\fBDefinition:\fR this determines whether the output is sent to \s-1STDOUT\s0 or coallated
into a final string and sent as a result of print_data
\&.
.Sp
\&\fBDefault\fR True (1)
.Sp
\&\fBRange\fR This is a Boolean data type and generally accepts 1 or 0
.RE
.SS "(see also)"
.IX Subsection "(see also)"
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted#Attributes>
\&\- Attributes
.SH "Methods"
.IX Header "Methods"
.ie n .SS "print_data( $arg_ref|%args|$data_ref )"
.el .SS "print_data( \f(CW$arg_ref\fP|%args|$data_ref )"
.IX Subsection "print_data( $arg_ref|%args|$data_ref )"
.RS 4
\&\fBDefinition:\fR this is the method used to print a data reference
.Sp
\&\fBAccepts:\fR either a single data reference or named arguments
in a fat comma list or hashref
.Sp
.RS 4
\&\fBnamed variable option\fR \- if data comes in a fat comma list or as a hash ref
and the keys include a 'print_ref' key then the list is processed as follows.
.Sp
.RS 4
\&\fBprint_ref\fR \- this is the data reference that should be printed in a perlish way
\&\- Required
.Sp
\&\fBmatch_ref\fR \- this is a reference used to compare against the 'print_ref'
\&\- Optional
.Sp
\&\fB[attribute name]\fR \- attribute names are accepted with temporary attribute settings.
These settings are temporarily set for a single \*(L"print_data\*(R" call and then the original
attribute values are restored.  For this to work the the attribute must meet the
necessary criteria.  These attributes can include all attributes active
for the constructed class not just this role.
.RE
.RE
.RS 4
.Sp
\&\fBsingle variable option\fR \- if only one data_ref is sent and it fails the test
for \*(L"exists \f(CW$data_ref\fR\->{print_ref}\*(R" then the program will attempt to name it as
print_ref => \f(CW$data_ref\fR and then process the data as a fat comma list.
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR 1 (And prints out the data ref) or a string \- see to_string
.RE
.ie n .SS "set_match_highlighting( $bool )"
.el .SS "set_match_highlighting( \f(CW$bool\fP )"
.IX Subsection "set_match_highlighting( $bool )"
.RS 4
\&\fBDefinition:\fR this is a way to change the match_highlighting
attribute
.Sp
\&\fBAccepts:\fR a Boolean value
.Sp
\&\fBReturns:\fR ''
.RE
.SS "get_match_highlighting"
.IX Subsection "get_match_highlighting"
.RS 4
\&\fBDefinition:\fR this is a way to view the state of the match_highlighting
attribute
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR The current 'match_highlighting' state
.RE
.SS "has_match_highlighting"
.IX Subsection "has_match_highlighting"
.RS 4
\&\fBDefinition:\fR this is a way to know if the match_highlighting
attribute is active
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 if the attribute is active (not just if it == 1)
.RE
.SS "clear_match_highlighting"
.IX Subsection "clear_match_highlighting"
.RS 4
\&\fBDefinition:\fR this clears the match_highlighting attribute
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR '' (always successful)
.RE
.ie n .SS "set_to_string( $bool )"
.el .SS "set_to_string( \f(CW$bool\fP )"
.IX Subsection "set_to_string( $bool )"
.RS 4
\&\fBDefinition:\fR this is a way to change the to_string
attribute
.Sp
\&\fBAccepts:\fR a Boolean value
.Sp
\&\fBReturns:\fR ''
.RE
.SS "get_to_string"
.IX Subsection "get_to_string"
.RS 4
\&\fBDefinition:\fR this is a way to view the state of the to_string
attribute
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR The current 'to_string' state
.RE
.SS "has_to_string"
.IX Subsection "has_to_string"
.RS 4
\&\fBDefinition:\fR this is a way to know if the to_string
attribute is active
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 if the attribute is active (not just if it == 1)
.RE
.SS "clear_to_string"
.IX Subsection "clear_to_string"
.RS 4
\&\fBDefinition:\fR this clears the to_string attribute
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR '' (always successful)
.RE
.SH "Caveat utilitor"
.IX Header "Caveat utilitor"
.SS "Supported Node types"
.IX Subsection "Supported Node types"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
.IP "\s-1UNDEF\s0" 4
.IX Item "UNDEF"
.PD
.SS "Supported one shot attributes"
.IX Subsection "Supported one shot attributes"
explanation
.IP "match_highlighting" 4
.IX Item "match_highlighting"
.PD 0
.IP "to_string" 4
.IX Item "to_string"
.PD
.SS "Printing for skipped nodes"
.IX Subsection "Printing for skipped nodes"
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted> allows for some
nodes to be skipped.  When a node is skipped the print_data
 function prints the scalar (perl pointer description)
of that node.
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Data\-Walk\-Extracted/issues <https://github.com/jandrew/Data-Walk-Extracted/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Support printing Objects / Instances
.Sp
\&\fB2.\fR Support printing CodeRefs
.Sp
\&\fB3.\fR Support \s-1REF\s0 types
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund.
.SH "Dependencies"
.IX Header "Dependencies"
version
.PP
utf8
.PP
Moose::Role
.Sp
.RS 4
\&\fBrequires\fR
.IP "_process_the_data" 4
.IX Item "_process_the_data"
.PD 0
.IP "_get_had_secondary" 4
.IX Item "_get_had_secondary"
.IP "_dispatch_method" 4
.IX Item "_dispatch_method"
.RE
.RS 4
.RE
.PD
.PP
MooseX::Types::Moose
.PP
Data::Walk::Extracted
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Log::Shiras::Unhide \- Can use to unhide '###InternalExtracteDGrafT' tags
.Sp
Log::Shiras::TapWarn \- to manage the output of exposed '###InternalExtracteDGrafT' lines
.Sp
Data::Dumper \- used in the '###InternalExtracteDGrafT' lines
.Sp
Data::Walk
.Sp
Data::Walker
.Sp
Data::Dumper \- Dumper
.Sp
\&\s-1YAML\s0 \- Dump
.RE
