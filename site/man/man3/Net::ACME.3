.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::ACME 3"
.TH Net::ACME 3 "2019-03-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::ACME \- Client for the (old) ACME protocol (e.g., Let’s Encrypt <http://letsencrypt.org>)
.PP

.IX Xref "Lets Encrypt Let's Encrypt letsencrypt"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package MyACME::SomeService;
\&
\&    use constant _HOST => ...;   #the name of the ACME host
\&
\&    #See below for full examples.
.Ve
.SH "END-OF-LIFE WARNING"
.IX Header "END-OF-LIFE WARNING"
\&\fB\s-1WARNING:\s0\fR Let’s Encrypt has announced end-of-life for their \s-1API\s0
that uses this protocol <https://community.letsencrypt.org/t/end-of-life-plan-for-acmev1/88430>. All applications that use this module should migrate to
Net::ACME2. Further use of this module is discouraged.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements client logic (including \s-1SSL\s0 certificate issuance)
for the “draft” version of the \s-1ACME\s0 protocol,
the system for automated issuance of \s-1SSL\s0 certificates used by
Let’s Encrypt <http://letsencrypt.org>.
.PP
For support of the \s-1IETF\s0 <http://ietf.org>\-standard version of this
protocol, look at Net::ACME2.
.PP
The methods of this class return objects that correspond to the
respective \s-1ACME\s0 resource:
.IP "\(bu" 4
\&\f(CW\*(C`register()\*(C'\fR: \f(CW\*(C`Net::ACME::Registration\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`start_domain_authz()\*(C'\fR: \f(CW\*(C`Net::ACME::Authorization::Pending\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`get_certificate()\*(C'\fR: \f(CW\*(C`Net::ACME::Certificate\*(C'\fR or \f(CW\*(C`Net::ACME::Certificate::Pending\*(C'\fR
.SH "WHY USE THIS MODULE?"
.IX Header "WHY USE THIS MODULE?"
.IP "\(bu" 4
Closely based on cPanel’s widely-used Let’s Encrypt plugin.
.IP "\(bu" 4
Support for both \s-1RSA\s0 and \s-1ECDSA\s0 encryption (via Crypt::Perl).
.IP "\(bu" 4
Thorough error-checking: any deviation from what the \s-1ACME\s0 protocol
expects is reported immediately via an exception.
.IP "\(bu" 4
Well-defined object system, including typed, queryable exceptions.
.IP "\(bu" 4
Extensive test coverage.
.IP "\(bu" 4
Light memory footprint \- no Moose/Moo/etc.
.IP "\(bu" 4
No careless overwriting of globals like \f(CW$@\fR, \f(CW$!\fR, and \f(CW$?\fR.
(Hopefully your code isn’t susceptible to this anyway, but it’s just a good
precaution.)
.IP "\(bu" 4
This is a pure-Perl solution. Most of its dependencies are
either core modules or pure Perl themselves. \s-1XS\s0 is necessary to
communicate with the \s-1ACME\s0 server via \s-1TLS\s0; however, most Perl installations
already include the necessary logic (i.e., Net::SSLeay) for \s-1TLS.\s0
.Sp
In short, Net::ACME will run anywhere that Perl can speak \s-1TLS,\s0 which is
\&\fIalmost\fR everywhere that Perl runs.
.SH "STATUS"
.IX Header "STATUS"
This module is now well-tested and should be safe for use in your application.
.SH "CUSTOMIZATION"
.IX Header "CUSTOMIZATION"
\&\fB\s-1HTTPS\s0 options\fR: This module uses \f(CW\*(C`HTTP::Tiny\*(C'\fR for its network operations.
In some instances it is desirable to specify custom \f(CW\*(C`SSL_options\*(C'\fR in that
module’s constructor; to do this, populate
\&\f(CW@Net::ACME::HTTP_Tiny::SSL_OPTIONS\fR.
.SH "URI vs. URL"
.IX Header "URI vs. URL"
This module uses “uri” for ACME-related objects and “url” for
HTTP-related ones. This apparent conflict is a result of maintaining
consistency with both the \s-1ACME\s0 specification (“uri”) and HTTP::Tiny (“url”).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the \f(CW\*(C`examples\*(C'\fR directory in the distribution for complete, interactive
example scripts that also illustrate a bit of how \s-1ACME\s0 works.
.PP
See below for cut-paste-y examples.
.SH "EXAMPLE: REGISTRATION"
.IX Header "EXAMPLE: REGISTRATION"
.Vb 1
\&    my $tos_url = Net::ACME::LetsEncrypt\->get_terms_of_service();
\&
\&    my $acme = Net::ACME::LetsEncrypt\->new( key => $reg_rsa_pem );
\&
\&    #Use this method any time you want to update contact information,
\&    #not just when you set up a new account.
\&    my $reg = $acme\->register(\*(Aqmailto:me@example.com\*(Aq, \*(Aqmailto:who@example.com\*(Aq);
\&
\&    $acme\->accept_tos( $reg\->uri(), $tos_url );
.Ve
.SH "EXAMPLE: DOMAIN AUTHORIZATION & CERTIFICATE PROCUREMENT"
.IX Header "EXAMPLE: DOMAIN AUTHORIZATION & CERTIFICATE PROCUREMENT"
.Vb 2
\&    for my $domain (@domains) {
\&        my $authz_p = $acme\->start_domain_authz($domain);
\&
\&        for my $cmb_ar ( $authz_p\->combinations() ) {
\&
\&            #$cmb_ar is a set of challenges that the ACME server will
\&            #accept as proof of domain control. As of November 2016, these
\&            #sets all contain exactly one challenge each: “http\-01”, etc.
\&
\&            #Each member of @$cmb_ar is an instance of
\&            #Net::ACME::Challenge::Pending\-\-maybe a subclass thereof such as
\&            #Net::ACME::Challenge::Pending::http_01.
\&
\&            #At this point, you examine $cmb_ar and determine if this
\&            #combination is one that you’re interested in. You might try
\&            #something like:
\&            #
\&            #   next if @$cmb_ar > 1;
\&            #   next if $cmb_ar\->[0]\->type() ne \*(Aqhttp\-01\*(Aq;
\&
\&            #Once you’ve examined $cmb_ar and set up the appropriate response(s),
\&            #it’s time to tell the ACME server to send its challenge query.
\&            $acme\->do_challenge($_) for @$cmb_ar;
\&
\&            while (1) {
\&                if ( $authz_p\->is_time_to_poll() ) {
\&                    my $poll = $authz_p\->poll();
\&
\&                    last if $poll\->status() eq \*(Aqvalid\*(Aq;
\&
\&                    if ( $poll\->status() eq \*(Aqinvalid\*(Aq ) {
\&                        my @failed = map { $_\->error() } $poll\->challenges();
\&
\&                        warn $_\->to_string() . $/ for @failed;
\&
\&                        die "Failed authorization for “$domain”!";
\&                    }
\&
\&                }
\&
\&                sleep 1;
\&            }
\&        }
\&    }
\&
\&    #Make a key and CSR.
\&    #Creation of CSRs is well\-documented so won’t be discussed here.
\&
\&    my $cert = $acme\->get_certificate($csr_pem);
\&
\&    #This shouldn’t actually be necessary for Let’s Encrypt,
\&    #but the ACME protocol describes it.
\&    while ( !$cert\->pem() ) {
\&        sleep 1;
\&        next if !$cert\->is_time_to_poll();
\&        $cert = $cert\->poll() || $cert;
\&    }
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Once the \s-1ACME\s0 specification <https://tools.ietf.org/html/draft-ietf-acme-acme>
is finalized, update this module to take advantage of the full specification.
As Let’s Encrypt’s Boulder <https://github.com/letsencrypt/boulder> is currently
the only widely-used \s-1ACME\s0 server, and that software is compatible with
the first draft of the \s-1ACME\s0 spec <https://tools.ietf.org/html/draft-ietf-acme-acme-01>,
there’s little reason to update for the time being.
.SH "THANKS"
.IX Header "THANKS"
.IP "\(bu" 4
cPanel, Inc. for permission to adapt their \s-1ACME\s0 framework for
public consumption.
.IP "\(bu" 4
Stephen Ludin for developing and maintaining Protocol::ACME, from which
this module took its inspiration.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For support of the version of this protocol codified in
\&\s-1RFC 8555\s0 <https://www.rfc-editor.org/rfc/rfc8555.txt>, look at
Net::ACME2.
.PP
I am aware of the following additional \s-1CPAN\s0 modules that implement
the draft \s-1ACME\s0 protocol:
.IP "\(bu" 4
Protocol::ACME
.IP "\(bu" 4
Crypt::LE
.IP "\(bu" 4
WWW::LetsEncrypt
.IP "\(bu" 4
Mojo::ACME
.SH "REPOSITORY (FEEDBACK/BUGS)"
.IX Header "REPOSITORY (FEEDBACK/BUGS)"
<https://github.com/FGasper/p5\-Net\-ACME>
.SH "AUTHOR"
.IX Header "AUTHOR"
Felipe Gasper (\s-1FELIPE\s0)
.SH "LICENSE"
.IX Header "LICENSE"
This module is licensed under the same terms as Perl.
