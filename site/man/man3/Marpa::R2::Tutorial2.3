.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Tutorial2 3"
.TH Marpa::R2::Tutorial2 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Tutorial2 \- Marpa Tutorial 2
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&    use Marpa::R2;
\&
\&    my $dsl = <<\*(AqEND_OF_DSL\*(Aq;
\&    :default ::= action => [name,values]
\&    lexeme default = latm => 1
\&    Calculator ::= Expression action => ::first
\&
\&    Factor ::= Number action => ::first
\&    Term ::=
\&        Term \*(Aq*\*(Aq Factor action => do_multiply
\&        | Factor action => ::first
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
\&    Number ~ digits
\&    digits ~ [\ed]+
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    END_OF_DSL
\&
\&    my $grammar = Marpa::R2::Scanless::G\->new( { source => \e$dsl } );
\&    my $recce = Marpa::R2::Scanless::R\->new(
\&        { grammar => $grammar, semantics_package => \*(AqMy_Actions\*(Aq } );
\&    my $input = \*(Aq42 * 1 + 7\*(Aq;
\&    my $length_read = $recce\->read( \e$input );
\&
\&    die "Read ended after $length_read of ", length $input, " characters"
\&        if $length_read != length $input;
\&
\&    if ( my $ambiguous_status = $recce\->ambiguous() ) {
\&        chomp $ambiguous_status;
\&        die "Parse is ambiguous\en", $ambiguous_status;
\&    }
\&
\&    my $value_ref = $recce\->value;
\&    my $value = ${$value_ref};
\&
\&    sub My_Actions::do_add {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 + $t2;
\&    }
\&
\&    sub My_Actions::do_multiply {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 * $t2;
\&    }
.Ve
.SH "Description"
.IX Header "Description"
.SS "Overview"
.IX Subsection "Overview"
This document contains a second tutorial
of the Scanless interface (\s-1SLIF\s0),
which demonstrates a lower level of method calls.
These lower level calls
allow access to more of Marpa's
features.
For example, users will need to
use the lower level calls
.IP "\(bu" 4
to use \s-1SLIF\s0 parse events;
.IP "\(bu" 4
to examine the values of multiple  parses of an ambiguous parse;
.IP "\(bu" 4
and to get finer control of the response to Marpa errors.
.PP
This uses the same extremely simple calculator
as the tutorial in the landing page.
Most of the code is exactly the same in fact,
and we will skip it.
Here is what is new:
.SS "Marpa::R2::Scanless::R::new"
.IX Subsection "Marpa::R2::Scanless::R::new"
.Vb 2
\&    my $recce = Marpa::R2::Scanless::R\->new(
\&        { grammar => $grammar, semantics_package => \*(AqMy_Actions\*(Aq } );
.Ve
.PP
\&\f(CW\*(C`Marpa::R2::Scanless::R::new\*(C'\fR creates a new \s-1SLIF\s0 recognizer.
Its arguments are references to hashes of named arguments.
In this example the first named argument is
the required argument: "\f(CW\*(C`grammar\*(C'\fR".
The value of the
\&\f(CW\*(C`grammar\*(C'\fR
named argument must be a Marpa::R2 \s-1SLIF\s0
grammar.
.PP
The second argument is optional, but you will use it frequently.
The "\f(CW\*(C`semantics_package\*(C'\fR" named argument tells Marpa in which Perl package to
look for the closures implementing the semantics for this grammar.
.SS "Marpa::R2::Scanless::R::read"
.IX Subsection "Marpa::R2::Scanless::R::read"
.Vb 2
\&    my $input = \*(Aq42 * 1 + 7\*(Aq;
\&    my $length_read = $recce\->read( \e$input );
.Ve
.PP
To parse a string,
we use 
the \f(CW\*(C`Marpa::R2::Scanless::R::read()\*(C'\fR method.
In its simplest form,
as here,
the \f(CW\*(C`Marpa::R2::Scanless::R::read()\*(C'\fR method
takes a reference
to a string containing the input stream as its argument.
.SS "Checking for a premature end"
.IX Subsection "Checking for a premature end"
.Vb 2
\&    die "Read ended after $length_read of ", length $input, " characters"
\&        if $length_read != length $input;
.Ve
.PP
Most premature endings occur when a parse is exhausted.
A parse is \*(L"exhausted\*(R" when there is no possible way for it
to continue on to success.
Premature parse exhaustion is thrown as a failure by
the \f(CW\*(C`Marpa::R2::Scanless::R::read()\*(C'\fR method,
and it is not necessary to check for it explicitly.
.PP
There are other premature endings
that are not necessarily failures,
and which therefore are not thrown.
These are Marpa's \s-1SLIF\s0 parse events.
\&\s-1SLIF\s0 parse events are an advanced feature, and are described
elsewhere.
In this example,
any premature ending caused by
the triggering of a \s-1SLIF\s0 parse event will be caused
by stray parse events \*(--
unexpected parse events due to a mistake in writing the \s-1DSL.\s0
.PP
Programming a stray parse event is a programming mistake that you
are not likely to make,
so arguably this check is not really necessary.
There are no \s-1SLIF\s0 parse events, stray or otherwise, in this example.
But this check is included for completeness,
and as an example of a cautious programming style.
.SS "Checking for an ambiguous parse"
.IX Subsection "Checking for an ambiguous parse"
.Vb 4
\&    if ( my $ambiguous_status = $recce\->ambiguous() ) {
\&        chomp $ambiguous_status;
\&        die "Parse is ambiguous\en", $ambiguous_status;
\&    }
.Ve
.PP
Much more likely than stray \s-1SLIF\s0 parse events are ambiguous parses \*(--
parses where the input can be parsed in two or more ways.
Ambiguous parses are not necessarily a problem \*(-- some applications
may not care about them.
Other applications, as an advanced technique,
actually exploit ambiguity,
.PP
Beginners should regard an ambiguous parse
as a sign of trouble.
The existence of ambiguous parses should be tolerated
only if you understand the kind of ambiguity that exists
in your grammar,
and only if you know that ambiguities of that kind
will not cause trouble.
The above code uses
the recognizer's \f(CW\*(C`ambigous()\*(C'\fR
method to spot ambiguous parses.
The \f(CW\*(C`ambigous()\*(C'\fR
method returns the empty string
if there was exactly one parse.
If there was no parse, 
the \f(CW\*(C`ambigous()\*(C'\fR
method returns a string stating that.
If there were two or more parses,
the \f(CW\*(C`ambigous()\*(C'\fR
method returns a string describing
the ambiguity.
.SS "Marpa::R2::Scanless::R::value"
.IX Subsection "Marpa::R2::Scanless::R::value"
.Vb 2
\&    my $value_ref = $recce\->value;
\&    my $value = ${$value_ref};
.Ve
.PP
The \f(CW\*(C`Marpa::R2::Scanless::R::value()\*(C'\fR method returns
a reference to the parse result's value,
if there was a parse result.
If there was no parse result,
\&\f(CW\*(C`Marpa::R2::Scanless::R::value()\*(C'\fR
returns
\&\f(CW\*(C`undef\*(C'\fR.
This code does not check for the case where there is
no parse result, because we already performed that
check along with the check for ambiguity.
.PP
The value of the parse is exactly the same,
and computed in exactly the same way,
as in the previous tutorial.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
