.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Config::Merge 3"
.TH Config::Merge 3 "2014-08-25" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Merge \- load a configuration directory tree containing
YAML, JSON, XML, Perl, INI or Config::General files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   OO style
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   use Config::Merge();
\&
\&   my $config    = Config::Merge\->new(\*(Aq/path/to/config\*(Aq);
\&
\&   @hosts        = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&   $hosts_ref    = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&   @cloned_hosts = $config\->clone(\*(Aqdb.hosts.session\*(Aq);
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
\&\s-1OR\s0
.PP
.Vb 4
\&   Functional style
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   # On startup
\&   use Config::Merge(\*(AqMy::Config\*(Aq => \*(Aq/path/to/config\*(Aq);
\&
\&
\&   # Then, in any module where you want to use the config
\&   package My::Module;
\&   use My::Config;
\&
\&   @hosts        = C(\*(Aqdb.hosts.sesssion\*(Aq);
\&   $hosts_ref    = C(\*(Aqdb.hosts.sesssion\*(Aq);
\&   @cloned_hosts = My::Config::clone(\*(Aqdb.hosts.session\*(Aq);
\&   $config       = My::Config::object;
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.PP
\&\s-1ADVANCED USAGE\s0
.PP
.Vb 11
\&   OO style
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   my $config    = Config::Merge\->new(
\&       path      => \*(Aq/path/to/config\*(Aq,
\&       skip      => sub {} | regex | {} ,
\&       is_local  => sub {} | regex | {} ,
\&       load_as   => sub {} | regex ,
\&       sort      => sub {} ,
\&       debug     => 1 | 0
\&   );
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&   Functional style
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   use Config::Merge(
\&       \*(AqMy::Config\*(Aq => \*(Aq/path/to/config\*(Aq,
\&       {
\&           skip      => sub {} | regex | {} ,
\&           is_local  => sub {} | regex | {} ,
\&           load_as   => sub {} | regex ,
\&           sort      => sub {} ,
\&           debug     => 1 | 0
\&       }
\&   );
\&
\&   # Also, you can subclass these:
\&
\&     package My::Config;
\&     sub skip {
\&         ...
\&     }
\&
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::Merge is a configuration module which has six goals:
.IP "\(bu" 4
Flexible storage
.Sp
Store all configuration in your format(s) of choice (\s-1YAML, JSON, INI, XML,\s0 Perl,
Config::General / Apache-style config) broken down into individual files in
a configuration directory tree, for easy maintenance.
 See \*(L"\s-1CONFIG TREE LAYOUT\*(R"\s0
.IP "\(bu" 4
Flexible access
.Sp
Provide a simple, easy to read, concise way of accessing the configuration
values (similar to Template). See \*(L"\s-1ACCESSING CONFIG DATA\*(R"\s0
.IP "\(bu" 4
Minimal maintenance
.Sp
Specify the location of the configuration files only once per
application, so that it requires minimal effort to relocate.
See \*(L"\s-1USING\s0 Config::Merge\*(R"
.IP "\(bu" 4
Easy to alter development environment
.Sp
Provide a way for overriding configuration values on a development
machine, so that differences between the dev environment and
the live environment do not get copied over accidentally.
See \*(L"\s-1OVERRIDING CONFIG LOCALLY\*(R"\s0
.IP "\(bu" 4
Minimise memory use
.Sp
Load all config at startup so that (eg in the mod_perl environment) the
data is shared between all child processes. See \*(L"\s-1MINIMISING MEMORY USE\*(R"\s0
.IP "\(bu" 4
Flexible implementation
.Sp
You may want to use a different schema for your configuration files,
so you can pass in (or subclass) methods for determining how your
files are merged.  See \*(L"\s-1ADVANCED USAGE\*(R"\s0.
.ie n .SH "USING ""Config::Merge"""
.el .SH "USING \f(CWConfig::Merge\fP"
.IX Header "USING Config::Merge"
There are two ways to use \f(CW\*(C`Config::Merge\*(C'\fR:
.IP "\s-1OO STYLE\s0" 4
.IX Item "OO STYLE"
.Vb 2
\&   use Config::Merge();
\&   my $config    = Config::Merge\->new(\*(Aq/path/to/config\*(Aq);
\&
\&   @hosts        = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&   $hosts_ref    = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&   @cloned_hosts = $config\->clone(\*(Aqdb.hosts.session\*(Aq);
.Ve
.Sp
Also, see \*(L"\s-1ADVANCED USAGE\*(R"\s0.
.IP "\s-1YOUR OWN CONFIG CLASS\s0 (functional style)" 4
.IX Item "YOUR OWN CONFIG CLASS (functional style)"
The following code:
.Sp
.Vb 2
\&   # On startup
\&   use Config::Merge(\*(AqMy::Config\*(Aq => \*(Aq/path/to/config\*(Aq);
.Ve
.RS 4
.IP "\(bu" 4
auto-generates the class \f(CW\*(C`My::Config\*(C'\fR
.IP "\(bu" 4
loads the configuration data in \f(CW\*(Aq/path/to/config\*(Aq\fR
.IP "\(bu" 4
creates the subs \f(CW\*(C`My::Config::C\*(C'\fR, \f(CW\*(C`My::Config::clone\*(C'\fR
and \f(CW\*(C`My::Config::object\*(C'\fR.
.RE
.RS 4
.Sp
Then when you want your application to have access to your configuration data,
you add this (eg in your class \f(CW\*(C`My::Module\*(C'\fR):
.Sp
.Vb 2
\&   package My::Module;
\&   use My::Config;       # Note, no ()
.Ve
.Sp
This exports the sub \f(CW\*(C`C\*(C'\fR into your current package, which allows you to
access your configuation data as follows:
.Sp
.Vb 4
\&   @hosts        = C(\*(Aqdb.hosts.sesssion\*(Aq);
\&   $hosts_ref    = C(\*(Aqdb.hosts.sesssion\*(Aq);
\&   @cloned_hosts = My::Config::clone(\*(Aqdb.hosts.session\*(Aq);
\&   $config       = My::Config::object;
.Ve
.RE
.SH "CONFIG TREE LAYOUT"
.IX Header "CONFIG TREE LAYOUT"
Config::Merge reads the data from any number (and type) of config files
stored in a directory tree. File names and directory names are used as keys in
the configuration hash.
.PP
It uses file extensions to decide what type of data the file contains, so:
.PP
.Vb 6
\&    YAML            : .yaml .yml
\&    JSON            : .json .jsn
\&    XML             : .xml
\&    INI             : .ini
\&    Perl            : .perl .pl
\&    Config::General : .conf .cnf
.Ve
.PP
When loading your config data, Config::Merge starts at the directory
specified at startup (see \*(L"\s-1USING\s0 Config::Merge\*(R") and looks
through all the sub-directories for files ending in one of the above
extensions.
.PP
The name of the file or subdirectory is used as the first key.  So:
.PP
.Vb 9
\&    global/
\&        db.yaml:
\&            username : admin
\&            hosts:
\&                     \- host1
\&                     \- host2
\&            password:
\&              host1:   password1
\&              host2:   password2
.Ve
.PP
would be loaded as :
.PP
.Vb 9
\&    $Config = {
\&       global => {
\&           db => {
\&               username => \*(Aqadmin\*(Aq,
\&               password => { host1 => \*(Aqpassword1\*(Aq, host2 => \*(Aqpassword2\*(Aq},
\&               hosts    => [\*(Aqhost1\*(Aq,\*(Aqhost2\*(Aq],
\&           }
\&       }
\&    }
.Ve
.PP
Subdirectories are processed before the current directory, so
you can have a directory and a config file with the same name,
and the values will be merged into a single hash, so for
instance, you can have:
.PP
.Vb 7
\&    confdir:
\&       syndication/
\&       \-\-data_types/
\&         \-\-traffic.yaml
\&         \-\-headlines.yaml
\&       \-\-data_types.ini
\&       syndication.conf
.Ve
.PP
The config items in syndication.conf will be added to (or overwrite)
the items loaded into the syndication namespace via the subdirectory
called syndication.
.SH "OVERRIDING CONFIG LOCALLY"
.IX Header "OVERRIDING CONFIG LOCALLY"
The situation often arises where it is necessary to specify
different config values on different machines. For instance,
the database host on a dev machine may be different from the host
on the live application. Also, see \*(L"\s-1ADVANCED USAGE\*(R"\s0 which
provides you with other means to merge local data.
.PP
Instead of changing this data during dev and then having to remember
to change it back before putting the new code live, we have a mechanism
for overriding config locally in a \f(CW\*(C`local.*\*(C'\fR file and then, as long as
that file never gets uploaded to live, you are protected.
.PP
You can put a file called \f(CW\*(C`local.*\*(C'\fR (where * is any of the recognised
extensions) in any sub-directory, and
the data in this file will be merged with the existing data.
.PP
Just make sure that the \f(CW\*(C`local.*\*(C'\fR files are never checked into your live
code.
.PP
For instance, if we have:
.PP
.Vb 3
\&    confdir:
\&        db.yaml
\&        local.yaml
.Ve
.PP
and db.yaml has :
.PP
.Vb 5
\&    connections:
\&        default_settings:
\&            host:       localhost
\&            table:      abc
\&            password:   123
.Ve
.PP
And in local.yaml:
.PP
.Vb 4
\&    db:
\&        connections:
\&            default_settings:
\&                password:   456
.Ve
.PP
the resulting configuration will look like this:
.PP
.Vb 6
\&    db:
\&        connections:
\&            default_settings:
\&                host:       localhost
\&                table:      abc
\&                password:   456
.Ve
.SH "ACCESSING CONFIG DATA"
.IX Header "ACCESSING CONFIG DATA"
All configuration data is loaded into a single hash, eg:
.PP
.Vb 9
\&    $config = {
\&        db    => {
\&            hosts  => {
\&                session  => [\*(Aqhost1\*(Aq,\*(Aqhost2\*(Aq,\*(Aqhost3\*(Aq],
\&                images   => [\*(Aqhost1\*(Aq,\*(Aqhost2\*(Aq,\*(Aqhost3\*(Aq],
\&                etc...
\&            }
\&        }
\&    }
.Ve
.PP
If you want to access it via standard Perl dereferences, you can just ask
for the hash:
.PP
.Vb 4
\&    OO:
\&       $data_ref  = $config\->();
\&       $hosts_ref = $data_ref\->{db}{hosts}{session};
\&       $host_1    = $data_ref\->{db}{hosts}{session}[0];
\&
\&    Functional:
\&       $data_ref  = C();
\&       $hosts_ref = $data_ref\->{db}{hosts}{session};
\&       $host_1    = $data_ref\->{db}{hosts}{session}[0];
.Ve
.PP
However, \f(CW\*(C`Config::Merge\*(C'\fR also provides an easy to read dot-notation in the
style of Template Toolkit: \f(CW\*(C`(\*(Aqkey1.key2.keyn\*(Aq)\*(C'\fR.
.PP
A key can be the key of a hash or the index of an array. The return value is
context sensitive, so if called in list context, a hash ref or array ref will
be dereferenced.
.PP
.Vb 4
\&    OO:
\&       @hosts     = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&       $hosts_ref = $config\->(\*(Aqdb.hosts.session\*(Aq);
\&       $host_1    = $config\->(\*(Aqdb.hosts.session.0\*(Aq);
\&
\&    Functional:
\&       @hosts     = C(\*(Aqdb.hosts.session\*(Aq);
\&       $hosts_ref = C(\*(Aqdb.hosts.session\*(Aq);
\&       $host_1    = C(\*(Aqdb.hosts.session.0\*(Aq);
.Ve
.PP
These lookups are memo'ised, so lookups are fast.
.PP
If the specified key is not found, then an error is thrown.
.SH "MINIMISING MEMORY USE"
.IX Header "MINIMISING MEMORY USE"
The more configuration data you load, the more memory you use. In order to
keep the memory use as low as possible for mod_perl (or other forking
applications), the configuration data should be loaded at startup in the
parent process.
.PP
As long as the data is never changed by the children, the configuration hash
will be stored in shared memory, rather than there being a separate copy in each
child process.
.PP
(See <http://search.cpan.org/~pgollucci/mod_perl\-2.0.3/docs/user/performance/mpm.pod>)
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new()""" 4
.el .IP "\f(CWnew()\fR" 4
.IX Item "new()"
.Vb 1
\&    $conf = Config::Merge\->new($config_dir);
.Ve
.Sp
\&\fBnew()\fR instantiates a config object, loads the config from
the directory specified, and returns the object.
.ie n .IP """C()""" 4
.el .IP "\f(CWC()\fR" 4
.IX Item "C()"
.Vb 2
\&  $val = $config\->C(\*(Aqkey1.key2.keyn\*(Aq);
\&  $val = $config\->C(\*(Aqkey1.key2.keyn\*(Aq,$hash_ref);
.Ve
.Sp
\&\f(CW\*(C`Config::Merge\*(C'\fR objects are overloaded so that this also works:
.Sp
.Vb 2
\&  $val = $config\->(\*(Aqkey1.key2.keyn\*(Aq);
\&  $val = $config\->(\*(Aqkey1.key2.keyn\*(Aq,$hash_ref);
.Ve
.Sp
Or, if used in the functional style (see \*(L"\s-1USING\s0 Config::Merge\*(R"):
.Sp
.Vb 2
\&  $val = C(\*(Aqkey1.key2.keyn\*(Aq);
\&  $val = C(\*(Aqkey1.key2.keyn\*(Aq,$hash_ref);
.Ve
.Sp
\&\f(CW\*(C`key1\*(C'\fR etc can be keys in a hash, or indexes of an array.
.Sp
\&\f(CW\*(C`C(\*(Aqkey1.key2.keyn\*(Aq)\*(C'\fR returns everything from \f(CW\*(C`keyn\*(C'\fR down,
so you can use the return value just as you would any normal Perl variable.
.Sp
The return values are context-sensitive, so if called
in list context, an array ref or hash ref will be returned as lists.
Scalar values, code refs, regexes and blessed objects will always be returned
as themselves.
.Sp
So for example:
.Sp
.Vb 2
\&  $password = C(\*(Aqdatabase.main.password\*(Aq);
\&  $regex    = C(\*(Aqdatabase.main.password_regex\*(Aq);
\&
\&  @countries = C(\*(Aqlists.countries\*(Aq);
\&  $countries_array_ref = C(\*(Aqlists.countries\*(Aq);
\&
\&  etc
.Ve
.Sp
If called with a hash ref as the second parameter, then that hash ref will be
examined, rather than the \f(CW$config\fR data.
.ie n .IP """clone()""" 4
.el .IP "\f(CWclone()\fR" 4
.IX Item "clone()"
This works exactly the same way as \*(L"C()\*(R" but it performs a
deep clone of the data before returning it.
.Sp
This means that the returned data can be changed without
affecting the data stored in the \f(CW$conf\fR object;
.Sp
The data is deep cloned, using Storable, so the bigger the data, the more
performance hit.  That said, Storable's dclone is very fast.
.ie n .IP """register_loader()""" 4
.el .IP "\f(CWregister_loader()\fR" 4
.IX Item "register_loader()"
.Vb 1
\&    Config::Merge\->register_loader( \*(AqConfig::Merge::XYZ\*(Aq);
\&
\&    Config::Merge\->register_loader( \*(AqConfig::Merge::XYZ\*(Aq => \*(Aqxyz\*(Aq,\*(Aqxxx\*(Aq);
.Ve
.Sp
By default, \f(CW\*(C`Config::Merge\*(C'\fR uses the \f(CW\*(C`Config::Any\*(C'\fR
plugins to support \s-1YAML, JSON, INI, XML,\s0 Perl and Config::General configuration
files, using the standard file extensions to recognise the file type. (See
\&\*(L"\s-1CONFIG TREE LAYOUT\*(R"\s0).
.Sp
If you would like to change the handler for an extension (eg, you want \f(CW\*(C`.conf\*(C'\fR
and \f(CW\*(C`.cnf\*(C'\fR files to be treated as \s-1YAML\s0), do the following:
.Sp
.Vb 1
\&    Config::Merge\->register_loader (\*(AqConfig::Any::YAML\*(Aq => \*(Aqconf\*(Aq, \*(Aqcnf\*(Aq);
.Ve
.Sp
If you would like to add a new config style, then your module should have two
methods: \f(CW\*(C`extensions()\*(C'\fR (which returns a list of the extensions it handles),
and \f(CW\*(C`load()\*(C'\fR which accepts the name of the file to load, and returns
a hash ref containing the data in the file. See Config::Any for details.
.Sp
Alternatively, you can specify the extensions when you load it:
.Sp
.Vb 1
\&    Config::Merge\->register_loader (\*(AqMy::Merge\*(Aq => \*(Aqconf\*(Aq, \*(Aqcnf\*(Aq);
.Ve
.ie n .IP """load_config()""" 4
.el .IP "\f(CWload_config()\fR" 4
.IX Item "load_config()"
.Vb 1
\&    $config\->load_config();
.Ve
.Sp
Will reload the config files located in the directory specified at object
creation (see \*(L"\fBnew()\fR\*(R").
.Sp
\&\s-1BEWARE :\s0 If you are using this in a mod_perl environment, you will lose the
benefit of shared memory by calling this in a child process
 \- each child will have its own copy of the data.
See \*(L"\s-1MINIMISING MEMORY USE\*(R"\s0.
.Sp
Returns the config hash ref.
.ie n .IP """clear_cache()""" 4
.el .IP "\f(CWclear_cache()\fR" 4
.IX Item "clear_cache()"
.Vb 1
\&    $config\->clear_cache();
.Ve
.Sp
Config data is generally not supposed to be changed at runtime. However, if
you do make changes, you may get inconsistent results, because lookups are
cached.
.Sp
For instance:
.Sp
.Vb 2
\&    print $config\->C(\*(Aqdb.hosts.session\*(Aq);  # Caches this lookup
\&    > "host1 host2 host3"
\&
\&    $data = $config\->C(\*(Aqdb.hosts\*(Aq);
\&    $data\->{session} = 123;
\&
\&    print $config\->C(\*(Aqdb.hosts.session\*(Aq); # uses cached value
\&    > "host1 host2 host3"
\&
\&    $config\->clear_cache();
\&    print $config\->C(\*(Aqdb.hosts.session\*(Aq); # uses actual value
\&    > "123"
.Ve
.ie n .IP """import()""" 4
.el .IP "\f(CWimport()\fR" 4
.IX Item "import()"
\&\f(CW\*(C`import()\*(C'\fR will normally be called automatically when you
\&\f(CW\*(C`use Config::Merge\*(C'\fR. However, you may want to do this:
.Sp
.Vb 3
\&    use Config::Merge();
\&    Config::Merge\->register_loader(\*(AqMy::Plugin\*(Aq => \*(Aqext\*(Aq);
\&    Config::Merge\->import(\*(AqMy::Config\*(Aq => \*(Aq/path/to/config/dir\*(Aq);
.Ve
.Sp
If called with two params: \f(CW$config_class\fR and \f(CW$config_dir\fR, it
generates the new class (which inherits from Config::Merge)
specified in \f(CW$config_class\fR, creates a new
object of that class and creates 4 subs:
.RS 4
.ie n .IP """C()""" 4
.el .IP "\f(CWC()\fR" 4
.IX Item "C()"
.Vb 2
\&    As a function:
\&        C(\*(Aqkeys...\*(Aq)
\&
\&    is the equivalent of:
\&        $config\->C(\*(Aqkeys...\*(Aq);
.Ve
.ie n .IP """clone()""" 4
.el .IP "\f(CWclone()\fR" 4
.IX Item "clone()"
.Vb 2
\&    As a function:
\&        clone(\*(Aqkeys...\*(Aq)
\&
\&    is the equivalent of:
\&        $config\->clone(\*(Aqkeys...\*(Aq);
.Ve
.ie n .IP """object()""" 4
.el .IP "\f(CWobject()\fR" 4
.IX Item "object()"
.Vb 1
\&    $config = My::Config\->object();
.Ve
.Sp
Returns the \f(CW$config\fR object,
.ie n .IP """import()""" 4
.el .IP "\f(CWimport()\fR" 4
.IX Item "import()"
When you use your generated config class, it exports the \f(CW\*(C`C()\*(C'\fR sub into your
package:
.Sp
.Vb 2
\&    use My::Config;
\&    $hosts = C(\*(Aqdb.hosts.session\*(Aq);
.Ve
.RE
.RS 4
.RE
.SH "ADVANCED USAGE"
.IX Header "ADVANCED USAGE"
The items in the section allow you to customise how Config::Merge
loads your data.  You may never need them.
.PP
You can:
.IP "\(bu" 4
Override array values
.IP "\(bu" 4
Skip the loading of parts of your config tree
.IP "\(bu" 4
Specify which files / dirs are local
.IP "\(bu" 4
Specify how to translate a file / dir name into a key
.IP "\(bu" 4
Change order in which files are loaded
.IP "\(bu" 4
See debug output
.IP "Overriding array values" 4
.IX Item "Overriding array values"
Overriding hash values is easy, however arrays are more complex.
it may be simpler to copy and paste and edit the array you want to
change locally.
.Sp
However, if your array is too long, and you want to make small changes,
then you can use the following:
.Sp
In the main config:
.Sp
.Vb 3
\&    {
\&      cron => [qw( job1 job2 job3 job4)]
\&    }
.Ve
.Sp
In the local file
.Sp
.Vb 3
\&    {
\&      cron => {
\&        \*(Aq3\*(Aq  => \*(Aqnewjob4\*(Aq,      # changes \*(Aqjob4\*(Aq \-> \*(Aqnewjob4\*(Aq
\&
\&        \*(Aq!\*(Aq  => {               # signals an array override
\&
\&             \*(Aq\-\*(Aq => [1],        # deletes \*(Aqjob2\*(Aq
\&
\&             \*(Aq+\*(Aq => [\*(Aqjob5\*(Aq],   # appends \*(Aqjob5\*(Aq
\&
\&          OR \*(Aq+\*(Aq => {           # inserts \*(Aqjob3a\*(Aq after \*(Aqjob3\*(Aq
\&                 2 => \*(Aqjob3a\*(Aq
\&             }
\&        }
\&    }
.Ve
.RS 4
.IP "\(bu" 4
The override has to be a hash, with at least this structure
 \f(CW\*(C`{ \*(Aq!\*(Aq => {} }\*(C'\fR to signal an array override
.IP "\(bu" 4
Any other keys with integers are treated as indexes and
are used to change the value at that index in the original array
.IP "\(bu" 4
The \f(CW\*(Aq\-\*(Aq\fR key should contain an array ref, with the indexes of the
elements to remove from the array.
.IP "\(bu" 4
If the \f(CW\*(Aq+\*(Aq\fR key contains an array ref, then its contents are appended
to the original array.
.IP "\(bu" 4
If the \f(CW\*(Aq+\*(Aq\fR key contains a hash ref, then each value is inserted
into the original array at the index given in the key
.IP "\(bu" 4
Indexes are zero based, just as in Perl.
.RE
.RS 4
.RE
.ie n .IP """skip()""" 4
.el .IP "\f(CWskip()\fR" 4
.IX Item "skip()"
.Vb 7
\&    $c = Config::Merge\->new(
\&            path  => \*(Aq/path/to/config\*(Aq,
\&            skip  => qr/regex/,
\&                     | [ qr/regex1/, qr/regex2/...]
\&                     | {  name1 => 1, name2 => 2}
\&                     | sub {}
\&    );
.Ve
.Sp
\&\f(CW\*(C`skip()\*(C'\fR allows you to skip the loading of parts of your config
tree.  For instance, if you don't need a list of cron jobs when running
your web server, you can skip it.
.Sp
The decision is made based on the path to that value, eg 'app.db.hosts'
rather than on filenames. Also, the check is only performed for each
new directory or filename \- it doesn't check the data within each file.
.Sp
To use \f(CW\*(C`skip()\*(C'\fR, you can either subclass it, or pass in a parameter
to new:
.RS 4
.ie n .IP """qr/regex/"" or ""[qr/regex1/, qr/regex2]""" 4
.el .IP "\f(CWqr/regex/\fR or \f(CW[qr/regex1/, qr/regex2]\fR" 4
.IX Item "qr/regex/ or [qr/regex1/, qr/regex2]"
Each regex will be checked against the key path, and if it matches
then the loading of that tree will be skipped
.ie n .IP """{key_path => 1}""" 4
.el .IP "\f(CW{key_path => 1}\fR" 4
.IX Item "{key_path => 1}"
If the key path exists in the hash, then loading will be skipped
.ie n .IP """sub {}"" or subclassed ""skip""" 4
.el .IP "\f(CWsub {}\fR or subclassed \f(CWskip\fR" 4
.IX Item "sub {} or subclassed skip"
.Vb 5
\&   sub {
\&       my ($self,$key_path) = @_;
\&       ...make decision...
\&       return 1 | 0;
\&   }
.Ve
.RE
.RS 4
.RE
.ie n .IP """is_local()""" 4
.el .IP "\f(CWis_local()\fR" 4
.IX Item "is_local()"
.Vb 7
\&    $c = Config::Merge\->new(
\&            path     => \*(Aq/path/to/config\*(Aq,
\&            is_local => qr/regex/,
\&                        | [ qr/regex1/, qr/regex2/...]
\&                        | {  name1 => 1, name2 => 2}
\&                        | sub {}
\&    );
.Ve
.Sp
\&\f(CW\*(C`is_local()\*(C'\fR indicates whether a file or dir should be considered
part of the main config (and thus loaded normally) or part of the
local config (and thus merged into the main config).
.Sp
The decision is made based on the name of the file / dir, without
any extension.
.Sp
To use \f(CW\*(C`is_local()\*(C'\fR, you can either subclass it, or pass in a parameter
to new:
.RS 4
.ie n .IP """qr/regex/"" or ""[qr/regex1/, qr/regex2]""" 4
.el .IP "\f(CWqr/regex/\fR or \f(CW[qr/regex1/, qr/regex2]\fR" 4
.IX Item "qr/regex/ or [qr/regex1/, qr/regex2]"
Each regex will be checked against the file/dir name, and if it matches
then that tree will be merged
.ie n .IP """{filename => 1, dirname => 1}""" 4
.el .IP "\f(CW{filename => 1, dirname => 1}\fR" 4
.IX Item "{filename => 1, dirname => 1}"
If the file/dir name exists in the hash, then that tree will be merged
.ie n .IP """sub {}"" or subclassed ""is_local""" 4
.el .IP "\f(CWsub {}\fR or subclassed \f(CWis_local\fR" 4
.IX Item "sub {} or subclassed is_local"
.Vb 5
\&   sub {
\&       my ($self,$name) = @_;
\&       ...make decision...
\&       return 1 | 0;
\&   }
.Ve
.RE
.RS 4
.Sp
See \*(L"\s-1EXAMPLE USING\s0 \fBis_local()\fR \s-1AND\s0 \fBload_as()\fR\*(R".
.RE
.ie n .IP """load_as()""" 4
.el .IP "\f(CWload_as()\fR" 4
.IX Item "load_as()"
.Vb 5
\&    $c = Config::Merge\->new(
\&            path     => \*(Aq/path/to/config\*(Aq,
\&            load_as  => qr/(regex)/,
\&                        | sub {}
\&    );
.Ve
.Sp
\&\f(CW\*(C`load_as()\*(C'\fR returns the name of the key to use when loading
the file / dir. By default, it returns the \f(CW$name\fR for main
config files, or \f(CW\*(Aq\*(Aq\fR for local files.
.Sp
The decision is made based on the name of the file / dir, without
any extension.
.Sp
If \f(CW\*(C`load_as()\*(C'\fR returns an empty string, then each key in the file/tree
is merged separately. This is how the \f(CW\*(C`local.*\*(C'\fR files work by default.
See \*(L"\s-1OVERRIDING CONFIG LOCALLY\*(R"\s0.
.Sp
For instance:
.Sp
.Vb 3
\&   main.yaml:
\&     key1:  value
\&     key2:  value
\&
\&   db.yaml:
\&     key3:  value
\&     key4:  value
\&
\&   local.yaml:
\&     main:
\&        key1: new_value
\&     db:
\&        key4: new_value
.Ve
.Sp
To use \f(CW\*(C`load_as()\*(C'\fR, you can either subclass it, or pass in a parameter
to new:
.RS 4
.ie n .IP """qr/(regex)/""" 4
.el .IP "\f(CWqr/(regex)/\fR" 4
.IX Item "qr/(regex)/"
The regex will be checked against the file/dir name, and if it matches
then it returns the string captured in the regex, otherwise it returns
the original name.
.ie n .IP """sub {}"" or subclassed ""is_local""" 4
.el .IP "\f(CWsub {}\fR or subclassed \f(CWis_local\fR" 4
.IX Item "sub {} or subclassed is_local"
.Vb 7
\&   sub {
\&       my ($self,$name,$is_local) = @_;
\&       ...make decision...
\&       return \*(Aqstring\*(Aq;   # string is used as the keyname
\&       return \*(Aq\*(Aq;         # acts like local.* (see above)
\&       return undef;      # don\*(Aqt load this file/dir
\&   }
.Ve
.RE
.RS 4
.Sp
Also, see \*(L"\s-1EXAMPLE USING\s0 \fBis_local()\fR \s-1AND\s0 \fBload_as()\fR\*(R".
.RE
.ie n .IP "\s-1EXAMPLE USING\s0 ""is_local()"" \s-1AND\s0 ""load_as()""" 4
.el .IP "\s-1EXAMPLE USING\s0 \f(CWis_local()\fR \s-1AND\s0 \f(CWload_as()\fR" 4
.IX Item "EXAMPLE USING is_local() AND load_as()"
For instance, instead of using \f(CW\*(C`local.*\*(C'\fR files, you may want to
keep versioned copies of local configs for different machines, and so use:
.Sp
.Vb 3
\&   app.yaml
\&   app\-(dev1.domain.com).yaml
\&   app\-(dev2.domain.com).yaml
.Ve
.Sp
You would implement this as follows:
.Sp
.Vb 2
\&    my $config = Config::Merge\->new(
\&        path        => \*(Aq/path/to/config\*(Aq,
\&
\&        # If matches \*(Aqxxx\-(yyy)\*(Aq
\&        is_local    => sub {
\&            my ( $self, $name ) = @_;
\&            return $name=~/\- [(] .+ [)]/x ? 1 : 0;
\&        },
\&
\&        # If local and matches \*(Aqxxx\-(hostname)\*(Aq, return xxx
\&        load_as => sub {
\&            my ( $self, $name, $is_local ) = @_;
\&            if ($is_local) {
\&                if ( $name=~/(.*) \- [(] ($hostname) [)] /x ) {
\&                    return  $1;
\&                }
\&                return undef;
\&            }
\&            return $name;
\&        }
\&    );
.Ve
.Sp
See \f(CW\*(C`examples/advanced.pl\*(C'\fR for a working illustration.
.ie n .IP """sort()""" 4
.el .IP "\f(CWsort()\fR" 4
.IX Item "sort()"
.Vb 4
\&    $c = Config::Merge\->new(
\&            path   => \*(Aq/path/to/config\*(Aq,
\&            sort   => sub {}
\&    );
.Ve
.Sp
By default, directory entries are sorted alphabetically, with
directories before filenames.
.Sp
This would be the order for these directory entries:
.Sp
.Vb 4
\&  api/
\&  api\-(dev1)/
\&  api.yaml
\&  api\-(dev1).yaml
.Ve
.Sp
To override this, you can subclass \f(CW\*(C`sort()\*(C'\fR or pass it in as a
parameter to new:
.Sp
.Vb 5
\&   sub {
\&       my ($self,$names_array_ref) = @_
\&       ...sort...
\&       return $names_array_ref;
\&   }
.Ve
.ie n .IP """debug()""" 4
.el .IP "\f(CWdebug()\fR" 4
.IX Item "debug()"
.Vb 4
\&    my $config = Config::Merge\->new(
\&        path        => \*(Aq/path/to/config\*(Aq,
\&        debug       => 1 | 0
\&    );
.Ve
.Sp
If \f(CW\*(C`debug\*(C'\fR is true, then Config::Merge prints out an explanation
of what it is doing on \s-1STDERR.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Storable, Config::Any, Config::Any::YAML,
Config::Any::JSON, Config::Any::INI, Config::Any::XML,
Config::Any::General
.SH "THANKS"
.IX Header "THANKS"
Thanks to Hasanuddin Tamir [\s-1HASANT\s0] for vacating the Config::Merge namespace,
which allowed me to rename Config::Loader to the more meaningful Config::Merge.
.PP
His version of Config::Merge can be found in
<http://backpan.cpan.org/modules/by\-authors/id/H/HA/HASANT/>.
.PP
Thanks to Joel Bernstein and Brian Cassidy for the interface to the various
configuration modules. Also to Ewan Edwards for his suggestions about how
to make Config::Merge more flexible.
.SH "BUGS"
.IX Header "BUGS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
<http://github.com/clintongormley/ConfigMerge/issues>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Clinton Gormley, <clinton@traveljury.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2007\-2010 by Clinton Gormley
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.
