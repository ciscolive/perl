.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Scanless::G 3"
.TH Marpa::R2::Scanless::G 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Marpa::R2::Scanless::G \- Scanless interface grammars
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 10
\&    my $grammar = Marpa::R2::Scanless::G\->new(
\&        {
\&            source          => \e(<<\*(AqEND_OF_SOURCE\*(Aq),
\&    :default ::= action => do_first_arg
\&    :start ::= Script
\&    Script ::= Expression+ separator => comma action => do_script
\&    comma ~ [,]
\&    Expression ::=
\&        Number
\&        | \*(Aq(\*(Aq Expression \*(Aq)\*(Aq action => do_parens assoc => group
\&       || Expression \*(Aq**\*(Aq Expression action => do_pow assoc => right
\&       || Expression \*(Aq*\*(Aq Expression action => do_multiply
\&        | Expression \*(Aq/\*(Aq Expression action => do_divide
\&       || Expression \*(Aq+\*(Aq Expression action => do_add
\&        | Expression \*(Aq\-\*(Aq Expression action => do_subtract
\&    Number ~ [\ed]+
\&
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    # allow comments
\&    :discard ~ <hash comment>
\&    <hash comment> ~ <terminated hash comment> | <unterminated
\&       final hash comment>
\&    <terminated hash comment> ~ \*(Aq#\*(Aq <hash comment body> <vertical space char>
\&    <unterminated final hash comment> ~ \*(Aq#\*(Aq <hash comment body>
\&    <hash comment body> ~ <hash comment char>*
\&    <vertical space char> ~ [\ex{A}\ex{B}\ex{C}\ex{D}\ex{2028}\ex{2029}]
\&    <hash comment char> ~ [^\ex{A}\ex{B}\ex{C}\ex{D}\ex{2028}\ex{2029}]
\&    END_OF_SOURCE
\&        }
\&    );
.Ve
.SH "About this document"
.IX Header "About this document"
This page is the reference for the grammar objects
of Marpa's Scanless interface.
.SH "Constructor"
.IX Header "Constructor"
The \f(CW\*(C`new()\*(C'\fR method is the constructor for Scanless grammars.
An example of its use is above.
The \f(CW\*(C`new()\*(C'\fR constructor accepts a hash of named arguments.
The following named arguments are allowed:
.SS "bless_package"
.IX Subsection "bless_package"
Specifies the name of a Perl package.
The package is used
for blessing node values into a Perl class,
in conjunction with the
\&\f(CW\*(C`bless\*(C'\fR adverb.
\&\f(CW\*(C`bless_package\*(C'\fR should not be confused with the 
\&\s-1SLIF\s0's
\&\f(CW\*(C`semantics_package\*(C'\fR recognizer setting.
The two are not closely related.
.SS "source"
.IX Subsection "source"
The value of the \f(CW\*(C`source\*(C'\fR named argument must be a reference
to a string which contains a description of the grammar.
The string's format is a domain-specific language,
described in its own
document.
.SS "trace_file_handle"
.IX Subsection "trace_file_handle"
The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default the trace file handle is \f(CW\*(C`STDERR\*(C'\fR.
.SS "Discouraged named arguments"
.IX Subsection "Discouraged named arguments"
\fIaction_object\fR
.IX Subsection "action_object"
.PP
Use of this argument is discouraged
in favor of the \f(CW\*(C`semantics_package\*(C'\fR named argument of the \s-1SLIF\s0
recognizer.
Like the \f(CW\*(C`semantics_package\*(C'\fR named argument, it sets the semantic
package.
Unlike the \f(CW\*(C`semantics_package\*(C'\fR named argument, it is a fatal error if used
together with an explicit per-parse argument of the \s-1SLIF\s0 recognizer's \f(CW\*(C`value()\*(C'\fR method.
It is also a fatal error to try to use the \f(CW\*(C`semantics_package\*(C'\fR
and \f(CW\*(C`action_object\*(C'\fR arguments together.
.PP
\fIdefault_action\fR
.IX Subsection "default_action"
.PP
Use of this argument is discouraged in favor of using the
\&\f(CW\*(C`action\*(C'\fR adverb
in a
default pseudo-rule.
Specifies the \f(CW\*(C`default_action\*(C'\fR named argument that
will be used for the G1 grammar.
For details, see \*(L"default_action\*(R" in Marpa::R2::NAIF::Grammar.
.SH "Mutators"
.IX Header "Mutators"
.SS "\fBparse()\fP"
.IX Subsection "parse()"
.Vb 3
\&    my $grammar   = Marpa::R2::Scanless::G\->new( { source => \e$dsl } );
\&    my $input     = \*(Aq42 * 1 + 7\*(Aq;
\&    my $value_ref = $grammar\->parse( \e$input, \*(AqMy_Actions\*(Aq );
.Ve
.PP
This very-high level method is a \*(L"one shot\*(R"
way of producing a parse value from a grammar and an input stream.
The features this method provides
are those most often wanted in
the \*(L"first cut\*(R" of a parser.
.PP
As the parser grows,
users are likely to find their application has
outgrown this method.
It is recommended, rather than spend a lot of time
exploring ways to adapt this method to expanding needs,
that users be quick to abandon it
in favor of the lower level calls.
As an example of how to make this transition,
the tutorial in Marpa::R2 is reimplemented
using low-level calls in Marpa::R2::Tutorial2.
.PP
The \f(CW\*(C`parse()\*(C'\fR method takes one or more arguments.
The first argument, which is required, is a ref to an input string.
Optionally, the second argument may be a string specifying the package name
for the semantics.
The remaining arguments
(including the second argument if it exists, but is not a string)
must be references to hashes of named arguments.
These hash references will be
passed, as is,
to the constructor for the recognizer.
.PP
This method returns a reference to the only parse value, if there is
exactly one parse value.
If there is no parse, or if the parse is ambiguous,
\&\f(CW\*(C`parse()\*(C'\fR throws an exception.
.SS "\fBset()\fP"
.IX Subsection "set()"
.Vb 1
\&    $grammar\->set( { trace_file_handle => $trace_fh } );
.Ve
.PP
This method allows the named arguments to be changed after an \s-1SLIF\s0
grammar is created.
Currently, the only argument that may be changed in \f(CW\*(C`trace_file_handle\*(C'\fR.
.SH "Accessors"
.IX Header "Accessors"
.SS "\fBrule_expand()\fP"
.IX Subsection "rule_expand()"
.Vb 2
\&    my ($lhs_id, @rhs_ids) = $grammar\->rule_expand($rule_id);
\&    $text .= "Rule #$rule_id: $lhs_id ::= " . (join q{ }, @rhs_ids) . "\en";
.Ve
.PP
.Vb 2
\&    my ($lhs_id, @rhs_ids) = $grammar\->rule_expand($rule_id, \*(AqL0\*(Aq);
\&    $text .= "L0 Rule #$rule_id: $lhs_id ::= " . (join q{ }, @rhs_ids) . "\en";
.Ve
.PP
\&\*(L"Expands\*(R" a rule \s-1ID\s0 into symbol \s-1ID\s0's.
An array of symbol \s-1ID\s0's is returned.
The \s-1ID\s0 of the \s-1LHS\s0 symbol is the first element,
and the remaining elements are the \s-1ID\s0's of the \s-1RHS\s0 symbols,
in order.
Returns an empty array if the rule does not exist.
.PP
The first argument is the \s-1ID\s0 of the rule to be \*(L"expanded\*(R".
The second, optional, argument is the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
.SS "\fBrule_ids()\fP"
.IX Subsection "rule_ids()"
.Vb 1
\&    do_something($_) for $grammar\->rule_ids();
.Ve
.PP
.Vb 1
\&    do_something($_) for $grammar\->rule_ids(\*(AqL0\*(Aq);
.Ve
.PP
Returns a list of the rule \s-1ID\s0's as an array.
Takes one, optional, argument: the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
.SS "\fBrule_name()\fP"
.IX Subsection "rule_name()"
.Vb 1
\&    push @rule_names, $grammar\->rule_name($_) for $grammar\->rule_ids();
.Ve
.PP
Given a rule \s-1ID,\s0 returns the rule name.
A rule name is as defined by
the \f(CW\*(C`name\*(C'\fR adverb.
If no rule name was defined, the rule name is the name of
the \s-1LHS\s0 symbol.
.SS "\fBrule_show()\fP"
.IX Subsection "rule_show()"
.Vb 1
\&    my $rule_description = $grammar\->rule_show($rule_id);
.Ve
.PP
.Vb 1
\&    my $rule_description = $grammar\->rule_show($rule_id, \*(AqL0\*(Aq);
.Ve
.PP
For a rule \s-1ID,\s0
returns a string describing that rule in a form which is useful for tracing and debugging,
but subject to change.
Returns a Perl undef if the rule does not exist.
.PP
The first argument is the \s-1ID\s0 of the rule to be displayed.
The second, optional, argument is the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
.SS "\fBstart_symbol_id()\fP"
.IX Subsection "start_symbol_id()"
.Vb 1
\&    my $start_id = $grammar\->start_symbol_id();
.Ve
.PP
Returns the \s-1ID\s0 of the start symbol.
Note that there is no method to return the \s-1ID\s0 of the start
rule, because there may be no unique start rule.
.SS "\fBsymbol_description()\fP"
.IX Subsection "symbol_description()"
.Vb 3
\&    my $description = $grammar\->symbol_description($symbol_id)
\&        // \*(Aq[No description]\*(Aq;
\&    $text .= "symbol number: $symbol_id  description $description\en";
.Ve
.PP
.Vb 3
\&    my $description = $grammar\->symbol_description( $symbol_id, \*(AqL0\*(Aq )
\&        // \*(Aq[No description]\*(Aq;
\&    $text .= "L0 symbol number: $symbol_id  description $description\en";
.Ve
.PP
Given a symbol \s-1ID,\s0 returns a description of the symbol.
The description may not be defined.
Currently internal symbols tend to have descriptions,
while symbols explicitly specified by the user in the \s-1DSL\s0 are treated as self-explanatory.
The description is intended for humans to read, and is subject to change.
.PP
The first argument is the symbol \s-1ID.
A\s0 second, optional, argument is the subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
Returns a Perl \f(CW\*(C`undef\*(C'\fR if the symbol does not exist,
or if it has no description.
.SS "\fBsymbol_display_form()\fP"
.IX Subsection "symbol_display_form()"
.Vb 3
\&    my $display_form = $grammar\->symbol_display_form($symbol_id);
\&    $text
\&        .= "symbol number: $symbol_id  name in display form: $display_form\en";
.Ve
.PP
.Vb 3
\&    my $display_form = $grammar\->symbol_display_form( $symbol_id, \*(AqL0\*(Aq );
\&    $text
\&        .= "L0 symbol number: $symbol_id  name in display form: $display_form\en";
.Ve
.PP
Given a symbol \s-1ID,\s0 returns the \*(L"display form\*(R" of the symbol.
This is the symbol in a form thought most suitable for display in messages, etc.
The display form is always defined.
The display form of a symbol is not useable as a name \*(-- it is not necessarily unique,
and is subject to change.
.PP
The first argument is the symbol \s-1ID.
A\s0 second, optional, argument is the subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
Returns a Perl \f(CW\*(C`undef\*(C'\fR if the symbol does not exist.
.SS "\fBsymbol_dsl_form()\fP"
.IX Subsection "symbol_dsl_form()"
.Vb 3
\&    my $dsl_form = $grammar\->symbol_dsl_form($symbol_id)
\&        // \*(Aq[No name in DSL form]\*(Aq;
\&    $text .= "symbol number: $symbol_id  DSL form: $dsl_form\en";
.Ve
.PP
.Vb 3
\&    my $dsl_form = $grammar\->symbol_dsl_form( $symbol_id, \*(AqL0\*(Aq )
\&        // \*(Aq[No name in DSL form]\*(Aq;
\&    $text .= "L0 symbol number: $symbol_id  DSL form: $dsl_form\en";
.Ve
.PP
Given a symbol \s-1ID,\s0 returns the \*(L"\s-1DSL\s0 form\*(R" of the symbol.
This is the name of the symbol in a form similar
to the way it is specified by the user in the \s-1DSL.\s0
If the symbol has an explicit name,
the symbol's \s-1DSL\s0 form is the same as its explicit name.
If the symbol does not have an explicit name,
the method may return a Perl \f(CW\*(C`undef\*(C'\fR,
or it may return a \s-1DSL\s0 name invented by Marpa
and intended to be suggestive.
The \s-1DSL\s0 form of a symbol is not intended for use as a symbol name
\&\*(-- it is not necessarily unique,
is not always defined,
and it is subject to change.
.PP
The first argument is the symbol \s-1ID.
A\s0 second, optional, argument is the subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
Returns a Perl \f(CW\*(C`undef\*(C'\fR if the symbol does not exist,
or if it has no \s-1DSL\s0 form.
.SS "\fBsymbol_ids()\fP"
.IX Subsection "symbol_ids()"
.Vb 1
\&    do_something($_) for $grammar\->symbol_ids();
.Ve
.PP
.Vb 1
\&    do_something($_) for $grammar\->symbol_ids(\*(AqL0\*(Aq);
.Ve
.PP
Returns a list of the symbol \s-1ID\s0's as an array.
Takes one, optional, argument: the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
.SS "\fBsymbol_name()\fP"
.IX Subsection "symbol_name()"
.Vb 2
\&    my $name = $grammar\->symbol_name($symbol_id);
\&    $text .= "symbol number: $symbol_id  name: $name\en";
.Ve
.PP
.Vb 2
\&    my $name = $grammar\->symbol_name( $symbol_id, \*(AqL0\*(Aq );
\&    $text .= "L0 symbol number: $symbol_id  name: $name\en";
.Ve
.PP
Given a symbol \s-1ID,\s0 returns the name of the symbol.
For every symbol \s-1ID,\s0 this method's return value will be defined
and will be unique to that symbol \s-1ID,\s0
so that it is suitable for use as a symbol name.
If a symbol has an explicit name, the return value will be
the symbol's explicit name.
If there is no explicit name, it will be an internal name.
Internal names are subject to change.
.PP
The first argument is the symbol \s-1ID.
A\s0 second, optional, argument is the subgrammar.
Currently there are L0 and G1 subgrammars.
The default subgrammar is G1.
Returns a Perl \f(CW\*(C`undef\*(C'\fR if the symbol does not exist.
.SH "Trace methods"
.IX Header "Trace methods"
.SS "\fBshow_rules()\fP"
.IX Subsection "show_rules()"
.Vb 1
\&    my $show_rules_output = $grammar\->show_rules();
.Ve
.PP
.Vb 1
\&    $show_rules_output .= $grammar\->show_rules(3, \*(AqL0\*(Aq);
.Ve
.PP
The \f(CW\*(C`show_rules()\*(C'\fR method returns a descripton of
the rules for a subgrammar, by default G1.
It is useful for understanding the rules as they
appear in trace and debugging outputs.
To allow for improvements in Marpa::R2,
the output of \f(CW\*(C`show_rules()\*(C'\fR is subject to change.
.PP
The first optional argument can be a numeric verbosity level.
The default verbosity is 1, which is adequate for
most purposes.
A verbosity of 2 prints additional information useful
for those new to \s-1SLIF\s0 tracing and debugging.
A verbosity of 3 prints additional information for
experts.
.PP
The second, optional, argument is the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
.SS "\fBshow_symbols()\fP"
.IX Subsection "show_symbols()"
.Vb 1
\&    $show_symbols_output .= $grammar\->show_symbols(3);
.Ve
.PP
.Vb 1
\&    $show_symbols_output .= $grammar\->show_symbols(3, \*(AqL0\*(Aq);
.Ve
.PP
The \f(CW\*(C`show_symbols()\*(C'\fR method returns a descripton of
the symbols for a subgrammar,
by default G1.
It is useful for understanding the symbols as they
appear in trace and debugging outputs.
To allow for improvements in Marpa::R2,
the output of \f(CW\*(C`show_symbols()\*(C'\fR is subject to change.
.PP
The first argument can be a numeric verbosity level.
The default verbosity is 1, which is adequate for
most purposes.
A verbosity of 2 prints additional information useful
for those new to \s-1SLIF\s0 tracing and debugging.
A verbosity of 3 prints additional information for
experts.
.PP
The second, optional, argument is the name of a subgrammar.
Currently there are L0 and G1 subgrammars.
.SH "Discouraged methods"
.IX Header "Discouraged methods"
Discouraged methods are those that
continue to be supported, but whose use is discouraged for one
reason or another.
.SS "\fBg0_rule()\fP"
.IX Subsection "g0_rule()"
.Vb 5
\&    my @g0_rule_ids = $grammar\->g0_rule_ids();
\&    for my $g0_rule_id (@g0_rule_ids) {
\&        $g0_rules_description .= "$g0_rule_id "
\&            . ( join q{ }, map {"<$_>"} $grammar\->g0_rule($g0_rule_id) ) . "\en";
\&    }
.Ve
.PP
Please prefer \*(L"\fBrule_expand()\fR\*(R", together with
\&\*(L"\fBsymbol_name()\fR\*(R" or
\&\*(L"\fBsymbol_display_form()\fR\*(R".
Given a L0 rule \s-1ID\s0 as its argument,
returns an array containing the
names of the symbols of that rule.
The \f(CW\*(C`g0_rule()\*(C'\fR method
returns a Perl false if no L0 rule with that rule \s-1ID\s0 exists.
If the L0 rule \s-1ID\s0 exists,
\&\f(CW\*(C`g0_rule()\*(C'\fR returns a list of one or more symbol names.
The first symbol name will be that of
the rule's \s-1LHS\s0 symbol.
The rest of the list will be the names of the rule's
\&\s-1RHS\s0 symbols, in order.
.SS "\fBg0_rule_ids()\fP"
.IX Subsection "g0_rule_ids()"
.Vb 5
\&    my @g0_rule_ids = $grammar\->g0_rule_ids();
\&    for my $g0_rule_id (@g0_rule_ids) {
\&        $g0_rules_description .= "$g0_rule_id "
\&            . ( join q{ }, map {"<$_>"} $grammar\->g0_rule($g0_rule_id) ) . "\en";
\&    }
.Ve
.PP
Please prefer \*(L"\fBrule_expand()\fR\*(R".
Returns a list of the L0 rule \s-1ID\s0's.
.SS "\fBg1_rule_ids()\fP"
.IX Subsection "g1_rule_ids()"
.Vb 5
\&    my @g1_rule_ids = $grammar\->g1_rule_ids();
\&    for my $g1_rule_id (@g1_rule_ids) {
\&        $g1_rules_description .= "$g1_rule_id "
\&            . ( join q{ }, map {"<$_>"} $grammar\->rule($g1_rule_id) ) . "\en";
\&    }
.Ve
.PP
Please prefer \*(L"\fBrule_expand()\fR\*(R".
Returns a list of the G1 rule \s-1ID\s0's.
.SS "\fBrule()\fP"
.IX Subsection "rule()"
.Vb 5
\&    my @g1_rule_ids = $grammar\->g1_rule_ids();
\&    for my $g1_rule_id (@g1_rule_ids) {
\&        $g1_rules_description .= "$g1_rule_id "
\&            . ( join q{ }, map {"<$_>"} $grammar\->rule($g1_rule_id) ) . "\en";
\&    }
.Ve
.PP
Please prefer \*(L"\fBrule_expand()\fR\*(R", together with
\&\*(L"\fBsymbol_name()\fR\*(R" or
\&\*(L"\fBsymbol_display_form()\fR\*(R".
Given a G1 rule \s-1ID\s0 as its argument,
returns an array containing the
names of the symbols of that rule.
The \f(CW\*(C`rule()\*(C'\fR method
returns a Perl false if no G1 rule with that rule \s-1ID\s0 exists.
If the rule \s-1ID\s0 exists,
\&\f(CW\*(C`rule()\*(C'\fR returns a list of one or more symbol names.
The first symbol name will be that of
the rule's \s-1LHS\s0 symbol.
The rest of the list will be the names of the rule's
\&\s-1RHS\s0 symbols, in order.
The \s-1SLIF\s0's \f(CW\*(C`rule()\*(C'\fR method is useful in
combination with
the \s-1SLIF\s0's
of the progress method,
whose output identifies rules by rule \s-1ID.\s0
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
