.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JSON::Validator 3"
.TH JSON::Validator 3 "2020-10-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Validator \- Validate data against a JSON schema
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use JSON::Validator;
\&  my $jv = JSON::Validator\->new;
\&
\&  # Define a schema \- http://json\-schema.org/learn/miscellaneous\-examples.html
\&  # You can also load schema from disk or web
\&  $jv\->schema({
\&    type       => "object",
\&    required   => ["firstName", "lastName"],
\&    properties => {
\&      firstName => {type => "string"},
\&      lastName  => {type => "string"},
\&      age       => {type => "integer", minimum => 0, description => "Age in years"}
\&    }
\&  });
\&
\&  # Validate your data
\&  my @errors = $jv\->validate({firstName => "Jan Henning", lastName => "Thorsen", age => \-42});
\&
\&  # Do something if any errors was found
\&  die "@errors" if @errors;
\&
\&  # Use joi() to build the schema
\&  use JSON::Validator \*(Aqjoi\*(Aq;
\&
\&  $jv\->schema(joi\->object\->props({
\&    firstName => joi\->string\->required,
\&    lastName  => joi\->string\->required,
\&    age       => joi\->integer\->min(0),
\&  }));
\&
\&  # joi() can also validate directly
\&  my @errors = joi(
\&    {firstName => "Jan Henning", lastName => "Thorsen", age => \-42},
\&    joi\->object\->props({
\&      firstName => joi\->string\->required,
\&      lastName  => joi\->string\->required,
\&      age       => joi\->integer\->min(0),
\&    });
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JSON::Validator is a data structure validation library based around
\&\s-1JSON\s0 Schema <https://json-schema.org/>. This module can be used directly with
a \s-1JSON\s0 schema or you can use the elegant \s-1DSL\s0 schema-builder
JSON::Validator::Joi to define the schema programmatically.
.SS "Supported schema formats"
.IX Subsection "Supported schema formats"
JSON::Validator can load \s-1JSON\s0 schemas in multiple formats: Plain perl data
structured (as shown in \*(L"\s-1SYNOPSIS\*(R"\s0), \s-1JSON\s0 or \s-1YAML.\s0 The \s-1JSON\s0 parsing is done
with Mojo::JSON, while \s-1YAML\s0 files requires \s-1YAML::PP\s0 or \s-1YAML::XS\s0.
.SS "Resources"
.IX Subsection "Resources"
Here are some resources that are related to \s-1JSON\s0 schemas and validation:
.IP "\(bu" 4
<http://json\-schema.org/documentation.html>
.IP "\(bu" 4
<https://json\-schema.org/understanding\-json\-schema/index.html>
.IP "\(bu" 4
<https://github.com/json\-schema/json\-schema/>
.SS "Bundled specifications"
.IX Subsection "Bundled specifications"
This module comes with some \s-1JSON\s0 specifications bundled, so your application
don't have to fetch those from the web. These specifications should be up to
date, but please submit an issue if they are not.
.PP
Files referenced to an \s-1URL\s0 will automatically be cached if the first element in
\&\*(L"cache_paths\*(R" is a writable directory. Note that the cache headers for the
remote assets are \fBnot\fR honored, so you will manually need to remove any
cached file, should you need to refresh them.
.PP
To download and cache an online asset, do this:
.PP
.Vb 1
\&  JSON_VALIDATOR_CACHE_PATH=/some/writable/directory perl myapp.pl
.Ve
.PP
Here is the list of the bundled specifications:
.IP "\(bu" 2
\&\s-1JSON\s0 schema, draft 4, 6, 7
.Sp
Web page: <http://json\-schema.org>
.Sp
\&\f(CW$ref\fR: <http://json\-schema.org/draft\-04/schema#>,
<http://json\-schema.org/draft\-06/schema#>,
<http://json\-schema.org/draft\-07/schema#>.
.IP "\(bu" 2
\&\s-1JSON\s0 schema for JSONPatch files
.Sp
Web page: <http://jsonpatch.com>
.Sp
\&\f(CW$ref\fR: <http://json.schemastore.org/json\-patch#>
.IP "\(bu" 2
Swagger / OpenAPI specification, version 2
.Sp
Web page: <https://openapis.org>
.Sp
\&\f(CW$ref\fR: <http://swagger.io/v2/schema.json#>
.IP "\(bu" 2
OpenAPI specification, version 3
.Sp
Web page: <https://openapis.org>
.Sp
\&\f(CW$ref\fR: https://spec.openapis.org/oas/3.0/schema/2019\-04\-02 <https://github.com/OAI/OpenAPI-Specification/blob/master/schemas/v3.0/schema.json>
.Sp
This specification is still \s-1EXPERIMENTAL.\s0
.IP "\(bu" 2
Swagger Petstore
.Sp
This is used for unit tests, and should not be relied on by external users.
.SS "Optional modules"
.IX Subsection "Optional modules"
.IP "\(bu" 2
Sereal::Encoder
.Sp
Installing Sereal::Encoder v4.00 (or later) will make
\&\*(L"data_checksum\*(R" in JSON::Validator::Util significantly faster. This function is
used both when parsing schemas and validating data.
.IP "\(bu" 2
Format validators
.Sp
See the documentation in JSON::Validator::Formats for other optional modules
to do validation of specific \*(L"format\*(R", such as \*(L"hostname\*(R", \*(L"ipv4\*(R" and others.
.SH "ERROR OBJECT"
.IX Header "ERROR OBJECT"
The methods \*(L"validate\*(R" and the function \*(L"validate_json\*(R" returns a list of
JSON::Validator::Error objects when the input data violates the \*(L"schema\*(R".
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "joi"
.IX Subsection "joi"
\&\s-1DEPRECATED.\s0
.SS "validate_json"
.IX Subsection "validate_json"
\&\s-1DEPRECATED.\s0
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "cache_paths"
.IX Subsection "cache_paths"
Proxy attribtue for \*(L"cache_paths\*(R" in JSON::Validator::Store.
.SS "formats"
.IX Subsection "formats"
.Vb 2
\&  my $hash_ref  = $jv\->formats;
\&  my $jv = $jv\->formats(\e%hash);
.Ve
.PP
Holds a hash-ref, where the keys are supported \s-1JSON\s0 type \*(L"formats\*(R", and
the values holds a code block which can validate a given format. A code
block should return \f(CW\*(C`undef\*(C'\fR on success and an error string on error:
.PP
.Vb 1
\&  sub { return defined $_[0] && $_[0] eq "42" ? undef : "Not the answer." };
.Ve
.PP
See JSON::Validator::Formats for a list of supported formats.
.SS "recursive_data_protection"
.IX Subsection "recursive_data_protection"
.Vb 2
\&  my $jv = $jv\->recursive_data_protections( $boolean );
\&  my $boolean = $jv\->recursive_data_protection;
.Ve
.PP
Recursive data protection is active by default, however it can be deactivated
by assigning a false value to the \*(L"recursive_data_protection\*(R" attribute.
.PP
Recursive data protection can have a noticeable impact on memory usage when
validating large data structures. If you are encountering issues with memory
and you can guarantee that you do not have any loops in your data structure
then deactivating the recursive data protection may help.
.PP
This attribute is \s-1EXPERIMENTAL\s0 and may change in a future release.
.PP
\&\fBDisclaimer: Use at your own risk, if you have any doubt then don't use it\fR
.SS "ua"
.IX Subsection "ua"
Proxy attribtue for \*(L"ua\*(R" in JSON::Validator::Store.
.SS "version"
.IX Subsection "version"
\&\s-1DEPRECATED.\s0
.SH "METHODS"
.IX Header "METHODS"
.SS "bundle"
.IX Subsection "bundle"
.Vb 3
\&  # These two lines does the same
\&  my $schema = $jv\->bundle({schema => $jv\->schema\->data});
\&  my $schema = $jv\->bundle;
\&
\&  # Will only bundle a section of the schema
\&  my $schema = $jv\->bundle({schema => $jv\->schema\->get("/properties/person/age")});
.Ve
.PP
Used to create a new schema, where there are no \*(L"$ref\*(R" pointing to external
resources. This means that all the \*(L"$ref\*(R" that are found, will be moved into
the \*(L"definitions\*(R" key, in the returned \f(CW$schema\fR.
.SS "coerce"
.IX Subsection "coerce"
.Vb 3
\&  my $jv       = $jv\->coerce(\*(Aqbool,def,num,str\*(Aq);
\&  my $jv       = $jv\->coerce(\*(Aqbooleans,defaults,numbers,strings\*(Aq);
\&  my $hash_ref = $jv\->coerce;
.Ve
.PP
Set the given type to coerce. Before enabling coercion this module is very
strict when it comes to validating types. Example: The string \f(CW"1"\fR is not
the same as the number \f(CW1\fR, unless you have \*(L"numbers\*(R" coercion enabled.
.IP "\(bu" 2
booleans
.Sp
Will convert what looks can be interpreted as a boolean (that is, an actual
numeric \f(CW1\fR or \f(CW0\fR, and the strings \*(L"true\*(R" and \*(L"false\*(R") to a
JSON::PP::Boolean object. Note that \*(L"foo\*(R" is not considered a true value and
will fail the validation.
.IP "\(bu" 2
defaults
.Sp
Will copy the default value defined in the schema, into the input structure,
if the input value is non-existing.
.Sp
Note that support for \*(L"default\*(R" is currently \s-1EXPERIMENTAL,\s0 and enabling this
might be changed in future versions.
.IP "\(bu" 2
numbers
.Sp
Will convert strings that looks like numbers, into true numbers. This works for
both the \*(L"integer\*(R" and \*(L"number\*(R" types.
.IP "\(bu" 2
strings
.Sp
Will convert a number into a string. This works for the \*(L"string\*(R" type.
.SS "get"
.IX Subsection "get"
.Vb 2
\&  my $sub_schema = $jv\->get("/x/y");
\&  my $sub_schema = $jv\->get(["x", "y"]);
.Ve
.PP
Extract value from \*(L"schema\*(R" identified by the given \s-1JSON\s0 Pointer. Will at the
same time resolve \f(CW$ref\fR if found. Example:
.PP
.Vb 4
\&  $jv\->schema({x => {\*(Aq$ref\*(Aq => \*(Aq#/y\*(Aq}, y => {\*(Aqtype\*(Aq => \*(Aqstring\*(Aq}});
\&  $jv\->schema\->get(\*(Aq/x\*(Aq)           == {\*(Aq$ref\*(Aq => \*(Aq#/y\*(Aq}
\&  $jv\->schema\->get(\*(Aq/x\*(Aq)\->{\*(Aq$ref\*(Aq} == \*(Aq#/y\*(Aq
\&  $jv\->get(\*(Aq/x\*(Aq)                   == {type => \*(Aqstring\*(Aq}
.Ve
.PP
The argument can also be an array-ref with the different parts of the pointer
as each elements.
.SS "new"
.IX Subsection "new"
.Vb 2
\&  $jv = JSON::Validator\->new(%attributes);
\&  $jv = JSON::Validator\->new(\e%attributes);
.Ve
.PP
Creates a new JSON::Validate object.
.SS "load_and_validate_schema"
.IX Subsection "load_and_validate_schema"
.Vb 1
\&  my $jv = $jv\->load_and_validate_schema($schema, \e%args);
.Ve
.PP
Will load and validate \f(CW$schema\fR against the OpenAPI specification. \f(CW$schema\fR
can be anything \*(L"schema\*(R" in JSON::Validator accepts. The expanded specification
will be stored in \*(L"schema\*(R" in JSON::Validator on success. See
\&\*(L"schema\*(R" in JSON::Validator for the different version of \f(CW$url\fR that can be
accepted.
.PP
\&\f(CW%args\fR can be used to further instruct the validation process:
.IP "\(bu" 2
schema
.Sp
Defaults to \*(L"http://json\-schema.org/draft\-04/schema#\*(R", but can be any
structured that can be used to validate \f(CW$schema\fR.
.SS "schema"
.IX Subsection "schema"
.Vb 5
\&  my $jv     = $jv\->schema($json_or_yaml_string);
\&  my $jv     = $jv\->schema($url);
\&  my $jv     = $jv\->schema(\e%schema);
\&  my $jv     = $jv\->schema(JSON::Validator::Joi\->new);
\&  my $schema = $jv\->schema;
.Ve
.PP
Used to set a schema from either a data structure or a \s-1URL.\s0
.PP
\&\f(CW$schema\fR will be a JSON::Validator::Schema object when loaded,
and \f(CW\*(C`undef\*(C'\fR by default.
.PP
The \f(CW$url\fR can take many forms, but needs to point to a text file in the
\&\s-1JSON\s0 or \s-1YAML\s0 format.
.IP "\(bu" 4
file://...
.Sp
A file on disk. Note that it is required to use the \*(L"file\*(R" scheme if you want
to reference absolute paths on your file system.
.IP "\(bu" 4
http://... or https://...
.Sp
A web resource will be fetched using the Mojo::UserAgent, stored in \*(L"ua\*(R".
.IP "\(bu" 4
data://Some::Module/spec.json
.Sp
Will load a given \*(L"spec.json\*(R" file from \f(CW\*(C`Some::Module\*(C'\fR using
\&\*(L"data_section\*(R" in JSON::Validator::Util.
.IP "\(bu" 4
data:///spec.json
.Sp
A \*(L"data\*(R" \s-1URL\s0 without a module name will use the current package and search up
the call/inheritance tree.
.IP "\(bu" 4
Any other \s-1URL\s0
.Sp
An \s-1URL\s0 (without a recognized scheme) will be treated as a path to a file on
disk. If the file could not be found on disk and the path starts with \*(L"/\*(R", then
the will be loaded from the app defined in \*(L"ua\*(R". Something like this:
.Sp
.Vb 2
\&  $jv\->ua\->server\->app(MyMojoApp\->new);
\&  $jv\->ua\->get(\*(Aq/any/other/url.json\*(Aq);
.Ve
.SS "singleton"
.IX Subsection "singleton"
\&\s-1DEPRECATED.\s0
.SS "validate"
.IX Subsection "validate"
.Vb 2
\&  my @errors = $jv\->validate($data);
\&  my @errors = $jv\->validate($data, $schema);
.Ve
.PP
Validates \f(CW$data\fR against a given \s-1JSON\s0 \*(L"schema\*(R". \f(CW@errors\fR will
contain validation error objects, in a predictable order (specifically,
ASCIIbetically sorted by the error objects' \f(CW\*(C`path\*(C'\fR) or be an empty
list on success.
.PP
See \*(L"\s-1ERROR OBJECT\*(R"\s0 for details.
.PP
\&\f(CW$schema\fR is optional, but when specified, it will override schema stored in
\&\*(L"schema\*(R". Example:
.PP
.Vb 1
\&  $jv\->validate({hero => "superwoman"}, {type => "object"});
.Ve
.SS "\s-1SEE ALSO\s0"
.IX Subsection "SEE ALSO"
.IP "\(bu" 2
Mojolicious::Plugin::OpenAPI
.Sp
Mojolicious::Plugin::OpenAPI is a plugin for Mojolicious that utilize
JSON::Validator and the OpenAPI specification <https://www.openapis.org/>
to build routes with input and output validation.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2014\-2018, Jan Henning Thorsen
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jan Henning Thorsen \- \f(CW\*(C`jhthorsen@cpan.org\*(C'\fR
.PP
Daniel Böhmer \- \f(CW\*(C`post@daniel\-boehmer.de\*(C'\fR
.PP
Ed J \- \f(CW\*(C`mohawk2@users.noreply.github.com\*(C'\fR
.PP
Karen Etheridge \- \f(CW\*(C`ether@cpan.org\*(C'\fR
.PP
Kevin Goess \- \f(CW\*(C`cpan@goess.org\*(C'\fR
.PP
Martin Renvoize \- \f(CW\*(C`martin.renvoize@gmail.com\*(C'\fR
