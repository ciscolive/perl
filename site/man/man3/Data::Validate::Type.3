.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Validate::Type 3"
.TH Data::Validate::Type 3 "2020-10-22" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Validate::Type \- Data type validation functions.
.SH "VERSION"
.IX Header "VERSION"
Version 1.6.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&        # Call with explicit package name.
\&        use Data::Validate::Type;
\&        if ( Data::Validate::Type::is_string( \*(Aqtest\*(Aq ) )
\&        {
\&                # ...
\&        }
\&
\&        # Import specific functions.
\&        use Data::Validate::Type qw( is_string );
\&        if ( is_string( \*(Aqtest\*(Aq ) )
\&        {
\&                # ...
\&        }
\&
\&        # Import functions for a given paradigm.
\&        use Data::Validate::Type qw( :boolean_tests );
\&        if ( is_string( \*(Aqtest\*(Aq ) )
\&        {
\&                # ...
\&        }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Params::Util is a wonderful module, but suffers from a few drawbacks:
.IP "\(bu" 4
Function names start with an underscore, which is usually used to
indicate private functions.
.IP "\(bu" 4
Function names are uppercase, which is usually used to indicate file
handles or constants.
.IP "\(bu" 4
Function names don't pass PerlCritic's validation, making them
problematic to import.
.IP "\(bu" 4
Functions use by default the convention that collection that collections
need to not be empty to be valid (see _ARRAY0/_ARRAY for example), which is
counter-intuitive.
.IP "\(bu" 4
In Pure Perl mode, the functions are created via eval, which causes
issues for Devel::Cover in taint mode.
.PP
Those drawbacks are purely cosmetic and don't affect the usefulness of the
functions, except for the last one. This module used to encapsulate
Params::Util, but I had to refactor it out to fix the issues with
Devel::Cover.
.PP
Please note that I prefer long function names that are descriptive, to arcane
short ones. This increases readability, and the bulk of the typing can be
spared with the use of a good \s-1IDE\s0 like Padre.
.PP
Also, this is work in progress \- There is more functions that should be added
here, if you need one in particular feel free to contact me.
.SH "BOOLEAN TEST FUNCTIONS"
.IX Header "BOOLEAN TEST FUNCTIONS"
Functions in this group return a boolean to indicate whether the parameters
passed match the test(s) specified by the functions or not.
.PP
All the boolean functions can be imported at once in your namespace with the
following line:
.PP
.Vb 1
\&        use Data::Validate::Type qw( :boolean_tests );
.Ve
.SS "\fBis_string()\fP"
.IX Subsection "is_string()"
Return a boolean indicating if the variable passed is a string.
.PP
.Vb 1
\&        my $is_string = Data::Validate::Type::is_string( $variable );
.Ve
.PP
Note: 0 and '' (empty string) are valid strings.
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the string to be empty or not.
.SS "\fBis_arrayref()\fP"
.IX Subsection "is_arrayref()"
Return a boolean indicating if the variable passed is an arrayref that can be
dereferenced into an array.
.PP
.Vb 1
\&        my $is_arrayref = Data::Validate::Type::is_arrayref( $variable );
\&
\&        my $is_arrayref = Data::Validate::Type::is_arrayref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
\&
\&        # Check if the variable is an arrayref of hashrefs.
\&        my $is_arrayref = Data::Validate::Type::is_arrayref(
\&                $variable,
\&                allow_empty           => 1,
\&                no_blessing           => 0,
\&                element_validate_type =>
\&                        sub
\&                        {
\&                                return Data::Validate::Type::is_hashref( $_[0] );
\&                        },
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.IP "\(bu" 4
element_validate_type
.Sp
None by default. Set it to a coderef to validate the elements in the array.
The coderef will be passed the element to validate as first parameter, and it
must return a boolean indicating whether the element was valid or not.
.SS "\fBis_hashref()\fP"
.IX Subsection "is_hashref()"
Return a boolean indicating if the variable passed is a hashref that can be
dereferenced into a hash.
.PP
.Vb 1
\&        my $is_hashref = Data::Validate::Type::is_hashref( $variable );
\&
\&        my $is_hashref = Data::Validate::Type::is_hashref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.SS "\fBis_coderef()\fP"
.IX Subsection "is_coderef()"
Return a boolean indicating if the variable passed is an coderef that can be
dereferenced into a block of code.
.PP
.Vb 1
\&        my $is_coderef = Data::Validate::Type::is_coderef( $variable );
.Ve
.SS "\fBis_number()\fP"
.IX Subsection "is_number()"
Return a boolean indicating if the variable passed is a number.
.PP
.Vb 9
\&        my $is_number = Data::Validate::Type::is_number( $variable );
\&        my $is_number = Data::Validate::Type::is_number(
\&                $variable,
\&                positive => 1,
\&        );
\&        my $is_number = Data::Validate::Type::is_number(
\&                $variable,
\&                strictly_positive => 1,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
strictly_positive
.Sp
Boolean, default 0. Set to 1 to check for a strictly positive number.
.IP "\(bu" 4
positive
.Sp
Boolean, default 0. Set to 1 to check for a positive number.
.SS "\fBis_instance()\fP"
.IX Subsection "is_instance()"
Return a boolean indicating if the variable is an instance of the given class.
.PP
Note that this handles inheritance properly, so it will return true if the
variable is an instance of a subclass of the class given.
.PP
.Vb 4
\&        my $is_instance = Data::Validate::Type::is_instance(
\&                $variable,
\&                class => $class,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
class
.Sp
Required, the name of the class to check the variable against.
.SS "\fBis_regex()\fP"
.IX Subsection "is_regex()"
Return a boolean indicating if the variable is a regular expression.
.PP
.Vb 1
\&        my $is_regex = Data::Validate::Type::is_regex( $variable );
.Ve
.SH "ASSERTION-BASED FUNCTIONS"
.IX Header "ASSERTION-BASED FUNCTIONS"
Functions in this group do not return anything, but will die when the parameters
passed don't match the test(s) specified by the functions.
.PP
All the assertion test functions can be imported at once in your namespace with
the following line:
.PP
.Vb 1
\&        use Data::Validate::Type qw( :assertions );
.Ve
.SS "\fBassert_string()\fP"
.IX Subsection "assert_string()"
Die unless the variable passed is a string.
.PP
.Vb 1
\&        Data::Validate::Type::assert_string( $variable );
.Ve
.PP
Note: 0 and '' (empty string) are valid strings.
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the string to be empty or not.
.SS "\fBassert_arrayref()\fP"
.IX Subsection "assert_arrayref()"
Die unless the variable passed is an arrayref that can be dereferenced into an
array.
.PP
.Vb 1
\&        Data::Validate::Type::assert_arrayref( $variable );
\&
\&        Data::Validate::Type::assert_arrayref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
\&
\&        # Require the variable to be an arrayref of hashrefs.
\&        Data::Validate::Type::assert_arrayref(
\&                $variable,
\&                allow_empty           => 1,
\&                no_blessing           => 0,
\&                element_validate_type =>
\&                        sub
\&                        {
\&                                return Data::Validate::Type::is_hashref( $_[0] );
\&                        },
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.IP "\(bu" 4
element_validate_type
.Sp
None by default. Set it to a coderef to validate the elements in the array.
The coderef will be passed the element to validate as first parameter, and it
must return a boolean indicating whether the element was valid or not.
.SS "\fBassert_hashref()\fP"
.IX Subsection "assert_hashref()"
Die unless the variable passed is a hashref that can be dereferenced into a hash.
.PP
.Vb 1
\&        Data::Validate::Type::assert_hashref( $variable );
\&
\&        Data::Validate::Type::assert_hashref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.SS "\fBassert_coderef()\fP"
.IX Subsection "assert_coderef()"
Die unless the variable passed is an coderef that can be dereferenced into a
block of code.
.PP
.Vb 1
\&        Data::Validate::Type::assert_coderef( $variable );
.Ve
.SS "\fBassert_number()\fP"
.IX Subsection "assert_number()"
Die unless the variable passed is a number.
.PP
.Vb 9
\&        Data::Validate::Type::assert_number( $variable );
\&        Data::Validate::Type::assert_number(
\&                $variable,
\&                positive => 1,
\&        );
\&        Data::Validate::Type::assert_number(
\&                $variable,
\&                strictly_positive => 1,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
strictly_positive
.Sp
Boolean, default 0. Set to 1 to check for a strictly positive number.
.IP "\(bu" 4
positive
.Sp
Boolean, default 0. Set to 1 to check for a positive number.
.SS "\fBassert_instance()\fP"
.IX Subsection "assert_instance()"
Die unless the variable is an instance of the given class.
.PP
Note that this handles inheritance properly, so it will not die if the
variable is an instance of a subclass of the class given.
.PP
.Vb 4
\&        Data::Validate::Type::assert_instance(
\&                $variable,
\&                class => $class,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
class
.Sp
Required, the name of the class to check the variable against.
.SS "\fBassert_regex()\fP"
.IX Subsection "assert_regex()"
Die unless the variable is a regular expression.
.PP
.Vb 1
\&        Data::Validate::Type::assert_regex( $variable );
.Ve
.SH "FILTERING FUNCTIONS"
.IX Header "FILTERING FUNCTIONS"
Functions in this group return the variable tested against when it matches the
test(s) specified by the functions.
.PP
All the filtering functions can be imported at once in your namespace with the
following line:
.PP
.Vb 1
\&        use Data::Validate::Type qw( :filters );
.Ve
.SS "\fBfilter_string()\fP"
.IX Subsection "filter_string()"
Return the variable passed if it is a string, otherwise return undef.
.PP
.Vb 1
\&        Data::Validate::Type::filter_string( $variable );
.Ve
.PP
Note: 0 and '' (empty string) are valid strings.
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the string to be empty or not.
.SS "\fBfilter_arrayref()\fP"
.IX Subsection "filter_arrayref()"
Return the variable passed if it is an arrayref that can be dereferenced into an
array, otherwise undef.
.PP
.Vb 1
\&        Data::Validate::Type::filter_arrayref( $variable );
\&
\&        Data::Validate::Type::filter_arrayref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
\&
\&        # Only return the variable if it is an arrayref of hashrefs.
\&        Data::Validate::Type::filter_arrayref(
\&                $variable,
\&                allow_empty           => 1,
\&                no_blessing           => 0,
\&                element_validate_type =>
\&                        sub
\&                        {
\&                                return Data::Validate::Type::is_hashref( $_[0] );
\&                        },
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.IP "\(bu" 4
element_validate_type
.Sp
None by default. Set it to a coderef to validate the elements in the array.
The coderef will be passed the element to validate as first parameter, and it
must return a boolean indicating whether the element was valid or not.
.SS "\fBfilter_hashref()\fP"
.IX Subsection "filter_hashref()"
Return the variable passed if it is a hashref that can be dereferenced into a
hash, otherwise return undef.
.PP
.Vb 1
\&        Data::Validate::Type::filter_hashref( $variable );
\&
\&        Data::Validate::Type::filter_hashref(
\&                $variable,
\&                allow_empty => 1,
\&                no_blessing => 0,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
allow_empty
.Sp
Boolean, default 1. Allow the array to be empty or not.
.IP "\(bu" 4
no_blessing
.Sp
Boolean, default 0. Require that the variable is not blessed.
.SS "\fBfilter_coderef()\fP"
.IX Subsection "filter_coderef()"
Return the variable passed if it is a coderef that can be dereferenced into a
block of code, otherwise return undef.
.PP
.Vb 1
\&        Data::Validate::Type::filter_coderef( $variable );
.Ve
.SS "\fBfilter_number()\fP"
.IX Subsection "filter_number()"
Return the variable passed if it is a number, otherwise return undef.
.PP
.Vb 9
\&        Data::Validate::Type::filter_number( $variable );
\&        Data::Validate::Type::filter_number(
\&                $variable,
\&                positive => 1,
\&        );
\&        Data::Validate::Type::filter_number(
\&                $variable,
\&                strictly_positive => 1,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
strictly_positive
.Sp
Boolean, default 0. Set to 1 to check for a strictly positive number.
.IP "\(bu" 4
positive
.Sp
Boolean, default 0. Set to 1 to check for a positive number.
.SS "\fBfilter_instance()\fP"
.IX Subsection "filter_instance()"
Return the variable passed if it is an instance of the given class.
.PP
Note that this handles inheritance properly, so it will return the variable if
it is an instance of a subclass of the class given.
.PP
.Vb 4
\&        Data::Validate::Type::filter_instance(
\&                $variable,
\&                class => $class,
\&        );
.Ve
.PP
Parameters:
.IP "\(bu" 4
class
.Sp
Required, the name of the class to check the variable against.
.SS "\fBfilter_regex()\fP"
.IX Subsection "filter_regex()"
Return the variable passed if it is a regular expression.
.PP
.Vb 1
\&        Data::Validate::Type::filter_regex( $variable );
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests through the web interface at
<https://github.com/guillaumeaubert/Data\-Validate\-Type/issues>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&        perldoc Data::Validate::Type
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
GitHub (report bugs there)
.Sp
<https://github.com/guillaumeaubert/Data\-Validate\-Type/issues>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Data\-Validate\-Type>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Data\-Validate\-Type>
.IP "\(bu" 4
MetaCPAN
.Sp
<https://metacpan.org/release/Data\-Validate\-Type>
.SH "AUTHOR"
.IX Header "AUTHOR"
Guillaume Aubert <https://metacpan.org/author/AUBERTG>,
\&\f(CW\*(C`<aubertg at cpan.org>\*(C'\fR.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Adam Kennedy for writing Params::Util. This module started as an
encapsulation for Params::Util and I learnt quite a bit from it.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2012\-2017 Guillaume Aubert.
.PP
This code is free software; you can redistribute it and/or modify it under the
same terms as Perl 5 itself.
.PP
This program is distributed in the hope that it will be useful, but \s-1WITHOUT ANY
WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A
PARTICULAR PURPOSE.\s0 See the \s-1LICENSE\s0 file for more details.
