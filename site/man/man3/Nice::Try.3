.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Nice::Try 3"
.TH Nice::Try 3 "2020-09-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Nice::Try \- A real Try Catch Block Implementation Using Perl Filter
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Nice::Try;
\&
\&    print( "Hello, I want to try\en" );
\&    # Try out {
\&    print( "this piece of code\en" );
\&    try 
\&    {
\&        # Not so sure }
\&        print( "I am trying!\en" );
\&        die( "Bye cruel world..." );
\&        # Never going to reach this
\&        return( 1 );
\&    }
\&    # Some comment
\&    catch( Exception $e ) {
\&        return( "Caught an exception \e$e" );
\&    }
\&    # More comment with space too
\&
\&    catch( $e ) {
\&        print( "Got an error: $e\en" );
\&    }
\&    finally
\&    {
\&        print( "Cleaning up\en" );
\&    }
\&    print( "Ok, then\en" );
.Ve
.PP
When run, this would produce, as one would expect:
.PP
.Vb 6
\&    Hello, I want to try
\&    this piece of code
\&    I am trying!
\&    Got an error: Bye cruel world... at ./some/script.pl line 18.
\&    Cleaning up
\&    Ok, then
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.1.5
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Nice::Try is a lightweight implementation of Try-Catch exception trapping block using perl filter. It behaves like you would expect.
.PP
Here is a list of its distinctive features:
.IP "\(bu" 4
No routine to import like \f(CW\*(C`Nice::Try qw( try catch )\*(C'\fR. Just add \f(CW\*(C`use Nice::Try\*(C'\fR in your script
.IP "\(bu" 4
Properly report the right line number for the original error message
.IP "\(bu" 4
Allows embedded try-catch block within try-catch block, such as:
.Sp
.Vb 1
\&    use Nice::Try;
\&
\&    print( "Wow, something went awry: ", &gotcha, "\en" );
\&
\&    sub gotcha
\&    {
\&        print( "Hello, I want to try\en" );
\&        # Try out {
\&        CORE::say( \*(Aqthis piece\*(Aq );
\&        try 
\&        {
\&            # Not so sure }
\&            print( "I am trying!\en" );
\&            try
\&            {
\&                die( "Bye cruel world..." );
\&                return( 1 );
\&            }
\&            catch( $err )
\&            {
\&                die( "Dying again with embedded error: \*(Aq$err\*(Aq" );
\&            }
\&        }
\&        catch( Exception $e ) {
\&            return( "Caught an exception \e$e" );
\&        }
\&        catch( $e ) {
\&            try
\&            {
\&                print( "Got an error: $e\en" );
\&                print( "Trying something else.\en" );
\&                die( "No really, dying out... with error: $e\en" );
\&            }
\&            catch( $err2 )
\&            {
\&                return( "Returning from catch L2 with error \*(Aq$err2\*(Aq" );
\&            }
\&        }
\&        CORE::say( "Ok, then" );
\&    }
.Ve
.IP "\(bu" 4
No need for semicolon on the last closing brace
.IP "\(bu" 4
It does not rely on perl regular expression, but instead uses \s-1PPI\s0 (short for \*(L"Perl Parsing Interface\*(R").
.IP "\(bu" 4
Variable assignment in the catch block works. For example:
.Sp
.Vb 9
\&    try
\&    {
\&        # Something or
\&        die( "Oops\en" );
\&    }
\&    catch( $funky_variable_name )
\&    {
\&        return( "Oh no: $funky_variable_name" );
\&    }
.Ve
.IP "\(bu" 4
\&\f(CW$@\fR is always available too
.IP "\(bu" 4
You can return a value from try-catch blocks, even with embedded try-catch blocks
.IP "\(bu" 4
It recognises \f(CW@_\fR inside try-catch blocks, so you can do something like:
.Sp
.Vb 1
\&    print( &gotme( \*(AqJacques\*(Aq ), "\en" );
\&
\&    sub gotme
\&    {
\&        try
\&        {
\&            print( "I am trying my best $_[0]!\en" );
\&            die( "But I failed\en" );
\&        }
\&        catch( $some_reason )
\&        {
\&            return( "Failed: $some_reason" );
\&        }
\&    }
.Ve
.Sp
Would produce:
.Sp
.Vb 2
\&    I am trying my best Jacques!
\&    Failed: But I failed
.Ve
.SH "WHY USE IT?"
.IX Header "WHY USE IT?"
There are quite a few implementations of try-catch blocks in perl, and they can be grouped in 4 categories:
.IP "1 Try-Catch as subroutines" 4
.IX Item "1 Try-Catch as subroutines"
For example Try::Tiny
.IP "2 Using Perl Filter" 4
.IX Item "2 Using Perl Filter"
For example Nice::Try, Try::Harder
.IP "3 Using Devel::Declare" 4
.IX Item "3 Using Devel::Declare"
For example TryCatch
.IP "4 Others" 4
.IX Item "4 Others"
For example Syntax::Keyword::Try
.PP
Group 1 requires the use of semi-colons like:
.PP
.Vb 8
\&    try
\&    {
\&        # Something
\&    }
\&    catch
\&    {
\&        # More code
\&    };
.Ve
.PP
It also imports the subroutines \f(CW\*(C`try\*(C'\fR and \f(CW\*(C`catch\*(C'\fR in your namespace.
.PP
And you cannot do exception variable assignment like \f(CW\*(C`catch( $err )\*(C'\fR
.PP
In group 2, Try::Harder does a very nice work, but relies on perl regular expression with Text::Balanced and that makes it susceptible to failure if the try-catch block is not written as it expects it to be. For example if you put comments between try and catch, it would not work anymore. This is because parsing perl is famously difficult. Also, it does not do exception variable assignment, or catch filtered based on exception class like:
.PP
.Vb 9
\&    try
\&    {
\&        # Something
\&        die( Exception\->new( "Failed!" ) );
\&    }
\&    catch( Exception $e )
\&    {
\&        # Do something if exception is an Exception class
\&    }
.Ve
.PP
See \*(L"die\*(R" in perlfunc for more information on dying with an object.
.PP
Also Try::Harder will die if you use only \f(CW\*(C`try\*(C'\fR with no catch, such as:
.PP
.Vb 7
\&    use Try::Harder;
\&    try
\&    {
\&        die( "Oops\en" );
\&    }
\&    # Will never reach this
\&    print( "Got here with $@\en" );
.Ve
.PP
In this example, the print line will never get executed. With Nice::Try you can use \f(CW\*(C`try\*(C'\fR alone as an equivalent of \*(L"eval\*(R" in perlfunc and the \f(CW$@\fR will be available too. So:
.PP
.Vb 6
\&    use Nice::Try;
\&    try
\&    {
\&        die( "Oops\en" );
\&    }
\&    print( "Got here with $@\en" );
.Ve
.PP
will produces:
.PP
.Vb 1
\&    Got here with Oops
.Ve
.PP
In group 3, TryCatch was working wonderfully, but was relying on Devel::Declare which was doing some esoteric stuff and eventually the version 0.006020 broke TryCatch and there seems to be no intention of correcting this breaking change.
.PP
In group 4, there is Syntax::Keyword::Try, which is a great alternative if you do not care about exception variable assignment or exception class filter. You can only use \f(CW$@\fR
.PP
So, Nice::Try is quite unique and fill the missing features, but because it is purely in perl and not an \s-1XS\s0 module, it is slower than \s-1XS\s0 module like Syntax::Keyword::Try. I am not sure the difference would be noticeable for regular size script, but the parsing with \s-1PPI\s0 would definitely take more time on larger piece of code like 10,000 lines or more. If you know of a perl parser that uses \s-1XS,\s0 please let me know.
.SH "FINALLY"
.IX Header "FINALLY"
Like with other language such as Java or JavaScript, the \f(CW\*(C`finally\*(C'\fR block will be executed even if the \f(CW\*(C`try\*(C'\fR or \f(CW\*(C`catch\*(C'\fR block contains a return statement.
.PP
This is useful to do some clean-up. For example:
.PP
.Vb 10
\&    try
\&    {
\&        # Something worth dying
\&    }
\&    catch( $e )
\&    {
\&        return( "I failed: $e" );
\&    }
\&    finally
\&    {
\&        # Do some mop up
\&        # This would be reached even if catch already returned
\&        # Putting return statement here does not actually return anything.
\&        # This is only for clean\-up
\&    }
.Ve
.PP
However, because this is designed for clean-up, it is called in void context, so any \f(CW\*(C`return\*(C'\fR statement there will not actually return anything back to the caller.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
And to have Nice::Try save the filtered code to a file, pass it the \f(CW\*(C`debug_file\*(C'\fR parameter like this:
.PP
.Vb 1
\&    use Nice::Try debug_file => \*(Aq./updated_script.pl\*(Aq;
.Ve
.PP
You can also call your script using Filter::ExtractSource like this:
.PP
.Vb 1
\&    perl \-MFilter::ExtractSource script.pl > updated_script.pl
.Ve
.PP
or add \f(CW\*(C`use Filter::ExtractSource\*(C'\fR inside it.
.PP
In the updated script produced, you can add the line calling Nice::Try to:
.PP
.Vb 1
\&    use Nice::Try no_filter => 1;
.Ve
.PP
to avoid Nice::Try from filtering your script
.PP
If you want Nice::Try to produce human readable code, pass it the \f(CW\*(C`debug_code\*(C'\fR parameter like this:
.PP
.Vb 1
\&    use Nice::Try debug_code => 1;
.Ve
.SH "CREDITS"
.IX Header "CREDITS"
Credits to Stephen R. Scaffidi for his implementation of Try::Harder from which I borrowed some code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1PPI\s0, Filter::Util::Call, Try::Harder, Syntax::Keyword::Try
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated files under the same terms as Perl itself.
