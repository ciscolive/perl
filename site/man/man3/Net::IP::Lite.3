.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::IP::Lite 3"
.TH Net::IP::Lite 3 "2013-06-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IP::Lite \- Perl extension for manipulating IPv4/IPv6 addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Net::IP::Lite;
\&
\&        print ip2bin(\*(Aq127.0.0.1\*(Aq) . "\en";
\&        print ip_validate(\*(Aq127.0.0.1\*(Aq) . "\en";
\&
\&        print ip_is_ipv4(\*(Aq127.0.0.1\*(Aq) . "\en";
\&        print ip_is_ipv6(\*(Aq::1\*(Aq) . "\en";
\&        print ip_is_ipv6ipv4(\*(Aq::ffff:7f00:1\*(Aq) . "\en";
\&
\&        print ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv6ipv4\*(Aq,
\&                short_ipv6 => 1 }
\&        ) . "\en";
\&
\&        print ip_equal(\*(Aq0x7f000001\*(Aq, \*(Aq127.0.0.1\*(Aq) . "\en";
\&        print ip_equal_v4(\*(Aq0x7f000001\*(Aq, \*(Aq::ffff:127.0.0.1\*(Aq) . "\en";
\&        print ip_equal_v6(\*(Aq0x7f000001\*(Aq, \*(Aq::ffff:127.0.0.1\*(Aq) . "\en";
\&
\&        print ip_in_range(\*(Aq127.0.0.1\*(Aq, \*(Aq127.0.0.1/8\*(Aq) . "\en";
\&        print ip_in_range(\*(Aq127.0.0.1\*(Aq, [
\&                \*(Aq127.0.0.1/8\*(Aq,
\&                \*(Aq10.0.0.0 255.255.255.255\*(Aq
\&        ]) . "\en";
\&
\&        my $ip = Net::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq) || die \*(AqInvalid IP address\*(Aq;
\&        print $ip\->binary . "\en";
\&        print $ip\->address . "\en";
\&
\&        print $ip\->is_ipv4(\*(Aq127.0.0.1\*(Aq) . "\en";
\&        print $ip\->is_ipv6(\*(Aq::1\*(Aq) . "\en";
\&        print $ip\->is_ipv6ipv4(\*(Aq::ffff:7f00:1\*(Aq) . "\en";
\&
\&        print $ip\->transform({
\&                convert_to => \*(Aqipv6ipv4\*(Aq,
\&                short_ipv6 => 1
\&        }) . "\en";
\&
\&        print $ip\->equal(\*(Aq0x7f000001\*(Aq, \*(Aq127.0.0.1\*(Aq) . "\en";
\&        print $ip\->equal(\*(Aq0x7f000001\*(Aq, Net::IP::Lite\->new(\*(Aq127.1\*(Aq)) . "\en";
\&        print $ip\->equal_v4(\*(Aq0x7f000001\*(Aq, \*(Aq::ffff:127.0.0.1\*(Aq) . "\en";
\&        print $ip\->equal_v6(\*(Aq0x7f000001\*(Aq, \*(Aq::ffff:127.0.0.1\*(Aq) . "\en";
\&
\&        print $ip\->in_range(\*(Aq127.0.0.1\*(Aq, \*(Aq127.0.0.1/8\*(Aq) . "\en";
\&        print $ip\->in_range(\*(Aq127.0.0.1\*(Aq, [
\&                \*(Aq127.0.0.1/8\*(Aq,
\&                \*(Aq10.0.0.0 255.0.0.0\*(Aq,
\&                Net::IP::Lite::Net\->new(\*(Aq10.0.0.0/8\*(Aq)
\&        ]) . "\en";
\&
\&        my $net = Net::IP::Lite::Net\->new(\*(Aq10.0.0.0/8\*(Aq) || die ...;
\&        print $net\->address() . "\en";
\&        print $net\->mask\->address() . "\en";
\&        print $net\->contains(\*(Aq10.1.1.1\*(Aq) . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is another module to manipulate \fBIPv4/IPv6\fR addresses.
In contrast of \s-1NET::IP,\s0 it does not require Math::BigInt. Also, it supports
some additional IPv4 formats like 0x7f000001, 2130706433, 017700000001,
0177.0.0.1, 0x7f.0.0.0x1.
.PP
The module provides the following capabilities:
.IP "\(bu" 4
validating \s-1IP\s0 addresses;
.IP "\(bu" 4
converting \s-1IP\s0 addresses in different format;
.IP "\(bu" 4
comparing \s-1IP\s0 addresses;
.IP "\(bu" 4
verifying whether an \s-1IP\s0 is an IPv4 or an IPv6 or an IPv4\-embedded IPv6 address;
.IP "\(bu" 4
verifying whether an \s-1IP\s0 is in a range.
.PP
Most subroutines have two implementations, so you can use procedural
or object-oriented approach.
.SH "SUPPORTED FORMATS"
.IX Header "SUPPORTED FORMATS"
You can use any IPv4 and IPv6 formats:
.IP "\(bu" 4
127.0.0.1, 127.0.1, 127.1 (IPv4 with decimal octets);
.IP "\(bu" 4
0177.0.0.1, 0177.0.1, 0177.1 (IPv4 with octal octets);
.IP "\(bu" 4
0x7f.0x0.0x0.0x1, 0x7f.0x0.0x1, 0x7f.0x1 (IPv4 with hexadecimal octets);
.IP "\(bu" 4
0177.0.0.1, 0x7f.0.1, 0177.0x1 (IPv4 with mixed octets);
.IP "\(bu" 4
2130706433 (decimal IPv4);
.IP "\(bu" 4
0x7f000001 (hexadecimal IPv4);
.IP "\(bu" 4
017700000001 (octal IPv4);
.IP "\(bu" 4
0:0:0:0:0:0:0:1, ::, ::1 (IPv6);
.IP "\(bu" 4
0:0:0:0:0:ffff:127.0.0.1, ::ffff:127.0.0.1 (IPv4\-embedded IPv6 address).
.SH "PROCEDURAL INTERFACE"
.IX Header "PROCEDURAL INTERFACE"
.SS "ip2bin"
.IX Subsection "ip2bin"
Returns a string that contains binary representation of an \s-1IP\s0 address.
Returns the empty string if an invalid \s-1IP\s0 address is specified.
.PP
.Vb 3
\&        $ip = ip2bin(\*(Aq127.0.0.1\*(Aq); # \*(Aq01111111000000000000000000000001\*(Aq
\&        $ip = ip2bin(\*(Aq::1\*(Aq);       # \*(Aq0\*(Aq x 127 . \*(Aq1\*(Aq
\&        $ip = ip2bin(\*(Aq::1:\*(Aq);      # \*(Aq\*(Aq
.Ve
.SS "ip_validate"
.IX Subsection "ip_validate"
Returns \s-1TRUE\s0 if the specified \s-1IP\s0 address is a valid, or \s-1FALSE\s0 otherwise.
.PP
.Vb 5
\&        $ok = ip_validate(\*(Aq127.0.0.1\*(Aq);     # TRUE
\&        $ok = ip_validate(\*(Aq::1\*(Aq);           # TRUE
\&        $ok = ip_validate(\*(Aq127.0.0.\*(Aq);      # FALSE
\&        $ok = ip_validate(\*(Aq127.256\*(Aq);       # FALSE
\&        $ok = ip_validate(\*(Aq::1:127.0.0.1\*(Aq); # FALSE
.Ve
.SS "ip_is_ipv4"
.IX Subsection "ip_is_ipv4"
Returns \s-1TRUE\s0 if the specified \s-1IP\s0 address is an IPv4 address, or \s-1FALSE\s0 otherwise.
.PP
.Vb 4
\&        $ok = ip_is_ipv4(\*(Aq127.0.0.1\*(Aq);        # TRUE
\&        $ok = ip_is_ipv4(\*(Aq::1\*(Aq);              # FALSE
\&        $ok = ip_is_ipv4(\*(Aq0::0:\*(Aq);            # FALSE
\&        $ok = ip_is_ipv4(\*(Aq::ffff:127.0.0.1\*(Aq); # FALSE
.Ve
.SS "ip_is_ipv6"
.IX Subsection "ip_is_ipv6"
Returns \s-1TRUE\s0 if the specified \s-1IP\s0 address is an IPv6 address, or \s-1FALSE\s0 otherwise.
.PP
.Vb 5
\&        $ok = ip_is_ipv6(\*(Aq::1\*(Aq);              # TRUE
\&        $ok = ip_is_ipv6(\*(Aq::ffff:127.0.0.1\*(Aq); # TRUE
\&        $ok = ip_is_ipv6(\*(Aq0::0:\*(Aq);            # FALSE
\&        $ok = ip_is_ipv6(\*(Aq0::0:ffff1\*(Aq);       # FALSE
\&        $ok = ip_is_ipv6(\*(Aq127.0.0.1\*(Aq);        # FALSE
.Ve
.SS "ip_is_ipv6ipv4"
.IX Subsection "ip_is_ipv6ipv4"
Returns \s-1TRUE\s0 if the specified \s-1IP\s0 address is an IPv4\-embedded IPv6 address,
or \s-1FALSE\s0 otherwise.
.PP
.Vb 4
\&        $ok = ip_is_ipv6ipv4(\*(Aq::ffff:127.0.0.1\*(Aq); # TRUE
\&        $ok = ip_is_ipv6ipv4(\*(Aq::ffff:7f00:1\*(Aq);    # TRUE
\&        $ok = ip_is_ipv6ipv4(\*(Aq::fff1:7f00:1\*(Aq);    # FALSE
\&        $ok = ip_is_ipv6ipv4(\*(Aq127.0.0.1\*(Aq);        # FALSE
.Ve
.SS "ip_transform"
.IX Subsection "ip_transform"
Converts an \s-1IP\s0 address string to another \s-1IP\s0 address string (or number).
.PP
.Vb 1
\&        $ip = ip_transform($ip, $opts);
.Ve
.PP
Where \f(CW$opts\fR is a hash that can have the following keys:
.IP "\(bu" 4
short_ipv6 => 1 (return abbreviated IPv6 address);
.IP "\(bu" 4
short_ipv4 => 1 (return abbreviated IPv4 address);
.IP "\(bu" 4
lead_zeros => 1 (add leading zeros to IPv6 address or hexadecimal IPv4 address);
.IP "\(bu" 4
reverse => 1 (return reversed \s-1IP\s0 address);
.IP "\(bu" 4
convert_to => 'ipv6' (transform IPv4 to IPv6 address);
.IP "\(bu" 4
convert_to => 'ipv4' (transform IPv6\-embedded address to IPv4);
.IP "\(bu" 4
convert_to => 'ipv6ipv4' (transform \s-1IP\s0 address to format ::ffff:xx.xx.xx.xx);
.IP "\(bu" 4
format_ipv4 => 'X' (transform IPv4 address to hexadecimal number);
.IP "\(bu" 4
format_ipv4 => 'D' (transform IPv4 address to decimal number);
.IP "\(bu" 4
format_ipv4 => 'O' (transform IPv4 address to octal number);
.IP "\(bu" 4
format_ipv4 => 'x' (transform IPv4 address to hexadecimal octet format);
.IP "\(bu" 4
format_ipv4 => 'o' (transform IPv4 address to octal number).
.PP
.Vb 3
\&        $ip = ip_transform(\*(Aq127.0.1\*(Aq);          # 127.0.0.1
\&        $ip = ip_transform(\*(Aq::1\*(Aq);              # 0:0:0:0:0:0:0:1
\&        $ip = ip_transform(\*(Aq::ffff:127.0.0.1\*(Aq); # 0:0:0:0:0:ffff:7f00:1
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                short_ipv4 => 1
\&        }); # 127.1
\&
\&        $ip = ip_transform(\*(Aq0:0::1\*(Aq, {
\&                short_ipv6 => 1
\&        }); # ::1
\&
\&        $ip = ip_transform(\*(Aq0:0::1\*(Aq, {
\&                lead_zeros => 1
\&        }); # 0000:0000:0000:0000:0000:0000:0000:0001
\&
\&        $ip = ip_transform(\*(Aq0:0::1\*(Aq, {
\&                short_ipv6 => 1,
\&                lead_zeros => 1
\&        }); # ::0001
\&
\&        $ip = ip_transform(\*(Aq0:0::1\*(Aq, {
\&                reverse => 1
\&        }); # 1:0:0:0:0:0:0:0
\&
\&        $ip = ip_transform(\*(Aq::ffff:127.0.0.1\*(Aq, {
\&                reverse => 1,
\&                short_ipv6 => 1
\&        }); # 1:7f00:ffff::
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv6\*(Aq
\&        }); # 0:0:0:0:0:ffff:7f00:1
\&
\&        $ip = ip_transform(\*(Aq::ffff:127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv6\*(Aq
\&        }); # 0:0:0:0:0:ffff:7f00:1
\&
\&        $ip = ip_transform(\*(Aq::ffff:7f00:1\*(Aq, {
\&                convert_to => \*(Aqipv4\*(Aq
\&        }); # 127.0.0.1
\&
\&        $ip = ip_transform(\*(Aq::ffff:127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv4\*(Aq
\&        }); # 127.0.0.1
\&
\&        $ip = ip_transform(\*(Aq::ffff:7f00:1\*(Aq, {
\&                convert_to => \*(Aqipv6ipv4\*(Aq
\&        }); # 0:0:0:0:0:ffff:127.0.0.1
\&
\&        $ip = ip_transform(\*(Aq::ffff:127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv6ipv4\*(Aq
\&        }); # 0:0:0:0:0:ffff:127.0.0.1
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                convert_to => \*(Aqipv6ipv4\*(Aq
\&        }); # 0:0:0:0:0:ffff:127.0.0.1
\&
\&        $ip = ip_transform(\*(Aq0.0.0.1\*(Aq, {
\&                format_ipv4 => \*(AqX\*(Aq
\&        }); # 0x1
\&
\&        $ip = ip_transform(\*(Aq0.0.0.1\*(Aq, {
\&                format_ipv4 => \*(AqX\*(Aq,
\&                lead_zeros => 1
\&        }); # 0x00000001
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(AqD\*(Aq
\&        }); # 2130706433
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(AqO\*(Aq
\&        });
\&        # 017700000001
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(Aqx\*(Aq
\&        }); # 0x7f.0x0.0x0.0x1
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(Aqx\*(Aq,
\&        short_ipv4 => 1
\&        }); # 0x7f.0x1
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(Aqx\*(Aq,
\&                lead_zeros => 1 });
\&        # 0x7f.0x00.0x00.0x01\*(Aq
\&
\&        $ip = ip_transform(\*(Aq127.0.0.1\*(Aq, {
\&                format_ipv4 => \*(Aqo\*(Aq
\&        }); # 0177.0.0.01
.Ve
.SS "ip_equal"
.IX Subsection "ip_equal"
Compares two \s-1IP\s0 addresses.
.PP
.Vb 3
\&        $eq = ip_equal(\*(Aq127.0.0.1\*(Aq, \*(Aq0x7f000001\*(Aq);       # TRUE
\&        $eq = ip_equal(\*(Aq::\*(Aq, \*(Aq0:0:0:0:0:0:0:0\*(Aq);         # TRUE
\&        $eq = ip_equal(\*(Aq::ffff:127.0.0.1\*(Aq, \*(Aq127.0.0.1\*(Aq); # FALSE
.Ve
.SS "ip_equal_v4"
.IX Subsection "ip_equal_v4"
Compares two \s-1IP\s0 addresses as IPv4 addresses.
.PP
.Vb 3
\&        $eq = ip_equal_v4(\*(Aq127.0.0.1\*(Aq, \*(Aq0x7f000001\*(Aq);       # TRUE
\&        $eq = ip_equal_v4(\*(Aq::ffff:127.0.0.1\*(Aq, \*(Aq127.0.0.1\*(Aq); # TRUE
\&        $eq = ip_equal_v4(\*(Aq::\*(Aq, \*(Aq127.0.0.1\*(Aq);               # dies
.Ve
.SS "ip_equal_v6"
.IX Subsection "ip_equal_v6"
Compares two \s-1IP\s0 addresses as IPv6 addresses.
.PP
.Vb 4
\&        $eq = ip_equal_v6(\*(Aq127.0.0.1\*(Aq, \*(Aq0x7f000001\*(Aq);       # TRUE
\&        $eq = ip_equal_v6(\*(Aq::1\*(Aq, \*(Aq0:0::1\*(Aq);                 # TRUE
\&        $eq = ip_equal_v6(\*(Aq::ffff:127.0.0.1\*(Aq, \*(Aq127.0.0.1\*(Aq); # TRUE
\&        $eq = ip_equal_v6(\*(Aq::\*(Aq, \*(Aq127.0.0.1\*(Aq);               # FALSE
.Ve
.SS "ip_in_range"
.IX Subsection "ip_in_range"
Verifies whether the specified \s-1IP\s0 address in a range.
.PP
.Vb 1
\&        $in_range = ip_in_range(\*(Aq127.0.0.1\*(Aq, $range);
.Ve
.PP
Where range can be specified in the following ways:
.IP "\(bu" 4
an \s-1IP\s0 address and a mask ('192.168.0.1 255.255.255.0');
.IP "\(bu" 4
an \s-1IP\s0 address with a prefix ('ffff:ffff:1::/48');
.IP "\(bu" 4
an \s-1IP\s0 address without mask ('129.168.0.1' (equivalent to '192.168.0.1/32'));
.IP "\(bu" 4
as an array ([ '129.168.0.0/16', '172.16.0.0/12', '10.0.0.0 255.0.0.0', '::ffff/96' ]);
.PP
.Vb 6
\&        $in = ip_in_range(\*(Aq192.168.0.1\*(Aq, \*(Aq192.168.0 255.255.255.0\*(Aq);   # TRUE
\&        $in = ip_in_range(\*(Aq10.10.10.19\*(Aq, [ \*(Aq127.1\*(Aq, \*(Aq10.0/8\*(Aq ]);       # TRUE
\&        $in = ip_in_range(\*(Aq10.10.10.19\*(Aq, \*(Aq10.10.10.8/29\*(Aq);             # FALSE
\&        $in = ip_in_range(\*(Aqa0:a0:a0:a0:1::1\*(Aq, \*(Aqa0:a0:a0:a0::/64\*(Aq);     # TRUE
\&        $in = ip_in_range(\*(Aq::ffff:10.10.10.10\*(Aq, \*(Aq::ffff:0:0/96\*(Aq);      # TRUE
\&        $in = ip_in_range(\*(Aq1:2:3::8000:40\*(Aq, \*(Aq1:2:3::8000:20/123\*(Aq);     # FALSE
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
Net::IP::Lite exports the following functions:
.IP "\(bu" 4
ip2bin
.IP "\(bu" 4
ip_validate
.IP "\(bu" 4
ip_is_ipv4
.IP "\(bu" 4
ip_is_ipv6
.IP "\(bu" 4
ip_is_ipv6ipv4
.IP "\(bu" 4
ip_transform
.IP "\(bu" 4
ip_equal
.IP "\(bu" 4
ip_equal_v4
.IP "\(bu" 4
ip_equal_v6
.IP "\(bu" 4
ip_in_range
.SH "OBJECT-ORIENTED INTERFACE"
.IX Header "OBJECT-ORIENTED INTERFACE"
When you use the object oriented approach, binary representation of \s-1IP\s0 address
is calculated once (when you create Net::SimpleIO object). Thus, if you are
going to use an \s-1IP\s0 address (or a range) more than once, you can use once
created object to reduce redundant IP-to-binary conversions.
.SS "Net::IP::Lite object"
.IX Subsection "Net::IP::Lite object"
\fIconstructor\fR
.IX Subsection "constructor"
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq10.77.0.77\*(Aq) || die \*(AqInvalid IP address\*(Aq;
\&        $ip = Net::IP::Lite\->new(\*(Aq::1\*(Aq) || die ...
.Ve
.PP
\fIaddress\fR
.IX Subsection "address"
.PP
Returns the original \s-1IP\s0 address that was specified as the constructor argument.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq10.77.77\*(Aq);
\&        print $ip\->address(); # 10.77.77
.Ve
.PP
\fIbinary\fR
.IX Subsection "binary"
.PP
Returns a string that contains binary representation of the specified \s-1IP\s0
address.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq10.77.77\*(Aq);
\&        print $ip\->binary(); # 00001010010011010000000001001101
.Ve
.PP
\fIis_ipv4\fR
.IX Subsection "is_ipv4"
.PP
Returns \s-1TRUE\s0 if the \s-1IP\s0 address is a IPv4 address, or \s-1FALSE\s0 otherwise.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq10.77.77\*(Aq);
\&        $ipv4 = $ip\->is_ipv4(); # TRUE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq::1\*(Aq);
\&        $ipv4 = $ip\->is_ipv4(); # FALSE
.Ve
.PP
See also: \*(L"ip_is_ipv4\*(R"
.PP
\fIis_ipv6\fR
.IX Subsection "is_ipv6"
.PP
Returns \s-1TRUE\s0 if the \s-1IP\s0 address is a IPv6 address, or \s-1FALSE\s0 otherwise.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq::1\*(Aq);
\&        $ipv6 = $ip\->is_ipv6(); # TRUE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq127.1\*(Aq);
\&        $ipv6 = $ip\->is_ipv6(); # FALSE
.Ve
.PP
See also: \*(L"ip_is_ipv6\*(R"
.PP
\fIis_ipv6ipv4\fR
.IX Subsection "is_ipv6ipv4"
.PP
Returns \s-1TRUE\s0 if the \s-1IP\s0 address is a IPv4\-Embedded IPv6 address, or \s-1FALSE\s0
otherwise.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq::ffff:127.0.0.1\*(Aq);
\&        $emb = $ip\->is_ipv6ipv4(); # TRUE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq::ffff:7f00:1\*(Aq);
\&        $emb = $ip\->is_ipv6ipv4(); # TRUE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq::1\*(Aq);
\&        $emb = $ip\->is_ipv6ipv4(); # FALSE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq127.1\*(Aq);
\&        $emb = $ip\->is_ipv6ipv4(); # FALSE
.Ve
.PP
See also: \*(L"ip_is_ipv6ipv4\*(R"
.PP
\fItransform\fR
.IX Subsection "transform"
.PP
Converts the \s-1IP\s0 address to an \s-1IP\s0 address string (or number).
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq0:0:0:0:0:0:0:1\*(Aq);
\&        print $ip\->transform({ short_ipv6 => 1 }); # ::1
.Ve
.PP
See \*(L"ip_transform\*(R" for all possible values of \f(CW$opts\fR.
.PP
\fIequal\fR
.IX Subsection "equal"
.PP
Compares two \s-1IP\s0 addresses.
.PP
.Vb 3
\&        $ip = Net::IP::Lite\->new(\*(Aq0:0:0:0:0:0:0:1\*(Aq);
\&        $eq = $ip\->equal(\*(Aq::1\*(Aq); # TRUE
\&        $eq = $ip\->equal(\*(Aq::2\*(Aq); # FALSE
\&
\&        $ip1 = Net::IP::Lite\->new(\*(Aq0:0:0:0:0:0:0:1\*(Aq);
\&        $ip2 = Net::IP::Lite\->new(\*(Aq::1\*(Aq);
\&        $eq = $ip\->equal($ip2); # TRUE
.Ve
.PP
See also: \*(L"ip_equal\*(R"
.PP
\fIequal_v4\fR
.IX Subsection "equal_v4"
.PP
Compares two \s-1IP\s0 addresses as IPv4 addresses.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq::ffff:127.0.0.1\*(Aq);
\&        $eq = $ip\->equal_v4(\*(Aq127.0.0.1\*(Aq); # TRUE
\&
\&        $ip1 = Net::IP::Lite\->new(\*(Aq::ffff:7f00:1\*(Aq);
\&        $ip2 = Net::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq);
\&        $eq = $ip\->equal_v4($ip2); # TRUE
\&
\&        $ip = Net::IP::Lite\->new(\*(Aq::7f00:1\*(Aq);
\&        $eq = $ip\->equal_v4(\*(Aq127.0.0.1\*(Aq); # dies
.Ve
.PP
See also: \*(L"ip_equal_v4\*(R"
.PP
\fIequal_v6\fR
.IX Subsection "equal_v6"
.PP
Compares two \s-1IP\s0 addresses as IPv6 addresses.
.PP
.Vb 2
\&        $ip = Net::IP::Lite\->new(\*(Aq::ffff:127.0.0.1\*(Aq);
\&        $eq = $ip\->equal_v6(\*(Aq127.0.0.1\*(Aq); # TRUE
\&
\&        $ip1 = Net::IP::Lite\->new(\*(Aq::ffff:7f00:1\*(Aq);
\&        $ip2 = Net::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq);
\&        $eq = $ip\->equal_v6($ip2); # TRUE
.Ve
.PP
See also: \*(L"ip_equal_v6\*(R"
.PP
\fIin_range\fR
.IX Subsection "in_range"
.PP
Verifies whether the \s-1IP\s0 in a range.
.PP
.Vb 3
\&        $ip = Net::IP::Lite\->new(\*(Aq10.10.10.10\*(Aq);
\&        $in = $ip\->in_range(\*(Aq10.10.10.8/29\*(Aq); # TRUE
\&        $in = $ip\->in_range([ \*(Aq192.168.0 255.255.255.0\*(Aq, \*(Aq10.0/8\*(Aq ]); # TRUE
.Ve
.PP
See also: \*(L"ip_in_range\*(R"
.PP
Apart from string \s-1IP\s0 addresses you specify Net::IP::Lite::Net object:
.PP
.Vb 3
\&        $ip  = Net::IP::Lite\->new(\*(Aq10.10.10.10\*(Aq);
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.0/8\*(Aq) || die ...;
\&        $in = $ip\->in_range($net); # TRUE
\&
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1::/16\*(Aq) || die ...;
\&        $in = $ip\->in_range($net);               # FALSE
\&        $in = $ip\->in_range([ $net, \*(Aq10.0/8\*(Aq ]); # TRUE
.Ve
.PP
See also: \*(L"Net::IP::Lite::Net object\*(R"
.SS "Net::IP::Lite::Net object"
.IX Subsection "Net::IP::Lite::Net object"
\fIconstructor\fR
.IX Subsection "constructor"
.PP
The Net::IP::Lite::Net class is a descendant of Net::IP::Lite.
.PP
.Vb 4
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.0/8\*(Aq) || die ...;
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.0.0.8 255.255.255.248\*(Aq) || die ...;
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1::/16\*(Aq) || die ...;
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1:: ffff::\*(Aq) || die ...;
.Ve
.PP
Please note: Net::IP::Lite::Net allows you to create an network (without
possible hosts).
.PP
For example:
.PP
.Vb 1
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.10.10.8/28\*(Aq);
.Ve
.PP
You can use the <\*(L"contains\*(R" method to check whether there are any possible
hosts or not.
.PP
All Net:IP::Lite methods return the same values as if you created
Net::IP::Lite object without a mask.
.PP
.Vb 2
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1:: ffff::\*(Aq) || die ...;
\&        print $net\->address; # 1::
.Ve
.PP
See also: \*(L"Net::IP::Lite object\*(R"
.PP
\fImask\fR
.IX Subsection "mask"
.PP
Returns Net::IP::Lite instance for the network mask;
.PP
.Vb 2
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1:: ffff::\*(Aq) || die ...;
\&        print $net\->mask\->address(); # ffff::
\&
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1::/32\*(Aq) || die ...;
\&        print $net\->mask\->address(); # ffff:ffff:0:0:0:0:0:0
\&
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.0/8\*(Aq) || die ...;
\&        print $net\->mask\->binary(); # 11111111000000000000000000000000
.Ve
.PP
\fInetwork\fR
.IX Subsection "network"
.PP
Returns the original network definition that was specified as the constructor
argument.
.PP
.Vb 2
\&        my $net = Net::IP::Lite::Net\->new(\*(Aq1::/32\*(Aq) || die ...;
\&        print $net\->network(); # 1::/32
.Ve
.PP
\fIcontains\fR
.IX Subsection "contains"
.PP
Verifies whether an \s-1IP\s0 in the net.
.PP
.Vb 2
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1:: ffff::\*(Aq) || die ...;
\&        $in = $net\->contains(\*(Aq1:ff::1\*(Aq); # TRUE
.Ve
.PP
Also you can pass an Net::IP::Lite object:
.PP
.Vb 3
\&        $ip = Net::IP::Lite::Net\->new(\*(Aq1::1\*(Aq) || die ...;
\&        $net = Net::IP::Lite::Net\->new(\*(Aq1::/32\*(Aq) || die ...;
\&        my $in = $net\->contains($ip); # TRUE
.Ve
.PP
This method also can be used to check whether there are possible hosts
in the network or not:
.PP
.Vb 2
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.10.10.8/28\*(Aq);
\&        $ok = $net\->contains($net); # FALSE
\&
\&        $net = Net::IP::Lite::Net\->new(\*(Aq10.10.10.8/29\*(Aq);
\&        $ok = $net\->contains($net); # TRUE
.Ve
.PP
See also: \*(L"ip_in_range\*(R", \*(L"Net::IP::Lite object\*(R"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1NET::IP\s0, NetAddr::IP, NetAddr::IP::Lite
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&        perldoc Net::IP::Lite
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
Code Repository at GitHub
.Sp
<http://github.com/alexey\-komarov/Net\-IP\-Lite>
.IP "\(bu" 4
GitHub Issue Tracker
.Sp
<http://github.com/alexey\-komarov/Net\-IP\-Lite/issues>
.IP "\(bu" 4
\&\s-1RT, CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Net\-IP\-Lite>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alexey A. Komarov <alexkom@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2013 Alexey A. Komarov
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
