.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::DBus::ProxyObject 3"
.TH Net::DBus::ProxyObject 3 "2019-12-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DBus::ProxyObject \- Implement objects to export to the bus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Connecting an object to the bus, under a service
\&  package main;
\&
\&  use Net::DBus;
\&
\&  # Attach to the bus
\&  my $bus = Net::DBus\->find;
\&
\&  # Create our application\*(Aqs object instance
\&  my $object = Demo::HelloWorld\->new()
\&
\&  # Acquire a service \*(Aqorg.demo.Hello\*(Aq
\&  my $service = $bus\->export_service("org.demo.Hello");
\&
\&  # Finally export the object to the bus
\&  my $proxy = Demo::HelloWorld::DBus\->new($object);
\&
\&  ....rest of program...
\&
\&
\&  # Define a new package for the object we\*(Aqre going
\&  # to export
\&  package Demo::HelloWorld;
\&
\&  sub new {
\&      my $class = shift;
\&      my $service = shift;
\&      my $self = {};
\&
\&      $self\->{sighandler} = undef;
\&
\&      bless $self, $class;
\&
\&      return $self;
\&  }
\&
\&  sub sighandler {
\&      my $self = shift;
\&      my $callback = shift;
\&
\&      $self\->[sighandler} = $callback;
\&  }
\&
\&  sub Hello {
\&    my $self = shift;
\&    my $name = shift;
\&
\&    &{$self\->{sighandler}}("Greeting", "Hello $name");
\&    return "Said hello to $name";
\&  }
\&
\&  sub Goodbye {
\&    my $self = shift;
\&    my $name = shift;
\&
\&    &{$self\->{sighandler}}("Greeting", "Goodbye $name");
\&    return "Said goodbye to $name";
\&  }
\&
\&
\&  # Define a new package for the object we\*(Aqre going
\&  # to export
\&  package Demo::HelloWorld::DBus;
\&
\&  # Specify the main interface provided by our object
\&  use Net::DBus::Exporter qw(org.example.demo.Greeter);
\&
\&  # We\*(Aqre going to be a DBus object
\&  use base qw(Net::DBus::ProxyObject);
\&
\&  # Export a \*(AqGreeting\*(Aq signal taking a stringl string parameter
\&  dbus_signal("Greeting", ["string"]);
\&
\&  # Export \*(AqHello\*(Aq as a method accepting a single string
\&  # parameter, and returning a single string value
\&  dbus_method("Hello", ["string"], ["string"]);
\&
\&  sub new {
\&      my $class = shift;
\&      my $service = shift;
\&      my $impl = shfit;
\&      my $self = $class\->SUPER::new($service, "/org/demo/HelloWorld", $impl);
\&
\&      bless $self, $class;
\&
\&      $self\->sighandler(sub {
\&          my $signame = shift;
\&          my $arg = shift;
\&          $self\->emit_signal($signame, $arg);
\&      });
\&
\&      return $self;
\&  }
\&
\&  # Export \*(AqGoodbye\*(Aq as a method accepting a single string
\&  # parameter, and returning a single string, but put it
\&  # in the \*(Aqorg.exaple.demo.Farewell\*(Aq interface
\&
\&  dbus_method("Goodbye", ["string"], ["string"], "org.example.demo.Farewell");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This the base for creating a proxy between a bus object and an
application's object. It allows the application's object model
to remain separate from the \s-1RPC\s0 object model. The proxy object
will forward method calls from the bus, to the implementation
object. The proxy object can also register callbacks against
the application object, which it can use to then emit signals
on the bus.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $object = Net::DBus::ProxyObject\->new($service, $path, $impl)" 4
.el .IP "my \f(CW$object\fR = Net::DBus::ProxyObject\->new($service, \f(CW$path\fR, \f(CW$impl\fR)" 4
.IX Item "my $object = Net::DBus::ProxyObject->new($service, $path, $impl)"
This creates a new DBus object with an path of \f(CW$path\fR
registered within the service \f(CW$service\fR. The \f(CW$path\fR
parameter should be a string complying with the usual
DBus requirements for object paths, while the \f(CW$service\fR
parameter should be an instance of Net::DBus::Service.
The latter is typically obtained by calling the \f(CW\*(C`export_service\*(C'\fR
method on the Net::DBus object. The \f(CW$impl\fR parameter is
the application object which will implement the methods being
exported to the bus.
.ie n .IP "my $object = Net::DBus::ProxyObject\->new($parentobj, $subpath, $impl)" 4
.el .IP "my \f(CW$object\fR = Net::DBus::ProxyObject\->new($parentobj, \f(CW$subpath\fR, \f(CW$impl\fR)" 4
.IX Item "my $object = Net::DBus::ProxyObject->new($parentobj, $subpath, $impl)"
This creates a new DBus child object with an path of \f(CW$subpath\fR
relative to its parent \f(CW$parentobj\fR. The \f(CW$subpath\fR
parameter should be a string complying with the usual
DBus requirements for object paths, while the \f(CW$parentobj\fR
parameter should be an instance of Net::DBus::BaseObject or
a subclass. The \f(CW$impl\fR parameter is the application object
which will implement the methods being exported to the bus.
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel P. Berrange
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005\-2011 Daniel P. Berrange
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus, Net::DBus::Service, Net::DBus::BaseObject,
Net::DBus::ProxyObject, Net::DBus::Exporter,
Net::DBus::RemoteObject
