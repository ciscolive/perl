.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "P 3"
.TH P 3 "2019-10-31" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME P  \-   Safer, friendlier printf/print/sprintf + say"
.IX Header "NAME P - Safer, friendlier printf/print/sprintf + say"
.SH "VERSION"
.IX Header "VERSION"
Version  \*(L"1.1.41\*(R"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use P qw[:depth=5 :undef="(undef)"];
\&
\&  P FILEHANDLE FORMAT, LIST
\&  P FILEHANDLE, LIST         # comma is not disallowed
\&  P FORMAT, (LIST)
\&  P (LIST)
\&  P @ARRAY                   # may contain File Handle, Format and ARGS
\&                                   # all in 1 array.
\&  $s = P @ARRAY; P $s;       # can be same output as "P @ARRAY" 
\&  Pe                         # same as P STDERR,...
\&  $s = P FILEHANDLE ...      # sends same output to $s and FILEHANDLE
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`P\*(C'\fR is a combined print, printf, sprintf & say in 1 routine.  It saves
tremendously on development time.  It's not just a 1 character 'verb', 
but has other time-saving and powerful features.  It has the convenience
of \f(CW\*(C`say\*(C'\fR in adding a newline when needed but also allows specifying
a File Handle and format statement.
\&\f(CW\*(C`P\*(C'\fR accepts a filehandle with or without a comma after the filehandle.
.IP "o \fBNo more switching between print, printf, sprintf, and say.\fR" 4
.IX Item "o No more switching between print, printf, sprintf, and say."
.PP
A fixed string can be changed to formatted output with no change of
verb:
.PP
.Vb 7
\& Example: 
\&     # Starting with a "die" statement.
\&  1) die "Wrong number of params";
\&    # Then number of arguments passed is added:
\&  2) die P "Expecting 2 params, got %s", scalar @ARGV;
\&    # Then contents of @ARGV can be printed as well (no loop needed):
\&  3) die P "Expecting 2 params, got %s (ARGV=%s), 0+@ARGV, \e@ARGV;
.Ve
.PP
\&\f(CW\*(C`P\*(C'\fR can replacing \f(CW\*(C`sprintf\*(C'\fR without the need for a temporary
variable and without printing cryptic representations for \f(CW@ARGV\fR,
like "\f(CW\*(C`ARRAY(0x5A2B3C66)\*(C'\fR".  Instead,
\&\f(CW\*(C`P\*(C'\fR displays the actual contents of the array, showing
[\*(L"arg1\*(R", \*(L"arg2\*(R"].
.IP "\fB· Auto-Newline Handling\fR" 4
.IX Item "· Auto-Newline Handling"
.PP
When it comes to \f(CW\*(C`newline\*(C'\fR's, or \*(L"\en\*(R" at the end of line, \f(CW\*(C`P\*(C'\fR 
attempts to look at context.  If output is assigned to a variable,
then \f(CW\*(C`P\*(C'\fR acts like \f(CW\*(C`sprintf\*(C'\fR.  If it is to a file handle, then
it will act like \f(CW\*(C`say\*(C'\fR and automatically append a \f(CW\*(C`newline\*(C'\fR.
Unlike \f(CW\*(C`say\*(C'\fR, \f(CW\*(C`P\*(C'\fR can use formatted output and print to a file
handle.  Printing to \s-1STDERR\s0 is simplified with the \f(CW\*(C`Pe\*(C'\fR form of
\&\f(CW\*(C`P\*(C'\fR, which is a short form of 'P \s-1STDERR, \*(L"...\*(R"\s0'.
.PP
When \f(CW\*(C`P\*(C'\fR prints to strings, any one newline at the end of the 
string will be suppressed.  Conversely it will add one if
printing to a device.  If printing to a string and a device
at the same time, it will favor suppression and not output
a newline to the device.
.ie n .IP "\fB· Trapping \f(CB""undef""\fB\fR" 4
.el .IP "\fB· Trapping \f(CBundef\fB\fR" 4
.IX Item "· Trapping undef"
.PP
Rather than aborting output when \f(CW\*(C`undef\*(C'\fR is part of the output, 
\&\f(CW\*(C`P\*(C'\fR prints a configurable symbol, '∄', by default, the symbol
for \*(L"does not exist\*(R" where the undef would have printed and the 
rest of the string is printed normally.
.IP "\fB· Less restrictive syntax\fR" 4
.IX Item "· Less restrictive syntax"
.PP
\&\f(CW\*(C`P\*(C'\fR tries not to have arbitrary restrictions on it's arguments.
.PP
It handles cases that the equivalent perl statement won't.
.PP
.Vb 12
\&              VERB \->           P    print   printf  sprintf   say
\&          V \-\-FEATURE\-\- V      \-\-\-   \-\-\-\-\-   \-\-\-\-\-\-  \-\-\-\-\-\-\-   \-\-\-
\&      1) to a FH               Yes    Yes     Yes       No     Yes
\&      2) to $fh                Yes    Yes     Yes       No      No
\&      3) to a string           Yes     No      No      Yes      No 
\&      4) add EOL\-NL to FH?     Yes     No      No       No     Yes
\&      5) sub EOL\-NL in string  Yes     No      No       No      No
\&      6) FMT                   Yes     No     Yes      Yes      No
\&      7) @[FMT,ARGS]           Yes     No     Yes       No      No
\&      8) undef to "%s"         Yes     No      No       No      No
\&      9) @[$fh,FMT,ARGS]       Yes     No      No       No      No
\&     10) like "tee"            Yes     No      No       No      No
\&
\&   (9) \- File Handle in 1st member of ARRAY used for output.
\&
\&  (10) \- When P is being used as a string formatter like sprintf,
\&         it can still have a "$fh" as the first argument that will 
\&         print the formatted string to the file handle as well as 
\&         returning it\*(Aqs value (note: this will force the string
\&         to be printed w/o a trailing newline).
.Ve
.PP
\fIUndefs\fR
.IX Subsection "Undefs"
.PP
When printed as strings (\f(CW"%s"\fR), undefs are automatically caught and 
\&\*(L"∄\*(R", (U+2204 \- meaning "\fIThere does not exist\fR\*(L") is
printed in place of \*(R"\f(CW\*(C`Use of uninitialized value $x in xxx at \-e line z.\*(C'\fR"
.PP
By default \f(CW\*(C`P\*(C'\fR, prints the content of references (instead \s-1HASH\s0 
(or \s-1ARRAY\s0)=(0x12345678).  By default, it prints three levels deep with
deeper nesting replaced by by the unicode ellipsis character (U+2026).
.PP
While designed for development use, it is useful in many more situations, as 
tries to \*(L"do the right thing\*(R" based on context.  It can usually be used
as a drop-in replacement the perl functions \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR,
and, \f(CW\*(C`say\*(C'\fR.
.PP
P tries to smartly handle newlines at the end of the line \*(-- adding them 
or subtracting them based on if they are going to a file handle or to another
variable.
.PP
The newline handling at the end of a line can be supressed by adding
the Unicode control char \*(L"Don't break here\*(R" (0x83) at the end of a string
or by assigning the return value \fBand\fR having a file handle as the first
argument.  Ex: \f(CW\*(C`my $fmt = P STDOUT, "no LF added here\-\->"\*(C'\fR.
.PP
\&\f(CW\*(C`Bless\*(C'\fRed objects, by default, are printed with the class or package name
in front of the reference. Note that these substitutions are performed only with 
references printed through a string (\f(CW"%s"\fR) format \*(-- features designed
to give useful output in development or debug situations.
.PP
One difference between \f(CW\*(C`P\*(C'\fR and \f(CW\*(C`sprintf\*(C'\fR: \f(CW\*(C`P\*(C'\fR can take 
an array with the format in the 0th element, and parameters following.  
\&\f(CW\*(C`Sprintf\*(C'\fR will cause an error to be raised, if you try passing an array
to it, as it will force the array into scalar context \*(-- which as 
the manpage says \*(L"is almost never useful\*(R", and the perl-developers
admit \*(L"is never useful\*(R".  Rather than follow in the
design flaws of its predecessors, P \fItries\fR to do the right thing.
.PP
\&\fB\s-1NOTE:\s0\fR A side effect of P being a contextual replacement for sprintf,
is if it is used as the last line of a subroutine.  By default, this
won't print it's arguments to \s-1STDOUT\s0 unless you explicity specify the
filehandle, as it will think it is supposed to return the result \*(-- not
print it.  An alternate workaround \*(-- return another value, like a
status value.  \s-1OR\s0 use it as a feature.  A subroutine that has 
a \f(CW\*(C`P\-statment\*(C'\fR at the end can be used in string construction or
can be used for direct output.
.SH "EXAMPLE: Duel-Use Subroutines for Strings or Printing"
.IX Header "EXAMPLE: Duel-Use Subroutines for Strings or Printing"
.Vb 4
\&   sub items_in_list() {
\&            my $numitems = get_num();
\&                        P "num items=%s", $numitems;
\&   }   # can be used:
\&
\&         my $s=items_in_list();
\&         # or
\&         $items_in_list();      # prints to STDOUT w/newline on end
.Ve
.SS "Special Use Features"
.IX Subsection "Special Use Features"
While \f(CW\*(C`P\*(C'\fR is normally called procedurally, and not as an object, there are 
some rare cases where one would really like it to print \*(L"just 1 level
deeper\*(R".  To do that, you need to get a pointer to \f(CW\*(C`P\*(C'\fR's \f(CW\*(C`options\*(C'\fR.
.PP
To get that pointer, call \f(CW\*(C`P::\->ops({key=\*(C'\fRvalue})> to set \f(CW\*(C`P\*(C'\fR's options and
save the return value.  Use that pointer to call P.  See following example.
.SH "EXAMPLE: (changing P's defaults)"
.IX Header "EXAMPLE: (changing P's defaults)"
Suppose you had an array of objects, and you wanted to see the contents
of the objects in the array.  Normally P would only print the first two levels:
.PP
.Vb 6
\&  my %complex_probs = (                                
\&      questions =E<gt> [ "sqrt(\-4)",  "(1\-i)**2"     ],
\&      answers   =E<gt> [ {real => 0, i =>2 }, 
\&                     {real => 0, i => \-2 } ] );
\&  my $prob_ref = \e%complex_problems;
\&  P "my probs = %s", [$prob_ref];
.Ve
.PP
The above would normally produce:
.PP
.Vb 1
\&  my probs = [{answers=>[{…}, {…}], questions=>["sqrt(\-4)", "(1\-i)**2"]}]
.Ve
.PP
Instead of the contents of the hashes, P shows the ellipses (a
1 char-width wide character) for the interior of the hashes.  If you
wanted the interior to print, you'd need to raise the default data
expansion \fIdepth\fR for \f(CW\*(C`P\*(C'\fR as we do here:
.PP
.Vb 5
\&  my %complex_probs = (                                     
\&      questions => [ "sqrt(\-4)",          "(1\-i)**2"     ],
\&      answers   => [ {real => 0, i =>2 }, { real => 0, i => \-2 } ] );
\&  my $p=P::\->ops({depth=>4});                                
\&  $p\->P("my array = %s", \e%complex_probs);
.Ve
.PP
The above allows 1 extra level of depth to be printed, so the elements in the
hash are displayed producing:
.PP
.Vb 2
\&  my probs = [{answers=>[{i=>2, real=>0}, {i=>\-2, real=>0}],  # extra "\en" 
\&               questions=>["sqrt(\-4)", "(1\-i)**2"]}]
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR  when referring to the \fBpackage\fR \fB\f(CB\*(C`P\*(C'\fB\fR, a double colon is usually
needed to tell perl you are not talking about the function name.
.PP
Please don't expect data printed by P to be \*(L"pretty\*(R" or parseable.  It's not
meant to be a Perl::Tidy or Data::Dumper.  \fIEspecially\fR, when printing
references, it was designed as a development aid.
.ie n .SS "Summary of possible \s-1OO\s0 args to ""ops"" (and defaults)"
.el .SS "Summary of possible \s-1OO\s0 args to ``ops'' (and defaults)"
.IX Subsection "Summary of possible OO args to ops (and defaults)"
.ie n .IP """depth => 3""" 4
.el .IP "\f(CWdepth => 3\fR" 4
.IX Item "depth => 3"
.RS 4
.RS 4
Allows setting depth of nested structure printing.  \s-1NOTE:\s0 regardless of depth,
recursive structures in the same call to \f(CW\*(C`P\*(C'\fR, will not expand but be displayed
in an abbreviated form.
.RE
.RE
.RS 4
.RE
.ie n .IP """implicit_io => 0""" 4
.el .IP "\f(CWimplicit_io => 0\fR" 4
.IX Item "implicit_io => 0"
.RS 4
.RS 4
When printing references, \s-1GLOBS\s0 and \s-1IO\s0 refs do not have their
contents printed (since printing contents of such refs may do I/O that 
changes the object's state).  If this is wanted, one would call \f(CW\*(C`ops\*(C'\fR with \f(CW\*(C`implicit_io\*(C'\fR set to true (1).
.RE
.RE
.RS 4
.RE
.ie n .IP """noquote => 1""" 4
.el .IP "\f(CWnoquote => 1\fR" 4
.IX Item "noquote => 1"
.RS 4
.RS 4
In printing items in hashes or arrays, data that are Read-Only or do not need
quoting won't have quoting (contrast to Data::Dumper, where it can be turned
off or on, but not turned on, only when needed).
.RE
.RE
.RS 4
.RE
.ie n .IP """maxstring => undef""" 4
.el .IP "\f(CWmaxstring => undef\fR" 4
.IX Item "maxstring => undef"
.RS 4
.RS 2
Allows specifying a maximum length of any single datum when expanded from an indirection expansion.
.RE
.RE
.RS 4
.RE
.ie n .SS "Example 2: Not worrying about ""undefs"""
.el .SS "Example 2: Not worrying about ``undefs''"
.IX Subsection "Example 2: Not worrying about undefs"
Looking at some old code of mine, I found this:
.PP
.Vb 5
\&  print sprintf STDERR,
\&    "Error: in parsing (%s), proto=%s, host=%s, page=%s\en",
\&    $_[0] // "null", $proto // "null", $host // "null",
\&    $path // "null";
\&  die "Exiting due to error."
.Ve
.PP
Too many words and effort in upgrading a die message! Now it looks like:
.PP
.Vb 2
\&  die P "Error: in parsing (%s), proto=%s, host=%s, page=%s",
\&          $_[0], $proto, $host, $path;
.Ve
.PP
It's not just about formatting or replacing sprintf \*(-- but automatically
giving you sanity in places like error messages and debug output when
the variables you are printing may be 'undef' \*(-- which would abort the
output entirely!
.SH "MORE EXAMPLES"
.IX Header "MORE EXAMPLES"
.Vb 4
\& P "Hello %s", "World";            # auto NL when to a FH
\& P "Hello \ex83"; P "World";        # \ex83: suppress auto\-NL to FH\*(Aqs 
\& $s = P "%s", "Hello %s";          # not needed if printing to string 
\& P $s, "World";                    # still prints "Hello World" 
\&
\& @a = ("Hello %s", "World");       # using array, fmt as 1st arg 
\& P @a;                             # print "Hello World"
\& P 0 + @a;                         # prints #items in \*(Aq@a\*(Aq: 2
\&
\& P "a=%s", \e@a;                    # prints contents of \*(Aqa\*(Aq: [1,2,3...]
\&
\& P STDERR @a                       # use @a as args to a specific FH
\&                                   # Uses indirect method calls when
\&                                   # invoked like "print FH ARGS"
\&                                   #
\& Pe  "Output to STDERR"            # \*(AqShortcut\*(Aq for P to STDERR
\&
\& %H=(one=>1, two=>2, u=>undef);    # P Hash bucket usage + contents:
\&
\& P "%H hash usage: %s", "".%H;     # Shows used/total Hash bucket usage
\& P "%H=%s", \e%H;                   # print contents of hash:
\&
\&   %H={u=>(undef), one=>1, two=>2}
\&
\& bless my $h=\e%H, \*(AqHclass\*(Aq;        # Blessed objects...
\& P "Obj_h = %s", $h;               #   & content:
\&
\&   Obj_h = Hclass{u=>(undef), one=>1, two=>2}
.Ve
.SH "Sample Code + Test + Demo"
.IX Header "Sample Code + Test + Demo"
To demonstrate the various usages of P, several examples are embedded
with this documenation in a special \f(CW\*(C`DATA\*(C'\fR section.  If this module
is executed as with \f(CW\*(C`perl P.pm\*(C'\fR or just \f(CW\*(C`P.pm\*(C'\fR if the module is
set to be executable, it will run a short program that shows
different features of P as well as doing a short run-time test 
(that is actually part of the test suite).
.PP
The demo/example/test code embedded in this module is \s-1NOT\s0 compiled or
accessed when it is \f(CW\*(C`use\*(C'\fRed in code.
.PP
As of this writing there are 13 examples.  The output of these 
examples follows:
.Sp
.Vb 10
\&   #1  (ret from func)          : Hello Perl 1
\&   #2  (w/string)               : Hello Perl 2
\&   #3  (passed array)           : Hello Perl 3
\&   #4  (w/fmt+string)           : Hello Perl 4
\&   #5  (to STDERR)              : Hello Perl 5
\&   #6  (to strng embedded in #7): 
\&   #7  (prev string)            : prev str="Hello Perl 6" (no LF) && Hello Perl 7
\&   #8  (P && array ref)         : ["one", "two", "three", 4, 5, 6]
\&   #9  (P HASH ref)             : {a=>"apple", b=>"bread", c=>"cherry"}
\&   #10 (P Pkg ref)              : Pkg{a=>1, b=>2, x=>\*(Aqy\*(Aq}
\&   #11 (P @{[FH,["fmt:%s",…]]}) : fmt:Hello Perl 11
\&   #12 (truncate embedded float): norm=3.14159265358979324, embed={pi=>3.14}
\&   #13 (test mixed digit string): embed roman pi = ["3.ⅰⅳⅰⅴⅸ"]
.Ve
.PP
The code uses a function \f(CW\*(C`iter\*(C'\fR that prints \fIHello Perl\fR followed by
an autoincrementing counter that also is used as the test or example
number.
.PP
Putting the format + its arguments in an array is simple and does not
change if P is printing to output or to a string (cf. sprintf/printf).
P goes further than allowing the format specification in an array \*(-- it
also allows putting the file handle as the 1st element in the array as
shown in #11.
.PP
P is not picky about how file handles can be used \*(-- they can be
followed by a space or by a comma.  No special syntax is needed for the
arguments of P, it can follow the example of printf or the standard
usage of using commas to separate arguments.
.SH "NOTES"
.IX Header "NOTES"
Values given as args with a format statement, are checked for \fBundef\fR
and have \*(L"∄\*(R" substituted for undefined values.  If you print
vars as in decimal or floating point, they'll likely show up as 0, which
doesn't stand out as well.
.PP
Sometimes the perl parser gets confused about what args belong to P and
which do not.  Using parentheses (\fIex.\fR \f(CW\*(C`P("Hello World")\*(C'\fR) can help
in those cases.
.PP
Usable in any code, P was was designed to save typing, time and work of
undef checking, newline handling, peeking at data structures in small
spaces during development.  It tries to do the \*(L"right thing\*(R" with the
given input. It may not be suitable where speed is paramount.
