.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DNS::Unbound 3"
.TH DNS::Unbound 3 "2020-08-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DNS::Unbound \- libunbound in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $dns = DNS::Unbound\->new()\->set_option( verbosity => 2 );
\&
\&    # This appears to be safe:
\&    $dns\->enable_threads();
\&
\&    my $verbosity = $dns\->get_option( \*(Aqverbosity\*(Aq );
\&
\&    $dns\->set_option( verbosity => 1 + $verbosity );
.Ve
.PP
Synchronous queries:
.PP
.Vb 1
\&    my $res_hr = $dns\->resolve( \*(Aqcpan.org\*(Aq, \*(AqNS\*(Aq );
\&
\&    # See below about encodings in “data”.
\&    my @ns = map { $dns\->decode_name($_) } @{ $res_hr\->data() };
.Ve
.PP
Asynchronous queries use the “Promise” pattern <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>:
.PP
.Vb 4
\&    my $query1 = $dns\->resolve_async( \*(Aqusa.gov\*(Aq, \*(AqA\*(Aq )\->then(
\&        sub { my $data = shift()\->data(); ... },  # success handler
\&        sub { ... },                              # failure handler
\&    );
\&
\&    my $query2 = $dns\->resolve_async( \*(Aqin\-addr.arpa\*(Aq, \*(AqNS\*(Aq )\->then(
\&        sub { ... },
\&        sub { ... },
\&    );
\&
\&    # As an alternative to wait(), see below for documentation on
\&    # the fd(), poll(), and process() methods.
\&
\&    $dns\->wait();
.Ve
.PP
See \fIexamples/\fR in the distribution for demonstrations of
making this module interface with AnyEvent or IO::Async.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library is a Perl interface to NLNetLabs’s widely-used
Unbound <https://nlnetlabs.nl/projects/unbound/> recursive \s-1DNS\s0 resolver.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fI\s-1CLASS\s0\fP\->\fBnew()\fP"
.IX Subsection "CLASS->new()"
Instantiates this class.
.ie n .SS "$result_hr = \fI\s-1OBJ\s0\fP\->resolve( $NAME, $TYPE [, $CLASS ] )"
.el .SS "\f(CW$result_hr\fP = \fI\s-1OBJ\s0\fP\->resolve( \f(CW$NAME\fP, \f(CW$TYPE\fP [, \f(CW$CLASS\fP ] )"
.IX Subsection "$result_hr = OBJ->resolve( $NAME, $TYPE [, $CLASS ] )"
Runs a synchronous query for a given \f(CW$NAME\fR and \f(CW$TYPE\fR. \f(CW$TYPE\fR may be
expressed numerically or, for convenience, as a string. \f(CW$CLASS\fR is
optional and defaults to 1 (\f(CW\*(C`IN\*(C'\fR), which is probably what you want.
.PP
Returns a DNS::Unbound::Result instance.
.PP
\&\fB\s-1NOTE:\s0\fR libunbound doesn’t seem to offer effective controls for
timing out a synchronous query.
If timeouts are relevant for you, you probably need
to use \f(CW\*(C`resolve_async()\*(C'\fR instead.
.ie n .SS "$query = \fI\s-1OBJ\s0\fP\->resolve_async( $NAME, $TYPE [, $CLASS ] );"
.el .SS "\f(CW$query\fP = \fI\s-1OBJ\s0\fP\->resolve_async( \f(CW$NAME\fP, \f(CW$TYPE\fP [, \f(CW$CLASS\fP ] );"
.IX Subsection "$query = OBJ->resolve_async( $NAME, $TYPE [, $CLASS ] );"
Like \f(CW\*(C`resolve()\*(C'\fR but starts an asynchronous query rather than a
synchronous one.
.PP
This returns an instance of DNS::Unbound::AsyncQuery (a subclass
thereof, to be precise).
.PP
See below for
the methods you’ll need to use in tandem with this one.
.SS "\fI\s-1OBJ\s0\fP\->\fBenable_threads()\fP"
.IX Subsection "OBJ->enable_threads()"
Sets \fI\s-1OBJ\s0\fR’s asynchronous queries to use threads rather than forking.
Off by default. Throws an exception if called after an asynchronous query has
already been sent.
.PP
Returns \fI\s-1OBJ\s0\fR.
.PP
\&\fB\s-1NOTE:\s0\fR Despite Perl’s iffy relationship with threads, this appears
to work without issue.
.ie n .SS "\fI\s-1OBJ\s0\fP\->set_option( $NAME => $VALUE )"
.el .SS "\fI\s-1OBJ\s0\fP\->set_option( \f(CW$NAME\fP => \f(CW$VALUE\fP )"
.IX Subsection "OBJ->set_option( $NAME => $VALUE )"
Sets a configuration option. Returns \fI\s-1OBJ\s0\fR.
.PP
Note that this is basically just a passthrough to the underlying
\&\f(CW\*(C`ub_ctx_set_option()\*(C'\fR function and is thus subject to the same limitations
as that function; for example, you can’t set \f(CW\*(C`verbosity\*(C'\fR after the
configuration has been “finalized”. (So use \f(CW\*(C`debuglevel()\*(C'\fR for that
instead.)
.ie n .SS "$value = \fI\s-1OBJ\s0\fP\->get_option( $NAME )"
.el .SS "\f(CW$value\fP = \fI\s-1OBJ\s0\fP\->get_option( \f(CW$NAME\fP )"
.IX Subsection "$value = OBJ->get_option( $NAME )"
Gets a configuration option’s value.
.ie n .SS "\fI\s-1OBJ\s0\fP\->debuglevel( $LEVEL )"
.el .SS "\fI\s-1OBJ\s0\fP\->debuglevel( \f(CW$LEVEL\fP )"
.IX Subsection "OBJ->debuglevel( $LEVEL )"
Sets the debug level (an integer). Returns \fI\s-1OBJ\s0\fR.
.PP
As of libunbound v1.9.2, this is just a way to set the \f(CW\*(C`verbosity\*(C'\fR
option regardless of whether the configuration is finalized.
.ie n .SS "\fI\s-1OBJ\s0\fP\->debugout( $FD_OR_FH )"
.el .SS "\fI\s-1OBJ\s0\fP\->debugout( \f(CW$FD_OR_FH\fP )"
.IX Subsection "OBJ->debugout( $FD_OR_FH )"
Accepts a file descriptor or Perl filehandle and designates that
as the destination for libunbound diagnostic information.
.PP
Returns \fI\s-1OBJ\s0\fR.
.ie n .SS "$str = \fI\s-1CLASS\s0\fP\->\fBunbound_version()\fP"
.el .SS "\f(CW$str\fP = \fI\s-1CLASS\s0\fP\->\fBunbound_version()\fP"
.IX Subsection "$str = CLASS->unbound_version()"
Gives the libunbound version string.
.SH "METHODS FOR ALTERING RESOLVER LOGIC"
.IX Header "METHODS FOR ALTERING RESOLVER LOGIC"
The following parallel their equivalents in libunbound.
They return \fI\s-1OBJ\s0\fR and throw errors on failure.
.ie n .SS "\fI\s-1OBJ\s0\fP\->hosts( $FILENAME )"
.el .SS "\fI\s-1OBJ\s0\fP\->hosts( \f(CW$FILENAME\fP )"
.IX Subsection "OBJ->hosts( $FILENAME )"

.ie n .SS "\fI\s-1OBJ\s0\fP\->resolveconf( $FILENAME )"
.el .SS "\fI\s-1OBJ\s0\fP\->resolveconf( \f(CW$FILENAME\fP )"
.IX Subsection "OBJ->resolveconf( $FILENAME )"

.SH "METHODS FOR DEALING WITH ASYNCHRONOUS QUERIES"
.IX Header "METHODS FOR DEALING WITH ASYNCHRONOUS QUERIES"
Unless otherwise noted, the following methods correspond to their
equivalents in libunbound. They return the same values as the
libunbound equivalents.
.SS "\fI\s-1OBJ\s0\fP\->\fBpoll()\fP"
.IX Subsection "OBJ->poll()"

.SS "\fI\s-1OBJ\s0\fP\->\fBfd()\fP"
.IX Subsection "OBJ->fd()"

.SS "\fI\s-1OBJ\s0\fP\->\fBwait()\fP"
.IX Subsection "OBJ->wait()"

.SS "\fI\s-1OBJ\s0\fP\->\fBprocess()\fP"
.IX Subsection "OBJ->process()"

.SS "\fI\s-1OBJ\s0\fP\->\fBcount_pending_queries()\fP"
.IX Subsection "OBJ->count_pending_queries()"
Returns the number of outstanding asynchronous queries.
.SH "METHODS FOR DEALING WITH DNSSEC"
.IX Header "METHODS FOR DEALING WITH DNSSEC"
The following correspond to their equivalents in libunbound
and will only work if the underlying libunbound version supports them.
.PP
They return \fI\s-1OBJ\s0\fR and throw errors on failure.
.SS "\fI\s-1OBJ\s0\fP\->\fBadd_ta()\fP"
.IX Subsection "OBJ->add_ta()"

.SS "\fI\s-1OBJ\s0\fP\->\fBadd_ta_autr()\fP"
.IX Subsection "OBJ->add_ta_autr()"

.SS "\fI\s-1OBJ\s0\fP\->\fBadd_ta_file()\fP"
.IX Subsection "OBJ->add_ta_file()"

.SS "\fI\s-1OBJ\s0\fP\->\fBtrustedkeys()\fP"
.IX Subsection "OBJ->trustedkeys()"

.SH "CONVENIENCE FUNCTIONS"
.IX Header "CONVENIENCE FUNCTIONS"
The following may be called either as object methods or as static
functions (but not as class methods). In addition to these,
Socket provides the \f(CW\*(C`inet_ntoa()\*(C'\fR and \f(CW\*(C`inet_ntop()\*(C'\fR
functions for decoding the values of \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`AAAA\*(C'\fR records.
.PP
\&\fB\s-1NOTE:\s0\fR Consider parsing DNS::Unbound::Result’s \f(CW\*(C`answer_packet()\*(C'\fR
with Net::DNS::Packet as a more robust, albeit heavier, way to
parse query result data.
.ie n .SS "$decoded = decode_name($encoded)"
.el .SS "\f(CW$decoded\fP = decode_name($encoded)"
.IX Subsection "$decoded = decode_name($encoded)"
Decodes a \s-1DNS\s0 name. Useful for, e.g., \f(CW\*(C`NS\*(C'\fR, \f(CW\*(C`CNAME\*(C'\fR, and \f(CW\*(C`PTR\*(C'\fR query
results.
.PP
Note that this function’s return will normally include a trailing \f(CW\*(C`.\*(C'\fR
because of the trailing \s-1NUL\s0 byte in an encoded \s-1DNS\s0 name. This is normal
and expected.
.ie n .SS "$strings_ar = decode_character_strings($encoded)"
.el .SS "\f(CW$strings_ar\fP = decode_character_strings($encoded)"
.IX Subsection "$strings_ar = decode_character_strings($encoded)"
Decodes a list of character-strings into component strings,
returned as an array reference. Useful for \f(CW\*(C`TXT\*(C'\fR query results.
.SH "LICENSE & COPYRIGHT"
.IX Header "LICENSE & COPYRIGHT"
Copyright 2019 Gasper Software Consulting.
.PP
This library is licensed under the same terms as Perl itself.
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/FGasper/p5\-DNS\-Unbound>
.SH "THANK YOU"
.IX Header "THANK YOU"
Special thanks to \s-1ATOOMIC\s0 <https://metacpan.org/author/ATOOMIC> for
making some helpful review notes.
