.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Open::This 3"
.TH Open::This 3 "2020-08-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Open::This \- Try to Do the Right Thing when opening files
.SH "VERSION"
.IX Header "VERSION"
version 0.000024
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module powers the ot command line script, which tries to do the right
thing when opening a file.  Imagine your \f(CW$ENV{EDITOR}\fR is set to \f(CW\*(C`vim\*(C'\fR.
(This should also work for \f(CW\*(C`emacs\*(C'\fR and \f(CW\*(C`nano\*(C'\fR.)  The following examples
demonstrate how your input is translated when launching your editor.
.PP
.Vb 2
\&    ot Foo::Bar # vim lib/Foo/Bar.pm
\&    ot Foo::Bar # vim t/lib/Foo/Bar.pm
.Ve
.PP
Imagine this module has a \f(CW\*(C`sub do_something\*(C'\fR at line 55.
.PP
.Vb 1
\&    ot "Foo::Bar::do_something()" # vim +55 lib/Foo/Bar.pm
.Ve
.PP
Or, when copy/pasting from a stack trace.  (Note that you do not need quotes in
this case.)
.PP
.Vb 1
\&    ot Foo::Bar line 36 # vim +36 lib/Foo/Bar.pm
.Ve
.PP
Copy/pasting a \f(CW\*(C`git\-grep\*(C'\fR result.
.PP
.Vb 1
\&    ot lib/Foo/Bar.pm:99 # vim +99 Foo/Bar.pm
.Ve
.PP
Copy/pasting a partial GitHub \s-1URL.\s0
.PP
.Vb 1
\&    ot lib/Foo/Bar.pm#L100 # vim +100 Foo/Bar.pm
.Ve
.PP
Copy/pasting a full GitHub \s-1URL.\s0
.PP
.Vb 2
\&    ot https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L17\-L21
\&    # vim +17 lib/Open/This.pm
.Ve
.PP
Open a local file on the GitHub web site in your web browser.  From within a
checked out copy of https://github.com/oalders/open\-this
.PP
.Vb 1
\&    ot \-b Foo::Bar
.Ve
.PP
Open a local file at the correct line on the GitHub web site in your web
browser.  From within a checked out copy of
https://github.com/oalders/open\-this:
.PP
.Vb 2
\&    ot \-b Open::This line 50
\&    # https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L50
.Ve
.SH "SUPPORTED EDITORS"
.IX Header "SUPPORTED EDITORS"
This code has been well tested with \f(CW\*(C`vim\*(C'\fR.  It should also work with \f(CW\*(C`nvim\*(C'\fR,
\&\f(CW\*(C`emacs\*(C'\fR, \f(CW\*(C`pico\*(C'\fR, \f(CW\*(C`nano\*(C'\fR and \f(CW\*(C`kate\*(C'\fR.  Patches for other editors are very
welcome.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "parse_text"
.IX Subsection "parse_text"
Given a scalar value or an array of scalars, this function will try to extract
useful information from it.  Returns a hashref on success.  Returns undef on
failure.  \f(CW\*(C`file_name\*(C'\fR is the only hash key which is guaranteed to be in the
hash.
.PP
.Vb 2
\&    use Open::This qw( parse_text );
\&    my $parsed = parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq);
\&
\&    # $parsed = { file_name => \*(Aqt/lib/Foo/Bar.pm\*(Aq, line_number => 32, }
\&
\&    my $with_sub_name = parse_text( \*(AqFoo::Bar::do_something()\*(Aq );
\&
\&    # $with_sub_name = {
\&    #     file_name     => \*(Aqt/lib/Foo/Bar.pm\*(Aq,
\&    #     line_number   => 3,
\&    #     original_text => \*(Aqt/lib/Foo/Bar.pm:32\*(Aq,
\&    #     sub_name      => \*(Aqdo_something\*(Aq,
\&    # };
.Ve
.SS "to_editor_args"
.IX Subsection "to_editor_args"
Given a scalar value, this calls \f(CW\*(C`parse_text()\*(C'\fR and returns an array of values
which can be passed at the command line to an editor.
.PP
.Vb 2
\&    my @args = to_editor_args(\*(AqFoo::Bar::do_something()\*(Aq);
\&    # @args = ( \*(Aq+3\*(Aq, \*(Aqt/lib/Foo/Bar.pm\*(Aq );
.Ve
.SS "editor_args_from_parsed_text"
.IX Subsection "editor_args_from_parsed_text"
If you have a \f(CW\*(C`hashref\*(C'\fR from the \f(CW\*(C`parse_text\*(C'\fR function, you can get editor
args via this function.  (The faster way is just to call \f(CW\*(C`to_editor_args\*(C'\fR
directly.)
.PP
.Vb 2
\&    my @args
\&        = editor_args_from_parsed_text( parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq) );
.Ve
.SS "maybe_get_url_from_parsed_text"
.IX Subsection "maybe_get_url_from_parsed_text"
Tries to return an \s-1URL\s0 to a Git repository for a checked out file.  The \s-1URL\s0
will be built using the \f(CW\*(C`origin\*(C'\fR remote and the name of the current branch.  A
line number will be attached if it can be parsed from the text.  This has only
currently be tested with GitHub URLs and it assumes you're working on a branch
which has already been pushed to your remote.
.PP
.Vb 2
\&    my $url = maybe_get_url_from_parsed_text( parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq));
\&    # $url might be something like: https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L32
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
By default, \f(CW\*(C`ot\*(C'\fR will search your \f(CW\*(C`lib\*(C'\fR and \f(CW\*(C`t/lib\*(C'\fR directories for local
files.  You can override this via the \f(CW$ENV{OPEN_THIS_LIBS}\fR variable.  It
accepts a comma-separated list of libs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Olaf Alders <olaf@wundercounter.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2018 by Olaf Alders.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
