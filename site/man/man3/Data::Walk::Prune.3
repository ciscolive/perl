.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Walk::Prune 3"
.TH Data::Walk::Prune 3 "2016-08-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Walk::Prune \- A way to say what should be removed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        #!perl
\&        use MooseX::ShortCut::BuildInstance qw( build_instance );
\&        use Data::Walk::Extracted;
\&        use Data::Walk::Prune;
\&        use Data::Walk::Print;
\&
\&        my  $edward_scissorhands = build_instance( 
\&                        package => \*(AqEdward::Scissorhands\*(Aq,
\&                        superclasses =>[\*(AqData::Walk::Extracted\*(Aq],
\&                        roles =>[qw( Data::Walk::Print Data::Walk::Prune )],
\&                        change_array_size => 1, #Default
\&                );
\&        my  $firstref = {
\&                        Helping => [
\&                                \*(AqSomelevel\*(Aq,
\&                                {
\&                                        MyKey => {
\&                                                MiddleKey => {
\&                                                        LowerKey1 => \*(Aqlow_value1\*(Aq,
\&                                                        LowerKey2 => {
\&                                                                BottomKey1 => \*(Aqbvalue1\*(Aq,
\&                                                                BottomKey2 => \*(Aqbvalue2\*(Aq,
\&                                                        },
\&                                                },
\&                                        },
\&                                },
\&                        ],
\&                };
\&        my      $result = $edward_scissorhands\->prune_data(
\&                        tree_ref    => $firstref, 
\&                        slice_ref   => {
\&                                Helping => [
\&                                        undef,
\&                                        {
\&                                                MyKey => {
\&                                                        MiddleKey => {
\&                                                                LowerKey1 => {},
\&                                                        },
\&                                                },
\&                                        },
\&                                ],
\&                        },
\&                );
\&        $edward_scissorhands\->print_data( $result );
\&
\&        ######################################################################################
\&        #     Output of SYNOPSIS
\&        # 01 {
\&        # 02    Helping => [
\&        # 03            \*(AqSomelevel\*(Aq,
\&        # 04            {
\&        # 05                    MyKey => {
\&        # 06                            MiddleKey => {
\&        # 07                                    LowerKey2 => {
\&        # 08                                            BottomKey1 => \*(Aqbvalue1\*(Aq,
\&        # 09                                            BottomKey2 => \*(Aqbvalue2\*(Aq,
\&        # 10                                    },
\&        # 12                            },
\&        # 13                    },
\&        # 14            },
\&        # 15    ],
\&        # 16 },
\&        ######################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Moose::Role <https://metacpan.org/module/Moose::Manual::Roles> implements the method
prune_data.  It takes a \f(CW$tree_ref\fR and a \f(CW$slice_ref\fR and uses
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted>.  To remove
portions of the 'tree_ref' defined by an empty hash ref (no keys) or an empty array ref
(no positions) at all required points of the 'slice_ref'.  The 'slice_ref' must match the
tree ref up to each slice point.  If the slice points are on a branch of the slice_ref that
does not exist on the tree_ref then no cut takes place.
.SS "\s-1USE\s0"
.IX Subsection "USE"
This is a Moose::Role <https://metacpan.org/module/Moose::Manual::Roles> specifically
designed to be used with Data::Walk::Extracted
 <https://metacpan.org/module/Data::Walk::Extracted#Extending-Data::Walk::Extracted>.
It can be combined traditionaly to the ~::Extracted class using Moose
 <https://metacpan.org/module/Moose::Manual::Roles> methods or for information on how to join
this role to Data::Walk::Extracted at run time see Moose::Util
 <https://metacpan.org/module/Moose::Util> or MooseX::ShortCut::BuildInstance
 <https://metacpan.org/module/MooseX::ShortCut::BuildInstance> for more information.
.SH "Attributes"
.IX Header "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes
see Methods.  The \->new function will either accept fat comma lists or a
complete hash ref that has the possible attributes as the top keys.  Additionally
some attributes that have all the following methods; get_$attribute, set_$attribute,
has_$attribute, and clear_$attribute, can be passed to prune_data
 and will be adjusted for just the run of that
method call.  These are called 'one shot' attributes.  The class and each role (where
applicable) in this package have a list of supported one shot attributes
\&.
.SS "prune_memory"
.IX Subsection "prune_memory"
.RS 4
\&\fBDefinition:\fR When running a prune operation any branch called on the pruner
that does not exist in the tree will not be used.  This attribute turns on tracking
of the actual cuts made and stores them for review after the method is complete.
This is a way to know if the cut was actually implemented.
.Sp
\&\fBDefault\fR undefined
.Sp
\&\fBRange\fR 1 = remember the cuts | 0 = don't remember
.RE
.SS "(see also)"
.IX Subsection "(see also)"
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted#Attributes>
\&\- Attributes
.SH "Methods"
.IX Header "Methods"
.ie n .SS "prune_data( %args )"
.el .SS "prune_data( \f(CW%args\fP )"
.IX Subsection "prune_data( %args )"
.RS 4
\&\fBDefinition:\fR This is a method used to remove targeted parts of a data reference.
.Sp
\&\fBAccepts:\fR a hash ref with the keys 'slice_ref' and 'tree_ref' (both required).
The slice ref can contain more than one 'slice' location in the data reference.
.Sp
.RS 4
\&\fBtree_ref\fR This is the primary data ref that will be manipulated and returned changed.
.Sp
\&\fBslice_ref\fR This is a data ref that will be used to prune the 'tree_ref'.  In general
the slice_ref should match the tree_ref for positions that should remain unchanged.
Where the tree_ref should be trimmed insert either an empty array ref or an empty hash
ref.  If this position represents a value in a hash key => value pair then the hash
key is deleted.  If this position represents a value in an array then the position is
deleted/cleared depending on the attribute change_array_size
 <https://metacpan.org/module/Data::Walk::Extracted#change_array_size> in
Data::Walk::Extracted.  If the slice ref diverges from the tree ref then no action is
taken past the divergence, even if there is a mandated slice. (no auto vivication occurs!)
.Sp
\&\fB[attribute name]\fR \- attribute names are accepted with temporary attribute settings.
These settings are temporarily set for a single \*(L"prune_data\*(R" call and then the original
attribute values are restored.  For this to work the the attribute must meet the
necessary criteria.
.RE
.RE
.RS 4
.Sp
\&\fBExample\fR
.Sp
.Vb 5
\&        $pruned_tree_ref = $self\->prune_data(
\&                tree_ref => $tree_data,
\&                slice_ref => $slice_data,
\&                prune_memory => 0,
\&        );
.Ve
.Sp
\&\fBReturns:\fR The \f(CW$tree_ref\fR with any changes
.RE
.ie n .SS "set_prune_memory( $Bool )"
.el .SS "set_prune_memory( \f(CW$Bool\fP )"
.IX Subsection "set_prune_memory( $Bool )"
.RS 4
\&\fBDefinition:\fR This will change the setting of the prune_memory
attribute.
.Sp
\&\fBAccepts:\fR 1 = remember | 0 = no memory
.Sp
\&\fBReturns:\fR nothing
.RE
.SS "get_prune_memory"
.IX Subsection "get_prune_memory"
.RS 4
\&\fBDefinition:\fR This will return the current setting of the prune_memory
attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR A \f(CW$Bool\fR value for the current state
.RE
.SS "has_prune_memory"
.IX Subsection "has_prune_memory"
.RS 4
\&\fBDefinition:\fR This will indicate if the prune_memory attribute is set
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR A \f(CW$Bool\fR value 1 = defined, 0 = not defined
.RE
.SS "clear_prune_memory"
.IX Subsection "clear_prune_memory"
.RS 4
\&\fBDefinition:\fR This will clear the prune_memory attribute value
(Not the actual prune memory)
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR A \f(CW$Bool\fR value 1 = defined, 0 = not defined
.RE
.SS "has_pruned_positions"
.IX Subsection "has_pruned_positions"
.RS 4
\&\fBDefinition:\fR This answers if any pruned positions were stored
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR A \f(CW$Bool\fR value 1 = pruned cuts are stored, 0 = no stored cuts
.RE
.SS "get_pruned_positions"
.IX Subsection "get_pruned_positions"
.RS 4
\&\fBDefinition:\fR This returns an array ref of stored cuts
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an ArrayRef \- although the cuts were defined in one data ref
this will return one data ref per cut.  Each ref will go to the root of the
original data ref.
.RE
.SS "number_of_cuts"
.IX Subsection "number_of_cuts"
.RS 4
\&\fBDefinition:\fR This returns the number of cuts actually made
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer
.RE
.SH "Caveat utilitor"
.IX Header "Caveat utilitor"
.SS "deep cloning"
.IX Subsection "deep cloning"
Because this uses Data::Walk::Extracted the final \f(CW$tree_ref\fR is deep cloned where
the \f(CW$slice_ref\fR passed through.
.SS "Supported Node types"
.IX Subsection "Supported Node types"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
.IP "\s-1UNDEF\s0" 4
.IX Item "UNDEF"
.PD
.SS "Supported one shot attributes"
.IX Subsection "Supported one shot attributes"
explanation
.IP "prune_memory" 4
.IX Item "prune_memory"
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.RS 4
\&\fB\f(CB$ENV\fB{Smart_Comments}\fR
.Sp
The module uses Smart::Comments <https://metacpan.org/module/Smart::Comments> if the '\-ENV'
option is set.  The 'use' is encapsulated in an if block triggered by an environmental
variable to comfort non-believers.  Setting the variable \f(CW$ENV\fR{Smart_Comments} in a \s-1BEGIN\s0
block will load and turn on smart comment reporting.  There are three levels of 'Smartness'
available in this module '###',  '####', and '#####'.
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Data\-Walk\-Extracted/issues <https://github.com/jandrew/Data-Walk-Extracted/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Add Log::Shiras <https://metacpan.org/module/Log::Shiras> debugging in exchange for
Smart::Comments <https://metacpan.org/module/Smart::Comments>
.Sp
\&\fB2.\fR Support pruning through Objects / Instances nodes
.Sp
\&\fB3.\fR Support pruning through CodeRef nodes
.Sp
\&\fB4.\fR Support pruning through \s-1REF\s0 nodes
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2013 by Jed Lund.
.SH "Dependencies"
.IX Header "Dependencies"
version <https://metacpan.org/module/version>
.PP
Moose::Role <https://metacpan.org/module/Moose::Role>
.Sp
.RS 4
\&\fBrequires\fR
.IP "_process_the_data" 4
.IX Item "_process_the_data"
.PD 0
.IP "_dispatch_method" 4
.IX Item "_dispatch_method"
.IP "_build_branch" 4
.IX Item "_build_branch"
.RE
.RS 4
.RE
.PD
.PP
MooseX::Types::Moose <https://metacpan.org/module/MooseX::Types::Moose>
.PP
Data::Walk::Extracted <https://metacpan.org/module/Data::Walk::Extracted>
.PP
Data::Walk::Extracted::Dispatch <https://metacpan.org/module/Data::Walk::Extracted::Dispatch>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Smart::Comments <https://metacpan.org/module/Smart::Comments> \- is used if the \-ENV option is set
.Sp
Data::Walk <https://metacpan.org/module/Data::Walk>
.Sp
Data::Walker <https://metacpan.org/module/Data::Walker>
.Sp
Data::ModeMerge <https://metacpan.org/module/Data::ModeMerge>
.Sp
Data::Walk::Print <https://metacpan.org/module/Data::Walk::Print> \- available Data::Walk::Extracted Role
.Sp
Data::Walk::Graft <https://metacpan.org/module/Data::Walk::Graft> \- available Data::Walk::Extracted Role
.Sp
Data::Walk::Clone <https://metacpan.org/module/Data::Walk::Clone> \- available Data::Walk::Extracted Role
.RE
