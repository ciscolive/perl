.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::CLI::Interact::Phrasebook 3"
.TH Net::CLI::Interact::Phrasebook 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::CLI::Interact::Phrasebook \- Load command phrasebooks from a Library
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A command phrasebook is where you store the repeatable sequences of commands
which can be sent to connected network devices. An example would be a command
to show the configuration of a device: storing this in a phrasebook (sometimes
known as a dictionary) saves time and effort.
.PP
This module implements the loading and preparing of phrasebooks from an
on-disk file-based hierarchical library, and makes them available to the
application as smart objects for use in Net::CLI::Interact sessions.
Entries in the phrasebook will be one of the following types:
.IP "Prompt" 4
.IX Item "Prompt"
Named regular expressions that match the content of a single line of text in
the output returned from a connected device. They are a demarcation between
commands sent and responses returned.
.IP "Macro" 4
.IX Item "Macro"
Alternating sequences of command statements sent to the device, and regular
expressions to match the response. There are different kinds of Macro,
explained below.
.PP
The named regular expressions used in Prompts and Macros are known as \fIMatch\fR
statements. The command statements in Macros which are sent to the device are
known as \fISend\fR statements. That is, Prompts and Macros are built from one or
more Match and Send statements.
.PP
Each Send or Match statement becomes an instance of the
Net::CLI::Interact::Action class. These are built up into Prompts and
Macros, which become instances of the Net::CLI::Interact::ActionSet class.
.SH "USAGE"
.IX Header "USAGE"
A phrasebook is a plain text file containing named Prompts or Macros. Each
file exists in a directory hierarchy, such that files \*(L"deeper\*(R" in the
hierarchy have their entries override the similarly named entries higher up.
For example:
.PP
.Vb 3
\& /dir1/file1
\& /dir1/file2
\& /dir1/dir2/file3
.Ve
.PP
Entries in \f(CW\*(C`file3\*(C'\fR sharing a name with any entries from \f(CW\*(C`file1\*(C'\fR or \f(CW\*(C`file2\*(C'\fR
will take precedence. Those in \f(CW\*(C`file2\*(C'\fR will also override entries in
\&\f(CW\*(C`file1\*(C'\fR, because asciibetical sorting places the files in that order, and
later definitions with the same name and type override earlier ones.
.PP
When this module is loaded, a \fIpersonality\fR key is required. This locates a
directory on disk, and then the files in that directory and all its ancestors
in the hierarchy are loaded. The directories to search are specified by two
\&\fILibrary\fR options (see below). All phrasebooks matching the given
\&\fIpersonality\fR are loaded, allowing a user to override or augment the default,
shipped phrasebooks.
.SH "INTERFACE"
.IX Header "INTERFACE"
.SS "new( \e%options )"
.IX Subsection "new( %options )"
This takes the following options, and returns a loaded phrasebook object:
.ie n .IP """personality => $directory"" (required)" 4
.el .IP "\f(CWpersonality => $directory\fR (required)" 4
.IX Item "personality => $directory (required)"
The name of a directory component on disk. Any files higher in the libraries
hierarchy are also loaded, but entries in files contained within this
directory, or \*(L"closer\*(R" to it, will take precedence.
.ie n .IP """library => $directory | \e@directories""" 4
.el .IP "\f(CWlibrary => $directory | \e@directories\fR" 4
.IX Item "library => $directory | @directories"
First library hierarchy, specified either as a single directory or a list of
directories that are searched in order. The idea is that this option be set in
your application code, perhaps specifying some directory of phrasebooks
shipped with the distribution.
.ie n .IP """add_library => $directory | \e@directories""" 4
.el .IP "\f(CWadd_library => $directory | \e@directories\fR" 4
.IX Item "add_library => $directory | @directories"
Second library hierarchy, specified either as a single directory or a list of
directories that are searched in order. This parameter is for the end-user to
provide the location(s) of their own phrasebook(s). Any entries found via this
path will override those found via the first \f(CW\*(C`library\*(C'\fR path.
.ie n .SS "prompt( $name )"
.el .SS "prompt( \f(CW$name\fP )"
.IX Subsection "prompt( $name )"
Returns the Prompt associated to the given \f(CW$name\fR, or throws an exception if
no such prompt can be found. The returned object is an instance of
Net::CLI::Interact::ActionSet.
.ie n .SS "has_prompt( $name )"
.el .SS "has_prompt( \f(CW$name\fP )"
.IX Subsection "has_prompt( $name )"
Returns true if a prompt of the given \f(CW$name\fR exists in the loaded phrasebooks.
.SS "prompt_names"
.IX Subsection "prompt_names"
Returns a list of the names of the current loaded Prompts.
.ie n .SS "macro( $name )"
.el .SS "macro( \f(CW$name\fP )"
.IX Subsection "macro( $name )"
Returns the Macro associated to the given \f(CW$name\fR, or throws an exception if
no such macro can be found. The returned object is an instance of
Net::CLI::Interact::ActionSet.
.ie n .SS "has_macro( $name )"
.el .SS "has_macro( \f(CW$name\fP )"
.IX Subsection "has_macro( $name )"
Returns true if a macro of the given \f(CW$name\fR exists in the loaded phrasebooks.
.SS "macro_names"
.IX Subsection "macro_names"
Returns a list of the names of the current loaded Macros.
.SH "PHRASEBOOK FORMAT"
.IX Header "PHRASEBOOK FORMAT"
.SS "Prompt"
.IX Subsection "Prompt"
A Prompt is a named regular expression which matches the content of a single
line of text. Here is an example:
.PP
.Vb 2
\& prompt configure
\&     match /\e(config[^)]*\e)# ?$/
.Ve
.PP
On the first line is the keyword \f(CW\*(C`prompt\*(C'\fR followed by the name of the Prompt,
which must be a valid Perl identifier (letters, numbers, underscores only).
.PP
On the immediately following line is the keyword \f(CW\*(C`match\*(C'\fR followed by a
regular expression, enclosed in two forward-slash characters. Currently, no
alternate bookend characters are supported, nor are regular expression
modifiers (such as \f(CW\*(C`xism\*(C'\fR) outside of the match, but you can of course
include them within.
.PP
The Prompt is used to find out when the connected \s-1CLI\s0 has emitted all of the
response to a command. Try to make the Prompt as specific as possible,
including line-end anchors. Remember that it will be matched against one line
of text, only.
.SS "Macro"
.IX Subsection "Macro"
In general, Macros are alternating sequences of commands to send to the
connected \s-1CLI,\s0 and regular expressions to match the end of the returned
response. Macros are useful for issuing commands which have intermediate
prompts, or confirmation steps. They also support the \fIslurping\fR of
additional output when the connected \s-1CLI\s0 has split the response into pages.
.PP
At its simplest a Macro can be just one command:
.PP
.Vb 3
\& macro show_int_br
\&     send show ip int br
\&     match /> ?$/
.Ve
.PP
On the first line is the keyword \f(CW\*(C`macro\*(C'\fR followed by the name of the Macro,
which must be a valid Perl identifier (letters, numbers, underscores only).
.PP
On the immediately following line is the keyword \f(CW\*(C`send\*(C'\fR followed by a space
and then any text up until the end of the line, and if you want to include
whitespace at the beginning or end of the command, use quotes. This text is
sent to the connected \s-1CLI\s0 as a single command statement. The next line
contains the keyword \f(CW\*(C`match\*(C'\fR followed by the Prompt (regular expression)
which will terminate gathering of returned output from the sent command.
.PP
Macros support the following features:
.IP "Automatic Matching" 4
.IX Item "Automatic Matching"
Normally, you ought always to specify \f(CW\*(C`send\*(C'\fR statements along with a
following \f(CW\*(C`match\*(C'\fR statement so that the module can tell when the output from
your command has ended. However you can omit any Match and the module will
insert either the current \f(CW\*(C`prompt\*(C'\fR value if set by the user, or the last
Prompt from the last Macro. So the previous example could be re-written as:
.Sp
.Vb 2
\& macro show_int_br
\&     send show ip int br
.Ve
.Sp
You can have as many \f(CW\*(C`send\*(C'\fR statements as you like, and the Match statements
will be inserted for you:
.Sp
.Vb 3
\& macro show_int_br_and_timestamp
\&     send show ip int br
\&     send show clock
.Ve
.Sp
However it is recommended that this type of sequence be implemented as
individual commands (or separate Macros) rather than a single Macro, as it
will be easier for you to retrieve the command response(s). Normally the
Automatic Matching is used just to allow missing off of the final Match
statement when it's the same as the current Prompt.
.IP "Format Interpolation" 4
.IX Item "Format Interpolation"
Each \f(CW\*(C`send\*(C'\fR statement is in fact run through Perl's \f(CW\*(C`sprintf\*(C'\fR command, so
variables may be interpolated into the statement using standard \f(CW"%"\fR fields.
For example:
.Sp
.Vb 2
\& macro show_int_x
\&     send show interface %s
.Ve
.Sp
The method for passing variables into the module upon execution of this Macro
is documented in Net::CLI::Interact::Role::Engine. This feature is useful
for username/password prompts.
.IP "Named Match References" 4
.IX Item "Named Match References"
If you're going to use the same Match (regular expression) in a number of
Macros, then set it up as a Prompt (see above) and refer to it by name,
instead:
.Sp
.Vb 2
\& prompt priv_exec
\&     match /# ?$/
\& 
\& macro to_priv_exec
\&     send enable
\&     match /[Pp]assword: ?$/
\&     send %s
\&     match priv_exec
.Ve
.Sp
As you can see, in the case of the last Match, we have the keyword \f(CW\*(C`match\*(C'\fR
followed by the name of a defined Prompt. To match multiple defined Prompts
use this syntax (with as many named references as you like):
.Sp
.Vb 3
\& macro to_privileged
\&     send enable
\&     match username_prompt or priv_exec
.Ve
.IP "Continuations" 4
.IX Item "Continuations"
Sometimes the connected \s-1CLI\s0 will not know it's talking to a program and so
paginate the output (that is, split it into pages). There is usually a
keypress required between each page. This is supported via the following
syntax:
.Sp
.Vb 3
\& macro show_run
\&     send show running\-config
\&     follow / \-\-More\-\- / with \*(Aq \*(Aq
.Ve
.Sp
On the line following the \f(CW\*(C`send\*(C'\fR statement is the keyword \f(CW\*(C`follow\*(C'\fR and a
regular expression enclosed in forward-slashes. This is the Match which will,
if seen in the command output, trigger the continuation. On the line you then
have the keyword \f(CW\*(C`with\*(C'\fR followed by a space and some text, until the end of
the line. If you need to enclose whitespace use quotes, as in the example.
.Sp
The module will send the continuation text and gobble the matched prompt from
the emitted output so you only have one complete piece of text returned, even
if split over many pages. The sent text can contain metacharacters such as
\&\f(CW\*(C`\en\*(C'\fR for a newline.
.Sp
Note that in the above example the \f(CW\*(C`follow\*(C'\fR statement should be seen as an
extension of the \f(CW\*(C`send\*(C'\fR statement. There is still an implicit Match prompt
added at the end of this Macro, as per Automatic Matching, above.
.IP "Line Endings" 4
.IX Item "Line Endings"
Normally all sent command statements are appended with a newline (or the value
of \f(CW\*(C`ors\*(C'\fR, if set). To suppress that feature, use the keyword \f(CW\*(C`put\*(C'\fR instead
of \f(CW\*(C`send\*(C'\fR. However this does not prevent the Format Interpolation via
\&\f(CW\*(C`sprintf\*(C'\fR as described above (simply use \f(CW"%%"\fR to get a literal \f(CW"%"\fR).
