.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Getopt::EX::LabeledParam 3"
.TH Getopt::EX::LabeledParam 3 "2020-10-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Getopt::EX::LabeledParam \- Labeled parameter handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  GetOptions(\*(Aqcolormap|cm:s\*(Aq => @opt_colormap);
\&  my %colormap;
\&  my @colors;
\&
\&  require Getopt::EX::LabeledParam;
\&  my $cmap = Getopt::EX::LabeledParam\->new(
\&      NEWLABEL => 0,
\&      HASH => \e%colormap,
\&      LIST => \e@colors,
\&      );
\&  $cmap\->append(@opt_colormap);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements super class of Getopt::EX::Colormap.
.PP
Parameters can be given in two ways: one in labeled table, and one in
indexed list.
.PP
Basically, labeled parameter is defined by \fB\s-1LABEL\s0\fR=\fI\s-1VALUE\s0\fR notation:
.PP
.Vb 1
\&    FILE=R
.Ve
.PP
Definition can be connected by comma (\f(CW\*(C`,\*(C'\fR):
.PP
.Vb 1
\&    FILE=R,LINE=G
.Ve
.PP
Multiple labels can be set for same value:
.PP
.Vb 1
\&    FILE=LINE=TEXT=R
.Ve
.PP
Wildcard \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR can be used in label name, and they matches
existing hash key name.  If labels \f(CW\*(C`OLD_FILE\*(C'\fR and \f(CW\*(C`NEW_FILE\*(C'\fR exists
in hash,
.PP
.Vb 1
\&    *FILE=R
.Ve
.PP
and
.PP
.Vb 1
\&    OLD_FILE=NEW_FILE=R
.Ve
.PP
produces same result.
.PP
If \fB\s-1VALUE\s0\fR part start with plus (\f(CW\*(C`+\*(C'\fR) character, it is appended to
current value.  At this time, \f(CW\*(C`CONCAT\*(C'\fR string is inserted before
additional string.  Default \f(CW\*(C`CONCAT\*(C'\fR strings is empty, so use
configure method to set.  If \fB\s-1VALUE\s0\fR part start with minus (\f(CW\*(C`\-\*(C'\fR)
character, following characters are deleted from the current value.
.PP
If \fB\s-1LABEL\s0\fR= part is omitted, values are treated anonymous list and
stored in list object.  For example,
.PP
.Vb 1
\&    R,G,B,C,M,Y
.Ve
.PP
makes six entries in the list.  The list object is accessed by index,
rather than label.
.PP
Handler maintains hash and list objects, and labeled values are stored
in hash, non-label values are in list automatically.  User can mix
both specifications.
.PP
When the value field has a special form of function call,
Getopt::EX::Func object is created and stored for that entry.  See
\&\*(L"\s-1FUNCTION SPEC\*(R"\s0 section in Getopt::EX::Colormap for more detail.
Module should have switch to enable this capability, but not now.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBconfigure\fR" 4
.IX Item "configure"
.RS 4
.PD 0
.IP "\fB\s-1HASH\s0\fR => \fIhashref\fR" 4
.IX Item "HASH => hashref"
.IP "\fB\s-1LIST\s0\fR => \fIlistref\fR" 4
.IX Item "LIST => listref"
.PD
\&\fB\s-1HASH\s0\fR and \fB\s-1LIST\s0\fR reference can be set by \fBnew\fR or \fBconfigure\fR
method.  You can provide default setting of hash and list, and it is
usually easier to access those values directly, rather than through
class methods.
.IP "\fB\s-1NEWLABEL\s0\fR => 0/1" 4
.IX Item "NEWLABEL => 0/1"
By default, \fBload_params\fR does not create new entry in colormap
table, and absent label is ignored.  Setting <\s-1NEWLABEL\s0> parameter true
makes it possible create a new hash entry.
.IP "\fB\s-1CONCAT\s0\fR => \fIstring\fR" 4
.IX Item "CONCAT => string"
Set concatination string inserted before appending string.
.RE
.RS 4
.RE
.IP "\fBappend\fR \s-1HASHREF\s0 or \s-1LIST\s0" 4
.IX Item "append HASHREF or LIST"
Append colormap hash or color list.  If a hash reference is given, all
entry of the hash is appended to the colormap.  Otherwise, they are
appended anonymous color list.
