.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::Mechanize::Firefox 3"
.TH WWW::Mechanize::Firefox 3 "2018-10-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::Mechanize::Firefox \- use Firefox as if it were WWW::Mechanize
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use WWW::Mechanize::Firefox;
\&  my $mech = WWW::Mechanize::Firefox\->new();
\&  $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&
\&  $mech\->eval_in_page(\*(Aqalert("Hello Firefox")\*(Aq);
\&  my $png = $mech\->content_as_png();
.Ve
.PP
This module will let you automate Firefox through the
Mozrepl plugin. You need to have installed
that plugin in your Firefox.
.PP
For more examples see WWW::Mechanize::Firefox::Examples.
.SH "IMPORTANT NOTICE"
.IX Header "IMPORTANT NOTICE"
The Mozrepl plugin that this module uses no longer works due to key technologies
it depends on being retired from the Mozilla platform in November 2017.
.PP
According the github repo <https://github.com/bard/mozrepl>, the last known compatible version is Firefox 54.
.PP
Therefore this module cannot be used on Firefox versions greather than 54.
.SH "CONSTRUCTOR and CONFIGURATION"
.IX Header "CONSTRUCTOR and CONFIGURATION"
.ie n .SS """$mech\->new( %args )"""
.el .SS "\f(CW$mech\->new( %args )\fP"
.IX Subsection "$mech->new( %args )"
.Vb 2
\&  use WWW::Mechanize::Firefox;
\&  my $mech = WWW::Mechanize::Firefox\->new();
.Ve
.PP
Creates a new instance and connects it to Firefox.
.PP
Note that Firefox must have the \f(CW\*(C`mozrepl\*(C'\fR
extension installed and enabled.
.PP
The following options are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`tab\*(C'\fR \- regex for the title of the tab to reuse. If no matching tab is
found, the constructor dies.
.Sp
If you pass in the string \f(CW\*(C`current\*(C'\fR, the currently
active tab will be used instead.
.Sp
If you pass in a MozRepl::RemoteObject instance, this will be used
as the new tab. This is convenient if you have an existing tab
in Firefox as object already, for example created through
Firefox::Application\f(CW\*(C`\->addTab()\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`create\*(C'\fR \- will create a new tab if no existing tab matching
the criteria given in \f(CW\*(C`tab\*(C'\fR can be found.
.IP "\(bu" 4
\&\f(CW\*(C`activate\*(C'\fR \- make the tab the active tab
.IP "\(bu" 4
\&\f(CW\*(C`launch\*(C'\fR \- name of the program to launch if we can't connect to it on
the first try.
.IP "\(bu" 4
\&\f(CW\*(C`frames\*(C'\fR \- an array reference of ids of subframes to include when
searching for elements on a page.
.Sp
If you want to always search through all frames, just pass \f(CW1\fR. This
is the default.
.Sp
To prevent searching through frames, pass
.Sp
.Vb 1
\&          frames => 0
.Ve
.Sp
To whitelist frames to be searched, pass the list
of frame selectors:
.Sp
.Vb 1
\&          frames => [\*(Aq#content_frame\*(Aq]
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`autodie\*(C'\fR \- whether web failures converted are fatal Perl errors. See
the \f(CW\*(C`autodie\*(C'\fR accessor. True by default to make error checking easier.
.Sp
To make errors non-fatal, pass
.Sp
.Vb 1
\&    autodie => 0
.Ve
.Sp
in the constructor.
.IP "\(bu" 4
\&\f(CW\*(C`agent\*(C'\fR \- the name of the User Agent to use. This overrides
how Firefox identifies itself.
.IP "\(bu" 4
\&\f(CW\*(C`log\*(C'\fR \- array reference to log levels, passed through to MozRepl::RemoteObject
.IP "\(bu" 4
\&\f(CW\*(C`bufsize\*(C'\fR \- Net::Telnet buffer size, if the default of 1MB is not enough
.IP "\(bu" 4
\&\f(CW\*(C`events\*(C'\fR \- the set of default Javascript events to listen for while
waiting for a reply. In fact, WWW::Mechanize::Firefox will almost always
wait until a 'DOMContentLoaded' or 'load' event. 'pagehide' events
will tell it for what frames to wait.
.Sp
The default set is
.Sp
.Vb 4
\&  \*(AqDOMContentLoaded\*(Aq,\*(Aqload\*(Aq,
\&  \*(Aqpageshow\*(Aq,
\&  \*(Aqpagehide\*(Aq,
\&  \*(Aqerror\*(Aq,\*(Aqabort\*(Aq,\*(Aqstop\*(Aq,
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`app\*(C'\fR \- a premade Firefox::Application
.IP "\(bu" 4
\&\f(CW\*(C`repl\*(C'\fR \- a premade MozRepl::RemoteObject instance or a connection string
suitable for initializing one
.IP "\(bu" 4
\&\f(CW\*(C`use_queue\*(C'\fR \- whether to use the command queueing of MozRepl::RemoteObject.
Default is 1.
.IP "\(bu" 4
\&\f(CW\*(C`js_JSON\*(C'\fR \- whether to use native \s-1JSON\s0 encoder of Firefox
.Sp
.Vb 1
\&    js_JSON => \*(Aqnative\*(Aq, # force using the native JSON encoder
.Ve
.Sp
The default is to autodetect whether a native \s-1JSON\s0 encoder is available and
whether the transport is \s-1UTF\-8\s0 safe.
.IP "\(bu" 4
\&\f(CW\*(C`pre_events\*(C'\fR \- the events that are sent to an input field before its
value is changed. By default this is \f(CW\*(C`[focus]\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`post_events\*(C'\fR \- the events that are sent to an input field after its
value is changed. By default this is \f(CW\*(C`[blur, change]\*(C'\fR.
.ie n .SS """$mech\->agent( $product_id );"""
.el .SS "\f(CW$mech\->agent( $product_id );\fP"
.IX Subsection "$mech->agent( $product_id );"
.Vb 1
\&    $mech\->agent(\*(Aqwonderbot/JS 1.0\*(Aq);
.Ve
.PP
Set the product token that is used to identify the user agent on the network.
The agent value is sent as the \*(L"User-Agent\*(R" header in the requests. The default
is whatever Firefox uses.
.PP
To reset the user agent to the Firefox default, pass an empty string:
.PP
.Vb 1
\&    $mech\->agent(\*(Aq\*(Aq);
.Ve
.ie n .SS """$mech\->autodie( [$state] )"""
.el .SS "\f(CW$mech\->autodie( [$state] )\fP"
.IX Subsection "$mech->autodie( [$state] )"
.Vb 1
\&  $mech\->autodie(0);
.Ve
.PP
Accessor to get/set whether warnings become fatal.
.ie n .SS """$mech\->events()"""
.el .SS "\f(CW$mech\->events()\fP"
.IX Subsection "$mech->events()"
.Vb 1
\&  $mech\->events( [\*(Aqload\*(Aq] );
.Ve
.PP
Sets or gets the set of Javascript events that WWW::Mechanize::Firefox
will wait for after requesting a new page. Returns an array reference.
.PP
Changing the set of events will most likely make WWW::Mechanize::Firefox
stall while waiting for a response.
.PP
This method is special to WWW::Mechanize::Firefox.
.ie n .SS """$mech\->on_event()"""
.el .SS "\f(CW$mech\->on_event()\fP"
.IX Subsection "$mech->on_event()"
.Vb 1
\&  $mech\->on_event(1); # prints every page load event
\&
\&  # or give it a callback
\&  $mech\->on_event(sub { warn "Page loaded with $ev\->{name} event" });
.Ve
.PP
Gets/sets the notification handler for the Javascript event
that finished a page load. Set it to \f(CW1\fR to output via \f(CW\*(C`warn\*(C'\fR,
or a code reference to call it with the event.
.PP
This method is special to WWW::Mechanize::Firefox.
.ie n .SS """$mech\->cookies()"""
.el .SS "\f(CW$mech\->cookies()\fP"
.IX Subsection "$mech->cookies()"
.Vb 1
\&  my $cookie_jar = $mech\->cookies();
.Ve
.PP
Returns a HTTP::Cookies object that was initialized
from the live Firefox instance.
.PP
\&\fBNote:\fR \f(CW\*(C`\->set_cookie\*(C'\fR is not yet implemented,
as is saving the cookie jar.
.SH "JAVASCRIPT METHODS"
.IX Header "JAVASCRIPT METHODS"
.ie n .SS """$mech\->allow( %options )"""
.el .SS "\f(CW$mech\->allow( %options )\fP"
.IX Subsection "$mech->allow( %options )"
Enables or disables browser features for the current tab.
The following options are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`plugins\*(C'\fR   \- Whether to allow plugin execution.
.IP "\(bu" 4
\&\f(CW\*(C`javascript\*(C'\fR    \- Whether to allow Javascript execution.
.IP "\(bu" 4
\&\f(CW\*(C`metaredirects\*(C'\fR \- Attribute stating if refresh based redirects can be allowed.
.IP "\(bu" 4
\&\f(CW\*(C`frames\*(C'\fR, \f(CW\*(C`subframes\*(C'\fR      \- Attribute stating if it should allow subframes (framesets/iframes) or not.
.IP "\(bu" 4
\&\f(CW\*(C`images\*(C'\fR    \- Attribute stating whether or not images should be loaded.
.PP
Options not listed remain unchanged.
.PP
\fIDisable Javascript\fR
.IX Subsection "Disable Javascript"
.PP
.Vb 1
\&  $mech\->allow( javascript => 0 );
.Ve
.ie n .SS """$mech\->js_errors()"""
.el .SS "\f(CW$mech\->js_errors()\fP"
.IX Subsection "$mech->js_errors()"
.Vb 2
\&  print $_\->{message}
\&      for $mech\->js_errors();
.Ve
.PP
An interface to the Javascript Error Console
.PP
Returns the list of errors in the \s-1JEC\s0
.PP
Maybe this should be called \f(CW\*(C`js_messages\*(C'\fR or
\&\f(CW\*(C`js_console_messages\*(C'\fR instead.
.ie n .SS """$mech\->clear_js_errors()"""
.el .SS "\f(CW$mech\->clear_js_errors()\fP"
.IX Subsection "$mech->clear_js_errors()"
.Vb 1
\&    $mech\->clear_js_errors();
.Ve
.PP
Clears all Javascript messages from the console
.ie n .SS """$mech\->eval_in_page( $str [, $env [, $document]] )"""
.el .SS "\f(CW$mech\->eval_in_page( $str [, $env [, $document]] )\fP"
.IX Subsection "$mech->eval_in_page( $str [, $env [, $document]] )"
.ie n .SS """$mech\->eval( $str [, $env [, $document]] )"""
.el .SS "\f(CW$mech\->eval( $str [, $env [, $document]] )\fP"
.IX Subsection "$mech->eval( $str [, $env [, $document]] )"
.Vb 1
\&  my ($value, $type) = $mech\->eval( \*(Aq2+2\*(Aq );
.Ve
.PP
Evaluates the given Javascript fragment in the
context of the web page.
Returns a pair of value and Javascript type.
.PP
This allows access to variables and functions declared
\&\*(L"globally\*(R" on the web page.
.PP
The returned result needs to be treated with
extreme care because
it might lead to Javascript execution in the context of
your application instead of the context of the webpage.
This should be evident for functions and complex data
structures like objects. When working with results from
untrusted sources, you can only safely use simple
types like \f(CW\*(C`string\*(C'\fR.
.PP
If you want to modify the environment the code is run under,
pass in a hash reference as the second parameter. All keys
will be inserted into the \f(CW\*(C`this\*(C'\fR object as well as
\&\f(CW\*(C`this.window\*(C'\fR. Also, complex data structures are only
supported if they contain no objects.
If you need finer control, you'll have to
write the Javascript yourself.
.PP
This method is special to WWW::Mechanize::Firefox.
.PP
Also, using this method opens a potential \fBsecurity risk\fR as
the returned values can be objects and using these objects
can execute malicious code in the context of the Firefox application.
.ie n .SS """$mech\->unsafe_page_property_access( ELEMENT )"""
.el .SS "\f(CW$mech\->unsafe_page_property_access( ELEMENT )\fP"
.IX Subsection "$mech->unsafe_page_property_access( ELEMENT )"
Allows you unsafe access to properties of the current page. Using
such properties is an incredibly bad idea.
.PP
This is why the function \f(CW\*(C`die\*(C'\fRs. If you really want to use
this function, edit the source code.
.SH "UI METHODS"
.IX Header "UI METHODS"
See also Firefox::Application for how to add more than one tab
and how to manipulate windows and tabs.
.ie n .SS """$mech\->application()"""
.el .SS "\f(CW$mech\->application()\fP"
.IX Subsection "$mech->application()"
.Vb 1
\&    my $ff = $mech\->application();
.Ve
.PP
Returns the Firefox::Application object for manipulating
more parts of the Firefox \s-1UI\s0 and application.
.ie n .SS """$mech\->autoclose_tab"""
.el .SS "\f(CW$mech\->autoclose_tab\fP"
.IX Subsection "$mech->autoclose_tab"
.Vb 1
\&  $mech\->autoclose_tab( 0 ); # keep tab open after program end
.Ve
.PP
Set whether to close the tab associated with the instance.
.ie n .SS """$mech\->tab()"""
.el .SS "\f(CW$mech\->tab()\fP"
.IX Subsection "$mech->tab()"
Gets the object that represents the Firefox tab used by WWW::Mechanize::Firefox.
.PP
This method is special to WWW::Mechanize::Firefox.
.ie n .SS """$mech\->make_progress_listener( %callbacks )"""
.el .SS "\f(CW$mech\->make_progress_listener( %callbacks )\fP"
.IX Subsection "$mech->make_progress_listener( %callbacks )"
.Vb 3
\&    my $eventlistener = $mech\->progress_listener(
\&        onStateChange => \e&onStateChange,
\&    );
.Ve
.PP
Creates an unconnected \f(CW\*(C`nsIWebProgressListener\*(C'\fR interface
which calls the Perl subroutines you pass in.
.PP
Returns a handle. Once the handle gets released, all callbacks will
get stopped. Also, all Perl callbacks will get deregistered from the
Javascript bridge, so make sure not to use the same callback
in different progress listeners at the same time.
The sender may still call your callbacks.
.ie n .SS """$mech\->progress_listener( $source, %callbacks )"""
.el .SS "\f(CW$mech\->progress_listener( $source, %callbacks )\fP"
.IX Subsection "$mech->progress_listener( $source, %callbacks )"
.Vb 4
\&    my $eventlistener = progress_listener(
\&        $browser,
\&        onLocationChange => \e&onLocationChange,
\&    );
.Ve
.PP
Sets up the callbacks for the \f(CW\*(C`nsIWebProgressListener\*(C'\fR interface
to be the Perl subroutines you pass in.
.PP
\&\f(CW $source \fR needs to support \f(CW\*(C`.addProgressListener\*(C'\fR and \f(CW\*(C`.removeProgressListener\*(C'\fR.
.PP
Returns a handle. Once the handle gets released, all callbacks will
get stopped. Also, all Perl callbacks will get deregistered from the
Javascript bridge, so make sure not to use the same callback
in different progress listeners at the same time.
.ie n .SS """$mech\->repl()"""
.el .SS "\f(CW$mech\->repl()\fP"
.IX Subsection "$mech->repl()"
.Vb 1
\&  my ($value,$type) = $mech\->repl\->expr(\*(Aq2+2\*(Aq);
.Ve
.PP
Gets the MozRepl::RemoteObject instance that is used.
.PP
This method is special to WWW::Mechanize::Firefox.
.ie n .SS """$mech\->highlight_node( @nodes )"""
.el .SS "\f(CW$mech\->highlight_node( @nodes )\fP"
.IX Subsection "$mech->highlight_node( @nodes )"
.Vb 2
\&    my @links = $mech\->selector(\*(Aqa\*(Aq);
\&    $mech\->highlight_node(@links);
.Ve
.PP
Convenience method that marks all nodes in the arguments
with
.PP
.Vb 3
\&  background: red;
\&  border: solid black 1px;
\&  display: block; /* if the element was display: none before */
.Ve
.PP
This is convenient if you need visual verification that you've
got the right nodes.
.PP
There currently is no way to restore the nodes to their original
visual state except reloading the page.
.SH "NAVIGATION METHODS"
.IX Header "NAVIGATION METHODS"
.ie n .SS """$mech\->get( $url, %options )"""
.el .SS "\f(CW$mech\->get( $url, %options )\fP"
.IX Subsection "$mech->get( $url, %options )"
.Vb 1
\&  $mech\->get( $url, \*(Aq:content_file\*(Aq => $tempfile );
.Ve
.PP
Retrieves the \s-1URL\s0 \f(CW\*(C`URL\*(C'\fR into the tab.
.PP
It returns a faked HTTP::Response object for interface compatibility
with WWW::Mechanize.
.PP
Recognized options:
.IP "\(bu" 4
\&\f(CW\*(C`:content_file\*(C'\fR \- filename to store the data in
.IP "\(bu" 4
\&\f(CW\*(C`no_cache\*(C'\fR \- if true, bypass the browser cache
.IP "\(bu" 4
\&\f(CW\*(C`synchronize\*(C'\fR \- wait until all elements have loaded
.Sp
The default is to wait until all elements have loaded. You can switch
this off by passing
.Sp
.Vb 1
\&    synchronize => 0
.Ve
.Sp
for example if you want to manually poll for an element that appears fairly
early during the load of a complex page.
.ie n .SS """$mech\->get_local( $filename , %options )"""
.el .SS "\f(CW$mech\->get_local( $filename , %options )\fP"
.IX Subsection "$mech->get_local( $filename , %options )"
.Vb 1
\&  $mech\->get_local(\*(Aqtest.html\*(Aq);
.Ve
.PP
Shorthand method to construct the appropriate
\&\f(CW\*(C`file://\*(C'\fR \s-1URI\s0 and load it into Firefox. Relative
paths will be interpreted as relative to \f(CW$0\fR.
.PP
This method accepts the same options as \f(CW\*(C`\->get()\*(C'\fR.
.PP
This method is special to WWW::Mechanize::Firefox but could
also exist in WWW::Mechanize through a plugin.
.PP
Options:
.IP "\(bu" 4
\&\fBbasedir\fR \- a reference directory to use instead of \f(CW\*(C` dirname($0) \*(C'\fR
.ie n .SS """$mech\->post( $url, %options )"""
.el .SS "\f(CW$mech\->post( $url, %options )\fP"
.IX Subsection "$mech->post( $url, %options )"
.Vb 7
\&  $mech\->post( \*(Aqhttp://example.com\*(Aq,
\&      params => { param => "Hello World" },
\&      headers => {
\&        "Content\-Type" => \*(Aqapplication/x\-www\-form\-urlencoded\*(Aq,
\&      },
\&      charset => \*(Aqutf\-8\*(Aq,
\&  );
.Ve
.PP
Sends a \s-1POST\s0 request to \f(CW$url\fR.
.PP
A \f(CW\*(C`Content\-Length\*(C'\fR header will be automatically calculated if
it is not given.
.PP
The following options are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR \- a hash of \s-1HTTP\s0 headers to send. If not given,
the content type will be generated automatically.
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- the raw data to send, if you've encoded it already.
.ie n .SS """$mech\->add_header( $name => $value, ... )"""
.el .SS "\f(CW$mech\->add_header( $name => $value, ... )\fP"
.IX Subsection "$mech->add_header( $name => $value, ... )"
.Vb 4
\&    $mech\->add_header(
\&        \*(AqX\-WWW\-Mechanize\-Firefox\*(Aq => "I\*(Aqm using it",
\&        Encoding => \*(Aqtext/klingon\*(Aq,
\&    );
.Ve
.PP
This method sets up custom headers that will be sent with \fBevery\fR \s-1HTTP\s0(S)
request that Firefox makes.
.PP
Using multiple instances of WWW::Mechanize::Firefox objects with the same
application together with changed request headers will most likely have weird
effects. So don't do that.
.PP
Note that currently, we only support one value per header.
.PP
Some versions of Firefox don't work with the method that is used to set
the custom headers. Please see \f(CW\*(C`t/60\-mech\-custom\-headers.t\*(C'\fR for the exact
versions where the implemented mechanism doesn't work. Roughly, this is
for versions 17 to 24 of Firefox.
.ie n .SS """$mech\->delete_header( $name , $name2... )"""
.el .SS "\f(CW$mech\->delete_header( $name , $name2... )\fP"
.IX Subsection "$mech->delete_header( $name , $name2... )"
.Vb 1
\&    $mech\->delete_header( \*(AqUser\-Agent\*(Aq );
.Ve
.PP
Removes \s-1HTTP\s0 headers from the agent's list of special headers. Note
that Firefox may still send a header with its default value.
.ie n .SS """$mech\->reset_headers"""
.el .SS "\f(CW$mech\->reset_headers\fP"
.IX Subsection "$mech->reset_headers"
.Vb 1
\&    $mech\->reset_headers();
.Ve
.PP
Removes all custom headers and makes Firefox send its defaults again.
.ie n .SS """$mech\->synchronize( $event, $callback )"""
.el .SS "\f(CW$mech\->synchronize( $event, $callback )\fP"
.IX Subsection "$mech->synchronize( $event, $callback )"
Wraps a synchronization semaphore around the callback
and waits until the event \f(CW$event\fR fires on the browser.
If you want to wait for one of multiple events to occur,
pass an array reference as the first parameter.
.PP
Usually, you want to use it like this:
.PP
.Vb 4
\&  my $l = $mech\->xpath(\*(Aq//a[@onclick]\*(Aq, single => 1);
\&  $mech\->synchronize(\*(AqDOMFrameContentLoaded\*(Aq, sub {
\&      $mech\->click( $l );
\&  });
.Ve
.PP
It is necessary to synchronize with the browser whenever
a click performs an action that takes longer and
fires an event on the browser object.
.PP
The \f(CW\*(C`DOMFrameContentLoaded\*(C'\fR event is fired by Firefox when
the whole \s-1DOM\s0 and all \f(CW\*(C`iframe\*(C'\fRs have been loaded.
If your document doesn't have frames, use the \f(CW\*(C`DOMContentLoaded\*(C'\fR
event instead.
.PP
If you leave out \f(CW$event\fR, the value of \f(CW\*(C`\->events()\*(C'\fR will
be used instead.
.ie n .SS """$mech\->res()"" / ""$mech\->response(%options)"""
.el .SS "\f(CW$mech\->res()\fP / \f(CW$mech\->response(%options)\fP"
.IX Subsection "$mech->res() / $mech->response(%options)"
.Vb 1
\&    my $response = $mech\->response(headers => 0);
.Ve
.PP
Returns the current response as a HTTP::Response object.
.PP
The \f(CW\*(C`headers\*(C'\fR option tells the module whether to fetch the headers
from Firefox or not. This is mainly an internal optimization hack.
.ie n .SS """$mech\->success()"""
.el .SS "\f(CW$mech\->success()\fP"
.IX Subsection "$mech->success()"
.Vb 3
\&    $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&    print "Yay"
\&        if $mech\->success();
.Ve
.PP
Returns a boolean telling whether the last request was successful.
If there hasn't been an operation yet, returns false.
.PP
This is a convenience function that wraps \f(CW\*(C`$mech\->res\->is_success\*(C'\fR.
.ie n .SS """$mech\->status()"""
.el .SS "\f(CW$mech\->status()\fP"
.IX Subsection "$mech->status()"
.Vb 3
\&    $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&    print $mech\->status();
\&    # 200
.Ve
.PP
Returns the \s-1HTTP\s0 status code of the response.
This is a 3\-digit number like 200 for \s-1OK, 404\s0 for not found, and so on.
.ie n .SS """$mech\->reload( [$bypass_cache] )"""
.el .SS "\f(CW$mech\->reload( [$bypass_cache] )\fP"
.IX Subsection "$mech->reload( [$bypass_cache] )"
.Vb 1
\&    $mech\->reload();
.Ve
.PP
Reloads the current page. If \f(CW$bypass_cache\fR
is a true value, the browser is not allowed to
use a cached page. This is the difference between
pressing \f(CW\*(C`F5\*(C'\fR (cached) and \f(CW\*(C`shift\-F5\*(C'\fR (uncached).
.PP
Returns the (new) response.
.ie n .SS """$mech\->back( [$synchronize] )"""
.el .SS "\f(CW$mech\->back( [$synchronize] )\fP"
.IX Subsection "$mech->back( [$synchronize] )"
.Vb 1
\&    $mech\->back();
.Ve
.PP
Goes one page back in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->forward( [$synchronize] )"""
.el .SS "\f(CW$mech\->forward( [$synchronize] )\fP"
.IX Subsection "$mech->forward( [$synchronize] )"
.Vb 1
\&    $mech\->forward();
.Ve
.PP
Goes one page forward in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->uri()"""
.el .SS "\f(CW$mech\->uri()\fP"
.IX Subsection "$mech->uri()"
.Vb 1
\&    print "We are at " . $mech\->uri;
.Ve
.PP
Returns the current document \s-1URI.\s0
.SH "CONTENT METHODS"
.IX Header "CONTENT METHODS"
.ie n .SS """$mech\->document()"""
.el .SS "\f(CW$mech\->document()\fP"
.IX Subsection "$mech->document()"
Returns the \s-1DOM\s0 document object.
.PP
This is WWW::Mechanize::Firefox specific.
.ie n .SS """$mech\->docshell()"""
.el .SS "\f(CW$mech\->docshell()\fP"
.IX Subsection "$mech->docshell()"
.Vb 1
\&    my $ds = $mech\->docshell;
.Ve
.PP
Returns the \f(CW\*(C`docShell\*(C'\fR Javascript object associated with the tab.
.PP
This is WWW::Mechanize::Firefox specific.
.ie n .SS """$mech\->content( %options )"""
.el .SS "\f(CW$mech\->content( %options )\fP"
.IX Subsection "$mech->content( %options )"
.Vb 3
\&  print $mech\->content;
\&  print $mech\->content( format => \*(Aqhtml\*(Aq ); # default
\&  print $mech\->content( format => \*(Aqtext\*(Aq ); # identical to \->text
.Ve
.PP
This always returns the content as a Unicode string. It tries
to decode the raw content according to its input encoding.
This currently only works for \s-1HTML\s0 pages, not for images etc.
.PP
Recognized options:
.IP "\(bu" 4
\&\f(CW\*(C`document\*(C'\fR \- the document to use.
.Sp
Default is \f(CW\*(C`$self\->document\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`format\*(C'\fR \- the stuff to return
.Sp
The allowed values are \f(CW\*(C`html\*(C'\fR and \f(CW\*(C`text\*(C'\fR. The default is \f(CW\*(C`html\*(C'\fR.
.ie n .SS """$mech\->text()"""
.el .SS "\f(CW$mech\->text()\fP"
.IX Subsection "$mech->text()"
Returns the text of the current \s-1HTML\s0 content.  If the content isn't
\&\s-1HTML,\s0 \f(CW$mech\fR will die.
.ie n .SS """$mech\->content_encoding()"""
.el .SS "\f(CW$mech\->content_encoding()\fP"
.IX Subsection "$mech->content_encoding()"
.Vb 1
\&    print "The content is encoded as ", $mech\->content_encoding;
.Ve
.PP
Returns the encoding that the content is in. This can be used
to convert the content from \s-1UTF\-8\s0 back to its native encoding.
.ie n .SS """$mech\->update_html( $html )"""
.el .SS "\f(CW$mech\->update_html( $html )\fP"
.IX Subsection "$mech->update_html( $html )"
.Vb 1
\&  $mech\->update_html($html);
.Ve
.PP
Writes \f(CW$html\fR into the current document. This is mostly
implemented as a convenience method for HTML::Display::MozRepl.
.ie n .SS """$mech\->save_content( $localname [, $resource_directory] [, %options ] )"""
.el .SS "\f(CW$mech\->save_content( $localname [, $resource_directory] [, %options ] )\fP"
.IX Subsection "$mech->save_content( $localname [, $resource_directory] [, %options ] )"
.Vb 2
\&  $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&  $mech\->save_content(\*(Aqgoogle search page\*(Aq,\*(Aqgoogle search page files\*(Aq);
.Ve
.PP
Saves the given \s-1URL\s0 to the given filename. The \s-1URL\s0 will be
fetched from the cache if possible, avoiding unnecessary network
traffic.
.PP
If \f(CW$resource_directory\fR is given, the whole page will be saved.
All \s-1CSS,\s0 subframes and images
will be saved into that directory, while the page \s-1HTML\s0 itself will
still be saved in the file pointed to by \f(CW$localname\fR.
.PP
Returns a \f(CW\*(C`nsIWebBrowserPersist\*(C'\fR object through which you can cancel the
download by calling its \f(CW\*(C`\->cancelSave\*(C'\fR method. Also, you can poll
the download status through the \f(CW\*(C`\->{currentState}\*(C'\fR property.
.PP
If you need to set persist flags pass the unsigned long value in the
\&\f(CW\*(C`persist\*(C'\fR option.
.PP
.Vb 2
\&    $mech\->get(\*(Aqhttp://zombisoft.com\*(Aq);
\&    $mech\->save_content(\*(AqZombisoft\*(Aq,\*(Aqzombisoft\-resource\-files\*(Aq, "persist" => 512 | 2048);
.Ve
.PP
A list of flags and their values can be found at
<https://developer.mozilla.org/en\-US/docs/XPCOM_Interface_Reference/nsIWebBrowserPersist>.
.PP
If you are interested in the intermediate download progress, create
a ProgressListener through \f(CW\*(C`$mech\->progress_listener\*(C'\fR
and pass it in the \f(CW\*(C`progress\*(C'\fR option.
.PP
The download will
continue in the background. It will not show up in the
Download Manager.
.ie n .SS """$mech\->save_url( $url, $localname, [%options] )"""
.el .SS "\f(CW$mech\->save_url( $url, $localname, [%options] )\fP"
.IX Subsection "$mech->save_url( $url, $localname, [%options] )"
.Vb 1
\&  $mech\->save_url(\*(Aqhttp://google.com\*(Aq,\*(Aqgoogle_index.html\*(Aq);
.Ve
.PP
Saves the given \s-1URL\s0 to the given filename. The \s-1URL\s0 will be
fetched from the cache if possible, avoiding unnecessary network
traffic.
.PP
If you are interested in the intermediate download progress, create
a ProgressListener through \f(CW\*(C`$mech\->progress_listener\*(C'\fR
and pass it in the \f(CW\*(C`progress\*(C'\fR option.
The download will
continue in the background. It will also not show up in the
Download Manager.
.PP
If the \f(CW\*(C`progress\*(C'\fR option is not passed in, \f(CW\*(C` \-\*(C'\fRsave_url >
will only return after the download has finished.
.PP
Returns a \f(CW\*(C`nsIWebBrowserPersist\*(C'\fR object through which you can cancel the
download by calling its \f(CW\*(C`\->cancelSave\*(C'\fR method. Also, you can poll
the download status through the \f(CW\*(C`\->{currentState}\*(C'\fR property.
.ie n .SS """$mech\->base()"""
.el .SS "\f(CW$mech\->base()\fP"
.IX Subsection "$mech->base()"
.Vb 1
\&  print $mech\->base;
.Ve
.PP
Returns the \s-1URL\s0 base for the current page.
.PP
The base is either specified through a \f(CW\*(C`base\*(C'\fR
tag or is the current \s-1URL.\s0
.PP
This method is specific to WWW::Mechanize::Firefox
.ie n .SS """$mech\->content_type()"""
.el .SS "\f(CW$mech\->content_type()\fP"
.IX Subsection "$mech->content_type()"
.ie n .SS """$mech\->ct()"""
.el .SS "\f(CW$mech\->ct()\fP"
.IX Subsection "$mech->ct()"
.Vb 1
\&  print $mech\->content_type;
.Ve
.PP
Returns the content type of the currently loaded document
.ie n .SS """$mech\->is_html()"""
.el .SS "\f(CW$mech\->is_html()\fP"
.IX Subsection "$mech->is_html()"
.Vb 1
\&  print $mech\->is_html();
.Ve
.PP
Returns true/false on whether our content is \s-1HTML,\s0 according to the
\&\s-1HTTP\s0 headers.
.ie n .SS """$mech\->title()"""
.el .SS "\f(CW$mech\->title()\fP"
.IX Subsection "$mech->title()"
.Vb 1
\&  print "We are on page " . $mech\->title;
.Ve
.PP
Returns the current document title.
.SH "EXTRACTION METHODS"
.IX Header "EXTRACTION METHODS"
.ie n .SS """$mech\->links()"""
.el .SS "\f(CW$mech\->links()\fP"
.IX Subsection "$mech->links()"
.Vb 2
\&  print $_\->text . " \-> " . $_\->url . "\en"
\&      for $mech\->links;
.Ve
.PP
Returns all links in the document as WWW::Mechanize::Link objects.
.PP
Currently accepts no parameters. See \f(CW\*(C`\->xpath\*(C'\fR
or \f(CW\*(C`\->selector\*(C'\fR when you want more control.
.ie n .SS """$mech\->find_link_dom( %options )"""
.el .SS "\f(CW$mech\->find_link_dom( %options )\fP"
.IX Subsection "$mech->find_link_dom( %options )"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_link_dom( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method to find links, like WWW::Mechanize's
\&\f(CW\*(C`\->find_links\*(C'\fR method. This method returns \s-1DOM\s0 objects from
Firefox instead of WWW::Mechanize::Link objects.
.PP
Note that Firefox
might have reordered the links or frame links in the document
so the absolute numbers passed via \f(CW\*(C`n\*(C'\fR
might not be the same between
WWW::Mechanize and WWW::Mechanize::Firefox.
.PP
Returns the \s-1DOM\s0 object as MozRepl::RemoteObject::Instance.
.PP
The supported options are:
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR and \f(CW\*(C`text_contains\*(C'\fR and \f(CW\*(C`text_regex\*(C'\fR
.Sp
Match the text of the link as a complete string, substring or regular expression.
.Sp
Matching as a complete string or substring is a bit faster, as it is
done in the XPath engine of Firefox.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR and \f(CW\*(C`id_contains\*(C'\fR and \f(CW\*(C`id_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`id\*(C'\fR attribute of the link completely or as part
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR and \f(CW\*(C`name_contains\*(C'\fR and \f(CW\*(C`name_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`name\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR and \f(CW\*(C`url_regex\*(C'\fR
.Sp
Matches the \s-1URL\s0 attribute of the link (\f(CW\*(C`href\*(C'\fR, \f(CW\*(C`src\*(C'\fR or \f(CW\*(C`content\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`class\*(C'\fR \- the \f(CW\*(C`class\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`n\*(C'\fR \- the (1\-based) index. Defaults to returning the first link.
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.Sp
The method \f(CW\*(C`croak\*(C'\fRs if no link is found. If the \f(CW\*(C`single\*(C'\fR option is true,
it also \f(CW\*(C`croak\*(C'\fRs when more than one link is found.
.ie n .SS """$mech\->find_link( %options )"""
.el .SS "\f(CW$mech\->find_link( %options )\fP"
.IX Subsection "$mech->find_link( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_link( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method quite similar to WWW::Mechanize's method.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns a WWW::Mechanize::Link object.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links( %options )"""
.el .SS "\f(CW$mech\->find_all_links( %options )\fP"
.IX Subsection "$mech->find_all_links( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_all_links( text_regex => qr/google/i );
.Ve
.PP
Finds all links in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links_dom %options"""
.el .SS "\f(CW$mech\->find_all_links_dom %options\fP"
.IX Subsection "$mech->find_all_links_dom %options"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_all_links_dom( text_regex => qr/google/i );
.Ve
.PP
Finds all matching linky \s-1DOM\s0 nodes in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->follow_link( $link )"""
.el .SS "\f(CW$mech\->follow_link( $link )\fP"
.IX Subsection "$mech->follow_link( $link )"
.ie n .SS """$mech\->follow_link( %options )"""
.el .SS "\f(CW$mech\->follow_link( %options )\fP"
.IX Subsection "$mech->follow_link( %options )"
.Vb 1
\&  $mech\->follow_link( xpath => \*(Aq//a[text() = "Click here!"]\*(Aq );
.Ve
.PP
Follows the given link. Takes the same parameters that \f(CW\*(C`find_link_dom\*(C'\fR
uses. In addition, \f(CW\*(C`synchronize\*(C'\fR can be passed to (not) force
waiting for a new page to be loaded.
.PP
Note that \f(CW\*(C`\->follow_link\*(C'\fR will only try to follow link-like
things like \f(CW\*(C`A\*(C'\fR tags.
.ie n .SS """$mech\->xpath( $query, %options )"""
.el .SS "\f(CW$mech\->xpath( $query, %options )\fP"
.IX Subsection "$mech->xpath( $query, %options )"
.Vb 2
\&    my $link = $mech\->xpath(\*(Aq//a[@id="clickme"]\*(Aq, one => 1);
\&    # croaks if there is no link or more than one link found
\&
\&    my @para = $mech\->xpath(\*(Aq//p\*(Aq);
\&    # Collects all paragraphs
\&
\&    my @para_text = $mech\->xpath(\*(Aq//p/text()\*(Aq, type => $mech\->xpathResult(\*(AqSTRING_TYPE\*(Aq));
\&    # Collects all paragraphs as text
.Ve
.PP
Runs an XPath query in Firefox against the current document.
.PP
If you need more information about the returned results,
use the \f(CW\*(C`\->xpathEx()\*(C'\fR function.
.PP
The options allow the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`document\*(C'\fR \- document in which the query is to be executed. Use this to
search a node within a specific subframe of \f(CW\*(C`$mech\->document\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`frames\*(C'\fR \- if true, search all documents in all frames and iframes.
This may or may not conflict with \f(CW\*(C`node\*(C'\fR. This will default to the
\&\f(CW\*(C`frames\*(C'\fR setting of the WWW::Mechanize::Firefox object.
.IP "\(bu" 4
\&\f(CW\*(C`node\*(C'\fR \- node relative to which the query is to be executed. Note
that you will have to use a relative XPath expression as well. Use
.Sp
.Vb 1
\&  .//foo
.Ve
.Sp
instead of
.Sp
.Vb 1
\&  //foo
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`maybe\*(C'\fR \- If true, ensure that at most one element is found. Otherwise
croak or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`all\*(C'\fR \- If true, return all elements found. This is the default.
You can use this option if you want to use \f(CW\*(C`\->xpath\*(C'\fR in scalar context
to count the number of matched elements, as it will otherwise emit a warning
for each usage in scalar context without any of the above restricting options.
.IP "\(bu" 4
\&\f(CW\*(C`any\*(C'\fR \- no error is raised, no matter if an item is found or not.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- force the return type of the query.
.Sp
.Vb 1
\&  type => $mech\->xpathResult(\*(AqORDERED_NODE_SNAPSHOT_TYPE\*(Aq),
.Ve
.Sp
WWW::Mechanize::Firefox tries a best effort in giving you the appropriate
result of your query, be it a \s-1DOM\s0 node or a string or a number. In the case
you need to restrict the return type, you can pass this in.
.Sp
The allowed strings are documented in the \s-1MDN.\s0 Interesting types are
.Sp
.Vb 4
\&  ANY_TYPE     (default, uses whatever things the query returns)
\&  STRING_TYPE
\&  NUMBER_TYPE
\&  ORDERED_NODE_SNAPSHOT_TYPE
.Ve
.PP
Returns the matched results.
.PP
You can pass in a list of queries as an array reference for the first parameter.
The result will then be the list of all elements matching any of the queries.
.PP
This is a method that is not implemented in WWW::Mechanize.
.PP
In the long run, this should go into a general plugin for
WWW::Mechanize.
.ie n .SS """$mech\->xpathEx( $query, %options )"""
.el .SS "\f(CW$mech\->xpathEx( $query, %options )\fP"
.IX Subsection "$mech->xpathEx( $query, %options )"
.Vb 1
\&    my @links = $mech\->xpathEx(\*(Aq//a[@id="clickme"]\*(Aq);
.Ve
.PP
Runs an XPath query in Firefox against a document. Returns a list
of found elements. Each element in the result has the following properties:
.IP "\(bu" 4
\&\f(CW\*(C`resultType\*(C'\fR \- the type of the result. The numerical value of \f(CW\*(C`$mech\->xpathResult()\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`resultSize\*(C'\fR \- the number of elements in this result. This is 1 for atomic results like
strings or numbers, and the number of elements for nodesets.
.IP "\(bu" 4
\&\f(CW\*(C`result\*(C'\fR \- the best result available. This is the nodeset
or the text or number, depending on the query.
.ie n .SS """$mech\->selector( $css_selector, %options )"""
.el .SS "\f(CW$mech\->selector( $css_selector, %options )\fP"
.IX Subsection "$mech->selector( $css_selector, %options )"
.Vb 1
\&  my @text = $mech\->selector(\*(Aqp.content\*(Aq);
.Ve
.PP
Returns all nodes matching the given \s-1CSS\s0 selector. If
\&\f(CW$css_selector\fR is an array reference, it returns
all nodes matched by any of the \s-1CSS\s0 selectors in the array.
.PP
This takes the same options that \f(CW\*(C`\->xpath\*(C'\fR does.
.PP
In the long run, this should go into a general plugin for
WWW::Mechanize.
.ie n .SS """$mech\->by_id( $id, %options )"""
.el .SS "\f(CW$mech\->by_id( $id, %options )\fP"
.IX Subsection "$mech->by_id( $id, %options )"
.Vb 1
\&  my @text = $mech\->by_id(\*(Aq_foo:bar\*(Aq);
.Ve
.PP
Returns all nodes matching the given ids. If
\&\f(CW$id\fR is an array reference, it returns
all nodes matched by any of the ids in the array.
.PP
This method is equivalent to calling \f(CW\*(C`\->xpath\*(C'\fR :
.PP
.Vb 1
\&    $self\->xpath(qq{//*[\e@id="$_"], %options)
.Ve
.PP
It is convenient when your element ids get mistaken for
\&\s-1CSS\s0 selectors.
.ie n .SS """$mech\->click( $name [,$x ,$y] )"""
.el .SS "\f(CW$mech\->click( $name [,$x ,$y] )\fP"
.IX Subsection "$mech->click( $name [,$x ,$y] )"
.Vb 2
\&  $mech\->click( \*(Aqgo\*(Aq );
\&  $mech\->click({ xpath => \*(Aq//button[@name="go"]\*(Aq });
.Ve
.PP
Has the effect of clicking a button (or other element) on the current form. The
first argument is the \f(CW\*(C`name\*(C'\fR of the button to be clicked. The second and third
arguments (optional) allow you to specify the (x,y) coordinates of the click.
.PP
If there is only one button on the form, \f(CW\*(C`$mech\->click()\*(C'\fR with
no arguments simply clicks that one button.
.PP
If you pass in a hash reference instead of a name,
the following keys are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`selector\*(C'\fR \- Find the element to click by the \s-1CSS\s0 selector
.IP "\(bu" 4
\&\f(CW\*(C`xpath\*(C'\fR \- Find the element to click by the XPath query
.IP "\(bu" 4
\&\f(CW\*(C`dom\*(C'\fR \- Click on the passed \s-1DOM\s0 element
.Sp
You can use this to click on arbitrary page elements. There is no convenient
way to pass x/y co-ordinates with this method.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- Click on the element with the given id
.Sp
This is useful if your document ids contain characters that
do look like \s-1CSS\s0 selectors. It is equivalent to
.Sp
.Vb 1
\&    xpath => qq{//*[\e@id="$id"]}
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`synchronize\*(C'\fR \- Synchronize the click (default is 1)
.Sp
Synchronizing means that WWW::Mechanize::Firefox will wait until
one of the events listed in \f(CW\*(C`events\*(C'\fR is fired. You want to switch
it off when there will be no \s-1HTTP\s0 response or \s-1DOM\s0 event fired, for
example for clicks that only modify the \s-1DOM.\s0
.Sp
You can pass in a scalar that is a false value to not wait for
any kind of event.
.Sp
Passing in an array reference will use the array elements as
Javascript events to wait for.
.Sp
Passing in any other true value will use the value of \f(CW\*(C`\->events\*(C'\fR
as the list of events to wait for.
.PP
Returns a HTTP::Response object.
.PP
As a deviation from the WWW::Mechanize \s-1API,\s0 you can also pass a
hash reference as the first parameter. In it, you can specify
the parameters to search much like for the \f(CW\*(C`find_link\*(C'\fR calls.
.PP
Note: Currently, clicking on images with the \f(CW\*(C`ismap\*(C'\fR attribute
does not trigger the move to the new \s-1URL. A\s0 workaround is to program
the new \s-1URL\s0 into your script.
.ie n .SS """$mech\->click_button( ... )"""
.el .SS "\f(CW$mech\->click_button( ... )\fP"
.IX Subsection "$mech->click_button( ... )"
.Vb 2
\&  $mech\->click_button( name => \*(Aqgo\*(Aq );
\&  $mech\->click_button( input => $mybutton );
.Ve
.PP
Has the effect of clicking a button on the current form by specifying its
name, value, or index. Its arguments are a list of key/value pairs. Only
one of name, number, input or value must be specified in the keys.
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR \- name of the button
.IP "\(bu" 4
\&\f(CW\*(C`value\*(C'\fR \- value of the button
.IP "\(bu" 4
\&\f(CW\*(C`input\*(C'\fR \- \s-1DOM\s0 node
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- id of the button
.IP "\(bu" 4
\&\f(CW\*(C`number\*(C'\fR \- number of the button
.PP
If you find yourself wanting to specify a button through its
\&\f(CW\*(C`selector\*(C'\fR or \f(CW\*(C`xpath\*(C'\fR, consider using \f(CW\*(C`\->click\*(C'\fR instead.
.SH "FORM METHODS"
.IX Header "FORM METHODS"
.ie n .SS """$mech\->current_form()"""
.el .SS "\f(CW$mech\->current_form()\fP"
.IX Subsection "$mech->current_form()"
.Vb 1
\&  print $mech\->current_form\->{name};
.Ve
.PP
Returns the current form.
.PP
This method is incompatible with WWW::Mechanize.
It returns the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR object and not
a HTML::Form instance.
.PP
Note that WWW::Mechanize::Firefox has little way to know
that the current form is not displayed in the browser
anymore, so it often holds on to the last value. If
you want to make sure that a fresh or no form is used,
remove it:
.PP
.Vb 1
\&    $mech\->clear_current_form;
.Ve
.PP
The current form will be reset by WWW::Mechanize::Firefox
on calls to \f(CW\*(C`\->get()\*(C'\fR and \f(CW\*(C`\->get_local()\*(C'\fR,
and on calls to \f(CW\*(C`\->submit()\*(C'\fR and \f(CW\*(C`\->submit_with_fields\*(C'\fR.
.ie n .SS """$mech\->form_name( $name [, %options] )"""
.el .SS "\f(CW$mech\->form_name( $name [, %options] )\fP"
.IX Subsection "$mech->form_name( $name [, %options] )"
.Vb 1
\&  $mech\->form_name( \*(Aqsearch\*(Aq );
.Ve
.PP
Selects the current form by its name. The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_id( $id [, %options] )"""
.el .SS "\f(CW$mech\->form_id( $id [, %options] )\fP"
.IX Subsection "$mech->form_id( $id [, %options] )"
.Vb 1
\&  $mech\->form_id( \*(Aqlogin\*(Aq );
.Ve
.PP
Selects the current form by its \f(CW\*(C`id\*(C'\fR attribute.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.PP
This is equivalent to calling
.PP
.Vb 1
\&    $mech\->by_id($id,single => 1,%options)
.Ve
.ie n .SS """$mech\->form_number( $number [, %options] )"""
.el .SS "\f(CW$mech\->form_number( $number [, %options] )\fP"
.IX Subsection "$mech->form_number( $number [, %options] )"
.Vb 1
\&  $mech\->form_number( 2 );
.Ve
.PP
Selects the \fInumber\fRth form.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_with_fields( [$options], @fields )"""
.el .SS "\f(CW$mech\->form_with_fields( [$options], @fields )\fP"
.IX Subsection "$mech->form_with_fields( [$options], @fields )"
.Vb 3
\&  $mech\->form_with_fields(
\&      \*(Aquser\*(Aq, \*(Aqpassword\*(Aq
\&  );
.Ve
.PP
Find the form which has the listed fields.
.PP
If the first argument is a hash reference, it's taken
as options to \f(CW\*(C`\->xpath\*(C'\fR.
.PP
See also \*(L"$mech\->submit_form\*(R".
.ie n .SS """$mech\->forms( %options )"""
.el .SS "\f(CW$mech\->forms( %options )\fP"
.IX Subsection "$mech->forms( %options )"
.Vb 1
\&  my @forms = $mech\->forms();
.Ve
.PP
When called in a list context, returns a list
of the forms found in the last fetched page.
In a scalar context, returns a reference to
an array with those forms.
.PP
The options
are identical to those accepted by the \*(L"$mech\->selector\*(R" method.
.PP
The returned elements are the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR elements.
.ie n .SS """$mech\->field( $selector, $value, [,\e@pre_events [,\e@post_events]] )"""
.el .SS "\f(CW$mech\->field( $selector, $value, [,\e@pre_events [,\e@post_events]] )\fP"
.IX Subsection "$mech->field( $selector, $value, [,@pre_events [,@post_events]] )"
.Vb 2
\&  $mech\->field( user => \*(Aqjoe\*(Aq );
\&  $mech\->field( not_empty => \*(Aq\*(Aq, [], [] ); # bypass JS validation
.Ve
.PP
Sets the field with the name given in \f(CW$selector\fR to the given value.
Returns the value.
.PP
The method understands very basic \s-1CSS\s0 selectors in the value for \f(CW$selector\fR,
like the HTML::Form \fBfind_input()\fR method.
.PP
A selector prefixed with '#' must match the id attribute of the input.
A selector prefixed with '.' matches the class attribute. A selector
prefixed with '^' or with no prefix matches the name attribute.
.PP
By passing the array reference \f(CW@pre_events\fR, you can indicate which
Javascript events you want to be triggered before setting the value.
\&\f(CW@post_events\fR contains the events you want to be triggered
after setting the value.
.PP
By default, the events set in the
constructor for \f(CW\*(C`pre_events\*(C'\fR and \f(CW\*(C`post_events\*(C'\fR
are triggered.
.ie n .SS """$mech\->value( $selector_or_element, [%options] )"""
.el .SS "\f(CW$mech\->value( $selector_or_element, [%options] )\fP"
.IX Subsection "$mech->value( $selector_or_element, [%options] )"
.Vb 1
\&    print $mech\->value( \*(Aquser\*(Aq );
.Ve
.PP
Returns the value of the field given by \f(CW$selector_or_name\fR or of the
\&\s-1DOM\s0 element passed in.
.PP
The legacy form of
.PP
.Vb 1
\&    $mech\->value( name => value );
.Ve
.PP
is also still supported but will likely be deprecated
in favour of the \f(CW\*(C`\->field\*(C'\fR method.
.PP
For fields that can have multiple values, like a \f(CW\*(C`select\*(C'\fR field,
the method is context sensitive and returns the first selected
value in scalar context and all values in list context.
.ie n .SS """$mech\->get_set_value( %options )"""
.el .SS "\f(CW$mech\->get_set_value( %options )\fP"
.IX Subsection "$mech->get_set_value( %options )"
Allows fine-grained access to getting/setting a value
with a different \s-1API.\s0 Supported keys are:
.PP
.Vb 5
\&  pre
\&  post
\&  name
\&  node
\&  value
.Ve
.PP
in addition to all keys that \f(CW\*(C`$mech\->xpath\*(C'\fR supports.
.ie n .SS """$mech\->select( $name, $value )"""
.el .SS "\f(CW$mech\->select( $name, $value )\fP"
.IX Subsection "$mech->select( $name, $value )"
.ie n .SS """$mech\->select( $name, \e@values )"""
.el .SS "\f(CW$mech\->select( $name, \e@values )\fP"
.IX Subsection "$mech->select( $name, @values )"
Given the name of a \f(CW\*(C`select\*(C'\fR field, set its value to the value
specified.  If the field is not \f(CW\*(C`<select multiple>\*(C'\fR and the
\&\f(CW$value\fR is an array, only the \fBfirst\fR value will be set.
Passing \f(CW$value\fR as a hash with
an \f(CW\*(C`n\*(C'\fR key selects an item by number (e.g.
\&\f(CW\*(C`{n => 3}\*(C'\fR or \f(CW\*(C`{n => [2,4]}\*(C'\fR).
The numbering starts at 1.  This applies to the current form.
.PP
If you have a field with \f(CW\*(C`<select multiple>\*(C'\fR and you pass a single
\&\f(CW$value\fR, then \f(CW$value\fR will be added to the list of fields selected,
without clearing the others.  However, if you pass an array reference,
then all previously selected values will be cleared.
.PP
Returns true on successfully setting the value. On failure, returns
false and calls \f(CW\*(C`$self>warn()\*(C'\fR with an error message.
.ie n .SS """$mech\->tick( $name, $value [, $set ] )"""
.el .SS "\f(CW$mech\->tick( $name, $value [, $set ] )\fP"
.IX Subsection "$mech->tick( $name, $value [, $set ] )"
.Vb 1
\&    $mech\->tick("confirmation_box", \*(Aqyes\*(Aq);
.Ve
.PP
\&\*(L"Ticks\*(R" the first checkbox that has both the name and value associated with it
on the current form. Dies if there is no named check box for that value.
Passing in a false value as the third optional argument will cause the
checkbox to be unticked.
.PP
(Un)ticking the checkbox is done by sending a click event to it if needed.
If \f(CW$value\fR is \f(CW\*(C`undef\*(C'\fR, the first checkbox matching \f(CW$name\fR will
be (un)ticked.
.PP
If \f(CW$name\fR is a reference to a hash, that hash will be used
as the options to \f(CW\*(C`\->find_link_dom\*(C'\fR to find the element.
.ie n .SS """$mech\->untick( $name, $value )"""
.el .SS "\f(CW$mech\->untick( $name, $value )\fP"
.IX Subsection "$mech->untick( $name, $value )"
.Vb 1
\&  $mech\->untick(\*(Aqspam_confirm\*(Aq,\*(Aqyes\*(Aq,undef)
.Ve
.PP
Causes the checkbox to be unticked. Shorthand for
.PP
.Vb 1
\&  $mech\->tick($name,$value,undef)
.Ve
.ie n .SS """$mech\->submit( $form )"""
.el .SS "\f(CW$mech\->submit( $form )\fP"
.IX Subsection "$mech->submit( $form )"
.Vb 1
\&  $mech\->submit;
.Ve
.PP
Submits the form. Note that this does \fBnot\fR fire the \f(CW\*(C`onClick\*(C'\fR
event and thus also does not fire eventual Javascript handlers.
Maybe you want to use \f(CW\*(C`$mech\->click\*(C'\fR instead.
.PP
The default is to submit the current form as returned
by \f(CW\*(C`$mech\->current_form\*(C'\fR.
.ie n .SS """$mech\->submit_form( %options )"""
.el .SS "\f(CW$mech\->submit_form( %options )\fP"
.IX Subsection "$mech->submit_form( %options )"
.Vb 6
\&  $mech\->submit_form(
\&      with_fields => {
\&          user => \*(Aqme\*(Aq,
\&          pass => \*(Aqsecret\*(Aq,
\&      }
\&  );
.Ve
.PP
This method lets you select a form from the previously fetched page,
fill in its fields, and submit it. It combines the form_number/form_name,
set_fields and click methods into one higher level call. Its arguments are
a list of key/value pairs, all of which are optional.
.IP "\(bu" 4
\&\f(CW\*(C`form => $mech\->current_form()\*(C'\fR
.Sp
Specifies the form to be filled and submitted. Defaults to the current form.
.IP "\(bu" 4
\&\f(CW\*(C`fields => \e%fields\*(C'\fR
.Sp
Specifies the fields to be filled in the current form
.IP "\(bu" 4
\&\f(CW\*(C`with_fields => \e%fields\*(C'\fR
.Sp
Probably all you need for the common case. It combines a smart form selector
and data setting in one operation. It selects the first form that contains
all fields mentioned in \e%fields. This is nice because you don't need to
know the name or number of the form to do this.
.Sp
(calls \*(L"$mech\->\fBform_with_fields()\fR\*(R" and \*(L"$mech\->\fBset_fields()\fR\*(R").
.Sp
If you choose this, the form_number, form_name, form_id and fields options
will be ignored.
.ie n .SS """$mech\->set_fields( $name => $value, ... )"""
.el .SS "\f(CW$mech\->set_fields( $name => $value, ... )\fP"
.IX Subsection "$mech->set_fields( $name => $value, ... )"
.Vb 4
\&  $mech\->set_fields(
\&      user => \*(Aqme\*(Aq,
\&      pass => \*(Aqsecret\*(Aq,
\&  );
.Ve
.PP
This method sets multiple fields of the current form. It takes a list of
field name and value pairs. If there is more than one field with the same
name, the first one found is set. If you want to select which of the
duplicate field to set, use a value which is an anonymous array which
has the field value and its number as the 2 elements.
.ie n .SS """$mech\->set_visible( @values )"""
.el .SS "\f(CW$mech\->set_visible( @values )\fP"
.IX Subsection "$mech->set_visible( @values )"
.Vb 1
\&  $mech\->set_visible( $username, $password );
.Ve
.PP
This method sets fields of the current form without having to know their
names. So if you have a login screen that wants a username and password,
you do not have to fetch the form and inspect the source (or use the
\&\f(CW\*(C`mech\-dump\*(C'\fR utility, installed with WWW::Mechanize) to see what
the field names are; you can just say
.PP
.Vb 1
\&  $mech\->set_visible( $username, $password );
.Ve
.PP
and the first and second fields will be set accordingly. The method is
called set_visible because it acts only on visible fields;
hidden form inputs are not considered. It also respects
the respective return value of \f(CW\*(C`\->is_visible()\*(C'\fR for each
field, so hiding of fields through \s-1CSS\s0 affects this too.
.PP
The specifiers that are possible in WWW::Mechanize are not yet supported.
.ie n .SS """$mech\->is_visible( $element )"""
.el .SS "\f(CW$mech\->is_visible( $element )\fP"
.IX Subsection "$mech->is_visible( $element )"
.ie n .SS """$mech\->is_visible(  %options )"""
.el .SS "\f(CW$mech\->is_visible(  %options )\fP"
.IX Subsection "$mech->is_visible( %options )"
.Vb 3
\&  if ($mech\->is_visible( selector => \*(Aq#login\*(Aq )) {
\&      print "You can log in now.";
\&  };
.Ve
.PP
Returns true if the element is visible, that is, it is
a member of the \s-1DOM\s0 and neither it nor its ancestors have
a \s-1CSS\s0 \f(CW\*(C`visibility\*(C'\fR attribute of \f(CW\*(C`hidden\*(C'\fR or
a \f(CW\*(C`display\*(C'\fR attribute of \f(CW\*(C`none\*(C'\fR.
.PP
You can either pass in a \s-1DOM\s0 element or a set of key/value
pairs to search the document for the element you want.
.IP "\(bu" 4
\&\f(CW\*(C`xpath\*(C'\fR \- the XPath query
.IP "\(bu" 4
\&\f(CW\*(C`selector\*(C'\fR \- the \s-1CSS\s0 selector
.IP "\(bu" 4
\&\f(CW\*(C`dom\*(C'\fR \- a \s-1DOM\s0 node
.PP
The remaining options are passed through to either the
/$mech\->xpath or /$mech\->selector method.
.ie n .SS """$mech\->wait_until_invisible( $element )"""
.el .SS "\f(CW$mech\->wait_until_invisible( $element )\fP"
.IX Subsection "$mech->wait_until_invisible( $element )"
.ie n .SS """$mech\->wait_until_invisible( %options )"""
.el .SS "\f(CW$mech\->wait_until_invisible( %options )\fP"
.IX Subsection "$mech->wait_until_invisible( %options )"
.Vb 1
\&  $mech\->wait_until_invisible( $please_wait );
.Ve
.PP
Waits until an element is not visible anymore.
.PP
Takes the same options as \*(L"\->is_visible\*(R" in \f(CW$mech\fR\->is_visible.
.PP
In addition, the following options are accepted:
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR \- the timeout after which the function will \f(CW\*(C`croak\*(C'\fR. To catch
the condition and handle it in your calling program, use an eval block.
A timeout of \f(CW0\fR means to never time out.
.IP "\(bu" 4
\&\f(CW\*(C`sleep\*(C'\fR \- the interval in seconds used to sleep. Subsecond
intervals are possible.
.PP
Note that when passing in a selector, that selector is requeried
on every poll instance. So the following query will work as expected:
.PP
.Vb 1
\&  xpath => \*(Aq//*[contains(text(),"stand by")]\*(Aq
.Ve
.PP
This also means that if your selector query relies on finding
a changing text, you need to pass the node explicitly instead of
passing the selector.
.ie n .SS """$mech\->clickables()"""
.el .SS "\f(CW$mech\->clickables()\fP"
.IX Subsection "$mech->clickables()"
.Vb 4
\&    print "You could click on\en";
\&    for my $el ($mech\->clickables) {
\&        print $el\->{innerHTML}, "\en";
\&    };
.Ve
.PP
Returns all clickable elements, that is, all elements
with an \f(CW\*(C`onclick\*(C'\fR attribute.
.ie n .SS """$mech\->expand_frames( $spec )"""
.el .SS "\f(CW$mech\->expand_frames( $spec )\fP"
.IX Subsection "$mech->expand_frames( $spec )"
.Vb 1
\&  my @frames = $mech\->expand_frames();
.Ve
.PP
Expands the frame selectors (or \f(CW1\fR to match all frames)
into their respective \s-1DOM\s0 document nodes according to the current
document. All frames will be visited in breadth first order.
.PP
This is mostly an internal method.
.SH "IMAGE METHODS"
.IX Header "IMAGE METHODS"
.ie n .SS """$mech\->content_as_png( [$tab, \e%coordinates, \e%target_size ] )"""
.el .SS "\f(CW$mech\->content_as_png( [$tab, \e%coordinates, \e%target_size ] )\fP"
.IX Subsection "$mech->content_as_png( [$tab, %coordinates, %target_size ] )"
.Vb 1
\&    my $png_data = $mech\->content_as_png();
\&
\&    # Create scaled\-down 480px wide preview
\&    my $png_data = $mech\->content_as_png(undef, undef, { width => 480 });
.Ve
.PP
Returns the given tab or the current page rendered as \s-1PNG\s0 image.
.PP
All parameters are optional.
.IP "\(bu" 4
\&\f(CW$tab\fR defaults to the current tab.
.IP "\(bu" 4
If the coordinates are given, that rectangle will be cut out.
The coordinates should be a hash with the four usual entries,
\&\f(CW\*(C`left\*(C'\fR,\f(CW\*(C`top\*(C'\fR,\f(CW\*(C`width\*(C'\fR,\f(CW\*(C`height\*(C'\fR.
.IP "\(bu" 4
The target size of the image can also be given. It defaults to
the size of the image. The allowed parameters in the hash are
.Sp
\&\f(CW\*(C`scalex\*(C'\fR, \f(CW\*(C`scaley\*(C'\fR \- for specifying the scale, default is 1.0 in each direction.
.Sp
\&\f(CW\*(C`width\*(C'\fR, \f(CW\*(C`height\*(C'\fR \- for specifying the target size
.Sp
If you want the resulting image to be 480 pixels wide, specify
.Sp
.Vb 1
\&    { width => 480 }
.Ve
.Sp
The height will then be calculated from the ratio of original width to
original height.
.PP
This method is specific to WWW::Mechanize::Firefox.
.PP
Currently, the data transfer between Firefox and Perl
is done Base64\-encoded. It would be beneficial to find what's
necessary to make \s-1JSON\s0 handle binary data more gracefully.
.ie n .SS """$mech\->element_as_png( $element )"""
.el .SS "\f(CW$mech\->element_as_png( $element )\fP"
.IX Subsection "$mech->element_as_png( $element )"
.Vb 2
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my $i_want_this = $mech\->element_as_png($shiny);
.Ve
.PP
Returns \s-1PNG\s0 image data for a single element
.ie n .SS """$mech\->element_coordinates( $element )"""
.el .SS "\f(CW$mech\->element_coordinates( $element )\fP"
.IX Subsection "$mech->element_coordinates( $element )"
.Vb 3
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my ($pos) = $mech\->element_coordinates($shiny);
\&    print $pos\->{left},\*(Aq,\*(Aq, $pos\->{top};
.Ve
.PP
Returns the page-coordinates of the \f(CW$element\fR
in pixels as a hash with four entries, \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR.
.PP
This function might get moved into another module more geared
towards rendering \s-1HTML.\s0
.SH "COOKIE HANDLING"
.IX Header "COOKIE HANDLING"
Firefox cookies will be read through HTTP::Cookies::MozRepl. This is
relatively slow currently.
.SH "INCOMPATIBILITIES WITH WWW::Mechanize"
.IX Header "INCOMPATIBILITIES WITH WWW::Mechanize"
There are many incompatibilities with WWW::Mechanize, but enough
similarities to warrant the same namespace. The main thing is
that only the most needed WWW::Mechanize methods
have been implemented by me so far.
.SS "Link attributes"
.IX Subsection "Link attributes"
In Firefox, the \f(CW\*(C`name\*(C'\fR attribute of links seems always
to be present on links, even if it's empty. This is in
difference to WWW::Mechanize, where the \f(CW\*(C`name\*(C'\fR attribute
can be \f(CW\*(C`undef\*(C'\fR.
.SS "Frame tags"
.IX Subsection "Frame tags"
Firefox is much less lenient than WWW::Mechanize when it comes
to \s-1FRAME\s0 tags. A page will not contain a \s-1FRAME\s0 tag if it contains
content other than the \s-1FRAMESET.\s0 WWW::Mechanize has no such restriction.
.SS "Unsupported Methods"
.IX Subsection "Unsupported Methods"
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_inputs\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_submits\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_image\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.SS "Functions that will likely never be implemented"
.IX Subsection "Functions that will likely never be implemented"
These functions are unlikely to be implemented because
they make little sense in the context of Firefox.
.IP "\(bu" 4
\&\f(CW\*(C`\->clone\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->credentials( $username, $password )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->get_basic_credentials( $realm, $uri, $isproxy )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->clear_credentials()\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->put\*(C'\fR
.Sp
I have no use for it
.IP "\(bu" 4

.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Add \f(CW\*(C`limit\*(C'\fR parameter to \f(CW\*(C`\->xpath()\*(C'\fR to allow an early exit-case
when searching through frames.
.IP "\(bu" 4
Implement download progress via \f(CW\*(C`nsIWebBrowserPersist.progressListener\*(C'\fR
and our own \f(CW\*(C`nsIWebProgressListener\*(C'\fR.
.IP "\(bu" 4
Rip out parts of Test::HTML::Content and graft them
onto the \f(CW\*(C`links()\*(C'\fR and \f(CW\*(C`find_link()\*(C'\fR methods here.
Firefox is a conveniently unified XPath engine.
.Sp
Preferrably, there should be a common \s-1API\s0 between the two.
.IP "\(bu" 4
Spin off XPath queries (\f(CW\*(C`\->xpath\*(C'\fR) and \s-1CSS\s0 selectors (\f(CW\*(C`\->selector\*(C'\fR)
into their own Mechanize plugin(s).
.SH "INSTALLATION"
.IX Header "INSTALLATION"
See WWW::Mechanize::Firefox::Troubleshooting.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The MozRepl Firefox plugin at <http://wiki.github.com/bard/mozrepl>
.IP "\(bu" 4
WWW::Mechanize \- the module whose \s-1API\s0 grandfathered this module
.IP "\(bu" 4
WWW::Scripter \- another WWW::Mechanize\-workalike with Javascript support
.IP "\(bu" 4
<https://developer.mozilla.org/En/FUEL/Window> for \s-1JS\s0 events relating to tabs
.IP "\(bu" 4
<https://developer.mozilla.org/en/Code_snippets/Tabbed_browser#Reusing_tabs>
for more tab info
.IP "\(bu" 4
<https://developer.mozilla.org/en/Document_Loading_\-_From_Load_Start_to_Finding_a_Handler>
for information on how to possibly override the \*(L"Save As\*(R" dialog
.IP "\(bu" 4
<http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox\-driver/extension/components/promptService.js>
for information on how to override a lot of other prompts (like proxy etc.)
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<http://github.com/Corion/www\-mechanize\-firefox>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is
<http://perlmonks.org/>.
.SH "TALKS"
.IX Header "TALKS"
I've given two talks about this module at Perl conferences:
.PP
German Perl Workshop, German <http://corion.net/talks/WWW-Mechanize-FireFox/www-mechanize-firefox.html>
.PP
YAPC::Europe 2010, English <http://corion.net/talks/WWW-Mechanize-FireFox/www-mechanize-firefox.en.html>
.SH "ARTICLES"
.IX Header "ARTICLES"
<http://perltricks.com/article/138/2014/12/8/Controlling\-Firefox\-from\-Perl>
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-Firefox>
or via mail to www\-mechanize\-firefox\-Bugs@rt.cpan.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2009\-2013 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
