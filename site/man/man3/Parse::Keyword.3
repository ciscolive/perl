.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Parse::Keyword 3"
.TH Parse::Keyword 3 "2017-02-02" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Keyword \- DEPRECATED: write syntax extensions in perl
.SH "VERSION"
.IX Header "VERSION"
version 0.09
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Parse::Keyword { try => \e&try_parser };
\&  use Exporter \*(Aqimport\*(Aq;
\&  our @EXPORT = \*(Aqtry\*(Aq;
\&
\&  sub try {
\&      my ($try, $catch) = @_;
\&      &Try::Tiny::try($try, ($catch ? (&Try::Tiny::catch($catch)) : ()));
\&  }
\&
\&  sub try_parser {
\&      lex_read_space;
\&      die "syntax error" unless lex_peek eq \*(Aq{\*(Aq;
\&      my $try = parse_block;
\&      lex_read_space;
\&
\&      my $catch;
\&      if (lex_peek(6) =~ /^catch\eb/) {
\&          lex_read(5);
\&          lex_read_space;
\&          die "syntax error" unless lex_peek eq \*(Aq{\*(Aq;
\&          $catch = parse_block;
\&      }
\&
\&      return (sub { ($try, $catch) }, 1);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1DO NOT USE\s0!"
.IX Subsection "DO NOT USE!"
This module has fundamental errors in the way it handles closures, which are
not fixable. Runtime keywords will never be able to work properly with the
current design of this module. There are certain cases where this module is
still safe to use (keywords that only have effect at compile time, or keywords
that never call any of the \f(CW\*(C`parse_*\*(C'\fR functions), but that is limiting enough
to make this module mostly worthless, and I likely won't be continuing to
maintain it. Be warned!
.PP
\&\fB\s-1NOTE:\s0 The \s-1API\s0 of this module is still in flux. I may make
backwards-incompatible changes as I figure out how it should look.\fR
.PP
This module allows you to write keyword-based syntax extensions without
requiring you to write any C code yourself. It is similar to Devel::Declare,
except that it uses the Perl parser \s-1API\s0 introduced in Perl 5.14 in order to
allow you to parse parts of things using perl's own parser, rather than having
to fake it with balanced brace matching or other fragile things.
.PP
To use this module, you should pass a hashref to the \f(CW\*(C`use\*(C'\fR statement. The keys
of this hashref are subroutines in the current package which should have
special parsing behavior attached to them, and the values are coderefs which
should be used to implement the custom parsing behavior.
.PP
The parsing coderefs will be called when perl encounters a call to the keyword
that you attached custom parsing to. The current parser state will be directly
after parsing the keyword. The parser function will receive the name of the
keyword as a parameter, and should return a coderef which, when called at
runtime, will produce the arguments to the function. In addition, if your
keyword should be parsed as a statement (for instance, if you don't want to
require a trailing semicolon), you can return a second, true value.
.PP
In order to actually handle the parsing itself, this module also exports
various parsing functions, which you can call. See below for details.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "lex_peek($n)"
.IX Subsection "lex_peek($n)"
Returns a string consisting of the next \f(CW$n\fR characters in the input (or next
one character, if \f(CW$n\fR isn't given). This string may be shorter than \f(CW$n\fR
characters if there are fewer than \f(CW$n\fR characters remaining to read. The
current position in the buffer to be parsed is not moved. See \*(L"PL_parser\->linestr\*(R" in perlapi and \*(L"lex_next_chunk\*(R" in perlapi for more
information.
.PP
\&\s-1NOTE:\s0 This function currently only returns text that is on the current line,
unless the current line has been fully read (via \f(CW\*(C`lex_read\*(C'\fR). This is due to a
bug in perl itself, and this restriction will hopefully be lifted in a future
version of this module, so don't depend on it. See the \*(L"\s-1BUGS\*(R"\s0 section for
more information.
.SS "lex_read($n)"
.IX Subsection "lex_read($n)"
Moves the current position in the parsing buffer forward by \f(CW$n\fR characters
(or one character, if \f(CW$n\fR isn't given). See \*(L"lex_read_to\*(R" in perlapi for more
details.
.SS "lex_read_space"
.IX Subsection "lex_read_space"
Moves the current position in the parsing buffer forward past any whitespace or
comments. See \*(L"lex_read_space\*(R" in perlapi for more details.
.SS "lex_stuff($str)"
.IX Subsection "lex_stuff($str)"
Inserts \f(CW$str\fR into the current parsing buffer at the current location, so
that future calls to \f(CW\*(C`lex_peek\*(C'\fR and such will see it. Note that this does not
move the current position in the parsing buffer, so multiple calls to
\&\f(CW\*(C`lex_stuff\*(C'\fR at the same location will end up inserted into the buffer in
reverse order. See \*(L"lex_stuff_sv\*(R" in perlapi for more information.
.SS "parse_block, parse_stmtseq, parse_fullstmt, parse_barestmt, parse_fullexpr, parse_listexpr, parse_termexpr, parse_arithexpr"
.IX Subsection "parse_block, parse_stmtseq, parse_fullstmt, parse_barestmt, parse_fullexpr, parse_listexpr, parse_termexpr, parse_arithexpr"
These functions parse the specified amount of Perl code, and return a coderef
which will evaluate that code when executed. They each take an optional boolean
parameter that should be true if you are creating a subroutine which will be
going in the symbol table, or in other more obscure situations involving
closures (the CVf_ANON flag will be set on the created coderef if this is not
passed \- see \f(CW\*(C`t/unavailable.t\*(C'\fR in this distribution). See
\&\*(L"parse_block\*(R" in perlapi, \*(L"parse_stmtseq\*(R" in perlapi, \*(L"parse_fullstmt\*(R" in perlapi,
\&\*(L"parse_barestmt\*(R" in perlapi, \*(L"parse_fullexpr\*(R" in perlapi, parse_listexpr,
parse_termexpr, and \*(L"parse_arithexpr\*(R" in perlapi for more details.
.SS "compiling_package"
.IX Subsection "compiling_package"
Returns the name of the package that the keyword which is currently being
parsed was called in. This should be used instead of \f(CW\*(C`caller\*(C'\fR if you want to
do something like install a subroutine in the calling package.
.SH "BUGS"
.IX Header "BUGS"
Peeking into the next line is currently (as of 5.19.2) broken in perl if the
current line hasn't been fully consumed. This module works around this by just
not doing that. This shouldn't be an issue for the most part, since it will
only come up if you need to conditionally parse something based on a token that
can span multiple lines. Just keep in mind that if you're reading in a large
chunk of text, you'll need to alternate between calling \f(CW\*(C`lex_peek\*(C'\fR and
\&\f(CW\*(C`lex_read\*(C'\fR, or else you'll only be able to see text on the current line.
.PP
This module also inherits the limitation from Devel::CallParser that custom
parsing is only triggered if the keyword is called by its unqualified name
(\f(CW\*(C`try\*(C'\fR, not \f(CW\*(C`Try::try\*(C'\fR, for instance).
.PP
This module doesn't yet work with lexical subs, such as via
Exporter::Lexical. This will hopefully be fixed in the future, but will
likely require modifications to perl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::CallParser
.PP
Keyword::API
.PP
Devel::Declare
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find this documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Parse::Keyword
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
MetaCPAN
.Sp
<https://metacpan.org/release/Parse\-Keyword>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Parse\-Keyword>
.IP "\(bu" 4
Github
.Sp
<https://github.com/haarg/Parse\-Keyword>
.SH "AUTHOR"
.IX Header "AUTHOR"
Jesse Luehrs <doy@tozt.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Jesse Luehrs.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
