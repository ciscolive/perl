.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Trace::Manual 3"
.TH Log::Trace::Manual 3 "2005-11-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Trace::Manual \- A guide to using Log::Trace
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a brief guide to how you can use the Log::Trace module in your scripts
and modules.  The \f(CW\*(C`Log::Trace\*(C'\fR documentation has a comprehensive list of
options.
.SH "The basics"
.IX Header "The basics"
You can enable tracing by specifying the tracing target via the '\f(CW\*(C`use\*(C'\fR'
statement or at runtime via the \f(CW\*(C`import()\*(C'\fR method.  In most cases, you'll want
to keep the code that enables tracing in a single point, usually the main
script of your application.  In general, modules should avoid directly
setting tracing options.
.SS "using Log::Trace in your scripts"
.IX Subsection "using Log::Trace in your scripts"
Here's a slightly contrived example which demonstrates the \f(CW\*(C`TRACE\*(C'\fR, \f(CW\*(C`TRACEF\*(C'\fR,
\&\f(CW\*(C`DUMP\*(C'\fR and \f(CW\*(C`TRACE_HERE\*(C'\fR functions:
.PP
.Vb 4
\&        #!/usr/bin/perl \-w
\&        use strict;
\&        use Another::Module;
\&        use Log::Trace log => \*(Aq/var/log/myapp.log\*(Aq;
\&
\&        TRACE("\-\-\-\-\-\-\-\- Starting archiver \-\-\-\-\-\-\-\-\-");
\&        TRACEF("We are going to try to archive %d items", scalar @ARGV);
\&        DUMP("List of things to archive", \e@ARGV);
\&        archive_em($_) foreach(@ARGV);
\&
\&        sub archive_em {
\&                TRACE_HERE();
\&                my $thing = shift;
\&                unless (Another::Module::check_safe($thing)) {
\&                        warn "bad chars in: $thing";
\&                        return;
\&                }
\&                rename $thing, $thing.".archive" or warn "Couldn\*(Aqt archive $thing: $!";
\&                TRACE("Tried to archive $thing");
\&        }
.Ve
.PP
Note the way \f(CW\*(C`Log::Trace\*(C'\fR is imported.  The import list controls where the
output of the four tracing functions goes.  Instead we could have done:
.PP
.Vb 1
\&        use Log::Trace qw(warn);
.Ve
.PP
and the trace output would have gone to \s-1STDERR.\s0
.SS "Using Log::Trace with modules"
.IX Subsection "Using Log::Trace with modules"
In the previous example, tracing was enabled only in the main script.  Now
we'll see how to enable tracing in \f(CW\*(C`Another::Module\*(C'\fR at the same time.
.PP
First, \f(CW\*(C`Another::Module\*(C'\fR needs to define a \f(CW\*(C`TRACE\*(C'\fR subroutine.  It may also
define \f(CW\*(C`TRACEF\*(C'\fR, \f(CW\*(C`TRACE_HERE\*(C'\fR and \f(CW\*(C`DUMP\*(C'\fR stubs.  It can do that simply by
using \f(CW\*(C`Log::Trace\*(C'\fR.  However, if \f(CW\*(C`Another::Module\*(C'\fR defines its own stub
tracing functions, we can remove the dependency on \f(CW\*(C`Log::Trace\*(C'\fR.
.PP
.Vb 1
\&        package Another::Module;
\&
\&        sub check_safe {my_routine {
\&                my $filename = shift;
\&                TRACE("Checking that \*(Aq$filename\*(Aq has safe characters");
\&                return $filename =~ /^([\ew.\e\-/]+)$/
\&        }
\&
\&        sub my_other_routine {
\&                TRACE_HERE();
\&        }
\&
\&        # tracing stubs
\&        sub TRACE {}
\&        sub TRACE_HERE {}
.Ve
.PP
Now, in the main script, we can change the '\f(CW\*(C`use\*(C'\fR' statement so tracing will
be enabled in \f(CW\*(C`Another::Module\*(C'\fR:
.PP
.Vb 1
\&        use Log::Trace log => \*(Aq/var/log/myapp.log\*(Aq, {Deep => 1};
.Ve
.PP
By default, the \f(CW\*(C`Deep\*(C'\fR option will force \f(CW\*(C`Log::Trace\*(C'\fR to export tracing
functions to any modules that define a \f(CW\*(C`TRACE\*(C'\fR subroutine.  That includes
modules that are not directly used by the main script.  But this behaviour can
be relaxed or tightened with other options.  See \*(L"Deep import\*(R" for examples.
.PP
Adding \f(CW\*(C`TRACE\*(C'\fR and other stub functions to your module is an \fIInterface Contract\fR
between your module and Log::Trace (in some software circles this might be given a name such as
ISupportsTracing).  Of course you can write other code that takes advantage of this
interface completely independent of Log::Trace, e.g.
.PP
.Vb 4
\&        use Another::Module;
\&        if($ENV{DEBUG}) {
\&                *Another::Module::TRACE = sub {print "TRACE: ".join("\et",@_)."\en"};
\&        }
.Ve
.SS "Error handling"
.IX Subsection "Error handling"
Since \f(CW\*(C`Log::Trace\*(C'\fR is designed with debugging in mind, all tracing failures
are non-fatal, so allowing normal execution to continue.  However, Log::Trace
will report to \s-1STDERR\s0 that a problem has occurred.
.PP
For example, this code:
.PP
.Vb 3
\&        use Log::Trace file => \*(Aq/myapp.log\*(Aq;
\&        TRACE(\*(AqRunning\*(Aq);
\&        print "Hello World!\en";
.Ve
.PP
Will produce this output:
.PP
.Vb 2
\&        Log::Trace: Cannot open /myapp.log : Permission denied at lib/Log/Trace.pm line <nnn>.
\&        Hello World!
.Ve
.SH "Cookbook"
.IX Header "Cookbook"
.SS "Enabling tracing on the command line"
.IX Subsection "Enabling tracing on the command line"
You can invoke tracing on the command line:
.PP
.Vb 3
\&        perl \-MLog::Trace=print \-e "TRACE(\*(Aqhello\*(Aq)"
\&        perl \-MLog::Trace=warn \-e "TRACE(\*(Aqhello\*(Aq)"
\&        perl \-MLog::Trace=log,test.log \-e "TRACE(\*(Aqhello\*(Aq)"
.Ve
.PP
However you can't apply this approach to scripts that use \f(CW\*(C`Log::Trace\*(C'\fR or
define a \f(CW\*(C`TRACE\*(C'\fR stub as these will clobber \f(CW*main::TRACE\fR set up by \-M when
they are compiled.  Fortunately it is straightforward to write your
command-line scripts so you can, for example, get trace output with \-t and deep
trace output with \-T:
.PP
.Vb 3
\&        use Log::Trace;
\&        use Getopt::Std;
\&        use MyModule;
\&
\&        use vars qw($opt_t $opt_T);
\&        getopts("tT");
\&
\&        # tracing
\&        import Log::Trace \*(Aqprint\*(Aq if $opt_t;
\&        import Log::Trace \*(Aqprint\*(Aq => {Deep => 1} if $opt_T;
\&
\&        do_something_involving_tracing();
.Ve
.SS "Sending \s-1TRACE\s0 output to browser in \s-1CGI\s0"
.IX Subsection "Sending TRACE output to browser in CGI"
Whilst tracing to a log file or \f(CW\*(C`STDERR\*(C'\fR is tolerable for CGIs, it's often far
more convenient to return the tracing information back to the browser of the
client-side developer.
.PP
.Vb 1
\&        use CGI;
\&
\&        use constant DEV_SERVER => 1;
\&
\&        my $trace_buffer;
\&        if(DEV_SERVER && CGI::param(\*(AqTracing\*(Aq)) {
\&                require Log::Trace;
\&                import Log::Trace buffer => \e$trace_buffer, {Deep => 1};
\&        }
\&
\&        my $output = do_everything();
\&
\&        print CGI::header();
\&        print $output;
\&        if (DEV_SERVER && $trace_buffer)
\&        {
\&                print "\en\en", "<pre>", CGI::escapeHTML($trace_buffer), "</pre>";
\&        }
.Ve
.PP
You should remember to change the \f(CW\*(C`DEV_SERVER\*(C'\fR constant when releasing the \s-1CGI\s0
to a production environment.
.SS "Log levels"
.IX Subsection "Log levels"
\&\f(CW\*(C`Log::Trace\*(C'\fR can filter the tracing output by referring to the logging level.
The logging level is defined when you enable tracing.  \f(CW\*(C`Log::Trace\*(C'\fR doesn't
impose any conventions on the levels.  The default levels implementation
requires that the levels be numeric, but that can be overriden.
.PP
In the simplest case, you can specify the level as a threshold value:
.PP
.Vb 1
\&        use Log::Trace print => {Level => 3};
.Ve
.PP
In this example, all trace messages at level \f(CW3\fR or below will be output.
.PP
You can also specify a list of valid levels:
.PP
.Vb 1
\&        use Log::Trace print => {Level => [0 .. 3, 7]};
.Ve
.PP
All the tracing functions accept a hash as an optional first parameter where
you can specify the level for that trace message.  E.g.:
.PP
.Vb 4
\&        TRACE({Level => 4}, "This is a warning");
\&        TRACEF({Level => 6}, "%d items found", scalar @items);
\&        TRACE_HERE({Level => 10});
\&        DUMP({Level => 8}, \*(AqRetrieved data\*(Aq, \e%data);
.Ve
.PP
\&\f(CW\*(C`DUMP\*(C'\fR is designed to accept a hash as its first parameter, but there may be
cases where you wish to dump a hash that contains a \f(CW\*(C`Level\*(C'\fR key.  In those
cases, you can take advantage of the return value of \f(CW\*(C`DUMP()\*(C'\fR:
.PP
.Vb 2
\&        my $dumped = DUMP({Level => 1, Health => \*(Aq0.68\*(Aq});
\&        TRACE({Level => 8}, \*(AqGame stats\*(Aq, $dumped);
.Ve
.PP
If you specify a tracing level when you enable \f(CW\*(C`Log::Trace\*(C'\fR, then tracing
messages that do not specify a level will not be output, unless you include
\&\f(CW\*(C`undef\*(C'\fR in the trace levels:
.PP
.Vb 4
\&        use Log::Trace print => {Level => [3, undef]};
\&        TRACE("This is level undef, and will be output");
\&        TRACE({Level => 3}, "This will also be output");
\&        TRACE({Level => 8}, "... but this won\*(Aqt");
.Ve
.PP
Here are some sample tracing levels (borrowed from Log::Agent) which you can
use as a guide:
.PP
.Vb 8
\&        0       emergency
\&        1       alert
\&        2       critical
\&        3       error
\&        4       warning
\&        6       notice
\&        8       info
\&        10      debug
.Ve
.SS "Fine-tuning deep import"
.IX Subsection "Fine-tuning deep import"
Occasionally you won't want to see the trace output from \s-1ALL\s0 your modules in
your application.  For example your application may give a module a huge data
structure or call it in a long loop.  The \f(CW\*(C`Exclude\*(C'\fR option allows you to mask
out one or more modules.
.PP
.Vb 1
\&        use Log::Trace warn => {\*(AqDeep\*(Aq => 1, \*(AqExclude\*(Aq => \*(AqMyVerboseModule\*(Aq};
.Ve
.PP
or
.PP
.Vb 1
\&        use Log::Trace warn => {\*(AqDeep\*(Aq => 1, \*(AqExclude\*(Aq => [\*(AqMyVerboseModule\*(Aq, \*(AqAnother::Module\*(Aq]};
.Ve
.PP
Conversely you can use an opt-in approach rather than opt-out.  The \f(CW\*(C`Match\*(C'\fR
option allows a regular expression to be used to select which packages are
initialised by Log::Trace.  For example:
.PP
.Vb 1
\&        use Log::Trace print => {\*(AqDeep\*(Aq => 1, \*(AqMatch\*(Aq => qr/^MySubSystem::/};
.Ve
.SH "Advanced features"
.IX Header "Advanced features"
.SS "Issues with the order of importing"
.IX Subsection "Issues with the order of importing"
When the Deep or Everywhere options are used, Log::Trace is imported into all the packages which have been compiled so far.
.PP
.Vb 3
\&        use Package::Foo;
\&        use Log::Trace (\*(Aqprint\*(Aq => {Deep => 1});
\&        use Package::Bar; #Compiled after Log::Trace is imported
.Ve
.PP
In this example, the \s-1TRACE\s0 function in Package::Bar won't be overridden.  It's trivial to swap the order in the example above
so that Log::Trace is the last module used, but suppose you have a module (such as a factory) that loads others on demand:
.PP
.Vb 9
\&        package MyApp::Reader;
\&        sub new {
\&                my $package = shift;
\&                my $type = shift;
\&                die unless($type =~ /^MyApp::Reader::\ew+$/);
\&                eval "require $type";
\&                die($@) if($@);
\&                return $type\->new(@_);
\&        }
.Ve
.PP
How do you ensure Log::Trace gets imported into the backend MyApp::Reader::* modules (without polluting
all your modules with Log::Trace::import calls)?
.IP "Using the (experimental) AutoImport feature" 4
.IX Item "Using the (experimental) AutoImport feature"
The AutoImport feature will override \f(CW\*(C`CORE::require\*(C'\fR so that from now on any modules
that are loaded will have the Log::Trace import run against them:
.Sp
.Vb 1
\&        use Log::Trace(\*(Aqlog\*(Aq => \*(Aq/var/log/myapp.log\*(Aq, {\*(AqDeep\*(Aq => 1, \*(AqAutoImport\*(Aq => 1});
.Ve
.Sp
This only works with recent versions of perl (see the \s-1ENVIRONMENT NOTES\s0 in Log::Trace).
.IP "Getting the factory to wire the components it produces" 4
.IX Item "Getting the factory to wire the components it produces"
A more \*(L"low-tech\*(R" approach that works with all versions of perl is to get the factory
to attach the stub functions of the modules it loads to whatever its own stub functions
have been wired to by the caller.
.Sp
.Vb 7
\&        package MyApp::Reader;
\&        sub new {
\&                my $package = shift;
\&                my $type = shift;
\&                die unless($type =~ /^MyApp::Reader::\ew+$/);
\&                eval "require $type";
\&                die($@) if($@);
\&
\&                # Wire the component we\*(Aqve created into whatever
\&                # our TRACE etc function has been wired to
\&                *{"$type\e::TRACE"} = \e&MyApp::Reader::TRACE;
\&                *{"$type\e::DUMP"} = \e&MyApp::Reader::DUMP;
\&
\&                return $type\->new(@_);
\&        }
.Ve
.SS "Custom \s-1TRACE\s0 functions"
.IX Subsection "Custom TRACE functions"
If \f(CW\*(C`STDOUT\*(C'\fR, \f(CW\*(C`STDERR\*(C'\fR, \f(CW\*(C`syslog\*(C'\fR, a file, a file handle, or a buffer is not
to your liking then the custom method is for you.
.PP
Suppose you want to send your Log::Trace output into a database:
.PP
.Vb 2
\&        our $sth;
\&        $sth = setup_logging_statement();
\&
\&        use Log::Trace custom => \e&log_to_database;
\&
\&        sub log_to_database {
\&
\&                #TRACE can get any number of arguments
\&                my $message = join(",", @_);
\&
\&                $sth\->execute($message);
\&
\&        }
.Ve
.SS "Controlling \s-1DUMP\s0 output"
.IX Subsection "Controlling DUMP output"
By default, Data::Dumper is used with a fixed set of options for \s-1DUMP\s0 output.
You can choose a different serialiser using the \f(CW\*(C`Dumper\*(C'\fR option:
.PP
.Vb 1
\&        import Log::Trace(\*(Aqprint\*(Aq => {Dumper => "YAML"}});
.Ve
.PP
Where the string refers to a Data::Serializer::* backend.
You can also control the options passed to the Data::Serializer backend (and thus customise the \s-1DUMP\s0 output)
by passing a hashref of Data::Serializer contructor options:
.PP
.Vb 6
\&        import Log::Trace(\*(Aqprint\*(Aq => {Dumper => {
\&                serializer => \*(AqXML::Dumper\*(Aq,
\&                options => {
\&                        dtd => \*(Aqpath/to/my.dtd\*(Aq                 
\&                }
\&        }});
.Ve
.PP
At the time of writing, not all the configuration options of the underlying serialisation modules are exposed via their Data::Serializer wrappers.
If you find this a limitation, please contribute patches to extend these modules as this will benefit a number of other modules that make use
of the Data::Serializer \s-1API.\s0
.SS "Execution path vs. profiling"
.IX Subsection "Execution path vs. profiling"
You can use the \f(CW\*(C`AllSubs\*(C'\fR tracing option to trace the execution path through each
subroutine.  By default \f(CW\*(C`Log::Trace\*(C'\fR only wraps each subroutine in packages
with \f(CW\*(C`TRACE\*(C'\fR defined.  You can force it to do it to all modules using the
\&\f(CW\*(C`Everywhere\*(C'\fR option.  The following:
.PP
.Vb 3
\&        use Data::Dumper;
\&        use Log::Trace print => {AllSubs => 1, Verbose => 1, Everywhere => 1, Exclude => \*(AqConfig\*(Aq};
\&        Data::Dumper\->Dumpperl([[4]]);
.Ve
.PP
generates the output:
.PP
.Vb 10
\&        main::_\|_ANON_\|_ (3) :: Data::Dumper::Dumpperl(  )
\&        Data::Dumper::Dumpperl (3) :: Data::Dumper::new(  )
\&        Data::Dumper::Dumpperl (3) :: Data::Dumper::_dump( Data::Dumper, ... )
\&        Data::Dumper::_dump (205) :: overload::StrVal( ARRAY, ... )
\&        overload::StrVal (239) :: overload::OverloadedStringify( ARRAY, ... )
\&        overload::OverloadedStringify (92) :: overload::mycan(  )
\&        overload::OverloadedStringify (92) :: overload::ov_method(      )
\&        overload::OverloadedStringify (92) :: overload::mycan(  )
\&        overload::OverloadedStringify (92) :: overload::ov_method(      )
\&        overload::OverloadedStringify (92) :: overload::mycan(  )
\&        overload::OverloadedStringify (92) :: overload::ov_method(      )
\&        overload::OverloadedStringify (92) :: overload::mycan(  )
\&        overload::OverloadedStringify (92) :: overload::ov_method(      )
\&        Data::Dumper::_dump (205) :: Data::Dumper::_dump( Data::Dumper, ... )
\&        (eval) (0) :: Data::Dumper::DESTROY( Data::Dumper, ... )
.Ve
.SS "Targeting one module"
.IX Subsection "Targeting one module"
You may wonder \*(L"How do I trace what's going on in module Acme::Foo I downloaded from \s-1CPAN\s0 that isn't Log::Trace enabled?\*(R".
Assuming the module doesn't have any other kind of tracing that you can hook into, all you can do is use the \f(CW\*(C`AllSubs\*(C'\fR approach.
Assuming that's \s-1OK,\s0 you can restrict this to just the offending module with:
.PP
.Vb 1
\&        use Log::Trace print => {AllSubs => 1, Everywhere => 1, Match => qr/^Acme:Foo$/};
.Ve
.SS "Avoiding performance penalty"
.IX Subsection "Avoiding performance penalty"
Although the trace stubs don't do anything, they do incur a small function call
overhead.  If this performance hit is unacceptable, you can use a constant to
enable/disable all the \f(CW\*(C`Log::Trace\*(C'\fR statements in your code.  The test for the
constant value will be optimised out at compile time so no runtime overhead is
incurred if the constant has a false value:
.PP
.Vb 1
\&        package ThrashMe;
\&
\&        use constant TRACING_ENABLED => 1; #Set to zero to optimise
\&
\&        sub performance_critical {
\&                TRACE("this may slow things down") if(TRACING_ENABLED);
\&                do_stuff();
\&        }
\&
\&        sub TRACE{}
\&
\&        1;
.Ve
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Revision:\fR 1.9 $
