.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tree::Ops 3"
.TH Tree::Ops 3 "2020-11-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Tree::Ops \- Tree operations.
.SH "Synopsis"
.IX Header "Synopsis"
Create a tree:
.PP
.Vb 1
\&  my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&
\&  for(1..2)
\&   {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&    $a\->single(\*(Aqc\*(Aq, "C$_");
\&    $a\->close;
\&   }
\&  $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&  $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
.Ve
.PP
Print it:
.PP
.Vb 10
\&  is_deeply $a\->print, <<END;
\&Key    Value
\&a      A
\&  b    B1
\&    c  C1
\&  b    B2
\&    c  C2
\&  d    D
\&  e    E
\&END
.Ve
.PP
Navigate through the tree:
.PP
.Vb 2
\&  is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&  is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
.Ve
.PP
Traverse the tree:
.PP
.Vb 1
\&  is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
.Ve
.PP
Select items from the tree:
.PP
.Vb 3
\&  is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&  is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&  is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
.Ve
.PP
Reorganize the tree:
.PP
.Vb 11
\&  $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&  is_deeply $a\->print, <<END;
\&Key      Value
\&a        A
\&  b      B1
\&    c    C1
\&  b      B2
\&    d    D
\&      c  C2
\&    e    E
\&END
.Ve
.SH "Description"
.IX Header "Description"
Tree operations.
.PP
Version 20201030.
.PP
The following sections describe the methods in each functional area of this
module.  For an alphabetic listing of all methods by name see Index.
.SH "Build"
.IX Header "Build"
Create a tree.  There is no implicit ordering applied to the tree, the relationships between parents and children within the tree are as established by the user and can be reorganized at will using the methods in this module.
.ie n .SS "new($key, $value)"
.el .SS "new($key, \f(CW$value\fP)"
.IX Subsection "new($key, $value)"
Create a new child optionally recording the specified key or value.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $key       Key
\&  2  $value     Value
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;  # XXXXXXX
\&
\&    for(1..2)
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&      $a\->single(\*(Aqc\*(Aq, "C$_");
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;
\&      $a\->close;
\&     }
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.PP
This is a static method and so should either be imported or invoked as:
.PP
.Vb 1
\&  Tree::Ops::new
.Ve
.SS "activeScope($tree)"
.IX Subsection "activeScope($tree)"
Locate the active scope in a tree.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&    for(1..2)
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&      $a\->single(\*(Aqc\*(Aq, "C$_");
\&  
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;  # XXXXXXX
\&
\&      $a\->close;
\&     }
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.ie n .SS "open($tree, $key, $value)"
.el .SS "open($tree, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "open($tree, $key, $value)"
Add a child and make it the currently active scope into which new children will be added.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $key       Key
\&  3  $value     Value to be recorded in the interior child being opened
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&    for(1..2)
\&  
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");  # XXXXXXX
\&
\&      $a\->single(\*(Aqc\*(Aq, "C$_");
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;
\&      $a\->close;
\&     }
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.SS "close($tree)"
.IX Subsection "close($tree)"
Close the current scope returning to the previous scope.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&    for(1..2)
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&      $a\->single(\*(Aqc\*(Aq, "C$_");
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;
\&  
\&      $a\->close;  # XXXXXXX
\&
\&     }
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.ie n .SS "single($tree, $key, $value)"
.el .SS "single($tree, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "single($tree, $key, $value)"
Add one child in the current scope.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $key       Key
\&  3  $value     Value to be recorded in the child being created
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&    for(1..2)
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&  
\&      $a\->single(\*(Aqc\*(Aq, "C$_");  # XXXXXXX
\&
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;
\&      $a\->close;
\&     }
\&  
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);  # XXXXXXX
\&
\&  
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.ie n .SS "include($tree, $include)"
.el .SS "include($tree, \f(CW$include\fP)"
.IX Subsection "include($tree, $include)"
Include the specified tree in the currently open scope.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree being built
\&  2  $include   Tree to include
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($i) = fromLetters \*(Aqb(cd)\*(Aq;
\&  
\&    my $a = Tree::Ops::new \*(AqA\*(Aq;
\&       $a\->open (\*(AqB\*(Aq);
\&  
\&       $a\->include($i);  # XXXXXXX
\&
\&       $a\->close;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  A
\&    B
\&      a
\&        b
\&          c
\&          d
\&  END
.Ve
.SS "fromLetters($letters)"
.IX Subsection "fromLetters($letters)"
Create a tree from a string of letters returning the children created in alphabetic order  \- useful for testing.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $letters   String of letters and ( ).
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a) = fromLetters(q(bc(d)e));  # XXXXXXX
\&
\&  
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&    c
\&      d
\&    e
\&  END
.Ve
.SH "Navigation"
.IX Header "Navigation"
Navigate through a tree.
.SS "first($parent)"
.IX Subsection "first($parent)"
Get the first child under the specified parent.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&    is_deeply $c\->parent,   $b;
\&  
\&    is_deeply $a\->first,    $b;  # XXXXXXX
\&
\&    is_deeply $a\->last,     $d;
\&    is_deeply $e\->next,     $f;
\&    is_deeply $f\->prev,     $e;
.Ve
.SS "last($parent)"
.IX Subsection "last($parent)"
Get the last child under the specified parent.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&    is_deeply $c\->parent,   $b;
\&    is_deeply $a\->first,    $b;
\&  
\&    is_deeply $a\->last,     $d;  # XXXXXXX
\&
\&    is_deeply $e\->next,     $f;
\&    is_deeply $f\->prev,     $e;
.Ve
.SS "next($child)"
.IX Subsection "next($child)"
Get the next sibling following the specified child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&    is_deeply $c\->parent,   $b;
\&    is_deeply $a\->first,    $b;
\&    is_deeply $a\->last,     $d;
\&  
\&    is_deeply $e\->next,     $f;  # XXXXXXX
\&
\&    is_deeply $f\->prev,     $e;
.Ve
.SS "prev($child)"
.IX Subsection "prev($child)"
Get the previous sibling of the specified child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&    is_deeply $c\->parent,   $b;
\&    is_deeply $a\->first,    $b;
\&    is_deeply $a\->last,     $d;
\&    is_deeply $e\->next,     $f;
\&  
\&    is_deeply $f\->prev,     $e;  # XXXXXXX
.Ve
.SS "firstMost($parent)"
.IX Subsection "firstMost($parent)"
Return the first most descendant child in the tree starting at this parent or else return \fBundef\fR if this parent has no children.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&  
\&    ok  $a\->firstMost == $c;  # XXXXXXX
\&
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "nextMost($child)"
.IX Subsection "nextMost($child)"
Return the next child with no children, i.e. the next leaf of the tree, else return \fBundef\fR if there is no such child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Current leaf
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&  
\&    ok  $a\->nextMost  == $c;  # XXXXXXX
\&
\&  
\&    ok  $b\->nextMost  == $c;  # XXXXXXX
\&
\&  
\&    ok  $c\->nextMost  == $x;  # XXXXXXX
\&
\&  
\&    ok  $y\->nextMost  == $x;  # XXXXXXX
\&
\&  
\&    ok  $x\->nextMost  == $e;  # XXXXXXX
\&
\&  
\&    ok  $d\->nextMost  == $e;  # XXXXXXX
\&
\&  
\&    ok  $e\->nextMost  == $f;  # XXXXXXX
\&
\&  
\&    ok  $f\->nextMost  == $g;  # XXXXXXX
\&
\&  
\&    ok  $g\->nextMost  == $j;  # XXXXXXX
\&
\&  
\&    ok  $h\->nextMost  == $j;  # XXXXXXX
\&
\&  
\&    ok  $i\->nextMost  == $j;  # XXXXXXX
\&
\&  
\&    ok !$j\->nextMost;  # XXXXXXX
\&
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "prevMost($child)"
.IX Subsection "prevMost($child)"
Return the previous child with no children, i.e. the previous leaf of the tree, else return \fBundef\fR if there is no such child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Current leaf
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&  
\&    ok !$a\->prevMost;  # XXXXXXX
\&
\&  
\&    ok  $j\->prevMost  == $g;  # XXXXXXX
\&
\&  
\&    ok  $i\->prevMost  == $g;  # XXXXXXX
\&
\&  
\&    ok  $h\->prevMost  == $g;  # XXXXXXX
\&
\&  
\&    ok  $g\->prevMost  == $f;  # XXXXXXX
\&
\&  
\&    ok  $f\->prevMost  == $e;  # XXXXXXX
\&
\&  
\&    ok  $e\->prevMost  == $x;  # XXXXXXX
\&
\&  
\&    ok  $d\->prevMost  == $x;  # XXXXXXX
\&
\&  
\&    ok  $x\->prevMost  == $c;  # XXXXXXX
\&
\&  
\&    ok  $y\->prevMost  == $c;  # XXXXXXX
\&
\&  
\&    ok !$c\->prevMost;  # XXXXXXX
\&
\&  
\&    ok !$b\->prevMost;  # XXXXXXX
\&
\&  
\&    ok !$a\->prevMost;  # XXXXXXX
\&
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "lastMost($parent)"
.IX Subsection "lastMost($parent)"
Return the last most descendant child in the tree starting at this parent or else return \fBundef\fR if this parent has no children.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&  
\&    ok  $a\->lastMost  == $j;  # XXXXXXX
\&
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "topMost($child)"
.IX Subsection "topMost($child)"
Return the top most parent in the tree containing the specified child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&  
\&    ok  $i\->topMost   == $a;  # XXXXXXX
.Ve
.ie n .SS "mostRecentCommonAncestor($first, $second)"
.el .SS "mostRecentCommonAncestor($first, \f(CW$second\fP)"
.IX Subsection "mostRecentCommonAncestor($first, $second)"
Find the most recent common ancestor of the specified children.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First child
\&  2  $second    Second child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k) =
\&      fromLetters \*(Aqb(c(d(e))f(g(h)i)j)k\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&      f
\&        g
\&          h
\&        i
\&      j
\&    k
\&  END
\&  
\&  
\&    ok $e\->mostRecentCommonAncestor($h) == $b;  # XXXXXXX
\&
\&  
\&    ok $e\->mostRecentCommonAncestor($k) == $a;  # XXXXXXX
.Ve
.ie n .SS "go($parent, @path)"
.el .SS "go($parent, \f(CW@path\fP)"
.IX Subsection "go($parent, @path)"
Return the child at the end of the path starting at the specified parent. A path is a list of zero based children numbers. Return \fBundef\fR if the path is not valid.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $parent    Parent
\&  2  @path      List of zero based children numbers
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cd(e(fg)h)i)j\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&      d
\&        e
\&          f
\&          g
\&        h
\&      i
\&    j
\&  END
\&  
\&  
\&    ok $a\->go(0,1,0,1) == $g;  # XXXXXXX
\&
\&  
\&    ok $d\->go(0,0)     == $f;  # XXXXXXX
\&
\&  
\&    is_deeply [$e\->path],         [0,1,0];
\&    is_deeply [$g\->pathFrom($d)], [0,1];
\&  
\&    is_deeply $b\->dup\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
\&  
\&    my $B = $b\->transcribe;
\&  
\&    $b\->by(sub
\&     {my ($c) = @_;
\&      my @path = $c\->pathFrom($b);
\&  
\&      my $C = $B\->go(@path);  # XXXXXXX
\&
\&      is_deeply $c\->key, $C\->key;
\&      is_deeply $c\->{transcribedTo},   $C;
\&      is_deeply $C\->{transcribedFrom}, $c;
\&     });
\&  
\&    is_deeply $B\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
.Ve
.SH "Location"
.IX Header "Location"
Verify the current location.
.SS "context($child)"
.IX Subsection "context($child)"
Get the context of the current child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $s, $t, $x, $y, $z) =
\&      fromLetters \*(Aqb(c)y(x)z(st)d(efgh(i(j))))\*(Aq;
\&  
\&  
\&    is_deeply [$x\->context], [$x, $y, $a];  # XXXXXXX
\&
\&  
\&    is_deeply join(\*(Aq \*(Aq, $a\->by(sub{$_[0]\->key})), "c b x y s t z e f g j i h d a";
\&    is_deeply join(\*(Aq \*(Aq, map{$_\->key} $a\->by),     "c b x y s t z e f g j i h d a";
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    z
\&      s
\&      t
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    $z\->cut;
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SS "isFirst($child)"
.IX Subsection "isFirst($child)"
Return the specified child if that child is first under its parent, else return \fBundef\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $b\->singleChildOfParent, $c;
\&  
\&    is_deeply $e\->isFirst, $e;  # XXXXXXX
\&
\&  
\&    ok !$f\->isFirst;  # XXXXXXX
\&
\&    ok !$g\->isLast;
\&    is_deeply $h\->isLast, $h;
\&    ok  $j\->empty;
\&    ok !$i\->empty;
\&    ok  $a\->isTop;
\&    ok !$b\->isTop;
.Ve
.SS "isLast($child)"
.IX Subsection "isLast($child)"
Return the specified child if that child is last under its parent, else return \fBundef\fR.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $b\->singleChildOfParent, $c;
\&    is_deeply $e\->isFirst, $e;
\&    ok !$f\->isFirst;
\&  
\&    ok !$g\->isLast;  # XXXXXXX
\&
\&  
\&    is_deeply $h\->isLast, $h;  # XXXXXXX
\&
\&    ok  $j\->empty;
\&    ok !$i\->empty;
\&    ok  $a\->isTop;
\&    ok !$b\->isTop;
.Ve
.SS "isTop($parent)"
.IX Subsection "isTop($parent)"
Return the specified parent if that parent is the top most parent in the tree.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $b\->singleChildOfParent, $c;
\&    is_deeply $e\->isFirst, $e;
\&    ok !$f\->isFirst;
\&    ok !$g\->isLast;
\&    is_deeply $h\->isLast, $h;
\&    ok  $j\->empty;
\&    ok !$i\->empty;
\&  
\&    ok  $a\->isTop;  # XXXXXXX
\&
\&  
\&    ok !$b\->isTop;  # XXXXXXX
.Ve
.SS "singleChildOfParent($parent)"
.IX Subsection "singleChildOfParent($parent)"
Return the only child of this parent if the parent has an only child, else \fBundef\fR
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&  
\&    is_deeply $b\->singleChildOfParent, $c;  # XXXXXXX
\&
\&    is_deeply $e\->isFirst, $e;
\&    ok !$f\->isFirst;
\&    ok !$g\->isLast;
\&    is_deeply $h\->isLast, $h;
\&    ok  $j\->empty;
\&    ok !$i\->empty;
\&    ok  $a\->isTop;
\&    ok !$b\->isTop;
.Ve
.SS "empty($parent)"
.IX Subsection "empty($parent)"
Return the specified parent if it has no children else \fBundef\fR
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $b\->singleChildOfParent, $c;
\&    is_deeply $e\->isFirst, $e;
\&    ok !$f\->isFirst;
\&    ok !$g\->isLast;
\&    is_deeply $h\->isLast, $h;
\&  
\&    ok  $j\->empty;  # XXXXXXX
\&
\&  
\&    ok !$i\->empty;  # XXXXXXX
\&
\&    ok  $a\->isTop;
\&    ok !$b\->isTop;
.Ve
.SH "Put"
.IX Header "Put"
Insert children into a tree.
.ie n .SS "putFirst($parent, $child)"
.el .SS "putFirst($parent, \f(CW$child\fP)"
.IX Subsection "putFirst($parent, $child)"
Place a new child first under the specified parent and return the child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $parent    Parent
\&  2  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e) = fromLetters \*(Aqb(c)d(e)\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&  END
\&  
\&    my $z = $b\->putNext(new \*(Aqz\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    d
\&      e
\&  END
\&  
\&    my $y = $d\->putPrev(new \*(Aqy\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putLast(new \*(Aqt\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      t
\&    y
\&    d
\&      e
\&  END
\&  
\&  
\&    $z\->putFirst(new \*(Aqs\*(Aq);  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      s
\&      t
\&    y
\&    d
\&      e
\&  END
.Ve
.ie n .SS "putLast($parent, $child)"
.el .SS "putLast($parent, \f(CW$child\fP)"
.IX Subsection "putLast($parent, $child)"
Place a new child last under the specified parent and return the child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $parent    Parent
\&  2  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e) = fromLetters \*(Aqb(c)d(e)\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&  END
\&  
\&    my $z = $b\->putNext(new \*(Aqz\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    d
\&      e
\&  END
\&  
\&    my $y = $d\->putPrev(new \*(Aqy\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    y
\&    d
\&      e
\&  END
\&  
\&  
\&    $z\->putLast(new \*(Aqt\*(Aq);  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      t
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putFirst(new \*(Aqs\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      s
\&      t
\&    y
\&    d
\&      e
\&  END
.Ve
.ie n .SS "putNext($child, $new)"
.el .SS "putNext($child, \f(CW$new\fP)"
.IX Subsection "putNext($child, $new)"
Place a new child after the specified child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Existing child
\&  2  $new       New child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e) = fromLetters \*(Aqb(c)d(e)\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&  END
\&  
\&  
\&    my $z = $b\->putNext(new \*(Aqz\*(Aq);  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    d
\&      e
\&  END
\&  
\&    my $y = $d\->putPrev(new \*(Aqy\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putLast(new \*(Aqt\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      t
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putFirst(new \*(Aqs\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      s
\&      t
\&    y
\&    d
\&      e
\&  END
.Ve
.ie n .SS "putPrev($child, $new)"
.el .SS "putPrev($child, \f(CW$new\fP)"
.IX Subsection "putPrev($child, $new)"
Place a new child before the specified child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Child
\&  2  $new       New child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e) = fromLetters \*(Aqb(c)d(e)\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&  END
\&  
\&    my $z = $b\->putNext(new \*(Aqz\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    d
\&      e
\&  END
\&  
\&  
\&    my $y = $d\->putPrev(new \*(Aqy\*(Aq);  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putLast(new \*(Aqt\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      t
\&    y
\&    d
\&      e
\&  END
\&  
\&    $z\->putFirst(new \*(Aqs\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    z
\&      s
\&      t
\&    y
\&    d
\&      e
\&  END
.Ve
.SH "Steps"
.IX Header "Steps"
Move the start or end of a scope forwards or backwards as suggested by Alex Monroe.
.SS "step($parent)"
.IX Subsection "step($parent)"
Make the first child of the specified parent the parents previous sibling and return the parent. In effect this moves the start of the parent one step forwards.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&  
\&    $d\->step;  # XXXXXXX
\&
\&    is_deeply $a\->brackets, \*(Aqa(b(c)ed(fgh(i(j))))\*(Aq;
\&  
\&    $d\->stepBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $b\->stepEnd;
\&    is_deeply $a\->brackets, \*(Aqa(b(cd(efgh(i(j)))))\*(Aq;
\&  
\&    $b\->stepEndBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
.Ve
.SS "stepEnd($parent)"
.IX Subsection "stepEnd($parent)"
Make the next sibling of the specified parent the parents last child and return the parent. In effect this moves the end of the parent one step forwards.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $d\->step;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)ed(fgh(i(j))))\*(Aq;
\&  
\&    $d\->stepBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&  
\&    $b\->stepEnd;  # XXXXXXX
\&
\&    is_deeply $a\->brackets, \*(Aqa(b(cd(efgh(i(j)))))\*(Aq;
\&  
\&    $b\->stepEndBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
.Ve
.SS "\fBstepBack()\fP"
.IX Subsection "stepBack()"
Make the previous sibling of the specified parent the parents first child and return the parent. In effect this moves the start of the parent one step backwards.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $d\->step;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)ed(fgh(i(j))))\*(Aq;
\&  
\&  
\&    $d\->stepBack;  # XXXXXXX
\&
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $b\->stepEnd;
\&    is_deeply $a\->brackets, \*(Aqa(b(cd(efgh(i(j)))))\*(Aq;
\&  
\&    $b\->stepEndBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
.Ve
.SS "\fBstepEndBack()\fP"
.IX Subsection "stepEndBack()"
Make the last child of the specified parent the parents next sibling and return the parent. In effect this moves the end of the parent one step backwards.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $d\->step;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)ed(fgh(i(j))))\*(Aq;
\&  
\&    $d\->stepBack;
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
\&  
\&    $b\->stepEnd;
\&    is_deeply $a\->brackets, \*(Aqa(b(cd(efgh(i(j)))))\*(Aq;
\&  
\&  
\&    $b\->stepEndBack;  # XXXXXXX
\&
\&    is_deeply $a\->brackets, \*(Aqa(b(c)d(efgh(i(j))))\*(Aq;
.Ve
.SH "Edit"
.IX Header "Edit"
Edit a tree in situ.
.SS "cut($child)"
.IX Subsection "cut($child)"
Cut out a child and all its content and children, return it ready for reinsertion else where.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $s, $t, $x, $y, $z) =
\&      fromLetters \*(Aqb(c)y(x)z(st)d(efgh(i(j))))\*(Aq;
\&  
\&    is_deeply [$x\->context], [$x, $y, $a];
\&  
\&    is_deeply join(\*(Aq \*(Aq, $a\->by(sub{$_[0]\->key})), "c b x y s t z e f g j i h d a";
\&    is_deeply join(\*(Aq \*(Aq, map{$_\->key} $a\->by),     "c b x y s t z e f g j i h d a";
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    z
\&      s
\&      t
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&  
\&    $z\->cut;  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SS "dup($parent)"
.IX Subsection "dup($parent)"
Duplicate a specified parent and all its descendants returning the root of the resulting tree.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cd(e(fg)h)i)j\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&      d
\&        e
\&          f
\&          g
\&        h
\&      i
\&    j
\&  END
\&  
\&    ok $a\->go(0,1,0,1) == $g;
\&    ok $d\->go(0,0)     == $f;
\&  
\&    is_deeply [$e\->path],         [0,1,0];
\&    is_deeply [$g\->pathFrom($d)], [0,1];
\&  
\&  
\&    is_deeply $b\->dup\->print, <<END;  # XXXXXXX
\&
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
\&  
\&    my $B = $b\->transcribe;
\&  
\&    $b\->by(sub
\&     {my ($c) = @_;
\&      my @path = $c\->pathFrom($b);
\&      my $C = $B\->go(@path);
\&      is_deeply $c\->key, $C\->key;
\&      is_deeply $c\->{transcribedTo},   $C;
\&      is_deeply $C\->{transcribedFrom}, $c;
\&     });
\&  
\&    is_deeply $B\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
.Ve
.SS "transcribe($parent)"
.IX Subsection "transcribe($parent)"
Duplicate a specified parent and all its descendants recording the mapping in a temporary {transcribed} field in the tree being transcribed. Returns the root parent of the tree being duplicated.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cd(e(fg)h)i)j\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&      d
\&        e
\&          f
\&          g
\&        h
\&      i
\&    j
\&  END
\&  
\&    ok $a\->go(0,1,0,1) == $g;
\&    ok $d\->go(0,0)     == $f;
\&  
\&    is_deeply [$e\->path],         [0,1,0];
\&    is_deeply [$g\->pathFrom($d)], [0,1];
\&  
\&    is_deeply $b\->dup\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
\&  
\&  
\&    my $B = $b\->transcribe;  # XXXXXXX
\&
\&  
\&    $b\->by(sub
\&     {my ($c) = @_;
\&      my @path = $c\->pathFrom($b);
\&      my $C = $B\->go(@path);
\&      is_deeply $c\->key, $C\->key;
\&      is_deeply $c\->{transcribedTo},   $C;
\&      is_deeply $C\->{transcribedFrom}, $c;
\&     });
\&  
\&    is_deeply $B\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
.Ve
.SS "unwrap($child)"
.IX Subsection "unwrap($child)"
Unwrap the specified child and return that child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g) = fromLetters \*(Aqb(c(de)f)g\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&    $c\->wrap(\*(Aqz\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      z
\&        c
\&          d
\&          e
\&      f
\&    g
\&  END
\&  
\&  
\&    $c\->parent\->unwrap;  # XXXXXXX
\&
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&    $c\->wrapChildren("Z");
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&        Z
\&          d
\&          e
\&      f
\&    g
\&  END
.Ve
.ie n .SS "wrap($child, $key, $value)"
.el .SS "wrap($child, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "wrap($child, $key, $value)"
Wrap the specified child with a new parent and return the new parent optionally setting its key and value.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $child     Child to wrap
\&  2  $key       Optional key
\&  3  $value     Optional value
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g) = fromLetters \*(Aqb(c(de)f)g\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&  
\&    $c\->wrap(\*(Aqz\*(Aq);  # XXXXXXX
\&
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      z
\&        c
\&          d
\&          e
\&      f
\&    g
\&  END
\&  
\&    $c\->parent\->unwrap;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&    $c\->wrapChildren("Z");
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&        Z
\&          d
\&          e
\&      f
\&    g
\&  END
.Ve
.ie n .SS "wrapChildren($parent, $key, $value)"
.el .SS "wrapChildren($parent, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "wrapChildren($parent, $key, $value)"
Wrap the children of the specified parent with a new intermediate parent that becomes the child of the specified parent, optionally setting the key and the value for the new parent.  Return the new parent.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $parent    Child to wrap
\&  2  $key       Optional key for new wrapping parent
\&  3  $value     Optional value for new wrapping parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g) = fromLetters \*(Aqb(c(de)f)g\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&    $c\->wrap(\*(Aqz\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      z
\&        c
\&          d
\&          e
\&      f
\&    g
\&  END
\&  
\&    $c\->parent\->unwrap;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&        d
\&        e
\&      f
\&    g
\&  END
\&  
\&  
\&    $c\->wrapChildren("Z");  # XXXXXXX
\&
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&        Z
\&          d
\&          e
\&      f
\&    g
\&  END
.Ve
.SS "merge($parent)"
.IX Subsection "merge($parent)"
Unwrap the children of the specified parent with the whose key fields smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator> that of their parent. Returns the specified parent regardless.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Merging parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    $d\->split;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&      d
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $f\->parent\->mergeLikePrev;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $g\->parent\->mergeLikeNext;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&        h
\&          i
\&            j
\&  END
\&  
\&  
\&    $d\->merge;  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SS "mergeLikePrev($child)"
.IX Subsection "mergeLikePrev($child)"
Merge the preceding sibling of the specified child  if that sibling exists and the key data of the two siblings smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator>. Returns the specified child regardless. From a proposal made by Micaela Monroe.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    $d\->split;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&      d
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&  
\&    $f\->parent\->mergeLikePrev;  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $g\->parent\->mergeLikeNext;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&        h
\&          i
\&            j
\&  END
\&  
\&    $d\->merge;
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SS "mergeLikeNext($child)"
.IX Subsection "mergeLikeNext($child)"
Merge the following sibling of the specified child  if that sibling exists and the key data of the two siblings smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator>. Returns the specified child regardless. From a proposal made by Micaela Monroe.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    $d\->split;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&      d
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $f\->parent\->mergeLikePrev;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&  
\&    $g\->parent\->mergeLikeNext;  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&        h
\&          i
\&            j
\&  END
\&  
\&    $d\->merge;
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SS "split($parent)"
.IX Subsection "split($parent)"
Make the specified parent a grandparent of each of its children by interposing a copy of the specified parent between the specified parent and each of its children. Return the specified parent.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $parent    Parent to make into a grand parent
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(c)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&  
\&    $d\->split;  # XXXXXXX
\&
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&      d
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $f\->parent\->mergeLikePrev;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&      d
\&        h
\&          i
\&            j
\&  END
\&  
\&    $g\->parent\->mergeLikeNext;
\&    is_deeply $a\->print, <<END;
\&  Key          Value
\&  a
\&    b
\&      c
\&    d
\&      d
\&        e
\&        f
\&      d
\&        g
\&        h
\&          i
\&            j
\&  END
\&  
\&    $d\->merge;
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.SH "Traverse"
.IX Header "Traverse"
Traverse a tree.
.ie n .SS "by($tree, $sub)"
.el .SS "by($tree, \f(CW$sub\fP)"
.IX Subsection "by($tree, $sub)"
Traverse a tree in post-order to process each child with the specified sub and return an array of the results of processing each child. If no sub sub is specified, the children are returned in tree order.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $sub       Optional sub to process each child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $s, $t, $x, $y, $z) =
\&      fromLetters \*(Aqb(c)y(x)z(st)d(efgh(i(j))))\*(Aq;
\&  
\&    is_deeply [$x\->context], [$x, $y, $a];
\&  
\&  
\&    is_deeply join(\*(Aq \*(Aq, $a\->by(sub{$_[0]\->key})), "c b x y s t z e f g j i h d a";  # XXXXXXX
\&
\&  
\&    is_deeply join(\*(Aq \*(Aq, map{$_\->key} $a\->by),     "c b x y s t z e f g j i h d a";  # XXXXXXX
\&
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    z
\&      s
\&      t
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    $z\->cut;
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
.Ve
.ie n .SS "select($tree, $select)"
.el .SS "select($tree, \f(CW$select\fP)"
.IX Subsection "select($tree, $select)"
Select matching children in a tree in post-order. A child can be selected via named value, array of values, a hash of values, a regular expression or a sub reference.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $select    Method to select a child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my $a = Tree::Ops::new \*(Aqa\*(Aq, \*(AqA\*(Aq;
\&    for(1..2)
\&     {$a\->open  (\*(Aqb\*(Aq, "B$_");
\&      $a\->single(\*(Aqc\*(Aq, "C$_");
\&      ok $a\->activeScope\->key eq \*(Aqb\*(Aq;
\&      $a\->close;
\&     }
\&    $a\->single  (\*(Aqd\*(Aq, \*(AqD\*(Aq);
\&    $a\->single  (\*(Aqe\*(Aq, \*(AqE\*(Aq);
\&    is_deeply $a\->print, <<END;
\&  Key    Value
\&  a      A
\&    b    B1
\&      c  C1
\&    b    B2
\&      c  C2
\&    d    D
\&    e    E
\&  END
\&  
\&    is_deeply [map{$_\->value} $a\->by], [qw(C1 B1 C2 B2 D E A)];
\&  
\&    is_deeply $a\->lastMost\->prev\->prev\->first\->key,           \*(Aqc\*(Aq;
\&    is_deeply $a\->first\->next\->last\->parent\->first\->value,    \*(AqC2\*(Aq;
\&  
\&  
\&    is_deeply [map{$_\->value} $a\->select(\*(Aqb\*(Aq)],               [qw(B1 B2)];  # XXXXXXX
\&
\&  
\&    is_deeply [map{$_\->value} $a\->select(qr(b|c))],           [qw(B1 C1 B2 C2)];  # XXXXXXX
\&
\&  
\&    is_deeply [map{$_\->value} $a\->select(sub{$_[0] eq \*(Aqd\*(Aq})], [qw(D)];  # XXXXXXX
\&
\&  
\&    $a\->first\->next\->stepEnd\->stepEnd\->first\->next\->stepBack;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a        A
\&    b      B1
\&      c    C1
\&    b      B2
\&      d    D
\&        c  C2
\&      e    E
\&  END
.Ve
.SH "Partitions"
.IX Header "Partitions"
Various partitions of the tree
.SS "leaves($tree)"
.IX Subsection "leaves($tree)"
The set of all children without further children, i.e. each leaf of the tree.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];  # XXXXXXX
\&
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "parentsPreOrder($tree)"
.IX Subsection "parentsPreOrder($tree)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in normal pre-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&  
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];  # XXXXXXX
\&
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "parentsPostOrder($tree)"
.IX Subsection "parentsPostOrder($tree)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in normal post-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&  
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];  # XXXXXXX
\&
\&  
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];  # XXXXXXX
\&
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "parentsReversePreOrder($tree)"
.IX Subsection "parentsReversePreOrder($tree)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in reverse pre-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];  # XXXXXXX
\&
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "parentsReversePostOrder($tree)"
.IX Subsection "parentsReversePostOrder($tree)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in reverse post-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&  
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];  # XXXXXXX
\&
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SS "parents($tree)"
.IX Subsection "parents($tree)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in normal post-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $tree      Tree
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];  # XXXXXXX
\&
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&  
\&    ok !$j\->parents;  # XXXXXXX
\&
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SH "Order"
.IX Header "Order"
Check the order and relative position of children in a tree.
.ie n .SS "above($first, $second)"
.el .SS "above($first, \f(CW$second\fP)"
.IX Subsection "above($first, $second)"
Return the first child if it is above the second child else return \fBundef\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First child
\&  2  $second    Second child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n) =
\&      fromLetters(\*(Aqb(c(d(efgh(i(j)k)l)m)n\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&          f
\&          g
\&          h
\&            i
\&              j
\&            k
\&          l
\&        m
\&      n
\&  END
\&  
\&  
\&    ok  $c\->above($j)  == $c;  # XXXXXXX
\&
\&  
\&    ok !$m\->above($j);  # XXXXXXX
\&
\&  
\&    ok  $i\->below($b)  == $i;
\&    ok !$i\->below($n);
\&  
\&    ok  $n\->after($e)  == $n;
\&    ok !$k\->after($c);
\&  
\&    ok  $c\->before($n) == $c;
\&    ok !$c\->before($m);
\&  
\&    is_deeply [map{$_\->key} $j\->lineage($d)], [qw(j i h d)];
\&    ok !$d\->lineage($m);
.Ve
.ie n .SS "below($first, $second)"
.el .SS "below($first, \f(CW$second\fP)"
.IX Subsection "below($first, $second)"
Return the first child if it is below the second child else return \fBundef\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First child
\&  2  $second    Second child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n) =
\&      fromLetters(\*(Aqb(c(d(efgh(i(j)k)l)m)n\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&          f
\&          g
\&          h
\&            i
\&              j
\&            k
\&          l
\&        m
\&      n
\&  END
\&  
\&    ok  $c\->above($j)  == $c;
\&    ok !$m\->above($j);
\&  
\&  
\&    ok  $i\->below($b)  == $i;  # XXXXXXX
\&
\&  
\&    ok !$i\->below($n);  # XXXXXXX
\&
\&  
\&    ok  $n\->after($e)  == $n;
\&    ok !$k\->after($c);
\&  
\&    ok  $c\->before($n) == $c;
\&    ok !$c\->before($m);
\&  
\&    is_deeply [map{$_\->key} $j\->lineage($d)], [qw(j i h d)];
\&    ok !$d\->lineage($m);
.Ve
.ie n .SS "after($first, $second)"
.el .SS "after($first, \f(CW$second\fP)"
.IX Subsection "after($first, $second)"
Return the first child if it occurs strictly after the second child in the tree or else \fBundef\fR if the first child is above, below or before the second child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First child
\&  2  $second    Second child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n) =
\&      fromLetters(\*(Aqb(c(d(efgh(i(j)k)l)m)n\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&          f
\&          g
\&          h
\&            i
\&              j
\&            k
\&          l
\&        m
\&      n
\&  END
\&  
\&    ok  $c\->above($j)  == $c;
\&    ok !$m\->above($j);
\&  
\&    ok  $i\->below($b)  == $i;
\&    ok !$i\->below($n);
\&  
\&  
\&    ok  $n\->after($e)  == $n;  # XXXXXXX
\&
\&  
\&    ok !$k\->after($c);  # XXXXXXX
\&
\&  
\&    ok  $c\->before($n) == $c;
\&    ok !$c\->before($m);
\&  
\&    is_deeply [map{$_\->key} $j\->lineage($d)], [qw(j i h d)];
\&    ok !$d\->lineage($m);
.Ve
.ie n .SS "before($first, $second)"
.el .SS "before($first, \f(CW$second\fP)"
.IX Subsection "before($first, $second)"
Return the first child if it occurs strictly before the second child in the tree or else \fBundef\fR if the first child is above, below or after the second child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $first     First child
\&  2  $second    Second child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n) =
\&      fromLetters(\*(Aqb(c(d(efgh(i(j)k)l)m)n\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&          f
\&          g
\&          h
\&            i
\&              j
\&            k
\&          l
\&        m
\&      n
\&  END
\&  
\&    ok  $c\->above($j)  == $c;
\&    ok !$m\->above($j);
\&  
\&    ok  $i\->below($b)  == $i;
\&    ok !$i\->below($n);
\&  
\&    ok  $n\->after($e)  == $n;
\&    ok !$k\->after($c);
\&  
\&  
\&    ok  $c\->before($n) == $c;  # XXXXXXX
\&
\&  
\&    ok !$c\->before($m);  # XXXXXXX
\&
\&  
\&    is_deeply [map{$_\->key} $j\->lineage($d)], [qw(j i h d)];
\&    ok !$d\->lineage($m);
.Ve
.SH "Paths"
.IX Header "Paths"
Find paths between nodes
.SS "path($child)"
.IX Subsection "path($child)"
Return the list of zero based child indexes for the path from the root of the tree containing the specified child to the specified child for use by the go method.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cd(e(fg)h)i)j\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&      d
\&        e
\&          f
\&          g
\&        h
\&      i
\&    j
\&  END
\&  
\&    ok $a\->go(0,1,0,1) == $g;
\&    ok $d\->go(0,0)     == $f;
\&  
\&  
\&    is_deeply [$e\->path],         [0,1,0];  # XXXXXXX
\&
\&    is_deeply [$g\->pathFrom($d)], [0,1];
\&  
\&    is_deeply $b\->dup\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
\&  
\&    my $B = $b\->transcribe;
\&  
\&    $b\->by(sub
\&     {my ($c) = @_;
\&  
\&      my @path = $c\->pathFrom($b);  # XXXXXXX
\&
\&  
\&      my $C = $B\->go(@path);  # XXXXXXX
\&
\&      is_deeply $c\->key, $C\->key;
\&      is_deeply $c\->{transcribedTo},   $C;
\&      is_deeply $C\->{transcribedFrom}, $c;
\&     });
\&  
\&    is_deeply $B\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
.Ve
.ie n .SS "pathFrom($child, $ancestor)"
.el .SS "pathFrom($child, \f(CW$ancestor\fP)"
.IX Subsection "pathFrom($child, $ancestor)"
Return the list of zero based child indexes for the path from the specified ancestor to the specified child for use by the go method else confess if the ancestor is not, in fact, an ancestor.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Child
\&  2  $ancestor  Ancestor
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cd(e(fg)h)i)j\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&      d
\&        e
\&          f
\&          g
\&        h
\&      i
\&    j
\&  END
\&  
\&    ok $a\->go(0,1,0,1) == $g;
\&    ok $d\->go(0,0)     == $f;
\&  
\&    is_deeply [$e\->path],         [0,1,0];
\&  
\&    is_deeply [$g\->pathFrom($d)], [0,1];  # XXXXXXX
\&
\&  
\&    is_deeply $b\->dup\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
\&  
\&    my $B = $b\->transcribe;
\&  
\&    $b\->by(sub
\&     {my ($c) = @_;
\&  
\&      my @path = $c\->pathFrom($b);  # XXXXXXX
\&
\&      my $C = $B\->go(@path);
\&      is_deeply $c\->key, $C\->key;
\&      is_deeply $c\->{transcribedTo},   $C;
\&      is_deeply $C\->{transcribedFrom}, $c;
\&     });
\&  
\&    is_deeply $B\->print, <<END;
\&  Key      Value
\&  b
\&    c
\&    d
\&      e
\&        f
\&        g
\&      h
\&    i
\&  END
.Ve
.SS "siblingsBefore($child)"
.IX Subsection "siblingsBefore($child)"
Return a list of siblings before the specified child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cde(f)ghi)j\*(Aq;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&      d
\&      e
\&        f
\&      g
\&      h
\&      i
\&    j
\&  END
\&  
\&    is_deeply [$d\->siblingsStrictlyBetween($h)], [$e, $g];
\&    is_deeply [$d\->siblingsAfter],               [$e, $g, $h, $i];
\&  
\&    is_deeply [$g\->siblingsBefore],              [$c, $d, $e];  # XXXXXXX
\&
\&    eval {$e\->siblingsStrictlyBetween($f)};
\&    ok $@ =~ m(Must be siblings);
.Ve
.SS "siblingsAfter($child)"
.IX Subsection "siblingsAfter($child)"
Return a list of siblings after the specified child.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cde(f)ghi)j\*(Aq;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&      d
\&      e
\&        f
\&      g
\&      h
\&      i
\&    j
\&  END
\&  
\&    is_deeply [$d\->siblingsStrictlyBetween($h)], [$e, $g];
\&  
\&    is_deeply [$d\->siblingsAfter],               [$e, $g, $h, $i];  # XXXXXXX
\&
\&    is_deeply [$g\->siblingsBefore],              [$c, $d, $e];
\&    eval {$e\->siblingsStrictlyBetween($f)};
\&    ok $@ =~ m(Must be siblings);
.Ve
.ie n .SS "siblingsStrictlyBetween($start, $finish)"
.el .SS "siblingsStrictlyBetween($start, \f(CW$finish\fP)"
.IX Subsection "siblingsStrictlyBetween($start, $finish)"
Return a list of the siblings strictly between two children of the same parent else return \fBundef\fR.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $start     Start child
\&  2  $finish    Finish child
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j) = fromLetters \*(Aqb(cde(f)ghi)j\*(Aq;
\&    is_deeply $a\->print, <<END;
\&  Key      Value
\&  a
\&    b
\&      c
\&      d
\&      e
\&        f
\&      g
\&      h
\&      i
\&    j
\&  END
\&  
\&  
\&    is_deeply [$d\->siblingsStrictlyBetween($h)], [$e, $g];  # XXXXXXX
\&
\&    is_deeply [$d\->siblingsAfter],               [$e, $g, $h, $i];
\&    is_deeply [$g\->siblingsBefore],              [$c, $d, $e];
\&  
\&    eval {$e\->siblingsStrictlyBetween($f)};  # XXXXXXX
\&
\&    ok $@ =~ m(Must be siblings);
.Ve
.ie n .SS "lineage($child, $ancestor)"
.el .SS "lineage($child, \f(CW$ancestor\fP)"
.IX Subsection "lineage($child, $ancestor)"
Return the path from the specified child to the specified ancestor else return \fBundef\fR if the child is not a descendant of the ancestor.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Child
\&  2  $ancestor  Ancestor
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n) =
\&      fromLetters(\*(Aqb(c(d(efgh(i(j)k)l)m)n\*(Aq);
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&          f
\&          g
\&          h
\&            i
\&              j
\&            k
\&          l
\&        m
\&      n
\&  END
\&  
\&    ok  $c\->above($j)  == $c;
\&    ok !$m\->above($j);
\&  
\&    ok  $i\->below($b)  == $i;
\&    ok !$i\->below($n);
\&  
\&    ok  $n\->after($e)  == $n;
\&    ok !$k\->after($c);
\&  
\&    ok  $c\->before($n) == $c;
\&    ok !$c\->before($m);
\&  
\&  
\&    is_deeply [map{$_\->key} $j\->lineage($d)], [qw(j i h d)];  # XXXXXXX
\&
\&  
\&    ok !$d\->lineage($m);  # XXXXXXX
.Ve
.SS "nextPreOrderPath($start)"
.IX Subsection "nextPreOrderPath($start)"
Return a list of children visited between the specified child and the next child in pre-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $start     The child at the start of the path
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r) =
\&      fromLetters \*(Aqb(c(d(e(fg)hi(j(kl)m)n)op)q)r\*(Aq;
\&    my @p = [$a];
\&  
\&    for(1..99)
\&  
\&     {my @n = $p[\-1][\-1]\->nextPreOrderPath;  # XXXXXXX
\&
\&      last unless @n;
\&      push @p, [@n];
\&     }
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&            f
\&            g
\&          h
\&          i
\&            j
\&              k
\&              l
\&            m
\&          n
\&        o
\&        p
\&      q
\&    r
\&  END
\&  
\&    my @pre = map{[map{$_\->key} @$_]} @p;
\&    is_deeply scalar(@pre), scalar([\*(Aqa\*(Aq..\*(Aqr\*(Aq]\->@*);
\&    is_deeply [@pre],
\&     [["a"],
\&      ["b"],
\&      ["c"],
\&      ["d"],
\&      ["e"],
\&      ["f"],
\&      ["g"],
\&      ["e", "h"],
\&      ["i"],
\&      ["j"],
\&      ["k"],
\&      ["l"],
\&      ["j", "m"],
\&      ["i", "n"],
\&      ["d", "o"],
\&      ["p"],
\&      ["c", "q"],
\&      ["b", "r"]];
.Ve
.SS "nextPostOrderPath($start)"
.IX Subsection "nextPostOrderPath($start)"
Return a list of children visited between the specified child and the next child in post-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $start     The child at the start of the path
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r) =
\&      fromLetters \*(Aqb(c(d(e(fg)hi(j(kl)m)n)op)q)r\*(Aq;
\&  
\&    my @n = $a;
\&    my @p;
\&    for(1..99)
\&  
\&     {@n = $n[\-1]\->nextPostOrderPath;  # XXXXXXX
\&
\&      last unless @n;
\&      push @p, [@n];
\&      last if $n[\-1] == $a;
\&     }
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&            f
\&            g
\&          h
\&          i
\&            j
\&              k
\&              l
\&            m
\&          n
\&        o
\&        p
\&      q
\&    r
\&  END
\&  
\&    my @post = map{[map{$_\->key} @$_]} @p;
\&    is_deeply scalar(@post), scalar([\*(Aqa\*(Aq..\*(Aqr\*(Aq]\->@*);
\&    is_deeply [@post],
\&   [["b" .. "f"],
\&    ["g"],
\&    ["e"],
\&    ["h"],
\&    ["i", "j", "k"],
\&    ["l"],
\&    ["j"],
\&    ["m"],
\&    ["i"],
\&    ["n"],
\&    ["d"],
\&    ["o"],
\&    ["p"],
\&    ["c"],
\&    ["q"],
\&    ["b"],
\&    ["r"],
\&    ["a"]];
.Ve
.SS "prevPostOrderPath($start)"
.IX Subsection "prevPostOrderPath($start)"
Return a list of children visited between the specified child and the previous child in post-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $start     The child at the start of the path
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r) =
\&      fromLetters \*(Aqb(c(d(e(fg)hi(j(kl)m)n)op)q)r\*(Aq;
\&    my @p = [$a];
\&  
\&    for(1..99)
\&  
\&     {my @n = $p[\-1][\-1]\->prevPostOrderPath;  # XXXXXXX
\&
\&      last unless @n;
\&      push @p, [@n];
\&     }
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&            f
\&            g
\&          h
\&          i
\&            j
\&              k
\&              l
\&            m
\&          n
\&        o
\&        p
\&      q
\&    r
\&  END
\&  
\&    my @post = map{[map{$_\->key} @$_]} @p;
\&    is_deeply scalar(@post), scalar([\*(Aqa\*(Aq..\*(Aqr\*(Aq]\->@*);
\&    is_deeply [@post],
\&     [["a"],
\&      ["r"],
\&      ["b"],
\&      ["q"],
\&      ["c"],
\&      ["p"],
\&      ["o"],
\&      ["d"],
\&      ["n"],
\&      ["i"],
\&      ["m"],
\&      ["j"],
\&      ["l"],
\&      ["k"],
\&      ["j", "i", "h"],
\&      ["e"],
\&      ["g"],
\&      ["f"]];
.Ve
.SS "prevPreOrderPath($start)"
.IX Subsection "prevPreOrderPath($start)"
Return a list of children visited between the specified child and the previous child in pre-order.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $start     The child at the start of the path
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r) =
\&      fromLetters \*(Aqb(c(d(e(fg)hi(j(kl)m)n)op)q)r\*(Aq;
\&  
\&    my @n = $a;
\&    my @p;
\&    for(1..99)
\&  
\&     {@n = $n[\-1]\->prevPreOrderPath;  # XXXXXXX
\&
\&      last unless @n;
\&      push @p, [@n];
\&      last if $n[\-1] == $a;
\&     }
\&  
\&    is_deeply $a\->print, <<END;
\&  Key            Value
\&  a
\&    b
\&      c
\&        d
\&          e
\&            f
\&            g
\&          h
\&          i
\&            j
\&              k
\&              l
\&            m
\&          n
\&        o
\&        p
\&      q
\&    r
\&  END
\&  
\&    my @pre = map{[map{$_\->key} @$_]} @p;
\&    is_deeply scalar(@pre), scalar([\*(Aqa\*(Aq..\*(Aqr\*(Aq]\->@*);
\&    is_deeply [@pre],
\&     [["r"],
\&      ["b", "q"],
\&      ["c", "p"],
\&      ["o"],
\&      ["d", "n"],
\&      ["i", "m"],
\&      ["j", "l"],
\&      ["k"],
\&      ["j"],
\&      ["i"],
\&      ["h"],
\&      ["e", "g"],
\&      ["f"],
\&      ["e"],
\&      ["d"],
\&      ["c"],
\&      ["b"],
\&      ["a"]];
.Ve
.SH "Print"
.IX Header "Print"
Print a tree.
.ie n .SS "printPreOrder($tree, $print)"
.el .SS "printPreOrder($tree, \f(CW$print\fP)"
.IX Subsection "printPreOrder($tree, $print)"
Print tree in normal pre-order.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d) = fromLetters \*(Aqb(c)d\*(Aq;
\&    my sub test(@) {join \*(Aq \*(Aq, map{join \*(Aq\*(Aq, $_\->key} @_}
\&  
\&  
\&    is_deeply $a\->printPreOrder, <<END;  # XXXXXXX
\&
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&  END
\&  
\&    is_deeply test($a\->nextPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPreOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->nextPreOrderPath), \*(Aqb d\*(Aq;
\&    is_deeply test($d\->nextPreOrderPath), \*(Aq\*(Aq;
\&  
\&    is_deeply $a\->printPostOrder, <<END;
\&  Key    Value
\&      c
\&    b
\&    d
\&  a
\&  END
\&  
\&    is_deeply test($a\->nextPostOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->nextPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->nextPostOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePreOrder, <<END;
\&  Key    Value
\&  a
\&    d
\&    b
\&      c
\&  END
\&    is_deeply test($a\->prevPreOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPreOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->prevPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPreOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePostOrder, <<END;
\&  Key    Value
\&    d
\&      c
\&    b
\&  a
\&  END
\&  
\&    is_deeply test($a\->prevPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPostOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->prevPostOrderPath), \*(Aq\*(Aq;
.Ve
.ie n .SS "printPostOrder($tree, $print)"
.el .SS "printPostOrder($tree, \f(CW$print\fP)"
.IX Subsection "printPostOrder($tree, $print)"
Print tree in normal post-order.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d) = fromLetters \*(Aqb(c)d\*(Aq;
\&    my sub test(@) {join \*(Aq \*(Aq, map{join \*(Aq\*(Aq, $_\->key} @_}
\&  
\&    is_deeply $a\->printPreOrder, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&  END
\&  
\&    is_deeply test($a\->nextPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPreOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->nextPreOrderPath), \*(Aqb d\*(Aq;
\&    is_deeply test($d\->nextPreOrderPath), \*(Aq\*(Aq;
\&  
\&  
\&    is_deeply $a\->printPostOrder, <<END;  # XXXXXXX
\&
\&  Key    Value
\&      c
\&    b
\&    d
\&  a
\&  END
\&  
\&    is_deeply test($a\->nextPostOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->nextPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->nextPostOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePreOrder, <<END;
\&  Key    Value
\&  a
\&    d
\&    b
\&      c
\&  END
\&    is_deeply test($a\->prevPreOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPreOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->prevPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPreOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePostOrder, <<END;
\&  Key    Value
\&    d
\&      c
\&    b
\&  a
\&  END
\&  
\&    is_deeply test($a\->prevPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPostOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->prevPostOrderPath), \*(Aq\*(Aq;
.Ve
.ie n .SS "printReversePreOrder($tree, $print)"
.el .SS "printReversePreOrder($tree, \f(CW$print\fP)"
.IX Subsection "printReversePreOrder($tree, $print)"
Print tree in reverse pre-order
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d) = fromLetters \*(Aqb(c)d\*(Aq;
\&    my sub test(@) {join \*(Aq \*(Aq, map{join \*(Aq\*(Aq, $_\->key} @_}
\&  
\&    is_deeply $a\->printPreOrder, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&  END
\&  
\&    is_deeply test($a\->nextPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPreOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->nextPreOrderPath), \*(Aqb d\*(Aq;
\&    is_deeply test($d\->nextPreOrderPath), \*(Aq\*(Aq;
\&  
\&    is_deeply $a\->printPostOrder, <<END;
\&  Key    Value
\&      c
\&    b
\&    d
\&  a
\&  END
\&  
\&    is_deeply test($a\->nextPostOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->nextPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->nextPostOrderPath), \*(Aqa\*(Aq;
\&  
\&  
\&    is_deeply $a\->printReversePreOrder, <<END;  # XXXXXXX
\&
\&  Key    Value
\&  a
\&    d
\&    b
\&      c
\&  END
\&    is_deeply test($a\->prevPreOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPreOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->prevPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPreOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePostOrder, <<END;
\&  Key    Value
\&    d
\&      c
\&    b
\&  a
\&  END
\&  
\&    is_deeply test($a\->prevPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPostOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->prevPostOrderPath), \*(Aq\*(Aq;
.Ve
.ie n .SS "printReversePostOrder($tree, $print)"
.el .SS "printReversePostOrder($tree, \f(CW$print\fP)"
.IX Subsection "printReversePostOrder($tree, $print)"
Print tree in reverse post-order
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d) = fromLetters \*(Aqb(c)d\*(Aq;
\&    my sub test(@) {join \*(Aq \*(Aq, map{join \*(Aq\*(Aq, $_\->key} @_}
\&  
\&    is_deeply $a\->printPreOrder, <<END;
\&  Key    Value
\&  a
\&    b
\&      c
\&    d
\&  END
\&  
\&    is_deeply test($a\->nextPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPreOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->nextPreOrderPath), \*(Aqb d\*(Aq;
\&    is_deeply test($d\->nextPreOrderPath), \*(Aq\*(Aq;
\&  
\&    is_deeply $a\->printPostOrder, <<END;
\&  Key    Value
\&      c
\&    b
\&    d
\&  a
\&  END
\&  
\&    is_deeply test($a\->nextPostOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->nextPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->nextPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->nextPostOrderPath), \*(Aqa\*(Aq;
\&  
\&    is_deeply $a\->printReversePreOrder, <<END;
\&  Key    Value
\&  a
\&    d
\&    b
\&      c
\&  END
\&    is_deeply test($a\->prevPreOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPreOrderPath), \*(Aqb c\*(Aq;
\&    is_deeply test($c\->prevPreOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPreOrderPath), \*(Aqa\*(Aq;
\&  
\&  
\&    is_deeply $a\->printReversePostOrder, <<END;  # XXXXXXX
\&
\&  Key    Value
\&    d
\&      c
\&    b
\&  a
\&  END
\&  
\&    is_deeply test($a\->prevPostOrderPath), \*(Aqd\*(Aq;
\&    is_deeply test($d\->prevPostOrderPath), \*(Aqb\*(Aq;
\&    is_deeply test($b\->prevPostOrderPath), \*(Aqc\*(Aq;
\&    is_deeply test($c\->prevPostOrderPath), \*(Aq\*(Aq;
.Ve
.ie n .SS "print($tree, $print)"
.el .SS "print($tree, \f(CW$print\fP)"
.IX Subsection "print($tree, $print)"
Print tree in normal pre-order.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&  
\&    is_deeply $a\->print, <<END;  # XXXXXXX
\&
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.ie n .SS "brackets($tree, $print, $separator)"
.el .SS "brackets($tree, \f(CW$print\fP, \f(CW$separator\fP)"
.IX Subsection "brackets($tree, $print, $separator)"
Bracketed string representation of a tree.
.PP
.Vb 4
\&     Parameter   Description
\&  1  $tree       Tree
\&  2  $print      Optional print method
\&  3  $separator  Optional child separator
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&    is_deeply $a\->xml,
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.ie n .SS "xml($tree, $print)"
.el .SS "xml($tree, \f(CW$print\fP)"
.IX Subsection "xml($tree, $print)"
Print a tree as as xml.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&    my ($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $x, $y) =
\&      fromLetters \*(Aqb(c)y(x)d(efgh(i(j)))\*(Aq;
\&  
\&    is_deeply $a\->print, <<END;
\&  Key        Value
\&  a
\&    b
\&      c
\&    y
\&      x
\&    d
\&      e
\&      f
\&      g
\&      h
\&        i
\&          j
\&  END
\&  
\&  
\&    is_deeply $a\->xml,  # XXXXXXX
\&
\&     \*(Aq<a><b><c/></b><y><x/></y><d><e/><f/><g/><h><i><j/></i></h></d></a>\*(Aq;
\&  
\&    is_deeply [$c, $x, $e, $f, $g, $j], [$a\->leaves];
\&    is_deeply [$a, $b, $y, $d, $h, $i], [$a\->parentsPreOrder];
\&    is_deeply [$b, $y, $i, $h, $d, $a], [$a\->parentsPostOrder];
\&    is_deeply [$a\->parents],            [$a\->parentsPostOrder];
\&  
\&    is_deeply [$a, $d, $h, $i, $y, $b], [$a\->parentsReversePreOrder];
\&    is_deeply [$i, $h, $d, $y, $b, $a], [$a\->parentsReversePostOrder];
\&  
\&    ok !$j\->parents;
\&  
\&    ok  $a\->lastMost  == $j;
\&    ok !$a\->prevMost;
\&    ok  $j\->prevMost  == $g;
\&    ok  $i\->prevMost  == $g;
\&    ok  $h\->prevMost  == $g;
\&    ok  $g\->prevMost  == $f;
\&    ok  $f\->prevMost  == $e;
\&    ok  $e\->prevMost  == $x;
\&    ok  $d\->prevMost  == $x;
\&    ok  $x\->prevMost  == $c;
\&    ok  $y\->prevMost  == $c;
\&    ok !$c\->prevMost;
\&    ok !$b\->prevMost;
\&    ok !$a\->prevMost;
\&  
\&    ok  $a\->firstMost == $c;
\&    ok  $a\->nextMost  == $c;
\&    ok  $b\->nextMost  == $c;
\&    ok  $c\->nextMost  == $x;
\&    ok  $y\->nextMost  == $x;
\&    ok  $x\->nextMost  == $e;
\&    ok  $d\->nextMost  == $e;
\&    ok  $e\->nextMost  == $f;
\&    ok  $f\->nextMost  == $g;
\&    ok  $g\->nextMost  == $j;
\&    ok  $h\->nextMost  == $j;
\&    ok  $i\->nextMost  == $j;
\&    ok !$j\->nextMost;
\&  
\&    ok  $i\->topMost   == $a;
.Ve
.SH "Data Structures"
.IX Header "Data Structures"
Data structures use by this package.
.SS "Tree::Ops Definition"
.IX Subsection "Tree::Ops Definition"
Child in the tree.
.PP
\fIOutput fields\fR
.IX Subsection "Output fields"
.PP
children
.IX Subsection "children"
.PP
Children of this child.
.PP
key
.IX Subsection "key"
.PP
Key for this child \- any thing that can be compared with the smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator> operator.
.PP
lastChild
.IX Subsection "lastChild"
.PP
Last active child chain \- enables us to find the currently open scope from the start if the tree.
.PP
parent
.IX Subsection "parent"
.PP
Parent for this child.
.PP
value
.IX Subsection "value"
.PP
Value for this child.
.SH "Private Methods"
.IX Header "Private Methods"
.ie n .SS "setParentOfChild($child, $parent)"
.el .SS "setParentOfChild($child, \f(CW$parent\fP)"
.IX Subsection "setParentOfChild($child, $parent)"
Set the parent of a child and return the child.
.PP
.Vb 3
\&     Parameter  Description
\&  1  $child     Child
\&  2  $parent    Parent
.Ve
.SS "indexOfChildInParent($child)"
.IX Subsection "indexOfChildInParent($child)"
Get the index of a child within the specified parent.
.PP
.Vb 2
\&     Parameter  Description
\&  1  $child     Child
.Ve
.ie n .SS "parentsOrdered($tree, $preorder, $reverse)"
.el .SS "parentsOrdered($tree, \f(CW$preorder\fP, \f(CW$reverse\fP)"
.IX Subsection "parentsOrdered($tree, $preorder, $reverse)"
The set of all parents in the tree, i.e. each non leaf of the tree, i.e  the interior of the tree in the specified order.
.PP
.Vb 4
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $preorder  Pre\-order if true else post\-order
\&  3  $reverse   Reversed if true
.Ve
.ie n .SS "printTree($tree, $print, $preorder, $reverse)"
.el .SS "printTree($tree, \f(CW$print\fP, \f(CW$preorder\fP, \f(CW$reverse\fP)"
.IX Subsection "printTree($tree, $print, $preorder, $reverse)"
String representation as a horizontal tree.
.PP
.Vb 5
\&     Parameter  Description
\&  1  $tree      Tree
\&  2  $print     Optional print method
\&  3  $preorder  Pre\-order
\&  4  $reverse   Reverse
.Ve
.SH "Index"
.IX Header "Index"
1 above \- Return the first child if it is above the second child else return \fBundef\fR.
.PP
2 activeScope \- Locate the active scope in a tree.
.PP
3 after \- Return the first child if it occurs strictly after the second child in the tree or else \fBundef\fR if the first child is above, below or before the second child.
.PP
4 before \- Return the first child if it occurs strictly before the second child in the tree or else \fBundef\fR if the first child is above, below or after the second child.
.PP
5 below \- Return the first child if it is below the second child else return \fBundef\fR.
.PP
6 brackets \- Bracketed string representation of a tree.
.PP
7 by \- Traverse a tree in post-order to process each child with the specified sub and return an array of the results of processing each child.
.PP
8 close \- Close the current scope returning to the previous scope.
.PP
9 context \- Get the context of the current child.
.PP
10 cut \- Cut out a child and all its content and children, return it ready for reinsertion else where.
.PP
11 dup \- Duplicate a specified parent and all its descendants returning the root of the resulting tree.
.PP
12 empty \- Return the specified parent if it has no children else \fBundef\fR
.PP
13 first \- Get the first child under the specified parent.
.PP
14 firstMost \- Return the first most descendant child in the tree starting at this parent or else return \fBundef\fR if this parent has no children.
.PP
15 fromLetters \- Create a tree from a string of letters returning the children created in alphabetic order  \- useful for testing.
.PP
16 go \- Return the child at the end of the path starting at the specified parent.
.PP
17 include \- Include the specified tree in the currently open scope.
.PP
18 indexOfChildInParent \- Get the index of a child within the specified parent.
.PP
19 isFirst \- Return the specified child if that child is first under its parent, else return \fBundef\fR.
.PP
20 isLast \- Return the specified child if that child is last under its parent, else return \fBundef\fR.
.PP
21 isTop \- Return the specified parent if that parent is the top most parent in the tree.
.PP
22 last \- Get the last child under the specified parent.
.PP
23 lastMost \- Return the last most descendant child in the tree starting at this parent or else return \fBundef\fR if this parent has no children.
.PP
24 leaves \- The set of all children without further children, i.
.PP
25 lineage \- Return the path from the specified child to the specified ancestor else return \fBundef\fR if the child is not a descendant of the ancestor.
.PP
26 merge \- Unwrap the children of the specified parent with the whose key fields smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator> that of their parent.
.PP
27 mergeLikeNext \- Merge the following sibling of the specified child  if that sibling exists and the key data of the two siblings smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator>.
.PP
28 mergeLikePrev \- Merge the preceding sibling of the specified child  if that sibling exists and the key data of the two siblings smartmatch <https://perldoc.perl.org/perlop.html#Smartmatch-Operator>.
.PP
29 mostRecentCommonAncestor \- Find the most recent common ancestor of the specified children.
.PP
30 new \- Create a new child optionally recording the specified key or value.
.PP
31 next \- Get the next sibling following the specified child.
.PP
32 nextMost \- Return the next child with no children, i.
.PP
33 nextPostOrderPath \- Return a list of children visited between the specified child and the next child in post-order.
.PP
34 nextPreOrderPath \- Return a list of children visited between the specified child and the next child in pre-order.
.PP
35 open \- Add a child and make it the currently active scope into which new children will be added.
.PP
36 parents \- The set of all parents in the tree, i.
.PP
37 parentsOrdered \- The set of all parents in the tree, i.
.PP
38 parentsPostOrder \- The set of all parents in the tree, i.
.PP
39 parentsPreOrder \- The set of all parents in the tree, i.
.PP
40 parentsReversePostOrder \- The set of all parents in the tree, i.
.PP
41 parentsReversePreOrder \- The set of all parents in the tree, i.
.PP
42 path \- Return the list of zero based child indexes for the path from the root of the tree containing the specified child to the specified child for use by the go method.
.PP
43 pathFrom \- Return the list of zero based child indexes for the path from the specified ancestor to the specified child for use by the go method else confess if the ancestor is not, in fact, an ancestor.
.PP
44 prev \- Get the previous sibling of the specified child.
.PP
45 prevMost \- Return the previous child with no children, i.
.PP
46 prevPostOrderPath \- Return a list of children visited between the specified child and the previous child in post-order.
.PP
47 prevPreOrderPath \- Return a list of children visited between the specified child and the previous child in pre-order.
.PP
48 print \- Print tree in normal pre-order.
.PP
49 printPostOrder \- Print tree in normal post-order.
.PP
50 printPreOrder \- Print tree in normal pre-order.
.PP
51 printReversePostOrder \- Print tree in reverse post-order
.PP
52 printReversePreOrder \- Print tree in reverse pre-order
.PP
53 printTree \- String representation as a horizontal tree.
.PP
54 putFirst \- Place a new child first under the specified parent and return the child.
.PP
55 putLast \- Place a new child last under the specified parent and return the child.
.PP
56 putNext \- Place a new child after the specified child.
.PP
57 putPrev \- Place a new child before the specified child.
.PP
58 select \- Select matching children in a tree in post-order.
.PP
59 setParentOfChild \- Set the parent of a child and return the child.
.PP
60 siblingsAfter \- Return a list of siblings after the specified child.
.PP
61 siblingsBefore \- Return a list of siblings before the specified child.
.PP
62 siblingsStrictlyBetween \- Return a list of the siblings strictly between two children of the same parent else return \fBundef\fR.
.PP
63 single \- Add one child in the current scope.
.PP
64 singleChildOfParent \- Return the only child of this parent if the parent has an only child, else \fBundef\fR
.PP
65 split \- Make the specified parent a grandparent of each of its children by interposing a copy of the specified parent between the specified parent and each of its children.
.PP
66 step \- Make the first child of the specified parent the parents previous sibling and return the parent.
.PP
67 stepBack \- Make the previous sibling of the specified parent the parents first child and return the parent.
.PP
68 stepEnd \- Make the next sibling of the specified parent the parents last child and return the parent.
.PP
69 stepEndBack \- Make the last child of the specified parent the parents next sibling and return the parent.
.PP
70 topMost \- Return the top most parent in the tree containing the specified child.
.PP
71 transcribe \- Duplicate a specified parent and all its descendants recording the mapping in a temporary {transcribed} field in the tree being transcribed.
.PP
72 unwrap \- Unwrap the specified child and return that child.
.PP
73 wrap \- Wrap the specified child with a new parent and return the new parent optionally setting its key and value.
.PP
74 wrapChildren \- Wrap the children of the specified parent with a new intermediate parent that becomes the child of the specified parent, optionally setting the key and the value for the new parent.
.PP
75 xml \- Print a tree as as xml.
.SH "Installation"
.IX Header "Installation"
This module is written in 100% Pure Perl and, thus, it is easy to read,
comprehend, use, modify and install via \fBcpan\fR:
.PP
.Vb 1
\&  sudo cpan install Tree::Ops
.Ve
.SH "Author"
.IX Header "Author"
philiprbrenan@gmail.com <mailto:philiprbrenan@gmail.com>
.PP
<http://www.appaapps.com>
.SH "Copyright"
.IX Header "Copyright"
Copyright (c) 2016\-2019 Philip R Brenan.
.PP
This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.
