.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object::Types::Keywords 3"
.TH Data::Object::Types::Keywords 3 "2020-04-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object::Types::Keywords
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Data-Object Type Library Keywords
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package Test::Library;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  register
\&  {
\&    name => \*(AqPerson\*(Aq,
\&    aliases => [\*(AqStudent\*(Aq, \*(AqTeacher\*(Aq],
\&    validation => is_instance_of(\*(AqTest::Person\*(Aq),
\&    parent => \*(AqObject\*(Aq
\&  },
\&  {
\&    name => \*(AqPrincipal\*(Aq,
\&    validation => is_instance_of(\*(AqTest::Person\*(Aq),
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  # creates person, student, and teacher constraints
\&
\&  package main;
\&
\&  my $library = Test::Library\->meta;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides type library keyword functions for
Data::Object::Types::Library and Type::Library libraries.
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Types::Standard
.SH "SCENARIOS"
.IX Header "SCENARIOS"
This package supports the following scenarios:
.SS "exports"
.IX Subsection "exports"
.Vb 1
\&  package Test::Library::Exports;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  # The following is a snapshot of the exported keyword functions:
\&
\&  # as
\&  # class_type
\&  # classifier
\&  # coerce
\&  # compile_match_on_type
\&  # declare
\&  # declare_coercion
\&  # duck_type
\&  # dwim_type
\&  # english_list
\&  # enum
\&  # extends
\&  # from
\&  # is_all_of
\&  # is_any_of
\&  # is_one_of
\&  # inline_as
\&  # intersection
\&  # is_capable_of
\&  # is_consumer_of
\&  # is_instance_of
\&  # match_on_type
\&  # message
\&  # register
\&  # role_type
\&  # subtype
\&  # to_type
\&  # type
\&  # union
\&  # via
\&  # where
\&
\&  "Test::Library::Exports"
.Ve
.PP
This package supports exporting functions which help configure Type::Library
derived libraries.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
This package implements the following functions:
.SS "is_all_of"
.IX Subsection "is_all_of"
.Vb 1
\&  is_all_of(CodeRef @checks) : CodeRef
.Ve
.PP
The is_all_of function accepts one or more callbacks and returns truthy if all
of the callbacks return truthy.
.IP "is_all_of example #1" 4
.IX Item "is_all_of example #1"
.Vb 1
\&  package Test::Library::HasAllOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_all_of(
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::Entity\*(Aq);
\&      return 1;
\&    },
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::Person\*(Aq);
\&      return 1;
\&    },
\&  );
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_any_of"
.IX Subsection "is_any_of"
.Vb 1
\&  is_any_of(CodeRef @checks) : CodeRef
.Ve
.PP
The is_any_of function accepts one or more callbacks and returns truthy if any
of the callbacks return truthy.
.IP "is_any_of example #1" 4
.IX Item "is_any_of example #1"
.Vb 1
\&  package Test::Library::HasAnyOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_any_of(
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqApp::Person\*(Aq);
\&      return 1;
\&    },
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::Person\*(Aq);
\&      return 1;
\&    },
\&  );
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_capable_of"
.IX Subsection "is_capable_of"
.Vb 1
\&  is_capable_of(Str @routines) : CodeRef
.Ve
.PP
The is_capable_of function accepts one or more subroutine names and returns a
callback which returns truthy if the value passed to the callback has
implemented all of the routines specified.
.IP "is_capable_of example #1" 4
.IX Item "is_capable_of example #1"
.Vb 1
\&  package Test::Library::IsCapableOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_capable_of(qw(create update delete));
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_comprised_of"
.IX Subsection "is_comprised_of"
.Vb 1
\&  is_comprised_of(Str @names) : CodeRef
.Ve
.PP
The is_comprised_of function accepts one or more names and returns a callback
which returns truthy if the value passed to the callback is a hashref or
hashref based object which has keys that correspond to the names provided.
.IP "is_comprised_of example #1" 4
.IX Item "is_comprised_of example #1"
.Vb 1
\&  package Test::Library::IsComprisedOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_comprised_of(qw(mon tues wed thurs fri sat sun));
\&
\&  register {
\&    name => \*(AqWorkHours\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqHashRef\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_consumer_of"
.IX Subsection "is_consumer_of"
.Vb 1
\&  is_consumer_of(Str $name) : CodeRef
.Ve
.PP
The is_consumer_of function accepts a role name and returns a callback which
returns truthy if the value passed to the callback consumes the role specified.
.IP "is_consumer_of example #1" 4
.IX Item "is_consumer_of example #1"
.Vb 1
\&  package Test::Library::IsConsumerOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_consumer_of(\*(AqTest::Role::Identifiable\*(Aq);
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_instance_of"
.IX Subsection "is_instance_of"
.Vb 1
\&  is_instance_of(Str $name) : CodeRef
.Ve
.PP
The is_instance_of function accepts a class or package name and returns a
callback which returns truthy if the value passed to the callback inherits from
the class or package specified.
.IP "is_instance_of example #1" 4
.IX Item "is_instance_of example #1"
.Vb 1
\&  package Test::Library::IsInstanceOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_instance_of(\*(AqTest::Person\*(Aq);
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "is_one_of"
.IX Subsection "is_one_of"
.Vb 1
\&  is_one_of(CodeRef @checks) : CodeRef
.Ve
.PP
The is_one_of function accepts one or more callbacks and returns truthy if
only one of the callbacks return truthy.
.IP "is_one_of example #1" 4
.IX Item "is_one_of example #1"
.Vb 1
\&  package Test::Library::HasOneOf;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  my $validation = is_one_of(
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::Student\*(Aq);
\&      return 1;
\&    },
\&    sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::Teacher\*(Aq);
\&      return 1;
\&    },
\&  );
\&
\&  register {
\&    name => \*(AqPerson\*(Aq,
\&    validation => $validation,
\&    parent => \*(AqObject\*(Aq
\&  };
\&
\&  $validation
.Ve
.SS "register"
.IX Subsection "register"
.Vb 1
\&  register(HashRef $type) : InstanceOf["Type::Tiny"]
.Ve
.PP
The register function takes a simple hashref and creates and registers a
Type::Tiny type object.
.IP "register example #1" 4
.IX Item "register example #1"
.Vb 1
\&  package Test::Library::Standard;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  register {
\&    name => \*(AqMessage\*(Aq,
\&    coercions => [
\&      \*(AqStr\*(Aq, sub {
\&        my ($value) = @_;
\&
\&        {
\&          type => \*(Aqsimple\*(Aq,
\&          payload => $value
\&        }
\&      }
\&    ],
\&    validation => sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->{type};
\&      return 0 if !$value\->{payload};
\&      return 1;
\&    },
\&    parent => \*(AqHashRef\*(Aq
\&  };
.Ve
.IP "register example #2" 4
.IX Item "register example #2"
.Vb 1
\&  package Test::Library::Parameterized;
\&
\&  use Data::Object::Types::Keywords;
\&
\&  use base \*(AqData::Object::Types::Library\*(Aq;
\&
\&  extends \*(AqTypes::Standard\*(Aq;
\&
\&  register {
\&    name => \*(AqPeople\*(Aq,
\&    coercions => [
\&      \*(AqArrayRef\*(Aq, sub {
\&        my ($value) = @_;
\&
\&        Test::People\->new($value)
\&      }
\&    ],
\&    validation => sub {
\&      my ($value) = @_;
\&
\&      return 0 if !$value\->isa(\*(AqTest::People\*(Aq);
\&      return 1;
\&    },
\&    explaination => sub {
\&      my ($value, $type, $name) = @_;
\&
\&      my $param = $type\->parameters\->[0];
\&
\&      for my $i (0 .. $#$value) {
\&        next if $param\->check($value\->[$i]);
\&
\&        my $indx = sprintf(\*(Aq%s\->[%d]\*(Aq, $name, $i);
\&        my $desc = $param\->validate_explain($value\->[$i], $indx);
\&        my $text = \*(Aq"%s" constrains each value in the array object with "%s"\*(Aq;
\&
\&        return [sprintf($text, $type, $param), @{$desc}];
\&      }
\&
\&      return;
\&    },
\&    parameterize_constraint => sub {
\&      my ($value, $type) = @_;
\&
\&      $type\->check($_) || return for @$value;
\&
\&      return !!1;
\&    },
\&    parameterize_coercions => sub {
\&      my ($data, $type, $anon) = @_;
\&
\&      my $coercions = [];
\&
\&      push @$coercions, \*(AqArrayRef\*(Aq, sub {
\&        my $value = @_ ? $_[0] : $_;
\&        my $items = [];
\&
\&        for (my $i = 0; $i < @$value; $i++) {
\&          return $value unless $anon\->check($value\->[$i]);
\&          $items\->[$i] = $data\->coerce($value\->[$i]);
\&        }
\&
\&        return $type\->coerce($items);
\&      };
\&
\&      return $coercions;
\&    },
\&    parent => \*(AqObject\*(Aq
\&  };
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object-types/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object-types/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object-types>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object-types/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object-types/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object-types/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object-types/issues>
