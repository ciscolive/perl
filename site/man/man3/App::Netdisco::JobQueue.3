.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Netdisco::JobQueue 3"
.TH App::Netdisco::JobQueue 3 "2020-11-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
App::Netdisco::JobQueue
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Interface for Netdisco job queue.
.PP
There are no default exports, however the \f(CW\*(C`:all\*(C'\fR tag will export all
subroutines.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.ie n .SS "jq_getsome( $num? )"
.el .SS "jq_getsome( \f(CW$num\fP? )"
.IX Subsection "jq_getsome( $num? )"
Returns a list of randomly selected queued jobs. Default is to return one job,
unless \f(CW$num\fR is provided. Jobs are returned as objects which implement the
Netdisco job instance interface (see below).
.SS "\fBjq_locked()\fP"
.IX Subsection "jq_locked()"
Returns the list of jobs currently booked out to this processing node (denoted
by the local hostname). Jobs are returned as objects which implement the
Netdisco job instance interface (see below).
.ie n .SS "jq_queued( $job_type )"
.el .SS "jq_queued( \f(CW$job_type\fP )"
.IX Subsection "jq_queued( $job_type )"
Returns a list of \s-1IP\s0 addresses of devices which currently have a job of the
given \f(CW$job_type\fR queued (e.g. \f(CW\*(C`discover\*(C'\fR, \f(CW\*(C`arpnip\*(C'\fR, etc).
.SS "\fBjq_warm_thrusters()\fP"
.IX Subsection "jq_warm_thrusters()"
Performs initialisation of the Job Queue backend.
.SS "\fBjq_log()\fP"
.IX Subsection "jq_log()"
Returns a list of the most recent jobs as defined in \f(CW\*(C`jobs_qdepth\*(C'\fR from the
queue. Jobs are returned as objects which implement the Netdisco job instance
interface (see below).
.ie n .SS "jq_userlog( $user )"
.el .SS "jq_userlog( \f(CW$user\fP )"
.IX Subsection "jq_userlog( $user )"
Returns a list of jobs which have been entered into the queue by the passed
\&\f(CW$user\fR. Jobs are returned as objects which implement the Netdisco job
instance interface (see below).
.ie n .SS "jq_lock( $job )"
.el .SS "jq_lock( \f(CW$job\fP )"
.IX Subsection "jq_lock( $job )"
Marks a job in the queue as booked out to this processing node (denoted by the
local hostname). The \f(CW$job\fR parameter must be an object which implements the
Netdisco job instance interface (see below).
.PP
Returns true if successful else returns false.
.ie n .SS "jq_defer( $job )"
.el .SS "jq_defer( \f(CW$job\fP )"
.IX Subsection "jq_defer( $job )"
Marks a job in the queue as available for taking. This is usually done after a
job is booked but the processing node changes its mind and decides to return
the job to the queue. The \f(CW$job\fR parameter must be an object which implements
the Netdisco job instance interface (see below).
.PP
Returns true if successful else returns false.
.ie n .SS "jq_complete( $job )"
.el .SS "jq_complete( \f(CW$job\fP )"
.IX Subsection "jq_complete( $job )"
Marks a job as complete. The \f(CW$job\fR parameter must be an object which
implements the Netdisco job instance interface (see below). The queue item's
status, log and finished fields will be updated from the passed \f(CW$job\fR.
.PP
Returns true if successful else returns false.
.SS "jq_insert( \e%job | [ \e%job, \e%job ...] )"
.IX Subsection "jq_insert( %job | [ %job, %job ...] )"
Adds the passed jobs to the queue.
.ie n .SS "jq_delete( $id? )"
.el .SS "jq_delete( \f(CW$id\fP? )"
.IX Subsection "jq_delete( $id? )"
If passed the \s-1ID\s0 of a job, deletes it from the queue. Otherwise deletes \s-1ALL\s0
jobs from the queue.
.SH "Job Instance Interface"
.IX Header "Job Instance Interface"
.SS "id (auto)"
.IX Subsection "id (auto)"
.SS "entered"
.IX Subsection "entered"
.SS "started"
.IX Subsection "started"
.SS "finished"
.IX Subsection "finished"
.SS "device"
.IX Subsection "device"
.SS "port"
.IX Subsection "port"
.SS "action"
.IX Subsection "action"
.SS "subaction or extra"
.IX Subsection "subaction or extra"
.SS "status"
.IX Subsection "status"
.SS "username"
.IX Subsection "username"
.SS "userip"
.IX Subsection "userip"
.SS "log"
.IX Subsection "log"
.SS "debug"
.IX Subsection "debug"
