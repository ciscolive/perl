.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Exhaustion 3"
.TH Marpa::R2::Exhaustion 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
Marpa::R2::Exhaustion \- Parse exhaustion in the \s-1SLIF\s0
.SH "About this document"
.IX Header "About this document"
This page is part of the reference documents for the recognizer objects
of Marpa's \s-1SLIF\s0 (Scanless interface).
It contains a detailed discussion of parse exhaustion.
.SH "Exhaustion"
.IX Header "Exhaustion"
At bottom, \fBparse exhaustion\fR is a simple concept.
The recognizer may reach a point where there is
simply no way to continue successfully.
Regardless of what it reads next,
the parse will fail.
When this happens, the parse is said to be \fBexhausted\fR.
.PP
Some users have confused parse exhaustion with parse failure.
But other users have confused parse exhaustion with parse success.
That is because,
for a particular grammar,
there can be a strong association between parse exhaustion
and parse success,
but the strong association can go either way.
Grammars can be either exhaustion-loving or exhaustion-hating.
\&\fBBoth\fR kinds of grammar are very common in
practical application.
.SH "Hate and love"
.IX Header "Hate and love"
In an \fBexhaustion-hating\fR application,
parse exhaustion is typically parse failure.
C programs, Perl scripts and most programming languages
are exhaustion-hating applications.
If a C program is well-formed,
it is always possible to read more input.
The same is true of a Perl program that does not have a \f(CW\*(C`_\|_DATA_\|_\*(C'\fR section.
.PP
In an \fBexhaustion-loving\fR applications
parse exhaustion means parse success.
A toy example of an exhaustion-loving
application is the language consisting of balanced parentheses.
When the parentheses come into perfect balance the parse is exhausted,
because any further input would unbalance the brackets.
And the parse succeeds when the parentheses come into perfect balance.
Exhaustion means success.
.PP
Any language which balances start and end indicators will tend to
be exhaustion-loving.
\&\s-1HTML\s0 and \s-1XML,\s0 with their start and end tags, can be seen
as exhaustion-loving languages.
.PP
For many languages, it's not strictly love or hate.
I mentioned Perl's \f(CW\*(C`_\|_DATA_\|_\*(C'\fR as a complication in a
basically exhaustion-hating language.
It is possible for a language to be
exhaustion-loving at some points
and exhaustion-hating at others.
We can call those languages \fBexhaustion-conflicted\fR.
.SH "Reading methods"
.IX Header "Reading methods"
The methods that may encounter parse exhaustion are those
that read input:
\&\fBread()\fR,
\&\fBresume()\fR,
\&\fBlexeme_complete()\fR,
and \fBlexeme_read()\fR.
These are also, and not by coincidence, the event-triggering methods.
In this document, we will call them the \fBreading methods\fR.
.SH "Synchronous and asynchronous parse exhaustion"
.IX Header "Synchronous and asynchronous parse exhaustion"
Intuitively, parse exhaustion is \fBsynchonous\fR if it
occurs at a location where control would return to
the user anyway, and asynchronous otherwise.
More precisely,
we say that parse exhaustion is \fBsynchronous\fR
if it occurs at a point when control
would normally return from \s-1SLIF\s0 to the application,
due to either
.IP "\(bu" 4
the parse reaching end of string (\s-1EOS\s0), or
.IP "\(bu" 4
the occurrence of
a parse event other than an exhaustion event.
.PP
Marpa can be set up so that an event occurs on
asynchronous exhaustion.
Note that in The definition above
the occurrence of an exhaustion event
does not makes the parse exhaustion synchronous.
This wording is chosen to avoid a paradox.
If a parse exhaustion event could made exhaustion synchronous,
then it \fBshould not\fR occur, because parse exhaustion events
only occur on asynchronous parse exhaustion.
But if the parse exhaustion event did not occur,
then the parse exhaustion would be asynchronous, so that
then a parse exhaustion event \fBshould\fR occur.
.PP
In this document, an \fBexhaustion location\fR is
a location at which parse exhaustion occurs.
.SH "Handling parse exhaustion"
.IX Header "Handling parse exhaustion"
How parse exhaustion is handled depends on the setting
of the
\&\s-1SLIF\s0's \f(CW\*(C`exhaustion\*(C'\fR recognizer
setting.
The value of this may be "\f(CW\*(C`fatal\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`event\*(C'\fR\*(L".
(\*(R"\f(CW\*(C`fatal\*(C'\fR" is the default.)
.PP
Synchronous parse exhaustion is always ignored,
regardless of the recognizer setting.
No exhaustion event is triggered by synchronous
parse exhaustion.
.PP
If the \f(CW\*(C`exhaustion\*(C'\fR setting is "\f(CW\*(C`fatal\*(C'\fR",
asynchronous parse exhaustion is thrown
as a fatal error.
If the \f(CW\*(C`exhaustion\*(C'\fR setting is "\f(CW\*(C`event\*(C'\fR",
then an
exhaustion event
is triggered, returning control to the application.
This is treated by the
triggering method as a successful return.
.PP
Note that the
\&\fBlexeme_complete()\fR,
and \fBlexeme_read()\fR,
always ignore
parse exhaustion,
regardless of the \f(CW\*(C`exhaustion\*(C'\fR recognizer setting.
This is because these methods
read input only at a single location,
so that every parse exhaustion is synchronous.
.SH "Detecting parse exhaustion"
.IX Header "Detecting parse exhaustion"
The return value of
a reading method
does not indicate whether exhaustion occurred or not.
In most cases, you will either know
from the the context whether the parse is exhausted,
or you will not care.
But what if you do not know and do care?
.PP
Those applications that want to know whether
a parse is exhausted or not
can directly query
parse exhaustion status
with
the \f(CW\*(C`exhausted()\*(C'\fR method.
Even when parse exhaustion events
are enabled,
using the \f(CW\*(C`exhausted()\*(C'\fR method is the preferred method for detecting exhaustion,
because it reports both asynchronous and synchronous parse exhaustion.
Exhaustion events only trigger in cases of asynchronous parse exhaustion.
.SH "Exhaustion-conflicted"
.IX Header "Exhaustion-conflicted"
Exhaustion-conflicted applications are those which cannot be
called exhaustion-loving or exhaustion-hating.
This may be because their behavior is a combination of the two.
But it may also be because the application's behavior is not known \*(--
for example, while developing an application, it's convenient
to assume that it is exhaustion-conflicted.
.PP
The \s-1SLIF\s0's behavior for exhaustion-conflicted applications has to be aimed
at a \*(L"lowest common denominator\*(R".
It is also a good idea for a default to be a lowest common
denominator and,
by default,
the \s-1SLIF\s0 assumes that an application
is exhausted-conflicted.
In fact,
the default behavior on parse exhaustion
usually works well enough
that it does not need customizing.
.PP
For a typical application without events, end of parse (\s-1EOP\s0)
is end of string (\s-1EOS\s0).
In this case exhaustion before \s-1EOS\s0 is a fatal error,
which is usually what is desired.
On return due to \s-1EOS,\s0
unless the application checks,
it will not know whether exhaustion occurred, but usually
it does not care.
If the application does care, it can
check for exhaustion explicitly.
.PP
If the application uses events to signal \s-1EOP,\s0
the case is much the same.
On return due to an event,
the application will not know if exhaustion occurred,
but usually
it will not care.
If the application does care, it can
check for exhaustion explicitly.
.PP
If the application uses events for other purposes,
an event may \*(L"hide\*(R" exhaustion, so that it is not
thrown as an error.
Typically, an application will soon attempt to continue
the reading of input,
and when it does there will be a fatal
error.
An application which wants to know about exhaustion immediately,
either to \*(L"fast fail\*(R" or for other reasons,
can
check for exhaustion explicitly
every time an event triggers.
.SS "Exhaustion-loving"
.IX Subsection "Exhaustion-loving"
For an exhaustion-loving application,
what was said for exhaustion-conflicted applications
applies without change.
Applications that consider it important to confirm
that exhaustion did occur at \s-1EOP\s0 can
check for exhaustion explicitly
.PP
Some applications go beyond being exhaustion-loving,
and want to use exhaustion to signal the \s-1EOP.\s0
These exhaustion-sensing applications are
discussed below.
.SS "Exhaustion-hating"
.IX Subsection "Exhaustion-hating"
Exhaustion-hating applications are handled reasonably
by the default behavior.
Asynchronous exhaustion will be a fatal error.
Synchronous exhaustion
will cause failure at the next read,
unless it happens at \s-1EOP.\s0
By default, exhaustion at \s-1EOP\s0 will go unreported
but if an application really is exhaustion-hating,
the parse will fail,
and parse failure will certainly show up
when the application tries to evaluate the parse.
.PP
Exhaustion-hating applications, if they want to be stricter
than this,
can check for exhaustion explicitly whenever
a reading method returns.
A possible annoyance is that, depending where it happens,
exhaustion may also cause the reading method to throw an exception.
Applications which want more orthogonality in their exhaustion handling
can enable exhaustion events,
which will prevent exceptions being thrown due to parse exhaustion.
.SH "Exhaustion-sensing"
.IX Header "Exhaustion-sensing"
Sometimes an application, rather than read
an entire input,
wants to find the longest occurrence starting at some location.
(Lexers are typically applications of this kind.)
Looking for exhaustion is one way to try to implement this
kind of \*(L"longest acceptable input stream\*(R" search.
But exhaustion-sensing is not necessarily the best way,
or even a good way,
to find the \*(L"longest parse\*(R".
Exhaustion may not happen until after last successful parse \*(--
sometimes not until long after it.
Completion parse events may be a cleaner way to deal with this.
.PP
Applications which do want to use parse exhaustion as part of
a strategy for finding the \s-1EOP\s0
can set the
\&\s-1SLIF\s0's \f(CW\*(C`exhaustion\*(C'\fR recognizer setting
to "\f(CW\*(C`event\*(C'\fR", so that a parse event occurs at parse exhaustion.
When the event-triggering method returns, the application
can then
check for exhaustion explicitly.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
