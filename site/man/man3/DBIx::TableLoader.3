.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::TableLoader 3"
.TH DBIx::TableLoader 3 "2019-05-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::TableLoader \- Easily load a database table from a data set
.SH "VERSION"
.IX Header "VERSION"
version 1.101
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $dbh = DBI\->connect(@connection_args);
\&
\&  DBIx::TableLoader\->new(dbh => $dbh, data => $data)\->load();
\&
\&  # interact with new database table full of data in $dbh
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module tries to provide a fast and simple (but very configurable)
interface for taking a set of data and loading it into a database table.
.PP
Common uses would be to take data from a file (like a \s-1CSV\s0)
and load it into a SQLite table.
(For that specific case see DBIx::TableLoader::CSV.)
.PP
In most cases simply calling \f(CW\*(C`load()\*(C'\fR is sufficient,
but all methods are documented below for completeness.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Create a new instance.  Accepts a hash or hashref of options.
.PP
This module is very configurable but tries to use good defaults
in the hopes that you won't need to configure too much in most cases.
.PP
Most likely needed options:
.IP "\(bu" 4
\&\f(CW\*(C`dbh\*(C'\fR \- A \fBd\fRata\fBb\fRase \fBh\fRandle as returned by \f(CW\*(C`DBI\->connect()\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- An arrayref of arrayrefs of data (which will be the input records)
.PP
See \*(L"\s-1OPTIONS\*(R"\s0 for the full list.
.SS "base_defaults"
.IX Subsection "base_defaults"
Returns a hashref of the options defined by the base class
and their default values.
.SS "defaults"
.IX Subsection "defaults"
Returns a hashref of additional options defined by a subclass.
.SS "columns"
.IX Subsection "columns"
.Vb 2
\&  my $columns = $loader\->columns;
\&  # [ [\*(Aqcolumn1\*(Aq, \*(Aqdata type\*(Aq], [\*(Aqcolumn two\*(Aq, \*(Aqdata type\*(Aq] ]
.Ve
.PP
Returns an arrayref of the columns.
Each element is an arrayref of column name and column data type.
.SS "column_names"
.IX Subsection "column_names"
.Vb 2
\&  my $column_names = $loader\->column_names;
\&  # [\*(Aqcolumn1\*(Aq, \*(Aqcolumn two\*(Aq]
.Ve
.PP
Returns an arrayref of the column names.
.SS "create"
.IX Subsection "create"
Executes a \f(CW\*(C`CREATE TABLE\*(C'\fR \s-1SQL\s0 statement on the database handle.
.SS "create_prefix"
.IX Subsection "create_prefix"
Generates the opening of the \f(CW\*(C`CREATE TABLE\*(C'\fR statement
(everything before the column specifications).
.PP
Defaults to \f(CW"CREATE $table_type TABLE $quoted_name ("\fR.
.SS "create_sql"
.IX Subsection "create_sql"
Generates the \s-1SQL\s0 for the \f(CW\*(C`CREATE TABLE\*(C'\fR statement
by concatenating \*(L"create_prefix\*(R",
the column definitions,
and \*(L"create_suffix\*(R".
.PP
Can be overridden in the constructor.
.SS "create_suffix"
.IX Subsection "create_suffix"
Generates the closing of the \f(CW\*(C`CREATE TABLE\*(C'\fR statement
(everything after the column specifications).
.PP
Defaults to \f(CW")"\fR.
.SS "default_name"
.IX Subsection "default_name"
Returns the default (base) name for the table.
.PP
This is mostly for subclasses where a useful table name
can be determined from the input (like a filename).
In this module it defaults to \f(CW\*(Aqdata\*(Aq\fR.
.PP
This gets concatenated together with
\&\*(L"name_prefix\*(R" and \*(L"name_suffix\*(R" in \*(L"name\*(R".
.SS "default_column_type"
.IX Subsection "default_column_type"
Columns that have not been given an explicit data type
will be defined using the \f(CW\*(C`default_column_type\*(C'\fR.
.PP
You can pass a value explicitly to the constructor,
or it will try to determine an appropriate (string) type
based on the database driver (using \*(L"default_sql_data_type\*(R").
.PP
If all else fails it will default to \f(CW\*(C`text\*(C'\fR
(which works for SQLite, PostgreSQL, MySQL, and some others).
.SS "default_sql_data_type"
.IX Subsection "default_sql_data_type"
Passed to \*(L"type_info\*(R" in \s-1DBI\s0 to query the database driver
for an appropriate default column type.
.PP
Defaults to \f(CW\*(C`DBI::SQL_LONGVARCHAR\*(C'\fR.
.SS "determine_column_types"
.IX Subsection "determine_column_types"
This method goes through the \f(CW\*(C`columns\*(C'\fR and converts any scalar
column name to an arrayref of column name and \f(CW\*(C`default_column_type\*(C'\fR.
It modifies itself and returns nothing.
It is called automatically from the constructor.
.SS "drop"
.IX Subsection "drop"
Execute the \f(CW\*(C`DROP TABLE\*(C'\fR statement on the database handle.
.SS "drop_prefix"
.IX Subsection "drop_prefix"
Returns the portion of the \s-1SQL\s0 statement before the table name.
.PP
Defaults to \f(CW\*(C`DROP TABLE\*(C'\fR.
.SS "drop_sql"
.IX Subsection "drop_sql"
Generates the \s-1SQL\s0 for the \f(CW\*(C`DROP TABLE\*(C'\fR statement
by concatenating \*(L"drop_prefix\*(R", \*(L"quoted_name\*(R", and \*(L"drop_suffix\*(R".
.PP
Alternatively \f(CW\*(C`drop_sql\*(C'\fR can be set in the constructor
if you need something more complex.
.SS "drop_suffix"
.IX Subsection "drop_suffix"
Returns the portion of the \s-1SQL\s0 statement after the table name.
.PP
Nothing by default.
.SS "get_raw_row"
.IX Subsection "get_raw_row"
Subclasses will override this method according to the input data format.
.PP
This is called from \*(L"get_row\*(R" to retrieve the next row of raw data.
.PP
It should return \f(CW\*(C`undef\*(C'\fR when there are no more rows.
.SS "get_row"
.IX Subsection "get_row"
.Vb 1
\&  my $row = $loader\->get_row();
.Ve
.PP
Returns a single row of data at a time (as an arrayref).
This method will be called repeatedly until it returns \f(CW\*(C`undef\*(C'\fR.
The returned arrayref will be flattened and passed to \*(L"execute\*(R" in \s-1DBI\s0.
.SS "handle_invalid_row"
.IX Subsection "handle_invalid_row"
This is called from \*(L"get_row\*(R" when a row is determined to be invalid
(when \*(L"validate_row\*(R" throws an error).
.PP
If \f(CW\*(C`handle_invalid_row\*(C'\fR was not specified in the constructor
this method is a no-op:
the original row will be returned (and eventually passed to \*(L"execute\*(R" in \s-1DBI\s0).
.PP
Possible values for the \f(CW\*(C`handle_invalid_row\*(C'\fR option:
.IP "\(bu" 4
\&\f(CW\*(C`die\*(C'\fR  \- Calls \f(CW\*(C`die()\*(C'\fR  with the error message
.IP "\(bu" 4
\&\f(CW\*(C`warn\*(C'\fR \- Calls \f(CW\*(C`warn()\*(C'\fR with the error message and returns the row unmodified
.IP "\(bu" 4
code ref
.Sp
If it's a subroutine reference it is called as a method,
receiving the loader object, the error message, and the row:
.Sp
.Vb 1
\&  $handler\->($loader, $error, $row);
.Ve
.Sp
The handler should either \f(CW\*(C`die\*(C'\fR to cease processing,
return false to skip this row and get the next one,
or return a (possibly modified) row that will be passed to \*(L"execute\*(R" in \s-1DBI\s0.
.Sp
This allows you to, for example, write to a log when a bad row
is found without aborting your transaction:
.Sp
.Vb 5
\&  handle_invalid_row => sub {
\&    my ($self, $error, $row) = @_;
\&    $logger\->log([\*(AqBad row: %s: %s\*(Aq, $error, $row]);
\&    return; # return false to skip this row and move to the next one
\&  }
.Ve
.SS "insert_sql"
.IX Subsection "insert_sql"
Generate the \f(CW\*(C`INSERT\*(C'\fR \s-1SQL\s0 statement that will be passed to \*(L"prepare\*(R" in \s-1DBI\s0.
.SS "insert_all"
.IX Subsection "insert_all"
Execute an \f(CW\*(C`INSERT\*(C'\fR statement on the database handle for each row of data.
It will call \*(L"prepare\*(R" in \s-1DBI\s0 using \*(L"insert_sql\*(R"
and then call \*(L"execute\*(R" in \s-1DBI\s0 once for each row returned by \*(L"get_row\*(R".
.SS "load"
.IX Subsection "load"
.Vb 1
\&  my $number_of_rows = $loader\->load();
.Ve
.PP
Load data into database table.
This is a wrapper that does the most commonly needed things
in a single method call.
If the \f(CW\*(C`transaction\*(C'\fR setting is true (default)
the actions will be wrapped in a transaction.
.IP "\(bu" 4
\&\*(L"drop\*(R" (if configured)
.IP "\(bu" 4
\&\*(L"create\*(R" (if configured)
.IP "\(bu" 4
\&\*(L"insert_all\*(R"
.PP
Returns the number of rows inserted.
.SS "name"
.IX Subsection "name"
Returns the full table name
(concatenation of \f(CW\*(C`name_prefix\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`name_suffix\*(C'\fR).
.SS "prepare_data"
.IX Subsection "prepare_data"
This method is called from \*(L"new\*(R" after the object is blessed (obviously).
Any preparation work specific to the type of data should be done here.
.PP
This is mostly a hook for subclasses and does very little in this module.
.SS "quoted_name"
.IX Subsection "quoted_name"
Returns the full, quoted table name.
Passes \f(CW\*(C`catalog\*(C'\fR, \f(CW\*(C`schema\*(C'\fR, and \f(CW\*(C`name\*(C'\fR attributes to \*(L"quote_identifier\*(R" in \s-1DBI\s0.
.SS "quoted_column_names"
.IX Subsection "quoted_column_names"
.Vb 2
\&  my $quoted_names = $loader\->quoted_column_names();
\&  # [\*(Aq"column1"\*(Aq, \*(Aq"column two"\*(Aq]
.Ve
.PP
Returns an arrayref of column names quoted by the database driver.
.SS "validate_row"
.IX Subsection "validate_row"
Called from \*(L"get_row\*(R" to check that the provided row is valid.
.PP
It may \f(CW\*(C`die\*(C'\fR for any error
which will be caught in \*(L"get_row\*(R"
and the error will be passed to \*(L"handle_invalid_row\*(R".
.PP
The return value works like that of \*(L"handle_invalid_row\*(R":
On success, the valid row (possibly modified) should be returned.
If a false value is returned \*(L"get_row\*(R" will attempt to
get another row.
.PP
Currently this only checks that the number of fields in the row
matches the number of columns expected,
however other checks may be added in the future.
Subclasses can overwrite this to define their own validations
(though calling the original (superclass method) is recommended).
.SH "OPTIONS"
.IX Header "OPTIONS"
This module is very [excessively] configurable.
In most cases the default values will be sufficient,
but you should be able to customize the object to fit your needs.
.PP
Frequently Used Options:
.IP "\(bu" 4
\&\f(CW\*(C`columns\*(C'\fR \- Arrayref of column definitions
.Sp
Each element can be an arrayref of column name and data type
or just a string for the column name and \*(L"default_column_type\*(R" will be used.
If not passed in the first row of \f(CW\*(C`data\*(C'\fR will be assumed to be column names.
.Sp
.Vb 1
\&  columns => [\*(Aqfirst_name\*(Aq, \*(Aqlast_name\*(Aq, [\*(Aqlast_seen\*(Aq, \*(Aqdate\*(Aq]]
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`dbh\*(C'\fR \- A database handle as returned by \f(CW\*(C`DBI\->connect()\*(C'\fR
.Sp
This module probably isn't useful without one.
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- An arrayref of arrayrefs of data to populate the table;
.Sp
Subclasses may define more appropriate options and ignore this parameter.
If you're using this base class, you'll probably need this
(unless you provide your own \f(CW\*(C`get_row\*(C'\fR coderef).
.Sp
.Vb 1
\&  data => [ [\*(Aqpolar\*(Aq, \*(Aqbear\*(Aq, \*(Aq2010\-08\-15\*(Aq], [\*(Aqblue\*(Aq, \*(Aqduck\*(Aq, \*(Aq2009\-07\-30\*(Aq] ]
.Ve
.PP
Less common options that are available when you desire extra tweaking power:
.IP "\(bu" 4
\&\f(CW\*(C`create\*(C'\fR \- Boolean; Whether or not to perform the \f(CW\*(C`CREATE TABLE\*(C'\fR statement
.Sp
Defaults to true.
.IP "\(bu" 4
\&\f(CW\*(C`default_column_type\*(C'\fR \- Default data type for each column
.Sp
This will be used for each column that does not explicitly define a data type.
The default will be determined from the database driver
using \f(CW\*(C`default_sql_data_type\*(C'\fR.  See \*(L"default_column_type\*(R".
.Sp
.Vb 1
\&  default_column_type => \*(AqCHAR(50)\*(Aq
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`drop\*(C'\fR \- Boolean to execute a \f(CW\*(C`DROP TABLE\*(C'\fR statement before \f(CW\*(C`CREATE TABLE\*(C'\fR
.Sp
Defaults to false.  Set it to true if the named table already exists and you
want to recreate it.
.IP "\(bu" 4
\&\f(CW\*(C`get_row\*(C'\fR \- A sub (coderef) that will override \*(L"get_raw_row\*(R"
.Sp
You can use this if your input data is in a different format
than the module expects (to split a string into an arrayref, for instance).
This is called like a method (the object will be \f(CW$_[0]\fR).
The return value will be passed to \f(CW\*(C`map_rows\*(C'\fR if both are present.
.Sp
.Vb 3
\&  # each record is a line from a log file;
\&  # use the m// operator in list context to capture desired fields
\&  get_row => sub { my $s = <$io>; [ $s =~ m/^(\ed+)\es+"([^"]+)"\es+(\eS+)$/ ] }
.Ve
.Sp
\&\f(CW\*(C`NOTE\*(C'\fR: If you use \f(CW\*(C`get_row\*(C'\fR and don't pass \f(CW\*(C`data\*(C'\fR
you will probably want to pass \f(CW\*(C`columns\*(C'\fR
(otherwise columns will be taken from the first call to \f(CW\*(C`get_row\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`grep_rows\*(C'\fR \- A sub (coderef) to determine if a row should be used or skipped
.Sp
Named after the built in \f(CW\*(C`grep\*(C'\fR function.
It will receive the row as an arrayref in \f(CW$_[0]\fR.
(The row will also be available in \f(CW$_\fR
for consistency with the built in \f(CW\*(C`grep\*(C'\fR.)
The object will be passed as \f(CW$_[1]\fR in case you want it.
If it returns a true value the row will be used.
If it returns false the next row will be fetched and the process will repeat
(until all rows have been exhausted).
.Sp
.Vb 1
\&  grep_rows => sub { $_\->[1] =~ /something/ } # accept the row if it matches
\&
\&  grep_rows => sub { my ($row, $obj) = @_; do_something(); } # 2 variables
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`handle_invalid_row\*(C'\fR \- How to handle invalid rows.
.Sp
Can be \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`warn\*(C'\fR, or a sub (coderef).
See \*(L"handle_invalid_row\*(R" for more details.
Default is to ignore (in which case \s-1DBI\s0 will likely error).
.IP "\(bu" 4
\&\f(CW\*(C`map_rows\*(C'\fR \- A sub (coderef) to filter/mangle a row before use
.Sp
Named after the built in \f(CW\*(C`map\*(C'\fR function.
It will receive the row as an arrayref in \f(CW$_[0]\fR.
(The row will also be available in \f(CW$_\fR
for consistency with the built in \f(CW\*(C`map\*(C'\fR.)
The object will be passed as \f(CW$_[1]\fR in case you want it.
It should return an arrayref (which will be used as the row).
.Sp
.Vb 1
\&  map_rows => sub { [ map { uc $_ } @$_ ] } # uppercase all the fields
\&
\&  map_rows => sub { my ($row, $obj) = @_; do_something(); } # 2 variables
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR \- Table name
.Sp
Defaults to \f(CW\*(Aqdata\*(Aq\fR.  Subclasses may provide a more useful default.
.IP "\(bu" 4
\&\f(CW\*(C`table_type\*(C'\fR \- String that will go before \f(CW\*(C`TABLE\*(C'\fR in \*(L"create_prefix\*(R"
.Sp
A useful value might be \f(CW\*(C`TEMPORARY\*(C'\fR or \f(CW\*(C`TEMP\*(C'\fR.
This is probably database driver dependent, so use an appropriate value.
.IP "\(bu" 4
\&\f(CW\*(C`transaction\*(C'\fR \- Boolean
.Sp
All the operations in \*(L"load\*(R" will be wrapped in a transaction by default.
Set this option to false to disable this.
.PP
Options that will seldom be necessary
but are available for completeness and/or consistency:
.IP "\(bu" 4
\&\f(CW\*(C`catalog\*(C'\fR \- Table catalog
.Sp
Passed to \*(L"quote_identifier\*(R" in \s-1DBI\s0 to get the full, quoted table name.
None by default.
.IP "\(bu" 4
\&\f(CW\*(C`create_prefix\*(C'\fR \- The opening of the \s-1SQL\s0 statement
.Sp
See \*(L"create_prefix\*(R".  Overwrite if you need something more complex.
.IP "\(bu" 4
\&\f(CW\*(C`create_sql\*(C'\fR \- The \f(CW\*(C`CREATE TABLE\*(C'\fR statement
.Sp
See \*(L"create_sql\*(R".  Overwrite if you need something more complex.
.IP "\(bu" 4
\&\f(CW\*(C`create_suffix\*(C'\fR \- The closing of the \s-1SQL\s0 statement
.Sp
See \*(L"create_suffix\*(R".  Overwrite if you need something more complex.
.IP "\(bu" 4
\&\f(CW\*(C`default_sql_data_type\*(C'\fR \- Default \s-1SQL\s0 standard data type
.Sp
If \f(CW\*(C`default_column_type\*(C'\fR is not supplied it will be determined by
asking the database driver for a type corresponding to \f(CW\*(C`DBI::SQL_LONGVARCHAR\*(C'\fR.
Alternate values can be passed (\f(CW\*(C`DBI::SQL_VARCHAR()\*(C'\fR for instance).
See \*(L"default_sql_data_type\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`drop_prefix\*(C'\fR \- The opening of the \s-1SQL\s0 statement
.Sp
See \*(L"drop_prefix\*(R".  Overwrite if you need something more complex.
.IP "\(bu" 4
\&\f(CW\*(C`drop_sql\*(C'\fR \- The \f(CW\*(C`DROP TABLE\*(C'\fR statement
.Sp
Will be constructed if not provided.  See \*(L"drop_sql\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`drop_suffix\*(C'\fR \- The closing of the \s-1SQL\s0 statement
.Sp
See \*(L"drop_suffix\*(R".  Overwrite if you need something more complex.
.IP "\(bu" 4
\&\f(CW\*(C`name_prefix\*(C'\fR \- String prepended to table name
.Sp
Probably mostly useful in subclasses where \f(CW\*(C`name\*(C'\fR is determined automatically.
.IP "\(bu" 4
\&\f(CW\*(C`name_suffix\*(C'\fR \- String appended to table name
.Sp
Probably mostly useful in subclasses where \f(CW\*(C`name\*(C'\fR is determined automatically.
.IP "\(bu" 4
\&\f(CW\*(C`quoted_name\*(C'\fR \- Full table name, properly quoted
.Sp
Only necessary if you need something more complicated than
\&\f(CW\*(C`$dbh\->quote_identifier($catalog, $schema, $table)\*(C'\fR
(see \*(L"quote_identifier\*(R" in \s-1DBI\s0).
.IP "\(bu" 4
\&\f(CW\*(C`schema\*(C'\fR \- Table schema
.Sp
Passed to \*(L"quote_identifier\*(R" in \s-1DBI\s0 to get the full, quoted table name.
None by default.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
This module was designed to be subclassed
for use with specific data input formats.
.PP
DBIx::TableLoader::CSV is a prime example.
It is the entire reason this base module was designed.
.PP
Subclasses will likely want to override the following methods:
.IP "\(bu" 4
\&\*(L"defaults\*(R" \- a hashref of additional acceptable options (and default values)
.IP "\(bu" 4
\&\*(L"default_name\*(R" \- if you can determine a good default name from the input
.IP "\(bu" 4
\&\*(L"get_raw_row\*(R" \- to return the next row of data
.IP "\(bu" 4
\&\*(L"prepare_data\*(R" \- to initialize your object/data (open the file, etc.)
.PP
Be sure to check out the code for DBIx::TableLoader::CSV.
Also see a very simple example in \fIt/subclass.t\fR.
.SH "RATIONALE"
.IX Header "RATIONALE"
It seemed frequent that I would find a data set that was difficult to
view/analyze (\s-1CSV,\s0 log file, etc.) and would prefer to load it into a database
for its powerful, familiar processing abilities.
.PP
I once chose to use MySQL because its built in \f(CW\*(C`LOAD DATA\*(C'\fR command
read the malformed \s-1CSV I\s0 was given and the \f(CW\*(C`.import\*(C'\fR command in SQLite did not.
.PP
I wrote this module so that I'd never have to make such a choice again.
I wanted to be able to use the power of Text::CSV to make sure I could
take any \s-1CSV I\s0 ever got and load it into SQLite easily.
.PP
I tried to make this module a base class to be able to handle various formats.
.SH "TODO"
.IX Header "TODO"
This is more of a list of ideas than features that are planned.
.IP "\(bu" 4
Allow a custom column name transformation sub to be passed in
.IP "\(bu" 4
Use \*(L"decamelize\*(R" in String::CamelCase by default?
.IP "\(bu" 4
Allow extra columns (like \f(CW\*(C`id\*(C'\fR) to be added and/or generated
.IP "\(bu" 4
Option to scan the data to guess appropriate data types for each column
.IP "\(bu" 4
Make a SQLite function so that you could call this from a \f(CW\*(C`dbish\*(C'\fR command line?
.IP "\(bu" 4
Allow \f(CW\*(C`UPDATE\*(C'\fR statements and specify the key columns (for the \f(CW\*(C`WHERE\*(C'\fR clause)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
DBIx::TableLoader::CSV
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Perldoc"
.IX Subsection "Perldoc"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&  perldoc DBIx::TableLoader
.Ve
.SS "Websites"
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP "\(bu" 4
MetaCPAN
.Sp
A modern, open-source \s-1CPAN\s0 search engine, useful to view \s-1POD\s0 in \s-1HTML\s0 format.
.Sp
<https://metacpan.org/release/DBIx\-TableLoader>
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests by email to \f(CW\*(C`bug\-dbix\-tableloader at rt.cpan.org\*(C'\fR, or through
the web interface at <https://rt.cpan.org/Public/Bug/Report.html?Queue=DBIx\-TableLoader>. You will be automatically notified of any
progress on the request by the system.
.SS "Source Code"
.IX Subsection "Source Code"
<https://github.com/rwstauner/DBIx\-TableLoader>
.PP
.Vb 1
\&  git clone https://github.com/rwstauner/DBIx\-TableLoader.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy Stauner <rwstauner@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Randy Stauner <randy@magnificent\-tears.com>
.IP "\(bu" 4
Randy Stauner <randy@r4s6.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Randy Stauner.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
