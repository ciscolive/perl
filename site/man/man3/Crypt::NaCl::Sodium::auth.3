.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::NaCl::Sodium::auth 3"
.TH Crypt::NaCl::Sodium::auth 3 "2015-12-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::NaCl::Sodium::auth \- Secret\-key message authentication (HMAC\-SHA256, HMAC\-SHA512, HMAC\-SHA512/256 )
.SH "VERSION"
.IX Header "VERSION"
version 1.0.8.0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Crypt::NaCl::Sodium qw( :utils );
\&
\&    my $crypto_auth = Crypt::NaCl::Sodium\->auth();
\&
\&    my ($key, $mac, $msg);
\&
\&    ## Alice
\&    ########
\&
\&    # Alice generates secret key
\&    $key = $crypto_auth\->keygen();
\&
\&    # ... and shares it with Bob
\&    send_to( Bob => { key => $key } );
\&
\&    # now Alice and Bob can start communicating
\&
\&    # Alice\*(Aqs message to Bob
\&    $msg = "Hi Bob!";
\&
\&    # MAC guarantees message integrity and authenticity
\&    $mac = $crypto_auth\->mac( $msg, $key );
\&
\&    # we can now send unencrypted message to Bob
\&    send_to( Bob => { msg => $msg } );
\&
\&    # and MAC confirming that Alice has wrote it
\&    send_to( Bob => { mac => $mac } );
\&
\&    ## Bob
\&    ########
\&
\&    # Bob receives the secret key from Alice
\&    $key = receive_for( Bob => \*(Aqkey\*(Aq );
\&
\&    # Bob is now ready to receive first message from Alice
\&    $msg = receive_for( Bob => \*(Aqmsg\*(Aq );
\&
\&    # and the MAC
\&    $mac = receive_for( Bob => \*(Aqmac\*(Aq );
\&
\&    # Bob can now confirm that Alice has sent the message
\&    unless ( $crypto_auth\->verify( $mac, $msg, $key ) ) {
\&        die "Impostor alert!";
\&    }
\&
\&    # now we know that Alice is talking to us \- time to reply
\&    $msg = "Hello Alice!";
\&
\&    $mac = $crypto_auth\->mac( $msg, $key );
\&
\&    # Alice will get our reply and the MAC
\&    send_to( Alice => { msg => $msg } );
\&    send_to( Alice => { mac => $mac } );
\&
\&    ## Alice
\&    ########
\&
\&    # receiving the reply
\&    $msg = receive_for( Alice => \*(Aqmsg\*(Aq );
\&    $mac = receive_for( Alice => \*(Aqmac\*(Aq );
\&
\&    # and Alice can now confirm that it is from Bob
\&    unless ( $crypto_auth\->verify( $mac, $msg, $key ) ) {
\&        die "Impostor alert!";
\&    }
\&
\&    # NOTE: send_to() and receive_for() and user functions providing transport of
\&    # messages
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Secret-key authentication allows to compute the authentication tag (also known
as Message Authentication Code) that verifies the integrity and authenticity of
the message to those who share the secret key.
.PP
For the same message the same key will always product the same output.
.PP
Unencrypted messages and their MACs can be made public, while the key should
remain secret.
.SH "METHODS"
.IX Header "METHODS"
.SS "keygen"
.IX Subsection "keygen"
.Vb 1
\&    my $key = $crypto_auth\->keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_auth\fR.
.PP
The length of the \f(CW$key\fR equals \*(L"\s-1KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.SS "mac"
.IX Subsection "mac"
.Vb 1
\&    my $mac = $crypto_auth\->mac( $msg, $key );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using given \f(CW$key\fR.
.PP
The length of the \f(CW$mac\fR equals \*(L"\s-1BYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.SS "verify"
.IX Subsection "verify"
.Vb 3
\&    unless ( $crypto_auth\->verify( $mac, $msg, $key ) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
Verifies the integrity and authenticity of the \f(CW$msg\fR using given \f(CW$mac\fR and \f(CW$key\fR.
.PP
Method returns true if message has been verified, false otherwise.
.SH "ADVANCED USAGE"
.IX Header "ADVANCED USAGE"
Single pass and streaming \s-1API\s0 keyed message authentication using \fI\s-1HMAC\-SHA\-256\s0\fR,
\&\fI\s-1HMAC\-SHA\-512\s0\fR and \fI\s-1HMAC\-SHA\-512/256\s0\fR are described below.
.SS "\s-1HMAC\-SHA\-256\s0"
.IX Subsection "HMAC-SHA-256"
\fIhmacsha256_keygen\fR
.IX Subsection "hmacsha256_keygen"
.PP
.Vb 1
\&    my $key256 = $crypto_auth\->hmacsha256_keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_auth\fR.
.PP
The length of the \f(CW$key256\fR equals \*(L"\s-1HMACSHA256_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha256\fR
.IX Subsection "hmacsha256"
.PP
.Vb 1
\&    my $mac256 = $crypto_auth\->hmacsha256( $msg, $key256 );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using given \f(CW$key256\fR.
.PP
The length of the \f(CW$mac256\fR equals \*(L"\s-1HMACSHA256_BYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha256_verify\fR
.IX Subsection "hmacsha256_verify"
.PP
.Vb 3
\&    unless ( $crypto_auth\->hmacsha256_verify( $mac256, $msg, $key256 ) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
Verifies the integrity and authenticity of the \f(CW$msg\fR using given \f(CW$mac256\fR and
\&\f(CW$key256\fR.
.PP
Method returns true if message has been verified, false otherwise.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length, allowing it to be
used with the multi-part \s-1API.\s0
.PP
\fIMulti-part \s-1API\s0\fR
.IX Subsection "Multi-part API"
.PP
Multi-part computation is also supported.
.PP
.Vb 1
\&    my $ctx256 = $crypto_auth\->hmacsha256_init( $key );
\&
\&    $ctx256\->update( $msgX );
\&    $ctx256\->update( $msgY )\->update( $msgZ, ... );
\&
\&    my $mac256 = $ctx256\->final();
\&
\&    my $msgXYZ = join(\*(Aq\*(Aq, $msgX, $msgY, $msgZ, ...);
\&    unless ( $crypto_auth\->hmacsha256_verify( $mac256, $msgXYZ, $key) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
hmacsha256_init
.IX Subsection "hmacsha256_init"
.PP
.Vb 1
\&    my $ctx256 = $crypto_auth\->hmacsha256_init( $key );
.Ve
.PP
Creates a context for multi-part computation using given \f(CW$key\fR.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length. Key larger then the
block size gets reduced to \f(CW\*(C`sha256($key)\*(C'\fR.
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::auth::hmacsha256stream\*(C'\fR object which encapsulates
the computation state of the \fI\s-1HMAC\-SHA\-256\s0\fR algorithm.
.PP
clone
.IX Subsection "clone"
.PP
.Vb 4
\&    while ( <> ) {
\&        $ctx256\->update( $_ );
\&        print "Line: $.: ", $ctx256\->clone\->final\->to_hex, "\en";
\&    }
.Ve
.PP
Returns a copy of \f(CW$ctx256\fR object, that contains the current computation
state.
.PP
update
.IX Subsection "update"
.PP
.Vb 1
\&    $ctx256\->update( $msgX, ... );
.Ve
.PP
Appends its arguments to the message for which the \s-1MAC\s0 is being calculated.
.PP
Returns the \f(CW$ctx256\fR object itself.
.PP
final
.IX Subsection "final"
.PP
.Vb 1
\&    my $mac256 = $ctx256\->final();
.Ve
.PP
Computes the final \s-1MAC\s0 of the input data.
.PP
Returns Data::BytesLocker object.
.SS "\s-1HMAC\-SHA\-512\s0"
.IX Subsection "HMAC-SHA-512"
\fIhmacsha512_keygen\fR
.IX Subsection "hmacsha512_keygen"
.PP
.Vb 1
\&    my $key512 = $crypto_auth\->hmacsha512_keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_auth\fR.
.PP
The length of the \f(CW$key512\fR equals \*(L"\s-1HMACSHA512_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha512\fR
.IX Subsection "hmacsha512"
.PP
.Vb 1
\&    my $mac512 = $crypto_auth\->hmacsha512( $msg, $key512 );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using given \f(CW$key512\fR.
.PP
The length of the \f(CW$mac512\fR equals \*(L"\s-1HMACSHA512_BYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha512_verify\fR
.IX Subsection "hmacsha512_verify"
.PP
.Vb 3
\&    unless ( $crypto_auth\->hmacsha512_verify( $mac512, $msg, $key512 ) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
Verifies the integrity and authenticity of the \f(CW$msg\fR using given \f(CW$mac512\fR and
\&\f(CW$key512\fR.
.PP
Method returns true if message has been verified, false otherwise.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length, allowing it to be
used with the multi-part \s-1API.\s0
.PP
\fIMulti-part \s-1API\s0\fR
.IX Subsection "Multi-part API"
.PP
Multi-part computation is also supported.
.PP
.Vb 1
\&    my $ctx512 = $crypto_auth\->hmacsha512_init( $key );
\&
\&    $ctx512\->update( $msgX );
\&    $ctx512\->update( $msgY )\->update( $msgZ, ... );
\&
\&    my $mac512 = $ctx512\->final();
\&
\&    my $msgXYZ = join(\*(Aq\*(Aq, $msgX, $msgY, $msgZ, ...);
\&    unless ( $crypto_auth\->hmacsha512_verify( $mac512, $msgXYZ, $key) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
hmacsha512_init
.IX Subsection "hmacsha512_init"
.PP
.Vb 1
\&    my $ctx512 = $crypto_auth\->hmacsha512_init( $key );
.Ve
.PP
Creates a context for multi-part computation using given \f(CW$key\fR.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length. Key larger then the
block size gets reduced to \f(CW\*(C`sha512($key)\*(C'\fR.
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::auth::hmacsha512stream\*(C'\fR object which encapsulates
the computation state of the \fI\s-1HMAC\-SHA\-512\s0\fR algorithm.
.PP
clone
.IX Subsection "clone"
.PP
.Vb 4
\&    while ( <> ) {
\&        $ctx512\->update( $_ );
\&        print "Line: $.: ", $ctx512\->clone\->final\->to_hex, "\en";
\&    }
.Ve
.PP
Returns a copy of \f(CW$ctx512\fR object, that contains the current computation
state.
.PP
update
.IX Subsection "update"
.PP
.Vb 1
\&    $ctx512\->update( $msgX, ... );
.Ve
.PP
Appends its arguments to the message for which the \s-1MAC\s0 is being calculated.
.PP
Returns the \f(CW$ctx512\fR object itself.
.PP
final
.IX Subsection "final"
.PP
.Vb 1
\&    my $mac512 = $ctx512\->final();
.Ve
.PP
Computes the final \s-1MAC\s0 of the input data.
.PP
Returns Data::BytesLocker object.
.SS "\s-1HMAC\-SHA\-512/256\s0"
.IX Subsection "HMAC-SHA-512/256"
\fIhmacsha512256_keygen\fR
.IX Subsection "hmacsha512256_keygen"
.PP
.Vb 1
\&    my $key512256 = $crypto_auth\->hmacsha512256_keygen();
.Ve
.PP
Helper method to generate a random key to be used by \f(CW$crypto_auth\fR.
.PP
The length of the \f(CW$key512256\fR equals \*(L"\s-1HMACSHA512256_KEYBYTES\*(R"\s0.
.PP
\&\fB\s-1NOTE:\s0\fR keep the key confidential.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha512256\fR
.IX Subsection "hmacsha512256"
.PP
.Vb 1
\&    my $mac512256 = $crypto_auth\->hmacsha512256( $msg, $key512256 );
.Ve
.PP
Computes the \s-1MAC\s0 of the \f(CW$msg\fR using given \f(CW$key512256\fR.
.PP
The length of the \f(CW$mac512256\fR equals \*(L"\s-1HMACSHA512256_BYTES\*(R"\s0.
.PP
Returns Data::BytesLocker object.
.PP
\fIhmacsha512256_verify\fR
.IX Subsection "hmacsha512256_verify"
.PP
.Vb 3
\&    unless ( $crypto_auth\->hmacsha512256_verify( $mac512256, $msg, $key512256 ) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
Verifies the integrity and authenticity of the \f(CW$msg\fR using given \f(CW$mac512256\fR and
\&\f(CW$key512256\fR.
.PP
Method returns true if message has been verified, false otherwise.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length, allowing it to be
used with the multi-part \s-1API.\s0
.PP
\fIMulti-part \s-1API\s0\fR
.IX Subsection "Multi-part API"
.PP
Multi-part computation is also supported.
.PP
.Vb 1
\&    my $ctx512256 = $crypto_auth\->hmacsha512256_init( $key );
\&
\&    $ctx512256\->update( $msgX );
\&    $ctx512256\->update( $msgY )\->update( $msgZ, ... );
\&
\&    my $mac512256 = $ctx512256\->final();
\&
\&    my $msgXYZ = join(\*(Aq\*(Aq, $msgX, $msgY, $msgZ, ...);
\&    unless ( $crypto_auth\->hmacsha512256_verify( $mac512256, $msgXYZ, $key) ) {
\&        die "Impostor alert!";
\&    }
.Ve
.PP
hmacsha512256_init
.IX Subsection "hmacsha512256_init"
.PP
.Vb 1
\&    my $ctx512256 = $crypto_auth\->hmacsha512256_init( $key );
.Ve
.PP
Creates a context for multi-part computation using given \f(CW$key\fR.
.PP
\&\fB\s-1NOTE:\s0\fR this function supports a key of arbitrary length. Key larger then the
block size gets reduced to \f(CW\*(C`sha512($key)\*(C'\fR.
.PP
Returns \f(CW\*(C`Crypt::NaCl::Sodium::auth::hmacsha512256stream\*(C'\fR object which encapsulates
the computation state of the \fI\s-1HMAC\-SHA\-512/256\s0\fR algorithm.
.PP
clone
.IX Subsection "clone"
.PP
.Vb 4
\&    while ( <> ) {
\&        $ctx512256\->update( $_ );
\&        print "Line: $.: ", $ctx512256\->clone\->final\->to_hex, "\en";
\&    }
.Ve
.PP
Returns a copy of \f(CW$ctx512256\fR object, that contains the current computation
state.
.PP
update
.IX Subsection "update"
.PP
.Vb 1
\&    $ctx512256\->update( $msgX, ... );
.Ve
.PP
Appends its arguments to the message for which the \s-1MAC\s0 is being calculated.
.PP
Returns the \f(CW$ctx512256\fR object itself.
.PP
final
.IX Subsection "final"
.PP
.Vb 1
\&    my $mac512256 = $ctx512256\->final();
.Ve
.PP
Computes the final \s-1MAC\s0 of the input data.
.PP
Returns Data::BytesLocker object.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "\s-1KEYBYTES\s0"
.IX Subsection "KEYBYTES"
.Vb 1
\&    my $key_length = $crypto_auth\->KEYBYTES;
.Ve
.PP
Returns the length of key.
.SS "\s-1HMACSHA256_KEYBYTES\s0"
.IX Subsection "HMACSHA256_KEYBYTES"
.Vb 1
\&    my $key256_length = $crypto_auth\->HMACSHA256_KEYBYTES;
.Ve
.PP
Returns the length of key for \fI\s-1HMAC\-SHA\-256\s0\fR algorithm.
.SS "\s-1HMACSHA512_KEYBYTES\s0"
.IX Subsection "HMACSHA512_KEYBYTES"
.Vb 1
\&    my $key512_length = $crypto_auth\->HMACSHA512_KEYBYTES;
.Ve
.PP
Returns the length of key for \fI\s-1HMAC\-SHA\-512\s0\fR algorithm.
.SS "\s-1HMACSHA512256_KEYBYTES\s0"
.IX Subsection "HMACSHA512256_KEYBYTES"
.Vb 1
\&    my $key512256_length = $crypto_auth\->HMACSHA512256_KEYBYTES;
.Ve
.PP
Returns the length of key for \fI\s-1HMAC\-SHA\-512/256\s0\fR algorithm.
.SS "\s-1BYTES\s0"
.IX Subsection "BYTES"
.Vb 1
\&    my $mac_length = $crypto_auth\->BYTES;
.Ve
.PP
Returns the length of \s-1MAC.\s0
.SS "\s-1HMACSHA256_BYTES\s0"
.IX Subsection "HMACSHA256_BYTES"
.Vb 1
\&    my $mac256_length = $crypto_auth\->HMACSHA256_BYTES;
.Ve
.PP
Returns the length of \s-1MAC\s0 for \fI\s-1HMAC\-SHA\-256\s0\fR algorithm.
.SS "\s-1HMACSHA512_BYTES\s0"
.IX Subsection "HMACSHA512_BYTES"
.Vb 1
\&    my $mac512_length = $crypto_auth\->HMACSHA512_BYTES;
.Ve
.PP
Returns the length of \s-1MAC\s0 for \fI\s-1HMAC\-SHA\-512\s0\fR algorithm.
.SS "\s-1HMACSHA512256_BYTES\s0"
.IX Subsection "HMACSHA512256_BYTES"
.Vb 1
\&    my $mac512256_length = $crypto_auth\->HMACSHA512256_BYTES;
.Ve
.PP
Returns the length of \s-1MAC\s0 for \fI\s-1HMAC\-SHA\-512/256\s0\fR algorithm.
.SH "SECURITY MODEL"
.IX Header "SECURITY MODEL"
\&\f(CW\*(C`crypto_auth\*(C'\fR does not make any promises regarding \fIstrong\fR unforgeability;
perhaps one valid authenticator can be converted into another valid authenticator
for the same message. \f(CW\*(C`crypto_auth\*(C'\fR also does not make any promises regarding
\&\fItruncated unforgeability\fR.
.PP
Default value for \*(L"\s-1HMACSHA512_KEYBYTES\*(R"\s0 is \f(CW32\fR, while \s-1RFC4868\s0 recommends using
\&\f(CW64\fR bytes when used as authentication/integrity mechanism. The \f(CW\*(C`*_init()\*(C'\fR
functions however support keys of any length.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Data::BytesLocker \- guarded data storage
.IP "\(bu" 4
Secret-key message authentication: crypto_auth <http://nacl.cr.yp.to/auth.html>
.IP "\(bu" 4
Using \s-1HMAC\-SHA\-256, HMAC\-SHA\-384,\s0 and \s-1HMAC\-SHA\-512\s0 with IPsec <https://tools.ietf.org/html/rfc4868>
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex J. G. Burzyński <ajgb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Alex J. G. Burzyński <ajgb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
