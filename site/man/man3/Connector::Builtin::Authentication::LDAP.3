.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector::Builtin::Authentication::LDAP 3"
.TH Connector::Builtin::Authentication::LDAP 3 "2019-11-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Connector::Builtin::Authentication::LDAP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Connector (see perldoc \fIConnector\fR) to authenticate users against \s-1LDAP.\s0
Supports simple authentication (via \s-1LDAP\s0 bind), \s-1SASL\s0 authentication is not
supported.
.PP
The module allows for direct bind or indirect bind (with preliminary user
search). Direct bind is the most straightforward method, but it requires
users to know their Distinguished Names (DNs) in \s-1LDAP.\s0 Indirect bind is more
convenient for users, but it involves \s-1LDAP\s0 database search, which requires read
access to larger parts of \s-1LDAP\s0 directory (so \s-1LDAP\s0 ACLs must be set properly to
allow indirect bind).
.PP
The module implements group participation checking. With this option enabled,
only users that belong to a predefined group may pass the authentication.
The group is stored in \s-1LDAP\s0 directory (it may be for example an entry of
type \fIgroupOfUniqueNames\fR with the group participants listed in attribute
\&\fIuniqueMember\fR).
.PP
When requesting indirect bind, the internal user search may return multiple
DNs. By default this is treated as an error (because of ambiguity) and results
with authentication failuer. This may be changed by setting a parameter named
\&\fIambiguous\fR, in which case the module will try to consecutively bind to each
\&\s-1DN\s0 from the search result.
.PP
The indirect bind may be configured to use custom search filter, instead of
the default one. This allows to incorporate additional restrictions on users
based on their attributes stored in \s-1LDAP.\s0
.SS "Usage"
.IX Subsection "Usage"
The username is the first component of the path, the password needs to be
passed in the extended parameters using the key password.
.PP
Example:
.PP
.Vb 1
\&   $connector\->get(\*(Aqusername\*(Aq, {  password => \*(AqmySecret\*(Aq } );
.Ve
.PP
To configure module for direct bind, the connector object should be created
with parameter \fIindirect\fR => 0. This is the simplest authentication method
and requires least parameters to be configured.
.PP
Example:
.PP
.Vb 8
\&    my $connector = Connector::Builtin::Authentication::LDAP\->new({
\&        LOCATION => \*(Aqldap://ldap.example.org\*(Aq,
\&        indirect => 0
\&    })
\&    my $result = $connector\->get(
\&        \*(Aquid=jsmith,ou=people,dc=example,dc=org\*(Aq,
\&        { password => \*(Aqsecret\*(Aq }
\&    );
.Ve
.PP
Indirect bind, which is default, searches through the \s-1LDAP\s0 directory. This
usually requires read access to database, and is performed by a separate user.
We'll call that user \fIbinddn\fR. For indirect-bind authentication, one usually
has to provide \s-1DN\s0 and password of the existing \fIbinddn\fR user.
.PP
Example:
.PP
.Vb 6
\&    my $connector = Connector::Builtin::Authentication::LDAP\->new({
\&        LOCATION => \*(Aqldap://ldap.example.org\*(Aq,
\&        binddn => \*(Aqcn=admin,dc=example,dc=org\*(Aq,
\&        password => \*(AqbinddnPassword\*(Aq
\&    })
\&    my $result = $connector\->get(\*(Aqjsmith\*(Aq, { password => \*(Aqsecret\*(Aq });
.Ve
.PP
Two parameters are used to check group participation: \fIgroupdn\fR and
\&\fIgroupattr\fR. The \fIgroupdn\fR parameter specifies \s-1DN\s0 of a group entry and the
\&\fIgroupattr\fR specifies an attribute of the \fIgroupdn\fR object where group
participants are listed. If you specify \fIgroupdn\fR, the group participation
check is enabled.
.PP
Example:
.PP
.Vb 10
\&    # Assume, we have in LDAP:
\&    #
\&    # dn: cn=vip,dc=example,dc=org
\&    # objectClass: groupOfNames
\&    # member: uid=jsmith,ou=people,dc=example,dc=org
\&    #
\&    my $connector = Connector::Builtin::Authentication::LDAP\->new({
\&        LOCATION => \*(Aqldap://ldap.example.org\*(Aq,
\&        indirect => 0,
\&        binddn => \*(Aqcn=admin,dc=example,dc=org\*(Aq,
\&        password => \*(AqbinddnPassword\*(Aq,
\&        groupdn => \*(Aqcn=vip,dc=example,dc=org\*(Aq,
\&    })
\&    my $result = $connector\->get(
\&        \*(Aquid=jsmith,ou=people,dc=example,dc=org\*(Aq,
\&        { password => \*(Aqsecret\*(Aq }
\&    );
.Ve
.PP
Note, that in this case we have provided \fIbinddn\fR despite the direct-bind
authentication was used. This is, because we needed read access to the
\&\f(CW\*(C`cn=vip,dc=example,dc=org\*(C'\fR entry (the group object).
.PP
The indirect-bind method accepts custom filters for user search.
.PP
Example:
.PP
.Vb 7
\&    my $connector = Connector::Builtin::Authentication::LDAP\->new({
\&        LOCATION => \*(Aqldap://ldap.example.org\*(Aq,
\&        binddn => \*(Aqcn=admin,dc=example,dc=org\*(Aq,
\&        password => \*(AqbinddnPassword\*(Aq,
\&        filter => \*(Aq(&(uid=[% LOGIN %])(accountStatus=active))\*(Aq
\&    })
\&    my $result = $connector\->get(\*(Aqjsmith\*(Aq, { password => \*(Aqsecret\*(Aq });
.Ve
.PP
You may substitute user name by using \fI[% \s-1LOGIN\s0 %]\fR template parameter,
as shown in the above example.
.SS "Configuration"
.IX Subsection "Configuration"
Below is the full list of configuration options.
.PP
\fIConnection options\fR
.IX Subsection "Connection options"
.IP "\fBkeepalive\fR => 1" 8
.IX Item "keepalive => 1"
If given, set the socket's \s-1SO_KEEPALIVE\s0 option depending on the Boolean value
of the option. (Default: use system default).
.IP "\fBtimeout\fR => N" 8
.IX Item "timeout => N"
Timeout passed to IO::Socket when connecting the remote server. (Default: 120)
.IP "\fBmultihomed\fR => N" 8
.IX Item "multihomed => N"
Will be passed to IO::Socket as the MultiHomed parameter when connecting to the
remote server
.IP "\fBlocaladdr\fR => \s-1HOST\s0" 8
.IX Item "localaddr => HOST"
Will be passed to IO::Socket as the LocalAddr parameter, which sets the
client's \s-1IP\s0 address (as opposed to the server's \s-1IP\s0 address.)
.IP "\fBdebug\fR => N" 8
.IX Item "debug => N"
Set the \s-1LDAP\s0 debug level.
.PP
\fI\s-1SSL\s0 Connection options\fR
.IX Subsection "SSL Connection options"
.IP "\fBverify\fR => 'none' | 'optional' | 'require'" 8
.IX Item "verify => 'none' | 'optional' | 'require'"
How to verify the server's certificate:
.Sp
.Vb 7
\&    none
\&        The server may provide a certificate but it will not be checked \- this
\&        may mean you are be connected to the wrong server
\&    optional
\&        Verify only when the server offers a certificate
\&    require
\&        The server must provide a certificate, and it must be valid.
.Ve
.Sp
If you set \fBverify\fR to optional or \fIrequire\fR, you must also set either
\&\fBcafile\fR or \fBcapath\fR. The most secure option is require.
.IP "\fBsslversion\fR  => 'sslv2' | 'sslv3' | 'sslv23' | 'tlsv1'" 8
.IX Item "sslversion => 'sslv2' | 'sslv3' | 'sslv23' | 'tlsv1'"
This defines the version of the \s-1SSL/TLS\s0 protocol to use. Defaults to 'tlsv1'.
.IP "\fBciphers\fR => \s-1CIPHERS\s0" 8
.IX Item "ciphers => CIPHERS"
Specify which subset of cipher suites are permissible for this connection,
using the standard OpenSSL string format. The default behavior is to keep the
decision on the underlying cryptographic library.
.IP "\fBcapath\fR => '/path/to/servercerts/'" 8
.IX Item "capath => '/path/to/servercerts/'"
See \fBcafile\fR.
.IP "\fBcafile\fR => '/path/to/servercert.pem'" 8
.IX Item "cafile => '/path/to/servercert.pem'"
When verifying the server's certificate, either set \fBcapath\fR to the pathname
of the directory containing \s-1CA\s0 certificates, or set \fBcafile\fR to the filename
containing the certificate of the \s-1CA\s0 who signed the server's certificate. These
certificates must all be in \s-1PEM\s0 format.
.IP "\fBclientcert\fR => '/path/to/cert.pem'" 8
.IX Item "clientcert => '/path/to/cert.pem'"
See \fBclientkey\fR.
.IP "\fBclientkey\fR => '/path/to/key.pem'" 8
.IX Item "clientkey => '/path/to/key.pem'"
If you want to use the client to offer a certificate to the server for \s-1SSL\s0
authentication (which is not the same as for the \s-1LDAP\s0 Bind operation) then set
\&\fBclientcert\fR to the user's certificate file, and \fBclientkey\fR to the user's
private key file. These files must be in \s-1PEM\s0 format.
.IP "\fBcheckcrl\fR => 1" 8
.IX Item "checkcrl => 1"
.PP
\fIBindDN\fR
.IX Subsection "BindDN"
.IP "\fBbinddn\fR => \s-1DN\s0" 8
.IX Item "binddn => DN"
Distinguished Name of the \s-1LDAP\s0 entry used to search \s-1LDAP\s0 database for users
being authenticated (indirect bind) and check their group participation.
.IP "\fBpassword\fR => \s-1PASSWORD\s0" 8
.IX Item "password => PASSWORD"
Password for the \fBbinddn\fR user.
.PP
\fISearch options (indirect bind)\fR
.IX Subsection "Search options (indirect bind)"
.IP "\fBtimelimit\fR => N" 8
.IX Item "timelimit => N"
A timelimit that restricts the maximum time (in seconds) allowed for a search.
A value of 0 (the default), means that no timelimit will be requested.
.IP "\fBsizelimit\fR => N" 8
.IX Item "sizelimit => N"
A sizelimit that restricts the maximum number of entries to be returned as a
result of the search. A value of 0, and the default, means that no restriction
is requested. Servers may enforce a maximum number of entries to return.
.IP "\fBbase\fR => \s-1DN\s0" 8
.IX Item "base => DN"
The \s-1DN\s0 that is the base object entry relative to which the search is to be
performed.
.IP "\fBfilter\fR => \s-1TEMPLATESTRING\s0" 8
.IX Item "filter => TEMPLATESTRING"
A filter that defines the conditions an entry in the directory must meet in
order for it to be returned by the search. This may be a (template) string or a
Net::LDAP::Filter object.
.IP "\fBscope\fR  => 'base' | 'one' | 'sub' | 'subtree' | 'children'" 8
.IX Item "scope => 'base' | 'one' | 'sub' | 'subtree' | 'children'"
By default the search is performed on the whole tree below the specified base
object. This maybe changed by specifying a scope parameter with one of the
following values:
.Sp
.Vb 10
\&    base
\&        Search only the base object.
\&    one
\&        Search the entries immediately below the base object.
\&    sub
\&    subtree
\&        Search the whole tree below (and including) the base object. This is
\&        the default.
\&    children
\&        Search the whole subtree below the base object, excluding the base object itself.
.Ve
.Sp
Note: children scope requires LDAPv3 subordinate feature extension.
.PP
\fIOther options\fR
.IX Subsection "Other options"
.IP "\fBuserattr\fR => \s-1ATTRNAME\s0" 8
.IX Item "userattr => ATTRNAME"
If the search \fBfilter\fR (for indirect bind) is not specified, it is constructed
internally as \fI\*(L"($userattr=[% \s-1LOGIN\s0 %])\*(R"\fR, where \fI\f(CI$userattr\fI\fR represents the
value of \fBuserattr\fR parameter.
.IP "\fBgroupattr\fR => \s-1ATTRNAME\s0" 8
.IX Item "groupattr => ATTRNAME"
If \fBgroupdn\fR is specified by caller, the \fBgroupattr\fR defines an attribute
within \fBgroupdn\fR object which shall be compared against the \s-1DN\s0 of the user
being authenticated in order to check its participation to the group. Defaults
to \fI'member'\fR.
.IP "\fBgroupdn\fR => \s-1DN\s0" 8
.IX Item "groupdn => DN"
\&\s-1DN\s0 of an \s-1LDAP\s0 entry which defines a group of users allowed to be authenticated.
If not defined, the group participation is not checked.
.IP "\fBindirect\fR => 1 | 0" 8
.IX Item "indirect => 1 | 0"
Use indirect bind (default). Set to \fI0\fR to disable indirect bind and use
direct bind.
.IP "\fBambiguous\fR => 0 | 1" 8
.IX Item "ambiguous => 0 | 1"
Accept ambiguous search results when doing indirect-bind authentication. By
default, this option is disabled.
.SS "Return values"
.IX Subsection "Return values"
1 if the password matches, 0 if the user is found but the password does not
match and undef if the user is not found (or it's found but group check
failed).
.SS "Limitations"
.IX Subsection "Limitations"
User names are limited to so called \fIvalueencoding\fR syntax defined by \s-1RFC4515.\s0
We allow non-ascii (utf\-8) characters and non-printable characters. Invalid
names are treated as not found.
