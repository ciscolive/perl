.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Path::Iterator::Rule 3"
.TH Path::Iterator::Rule 3 "2018-06-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Iterator::Rule \- Iterative, recursive file finder
.SH "VERSION"
.IX Header "VERSION"
version 1.014
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Iterator::Rule;
\&
\&  my $rule = Path::Iterator::Rule\->new; # match anything
\&  $rule\->file\->size(">10k");         # add/chain rules
\&
\&  # iterator interface
\&  my $next = $rule\->iter( @dirs );
\&  while ( defined( my $file = $next\->() ) ) {
\&    ...
\&  }
\&
\&  # list interface
\&  for my $file ( $rule\->all( @dirs ) ) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module iterates over files and directories to identify ones matching a
user-defined set of rules.  The \s-1API\s0 is based heavily on File::Find::Rule,
but with more explicit distinction between matching rules and options that
influence how directories are searched.  A \f(CW\*(C`Path::Iterator::Rule\*(C'\fR object is a
collection of rules (match criteria) with methods to add additional criteria.
Options that control directory traversal are given as arguments to the method
that generates an iterator.
.PP
Here is a summary of features for comparison to other file finding modules:
.IP "\(bu" 4
provides many \*(L"helper\*(R" methods for specifying rules
.IP "\(bu" 4
offers (lazy) iterator and flattened list interfaces
.IP "\(bu" 4
custom rules implemented with callbacks
.IP "\(bu" 4
breadth-first (default) or pre\- or post-order depth-first searching
.IP "\(bu" 4
follows symlinks (by default, but can be disabled)
.IP "\(bu" 4
directories visited only once (no infinite loop; can be disabled)
.IP "\(bu" 4
doesn't chdir during operation
.IP "\(bu" 4
provides an \s-1API\s0 for extensions
.PP
As a convenience, the \s-1PIR\s0 module is an empty subclass of this one
that is less arduous to type for one-liners.
.PP
\&\fBNote\fR: paths are constructed with unix-style forward-slashes for
efficiency rather than using File::Spec.  If proper path separators are
needed, call canonpath on the search results.
.SH "USAGE"
.IX Header "USAGE"
.SS "Constructors"
.IX Subsection "Constructors"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $rule = Path::Iterator::Rule\->new;
.Ve
.PP
Creates a new rule object that matches any file or directory.  It takes
no arguments. For convenience, it may also be called on an object, in which
case it still returns a new object that matches any file or directory.
.PP
\fI\f(CI\*(C`clone\*(C'\fI\fR
.IX Subsection "clone"
.PP
.Vb 3
\&  my $common      = Path::Iterator::Rule\->new\->file\->not_empty;
\&  my $big_files   = $common\->clone\->size(">1M");
\&  my $small_files = $common\->clone\->size("<10K");
.Ve
.PP
Creates a copy of a rule object.  Useful for customizing different
rule objects against a common base.
.SS "Matching and iteration"
.IX Subsection "Matching and iteration"
\fI\f(CI\*(C`iter\*(C'\fI\fR
.IX Subsection "iter"
.PP
.Vb 4
\&  my $next = $rule\->iter( @dirs, \e%options);
\&  while ( defined( my $file = $next\->() ) ) {
\&    ...
\&  }
.Ve
.PP
Creates a subroutine reference iterator that returns a single result
when dereferenced.  This iterator is \*(L"lazy\*(R" \*(-- results are not
pre-computed.
.PP
It takes as arguments a list of directories to search and an optional hash
reference of control options.  If no search directories are provided, the
current directory is used (\f(CW"."\fR).  Valid options include:
.IP "\(bu" 4
\&\f(CW\*(C`depthfirst\*(C'\fR \*(-- Controls order of results.  Valid values are \*(L"1\*(R" (post-order, depth-first search), \*(L"0\*(R" (breadth-first search) or \*(L"\-1\*(R" (pre-order, depth-first search). Default is 0.
.IP "\(bu" 4
\&\f(CW\*(C`error_handler\*(C'\fR \*(-- Catches errors during execution of rule tests. Default handler dies with the filename and error. If set to undef, error handling is disabled.
.IP "\(bu" 4
\&\f(CW\*(C`follow_symlinks\*(C'\fR \*(-- Follow directory symlinks when true. Default is 1.
.IP "\(bu" 4
\&\f(CW\*(C`report_symlinks\*(C'\fR \*(-- Includes symlinks in results when true. Default is equal to \f(CW\*(C`follow_symlinks\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`loop_safe\*(C'\fR \*(-- Prevents visiting the same directory more than once when true.  Default is 1.
.IP "\(bu" 4
\&\f(CW\*(C`relative\*(C'\fR \*(-- Return matching items relative to the search directory. Default is 0.
.IP "\(bu" 4
\&\f(CW\*(C`sorted\*(C'\fR \*(-- Whether entries in a directory are sorted before processing. Default is 1.
.IP "\(bu" 4
\&\f(CW\*(C`visitor\*(C'\fR \*(-- An optional coderef that will be called on items matching all rules.
.PP
Filesystem loops might exist from either hard or soft links.  The \f(CW\*(C`loop_safe\*(C'\fR
option prevents infinite loops, but adds some overhead by making \f(CW\*(C`stat\*(C'\fR calls.
Because directories are visited only once when \f(CW\*(C`loop_safe\*(C'\fR is true, matches
could come from a symlinked directory before the real directory depending on
the search order.
.PP
To get only the real files, turn off \f(CW\*(C`follow_symlinks\*(C'\fR.  You can have
symlinks included in results, but not descend into symlink directories if
you turn off \f(CW\*(C`follow_symlinks\*(C'\fR, but turn on \f(CW\*(C`report_symlinks\*(C'\fR.
.PP
Turning \f(CW\*(C`loop_safe\*(C'\fR off and leaving \f(CW\*(C`follow_symlinks\*(C'\fR on avoids \f(CW\*(C`stat\*(C'\fR calls
and will be fastest, but with the risk of an infinite loop and repeated files.
The default is slow, but safe.
.PP
The \f(CW\*(C`error_handler\*(C'\fR parameter must be a subroutine reference.  It will be
called when a rule test throws an exception.  The first argument will be
the file name being inspected and the second argument will be
the exception.
.PP
The optional \f(CW\*(C`visitor\*(C'\fR parameter must be a subroutine reference.  If set,
it will be called for any result that matches.  It is called the same way
a custom rule would be (see \*(L"\s-1EXTENDING\*(R"\s0) but its return value is ignored.
It is called when an item is first inspected \*(-- \*(L"postorder\*(R" is not respected.
.PP
The paths inspected and returned will be relative to the search directories
provided.  If these are absolute, then the paths returned will have absolute
paths.  If these are relative, then the paths returned will have relative
paths.
.PP
If the search directories are absolute and the \f(CW\*(C`relative\*(C'\fR option is true,
files returned will be relative to the search directory.  Note that if the
search directories are not mutually exclusive (whether containing
subdirectories like \f(CW@INC\fR or symbolic links), files found could be returned
relative to different initial search directories based on \f(CW\*(C`depthfirst\*(C'\fR,
\&\f(CW\*(C`follow_symlinks\*(C'\fR or \f(CW\*(C`loop_safe\*(C'\fR.
.PP
When the iterator is exhausted, it will return undef.
.PP
\fI\f(CI\*(C`iter_fast\*(C'\fI\fR
.IX Subsection "iter_fast"
.PP
This works just like \f(CW\*(C`iter\*(C'\fR, except that it optimizes for speed over
safety. Don't do this unless you're sure you need it and accept
the consequences.  See \*(L"\s-1PERFORMANCE\*(R"\s0 for details.
.PP
\fI\f(CI\*(C`all\*(C'\fI\fR
.IX Subsection "all"
.PP
.Vb 1
\&  my @matches = $rule\->all( @dir, \e%options );
.Ve
.PP
Returns a list of paths that match the rule.  It takes the same arguments and
has the same behaviors as the \f(CW\*(C`iter\*(C'\fR method.  The \f(CW\*(C`all\*(C'\fR method uses \f(CW\*(C`iter\*(C'\fR
internally to fetch all results.
.PP
In scalar context, it will return the count of matched paths.
.PP
In void context, it is optimized to iterate over everything, but not store
results.  This is most useful with the \f(CW\*(C`visitor\*(C'\fR option:
.PP
.Vb 1
\&    $rule\->all( $path, { visitor => \e&callback } );
.Ve
.PP
\fI\f(CI\*(C`all_fast\*(C'\fI\fR
.IX Subsection "all_fast"
.PP
This works just like \f(CW\*(C`all\*(C'\fR, except that it optimizes for speed over
safety. Don't do this unless you're sure you need it and accept
the consequences.  See \*(L"\s-1PERFORMANCE\*(R"\s0 for details.
.PP
\fI\f(CI\*(C`test\*(C'\fI\fR
.IX Subsection "test"
.PP
.Vb 1
\&  if ( $rule\->test( $path, $basename, $stash ) ) { ... }
.Ve
.PP
Test a file path against a rule.  Used internally, but provided should
someone want to create their own, custom iteration algorithm.
.SS "Logic operations"
.IX Subsection "Logic operations"
\&\f(CW\*(C`Path::Iterator::Rule\*(C'\fR provides three logic operations for adding rules to the
object.  Rules may be either a subroutine reference with specific semantics
(described below in \*(L"\s-1EXTENDING\*(R"\s0) or another \f(CW\*(C`Path::Iterator::Rule\*(C'\fR object.
.PP
\fI\f(CI\*(C`and\*(C'\fI\fR
.IX Subsection "and"
.PP
.Vb 2
\&  $rule\->and( sub { \-r \-w \-x $_ } ); # stacked filetest example
\&  $rule\->and( @more_rules );
.Ve
.PP
Adds one or more constraints to the current rule. E.g. \*(L"old rule \s-1AND\s0
new1 \s-1AND\s0 new2 \s-1AND ...\*(R".\s0  Returns the object to allow method chaining.
.PP
\fI\f(CI\*(C`or\*(C'\fI\fR
.IX Subsection "or"
.PP
.Vb 5
\&  $rule\->or(
\&    $rule\->new\->name("foo*"),
\&    $rule\->new\->name("bar*"),
\&    sub { \-r \-w \-x $_ },
\&  );
.Ve
.PP
Takes one or more alternatives and adds them as a constraint to the current
rule. E.g. \*(L"old rule \s-1AND\s0 ( new1 \s-1OR\s0 new2 \s-1OR ...\s0 )\*(R".  Returns the object to allow
method chaining.
.PP
\fI\f(CI\*(C`not\*(C'\fI\fR
.IX Subsection "not"
.PP
.Vb 1
\&  $rule\->not( sub { \-r \-w \-x $_ } );
.Ve
.PP
Takes one or more alternatives and adds them as a negative constraint to the
current rule. E.g. \*(L"old rule \s-1AND NOT\s0 ( new1 \s-1AND\s0 new2 \s-1AND ...\s0)\*(R".  Returns the
object to allow method chaining.
.PP
\fI\f(CI\*(C`skip\*(C'\fI\fR
.IX Subsection "skip"
.PP
.Vb 4
\&  $rule\->skip(
\&    $rule\->new\->dir\->not_writeable,
\&    $rule\->new\->dir\->name("foo"),
\&  );
.Ve
.PP
Takes one or more alternatives and will prune a directory if any of the
criteria match or if any of the rules already indicate the directory should be
pruned.  Pruning means the directory will not be returned by the iterator and
will not be searched.
.PP
For files, it is equivalent to \f(CW\*(C`$rule\->not($rule\->or(@rules))\*(C'\fR.  Returns
the object to allow method chaining.
.PP
This method should be called as early as possible in the rule chain.
See \*(L"skip_dirs\*(R" below for further explanation and an example.
.SH "RULE METHODS"
.IX Header "RULE METHODS"
Rule methods are helpers that add constraints.  Internally, they generate a
closure to accomplish the desired logic and add it to the rule object with the
\&\f(CW\*(C`and\*(C'\fR method.  Rule methods return the object to allow for method chaining.
.SS "File name rules"
.IX Subsection "File name rules"
\fI\f(CI\*(C`name\*(C'\fI\fR
.IX Subsection "name"
.PP
.Vb 2
\&  $rule\->name( "foo.txt" );
\&  $rule\->name( qr/foo/, "bar.*");
.Ve
.PP
The \f(CW\*(C`name\*(C'\fR method takes one or more patterns and creates a rule that is true
if any of the patterns match the \fBbasename\fR of the file or directory path.
Patterns may be regular expressions or glob expressions (or literal names).
.PP
\fI\f(CI\*(C`iname\*(C'\fI\fR
.IX Subsection "iname"
.PP
.Vb 2
\&  $rule\->iname( "foo.txt" );
\&  $rule\->iname( qr/foo/, "bar.*");
.Ve
.PP
The \f(CW\*(C`iname\*(C'\fR method is just like the \f(CW\*(C`name\*(C'\fR method, but matches
case-insensitively.
.PP
\fI\f(CI\*(C`skip_dirs\*(C'\fI\fR
.IX Subsection "skip_dirs"
.PP
.Vb 1
\&  $rule\->skip_dirs( @patterns );
.Ve
.PP
The \f(CW\*(C`skip_dirs\*(C'\fR method skips directories that match one or more patterns.
Patterns may be regular expressions or globs (just like \f(CW\*(C`name\*(C'\fR).  Directories
that match will not be returned from the iterator and will be excluded from
further search.  \fBThis includes the starting directories.\fR  If that isn't
what you want, see \*(L"skip_subdirs\*(R" instead.
.PP
\&\fBNote:\fR this rule should be specified early so that it has a chance to
operate before a logical shortcut.  E.g.
.PP
.Vb 2
\&  $rule\->skip_dirs(".git")\->file; # OK
\&  $rule\->file\->skip_dirs(".git"); # Won\*(Aqt work
.Ve
.PP
In the latter case, when a \*(L".git\*(R" directory is seen, the \f(CW\*(C`file\*(C'\fR rule
shortcuts the rule before the \f(CW\*(C`skip_dirs\*(C'\fR rule has a chance to act.
.PP
\fI\f(CI\*(C`skip_subdirs\*(C'\fI\fR
.IX Subsection "skip_subdirs"
.PP
.Vb 1
\&  $rule\->skip_subdirs( @patterns );
.Ve
.PP
This works just like \f(CW\*(C`skip_dirs\*(C'\fR, except that the starting directories
(depth 0) are not skipped and may be returned from the iterator
unless excluded by other rules.
.SS "File test rules"
.IX Subsection "File test rules"
Most of the \f(CW\*(C`\-X\*(C'\fR style filetest are available as boolean rules.  The table
below maps the filetest to its corresponding method name.
.PP
.Vb 10
\&   Test | Method               Test |  Method
\&  \-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-        \-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    \-r  |  readable             \-R  |  r_readable
\&    \-w  |  writeable            \-W  |  r_writeable
\&    \-w  |  writable             \-W  |  r_writable
\&    \-x  |  executable           \-X  |  r_executable
\&    \-o  |  owned                \-O  |  r_owned
\&        |                           |
\&    \-e  |  exists               \-f  |  file
\&    \-z  |  empty                \-d  |  directory, dir
\&    \-s  |  nonempty             \-l  |  symlink
\&        |                       \-p  |  fifo
\&    \-u  |  setuid               \-S  |  socket
\&    \-g  |  setgid               \-b  |  block
\&    \-k  |  sticky               \-c  |  character
\&        |                       \-t  |  tty
\&    \-T  |  ascii
\&    \-B  |  binary
.Ve
.PP
For example:
.PP
.Vb 1
\&  $rule\->file\->nonempty; # \-f \-s $file
.Ve
.PP
The \-X operators for timestamps take a single argument in a form that
Number::Compare can interpret.
.PP
.Vb 5
\&   Test | Method
\&  \-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    \-A  |  accessed
\&    \-M  |  modified
\&    \-C  |  changed
.Ve
.PP
For example:
.PP
.Vb 1
\&  $rule\->modified(">1"); # \-M $file > 1
.Ve
.SS "Stat test rules"
.IX Subsection "Stat test rules"
All of the \f(CW\*(C`stat\*(C'\fR elements have a method that takes a single argument in
a form understood by Number::Compare.
.PP
.Vb 10
\&  stat()  |  Method
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&       0  |  dev
\&       1  |  ino
\&       2  |  mode
\&       3  |  nlink
\&       4  |  uid
\&       5  |  gid
\&       6  |  rdev
\&       7  |  size
\&       8  |  atime
\&       9  |  mtime
\&      10  |  ctime
\&      11  |  blksize
\&      12  |  blocks
.Ve
.PP
For example:
.PP
.Vb 1
\&  $rule\->size(">10K")
.Ve
.SS "Depth rules"
.IX Subsection "Depth rules"
.Vb 2
\&  $rule\->min_depth(3);
\&  $rule\->max_depth(5);
.Ve
.PP
The \f(CW\*(C`min_depth\*(C'\fR and \f(CW\*(C`max_depth\*(C'\fR rule methods take a single argument and limit
the paths returned to a minimum or maximum depth (respectively) from the
starting search directory.  A depth of 0 means the starting directory itself.
A depth of 1 means its children.  (This is similar to the Unix \f(CW\*(C`find\*(C'\fR utility.)
.SS "Perl file rules"
.IX Subsection "Perl file rules"
.Vb 2
\&  # All perl rules
\&  $rule\->perl_file;
\&
\&  # Individual perl file rules
\&  $rule\->perl_module;     # .pm files
\&  $rule\->perl_pod;        # .pod files
\&  $rule\->perl_test;       # .t files
\&  $rule\->perl_installer;  # Makefile.PL or Build.PL
\&  $rule\->perl_script;     # .pl or \*(Aqperl\*(Aq in the shebang
.Ve
.PP
These rule methods match file names (or a shebang line) that are typical
of Perl distribution files.
.SS "Version control file rules"
.IX Subsection "Version control file rules"
.Vb 2
\&  # Skip all known VCS files
\&  $rule\->skip_vcs;
\&
\&  # Skip individual VCS files
\&  $rule\->skip_cvs;
\&  $rule\->skip_rcs;
\&  $rule\->skip_svn;
\&  $rule\->skip_git;
\&  $rule\->skip_bzr;
\&  $rule\->skip_hg;
\&  $rule\->skip_darcs;
.Ve
.PP
Skips files and/or prunes directories related to a version control system.
Just like \f(CW\*(C`skip_dirs\*(C'\fR, these rules should be specified early to get the
correct behavior.
.SS "File content rules"
.IX Subsection "File content rules"
\fI\f(CI\*(C`contents_match\*(C'\fI\fR
.IX Subsection "contents_match"
.PP
.Vb 1
\&  $rule\->contents_match(qr/BEGIN .* END/xs);
.Ve
.PP
The \f(CW\*(C`contents_match\*(C'\fR rule takes a list of regular expressions and returns
files that match one of the expressions.
.PP
The expressions are applied to the file's contents as a single string. For
large files, this is likely to take significant time and memory.
.PP
Files are assumed to be encoded in \s-1UTF\-8,\s0 but alternative Perl \s-1IO\s0 layers can
be passed as the first argument:
.PP
.Vb 1
\&  $rule\->contents_match(":encoding(iso\-8859\-1)", qr/BEGIN .* END/xs);
.Ve
.PP
See perlio for further details.
.PP
\fI\f(CI\*(C`line_match\*(C'\fI\fR
.IX Subsection "line_match"
.PP
.Vb 1
\&  $rule\->line_match(qr/^new/i, qr/^Addition/);
.Ve
.PP
The \f(CW\*(C`line_match\*(C'\fR rule takes a list of regular expressions and returns
files with at least one line that matches one of the expressions.
.PP
Files are assumed to be encoded in \s-1UTF\-8,\s0 but alternative Perl \s-1IO\s0 layers can
be passed as the first argument.
.PP
\fI\f(CI\*(C`shebang\*(C'\fI\fR
.IX Subsection "shebang"
.PP
.Vb 1
\&  $rule\->shebang(qr/#!.*\ebperl\eb/);
.Ve
.PP
The \f(CW\*(C`shebang\*(C'\fR rule takes a list of regular expressions or glob patterns and
checks them against the first line of a file.
.SS "Other rules"
.IX Subsection "Other rules"
\fI\f(CI\*(C`dangling\*(C'\fI\fR
.IX Subsection "dangling"
.PP
.Vb 2
\&  $rule\->symlink\->dangling;
\&  $rule\->not_dangling;
.Ve
.PP
The \f(CW\*(C`dangling\*(C'\fR rule method matches dangling symlinks.  Use it or its inverse
to control how dangling symlinks should be treated.
.SS "Negated rules"
.IX Subsection "Negated rules"
Most rule methods have a negated form preceded by \*(L"not_\*(R".
.PP
.Vb 1
\&  $rule\->not_name("foo.*")
.Ve
.PP
Because this happens automatically, it includes somewhat silly ones like
\&\f(CW\*(C`not_nonempty\*(C'\fR (which is thus a less efficient way of saying \f(CW\*(C`empty\*(C'\fR).
.PP
Rules that skip directories or version control files do not have a negated
version.
.SH "EXTENDING"
.IX Header "EXTENDING"
.SS "Custom rule subroutines"
.IX Subsection "Custom rule subroutines"
Rules are implemented as (usually anonymous) subroutine callbacks that return
a value indicating whether or not the rule matches.  These callbacks are called
with three arguments.  The first argument is a path, which is
also locally aliased as the \f(CW$_\fR global variable for convenience in simple
tests.
.PP
.Vb 1
\&  $rule\->and( sub { \-r \-w \-x $_ } ); # tests $_
.Ve
.PP
The second argument is the basename of the path, which is useful for certain
types of name checks:
.PP
.Vb 1
\&  $rule\->and( sub { $_[1] =~ /foo|bar/ } ); "foo" or "bar" in basename;
.Ve
.PP
The third argument is a hash reference that can be used to maintain state.
Keys beginning with an underscore are \fBreserved\fR for \f(CW\*(C`Path::Iterator::Rule\*(C'\fR
to provide additional data about the search in progress.
For example, the \f(CW\*(C`_depth\*(C'\fR key is used to support minimum and maximum
depth checks.
.PP
The custom rule subroutine must return one of four values:
.IP "\(bu" 4
A true value \*(-- indicates the constraint is satisfied
.IP "\(bu" 4
A false value \*(-- indicates the constraint is not satisfied
.IP "\(bu" 4
\&\f(CW\*(C`\e1\*(C'\fR \*(-- indicate the constraint is satisfied, and prune if it's a directory
.IP "\(bu" 4
\&\f(CW\*(C`\e0\*(C'\fR \*(-- indicate the constraint is not satisfied, and prune if it's a directory
.PP
A reference is a special flag that signals that a directory should not be
searched recursively, regardless of whether the directory should be
returned by the iterator or not.
.PP
The legacy \*(L"0 but true\*(R" value used previously for pruning is no longer valid
and will throw an exception if it is detected.
.PP
Here is an example.  This is equivalent to the \*(L"max_depth\*(R" rule method with
a depth of 3:
.PP
.Vb 8
\&  $rule\->and(
\&    sub {
\&      my ($path, $basename, $stash) = @_;
\&      return 1 if $stash\->{_depth} < 3;
\&      return \e1 if $stash\->{_depth} == 3;
\&      return \e0; # should never get here
\&    }
\&  );
.Ve
.PP
Files and directories and directories up to depth 3 will be returned and
directories will be searched.  Files of depth 3 will be returned. Directories
of depth 3 will be returned, but their contents will not be added to the
search.
.PP
Returning a reference is \*(L"sticky\*(R" \*(-- they will propagate through \*(L"and\*(R" and \*(L"or\*(R"
logic.
.PP
.Vb 4
\&    0 && \e0 = \e0    \e0 && 0 = \e0    0 || \e0 = \e0    \e0 || 0 = \e0
\&    0 && \e1 = \e0    \e0 && 1 = \e0    0 || \e1 = \e1    \e0 || 1 = \e1
\&    1 && \e0 = \e0    \e1 && 0 = \e0    1 || \e0 = \e1    \e1 || 0 = \e1
\&    1 && \e1 = \e1    \e1 && 1 = \e1    1 || \e1 = \e1    \e1 || 1 = \e1
.Ve
.PP
Once a directory is flagged to be pruned, it will be pruned regardless of
subsequent rules.
.PP
.Vb 1
\&    $rule\->max_depth(3)\->name(qr/foo/);
.Ve
.PP
This will return files or directories with \*(L"foo\*(R" in the name, but all
directories at depth 3 will be pruned, regardless of whether they match the
name rule.
.PP
Generally, if you want to do directory pruning, you are encouraged to use the
\&\*(L"skip\*(R" method instead of writing your own logic using \f(CW\*(C`\e0\*(C'\fR and \f(CW\*(C`\e1\*(C'\fR.
.SS "Extension modules and custom rule methods"
.IX Subsection "Extension modules and custom rule methods"
One of the strengths of File::Find::Rule is the many \s-1CPAN\s0 modules
that extend it.  \f(CW\*(C`Path::Iterator::Rule\*(C'\fR provides the \f(CW\*(C`add_helper\*(C'\fR method
to provide a similar mechanism for extensions.
.PP
The \f(CW\*(C`add_helper\*(C'\fR class method takes three arguments, a \f(CW\*(C`name\*(C'\fR for the rule
method, a closure-generating callback, and a flag for not generating a negated
form of the rule.  Unless the flag is true, an inverted \*(L"not_*\*(R" method is
generated automatically.  Extension classes should call this as a class method
to install new rule methods.  For example, this adds a \*(L"foo\*(R" method that checks
if the filename is \*(L"foo\*(R":
.PP
.Vb 1
\&  package Path::Iterator::Rule::Foo;
\&
\&  use Path::Iterator::Rule;
\&
\&  Path::Iterator::Rule\->add_helper(
\&    foo => sub {
\&      my @args = @_; # do this to customize closure with arguments
\&      return sub {
\&        my ($item, $basename) = @_;
\&        return if \-d "$item";
\&        return $basename =~ /^foo$/;
\&      }
\&    }
\&  );
\&
\&  1;
.Ve
.PP
This allows the following rule methods:
.PP
.Vb 2
\&  $rule\->foo;
\&  $fule\->not_foo;
.Ve
.PP
The \f(CW\*(C`add_helper\*(C'\fR method will warn and ignore a helper with the same name as
an existing method.
.SS "Subclassing"
.IX Subsection "Subclassing"
Instead of processing and returning strings, this module may be subclassed
to operate on objects that represent files.  Such objects \fBmust\fR stringify
to a file path.
.PP
The following private implementation methods must be overridden:
.IP "\(bu" 4
_objectify \*(-- given a path, return an object
.IP "\(bu" 4
_children \*(-- given a directory, return an (unsorted) list of [ basename, full path ] entries within it, excluding \*(L".\*(R" and \*(L"..\*(R"
.PP
Note that \f(CW\*(C`_children\*(C'\fR should return a \fIlist\fR of \fItuples\fR, where the tuples
are array references containing basename and full path.
.PP
See Path::Class::Rule source for an example.
.SH "LEXICAL WARNINGS"
.IX Header "LEXICAL WARNINGS"
If you run with lexical warnings enabled, \f(CW\*(C`Path::Iterator::Rule\*(C'\fR will issue
warnings in certain circumstances (such as an unreadable directory that must be
skipped).  To disable these categories, put the following statement at the
correct scope:
.PP
.Vb 1
\&  no warnings \*(AqPath::Iterator::Rule\*(Aq;
.Ve
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
By default, \f(CW\*(C`Path::Iterator::Rule\*(C'\fR iterator options are \*(L"slow but safe\*(R".  They
ensure uniqueness, return files in sorted order, and throw nice error messages
if something goes wrong.
.PP
If you want speed over safety, set these options:
.PP
.Vb 6
\&    %options = (
\&        loop_safe => 0,
\&        sorted => 0,
\&        depthfirst => \-1,
\&        error_handler => undef
\&    );
.Ve
.PP
Alternatively, use the \f(CW\*(C`iter_fast\*(C'\fR and \f(CW\*(C`all_fast\*(C'\fR methods instead, which set
these options for you.
.PP
.Vb 1
\&    $iter = $rule\->iter( @dirs, \e%options );
\&
\&    $iter = $rule\->iter_fast( @dirs ); # same thing
.Ve
.PP
Depending on the file structure being searched, \f(CW\*(C`depthfirst => \-1\*(C'\fR may or
may not be a good choice. If you have lots of nested directories and all the
files at the bottom, a depth first search might do less work or use less
memory, particularly if the search will be halted early (e.g. finding the first
N matches.)
.PP
Rules will shortcut on failure, so be sure to put rules likely to fail
early in a rule chain.
.PP
Consider:
.PP
.Vb 2
\&    $r1 = Path::Iterator::Rule\->new\->name(qr/foo/)\->file;
\&    $r2 = Path::Iterator::Rule\->new\->file\->name(qr/foo/);
.Ve
.PP
If there are lots of files, but only a few containing \*(L"foo\*(R", then
\&\f(CW$r1\fR above will be faster.
.PP
Rules are implemented as code references, so long chains have
some overhead.  Consider testing with a custom coderef that
combines several tests into one.
.PP
Consider:
.PP
.Vb 2
\&    $r3 = Path::Iterator::Rule\->new\->and( sub { \-x \-w \-r $_ } );
\&    $r4 = Path::Iterator::Rule\->new\->executable\->writeable\->readable;
.Ve
.PP
Rule \f(CW$r3\fR above will be much faster, not only because it stacks
the file tests, but because it requires only a single code reference.
.SH "CAVEATS"
.IX Header "CAVEATS"
Some features are still unimplemented:
.IP "\(bu" 4
Untainting options
.IP "\(bu" 4
Some File::Find::Rule helpers (e.g. \f(CW\*(C`grep\*(C'\fR)
.IP "\(bu" 4
Extension class loading via \f(CW\*(C`import()\*(C'\fR
.PP
Filetest operators and stat rules are subject to the usual portability
considerations.  See perlport for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There are many other file finding modules out there.  They all have various
features/deficiencies, depending on your preferences and needs.  Here is an
(incomplete) list of alternatives, with some comparison commentary.
.PP
Path::Class::Rule and IO::All::Rule are subclasses of
\&\f(CW\*(C`Path::Iterator::Rule\*(C'\fR and operate on Path::Class and IO::All objects,
respectively.  Because of this, they are substantially slower on
large directory trees than just using this module directly.
.PP
File::Find is part of the Perl core.  It requires the user to write a
callback function to process each node of the search.  Callbacks must use
global variables to determine the current node.  It only supports depth-first
search (both pre\- and post-order). It supports pre\- and post-processing
callbacks; the former is required for sorting files to process in a directory.
File::Find::Closures can be used to help create a callback for
File::Find.
.PP
File::Find::Rule is an object-oriented wrapper around File::Find.  It
provides a number of helper functions and there are many more
\&\f(CW\*(C`File::Find::Rule::*\*(C'\fR modules on \s-1CPAN\s0 with additional helpers.  It provides
an iterator interface, but precomputes all the results.
.PP
File::Next provides iterators for file, directories or \*(L"everything\*(R".  It
takes two callbacks, one to match files and one to decide which directories to
descend.  It does not allow control over breadth/depth order, though it does
provide means to sort files for processing within a directory. Like
File::Find, it requires callbacks to use global variables.
.PP
Path::Class::Iterator walks a directory structure with an iterator.  It is
implemented as Path::Class subclasses, which adds a degree of extra
complexity. It takes a single callback to define \*(L"interesting\*(R" paths to return.
The callback gets a Path::Class::Iterator::File or
Path::Class::Iterator::Dir object for evaluation.
.PP
File::Find::Object and companion File::Find::Object::Rule are like
File::Find and File::Find::Rule, but without File::Find inside.  They use an
iterator that does not precompute results. They can return
File::Find::Object::Result objects, which give a subset of the utility
of Path::Class objects.  File::Find::Object::Rule appears to be a literal
translation of File::Find::Rule, including oddities like making \f(CW\*(C`\-M\*(C'\fR into a
boolean.
.PP
File::chdir::WalkDir recursively descends a tree, calling a callback on each
file.  No iterator.  Supports exclusion patterns.  Depth-first post-order by
default, but offers pre-order option. Does not process symlinks.
.PP
File::Find::Iterator is based on iterator patterns in Higher Order Perl.  It
allows a filtering callback. Symlinks are followed automatically without
infinite loop protection. No control over order. It offers a \*(L"state file\*(R"
option for resuming interrupted work.
.PP
File::Find::Declare has declarative helper rules, no iterator, is
Moose-based and offers no control over ordering or following symlinks.
.PP
File::Find::Node has no iterator, does matching via callback and offers
no control over ordering.
.PP
File::Set builds up a set of files to operate on from a list of directories
to include or exclude, with control over recursion.  A callback is applied to
each file (or directory) in the set.  There is no iterator.  There is no
control over ordering.  Symlinks are not followed.  It has several extra
features for checksumming the set and creating tarballs with \fI/bin/tar\fR.
.SH "THANKS"
.IX Header "THANKS"
Thank you to Ricardo Signes (rjbs) for inspiring me to write yet another file
finder module, for writing file finder optimization benchmarks, and tirelessly
running my code over and over to see if it got faster.
.IP "\(bu" 4
See the speed of Perl file finders <http://rjbs.manxome.org/rubric/entry/1981>
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Path\-Iterator\-Rule/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Path\-Iterator\-Rule>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Path\-Iterator\-Rule.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
David Steinbrunner <dsteinbrunner@pobox.com>
.IP "\(bu" 4
Diab Jerius <djerius@cfa.harvard.edu>
.IP "\(bu" 4
Edward Betts <edward@4angle.com>
.IP "\(bu" 4
Gian Piero Carrubba <gpiero@butterfly.fdc.rm\-rf.it>
.IP "\(bu" 4
Graham Knop <haarg@cpan.org>
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Slaven Rezic <slaven.rezic@idealo.de>
.IP "\(bu" 4
Toby Inkster <tobyink@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
