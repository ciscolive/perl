.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DMARC::PurePerl 3"
.TH Mail::DMARC::PurePerl 3 "2020-07-12" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DMARC::PurePerl \- Pure Perl implementation of DMARC
.SH "VERSION"
.IX Header "VERSION"
version 1.20200214
.SH "METHODS"
.IX Header "METHODS"
.SS "init"
.IX Subsection "init"
Reset the Mail::DMARC object, preparing it for a fresh request.
.SS "validate"
.IX Subsection "validate"
This method does the following:
.Sp
.RS 4
* check if the \s-1RFC5322\s0.From domain exists (exists_in_dns)
.Sp
* query \s-1DNS\s0 for a \s-1DMARC\s0 policy (discover_policy)
.Sp
* check \s-1DKIM\s0 alignment (is_dkim_aligned)
.Sp
* check \s-1SPF\s0 alignment (is_spf_aligned)
.Sp
* determine \s-1DMARC\s0 alignment (is_aligned)
.Sp
* calculate the \fIeffective\fR \s-1DMARC\s0 policy
.Sp
* apply the \s-1DMARC\s0 policy (see Mail::DMARC::Result)
.RE
.SS "discover_policy"
.IX Subsection "discover_policy"
Query the \s-1DNS\s0 to determine if a \s-1DMARC\s0 policy exists. When the domain name in the email From header (header_from) is not an Organizational Domain (ex: www.example.com), an attempt is made to determine the O.D. using the Mozilla Public Suffix List. When the O.D. differs from the header_from, a second \s-1DNS\s0 query is sent to _dmarc.[O.D.].
.PP
If a \s-1DMARC DNS\s0 record is found, it is parsed as a Mail::DMARC::Policy object and returned.
.SS "is_aligned"
.IX Subsection "is_aligned"
Determine if this message is \s-1DMARC\s0 aligned. To pass this test, the message must pass at least one of the alignment test (\s-1DKIM\s0 or \s-1SPF\s0).
.SS "is_dkim_aligned"
.IX Subsection "is_dkim_aligned"
Determine if a valid \s-1DKIM\s0 signature in the message is aligned with the message's From header domain. This match can be in strict (exact match) or relaxed (subdomains match) alignment.
.SS "is_spf_aligned"
.IX Subsection "is_spf_aligned"
Same as \s-1DKIM,\s0 but for \s-1SPF.\s0
.SS "has_valid_reporting_uri"
.IX Subsection "has_valid_reporting_uri"
Check for the presence of a valid reporting \s-1URI\s0 in the rua or ruf \s-1DMARC\s0 policy tags.
.SS "get_organizational_domain"
.IX Subsection "get_organizational_domain"
From the 2013 \s-1DMARC\s0 spec, section 4:
.PP
.Vb 2
\&  Organizational Domain: ..is the domain that was registered with a domain
\&  name registrar. Heuristics are used to determine this...
.Ve
.SS "exists_in_dns"
.IX Subsection "exists_in_dns"
Determine if a domain exists, reliably. The \s-1DMARC\s0 draft says:
.PP
.Vb 2
\&  9.6 If the RFC5322.From domain does not exist in the DNS, Mail Receivers
\&      SHOULD direct the receiving SMTP server to reject the message {R9}.
.Ve
.PP
And in Appendix A.4:
.PP
.Vb 6
\&   A common practice among MTA operators, and indeed one documented in
\&   [ADSP], is a test to determine domain existence prior to any more
\&   expensive processing.  This is typically done by querying the DNS for
\&   MX, A or AAAA resource records for the name being evaluated, and
\&   assuming the domain is non\-existent if it could be determined that no
\&   such records were published for that domain name.
\&
\&   The original pre\-standardization version of this protocol included a
\&   mandatory check of this nature.  It was ultimately removed, as the
\&   method\*(Aqs error rate was too high without substantial manual tuning
\&   and heuristic work.  There are indeed use cases this work needs to
\&   address where such a method would return a negative result about a
\&   domain for which reporting is desired, such as a registered domain
\&   name that never sends legitimate mail and thus has none of these
\&   records present in the DNS.
.Ve
.PP
I went back to the \s-1ADSP\s0 (which led me to the ietf-dkim email list where
some 'experts' failed to agree on The Right Way to test domain validity. They
pointed out: \s-1MX\s0 records aren't mandatory, and A or \s-1AAAA\s0 aren't reliable.
.PP
Some experimentation proved both arguments in real world usage. This module
tests for existence by searching for a \s-1MX, NS, A,\s0 or \s-1AAAA\s0 record. Since this
search may be repeated for the Organizational Name, if the \s-1NS\s0 query fails,
there is no delegation from the \s-1TLD.\s0 That has proven very reliable.
.SS "fetch_dmarc_record"
.IX Subsection "fetch_dmarc_record"
Query the \s-1DNS\s0 for the presence of a \s-1DMARC\s0 record at the header from domain name and the Organizational Domain name. Returns the discovered \s-1DNS\s0 record answers.
.SS "get_from_dom"
.IX Subsection "get_from_dom"
Returns the header_from attribute, if defined.
.PP
When header_from is not defined, crudely, and very quickly parse a From header and return the domain name (aka, the header_from domain).
.PP
The From header format is defined in \s-1RFC 822\s0 and is very complex. The From header can contain multiple email addresses, each with different domains. This method returns the last one. If you want to handle this differently, parse the From header yourself and set header_from.
.SS "external_report"
.IX Subsection "external_report"
Determine if a report \s-1URL\s0 is external. If the domain name portion of the \s-1URI\s0 is not the same as the domain where the \s-1DMARC\s0 record was discovered, the report address is considered external.
.SS "verify_external_reporting"
.IX Subsection "verify_external_reporting"
\fI8.2.  Verifying External Destinations\fR
.IX Subsection "8.2. Verifying External Destinations"
.PP
It is possible to specify destinations for the different reports that
are outside the domain making the request.  This is enabled to allow
domains that do not have mail servers to request reports and have
them go someplace that is able to receive and process them.
.PP
Without checks, this would allow a bad actor to publish a \s-1DMARC\s0
policy record that requests reports be sent to a victim address, and
then send a large volume of mail that will fail both \s-1DKIM\s0 and \s-1SPF\s0
checks to a wide variety of destinations, which will in turn flood
the victim with unwanted reports.  Therefore, a verification
mechanism is included.
.PP
When a Mail Receiver discovers a \s-1DMARC\s0 policy in the \s-1DNS,\s0 and the
domain at which that record was discovered is not identical to the
host part of the authority component of a [\s-1URI\s0] specified in the
\&\*(L"rua\*(R" or \*(L"ruf\*(R" tag, the following verification steps \s-1SHOULD\s0 be taken:
.PP
.Vb 12
\&  1.  Extract the host portion of the authority component of the URI.
\&      Call this the "destination host".
\&  2.  Prepend the string "_report._dmarc".
\&  3.  Prepend the domain name from which the policy was retrieved,
\&      after conversion to an A\-label if needed.
\&  4.  Query the DNS for a TXT record at the constructed name.
\&  5.  For each record, parse the result...same overall format:
\&      "v=DMARC1" tag is mandatory and MUST appear first in the list.
\&  6.  If the result includes no TXT resource records...stop
\&  7.  If > 1 TXT resource record remains, external reporting authorized
\&  8.  If a "rua" or "ruf" tag is discovered, replace the
\&      corresponding value with the one found in this record.
.Ve
.PP
The overriding \s-1URI MUST\s0 use the same destination host from the first step.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Matt Simerson <msimerson@cpan.org>
.IP "\(bu" 4
Davide Migliavacca <shari@cpan.org>
.IP "\(bu" 4
Marc Bradshaw <marc@marcbradshaw.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Matt Simerson.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
