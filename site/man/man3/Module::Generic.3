.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic 3"
.TH Module::Generic 3 "2020-08-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic \- Generic Module to inherit from
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&    package MyModule;
\&    BEGIN
\&    {
\&        use strict;
\&        use Module::Generic;
\&        our( @ISA ) = qw( Module::Generic );
\&    };
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.13.0
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Module::Generic as its name says it all, is a generic module to inherit from.
It is designed to provide a useful framework and speed up coding and debugging.
It contains standard and support methods that may be superseded by your the module using 
Module::Generic.
.PP
As an added benefit, it also contains a powerfull \s-1AUTOLOAD\s0 transforming any hash 
object key into dynamic methods and also recognize the dynamic routine a la AutoLoader
from which I have shamelessly copied in the \s-1AUTOLOAD\s0 code. The reason is that while
\&\f(CW\*(C`AutoLoader\*(C'\fR provides the user with a convenient \s-1AUTOLOAD, I\s0 wanted a way to also
keep the functionnality of Module::Generic \s-1AUTOLOAD\s0 that were not included in
\&\f(CW\*(C`AutoLoader\*(C'\fR. So the only solution was a merger.
.SH "METHODS"
.IX Header "METHODS"
.SS "import"
.IX Subsection "import"
\&\fBimport\fR() is used for the AutoLoader mechanism and hence is not a public method.
It is just mentionned here for info only.
.SS "new"
.IX Subsection "new"
\&\fBnew\fR will create a new object for the package, pass any argument it might receive
to the special standard routine \fBinit\fR that \fImust\fR exist. 
Then it returns what returns \*(L"init\*(R".
.PP
To protect object inner content from sneaking by third party, you can declare the 
package global variable \fI\s-1OBJECT_PERMS\s0\fR and give it a Unix permission, but only 1 digit.
It will then work just like Unix permission. That is, if permission is 7, then only the 
module who generated the object may read/write content of the object. However, if
you set 5, the, other may look into the content of the object, but may not modify it.
7, as you would have guessed, allow other to modify the content of an object.
If \fI\s-1OBJECT_PERMS\s0\fR is not defined, permissions system is not activated and hence anyone 
may access and possibly modify the content of your object.
.PP
If the module runs under mod_perl, it is recognised and a clean up registered routine is 
declared to Apache to clean up the content of the object.
.SS "as_hash"
.IX Subsection "as_hash"
This will recursively transform the object into an hash suitable to be encoded in json.
.PP
It does this by calling each method of the object and build an hash reference with the 
method name as the key and the method returned value as the value.
.PP
If the method returned value is an object, it will call its \*(L"as_hash\*(R" method if it supports it.
.PP
It returns the hash reference built
.SS "clear_error"
.IX Subsection "clear_error"
Clear all error from the object and from the available global variable \f(CW$ERROR\fR.
.PP
This is a handy method to use at the beginning of other methods of calling package,
so the end user may do a test such as:
.PP
.Vb 2
\&    $obj\->some_method( \*(Aqsome arguments\*(Aq );
\&    die( $obj\->error() ) if( $obj\->error() );
\&
\&    ## some_method() would then contain something like:
\&    sub some_method
\&    {
\&        my $self = shift( @_ );
\&        ## Clear all previous error, so we may set our own later one eventually
\&        $self\->clear_error();
\&        ## ...
\&    }
.Ve
.PP
This way the end user may be sure that if \f(CW\*(C`$obj\-\*(C'\fR\fBerror()\fR> returns true something
wrong has occured.
.SS "clone"
.IX Subsection "clone"
Clone the current object if it is of type hash or array reference. It returns an error if the type is neither.
.PP
It returns the clone.
.SS "colour_closest"
.IX Subsection "colour_closest"
Provided with a colour, this returns the closest standard one supported by terminal.
.PP
A colour provided can be a colour name, or a 9 digits rgb value or an hexadecimal value
.SS "colour_format"
.IX Subsection "colour_format"
Provided with a hash reference of parameters, this will return a string properly formatted to display colours on the command line.
.PP
Parameters are:
.IP "\fItext\fR or \fImessage\fR" 4
.IX Item "text or message"
This is the text to be formatted in colour.
.IP "\fIbgcolour\fR or \fIbgcolor\fR or \fIbg_colour\fR or \fIbg_color\fR" 4
.IX Item "bgcolour or bgcolor or bg_colour or bg_color"
The value for the background colour.
.IP "\fIcolour\fR or \fIcolor\fR or \fIfg_colour\fR or \fIfg_color\fR or \fIfgcolour\fR or \fIfgcolor\fR" 4
.IX Item "colour or color or fg_colour or fg_color or fgcolour or fgcolor"
The value for the foreground colour.
.Sp
Valid value can be a colour name, an rgb value like \f(CW255255255\fR, a rgb annotation like \f(CW\*(C`rgb(255, 255, 255)\*(C'\fR or a rgba annotation like \f(CW\*(C`rgba(255,255,255,0.5)\*(C'\fR
.Sp
A colour can be preceded by the words \f(CW\*(C`light\*(C'\fR or \f(CW\*(C`bright\*(C'\fR to provide slightly lighter colour where supported.
.Sp
Similarly, if an rgba value is provided, and the opacity is less than 1, this is equivalent to using the keyword \f(CW\*(C`light\*(C'\fR
.Sp
It returns the text properly formatted to be outputted in a terminal.
.IP "\fIstyle\fR" 4
.IX Item "style"
The possible values are: \fIbold\fR, \fIitalic\fR, \fIunderline\fR, \fIblink\fR, \fIreverse\fR, \fIconceal\fR, \fIstrike\fR
.SS "colour_parse"
.IX Subsection "colour_parse"
Provided with a string, this will parse the string for colour formatting. Formatting can be encapsulated in another formatting, and can be expressed in 2 different ways. For example:
.PP
.Vb 1
\&    $self\->colour_parse( "And {style => \*(Aqi|b\*(Aq, color => green}what about{/} {style => \*(Aqblink\*(Aq, color => yellow}me{/} ?" );
.Ve
.PP
would result with the words \f(CW\*(C`what about\*(C'\fR in italic, bold and green colour and the word \f(CW\*(C`me\*(C'\fR in yellow colour blinking (if supported).
.PP
Another way is:
.PP
.Vb 1
\&    $self\->colour_parse( "And {bold light red on white}what about{/} {underline yellow}me too{/} ?" );
.Ve
.PP
would return a string with the words \f(CW\*(C`what about\*(C'\fR in light red bold text on a white background, and the words \f(CW\*(C`me too\*(C'\fR in yellow with an underline.
.PP
.Vb 1
\&    $self\->colour_parse( "Hello {bold red on white}everyone! This is {underline rgb(0,0,255)}embedded{/}{/} text..." );
.Ve
.PP
would return a string with the words \f(CW\*(C`everyone! This is\*(C'\fR in bold red characters on white background and the word \f(CW\*(C`embedded\*(C'\fR in underline blue color
.PP
The idea for this syntax, not the code, is taken from Term::ANSIColor
.SS "coloured"
.IX Subsection "coloured"
Provided with a colouring preference expressed as the first argument as string, and followed by 1 or more arguments that are concatenated to form the text string to format. For example:
.PP
.Vb 1
\&    print( $o\->coloured( \*(Aqbold white on red\*(Aq, "Hello it\*(Aqs me!\en" ) );
.Ve
.PP
A colour can be expressed as a rgb, such as :
.PP
.Vb 1
\&    print( $o\->coloured( \*(Aqunderline rgb( 0, 0, 255 ) on white\*(Aq, "Hello everyone!" ), "\en" );
.Ve
.PP
rgb can also be rgba with the last decimal, normally an opacity used here to set light color if the value is less than 1. For example :
.PP
.Vb 1
\&    print( $o\->coloured( \*(Aqunderline rgba(255, 0, 0, 0.5)\*(Aq, "Hello everyone!" ), "\en" );
.Ve
.SS "debug"
.IX Subsection "debug"
Set or get the debug level. This takes and return an integer.
.PP
Based on the value, \*(L"message\*(R" will or will not print out messages. For example :
.PP
.Vb 2
\&    $self\->debug( 2 );
\&    $self\->message( 2, "Debugging message here." );
.Ve
.PP
Since \f(CW2\fR used in \*(L"message\*(R" is equal to the debug value, the debugging message is printed.
.PP
If the debug value is switched to 1, the message will be silenced.
.SS "dump"
.IX Subsection "dump"
Provided with some data, this will return a string representation of the data formatted by Data::Printer
.SS "dump_print"
.IX Subsection "dump_print"
Provided with a file to write to and some data, this will format the string representation of the data using Data::Printer and save it to the given file.
.SS "dumper"
.IX Subsection "dumper"
Provided with some data, and optionally an hash reference of parameters as last argument, this will create a string representation of the data using Data::Dumper and return it.
.PP
This sets Data::Dumper to be terse, to indent, to use \f(CW\*(C`qq\*(C'\fR and optionally to not exceed a maximum \fIdepth\fR if it is provided in the argument hash reference.
.SS "printer"
.IX Subsection "printer"
Same as \*(L"dumper\*(R", but using Data::Printer to format the data.
.SS "dumpto_printer"
.IX Subsection "dumpto_printer"
Same as \*(L"dump_print\*(R" above that is an alias of this method.
.SS "dumpto_dumper"
.IX Subsection "dumpto_dumper"
Same as \*(L"dumpto_printer\*(R" above, but using Data::Dumper
.SS "error"
.IX Subsection "error"
Set the current error issuing a Module::Generic::Exception object, call \*(L"warn\*(R" in perlfunc, or \f(CW\*(C`$r\-\*(C'\fRwarn> under Apache2 modperl, and returns \fBundef()\fR or an empty list in list context:
.PP
.Vb 4
\&    if( $some_condition )
\&    {
\&        return( $self\->error( "Some error." ) );
\&    }
.Ve
.PP
Note that you do not have to worry about a trailing line feed sequence.
\&\fBerror\fR() takes care of it.
.PP
The script calling your module could write calls to your module methods like this:
.PP
.Vb 5
\&    my $cust_name = $object\->customer\->name ||
\&        die( "Got an error in file ", $object\->error\->file, " at line ", $object\->error\->line, ": ", $object\->error\->trace, "\en" );
\&    # or simply:
\&    my $cust_name = $object\->customer\->name ||
\&        die( "Got an error: ", $object\->error, "\en" );
.Ve
.PP
Note also that by calling \fBerror\fR() it will not clear the current error. For that
you have to call \fBclear_error\fR() explicitly.
.PP
Also, when an error is set, the global variable \fI\s-1ERROR\s0\fR is set accordingly. This is
especially usefull, when your initiating an object and that an error occured. At that
time, since the object could not be initiated, the end user can not use the object to 
get the error message, and then can get it using the global module variable 
\&\fI\s-1ERROR\s0\fR, for example:
.PP
.Vb 2
\&    my $obj = Some::Package\->new ||
\&    die( $Some::Package::ERROR, "\en" );
.Ve
.PP
If the caller has disabled warnings using the pragma \f(CW\*(C`no warnings\*(C'\fR, \*(L"error\*(R" will 
respect it and not call \fBwarn\fR. Calling \fBwarn\fR can also be silenced if the object has
a property \fIquiet\fR set to true.
.PP
The error message can be split in multiple argument. \*(L"error\*(R" will concatenate each argument to form a complete string. An argument can even be a reference to a sub routine and will get called to get the resulting string, unless the object property \fI_msg_no_exec_sub\fR is set to false. This can switched off with the method \*(L"noexec\*(R"
.PP
If perl runs under Apache2 modperl, and an error handler is set with \*(L"error_handler\*(R", this will call the error handler with the error string.
.PP
If an Apache2 modperl log handler has been set, this will also be called to log the error.
.PP
If the object property \fIfatal\fR is set to true, this will call die instead of \*(L"warn\*(R" in perlfunc.
.PP
Last, but not least since \*(L"error\*(R" returns undef in scalar context or an empty list in list context, if the method that triggered the error is chained, it would normally generate a perl error that the following method cannot be called on an undefined value. To solve this, when an object is expected, \*(L"error\*(R" returns a special object from module Module::Generic::Null that will enable all the chained methods to be performed and return the error when requested to. For example :
.PP
.Vb 2
\&    my $o = My::Package\->new;
\&    my $total $o\->get_customer(10)\->products\->total || die( $o\->error, "\en" );
.Ve
.PP
Assuming this method here \f(CW\*(C`get_customer\*(C'\fR returns an error, the chaining will continue, but produce nothing and ultimately returns undef.
.SS "errors"
.IX Subsection "errors"
Used by \fBerror\fR() to store the error sent to him for history.
.PP
It returns an array of all error that have occured in lsit context, and the last 
error in scalar context.
.SS "errstr"
.IX Subsection "errstr"
Set/get the error string, period. It does not produce any warning like \fBerror\fR would do.
.SS "get"
.IX Subsection "get"
Uset to get an object data key value:
.PP
.Vb 5
\&    $obj\->set( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
\&    ## ...
\&    my $verbose = $obj\->get( \*(Aqverbose\*(Aq );
\&    my @vals = $obj\->get( qw( verbose debug ) );
\&    print( $out "Verbose level is $vals[ 0 ] and debug level is $vals[ 1 ]\en" );
.Ve
.PP
This is no more needed, as it has been more conveniently bypassed by the \s-1AUTOLOAD\s0
generic routine with chich you may say:
.PP
.Vb 4
\&    $obj\->verbose( 1 );
\&    $obj\->debug( 0 );
\&    ## ...
\&    my $verbose = $obj\->verbose();
.Ve
.PP
Much better, no?
.SS "init"
.IX Subsection "init"
This is the \*(L"new\*(R" package object initializer. It is called by \*(L"new\*(R"
and is used to set up any parameter provided in a hash like fashion:
.PP
.Vb 1
\&    my $obj My::Module\->new( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
.Ve
.PP
You may want to superseed \*(L"init\*(R" to have suit your needs.
.PP
\&\*(L"init\*(R" needs to returns the object it received in the first place or an error if
something went wrong, such as:
.PP
.Vb 8
\&    sub init
\&    {
\&        my $self = shift( @_ );
\&        my $dbh  = DB::Object\->connect() ||
\&        return( $self\->error( "Unable to connect to database server." ) );
\&        $self\->{ \*(Aqdbh\*(Aq } = $dbh;
\&        return( $self );
\&    }
.Ve
.PP
In this example, using \*(L"error\*(R" will set the global variable \f(CW$ERROR\fR that will
contain the error, so user can say:
.PP
.Vb 1
\&    my $obj = My::Module\->new() || die( $My::Module::ERROR );
.Ve
.PP
If the global variable \fI\s-1VERBOSE\s0\fR, \fI\s-1DEBUG\s0\fR, \fI\s-1VERSION\s0\fR are defined in the module,
and that they do not exist as an object key, they will be set automatically and
accordingly to those global variable.
.PP
The supported data type of the object generated by the \*(L"new\*(R" method may either be
a hash reference or a glob reference. Those supported data types may very well be
extended to an array reference in a near future.
.PP
When provided with an hash reference, and when object property \fI_init_strict_use_sub\fR is set to true, \*(L"init\*(R" will call each method corresponding to the key name and pass it the key value and it will set an error and skip it if the corresponding method does not exist. Otherwise if the object property \fI_init_strict\fR is set to true, it will check the object property matching the hash key for the default value type and set an error and return undef if it does not match. Foe example, \*(L"init\*(R" in your module could be like this:
.PP
.Vb 7
\&    sub init
\&    {
\&        my $self = shift( @_ );
\&        $self\->{_init_strict} = 1;
\&        $self\->{products} = [];
\&        return( $self\->SUPER::init( @_ ) );
\&    }
.Ve
.PP
Then, if init is called like this:
.PP
.Vb 1
\&    $object\->init({ products => $some_string_but_not_array }) || die( $object\->error, "\en" );
.Ve
.PP
This would cause your script to die, because \f(CW\*(C`products\*(C'\fR value is a string and not an array reference.
.PP
Otherwise, if none of those special object properties are set, the init will create an object property matching the key of the hash and set its value accordingly. For example :
.PP
.Vb 5
\&    sub init
\&    {
\&        my $self = shift( @_ );
\&        return( $self\->SUPER::init( @_ ) );
\&    }
.Ve
.PP
Then, if init is called like this:
.PP
.Vb 1
\&    $object\->init( products => $array_ref, first_name => \*(AqJohn\*(Aq, last_name => \*(AqDoe\*(Aq });
.Ve
.PP
The object would then contain the properties \fIproducts\fR, \fIfirst_name\fR and \fIlast_name\fR and can be accessed as methods, such as :
.PP
.Vb 1
\&    my $fname = $object\->first_name;
.Ve
.SS "log_handler"
.IX Subsection "log_handler"
Provided a reference to a sub routine or an anonymous sub routine, this will set the handler that is called by \*(L"message\*(R"
.PP
It returns the current value set.
.SS "message"
.IX Subsection "message"
\&\fBmessage\fR() is used to display verbose/debug output. It will display something
to the extend that either \fIverbose\fR or \fIdebug\fR are toggled on.
.PP
If so, all debugging message will be prepended by \f(CW\*(C`## \*(C'\fR to highlight the fact
that this is a debugging message.
.PP
Addionally, if a number is provided as first argument to \fBmessage\fR(), it will be 
treated as the minimum required level of debugness. So, if the current debug
state level is not equal or superior to the one provided as first argument, the
message will not be displayed.
.PP
For example:
.PP
.Vb 6
\&    ## Set debugness to 3
\&    $obj\->debug( 3 );
\&    ## This message will not be printed
\&    $obj\->message( 4, "Some detailed debugging stuff that we might not want." );
\&    ## This will be displayed
\&    $obj\->message( 2, "Some more common message we want the user to see." );
.Ve
.PP
Now, why debug is used and not verbose level? Well, because mostly, the verbose level
needs only to be true, that is equal to 1 to be efficient. You do not really need to have
a verbose level greater than 1. However, the debug level usually may have various level.
.PP
Also, the text provided can be separated by comma, and even be a code reference, such as:
.PP
.Vb 1
\&    $self\->message( 2, "I have found", "something weird here:", sub{ $self\->dumper( $data ) } );
.Ve
.PP
If the object has a property \fI_msg_no_exec_sub\fR set to true, then a code reference will not be called and instead be added to the string as is. This can be done simply like this:
.PP
.Vb 1
\&    $self\->noexec\->message( 2, "I have found", "something weird here:", sub{ $self\->dumper( $data ) } );
.Ve
.SS "message_check"
.IX Subsection "message_check"
This is called by \*(L"message\*(R"
.PP
Provided with a list of arguments, this method will check if the first argument is an integer and find out if a debug message should be printed out or not. It returns the list of arguments as an array reference.
.SS "message_colour"
.IX Subsection "message_colour"
This is the same as \*(L"message\*(R", except this will check for colour formatting, which
\&\*(L"message\*(R" does not do. For example:
.PP
.Vb 1
\&    $self\->message_colour( 3, "And {bold light white on red}what about{/} {underline green}me again{/} ?" );
.Ve
.PP
\&\*(L"message_colour\*(R" can also be called as \fBmessage_color\fR
.PP
See also \*(L"colour_format\*(R" and \*(L"colour_parse\*(R"
.SS "messagef"
.IX Subsection "messagef"
This works like \*(L"sprintf\*(R" in perlfunc, so provided with a format and a list of arguments, this print out the message. For example :
.PP
.Vb 1
\&    $self\->messagef( 1, "Customer name is %s", $cust\->name );
.Ve
.PP
Where 1 is the debug level set with \*(L"debug\*(R"
.SS "messagef_colour"
.IX Subsection "messagef_colour"
This method is same as \*(L"message_colour\*(R" and messagef combined.
.PP
It enables to pass sprintf-like parameters while enabling colours.
.SS "message_log"
.IX Subsection "message_log"
This is called from \*(L"message\*(R".
.PP
Provided with a message to log, this will check if \*(L"message_log_io\*(R" returns a valid file handler, presumably to log file, and if so print the message to it.
.PP
If no file handle is set, this returns undef, other it returns the value from \f(CW\*(C`$io\-\*(C'\fRprint>
.SS "message_log_io"
.IX Subsection "message_log_io"
Set or get the message log file handle. If set, \*(L"message_log\*(R" will use it to print messages received from \*(L"message\*(R"
.PP
If no argument is provided bu your module has a global variable \f(CW\*(C`LOG_DEBUG\*(C'\fR set to true and global variable \f(CW\*(C`DEB_LOG\*(C'\fR set presumably to the file path of a log file, then this attempts to open in write mode the log file.
.PP
It returns the current log file handle, if any.
.SS "message_switch"
.IX Subsection "message_switch"
Provided with a boolean value, this toggles on or off all the calls to \*(L"message\*(R" by replacing the message method in your package with a dummy one that will ignore any call. Actually it aliases \*(L"message\*(R" to \*(L"message_off\*(R"
.PP
In reality this is not really needed, because \*(L"message\*(R" will, at the beginning check if the object has the debug flag on and if not returns undef.
.SS "new_array"
.IX Subsection "new_array"
Instantiate a new Module::Generic::Array object. If any arguments are provided, it will pass it to \*(L"new\*(R" in Module::Generic::Array and return the object.
.SS "new_hash"
.IX Subsection "new_hash"
Instantiate a new Module::Generic::Hash object. If any arguments are provided, it will pass it to \*(L"new\*(R" in Module::Generic::Hash and return the object.
.SS "new_number"
.IX Subsection "new_number"
Instantiate a new Module::Generic::Number object. If any arguments are provided, it will pass it to \*(L"new\*(R" in Module::Generic::Number and return the object.
.SS "new_scalar"
.IX Subsection "new_scalar"
Instantiate a new Module::Generic::Scalar object. If any arguments are provided, it will pass it to \*(L"new\*(R" in Module::Generic::Scalar and return the object.
.SS "noexec"
.IX Subsection "noexec"
Sets the module property \fI_msg_no_exec_sub\fR to true, so that any call to \*(L"message\*(R" whose arguments include a reference to a sub routine, will not try to execute the code. For example, imagine you have a sub routine such as:
.PP
.Vb 4
\&    sub hello
\&    {
\&        return( "Hello !" );
\&    }
.Ve
.PP
And in your code, you write:
.PP
.Vb 1
\&    $self\->message( 2, "Someone said: ", \e&hello );
.Ve
.PP
If \fI_msg_no_exec_sub\fR is set to false (by default), then the above would print out the following message:
.PP
.Vb 1
\&    Someone said Hello !
.Ve
.PP
But if \fI_msg_no_exec_sub\fR is set to true, then the same would rather produce the following :
.PP
.Vb 1
\&    Someone said CODE(0x7f9103801700)
.Ve
.SS "pass_error"
.IX Subsection "pass_error"
Provided with an error, typically a Module::Generic::Exception object, but it could be anything as long as it is an object, hopefully an exception object, this will set the error value to the error provided, and without issuing any new warning nor creating a new Module::Generic::Exception object.
.PP
It makes it possible to pass the error along so the caller can retrieve it later. This is typically used by a method calling another one in another module that produced an error. For example :
.PP
.Vb 8
\&    sub getCustomerInfo
\&    {
\&        my $self = shift( @_ );
\&        # Maybe a LWP::UserAgent sub class?
\&        my $client = $self\->lwp_client_object;
\&        my $res = $client\->get( $remote_api_endpoint ) ||
\&            return( $self\->pass_error( $client\->error ) );
\&    }
.Ve
.PP
Then :
.PP
.Vb 1
\&    my $client_info = $object\->getCustomerInfo || die( $object\->error, "\en" );
.Ve
.PP
Which would return the http client error that has been passed along
.SS "quiet"
.IX Subsection "quiet"
Set or get the object property \fIquiet\fR to true or false. If this is true, no warning will be issued when \*(L"error\*(R" is called.
.SS "save"
.IX Subsection "save"
Provided with some data and a file path, or alternatively an hash reference of options with the properties \fIdata\fR, \fIencoding\fR and \fIfile\fR, this will write to the given file the provided \fIdata\fR using the encoding \fIencoding\fR.
.PP
This is designed to simplify the tedious task of write to files.
.PP
If it cannot open the file in write mode, or cannot print to it, this will set an error and return undef. Otherwise this returns the size of the file in bytes.
.SS "set"
.IX Subsection "set"
\&\fBset\fR() sets object inner data type and takes arguments in a hash like fashion:
.PP
.Vb 1
\&    $obj\->set( \*(Aqverbose\*(Aq => 1, \*(Aqdebug\*(Aq => 0 );
.Ve
.SS "subclasses"
.IX Subsection "subclasses"
Provided with a \fI\s-1CLASS\s0\fR value, this method try to guess all the existing sub classes of the provided \fI\s-1CLASS\s0\fR.
.PP
If \fI\s-1CLASS\s0\fR is not provided, the class into which was blessed the calling object will
be used instead.
.PP
It returns an array of subclasses in list context and a reference to an array of those
subclasses in scalar context.
.PP
If an error occured, undef is returned and an error is set accordingly. The latter can
be retrieved using the \fBerror\fR method.
.SS "true"
.IX Subsection "true"
Returns a \f(CW\*(C`true\*(C'\fR variable from Module::Generic::Boolean
.SS "false"
.IX Subsection "false"
Returns a \f(CW\*(C`false\*(C'\fR variable from Module::Generic::Boolean
.SS "verbose"
.IX Subsection "verbose"
Set or get the verbosity level with an integer.
.SS "will"
.IX Subsection "will"
This will try to find out if an object supports a given method call and returns the code reference to it or undef if none is found.
.SS "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
The special \fB\s-1AUTOLOAD\s0\fR() routine is called by perl when no matching routine was found
in the module.
.PP
\&\fB\s-1AUTOLOAD\s0\fR() will then try hard to process the request.
For example, let's assue we have a routine \fBfoo\fR.
.PP
It will first, check if an equivalent entry of the routine name that was called exist in
the hash reference of the object. If there is and that more than one argument were
passed to this non existing routine, those arguments will be stored as a reference to an
array as a value of the key in the object. Otherwise the single argument will simply be stored
as the value of the key of the object.
.PP
Then, if called in list context, it will return a array if the value of the key entry was an array
reference, or a hash list if the value of the key entry was a hash reference, or finally the value
of the key entry.
.PP
If this non existing routine that was called is actually defined, the routine will be redeclared and
the arguments passed to it.
.PP
If this fails too, it will try to check for an AutoLoadable file in \f(CW\*(C`auto/PackageName/routine_name.al\*(C'\fR
.PP
If the filed exists, it will be required, the routine name linked into the package name space and finally
called with the arguments.
.PP
If the require process failed or if the AutoLoadable routine file did not exist, \fB\s-1AUTOLOAD\s0\fR() will
check if the special routine \fB\s-1EXTRA_AUTOLOAD\s0\fR() exists in the module. If it does, it will call it and pass
it the arguments. Otherwise, \fB\s-1AUTOLOAD\s0\fR will die with a message explaining that the called routine did 
not exist and could not be found in the current class.
.SH "SPECIAL METHODS"
.IX Header "SPECIAL METHODS"
.SS "_\|_instantiate_object"
.IX Subsection "__instantiate_object"
Provided with an object property name, and a class/package name, this will attempt to load the module if it is not already loaded. It does so using \*(L"load_class\*(R" in Class::Load. Once loaded, it will init an object passing it the other arguments received. It returns the object instantiated upon success or undef and sets an \*(L"error\*(R"
.PP
This is a support method used by \*(L"_instantiate_object\*(R"
.SS "_instantiate_object"
.IX Subsection "_instantiate_object"
This does the same thing as \*(L"_\|_instantiate_object\*(R" and the purpose is for this method to be potentially superseded in your own module. In your own module, you would call \*(L"_\|_instantiate_object\*(R"
.SS "_is_a"
.IX Subsection "_is_a"
Provided with an object and a package name and this will return true if the object is a blessed object from this package name (or a sub package of it), or false if not.
.PP
The value of this is to reduce the burden of having to check whether the object actually exists, i.e. is not null or undef, if it is an object and if it is from that class. This allows to do it in just one method call like this:
.PP
.Vb 4
\&    if( $self\->_is_a( $obj, \*(AqMy::Package\*(Aq ) )
\&    {
\&        # Do something
\&    }
.Ve
.PP
Of course, if you are sure the object is actually an object, then you can directly do:
.PP
.Vb 4
\&    if( $obj\->isa( \*(AqMy::Package\*(Aq ) )
\&    {
\&        # Do something
\&    }
.Ve
.SS "_is_class_loaded"
.IX Subsection "_is_class_loaded"
Provided with a class/package name, this returns true if the module is already loaded or false otherwise.
.SS "_is_array"
.IX Subsection "_is_array"
Provided with some data, this checks if the data is of type array, even if it is an object.
.PP
This uses \*(L"reftype\*(R" in Scalar::Util to achieve that purpose. So for example, an object such as :
.PP
.Vb 1
\&    package My::Module;
\&
\&    sub new
\&    {
\&        return( bless( [] => ( ref( $_[0] ) || $_[0] ) ) );
\&    }
.Ve
.PP
This would produce an object like :
.PP
.Vb 1
\&    My::Module=ARRAY(0x7f8f3b035c20)
.Ve
.PP
When checked with \*(L"_is_array\*(R" this, would return true just like an ordinary array.
.PP
If you would use :
.PP
.Vb 1
\&    ref( $object );
.Ve
.PP
It would rather return the module package name: \f(CW\*(C`My::Module\*(C'\fR
.SS "_is_hash"
.IX Subsection "_is_hash"
Same as \*(L"_is_array\*(R", but for hash reference.
.SS "_is_object"
.IX Subsection "_is_object"
Provided with some data, this checks if the data is an object. It uses \*(L"blessed\*(R" in Scalar::Util to achieve that purpose.
.SS "_is_scalar"
.IX Subsection "_is_scalar"
Provided with some data, this checks if the data is of type scalar reference, e.g. \f(CW\*(C`SCALAR(0x7fc0d3b7cea0)\*(C'\fR, even if it is an object.
.SS "_load_class"
.IX Subsection "_load_class"
Provided with a class/package name and this will attempt to load the module. This uses \*(L"load_class\*(R" in Class::Load to achieve that purpose and return whatever value \*(L"load_class\*(R" in Class::Load returns.
.SS "_obj2h"
.IX Subsection "_obj2h"
This ensures the module object is an hash reference, such as when the module object is based on a file handle for example. This permits Module::Generic to work no matter what is the underlying data type blessed into an object.
.SS "_parse_timestamp"
.IX Subsection "_parse_timestamp"
Provided with a string representing a date or datetime, and this will try to parse it and return a DateTime object. It will also create a DateTime::Format::Strptime to preserve the original date/datetime string representation and assign it to the DateTime object. So when the DateTime object is stringified, it displays the same string that was originally parsed.
.SS "_set_get"
.IX Subsection "_set_get"
Provided with an object property name and some value and this will set or get that value for that property.
.PP
However, if the value stored is an array and is called in list context, it will return the array as a list and not the array reference. Same thing for an hash reference. It will return an hash in list context. In scalar context, it returns whatever the value is, such as array reference, hash reference or string, etc.
.SS "_set_get_array"
.IX Subsection "_set_get_array"
Provided with an object property name and some data and this will store the data as an array reference.
.PP
It returns the current value stored, such as an array reference notwithstanding it is called in list or scalar context.
.PP
Example :
.PP
.Vb 1
\&    sub products { return( shift\->_set_get_array( \*(Aqproducts\*(Aq, @_ ) ); }
.Ve
.SS "_set_get_array_as_object"
.IX Subsection "_set_get_array_as_object"
Provided with an object property name and some data and this will store the data as an object of Module::Generic::Array
.PP
If this is called with no data set, an object is created with no data inside and returned
.PP
Example :
.PP
.Vb 2
\&    # In your module
\&    sub products { return( shift\->_set_get_array_as_object( \*(Aqproducts\*(Aq, @_ ) ); }
.Ve
.PP
And using your method:
.PP
.Vb 2
\&    printf( "There are %d products\en", $object\->products\->length );
\&    $object\->products\->push( $new_product );
.Ve
.SS "_set_get_boolean"
.IX Subsection "_set_get_boolean"
Provided with an object property name and some data and this will store the data as a boolean value.
.PP
If the data provided is a JSON::PP::Boolean or Module::Generic::Boolean object, the data is stored as is.
.PP
If the data is a scalar reference, its referenced value is check and \*(L"true\*(R" in Module::Generic::Boolean or \*(L"false\*(R" in Module::Generic::Boolean is set accordingly.
.PP
If the data is a string with value of \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`val\*(C'\fR \*(L"true\*(R" in Module::Generic::Boolean or \*(L"false\*(R" in Module::Generic::Boolean is set accordingly.
.PP
Otherwise the data provided is checked if it is a true value or not and \*(L"true\*(R" in Module::Generic::Boolean or \*(L"false\*(R" in Module::Generic::Boolean is set accordingly.
.PP
If no value is provided, and the object property has already been set, this performs the same checks as above and returns either a JSON::PP::Boolean or a Module::Generic::Boolean object.
.SS "_\|_create_class"
.IX Subsection "__create_class"
Provided with an object property name and an hash reference representing a dictionary and this will produce a dynamically created class/module.
.PP
If a property \fI_class\fR exists in the dictionary, it will be used as the class/package name, otherwise a name will be derived from the calling object class and the object property name. For example, in your module :
.PP
.Vb 11
\&    sub products { return( \*(Aqproducts\*(Aq, shift\->_set_get_class(
\&    {
\&    name        => { type => \*(Aqscalar\*(Aq },
\&    customer    => { type => \*(Aqobject\*(Aq, class => \*(AqMy::Customer\*(Aq },
\&    orders      => { type => \*(Aqarray_as_object\*(Aq },
\&    active      => { type => \*(Aqboolean\*(Aq },
\&    created     => { type => \*(Aqdatetime\*(Aq },
\&    metadata    => { type => \*(Aqhash\*(Aq },
\&    stock       => { type => \*(Aqnumber\*(Aq },
\&    url         => { type => \*(Aquri\*(Aq },
\&    }, @_ ) ); }
.Ve
.PP
Then calling your module method \fBproducts\fR such as :
.PP
.Vb 9
\&    my $prod = $object\->products({
\&        name => \*(AqCool product\*(Aq,
\&        customer => { first_name => \*(AqJohn\*(Aq, last_name => \*(AqDoe\*(Aq, email => \*(Aqjohn.doe@example.com\*(Aq },
\&        orders => [qw( 123 987 456 654 )],
\&        active => 1,
\&        metadata => { transaction_id => 123, api_call_id => 456 },
\&        stock => 10,
\&        uri => \*(Aqhttps://example.com/p/20\*(Aq
\&    });
.Ve
.PP
Using the resulting object \f(CW$prod\fR, we can access this dynamically created class/module such as :
.PP
.Vb 6
\&    printf( <<EOT, $prod\->name, $prod\->orders\->length, $prod\->customer\->last_name,, $prod\->url\->path )
\&    Product name: %s
\&    No of orders: %d
\&    Customer name: %s
\&    Product page path: %s
\&    EOT
.Ve
.SS "_set_get_class"
.IX Subsection "_set_get_class"
Given an object property name, a dynamic class fiels definition hash (dictionary), and optional arguments, this special method will create perl packages on the fly by calling the support method \*(L"_\|_create_class\*(R"
.PP
For example, consider the following:
.PP
.Vb 6
\&    #!/usr/local/bin/perl
\&    BEGIN
\&    {
\&        use strict;
\&        use Data::Dumper;
\&    };
\&
\&    {
\&        my $o = MyClass\->new( debug => 3 );
\&        $o\->setup\->age( 42 );
\&        print( "Age is: ", $o\->setup\->age, "\en" );
\&        print( "Setup object is: ", $o\->setup, "\en" );
\&        $o\->setup\->billing\->interval( \*(Aqmonth\*(Aq );
\&        print( "Billing interval is: ", $o\->setup\->billing\->interval, "\en" );
\&        print( "Billing object is: ", $o\->setup\->billing, "\en" );
\&        $o\->setup\->rgb( 255, 122, 100 );
\&        print( "rgb: ", join( \*(Aq, \*(Aq, @{$o\->setup\->rgb} ), "\en" );
\&        exit( 0 );
\&    }
\&
\&    package MyClass;
\&    BEGIN
\&    {
\&        use strict;
\&        use lib \*(Aq./lib\*(Aq;
\&        use parent qw( Module::Generic );
\&    };
\&
\&    sub setup 
\&    {
\&        return( shift\->_set_get_class( \*(Aqsetup\*(Aq,
\&        {
\&        name => { type => \*(Aqscalar\*(Aq },
\&        age => { type => \*(Aqnumber\*(Aq },
\&        metadata => { type => \*(Aqhash\*(Aq },
\&        rgb => { type => \*(Aqarray\*(Aq },
\&        url => { type => \*(Aquri\*(Aq },
\&        online => { type => \*(Aqboolean\*(Aq },
\&        created => { type => \*(Aqdatetime\*(Aq },
\&        billing => { type => \*(Aqclass\*(Aq, definition =>
\&            {
\&            interval => { type => \*(Aqscalar\*(Aq },
\&            frequency => { type => \*(Aqnumber\*(Aq },
\&            nickname => { type => \*(Aqscalar\*(Aq },
\&            }}
\&        }) );
\&    }
\&
\&    1;
\&
\&    _\|_END_\|_
.Ve
.PP
This will yield:
.PP
.Vb 5
\&    Age is: 42
\&    Setup object is: MyClass::Setup=HASH(0x7fa805abcb20)
\&    Billing interval is: month
\&    Billing object is: MyClass::Setup::Billing=HASH(0x7fa804ec3f40)
\&    rgb: 255, 122, 100
.Ve
.PP
The advantage of this over \fB_set_get_hash_as_object\fR is that here one controls what fields / method are supported and with which data type.
.SS "_set_get_class_array"
.IX Subsection "_set_get_class_array"
Provided with an object property name, a dictionary to create a dynamic class with \*(L"_\|_create_class\*(R" and an array reference of hash references and this will create an array of object, each one matching a set of data provided in the array reference. So for example, imagine you had a method such as below in your module :
.PP
.Vb 11
\&    sub products { return( shift\->_set_get_class_array( \*(Aqproducts\*(Aq, 
\&    {
\&    name        => { type => \*(Aqscalar\*(Aq },
\&    customer    => { type => \*(Aqobject\*(Aq, class => \*(AqMy::Customer\*(Aq },
\&    orders      => { type => \*(Aqarray_as_object\*(Aq },
\&    active      => { type => \*(Aqboolean\*(Aq },
\&    created     => { type => \*(Aqdatetime\*(Aq },
\&    metadata    => { type => \*(Aqhash\*(Aq },
\&    stock       => { type => \*(Aqnumber\*(Aq },
\&    url         => { type => \*(Aquri\*(Aq },
\&    }, @_ ) ); }
.Ve
.PP
Then your script would call this method like this :
.PP
.Vb 4
\&    $object\->products([
\&    { name => \*(AqCool product\*(Aq, customer => { first_name => \*(AqJohn\*(Aq, last_name => \*(AqDoe\*(Aq, email => \*(Aqjohn.doe@example.com\*(Aq }, active => 1, stock => 10, created => \*(Aq2020\-04\-12T07:10:30\*(Aq },
\&    { name => \*(AqAwesome tool\*(Aq, customer => { first_name => \*(AqMary\*(Aq, last_name => \*(AqDonald\*(Aq, email => \*(Aqm.donald@example.com\*(Aq }, active => 1, stock => 15, created => \*(Aq2020\-05\-12T15:20:10\*(Aq },
\&    ]);
.Ve
.PP
And this would store an array reference containing 2 objects with the above data.
.SS "_set_get_code"
.IX Subsection "_set_get_code"
Provided with an object property name and some code reference and this stores and retrieve the current value.
.PP
It returns under and set an error if the provided value is not a code reference.
.SS "_set_get_datetime"
.IX Subsection "_set_get_datetime"
Provided with an object property name and asome date or datetime string and this will attempt to parse it and save it as a DateTime object.
.PP
If the data is a 10 digits integer, this will treat it as a unix timestamp.
.PP
Parsing also recognise special word such as \f(CW\*(C`now\*(C'\fR
.PP
The created DateTime object is associated a DateTime::Format::Strptime object which enables the DateTime object to be stringified as a unix timestamp using local time stamp, whatever it is.
.PP
Even if there is no value set, and this method is called in chain, it returns a Module::Generic::Null whose purpose is to enable chaining without doing anything meaningful. For example, assuming the property \fIcreated\fR of your object is not set yet, but in your script you call it like this:
.PP
.Vb 1
\&    $object\->created\->iso8601
.Ve
.PP
Of course, the value of \f(CW\*(C`iso8601\*(C'\fR will be empty since this is a fake method produced by Module::Generic::Null. The return value of a method should always be checked.
.SS "_set_get_hash"
.IX Subsection "_set_get_hash"
Provided with an object property name and an hash reference and this set the property name with this hash reference.
.PP
You can even pass it an associative array, and it will be saved as a hash reference, such as :
.PP
.Vb 4
\&    $object\->metadata(
\&        transaction_id => 123,
\&        customer_id => 456
\&    );
\&
\&    my $hash = $object\->metadata;
.Ve
.SS "_set_get_hash_as_mix_object"
.IX Subsection "_set_get_hash_as_mix_object"
Provided with an object property name, and an optional hash reference and this returns a Module::Generic::Hash object, which allows to manipulate the hash just like any regular hash, but it provides on top object oriented method described in details in Module::Generic::Hash.
.PP
This is different from \*(L"_set_get_hash_as_object\*(R" below whose keys and values are accessed as dynamic methods and method arguments.
.SS "_set_get_hash_as_object"
.IX Subsection "_set_get_hash_as_object"
Provided with an object property name, an optional class name and an hash reference and this does the same as in \*(L"_set_get_hash\*(R", except it will create a class/package dynamically with a method for each of the hash keys, so that you can call the hash keys as method.
.PP
Also it does this recursively while handling looping, in which case, it will reuse the object previously created, and also it takes care of adapting the hash key to a proper field name, so something like \f(CW\*(C`99more\-options\*(C'\fR would become \f(CW\*(C`more_options\*(C'\fR. If the value itself is a hash, it processes it recursively transforming \f(CW\*(C`99more\-options\*(C'\fR to a proper package name \f(CW\*(C`MoreOptions\*(C'\fR prepended by \f(CW$class_name\fR provided as argument or whatever upper package was used in recursion processing.
.PP
For example in your module :
.PP
.Vb 1
\&    sub metadata { return( shift\->_set_get_hash_as_object( \*(Aqmetadata\*(Aq, @_ ) ); }
.Ve
.PP
Then populating the data :
.PP
.Vb 5
\&    $object\->metadata({
\&        first_name => \*(AqJohn\*(Aq,
\&        last_name => \*(AqDoe\*(Aq,
\&        email => \*(Aqjohn.doe@example.com\*(Aq,
\&    });
\&
\&    printf( "Customer name is %s\en", $object\->metadata\->last_name );
.Ve
.SS "_set_get_lvalue"
.IX Subsection "_set_get_lvalue"
This helper method makes it very easy to implement a \*(L"Lvalue subroutines\*(R" in perlsub method.
.PP
.Vb 4
\&    package MyObject;
\&    use strict;
\&    use warnings;
\&    use parent qw( Module::Generic );
\&    
\&    sub debug : lvalue { return( shift\->_set_get_lvalue( \*(Aqdebug\*(Aq, @_ ) ); }
.Ve
.PP
And then, this method can be called either as a lvalue method:
.PP
.Vb 2
\&    my $obj = MyObject\->new;
\&    $obj\->debug = 3;
.Ve
.PP
But also as a regular method:
.PP
.Vb 2
\&    $obj\->debug( 1 );
\&    printf( "Debug value is %d\en", $obj\->debug );
.Ve
.PP
It uses Want to achieve this. See also Sentinel
.SS "_set_get_number"
.IX Subsection "_set_get_number"
Provided with an object property name and a number, and this will create a Module::Generic::Number object and return it.
.PP
As of version v0.13.0 it also works as a lvalue method. See perlsub
.PP
In your module:
.PP
.Vb 2
\&    package MyObject;
\&    use parent qw( Module::Generic );
\&    
\&    sub level : lvalue { return( shift\->_set_get_number( \*(Aqlevel\*(Aq, @_ ) ); }
.Ve
.PP
In the script using module \f(CW\*(C`MyObject\*(C'\fR:
.PP
.Vb 8
\&    my $obj = MyObject\->new;
\&    $obj\->level = 3; # level is now 3
\&    # or
\&    $obj\->level( 4 ) # level is now 4
\&    print( "Level is: ", $obj\->level, "\en" ); # Level is 4
\&    print( "Is it an odd number: ", $obj\->level\->is_odd ? \*(Aqyes\*(Aq : \*(Aqno\*(Aq, "\en" );
\&    # Is it an od number: no
\&    $obj\->level++; # level is now 5
.Ve
.SS "_set_get_number_or_object"
.IX Subsection "_set_get_number_or_object"
Provided with an object property name and a number or an object and this call the value using \*(L"_set_get_number\*(R" or \*(L"_set_get_object\*(R" respectively
.SS "_set_get_object"
.IX Subsection "_set_get_object"
Provided with an object property name, a class/package name and some data and this will initiate a new object of the given class passing it the data.
.PP
If you pass an undefined value, it will set the property as undefined, removing whatever was set before.
.PP
You can also provide an existing object of the given class. \*(L"_set_get_object\*(R" will check the object provided does belong to the specified class or it will set an error and return undef.
.PP
It returns the object currently set, if any.
.SS "_set_get_object_array2"
.IX Subsection "_set_get_object_array2"
Provided with an object property name, a class/package name and some array reference itself containing array references each containing hash references or objects, and this will create an array of array of objects.
.SS "_set_get_object_array"
.IX Subsection "_set_get_object_array"
Provided with an object property name and a class/package name and similar to \*(L"_set_get_object_array2\*(R" this will create an array reference of objects.
.SS "_set_get_object_array_object"
.IX Subsection "_set_get_object_array_object"
Provided with an object property name, a class/package name and some data and this will create an array of object similar to \*(L"_set_get_object_array\*(R", except the array produced is a Module::Generic::Array
.SS "_set_get_object_variant"
.IX Subsection "_set_get_object_variant"
Provided with an object property name, a class/package name and some data, and depending whether the data provided is an hash reference or an array reference, this will either instantiate an object for the given hash reference or an array of objects with the hash references in the given array.
.PP
This means the value stored for the object property will vary between an hash or array reference.
.SS "_set_get_scalar"
.IX Subsection "_set_get_scalar"
Provided with an object property name, and a string, possibly a number or anything really and this will set the property value accordingly. Very straightforward.
.PP
It returns the currently value stored.
.SS "_set_get_scalar_as_object"
.IX Subsection "_set_get_scalar_as_object"
Provided with an object property name, and a string or a scalar reference and this stores it as an object of Module::Generic::Scalar
.PP
If there is already an object set for this property, the value provided will be assigned to it using \*(L"set\*(R" in Module::Generic::Scalar
.PP
If it is called and not value is set yet, this will instantiate a Module::Generic::Scalar object with no value.
.PP
So a call to this method can safely be chained to access the Module::Generic::Scalar methods. For example :
.PP
.Vb 1
\&    sub name { return( shift\->_set_get_scalar_as_object( \*(Aqname\*(Aq, @_ ) ); }
.Ve
.PP
Then, calling it :
.PP
.Vb 1
\&    $object\->name( \*(AqJohn Doe\*(Aq );
.Ve
.PP
Getting the value :
.PP
.Vb 2
\&    my $cust_name = $object\->name;
\&    print( "Nothing set yet.\en" ) if( !$cust_name\->length );
.Ve
.SS "_set_get_scalar_or_object"
.IX Subsection "_set_get_scalar_or_object"
Provided with an object property name, and a class/package name and this stores the value as an object calling \*(L"_set_get_object\*(R" if the value is an object of class \fIclass\fR or as a string calling \*(L"_set_get_scalar\*(R"
.PP
If no value has been set yet, this returns a Module::Generic::Null object to enable chaining.
.SS "_set_get_uri"
.IX Subsection "_set_get_uri"
Provided with an object property name, and an uri and this creates a \s-1URI\s0 object and sets the property value accordingly.
.PP
It accepts an \s-1URI\s0 object, an uri or urn string, or an absolute path, i.e. a string starting with \f(CW\*(C`/\*(C'\fR.
.PP
It returns the current value, if any, so the return value could be undef, thus it cannot be chained. Maybe it should return a Module::Generic::Null object ?
.SS "_to_array_object"
.IX Subsection "_to_array_object"
Provided with arguments or not, and this will return a Module::Generic::Array object of those data.
.PP
.Vb 2
\&    my $array = $self\->_to_array_object( qw( Hello world ) ); # Becomes an array object of \*(AqHello\*(Aq and \*(Aqworld\*(Aq
\&    my $array = $self\->_to_array_object( [qw( Hello world )] ); # Becomes an array object of \*(AqHello\*(Aq and \*(Aqworld\*(Aq
.Ve
.SS "_\|_dbh"
.IX Subsection "__dbh"
if your module has the global variables \f(CW\*(C`DB_DSN\*(C'\fR, this will create a database handler using \s-1DBI\s0
.PP
It will also use the following global variables in your module to set the database object: \f(CW\*(C`DB_RAISE_ERROR\*(C'\fR, \f(CW\*(C`DB_AUTO_COMMIT\*(C'\fR, \f(CW\*(C`DB_PRINT_ERROR\*(C'\fR, \f(CW\*(C`DB_SHOW_ERROR_STATEMENT\*(C'\fR, \f(CW\*(C`DB_CLIENT_ENCODING\*(C'\fR, \f(CW\*(C`DB_SERVER_PREPARE\*(C'\fR
.PP
If \f(CW\*(C`DB_SERVER_PREPARE\*(C'\fR is provided and true, \f(CW\*(C`pg_server_prepare\*(C'\fR will be set to true in the database handler.
.PP
It returns the database handler object.
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Return the value of your global variable \fI\s-1DEBUG\s0\fR, if any.
.SS "\s-1VERBOSE\s0"
.IX Subsection "VERBOSE"
Return the value of your global variable \fI\s-1VERBOSE\s0\fR, if any.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Generic::Exception, Module::Generic::Array, Module::Generic::Scalar, Module::Generic::Boolean, Module::Generic::Number, Module::Generic::Null, Module::Generic::Dynamic and Module::Generic::Tie
.PP
Number::Format, Class::Load, Scalar::Util
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2000\-2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated
files under the same terms as Perl itself.
