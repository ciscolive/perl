.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mnet::Stanza 3"
.TH Mnet::Stanza 3 "2020-08-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mnet::Stanza \- Manipulate stanza outline text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # use this module
\&    use Mnet::Stanza;
\&
\&    # read current config from standard input, trim extra spaces
\&    my $sh_run = undef;
\&    $sh_run .= "$_\en" while <STDIN>;
\&    $sh_run = Mnet::Stanza::trim($sh_run);
\&
\&    # parse existing version of secure acl from current config
\&    my $acl_old = Mnet::Stanza::parse($sh_run, qr/^ip access\-list DMZ/);
\&
\&    # note latest version of secure acl, trim extra spaces
\&    my $acl_new = Mnet::Stanza::trim("
\&        ip access\-list DMZ
\&         permit 192.168.0.0 0.0.255.255
\&    ");
\&
\&    # print config to update acl if current acl is different than latest
\&    if (Mnet::Stanza::diff($acl_old, $acl_new)) {
\&        print "no ip access\-list DMZ\en" if $acl_old;
\&        print "$acl_new\en";
\&    }
\&
\&    # print config applying acl to shutdown interfaces, if needed
\&    my @ints = Mnet::Stanza::parse($sh_run, qr/^interface/);
\&    foreach my $int (@ints) {
\&        next if $int !~ /^\es*shutdown/m;
\&        next if $int =~ /^\es*ip access\-group DMZ in/m;
\&        die "error, $int" if $int !~ /^interface (\eS+)/;
\&        print "interface $1\en";
\&        print " ip access\-group DMZ in\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mnet::Stanza can be used on text arranged in stanzas of indented lines or text
in outline format, such as the following:
.PP
.Vb 11
\&    line
\&    stanza 1
\&     indented line
\&    stanza 2
\&     sub\-stanza 1
\&      indented 1
\&      indented 2
\&      sub\-sub\-stanza 1
\&       indented 1
\&       indented 2
\&    end
.Ve
.PP
In the above example the following would be true:
.PP
.Vb 4
\&    stanza 1 contains a single indented line
\&    stanza 2 contains sub\-stanza 1 and everything under sub\-stanza 1
\&    sub\-stanza 1 contains two indented lines and a sub\-sub\-stanza 1
\&    sub\-sub\-stanza 1 contains two indented lines
.Ve
.PP
This can be used to parse cisco ios configs, amongst other things.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Mnet::Stanza implements the functions listed below.
.SS "trim"
.IX Subsection "trim"
.Vb 1
\&    $output = Mnet::Stanza::trim($input)
.Ve
.PP
The Mnet::Stanza::trim function can be used to normalize stanza spacing and may
be useful before calling the diff function or outputting a stanza to the user.
.PP
This function does the following:
.PP
.Vb 4
\&    \- replaces multiple spaces inside text with single spaces
\&    \- removes spaces at the end of any line of input
\&    \- removes blank lines and any linefeeds at end of input
\&    \- removes extra leading spaces while preserving indentation
.Ve
.PP
A null value will be output if the input is undefined.
.PP
Note that in some cases extra spaces in the input may be significant and it
may not be appropriate to use this trim function. This must be determined
by the developer. Also note that this function does not touch tabs.
.SS "parse"
.IX Subsection "parse"
.Vb 2
\&    @output = Mnet::Stanza::parse($input, qr/$match_re/)
\&    $output = Mnet::Stanza::parse($input, qr/$match_re/)
.Ve
.PP
The Mnet::Stanza::parse function can be used to output one or more matching
stanza sections from the input text, either as a list of matching stanzas or
a single string.
.PP
Here's some sample input text:
.PP
.Vb 6
\&    hostname test
\&    interface Ethernet1
\&     no ip address
\&     shutdown
\&    interface Ethernet2
\&     ip address 1.2.3.4 255.255.255.0
.Ve
.PP
Using an input match_re of qr/^interface/ the following two stanzas are output:
.PP
.Vb 5
\&    interface Ethernet1
\&     no ip address
\&     shutdown
\&    interface Ethernet2
\&     ip address 1.2.3.4 255.255.255.0
.Ve
.PP
Note that blank lines don't terminate stanzas.
.PP
Refer also to the Mnet::Stanza::trim function in this module.
.SS "diff"
.IX Subsection "diff"
.Vb 1
\&    $diff = Mnet::Stanza::diff($old, $new)
.Ve
.PP
The Mnet::Stanza::diff function checks to see if the input old and new stanza
strings are the same.
.PP
The returned diff value will be set as follows:
.PP
.Vb 5
\&    <null>      indicates old and new inputs match
\&    <undef>     indicates both inputs are undefined
\&    undef       indicates either new or old is undefined
\&    line        indicates mismatch line number and line text
\&    other       indicates mismatch such as extra eol chars at end
.Ve
.PP
Note that blank lines and all other spaces are significant. To remove extra
spaces use the Mnet::Stanza::trim function before calling this function.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mnet
.PP
Mnet::Log
