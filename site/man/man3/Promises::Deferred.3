.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises::Deferred 3"
.TH Promises::Deferred 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises::Deferred \- An implementation of Promises in Perl
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Promises::Deferred;
\&
\&  sub fetch_it {
\&      my ($uri) = @_;
\&      my $d = Promises::Deferred\->new;
\&      http_get $uri => sub {
\&          my ($body, $headers) = @_;
\&          $headers\->{Status} == 200
\&              ? $d\->resolve( decode_json( $body ) )
\&              : $d\->reject( $body )
\&      };
\&      $d\->promise;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is meant only to be used by an implementor,
meaning users of your functions/classes/modules should
always interact with the associated promise object, but
you (as the implementor) should use this class. Think
of this as the engine that drives the promises and the
promises as the steering wheels that control the
direction taken.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
Wherever a callback is mentioned below, it may take the form
of a coderef:
.PP
.Vb 1
\&    sub {...}
.Ve
.PP
or an object which has been overloaded to allow calling as a
coderef:
.PP
.Vb 1
\&    use AnyEvent;
\&
\&    my $cv = AnyEvent\->cond_var;
\&    fetch_it(\*(Aqhttp://metacpan.org\*(Aq)
\&        \->then( sub { say "Success"; return @_ })
\&        \->then( $cv, sub { $cv\->croak(@_)} )
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
This will construct an instance, it takes no arguments.
.ie n .IP """promise""" 4
.el .IP "\f(CWpromise\fR" 4
.IX Item "promise"
This will return a Promises::Promise that can be used
as a handle for this object. It will return a new one
every time it is called.
.ie n .IP """status""" 4
.el .IP "\f(CWstatus\fR" 4
.IX Item "status"
This will return the status of the asynchronous
operation, which will be either 'in progress', 'resolved'
or 'rejected'. These three strings are also constants
in this package (\f(CW\*(C`IN_PROGRESS\*(C'\fR, \f(CW\*(C`RESOLVED\*(C'\fR and \f(CW\*(C`REJECTED\*(C'\fR
respectively), which can be used to check these values.
.ie n .IP """result""" 4
.el .IP "\f(CWresult\fR" 4
.IX Item "result"
This will return the result that has been passed to either
the \f(CW\*(C`resolve\*(C'\fR or \f(CW\*(C`reject\*(C'\fR methods. It will always return
an \s-1ARRAY\s0 reference since both \f(CW\*(C`resolve\*(C'\fR and \f(CW\*(C`reject\*(C'\fR
take a variable number of arguments.
.ie n .IP """then( ?$callback, ?$error )""" 4
.el .IP "\f(CWthen( ?$callback, ?$error )\fR" 4
.IX Item "then( ?$callback, ?$error )"
This method is used to register two callbacks, both of which are optional. The
first \f(CW$callback\fR will be called on success and it will be passed all the
values that were sent to the corresponding call to \f(CW\*(C`resolve\*(C'\fR. The second,
\&\f(CW$error\fR will be called on error, and will be passed all the values that were
sent to the corresponding \f(CW\*(C`reject\*(C'\fR. It should be noted that this method will
always return a new Promises::Promise instance so that you can chain things
if you like.
.Sp
The success and error callbacks are wrapped in an \f(CW\*(C`eval\*(C'\fR block, so you can
safely call \f(CW\*(C`die()\*(C'\fR within a callback to signal an error without killing your
application. If an exception is caught, the next link in the chain will be
\&\f(CW\*(C`reject\*(C'\fR'ed and receive the exception in \f(CW@_\fR.
.Sp
If this is the last link in the chain, and there is no \f(CW$error\fR callback, the
error will be swallowed silently. You can still find it by checking the
\&\f(CW\*(C`result\*(C'\fR method, but no action will be taken. If this is not the last link in
the chain, and no \f(CW$error\fR is specified, we will attempt to bubble the error
to the next link in the chain. This allows error handling to be consolidated
at the point in the chain where it makes the most sense.
.ie n .IP """chain( @callbacks )""" 4
.el .IP "\f(CWchain( @callbacks )\fR" 4
.IX Item "chain( @callbacks )"
Utility method that takes a list of callbacks and turn them into a sequence
of \f(CW\*(C`then\*(C'\fRs.
.Sp
.Vb 3
\&    $promise\->then( sub { ...code A... } )
\&            \->then( sub { ...code B... } )
\&            \->then( sub { ...code C... } );
\&
\&    # equivalent to
\&
\&    $promise\->chain( 
\&        sub { ...code A... } ),
\&        sub { ...code B... } ),
\&        sub { ...code C... } ),
\&    );
.Ve
.ie n .IP """catch( $error )""" 4
.el .IP "\f(CWcatch( $error )\fR" 4
.IX Item "catch( $error )"
This method registers a a single error callback.  It is the equivalent
of calling:
.Sp
.Vb 1
\&    $promise\->then( sub {@_}, $error );
.Ve
.ie n .IP """done( $callback, ?$error )""" 4
.el .IP "\f(CWdone( $callback, ?$error )\fR" 4
.IX Item "done( $callback, ?$error )"
This method is used to register two callbacks, the first \f(CW$callback\fR will be
called on success and it will be passed all the values that were sent to the
corresponding call to \f(CW\*(C`resolve\*(C'\fR. The second, \f(CW$error\fR is optional and will
be called on error, and will be passed the all the values that were sent to
the corresponding \f(CW\*(C`reject\*(C'\fR.
.Sp
Unlike the \f(CW\*(C`then()\*(C'\fR method, \f(CW\*(C`done()\*(C'\fR returns an empty list specifically to
break the chain and to avoid deep recursion.  See the explanation in
Promises::Cookbook::Recursion.
.Sp
Also unlike the \f(CW\*(C`then()\*(C'\fR method, \f(CW\*(C`done()\*(C'\fR callbacks are not wrapped in an
\&\f(CW\*(C`eval\*(C'\fR block, so calling \f(CW\*(C`die()\*(C'\fR is not safe. What will happen if a \f(CW\*(C`done\*(C'\fR
callback calls \f(CW\*(C`die()\*(C'\fR depends on which event loop you are running: the pure
Perl AnyEvent::Loop will throw an exception, while \s-1EV\s0 and
Mojo::IOLoop will warn and continue running.
.ie n .IP """finally( $callback )""" 4
.el .IP "\f(CWfinally( $callback )\fR" 4
.IX Item "finally( $callback )"
This method is like the \f(CW\*(C`finally\*(C'\fR keyword in a \f(CW\*(C`try\*(C'\fR/\f(CW\*(C`catch\*(C'\fR block.  It
will execute regardless of whether the promise has been resolved or rejected.
Typically it is used to clean up resources, like closing open files etc. It
returns a Promises::Promise and so can be chained. The return value is
discarded and the success or failure of the \f(CW\*(C`finally\*(C'\fR callback will have no
effect on promises further down the chain.
.ie n .IP """timeout( $seconds )""" 4
.el .IP "\f(CWtimeout( $seconds )\fR" 4
.IX Item "timeout( $seconds )"
For asynchronous backend, returns a new promise that either takes on
the result of the current promise or is rejected after the given delay,
whichever comes first.
.Sp
The default synchronous backend does not implement a timer function. The method, in
that case, returns a chained promise that carries over the resolution of the
current promise and emits a warning.
.ie n .IP """resolve( @args )""" 4
.el .IP "\f(CWresolve( @args )\fR" 4
.IX Item "resolve( @args )"
This is the method to call upon the successful completion of your asynchronous
operation, meaning typically you would call this within the callback that you
gave to the asynchronous function/method. It takes an arbitrary list of
arguments and captures them as the \f(CW\*(C`result\*(C'\fR of this promise (so obviously
they can be retrieved with the \f(CW\*(C`result\*(C'\fR method).
.ie n .IP """reject( @args )""" 4
.el .IP "\f(CWreject( @args )\fR" 4
.IX Item "reject( @args )"
This is the method to call when an error occurs during your asynchronous
operation, meaning typically you would call this within the callback that you
gave to the asynchronous function/method. It takes an arbitrary list of
arguments and captures them as the \f(CW\*(C`result\*(C'\fR of this promise (so obviously
they can be retrieved with the \f(CW\*(C`result\*(C'\fR method).
.ie n .IP """is_in_progress""" 4
.el .IP "\f(CWis_in_progress\fR" 4
.IX Item "is_in_progress"
This is a predicate method against the status value, it
returns true if the status is \f(CW\*(C`IN_PROGRESS\*(C'\fR.
.ie n .IP """is_resolved""" 4
.el .IP "\f(CWis_resolved\fR" 4
.IX Item "is_resolved"
This is a predicate method against the status value, it
returns true if the status is \f(CW\*(C`RESOLVED\*(C'\fR.
.ie n .IP """is_rejected""" 4
.el .IP "\f(CWis_rejected\fR" 4
.IX Item "is_rejected"
This is a predicate method against the status value, it
returns true if the status is \f(CW\*(C`REJECTED\*(C'\fR.
.ie n .IP """is_done""" 4
.el .IP "\f(CWis_done\fR" 4
.IX Item "is_done"
This is a predicate method against the status value, it
returns true if the status is either \f(CW\*(C`RESOLVED\*(C'\fR or \f(CW\*(C`REJECTED\*(C'\fR.
.ie n .IP """is_unfulfilled""" 4
.el .IP "\f(CWis_unfulfilled\fR" 4
.IX Item "is_unfulfilled"
This is a predicate method against the status value, it
returns true if the status is still \f(CW\*(C`IN_PROGRESS\*(C'\fR.
.ie n .IP """is_fulfilled""" 4
.el .IP "\f(CWis_fulfilled\fR" 4
.IX Item "is_fulfilled"
This is a predicate method against the status value, it
returns true if the status is \f(CW\*(C`RESOLVED\*(C'\fR or if the
status is \f(CW\*(C`RESOLVING\*(C'\fR.
.ie n .IP """is_failed""" 4
.el .IP "\f(CWis_failed\fR" 4
.IX Item "is_failed"
This is a predicate method against the status value, it
returns true of the status is \f(CW\*(C`REJECTED\*(C'\fR or if the
status if \f(CW\*(C`REJECTING\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
