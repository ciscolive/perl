.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::Curl::Easy 3"
.TH Net::Curl::Easy 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Curl::Easy \- Perl interface for curl_easy_* functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Direct use.
.PP
.Vb 1
\& use Net::Curl::Easy qw(:constants);
\&
\& my $easy = Net::Curl::Easy\->new();
\& $easy\->setopt( CURLOPT_URL, "http://example.com/" );
\&
\& $easy\->perform();
.Ve
.PP
Build your own browser.
.PP
.Vb 3
\& package MyBrowser;
\& use Net::Curl::Easy qw(/^CURLOPT_/ /^CURLINFO_/);
\& use base qw(Net::Curl::Easy);
\&
\& sub new
\& {
\&     my $class = shift;
\&     my $self = $class\->SUPER::new( { head => \*(Aq\*(Aq, body => \*(Aq\*(Aq} );
\&     $self\->setopt( CURLOPT_USERAGENT, "MyBrowser v0.1" );
\&     $self\->setopt( CURLOPT_FOLLOWLOCATION, 1 );
\&     $self\->setopt( CURLOPT_COOKIEFILE, "" ); # enable cookie session
\&     $self\->setopt( CURLOPT_FILE, \e$self\->{body} );
\&     $self\->setopt( CURLOPT_HEADERDATA, \e$self\->{head} );
\&     return $self;
\& }
\&
\& sub get
\& {
\&     my ( $self, $uri ) = @_;
\&     $self\->setopt( CURLOPT_URL, $uri );
\&     @$self{qw(head body)} = (\*(Aq\*(Aq, \*(Aq\*(Aq);
\&     $self\->perform();
\&     my $ref = $self\->getinfo( CURLINFO_EFFECTIVE_URL );
\&     $self\->setopt( CURLOPT_REFERER, $ref );
\&     return @$self{qw(head body)};
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module wraps easy handle from libcurl and all related functions and
constants. It does not export by default anything, but constants can be
exported upon request.
.PP
.Vb 1
\& use Net::Curl::Easy qw(:constants);
.Ve
.SS "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "new( [\s-1BASE\s0] )" 4
.IX Item "new( [BASE] )"
Creates new Net::Curl::Easy object. If \s-1BASE\s0 is specified it will be used
as object base, otherwise an empty hash will be used. \s-1BASE\s0 must be a valid
reference which has not been blessed already. It will not be used by the
object.
.Sp
.Vb 1
\& my $easy = Net::Curl::Easy\->new( [qw(my very private data)] );
.Ve
.Sp
Calls \fBcurl_easy_init\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_init.html> and presets some defaults.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "duphandle( [\s-1BASE\s0] )" 4
.IX Item "duphandle( [BASE] )"
Clone Net::Curl::Easy object. It will not copy \s-1BASE\s0 from the source object.
If you want it copied you must do it on your own.
.Sp
.Vb 1
\& my $hash_clone = $easy\->duphandle( { %$easy } );
\&
\& use Storable qw(dclone);
\& my $deep_clone = $easy\->duphandle( dclone( $easy ) );
.Ve
.Sp
Calls \fBcurl_easy_duphandle\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_duphandle.html>.
.IP "setopt( \s-1OPTION, VALUE\s0 )" 4
.IX Item "setopt( OPTION, VALUE )"
Set an option. \s-1OPTION\s0 is a numeric value, use one of CURLOPT_* constants.
\&\s-1VALUE\s0 depends on whatever that option expects.
.Sp
.Vb 1
\& $easy\->setopt( Net::Curl::Easy::CURLOPT_URL, $uri );
.Ve
.Sp
Calls \fBcurl_easy_setopt\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_setopt.html>. Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "pushopt( \s-1OPTION, ARRAYREF\s0 )" 4
.IX Item "pushopt( OPTION, ARRAYREF )"
If option expects a slist, specified array will be appended instead of
replacing the old slist.
.Sp
.Vb 2
\& $easy\->pushopt( Net::Curl::Easy::CURLOPT_HTTPHEADER,
\&     [\*(AqMore: headers\*(Aq] );
.Ve
.Sp
Builds a slist and calls \fBcurl_easy_setopt\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_setopt.html>.
Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "reset( )" 4
.IX Item "reset( )"
Reinitializes easy handle \fB(was broken before v0.27!)\fR.
.Sp
.Vb 1
\& $easy\->reset();
.Ve
.Sp
Calls \fBcurl_easy_reset\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_reset.html> and presets some defaults.
.IP "perform( )" 4
.IX Item "perform( )"
Perform upload and download process.
.Sp
.Vb 1
\& $easy\->perform();
.Ve
.Sp
Calls \fBcurl_easy_perform\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_perform.html>. Rethrows exceptions from callbacks.
Throws \*(L"Net::Curl::Easy::Code\*(R" on other errors.
.IP "getinfo( \s-1OPTION\s0 )" 4
.IX Item "getinfo( OPTION )"
Retrieve a value. \s-1OPTION\s0 is one of \f(CW\*(C`CURLINFO_*\*(C'\fR constants.
.Sp
.Vb 1
\& my $socket = $self\->getinfo( CURLINFO_LASTSOCKET );
.Ve
.Sp
Calls \fBcurl_easy_getinfo\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_getinfo.html>.
Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "pause( )" 4
.IX Item "pause( )"
Pause the transfer.
.Sp
Calls \fBcurl_easy_pause\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_pause.html>. Not available in curl before 7.18.0.
Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "send( \s-1BUFFER\s0 )" 4
.IX Item "send( BUFFER )"
Send raw data.
.Sp
.Vb 1
\& $easy\->send( $data );
.Ve
.Sp
Calls \fBcurl_easy_send\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_send.html>. Not available in curl before 7.18.2.
Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "recv( \s-1BUFFER, MAXLENGTH\s0 )" 4
.IX Item "recv( BUFFER, MAXLENGTH )"
Receive raw data. Will receive at most \s-1MAXLENGTH\s0 bytes. New data will be
concatenated to \s-1BUFFER.\s0
.Sp
.Vb 1
\& $easy\->recv( $buffer, $len );
.Ve
.Sp
Calls \fBcurl_easy_recv\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_recv.html>. Not available in curl before 7.18.2.
Throws \*(L"Net::Curl::Easy::Code\*(R" on error.
.IP "error( )" 4
.IX Item "error( )"
Get last error message.
.Sp
See information on \f(CW\*(C`CURLOPT_ERRORBUFFER\*(C'\fR in \fBcurl_easy_setopt\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_setopt.html> for
a longer description.
.Sp
.Vb 2
\& my $error = $easy\->error();
\& print "Last error: $error\en";
.Ve
.IP "multi( )" 4
.IX Item "multi( )"
If easy object is associated with any multi handles, it will return that
multi handle.
.Sp
.Vb 1
\& my $multi = $easy\->multi;
.Ve
.Sp
Use \f(CW$multi\fR\->\fBadd_handle()\fR to attach the easy object to the multi interface.
.IP "share( )" 4
.IX Item "share( )"
If share object is attached to this easy handle, this method will return that
share object.
.Sp
.Vb 1
\& my $share = $easy\->share;
.Ve
.Sp
Use \fBsetopt()\fR with \s-1CURLOPT_SHARE\s0 option to attach the share object.
.IP "form( )" 4
.IX Item "form( )"
If form object is attached to this easy handle, this method will return that
form object.
.Sp
.Vb 1
\& my $form = $easy\->form;
.Ve
.Sp
Use \fBsetopt()\fR with \s-1CURLOPT_HTTPPOST\s0 option to attach the share object.
.IP "escape( )" 4
.IX Item "escape( )"
\&\s-1URL\s0 encodes the given string.
.Sp
.Vb 1
\& my $escaped = $easy\->escape( "+foo" );
.Ve
.Sp
Calls \fBcurl_easy_escape\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_escape.html> which \s-1URL\s0 encode the given string.
.IP "unescape( )" 4
.IX Item "unescape( )"
\&\s-1URL\s0 decodes the given string.
.Sp
.Vb 1
\& my $unescaped = $easy\->unescape( "%2Bbar" );
.Ve
.Sp
Calls \fBcurl_easy_unescape\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_unescape.html> which \s-1URL\s0 decodes the given string.
.Sp
If you are sure the unescaped data contains a utf8 string, you can mark it
with utf8::decode( \f(CW$unescaped\fR )
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
None of those functions are exported, you must use fully qualified names.
.IP "strerror( [\s-1WHATEVER\s0], \s-1CODE\s0 )" 4
.IX Item "strerror( [WHATEVER], CODE )"
Return a string for error code \s-1CODE.\s0
.Sp
.Vb 3
\& my $message = Net::Curl::Easy::strerror(
\&     Net::Curl::Easy::CURLE_OK
\& );
.Ve
.Sp
Calls \fBcurl_easy_strerror\fR\|(3) <https://curl.haxx.se/libcurl/c/curl_easy_strerror.html>.
.SS "\s-1CONSTANTS\s0"
.IX Subsection "CONSTANTS"
Net::Curl::Easy contains all the constants that do not form part of any
other Net::Curl modules. List below describes only the ones that behave
differently than their C counterparts.
.IP "\s-1CURLOPT_PRIVATE\s0" 4
.IX Item "CURLOPT_PRIVATE"
\&\fBsetopt()\fR does not allow to use this constant. Hide any private data in your
base object.
.IP "\s-1CURLOPT_ERRORBUFFER\s0" 4
.IX Item "CURLOPT_ERRORBUFFER"
\&\fBsetopt()\fR does not allow to use this constant. You can always retrieve latest
error message with \f(CW$east\fR\->\fBerror()\fR method.
.SS "\s-1CALLBACKS\s0"
.IX Subsection "CALLBACKS"
Reffer to libcurl documentation for more detailed info on each of those.
Callbacks can be set using \fBsetopt()\fR method.
.PP
.Vb 5
\& $easy\->setopt( CURLOPT_somethingFUNCTION, \e&callback_function );
\& # or
\& $easy\->setopt( CURLOPT_somethingFUNCTION, "callback_method" );
\& $easy\->setopt( CURLOPT_somethingDATA, [qw(any additional data
\&     you want)] );
.Ve
.IP "\s-1CURLOPT_WRITEFUNCTION\s0 ( \s-1CURLOPT_WRITEDATA\s0 )" 4
.IX Item "CURLOPT_WRITEFUNCTION ( CURLOPT_WRITEDATA )"
write callback receives 3 arguments: easy object, data to write, and whatever
\&\s-1CURLOPT_WRITEDATA\s0 was set to. It must return number of data bytes.
.Sp
.Vb 6
\& sub cb_write {
\&     my ( $easy, $data, $uservar ) = @_;
\&     # ... process ...
\&     return CURL_WRITEFUNC_PAUSE if $want_pause;
\&     return length $data;
\& }
.Ve
.IP "\s-1CURLOPT_READFUNCTION\s0 ( \s-1CURLOPT_READDATA\s0 )" 4
.IX Item "CURLOPT_READFUNCTION ( CURLOPT_READDATA )"
read callback receives 3 arguments: easy object, maximum data length, and
\&\s-1CURLOPT_READDATA\s0 value. It must return either a reference to data read or
one of numeric values: 0 \- transfer completed, \s-1CURL_READFUNC_ABORT\s0 \- abort
upload, \s-1CURL_READFUNC_PAUSE\s0 \- pause upload. Reference to any value that
is zero in length ("", undef) will also signalize completed transfer.
.Sp
.Vb 5
\& sub cb_read {
\&     my ( $easy, $maxlen, $uservar ) = @_;
\&     # ... read $data, $maxlen ...
\&     return \e$data;
\& }
.Ve
.IP "\s-1CURLOPT_IOCTLFUNCTION\s0 ( \s-1CURLOPT_IOCTLDATA\s0 )" 4
.IX Item "CURLOPT_IOCTLFUNCTION ( CURLOPT_IOCTLDATA )"
ioctl callback receives 3 arguments: easy object, ioctl command, and
\&\s-1CURLOPT_IOCTLDATA\s0 value. It must return a curlioerr value.
.Sp
.Vb 2
\& sub cb_ioctl {
\&     my ( $easy, $command, $uservar ) = @_;
\&
\&     if ( $command == CURLIOCMD_RESTARTREAD ) {
\&         if ( restart_read() ) {
\&             return CURLIOE_OK;
\&         } else {
\&             return CURLIOE_FAILRESTART;
\&         }
\&     }
\&     return CURLIOE_UNKNOWNCMD;
\& }
.Ve
.IP "\s-1CURLOPT_SEEKFUNCTION\s0 ( \s-1CURLOPT_SEEKDATA\s0 ) 7.18.0+" 4
.IX Item "CURLOPT_SEEKFUNCTION ( CURLOPT_SEEKDATA ) 7.18.0+"
seek callback receives 4 arguments: easy object, offset / position,
origin / whence, and \s-1CURLOPT_SEEKDATA\s0 value. Must return one of
CURL_SEEKFUNC_* values.
.Sp
.Vb 11
\& use Fcntl qw(:seek);
\& sub cb_seek {
\&     my ( $easy, $offset, $origin, $uservar ) = @_;
\&     if ( $origin = SEEK_SET ) {
\&         if ( seek SOMETHING, $offset, SEEK_SET ) {
\&             return CURL_SEEKFUNC_OK;
\&         }
\&         return CURL_SEEKFUNC_CANTSEEK;
\&     }
\&     return CURL_SEEKFUNC_FAIL
\& }
.Ve
.IP "\s-1CURLOPT_SOCKOPTFUNCTION\s0 ( \s-1CURLOPT_SOCKOPTDATA\s0 ) 7.15.6+" 4
.IX Item "CURLOPT_SOCKOPTFUNCTION ( CURLOPT_SOCKOPTDATA ) 7.15.6+"
sockopt callback receives 4 arguments: easy object, socket fd, socket purpose,
and \s-1CURLOPT_SOCKOPTDATA\s0 value. Is should return one of CURL_SOCKOPT_*
values.
.Sp
.Vb 5
\& sub cb_sockopt {
\&     my ( $easy, $socket, $purpose, $uservar ) = @_;
\&     # ... do something with the socket ...
\&     return CURL_SOCKOPT_OK;
\& }
.Ve
.IP "\s-1CURLOPT_OPENSOCKETFUNCTION\s0 ( \s-1CURLOPT_OPENSOCKETDATA\s0 ) 7.17.1+" 4
.IX Item "CURLOPT_OPENSOCKETFUNCTION ( CURLOPT_OPENSOCKETDATA ) 7.17.1+"
opensocket callback receives 4 arguments: easy object, socket purpose,
address structure (in form of a hashref), and \s-1CURLOPT_OPENSOCKETDATA\s0 value.
The address structure has following numeric values: \*(L"family\*(R", \*(L"socktype\*(R",
\&\*(L"protocol\*(R"; and \*(L"addr\*(R" in binary form. Use Socket module to
decode \*(L"addr\*(R" field. You are also allowed to change those values.
.Sp
Callback must return fileno of the socket or \s-1CURL_SOCKET_BAD\s0 on error.
.Sp
.Vb 3
\& use Socket;
\& sub cb_opensocket {
\&     my ( $easy, $purpose, $address, $uservar ) = @_;
\&
\&     # decode addr information
\&     my ( $port, $ip ) = unpack_sockaddr_in( $address\->{addr} );
\&     my $ip_string = inet_ntoa( $ip );
\&
\&     # open the socket
\&     socket my $socket, $address\->{family}, $address\->{socktype},
\&         $address\->{protocol};
\&
\&     # save it somewhere so perl won\*(Aqt close the socket
\&     $opened_sockets{ fileno( $socket ) } = $socket;
\&
\&     # return the socket
\&     return fileno $socket;
\& }
.Ve
.IP "\s-1CURLOPT_CLOSESOCKETFUNCTION\s0 ( \s-1CURLOPT_CLOSESOCKETDATA\s0 ) 7.21.7+" 4
.IX Item "CURLOPT_CLOSESOCKETFUNCTION ( CURLOPT_CLOSESOCKETDATA ) 7.21.7+"
closesocket callback receives 3 arguments: easy object, socket fileno,
and \s-1CURLOPT_CLOSESOCKETDATA\s0 value.
.Sp
.Vb 5
\& sub cb_closesocket {
\&     my ( $easy, $fileno, $uservar ) = @_;
\&     my $socket = delete $opened_sockets{ $fileno };
\&     close $socket;
\& }
.Ve
.IP "\s-1CURLOPT_PROGRESSFUNCTION\s0 ( \s-1CURLOPT_PROGRESSDATA\s0 )" 4
.IX Item "CURLOPT_PROGRESSFUNCTION ( CURLOPT_PROGRESSDATA )"
Progress callback receives 6 arguments: easy object, dltotal, dlnow, ultotal,
ulnow and \s-1CURLOPT_PROGRESSDATA\s0 value. It should return 0.
.Sp
.Vb 5
\& sub cb_progress {
\&     my ( $easy, $dltotal, $dlnow, $ultotal, $ulnow, $uservar ) = @_;
\&     # ... display progress ...
\&     return 0;
\& }
.Ve
.Sp
Since \s-1CURLOPT_XFERINFODATA\s0 is an alias to \s-1CURLOPT_PROGRESSDATA,\s0
they both set the same callback data for both
\&\s-1CURLOPT_PROGRESSFUNCTION\s0 and \s-1CURLOPT_PROGRESSFUNCTION\s0 callbacks.
.IP "\s-1CURLOPT_XFERINFOFUNCTION\s0 ( \s-1CURLOPT_XFERINFODATA\s0 ) 7.32.0+" 4
.IX Item "CURLOPT_XFERINFOFUNCTION ( CURLOPT_XFERINFODATA ) 7.32.0+"
Works exactly like \s-1CURLOPT_PROGRESSFUNCTION\s0 callback, except that dltotal, dlnow, ultotal
and ulnow are now integer values instead of double.
.Sp
Since \s-1CURLOPT_XFERINFODATA\s0 is an alias to \s-1CURLOPT_PROGRESSDATA,\s0
they both set the same callback data for both
\&\s-1CURLOPT_PROGRESSFUNCTION\s0 and \s-1CURLOPT_PROGRESSFUNCTION\s0 callbacks.
.IP "\s-1CURLOPT_HEADERFUNCTION\s0 ( \s-1CURLOPT_WRITEHEADER\s0 )" 4
.IX Item "CURLOPT_HEADERFUNCTION ( CURLOPT_WRITEHEADER )"
Behaviour is the same as in write callback. Callback is called once for
every header line.
.IP "\s-1CURLOPT_DEBUGFUNCTION\s0 ( \s-1CURLOPT_DEBUGDATA\s0 )" 4
.IX Item "CURLOPT_DEBUGFUNCTION ( CURLOPT_DEBUGDATA )"
Debug callback receives 4 arguments: easy object, message type, debug data
and \s-1CURLOPT_DEBUGDATA\s0 value. Must return 0.
.Sp
.Vb 5
\& sub cb_debug {
\&     my ( $easy, $type, $data, $uservar ) = @_;
\&     # ... display debug info ...
\&     return 0;
\& }
.Ve
.IP "\s-1CURLOPT_SSL_CTX_FUNCTION\s0 ( \s-1CURLOPT_SSL_CTX_DATA\s0 )" 4
.IX Item "CURLOPT_SSL_CTX_FUNCTION ( CURLOPT_SSL_CTX_DATA )"
Not supported, probably will never be.
.IP "\s-1CURLOPT_INTERLEAVEFUNCTION\s0 ( \s-1CURLOPT_INTERLEAVEDATA\s0 ) 7.20.0+" 4
.IX Item "CURLOPT_INTERLEAVEFUNCTION ( CURLOPT_INTERLEAVEDATA ) 7.20.0+"
Behaviour is the same as in write callback.
.IP "\s-1CURLOPT_CHUNK_BGN_FUNCTION\s0 ( \s-1CURLOPT_CHUNK_DATA\s0 ) 7.21.0+" 4
.IX Item "CURLOPT_CHUNK_BGN_FUNCTION ( CURLOPT_CHUNK_DATA ) 7.21.0+"
chunk_bgn callback receives 4 arguments: easy object, fileinfo structure (in
form of a hashref), number of remaining chunks, and \s-1CURLOPT_CHUNK_DATA\s0 value.
It must return one of CURL_CHUNK_BGN_FUNC_* values.
.Sp
.Vb 2
\& sub cb_chunk_bgn {
\&     my ( $easy, $fileinfo, $remaining, $uservar ) = @_;
\&
\&     if ( exists $fileinfo\->{filetype} and
\&             $fileinfo\->{filetype} != CURLFILETYPE_FILE ) {
\&         # download regular files only
\&         return CURL_CHUNK_BGN_FUNC_SKIP;
\&     }
\&     my $filename = "unknown." . $remaining;
\&     $filename = $fileinfo\->{filename}
\&         if defined $fileinfo\->{filename};
\&
\&     open $easy\->{myfile}, \*(Aq>\*(Aq, $filename
\&         or return CURL_CHUNK_BGN_FUNC_FAIL;
\&
\&     return CURL_CHUNK_BGN_FUNC_OK;
\& }
.Ve
.IP "\s-1CURLOPT_CHUNK_END_FUNCTION\s0 ( \s-1CURLOPT_CHUNK_DATA\s0 ) 7.21.0+" 4
.IX Item "CURLOPT_CHUNK_END_FUNCTION ( CURLOPT_CHUNK_DATA ) 7.21.0+"
chunk_end callback receives 2 arguments: easy object and \s-1CURLOPT_CHUNK_DATA\s0
value. Must return one of CURL_CHUNK_END_FUNC_* values.
.Sp
.Vb 5
\& sub cb_chunk_end {
\&     my ( $easy, $uservar ) = @_;
\&     # ... close $easy\-{myfile} ...
\&     return CURL_CHUNK_END_FUNC_OK;
\& }
.Ve
.IP "\s-1CURLOPT_FNMATCH_FUNCTION\s0 ( \s-1CURLOPT_FNMATCH_DATA\s0 ) 7.21.0+" 4
.IX Item "CURLOPT_FNMATCH_FUNCTION ( CURLOPT_FNMATCH_DATA ) 7.21.0+"
fnmatch callback receives 4 arguments: easy object, pattern, string, and
\&\s-1CURLOPT_FNMATCH_DATA\s0 value. Must return one of CURL_FNMATCHFUNC_* values.
.Sp
.Vb 6
\& sub cb_fnmatch {
\&     my ( $easy, $pattern, $string, $uservar ) = @_;
\&     return ( $string =~ m/$pattern/i
\&         ? CURL_FNMATCHFUNC_MATCH
\&         : CURL_FNMATCHFUNC_NOMATCH );
\& }
.Ve
.IP "\s-1CURLOPT_SSH_KEYFUNCTION\s0 ( \s-1CURLOPT_SSH_KEYDATA\s0 ) 7.19.6+" 4
.IX Item "CURLOPT_SSH_KEYFUNCTION ( CURLOPT_SSH_KEYDATA ) 7.19.6+"
sshkey callback receives 4 arguments: easy object, known key, found key,
khmatch status and \s-1CURLOPT_SSH_KEYDATA\s0 value.
Must return one of CURLKHSTAT_* values.
.Sp
.Vb 4
\& sub cb_sshkey {
\&     my ( $easy, $knownkey, $foundkey, $khmatch, $uservar ) = @_;
\&     return CURLKHSTAT_FINE_ADD_TO_FILE;
\& }
.Ve
.SS "Net::Curl::Easy::Code"
.IX Subsection "Net::Curl::Easy::Code"
Most Net::Curl::Easy methods on failure throw a Net::Curl::Easy::Code error
object. It has both numeric value and, when used as string, it calls \fBstrerror()\fR
function to display a nice message.
.PP
.Vb 10
\& eval {
\&     $easy\->somemethod();
\& };
\& if ( ref $@ eq "Net::Curl::Easy::Code" ) {
\&     if ( $@ == CURLE_SOME_ERROR_WE_EXPECTED ) {
\&         warn "Expected error, continuing\en";
\&     } else {
\&         die "Unexpected curl error: $@\en";
\&     }
\& } else {
\&     # rethrow everyting else
\&     die $@;
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Curl
Net::Curl::Multi
Net::Curl::examples
\&\fBlibcurl\-easy\fR\|(3)
\&\fBlibcurl\-errors\fR\|(3)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2011\-2015 Przemyslaw Iskra <sparky at pld\-linux.org>.
.PP
You may opt to use, copy, modify, merge, publish, distribute and/or sell
copies of the Software, and permit persons to whom the Software is furnished
to do so, under the terms of the \s-1MPL\s0 or the MIT/X\-derivate licenses. You may
pick one of these licenses.
