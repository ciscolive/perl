.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mo::Design 3"
.TH Mo::Design 3 "2016-07-06" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Overview"
.IX Header "Overview"
This is the design document for the Mo module.
.PP
It is intended to help people understand the thinking behind Mo.
.PP
Like Mo, this document is a work in progress. Nothing here is in stone.
Everything is up for discussion. This document just explains the current
understanding, so you'll know where to start.
.SH "Design Goals"
.IX Header "Design Goals"
Mo has the following design goals. These goals are all important and have to
be balanced against each other.
.IP "Provide usable \s-1OO\s0 for Perl modules." 4
.IX Item "Provide usable OO for Perl modules."
This includes \fIat least\fR the following. The current implementation contains a
bit more than this, but that is due to the other design goals.
.RS 4
.IP "Single Inheritance" 4
.IX Item "Single Inheritance"
Mo should provide a mechanism for inheritance. At least single inheritance.
.IP "Object Construction" 4
.IX Item "Object Construction"
Mo needs to provide a \f(CW\*(C`new()\*(C'\fR object constructor. It should take a set of
name/value pairs and return a new object reference, blessed into the class'
package name.
.IP "Attribute Declaration" 4
.IX Item "Attribute Declaration"
Mo needs to provide a way to declare attribute accessing methods. They need to
be able to set and get values.
.RE
.RS 4
.RE
.IP "Be minimal" 4
.IX Item "Be minimal"
Mo only adds core features if they are considered very desirable \fBand\fR can be
implemented in a very small amount of code. Most features are in external
\&\f(CW\*(C`feature\*(C'\fR modules now.
.IP "Be useful" 4
.IX Item "Be useful"
Mo wants to be the first module that Perl programmers reach for when they need
simple \s-1OO.\s0 To that end, it needs to be extremely useful and support common
idioms, even if they are not strictly minimal.
.IP "Be fast" 4
.IX Item "Be fast"
Mo should be about as fast as if you rolled your own \s-1OO.\s0 It should be fast at
both startup (compile) time and at run time. It should especially strive to
have fast accessors. Speed optimizations should be simple and minimal.
.IP "Be embeddable" 4
.IX Item "Be embeddable"
There may be situations where you want to inline Mo into your code. For this
reason, Mo will try to be in one minimal pure Perl file, with no comments or
documentation. See \f(CW\*(C`Mo::Inline\*(C'\fR.
.IP "Easy upgrade/downgrade path with Moo" 4
.IX Item "Easy upgrade/downgrade path with Moo"
Moose has become the accepted style of \s-1OO\s0 in perl. Mo will attempt to not
do the things it does in an incompatible style to the \f(CW\*(C`Moose\*(C'\fR family.
.Sp
This is not to say that all Mo code can be switched to Moo, or vice versa.
This \fIis\fR to say that you should be able to find a style of coding using the
full capabilities of Mo, that you can switch to Moo (or Mouse or Moose),
if you want to.
.Sp
This is a difficult design goal, and might sometimes lose out to the other
goals. However, this document will attempt to explain all the decisions.
.SH "Current Status"
.IX Header "Current Status"
This section will go into detail on all the current aspects of Mo, why
decisions were made and any known concerns being thought about.
.IP "Inheritance" 4
.IX Item "Inheritance"
Mo uses \f(CW\*(C`extends\*(C'\fR to name its (single inheritance) parent.
.Sp
In the past, Mo supported multiple inheritance. This was considered suboptimal
for a few reasons. \s-1MI\s0 is generally frowned upon in Perl. It has problems
that are better solved by roles. It also makes the \s-1BUILD\s0 call sequence much
more difficult, which makes Moose compatibility hard. For these reasons, we
removed \s-1MI\s0 as a Mo feature. As a result, the code became much simpler.
.Sp
It is highly doubtful that roles will be supported either. One should upgrade
to Moo or higher when \s-1MI\s0 or roles become needed.
.IP "Construction" 4
.IX Item "Construction"
Mo uses a \f(CW\*(C`new\*(C'\fR method for construction. It is super minimal and fast. It does no calling of the \s-1BUILD\s0 sequence. To get that, use:
.Sp
.Vb 1
\&    use Mo \*(Aqbuild\*(Aq;
.Ve
.IP "Accessors" 4
.IX Item "Accessors"
Mo uses \f(CW\*(C`has\*(C'\fR for generating accessors. Like Moose, it takes a name and a
list of option/value pairs.
.Sp
All options are silently ignored. Options like \f(CW\*(C`default\*(C'\fR and \f(CW\*(C`builder\*(C'\fR are
available as feature modules:
.Sp
.Vb 1
\&    use Mo qw\*(Aqdefault builder\*(Aq;
.Ve
.Sp
The default getter/setter is optimized for speed. It does no checks and is
always 'rw'.
.IP "No runtime checks" 4
.IX Item "No runtime checks"
Mo will not check or validate its usage. It is so minimal, that it will leave
this up to the code author. Run time checks don't offer any gain when the
usage is already correct. In a dynamic language like Perl, they only serve to
make code slower. Plus, runtime checks would bloat the Mo code. Where would
you draw the line? The best option is to leave them out, document things well,
and let people write tests for their code, if they really need to. Upgrading
from Mo is another alternative.
.IP "Size matters" 4
.IX Item "Size matters"
Mo.pm and its feature modules are golfed, compressed and unreadable by mere
mortals. It has no comments or pod. The documentation is in Mo.pod and the
comments are all in here. This makes Mo.pm a little black box of code that you
can use anywhere.
.Sp
When we hack on Mo.pm we do it on src/. When we are done we run \f(CW\*(C`make \-C
src/\*(C'\fR and it compresses stuff into \f(CW\*(C`lib/\*(C'\fR.
.Sp
The package declaration and \f(CW$VERSION\fR are on their own lines. That way if
someone inlines Mo, they can make their own package line more easily, and just
grab line 3, the code.
.IP "strict and warnings" 4
.IX Item "strict and warnings"
We turn on strict and warnings for the user of Mo because it is really easy
and offers great value. Also, all the other Moose family does it.
.SH "Topics, Concerns and Issues"
.IX Header "Topics, Concerns and Issues"
This is a list of everything else.
.SS "The feature system"
.IX Subsection "The feature system"
Mo now has a decent feature system so that almost anything can be added piecemeal. To use features you say:
.PP
.Vb 1
\&    use Mo qw\*(Aqfoo bar\*(Aq;
.Ve
.PP
This loads Mo::foo and Mo::bar. It calls the \f(CW\*(C`e()\*(C'\fR subroutine on each.
.SS "1024 Size Limit"
.IX Subsection "1024 Size Limit"
Mo.pm has a goal to never be larger than 1024 bytes. It has almost never been
larger than 500 bytes so far. It is currently under 450 and should only go
down (assuming we have the core features nailed down).
.SS "Automated Golfing"
.IX Subsection "Automated Golfing"
I want to start a policy that all of the golfing efforts will be made via a
script to sane code. We should automate testing both the ungolfed and golfed
code.
.PP
Golfing has now been automated using the power of \s-1PPI.\s0
.SS "Moose and Moo creators like Mo"
.IX Subsection "Moose and Moo creators like Mo"
I can't (and am certain that I don't) speak for all the Moose community, But
I(ngy) personally know that stevan (creator of Moose) and mst (creator of Moo)
approve of Mo. They hang out on the #mo irc channel, and mst has made a large
portion of the code commits.
.PP
This is a sign of a healthy project, because hopefully we can all forge a
clear idea of how all these modules relate to each other and support each
other.
.SS "Why not Moose?"
.IX Subsection "Why not Moose?"
The sad fact of Perl 5 is that there's no object model built in.
.PP
Moose not only added an elegant, usable object model, it took \s-1OO\s0 to a new
level. It is indeed a postmodern system. Unfortunately this comes at a (often
hefty) performance price.
.PP
Attempts to make something similar but less hefty came in the forms of
Mouse, Mousse and Moo. Mo is just the next attempt. It is a bare
minimum \s-1OO\s0 framework, that still looks like Moose.
.PP
I've heard people argue that Mo doesn't belong in the Moose family, but those
same people often feel the same way about Mouse and Moo. It won't stop me from
trying to make something wonderful, that can be fairly easily upgraded to
something possibly more wonderful.
.PP
With each of these attempts, less of the original Moose power is implemented.
This annoys the hardcore Moose developers. But hopefully it pushes them
towards making Moose better and better. I can imagine the day when Moose is a
compiled in part of the \f(CW\*(C`perl\*(C'\fR interpreter and thus faster then Mo. At that
point, all the others will become remnants of the past.
.PP
In the meantime, I hope that Mo et al, helps people to get past their Moose
inhibitions, and start using the Mo* that makes sense. I(ngy) have authored
other \s-1OO\s0 base modules like Spiffy and Gloom. There are things about those that
I sorely miss in the Moose family, but I have decided to stopping fighting the
Moose. I for one, welcome our new giant antlered overlord.
