.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Function::Parameters 3"
.TH Function::Parameters 3 "2017-11-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Function::Parameters \- define functions and methods with parameter lists ("subroutine signatures")
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Function::Parameters;
\&
\& # plain function
\& fun foo($x, $y, $z = 5) {
\&     return $x + $y + $z;
\& }
\& print foo(1, 2), "\en";  # 8
\&
\& # method with implicit $self
\& method bar($label, $n) {
\&     return "$label: " . ($n * $self\->scale);
\& }
\&
\& # named arguments: order doesn\*(Aqt matter in the call
\& fun create_point(:$x, :$y, :$color) {
\&     print "creating a $color point at ($x, $y)\en";
\& }
\& create_point(
\&     color => "red",
\&     x     => 10,
\&     y     => 5,
\& );
\&
\& package Derived {
\&     use Function::Parameters qw(:std :modifiers);
\&     use Moo;
\&
\&     extends \*(AqBase\*(Aq;
\&
\&     has \*(Aqgo_big\*(Aq => (
\&         is => \*(Aqro\*(Aq,
\&     );
\&
\&     # "around" method with implicit $orig and $self
\&     around size() {
\&         return $self\->$orig() * 2 if $self\->go_big;
\&         return $self\->$orig();
\&     }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides two new keywords, \f(CW\*(C`fun\*(C'\fR and \f(CW\*(C`method\*(C'\fR, for defining
functions and methods with parameter lists. At minimum this saves you from
having to unpack \f(CW@_\fR manually, but this module can do much more for you.
.PP
The parameter lists provided by this module are similar to the \f(CW\*(C`signatures\*(C'\fR
feature available in perl v5.20+. However, this module supports all perl
versions starting from v5.14, it offers far more features than core signatures,
and it is not experimental. The downside is that you need a C compiler if you
want to install it from source, as it uses Perl's
keyword plugin \s-1API\s0 in order to work reliably
without requiring a source filter.
.SS "Default functionality"
.IX Subsection "Default functionality"
This module is a lexically scoped pragma: If you \f(CW\*(C`use Function::Parameters\*(C'\fR
inside a block or file, the keywords won't be available outside of that block
or file.
.PP
You can also disable \f(CW\*(C`Function::Parameters\*(C'\fR within a block:
.PP
.Vb 4
\& {
\&     no Function::Parameters;  # disable all keywords
\&     ...
\& }
.Ve
.PP
Or explicitly list the keywords you want to disable:
.PP
.Vb 5
\& {
\&     no Function::Parameters qw(method);
\&     # \*(Aqmethod\*(Aq is a normal identifier here
\&     ...
\& }
.Ve
.PP
You can also explicitly list the keywords you want to enable:
.PP
.Vb 2
\& use Function::Parameters qw(fun);  # provides \*(Aqfun\*(Aq but not \*(Aqmethod\*(Aq
\& use Function::Parameters qw(method);  # provides \*(Aqmethod\*(Aq but not \*(Aqfun\*(Aq
.Ve
.PP
\fISimple parameter lists\fR
.IX Subsection "Simple parameter lists"
.PP
By default you get two keywords, \f(CW\*(C`fun\*(C'\fR and \f(CW\*(C`method\*(C'\fR (but see
\&\*(L"Customizing and extending\*(R" below). \f(CW\*(C`fun\*(C'\fR is very similar to \f(CW\*(C`sub\*(C'\fR. You can
use it to define both named and anonymous functions:
.PP
.Vb 3
\& fun left_pad($str, $n) {
\&     return sprintf \*(Aq%*s\*(Aq, $n, $str;
\& }
\&
\& print left_pad("hello", 10), "\en";
\&
\& my $twice = fun ($x) { $x * 2 };
\& print $twice\->(21), "\en";
.Ve
.PP
In the simplest case the parameter list is just a comma-separated list of zero
or more scalar variables (enclosed in parentheses, following the function name,
if any).
.PP
\&\f(CW\*(C`Function::Parameters\*(C'\fR automatically validates the arguments your function is
called with. If the number of arguments doesn't match the parameter list, an
exception is thrown.
.PP
Apart from that, the parameter variables are defined and initialized as if by:
.PP
.Vb 5
\& sub left_pad {
\&     sub left_pad;
\&     my ($str, $n) = @_;
\&     ...
\& }
.Ve
.PP
In particular, \f(CW@_\fR is still available in functions defined by \f(CW\*(C`fun\*(C'\fR and
holds the original argument list.
.PP
The inner \f(CW\*(C`sub left_pad;\*(C'\fR declaration is intended to illustrate that the name
of the function being defined is in scope in its own body, meaning you can call
it recursively without having to use parentheses:
.PP
.Vb 4
\& fun fac($n) {
\&     return 1 if $n < 2;
\&     return $n * fac $n \- 1;
\& }
.Ve
.PP
In a normal \f(CW\*(C`sub\*(C'\fR the last line would have had to be written
\&\f(CW\*(C`return $n * fac($n \- 1);\*(C'\fR.
.PP
\&\f(CW\*(C`method\*(C'\fR is almost the same as \f(CW\*(C`fun\*(C'\fR but automatically creates a \f(CW$self\fR
variable as the first parameter (which is removed from \f(CW@_\fR):
.PP
.Vb 3
\& method foo($x, $y) {
\&    ...
\& }
\&
\& # works like:
\& sub foo :method {
\&    my $self = shift;
\&    my ($x, $y) = @_;
\&    ...
\& }
.Ve
.PP
As you can see, the \f(CW\*(C`:method\*(C'\fR attribute is also added automatically (see
\&\*(L"method\*(R" in attributes for details).
.PP
In some cases (e.g. class methods) \f(CW$self\fR is not the best name for the
invocant of the method. You can override it on a case-by-case basis by putting
a variable name followed by a \f(CW\*(C`:\*(C'\fR (colon) as the first thing in the parameter
list:
.PP
.Vb 3
\& method new($class: $x, $y) {
\&     return bless { x => $x, y => $y }, $class;
\& }
.Ve
.PP
Here the invocant is named \f(CW$class\fR, not \f(CW$self\fR. It looks a bit weird but
still works the same way if the remaining parameter list is empty:
.PP
.Vb 3
\& method from_env($class:) {
\&     return $class\->new($ENV{x}, $ENV{y});
\& }
.Ve
.PP
\fIDefault arguments\fR
.IX Subsection "Default arguments"
.PP
(Most of the following examples use \f(CW\*(C`fun\*(C'\fR only. Unless specified otherwise
everything applies to \f(CW\*(C`method\*(C'\fR as well.)
.PP
You can make some arguments optional by giving them default values.
.PP
.Vb 3
\& fun passthrough($x, $y = 42, $z = []) {
\&     return ($x, $y, $z);
\& }
.Ve
.PP
In this example the first parameter \f(CW$x\fR is required but \f(CW$y\fR and \f(CW$z\fR are
optional.
.PP
.Vb 6
\& passthrough(\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq, \*(Aqd\*(Aq)   # error: Too many arguments
\& passthrough(\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq)        # returns (\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq)
\& passthrough(\*(Aqa\*(Aq, \*(Aqb\*(Aq)             # returns (\*(Aqa\*(Aq, \*(Aqb\*(Aq, [])
\& passthrough(\*(Aqa\*(Aq, undef)           # returns (\*(Aqa\*(Aq, undef, [])
\& passthrough(\*(Aqa\*(Aq)                  # returns (\*(Aqa\*(Aq, 42, [])
\& passthrough()                     # error: Too few arguments
.Ve
.PP
Default arguments are evaluated whenever a corresponding real argument is not
passed in by the caller. \f(CW\*(C`undef\*(C'\fR counts as a real argument; you can't use the
default value for parameter \fIN\fR and still pass a value for parameter \fIN+1\fR.
\&\f(CW\*(C`$z = []\*(C'\fR means each call that doesn't pass a third argument gets a new array
reference (they're not shared between calls).
.PP
Default arguments are evaluated as part of the function body, allowing for
silliness such as:
.PP
.Vb 4
\& fun weird($name = return "nope") {
\&     print "Hello, $name!\en";
\&     return $name;
\& }
\&
\& weird("Larry");  # prints "Hello, Larry!" and returns "Larry"
\& weird();         # returns "nope" immediately; function body doesn\*(Aqt run
.Ve
.PP
Preceding parameters are in scope for default arguments:
.PP
.Vb 3
\& fun dynamic_default($x, $y = length $x) {
\&    return "$x/$y";
\& }
\&
\& dynamic_default("hello", 0)  # returns "hello/0"
\& dynamic_default("hello")     # returns "hello/5"
\& dynamic_default("abc")       # returns "abc/3"
.Ve
.PP
If you just want to make a parameter optional without giving it a special
value, write \f(CW\*(C`$param = undef\*(C'\fR. There is a special shortcut syntax for
this case: \f(CW\*(C`$param = undef\*(C'\fR can also be written \f(CW\*(C`$param =\*(C'\fR (with no following
expression).
.PP
.Vb 4
\& fun foo($x = undef, $y = undef, $z = undef) {
\&     # three arguments, all optional
\&     ...
\& }
\&
\& fun foo($x=, $y=, $z=) {
\&     # shorter syntax, same meaning
\&     ...
\& }
.Ve
.PP
Optional parameters must come at the end. It is not possible to have a required
parameter after an optional one.
.PP
\fISlurpy/rest parameters\fR
.IX Subsection "Slurpy/rest parameters"
.PP
The last parameter of a function or method can be an array. This lets you slurp
up any number of arguments the caller passes (0 or more).
.PP
.Vb 3
\& fun scale($factor, @values) {
\&     return map { $_ * $factor } @values;
\& }
\&
\& scale(10, 1 .. 4)  # returns (10, 20, 30, 40)
\& scale(10)          # returns ()
.Ve
.PP
You can also use a hash, but then the number of arguments has to be even.
.PP
\fINamed parameters\fR
.IX Subsection "Named parameters"
.PP
As soon as your functions take more than three arguments, it gets harder to
keep track of what argument means what:
.PP
.Vb 2
\& foo($handle, $w, $h * 2 + 15, 1, 24, \*(Aqicon\*(Aq);
\& # what do these arguments mean?
.Ve
.PP
\&\f(CW\*(C`Function::Parameters\*(C'\fR offers an alternative for these kinds of situations in
the form of named parameters. Unlike the parameters described previously, which
are identified by position, these parameters are identified by name:
.PP
.Vb 3
\& fun create_point(:$x, :$y, :$color) {
\&     ...
\& }
\&
\& # Case 1
\& create_point(
\&     x     => 50,
\&     y     => 50,
\&     color => 0xff_00_00,
\& );
.Ve
.PP
To create a named parameter, put a \f(CW\*(C`:\*(C'\fR (colon) in front of it in the parameter
list. When the function is called, the arguments have to be supplied in the
form of a hash initializer (a list of alternating keys/values). As with a hash,
the order of key/value pairs doesn't matter (except in the case of duplicate
keys, where the last occurrence wins):
.PP
.Vb 6
\& # Case 2
\& create_point(
\&     color => 0xff_00_00,
\&     x     => 50,
\&     y     => 50,
\& );
\&
\& # Case 3
\& create_point(
\&     x     => 200,
\&     color => 0x12_34_56,
\&     color => 0xff_00_00,
\&     x     => 50,
\&     y     => 50,
\& );
.Ve
.PP
Case 1, Case 2, and Case 3 all mean the same thing.
.PP
As with positional parameters, you can make named parameters optional by
supplying a default argument:
.PP
.Vb 3
\& fun create_point(:$x, :$y, :$color = 0x00_00_00) {
\&     ...
\& }
\&
\& create_point(x => 0, y => 64)  # color => 0x00_00_00 is implicit
.Ve
.PP
If you want to accept any key/value pairs, you can add a
rest parameter (hashes are particularly useful):
.PP
.Vb 3
\& fun accept_all_keys(:$name, :$age, %rest) {
\&     ...
\& }
\&
\& accept_all_keys(
\&     age     => 42,
\&     gender  => 2,
\&     name    => "Jamie",
\&     marbles => [],
\& );
\& # $name = "Jamie";
\& # $age = 42;
\& # %rest = (
\& #     gender  => 2,
\& #     marbles => [],
\& # );
.Ve
.PP
You can combine positional and named parameters but all positional parameters
have to come first:
.PP
.Vb 8
\& method output(
\&    $data,
\&    :$handle       = $self\->output_handle,
\&    :$separator    = $self\->separator,
\&    :$quote_fields = 0,
\& ) {
\&     ...
\& }
\&
\& $obj\->output(["greetings", "from", "space"]);
\& $obj\->output(
\&    ["a", "random", "example"],
\&    quote_fields => 1,
\&    separator    => ";",
\& );
.Ve
.PP
\fIUnnamed parameters\fR
.IX Subsection "Unnamed parameters"
.PP
If your function doesn't use a particular parameter at all, you can omit its
name and just write a sigil in the parameter list:
.PP
.Vb 3
\& register_callback(\*(Aqclick\*(Aq, fun ($target, $) {
\&     ...
\& });
.Ve
.PP
Here we're calling a hypothetical \f(CW\*(C`register_callback\*(C'\fR function that registers
our coderef to be called in response to a \f(CW\*(C`click\*(C'\fR event. It will pass two
arguments to the click handler, but the coderef only cares about the first one
(\f(CW$target\fR). The second parameter doesn't even get a name (just a sigil,
\&\f(CW\*(C`$\*(C'\fR). This marks it as unused.
.PP
This case typically occurs when your functions have to conform to an externally
imposed interface, e.g. because they're called by someone else. It can happen
with callbacks or methods that don't need all of the arguments they get.
.PP
You can use unnamed slurpy parameters to accept and
ignore all following arguments. In particular, \f(CW\*(C`fun foo(@)\*(C'\fR is a lot like
\&\f(CW\*(C`sub foo\*(C'\fR in that it accepts and ignores any number of arguments (apart from
leaving them in \f(CW@_\fR).
.PP
\fIType constraints\fR
.IX Subsection "Type constraints"
.PP
It is possible to automatically check the types of arguments passed to your
function. There are two ways to do this.
.IP "1." 4
.Vb 1
\& use Types::Standard qw(Str Int ArrayRef);
\&
\& fun foo(Str $label, ArrayRef[Int] $counts) {
\&     ...
\& }
.Ve
.Sp
In this variant you simply put the name of a type in front of a parameter. The
way this works is that \f(CW\*(C`Function::Parameters\*(C'\fR parses the type using very
simple rules:
.RS 4
.IP "\(bu" 4
A \fItype\fR is a sequence of one or more simple types, separated by \f(CW\*(C`|\*(C'\fR (pipe).
\&\f(CW\*(C`|\*(C'\fR is meant for union types (e.g. \f(CW\*(C`Str | ArrayRef[Int]\*(C'\fR would accept either
a string or reference to an array of integers).
.IP "\(bu" 4
A \fIsimple type\fR is an identifier, optionally followed by a list of one or more
types, separated by \f(CW\*(C`,\*(C'\fR (comma), enclosed in \f(CW\*(C`[\*(C'\fR \f(CW\*(C`]\*(C'\fR (square brackets).
.RE
.RS 4
.Sp
\&\f(CW\*(C`Function::Parameters\*(C'\fR then resolves simple types by looking for functions of
the same name in your current package. A type specification like
\&\f(CW\*(C`Str | ArrayRef[Int]\*(C'\fR ends up running the Perl code
\&\f(CW\*(C`Str() | ArrayRef([Int()])\*(C'\fR (at compile time, while the function definition is
being processed). In other words, \f(CW\*(C`Function::Parameters\*(C'\fR doesn't support any
types natively; it simply uses whatever is in scope.
.Sp
You don't have to define these functions yourself. You can also import them
from a type library such as \f(CW\*(C`Types::Standard\*(C'\fR or
\&\f(CW\*(C`MooseX::Types::Moose\*(C'\fR.
.Sp
The only requirement is that the returned value (here referred to as \f(CW$tc\fR,
for \*(L"type constraint\*(R") is an object that provides \f(CW\*(C`$tc\->check($value)\*(C'\fR
and \f(CW\*(C`$tc\->get_message($value)\*(C'\fR methods. \f(CW\*(C`check\*(C'\fR is called to determine
whether a particular value is valid; it should return a true or false value.
\&\f(CW\*(C`get_message\*(C'\fR is called on values that fail the \f(CW\*(C`check\*(C'\fR test; it should
return a string that describes the error.
.RE
.IP "2." 4
.Vb 5
\& my ($my_type, $some_other_type);
\& BEGIN {
\&     $my_type = Some::Constraint::Class\->new;
\&     $some_other_type = Some::Other::Class\->new;
\& }
\&
\& fun foo(($my_type) $label, ($some_other_type) $counts) {
\&     ...
\& }
.Ve
.Sp
In this variant you enclose an arbitrary Perl expression in \f(CW\*(C`(\*(C'\fR \f(CW\*(C`)\*(C'\fR
(parentheses) and put it in front of a parameter. This expression is evaluated
at compile time and must return a type constraint object as described above.
(If you use variables here, make sure they're defined at compile time.)
.PP
\fIMethod modifiers\fR
.IX Subsection "Method modifiers"
.PP
\&\f(CW\*(C`Function::Parameters\*(C'\fR has support for method modifiers as provided by
\&\f(CW\*(C`Moo\*(C'\fR or \f(CW\*(C`Moose\*(C'\fR. They're not exported by default, so you
have to say
.PP
.Vb 1
\& use Function::Parameters qw(:modifiers);
.Ve
.PP
to get them. This line gives you method modifiers \fIonly\fR; \f(CW\*(C`fun\*(C'\fR and \f(CW\*(C`method\*(C'\fR
are not defined. To get both the standard keywords and method modifiers, you
can either write two \f(CW\*(C`use\*(C'\fR lines:
.PP
.Vb 2
\& use Function::Parameters;
\& use Function::Parameters qw(:modifiers);
.Ve
.PP
or explicitly list the keywords you want:
.PP
.Vb 1
\& use Function::Parameters qw(fun method :modifiers);
.Ve
.PP
or add the \f(CW\*(C`:std\*(C'\fR import tag (which gives you the default import behavior):
.PP
.Vb 1
\& use Function::Parameters qw(:std :modifiers);
.Ve
.PP
This defines the following additional keywords: \f(CW\*(C`before\*(C'\fR, \f(CW\*(C`after\*(C'\fR, \f(CW\*(C`around\*(C'\fR,
\&\f(CW\*(C`augment\*(C'\fR, \f(CW\*(C`override\*(C'\fR. These work mostly like \f(CW\*(C`method\*(C'\fR, but they don't
install the function into your package themselves. Instead they invoke whatever
\&\f(CW\*(C`before\*(C'\fR, \f(CW\*(C`after\*(C'\fR, \f(CW\*(C`around\*(C'\fR, \f(CW\*(C`augment\*(C'\fR, or \f(CW\*(C`override\*(C'\fR function
(respectively) is in scope to do the job.
.PP
.Vb 3
\& before foo($x, $y, $z) {
\&     ...
\& }
.Ve
.PP
works like
.PP
.Vb 3
\& &before(\*(Aqfoo\*(Aq, method ($x, $y, $z) {
\&     ...
\& });
.Ve
.PP
\&\f(CW\*(C`after\*(C'\fR, \f(CW\*(C`augment\*(C'\fR, and \f(CW\*(C`override\*(C'\fR work the same way.
.PP
\&\f(CW\*(C`around\*(C'\fR is slightly different: Instead of shifting off the first element of
\&\f(CW@_\fR into \f(CW$self\fR (as \f(CW\*(C`method\*(C'\fR does), it shifts off \fItwo\fR values:
.PP
.Vb 3
\& around foo($x, $y, $z) {
\&     ...
\& }
.Ve
.PP
works like
.PP
.Vb 6
\& &around(\*(Aqfoo\*(Aq, sub :method {
\&     my $orig = shift;
\&     my $self = shift;
\&     my ($x, $y, $z) = @_;
\&     ...
\& });
.Ve
.PP
(except you also get the usual \f(CW\*(C`Function::Parameters\*(C'\fR features such as
checking the number of arguments, etc).
.PP
\&\f(CW$orig\fR and \f(CW$self\fR both count as invocants and you can override their names
like this:
.PP
.Vb 5
\& around foo($original, $object: $x, $y, $z) {
\&     # $original is a reference to the wrapped method;
\&     # $object is the object we\*(Aqre being called on
\&     ...
\& }
.Ve
.PP
If you use \f(CW\*(C`:\*(C'\fR to pick your own invocant names in the parameter list of
\&\f(CW\*(C`around\*(C'\fR, you must specify exactly two variables.
.PP
These modifiers also differ from \f(CW\*(C`fun\*(C'\fR and \f(CW\*(C`method\*(C'\fR (and \f(CW\*(C`sub\*(C'\fR) in that they
require a function name (there are no anonymous method modifiers) and they
take effect at runtime, not compile time. When you say \f(CW\*(C`fun foo() {}\*(C'\fR, the
\&\f(CW\*(C`foo\*(C'\fR function is defined right after the closing \f(CW\*(C`}\*(C'\fR of the function body is
parsed. But with e.g. \f(CW\*(C`before foo() {}\*(C'\fR, the declaration becomes a normal
function call (to the \f(CW\*(C`before\*(C'\fR function in the current package), which is
performed at runtime.
.PP
\fIPrototypes and attributes\fR
.IX Subsection "Prototypes and attributes"
.PP
You can specify attributes (see \*(L"Subroutine Attributes\*(R" in perlsub) for your
functions using the usual syntax:
.PP
.Vb 3
\& fun deref($x) :lvalue {
\&    ${$x}
\& }
\&
\& my $silly;
\& deref(\e$silly) = 42;
.Ve
.PP
To specify a prototype (see \*(L"Prototypes\*(R" in perlsub), use the \f(CW\*(C`prototype\*(C'\fR
attribute:
.PP
.Vb 3
\& fun mypush($aref, @values) :prototype(\e@@) {
\&     push @{$aref}, @values;
\& }
.Ve
.PP
\fIIntrospection\fR
.IX Subsection "Introspection"
.PP
The function \f(CW\*(C`Function::Parameters::info\*(C'\fR lets you introspect parameter lists
at runtime. It is not exported, so you have to call it by its full name.
.PP
It takes a reference to a function and returns either \f(CW\*(C`undef\*(C'\fR (if it knows
nothing about the function) or an object that describes the parameter list of
the given function. See
\&\f(CW\*(C`Function::Parameters::Info\*(C'\fR for details.
.SS "Customizing and extending"
.IX Subsection "Customizing and extending"
\fIWrapping \f(CI\*(C`Function::Parameters\*(C'\fI\fR
.IX Subsection "Wrapping Function::Parameters"
.PP
Due to its nature as a lexical pragma, importing from \f(CW\*(C`Function::Parameters\*(C'\fR
always affects the scope that is currently being compiled. If you want to write
a wrapper module that enables \f(CW\*(C`Function::Parameters\*(C'\fR automatically, just call
\&\f(CW\*(C`Function::Parameters\->import\*(C'\fR from your own \f(CW\*(C`import\*(C'\fR method (and
\&\f(CW\*(C`Function::Parameters\->unimport\*(C'\fR from your \f(CW\*(C`unimport\*(C'\fR, as required).
.PP
\fIGory details of importing\fR
.IX Subsection "Gory details of importing"
.PP
At the lowest layer \f(CW\*(C`use Function::Parameters ...\*(C'\fR takes a list of one or more
hash references. Each key is a keyword to be defined as specified by the
corresponding value, which must be another hash reference containing
configuration options.
.PP
.Vb 8
\& use Function::Parameters
\&     {
\&         keyword_1 => { ... },
\&         keyword_2 => { ... },
\&     },
\&     {
\&         keyword_3 => { ... },
\&     };
.Ve
.PP
If you don't specify a particular option, its default value is used. The
available configuration options are:
.ie n .IP """attributes""" 4
.el .IP "\f(CWattributes\fR" 4
.IX Item "attributes"
(string) The attributes that every function declared with this
keyword should have (in the form of source code, with a leading \f(CW\*(C`:\*(C'\fR).
.Sp
Default: nothing
.ie n .IP """check_argument_count""" 4
.el .IP "\f(CWcheck_argument_count\fR" 4
.IX Item "check_argument_count"
(boolean) Whether functions declared with this keyword should check how many
arguments they are called with. If false, omitting a required argument sets it
to \f(CW\*(C`undef\*(C'\fR and excess arguments are silently ignored. If true, an exception is
thrown if too few or too many arguments are passed.
.Sp
Default: \f(CW1\fR
.ie n .IP """check_argument_types""" 4
.el .IP "\f(CWcheck_argument_types\fR" 4
.IX Item "check_argument_types"
(boolean) Whether functions declared with this keyword should check the types
of the arguments they are called with. If false,
type constraints are parsed but silently ignored. If true,
an exception is thrown if an argument fails a type check.
.Sp
Default: \f(CW1\fR
.ie n .IP """default_arguments""" 4
.el .IP "\f(CWdefault_arguments\fR" 4
.IX Item "default_arguments"
(boolean) Whether functions declared with this keyword should allow default
arguments in their parameter list. If false,
default arguments are a compile-time error.
.Sp
Default: \f(CW1\fR
.ie n .IP """install_sub""" 4
.el .IP "\f(CWinstall_sub\fR" 4
.IX Item "install_sub"
(sub name or reference) If this is set, named functions declared with this
keyword are not entered into the symbol table directly. Instead the subroutine
specified here (by name or reference) is called with two arguments, the name of
the function being declared and a reference to its body.
.Sp
Default: nothing
.ie n .IP """invocant""" 4
.el .IP "\f(CWinvocant\fR" 4
.IX Item "invocant"
(boolean) Whether functions declared with this keyword should allow explicitly
specifying invocant(s) at the beginning of the parameter list (as in
\&\f(CW\*(C`($invocant: ...)\*(C'\fR or \f(CW\*(C`($invocant1, $invocant2, $invocant3: ...)\*(C'\fR).
.Sp
Default: 0
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
(string) There are three possible values for this option. \f(CW\*(Aqrequired\*(Aq\fR means
functions declared with this keyword must have a name. \f(CW\*(Aqprohibited\*(Aq\fR means
specifying a name is not allowed. \f(CW\*(Aqoptional\*(Aq\fR means this keyword can be used
for both named and anonymous functions.
.Sp
Default: \f(CW\*(Aqoptional\*(Aq\fR
.ie n .IP """named_parameters""" 4
.el .IP "\f(CWnamed_parameters\fR" 4
.IX Item "named_parameters"
(boolean) Whether functions declared with this keyword should allow named
parameters. If false, named parameters are a compile-time
error.
.Sp
Default: \f(CW1\fR
.ie n .IP """reify_type""" 4
.el .IP "\f(CWreify_type\fR" 4
.IX Item "reify_type"
(coderef or \f(CW\*(Aqauto\*(Aq\fR or \f(CW\*(Aqmoose\*(Aq\fR) The code reference used to resolve
type constraints in functions declared with this keyword.
It is called once for each type constraint that doesn't use the \f(CW\*(C`( EXPR )\*(C'\fR
syntax, with one argument, the text of the type in the parameter list (e.g.
\&\f(CW\*(AqArrayRef[Int]\*(Aq\fR). The package the function declaration is in is available
through \f(CW\*(C`caller\*(C'\fR.
.Sp
The only requirement is that the returned value (here referred to as \f(CW$tc\fR,
for \*(L"type constraint\*(R") is an object that provides \f(CW\*(C`$tc\->check($value)\*(C'\fR
and \f(CW\*(C`$tc\->get_message($value)\*(C'\fR methods. \f(CW\*(C`check\*(C'\fR is called to determine
whether a particular value is valid; it should return a true or false value.
\&\f(CW\*(C`get_message\*(C'\fR is called on values that fail the \f(CW\*(C`check\*(C'\fR test; it should
return a string that describes the error.
.Sp
Instead of a code reference you can also specify one of two strings.
.Sp
\&\f(CW\*(Aqauto\*(Aq\fR stands for a built-in type reifier that treats identifiers as
subroutine names, \f(CW\*(C`[\*(C'\fR \f(CW\*(C`]\*(C'\fR as an array reference, and \f(CW\*(C`|\*(C'\fR as bitwise or. In
other words, it parses and executes type constraints (mostly) as if they had
been Perl source code.
.Sp
\&\f(CW\*(Aqmoose\*(Aq\fR stands for a built-in type reifier that loads
\&\f(CW\*(C`Moose::Util::TypeConstraints\*(C'\fR and just
forwards to
\&\f(CW\*(C`find_or_create_isa_type_constraint\*(C'\fR.
.Sp
Default: \f(CW\*(Aqauto\*(Aq\fR
.ie n .IP """runtime""" 4
.el .IP "\f(CWruntime\fR" 4
.IX Item "runtime"
(boolean) Whether functions declared with this keyword should be installed into
the symbol table at runtime. If false, named functions are defined (or their
\&\f(CW\*(C`install_sub\*(C'\fR is invoked if specified) immediately after
their declaration is parsed (as with \f(CW\*(C`sub\*(C'\fR). If
true, function declarations become normal statements that only take effect at
runtime (similar to \f(CW\*(C`*foo = sub { ... };\*(C'\fR or
\&\f(CW\*(C`$install_sub\->(\*(Aqfoo\*(Aq, sub { ... });\*(C'\fR, respectively).
.Sp
Default: \f(CW0\fR
.ie n .IP """shift""" 4
.el .IP "\f(CWshift\fR" 4
.IX Item "shift"
(string or arrayref) In its simplest form, this is the name of a variable that
acts as the default invocant (a required leading argument that is removed from
\&\f(CW@_\fR) for all functions declared with this keyword (e.g.  \f(CW\*(Aq$self\*(Aq\fR for
methods). You can also set this to an array reference of strings, which lets
you specify multiple default invocants, or even to an array reference of array
references of the form \f(CW\*(C`[ $name, $type ]\*(C'\fR (where \f(CW$name\fR is the variable name
and \f(CW$type\fR is a type constraint object), which lets you
specify multiple default invocants with type constraints.
.Sp
If you define any default invocants here and also allow individual declarations
to override the default (with \f(CW\*(C`invocant => 1\*(C'\fR), the number of overridden
invocants must match the default. For example, \f(CW\*(C`method\*(C'\fR has a default invocant
of \f(CW$self\fR, so \f(CW\*(C`method foo($x, $y: $z)\*(C'\fR is invalid because it tries to define
two invocants.
.Sp
Default: \f(CW\*(C`[]\*(C'\fR (meaning no invocants)
.ie n .IP """strict""" 4
.el .IP "\f(CWstrict\fR" 4
.IX Item "strict"
(boolean) Whether functions declared with this keyword should do \*(L"strict\*(R"
checks on their arguments. Currently setting this simply sets
\&\f(CW\*(C`check_argument_count\*(C'\fR to the same value with no
other effects.
.Sp
Default: nothing
.ie n .IP """types""" 4
.el .IP "\f(CWtypes\fR" 4
.IX Item "types"
(boolean) Whether functions declared with this keyword should allow type
constraints in their parameter lists. If false, trying to use
type constraints is a compile-time error.
.Sp
Default: \f(CW1\fR
.PP
You can get the same effect as \f(CW\*(C`use Function::Parameters;\*(C'\fR by saying:
.PP
.Vb 11
\& use Function::Parameters {
\&     fun => {
\&         # \*(Aqfun\*(Aq uses default settings only
\&     },
\&     method => {
\&         attributes => \*(Aq:method\*(Aq,
\&         shift      => \*(Aq$self\*(Aq,
\&         invocant   => 1,
\&         # the rest is defaults
\&     },
\& };
.Ve
.PP
\fIConfiguration bundles\fR
.IX Subsection "Configuration bundles"
.PP
Because specifying all these configuration options from scratch each time is a
lot of writing, \f(CW\*(C`Function::Parameters\*(C'\fR offers configuration bundles in the
form of special strings. These strings can be used to replace a configuration
hash completely or as the value of the \f(CW\*(C`defaults\*(C'\fR pseudo-option within a
configuration hash. The latter lets you use the configuration bundle behind the
string to provide defaults and tweak them with your own settings.
.PP
The following bundles are available:
.ie n .IP """function_strict""" 4
.el .IP "\f(CWfunction_strict\fR" 4
.IX Item "function_strict"
Equivalent to \f(CW\*(C`{}\*(C'\fR, i.e. all defaults.
.ie n .IP """function_lax""" 4
.el .IP "\f(CWfunction_lax\fR" 4
.IX Item "function_lax"
Equivalent to:
.Sp
.Vb 4
\& {
\&     defaults => \*(Aqfunction_strict\*(Aq,
\&     strict   => 0,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`function_strict\*(C'\fR but with
\&\f(CW\*(C`strict\*(C'\fR checks turned off.
.ie n .IP """function""" 4
.el .IP "\f(CWfunction\fR" 4
.IX Item "function"
Equivalent to \f(CW\*(C`function_strict\*(C'\fR. This is what the default \f(CW\*(C`fun\*(C'\fR keyword
actually uses. (In version 1 of this module, \f(CW\*(C`function\*(C'\fR was equivalent to
\&\f(CW\*(C`function_lax\*(C'\fR.)
.ie n .IP """method_strict""" 4
.el .IP "\f(CWmethod_strict\fR" 4
.IX Item "method_strict"
Equivalent to:
.Sp
.Vb 6
\& {
\&     defaults   => \*(Aqfunction_strict\*(Aq,
\&     attributes => \*(Aq:method\*(Aq,
\&     shift      => \*(Aq$self\*(Aq,
\&     invocant   => 1,
\& }
.Ve
.ie n .IP """method_lax""" 4
.el .IP "\f(CWmethod_lax\fR" 4
.IX Item "method_lax"
Equivalent to:
.Sp
.Vb 4
\& {
\&     defaults => \*(Aqmethod_strict\*(Aq,
\&     strict   => 0,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method_strict\*(C'\fR but with
\&\f(CW\*(C`strict\*(C'\fR checks turned off.
.ie n .IP """method""" 4
.el .IP "\f(CWmethod\fR" 4
.IX Item "method"
Equivalent to \f(CW\*(C`method_strict\*(C'\fR. This is what the default \f(CW\*(C`method\*(C'\fR keyword
actually uses. (In version 1 of this module, \f(CW\*(C`method\*(C'\fR was equivalent to
\&\f(CW\*(C`method_lax\*(C'\fR.)
.ie n .IP """classmethod_strict""" 4
.el .IP "\f(CWclassmethod_strict\fR" 4
.IX Item "classmethod_strict"
Equivalent to:
.Sp
.Vb 4
\& {
\&     defaults => \*(Aqmethod_strict\*(Aq,
\&     shift    => \*(Aq$class\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method_strict\*(C'\fR but the implicit first
parameter is called \f(CW$class\fR, not \f(CW$self\fR.
.ie n .IP """classmethod_lax""" 4
.el .IP "\f(CWclassmethod_lax\fR" 4
.IX Item "classmethod_lax"
Equivalent to:
.Sp
.Vb 4
\& {
\&     defaults => \*(Aqclassmethod_strict\*(Aq,
\&     strict   => 0,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`classmethod_strict\*(C'\fR but with
\&\f(CW\*(C`strict\*(C'\fR checks turned off.
.ie n .IP """classmethod""" 4
.el .IP "\f(CWclassmethod\fR" 4
.IX Item "classmethod"
Equivalent to \f(CW\*(C`classmethod_strict\*(C'\fR. This is currently not used anywhere within
\&\f(CW\*(C`Function::Parameters\*(C'\fR.
.ie n .IP """around""" 4
.el .IP "\f(CWaround\fR" 4
.IX Item "around"
Equivalent to:
.Sp
.Vb 7
\& {
\&     defaults    => \*(Aqmethod\*(Aq,
\&     install_sub => \*(Aqaround\*(Aq,
\&     shift       => [\*(Aq$orig\*(Aq, \*(Aq$self\*(Aq],
\&     runtime     => 1,
\&     name        => \*(Aqrequired\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method\*(C'\fR but with a custom installer
(\f(CW\*(Aqaround\*(Aq\fR), two implicit first parameters, only taking effect at
runtime, and a method name is required.
.ie n .IP """before""" 4
.el .IP "\f(CWbefore\fR" 4
.IX Item "before"
Equivalent to:
.Sp
.Vb 6
\& {
\&     defaults    => \*(Aqmethod\*(Aq,
\&     install_sub => \*(Aqbefore\*(Aq,
\&     runtime     => 1,
\&     name        => \*(Aqrequired\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method\*(C'\fR but with a custom installer
(\f(CW\*(Aqbefore\*(Aq\fR), only taking effect at runtime, and a method name is required.
.ie n .IP """after""" 4
.el .IP "\f(CWafter\fR" 4
.IX Item "after"
Equivalent to:
.Sp
.Vb 6
\& {
\&     defaults    => \*(Aqmethod\*(Aq,
\&     install_sub => \*(Aqafter\*(Aq,
\&     runtime     => 1,
\&     name        => \*(Aqrequired\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method\*(C'\fR but with a custom installer
(\f(CW\*(Aqafter\*(Aq\fR), only taking effect at runtime, and a method name is required.
.ie n .IP """augment""" 4
.el .IP "\f(CWaugment\fR" 4
.IX Item "augment"
Equivalent to:
.Sp
.Vb 6
\& {
\&     defaults    => \*(Aqmethod\*(Aq,
\&     install_sub => \*(Aqaugment\*(Aq,
\&     runtime     => 1,
\&     name        => \*(Aqrequired\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method\*(C'\fR but with a custom installer
(\f(CW\*(Aqaugment\*(Aq\fR), only taking effect at runtime, and a method name is required.
.ie n .IP """override""" 4
.el .IP "\f(CWoverride\fR" 4
.IX Item "override"
Equivalent to:
.Sp
.Vb 6
\& {
\&     defaults    => \*(Aqmethod\*(Aq,
\&     install_sub => \*(Aqoverride\*(Aq,
\&     runtime     => 1,
\&     name        => \*(Aqrequired\*(Aq,
\& }
.Ve
.Sp
i.e. just like \f(CW\*(C`method\*(C'\fR but with a custom installer
(\f(CW\*(Aqoverride\*(Aq\fR), only taking effect at runtime, and a method name is required.
.PP
You can get the same effect as \f(CW\*(C`use Function::Parameters;\*(C'\fR by saying:
.PP
.Vb 4
\& use Function::Parameters {
\&     fun    => { defaults => \*(Aqfunction\*(Aq },
\&     method => { defaults => \*(Aqmethod\*(Aq },
\& };
.Ve
.PP
or:
.PP
.Vb 4
\& use Function::Parameters {
\&     fun    => \*(Aqfunction\*(Aq,
\&     method => \*(Aqmethod\*(Aq,
\& };
.Ve
.PP
\fIImport tags\fR
.IX Subsection "Import tags"
.PP
In addition to hash references you can also use special strings in your import
list. The following import tags are available:
.ie n .IP "\*(Aqfun\*(Aq" 4
.el .IP "\f(CW\*(Aqfun\*(Aq\fR" 4
.IX Item "fun"
Equivalent to \f(CW\*(C`{ fun => \*(Aqfunction\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqmethod\*(Aq" 4
.el .IP "\f(CW\*(Aqmethod\*(Aq\fR" 4
.IX Item "method"
Equivalent to \f(CW\*(C`{ method => \*(Aqmethod\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqclassmethod\*(Aq" 4
.el .IP "\f(CW\*(Aqclassmethod\*(Aq\fR" 4
.IX Item "classmethod"
Equivalent to \f(CW\*(C`{ classmethod => \*(Aqclassmethod\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqbefore\*(Aq" 4
.el .IP "\f(CW\*(Aqbefore\*(Aq\fR" 4
.IX Item "before"
Equivalent to \f(CW\*(C`{ before => \*(Aqbefore\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqafter\*(Aq" 4
.el .IP "\f(CW\*(Aqafter\*(Aq\fR" 4
.IX Item "after"
Equivalent to \f(CW\*(C`{ after => \*(Aqafter\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqaround\*(Aq" 4
.el .IP "\f(CW\*(Aqaround\*(Aq\fR" 4
.IX Item "around"
Equivalent to \f(CW\*(C`{ around => \*(Aqaround\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqaugment\*(Aq" 4
.el .IP "\f(CW\*(Aqaugment\*(Aq\fR" 4
.IX Item "augment"
Equivalent to \f(CW\*(C`{ augment => \*(Aqaugment\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aqoverride\*(Aq" 4
.el .IP "\f(CW\*(Aqoverride\*(Aq\fR" 4
.IX Item "override"
Equivalent to \f(CW\*(C`{ override => \*(Aqoverride\*(Aq }\*(C'\fR.
.ie n .IP "\*(Aq:strict\*(Aq" 4
.el .IP "\f(CW\*(Aq:strict\*(Aq\fR" 4
.IX Item ":strict"
Equivalent to \f(CW\*(C`{ fun => \*(Aqfunction_strict\*(Aq, method => \*(Aqmethod_strict\*(Aq }\*(C'\fR
but that's just the default behavior anyway.
.ie n .IP "\*(Aq:lax\*(Aq" 4
.el .IP "\f(CW\*(Aq:lax\*(Aq\fR" 4
.IX Item ":lax"
Equivalent to \f(CW\*(C`{ fun => \*(Aqfunction_lax\*(Aq, method => \*(Aqmethod_lax\*(Aq }\*(C'\fR, i.e. it
provides \f(CW\*(C`fun\*(C'\fR and \f(CW\*(C`method\*(C'\fR keywords that define functions that don't check
their arguments.
.ie n .IP "\*(Aq:std\*(Aq" 4
.el .IP "\f(CW\*(Aq:std\*(Aq\fR" 4
.IX Item ":std"
Equivalent to \f(CW\*(Aqfun\*(Aq, \*(Aqmethod\*(Aq\fR. This is what's used by default:
.Sp
.Vb 1
\& use Function::Parameters;
.Ve
.Sp
is the same as:
.Sp
.Vb 1
\& use Function::Parameters qw(:std);
.Ve
.ie n .IP "\*(Aq:modifiers\*(Aq" 4
.el .IP "\f(CW\*(Aq:modifiers\*(Aq\fR" 4
.IX Item ":modifiers"
Equivalent to \f(CW\*(Aqbefore\*(Aq, \*(Aqafter\*(Aq, \*(Aqaround\*(Aq, \*(Aqaugment\*(Aq, \*(Aqoverride\*(Aq\fR.
.PP
For example, when you say
.PP
.Vb 1
\& use Function::Parameters qw(:modifiers);
.Ve
.PP
\&\f(CW\*(C`:modifiers\*(C'\fR is an import tag that expands to
.PP
.Vb 1
\& use Function::Parameters qw(before after around augment override);
.Ve
.PP
Each of those is another import tag. Stepping through the first one:
.PP
.Vb 1
\& use Function::Parameters qw(before);
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\& use Function::Parameters { before => \*(Aqbefore\*(Aq };
.Ve
.PP
This says to define the keyword \f(CW\*(C`before\*(C'\fR according to the
configuration bundle \f(CW\*(C`before\*(C'\fR:
.PP
.Vb 8
\& use Function::Parameters {
\&     before => {
\&         defaults    => \*(Aqmethod\*(Aq,
\&         install_sub => \*(Aqbefore\*(Aq,
\&         runtime     => 1,
\&         name        => \*(Aqrequired\*(Aq,
\&     },
\& };
.Ve
.PP
The \f(CW\*(C`defaults => \*(Aqmethod\*(Aq\*(C'\fR part pulls in the
contents of the \f(CW\*(Aqmethod\*(Aq\fR configuration bundle (which is the
same as \f(CW\*(Aqmethod_strict\*(Aq\fR):
.PP
.Vb 11
\& use Function::Parameters {
\&     before => {
\&         defaults    => \*(Aqfunction_strict\*(Aq,
\&         attributes  => \*(Aq:method\*(Aq,
\&         shift       => \*(Aq$self\*(Aq,
\&         invocant    => 1,
\&         install_sub => \*(Aqbefore\*(Aq,
\&         runtime     => 1,
\&         name        => \*(Aqrequired\*(Aq,
\&     },
\& };
.Ve
.PP
This in turn uses the
\&\f(CW\*(Aqfunction_strict\*(Aq\fR configuration bundle (which is
empty because it consists of default values only):
.PP
.Vb 10
\& use Function::Parameters {
\&     before => {
\&         attributes  => \*(Aq:method\*(Aq,
\&         shift       => \*(Aq$self\*(Aq,
\&         invocant    => 1,
\&         install_sub => \*(Aqbefore\*(Aq,
\&         runtime     => 1,
\&         name        => \*(Aqrequired\*(Aq,
\&     },
\& };
.Ve
.PP
But if we wanted to be completely explicit, we could write this as:
.PP
.Vb 8
\& use Function::Parameters {
\&     before => {
\&         check_argument_count => 1,
\&         check_argument_types => 1,
\&         default_arguments    => 1,
\&         named_parameters     => 1,
\&         reify_type           => \*(Aqauto\*(Aq,
\&         types                => 1,
\&
\&         attributes  => \*(Aq:method\*(Aq,
\&         shift       => \*(Aq$self\*(Aq,
\&         invocant    => 1,
\&         install_sub => \*(Aqbefore\*(Aq,
\&         runtime     => 1,
\&         name        => \*(Aqrequired\*(Aq,
\&     },
\& };
.Ve
.ie n .SS "Incompatibilites with version 1 of ""Function::Parameters"""
.el .SS "Incompatibilites with version 1 of \f(CWFunction::Parameters\fP"
.IX Subsection "Incompatibilites with version 1 of Function::Parameters"
.IP "\(bu" 4
Version 1 defaults to lax mode (no argument checks). To get the same behavior
on both version 1 and version 2, explicitly write either
\&\f(CW\*(C`use Function::Parameters qw(:strict);\*(C'\fR (the new default) or
\&\f(CW\*(C`use Function::Parameters qw(:lax);\*(C'\fR (the old default). (Or write
\&\f(CW\*(C`use Function::Parameters 2;\*(C'\fR to trigger an error if an older version of
\&\f(CW\*(C`Function::Parameters\*(C'\fR is loaded.)
.IP "\(bu" 4
Parameter lists used to be optional. The syntax \f(CW\*(C`fun foo { ... }\*(C'\fR would accept
any number of arguments. This syntax has been removed; you now have to write
\&\f(CW\*(C`fun foo(@) { ... }\*(C'\fR to accept (and ignore) all arguments. On the other hand,
if you meant for the function to take no arguments, write \f(CW\*(C`fun foo() { ... }\*(C'\fR.
.IP "\(bu" 4
There used to be a shorthand syntax for prototypes: Using \f(CW\*(C`:(...)\*(C'\fR (i.e. an
attribute with an empty name) as the first attribute was equivalent to
\&\f(CW\*(C`:prototype(...)\*(C'\fR. This syntax has been removed.
.IP "\(bu" 4
The default type reifier used to be hardcoded to use \f(CW\*(C`Moose\*(C'\fR (as in
\&\f(CW\*(C`reify_type => \*(Aqmoose\*(Aq\*(C'\fR). This has been changed to use whatever type
functions are in scope (\f(CW\*(C`reify_type => \*(Aqauto\*(Aq\*(C'\fR).
.IP "\(bu" 4
Type reifiers used to see the wrong package in
\&\f(CW\*(C`caller\*(C'\fR. As a workaround the correct calling package
used to be passed as a second argument. This problem has been fixed and the
second argument has been removed. (Technically this is a core perl bug
(\s-1RT\s0 #129239 <https://rt.perl.org/Public/Bug/Display.html?id=129239>) that
wasn't so much fixed as worked around in \f(CW\*(C`Function::Parameters\*(C'\fR.)
.Sp
If you want your type reifier to be compatible with both versions, you can do
this:
.Sp
.Vb 5
\& sub my_reifier {
\&     my ($type, $package) = @_;
\&     $package //= caller;
\&     ...
\& }
.Ve
.Sp
Or using \f(CW\*(C`Function::Parameters\*(C'\fR itself:
.Sp
.Vb 3
\& fun my_reifier($type, $package = caller) {
\&     ...
\& }
.Ve
.SH "SUPPORT AND DOCUMENTATION"
.IX Header "SUPPORT AND DOCUMENTATION"
After installing, you can find documentation for this module with the
\&\f(CW\*(C`perldoc\*(C'\fR command.
.PP
.Vb 1
\&    perldoc Function::Parameters
.Ve
.PP
You can also look for information at
<https://metacpan.org/pod/Function::Parameters>.
.PP
To see a list of open bugs, visit
<https://rt.cpan.org/Public/Dist/Display.html?Name=Function\-Parameters>.
.PP
To report a new bug, send an email to
\&\f(CW\*(C`bug\-Function\-Parameters [at] rt.cpan.org\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Function::Parameters::Info,
Moose,
Moo,
Type::Tiny
.SH "AUTHOR"
.IX Header "AUTHOR"
Lukas Mai, \f(CW\*(C`<l.mai at web.de>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (C) 2010\-2014, 2017 Lukas Mai.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See <http://dev.perl.org/licenses/> for more information.
