.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Validator::Custom 3"
.TH Validator::Custom 3 "2017-01-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Validator::Custom \- HTML form validation. Simple and good flexibility
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Validator::Custom is a validator for \s-1HTML\s0 form.
.IP "\(bu" 4
1. \fBChecking functions:\fR \f(CW\*(C`ascii_graphic\*(C'\fR, \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`number\*(C'\fR, \f(CW\*(C`in\*(C'\fR. You can also add your checking function.
.IP "\(bu" 4
2. \fBFiltering functions:\fR \f(CW\*(C`trim\*(C'\fR, \f(CW\*(C`remove_blank\*(C'\fR. You can also add your filtering function.
.IP "\(bu" 4
3. \fBValidation object:\fR Save each validation result and check if all data is valid.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Validator::Custom;
\&  my $vc = Validator::Custom\->new;
\&  
\&  # Input data
\&  my $id = 1;
\&  my $name = \*(AqKen Suzuki\*(Aq;
\&  my $price = \*(Aq 19.23 \*(Aq;
\&  my $favorite = [\*(Aq001\*(Aq, \*(Aq002\*(Aq];
\&  
\&  # Create validation object
\&  my $validation = $vc\->validation;
\&  
\&  # Check if id is integer
\&  if (!$vc\->check($id, \*(Aqint\*(Aq)) {
\&    # Add failed message
\&    $validation\->add_failed(id => \*(Aqid must be integer\*(Aq);
\&  }
\&  
\&  # Check if name has length
\&  if (!(length $name)) {
\&    $validation\->add_failed(name => \*(Aqname must have length\*(Aq);
\&  }
\&  # Check if name\*(Aqs length is less than 30
\&  elsif (!(length $name < 30)) {
\&    $validation\->add_failed(name => \*(Aqname is too long\*(Aq);
\&  }
\&  
\&  # Filter price to remove left\-rigth space
\&  $price = $vc\->filter($price, \*(Aqtrim\*(Aq);
\&
\&  # Check price is number and the digits of the decimal part is two or less than two
\&  if (!$vc\->check($price, \*(Aqnumber\*(Aq, {decimal_part_max => 2})) {
\&    # Set default value if validation fail
\&    $price = 20.25;
\&  }
\&  
\&  # Filter each value of favorite using "trim" filtering function
\&  $favorite = $vc\->filter_each($favorite, \*(Aqtrim\*(Aq);
\&  
\&  # Check if favorite has at least one values
\&  if (@$favorite == 0) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite must be selected more than one\*(Aq);
\&  }
\&  # Check if favorite is one of the specified values
\&  elsif (!($vc\->check_each($favorite, \*(Aqin\*(Aq,  [\*(Aq001\*(Aq, \*(Aq002\*(Aq, \*(Aq003\*(Aq]))) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite is invalid\*(Aq);
\&  }
\&  
\&  # Check if validation result is valid
\&  if ($validation\->is_valid) {
\&    # ...
\&  }
\&  else {
\&    
\&    # Check what parameter fail
\&    unless ($validation\->is_valid(\*(Aqname\*(Aq)) {
\&      # ...
\&    }
\&    
\&    # Get all failed parameter names
\&    my $failed = $validation\->failed;
\&
\&    # Get a failed parameter message
\&    my $name_message = $validation\->message(\*(Aqname\*(Aq);
\&    
\&    # Get all failed parameter messages
\&    my $messages = $validation\->messages;
\&    
\&    # Get all failed parameter names and the messages as hash reference
\&    my $messages_h = $validation\->messages_to_hash;
\&  }
.Ve
.SH "1. Basic usage"
.IX Header "1. Basic usage"
.SS "1. Create a new Validator::Custom object"
.IX Subsection "1. Create a new Validator::Custom object"
At first, create Validator::Custom object using \f(CW\*(C`new\*(C'\fR method.
.PP
.Vb 2
\&  use Validator::Custom;
\&  my $vc = Validator::Custom\->new;
.Ve
.SS "2. Prepare input data for validation"
.IX Subsection "2. Prepare input data for validation"
Next, prepare input data.
.PP
.Vb 4
\&  my $id = 1;
\&  my $name = \*(AqKen Suzuki\*(Aq;
\&  my $price = \*(Aq 19.23 \*(Aq;
\&  my $favorite = [\*(Aq001\*(Aq, \*(Aq002\*(Aq];
.Ve
.SS "3. Create a new validation object"
.IX Subsection "3. Create a new validation object"
Next, create a new validation object using \f(CW\*(C`validation\*(C'\fR method.
.PP
.Vb 1
\&  my $validation = $vc\->validation;
.Ve
.PP
This is Validator::Custom::Validation object
to store failed parameter names and the messages.
.SS "4. Validate input data"
.IX Subsection "4. Validate input data"
.Vb 5
\&  # Check if id is integer
\&  if (!$vc\->check($id, \*(Aqint\*(Aq)) {
\&    # Add failed message
\&    $validation\->add_failed(id => \*(Aqid must be integer\*(Aq);
\&  }
.Ve
.PP
You can use \f(CW\*(C`int\*(C'\fR checking function to check the value is integer.
\&\f(CW\*(C`int\*(C'\fR checking function is default one.
Any checking function is available through \f(CW\*(C`check\*(C'\fR method.
.PP
When the check doesn't succeed, you can add the failed parameter name and the message
using \f(CW\*(C`add_failed\*(C'\fR method of Validator::Custom::Validation class.
.PP
.Vb 2
\&  # Filter price to remove left\-rigth space
\&  $price = $vc\->filter($price, \*(Aqtrim\*(Aq);
.Ve
.PP
You can use \f(CW\*(C`trim\*(C'\fR filtering function to trim left-rigth spaces.
.PP
.Vb 2
\&  # Filter each value of favorite using "trim" filtering function
\&  $favorite = $vc\->filter_each($favorite, \*(Aqtrim\*(Aq);
.Ve
.PP
You can use \f(CW\*(C`filter_each\*(C'\fR method to filter each value of favorite.
.PP
.Vb 8
\&  # Check if favorite has at least one values
\&  if (@$favorite == 0) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite must be selected more than one\*(Aq);
\&  }
\&  # Check if favorite is one of the specified values
\&  elsif (!($vc\->check_each($favorite, \*(Aqin\*(Aq,  [\*(Aq001\*(Aq, \*(Aq002\*(Aq, \*(Aq003\*(Aq]))) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite is invalid\*(Aq);
\&  }
.Ve
.PP
You can use \f(CW\*(C`check_each\*(C'\fR method to check each value of favorite.
.PP
If you see default checks and filter,
see \*(L"\s-1CHECKING FUNCTIONS\*(R"\s0 in Validator::Custom and \*(L"\s-1FILTERING FUNCTIONS\*(R"\s0 in Validator::Custom.
.SH "2. Manipulate validation object"
.IX Header "2. Manipulate validation object"
If you check all input data is valid, use \f(CW\*(C`is_valid\*(C'\fR method.
.PP
.Vb 7
\&  # Check if validation result is valid
\&  if ($validation\->is_valid) {
\&    # Success
\&  }
\&  else {
\&    # Failed
\&  }
.Ve
.PP
If you can check a input data is valid, use \f(CW\*(C`is_valid\*(C'\fR method with parameter name.
.PP
.Vb 4
\&  # Check what parameter fail
\&  unless ($validation\->is_valid(\*(Aqname\*(Aq)) {
\&    # ...
\&  }
.Ve
.PP
You can get all failed parameter names using \f(CW\*(C`failed\*(C'\fR method.
.PP
.Vb 2
\&  # Get all failed parameter names
\&  my $failed = $validation\->failed;
.Ve
.PP
You can get a failed parameter message using \f(CW\*(C`message\*(C'\fR method.
.PP
.Vb 2
\&  # Get a failed parameter message
\&  my $name_message = $validation\->message(\*(Aqname\*(Aq);
.Ve
.PP
You can get all failed parameter messages using \f(CW\*(C`messages\*(C'\fR method.
.PP
.Vb 2
\&  # Get all failed parameter messages
\&  my $messages = $validation\->messages;
.Ve
.PP
You can get all failed names and the messages as hash reference using \f(CW\*(C`messages_to_hash\*(C'\fR method.
.PP
.Vb 2
\&  # Get all failed parameter names and the messages as hash reference
\&  my $messages_h = $validation\->messages_to_hash;
.Ve
.PP
See also Validator::Custom::Validation.
.SH "3. Advanced tequnique"
.IX Header "3. Advanced tequnique"
.SS "1. Add checking function"
.IX Subsection "1. Add checking function"
You can add your own checking function using \f(CW\*(C`add_check\*(C'\fR method if you need.
.PP
.Vb 3
\&  $vc\->add_check(
\&    telephone => sub {
\&      my ($vc, $value, $arg) = @_;
\&      
\&      my $is_valid;
\&      if ($value =~ /^[\ed\-]+$/) {
\&        $is_valid = 1;
\&      }
\&      return $is_valid;
\&    }
\&  );
.Ve
.PP
Checking function receives three arguments,
First argument is Validator::Custom object,
Second argument is the value for checking,
Third argument is the argument of checking function.
.PP
Your Checking function must return true or false value.
.SS "2. Add filtering function"
.IX Subsection "2. Add filtering function"
You can add your filtering function by \f(CW\*(C`add_filter\*(C'\fR method if you need.
.PP
.Vb 3
\&  $vc\->add_filter(
\&    to_upper_case => sub {
\&      my ($vc, $value, $arg) = @_;
\&      
\&      my $new_$value = uc $value;
\&                  
\&      return $new_value;
\&    }
\&  );
.Ve
.PP
Filtering function receives three arguments,
First argument is Validator::Custom object,
Second argument is the value for filtering.
Third argument is the argument of filtering function.
.PP
Your filtering function must return the result of filtering.
.SH "Checking functions"
.IX Header "Checking functions"
Validator::Custom have the following default checking functions.
You can call any checking function by \f(CW\*(C`check\*(C'\fR method.
.SS "int"
.IX Subsection "int"
Check if the value is integer value.
.PP
.Vb 2
\&  my $value = 19;
\&  my $is_valid = $vc\->check($value, \*(Aqint\*(Aq);
.Ve
.PP
Example of valid values:
.PP
.Vb 2
\&  "\-10"
\&  "234"
.Ve
.PP
Example of invalid values:
.PP
.Vb 2
\&  "10.11"
\&  "abc"
.Ve
.PP
If you also need to check the range of value, you can write the following way.
.PP
.Vb 1
\&  my $is_valid =  $vc\->check($value, \*(Aqint\*(Aq) && $value > 0;
.Ve
.SS "number"
.IX Subsection "number"
Check if the value is number.
Number means integer or decimal.
.PP
.Vb 1
\&  my $is_valid = $vc\->check($value, \*(Aqnumber\*(Aq);
.Ve
.PP
Example of valid values:
.PP
.Vb 6
\&  \*(Aq1\*(Aq
\&  \*(Aq123\*(Aq
\&  \*(Aq123.456\*(Aq
\&  \*(Aq\-1\*(Aq
\&  \*(Aq\-100\*(Aq
\&  \*(Aq\-100.789\*(Aq
.Ve
.PP
Example of invalid values:
.PP
.Vb 3
\&  \*(Aqa\*(Aq;
\&  \*(Aq1.a\*(Aq;
\&  \*(Aqa.1\*(Aq;
.Ve
.PP
You can also specify decimal part max digits using \f(CW\*(C`decimal_part_max\*(C'\fR option.
.PP
.Vb 1
\&  my $is_valid = $vc\->check($value, \*(Aqnumber\*(Aq, {decimal_part_max => 3});
.Ve
.PP
Example of valid values:
.PP
.Vb 3
\&  \*(Aq123\*(Aq
\&  \*(Aq123.456\*(Aq
\&  \*(Aq\-100.789\*(Aq
.Ve
.PP
Example of invalid values:
.PP
.Vb 2
\&  \*(Aq123.4567\*(Aq
\&  \*(Aq\-100.7891\*(Aq
.Ve
.SS "ascii_graphic"
.IX Subsection "ascii_graphic"
Check if the value is Ascii graphic characters(hex 21\-7e).
Generally, \f(CW\*(C`ascii_graphic\*(C'\fR function is used to
check the characters of a password.
.PP
.Vb 1
\&  my $is_valid = $vc\->check($value, \*(Aqascii\*(Aq);
.Ve
.PP
Example of valid values:
.PP
.Vb 1
\&  "Ken!@\-"
.Ve
.PP
Example of invalid values:
.PP
.Vb 2
\&  "aa aa"
\&  "\etaaa"
.Ve
.SS "in"
.IX Subsection "in"
Check if the value is one of the given values.
.PP
.Vb 2
\&  my $value = \*(Aq001\*(Aq;
\&  my $is_valid = $vc\->check($value, \*(Aqin\*(Aq, [\*(Aq001\*(Aq, \*(Aq002\*(Aq, \*(Aq003\*(Aq]);
.Ve
.PP
Example of valid values:
.PP
.Vb 3
\&  \*(Aq001\*(Aq
\&  \*(Aq002\*(Aq
\&  \*(Aq003\*(Aq
.Ve
.PP
Example of invalid values:
.PP
.Vb 2
\&  \*(Aq004\*(Aq
\&  \*(Aq005\*(Aq
.Ve
.SH "Filtering functions"
.IX Header "Filtering functions"
Validator::Custom have the following default filtering functions.
You can call any filtering function using \f(CW\*(C`filter\*(C'\fR method.
.SS "trim"
.IX Subsection "trim"
Trim leading and trailing white space.
Note that trim function remove unicode space character, not only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR.
.PP
.Vb 1
\&  my $new_value = $vc\->filter($value, \*(Aqtrim\*(Aq);
.Ve
.PP
Filtering example:
.PP
.Vb 2
\&  Input : \*(Aq  ã€€Ken  \*(Aq
\&  Output: \*(AqKen\*(Aq
.Ve
.SS "remove_blank"
.IX Subsection "remove_blank"
Remove blank character and undefined value from array reference.
.PP
.Vb 1
\&  my $new_values = $vc\->filter($values, \*(Aqremove_blank\*(Aq);
.Ve
.PP
Filtering example:
.PP
.Vb 2
\&  Input : [1, 2, \*(Aq\*(Aq, undef, 4]
\&  Output: [1, 2, 4]
.Ve
.SH "Methods"
.IX Header "Methods"
Validator::Custom inherits all methods from Object::Simple
and implements the following new ones.
.SS "new"
.IX Subsection "new"
Create a new Validator::Custom object.
.PP
.Vb 1
\&  my $vc = Validator::Custom\->new;
.Ve
.SS "add_check"
.IX Subsection "add_check"
Add a checking function.
.PP
.Vb 1
\&  $vc\->add_check(int => sub { ... });
.Ve
.PP
Example:
.PP
.Vb 3
\&  $vc\->add_check(
\&    int => sub {
\&      my ($vc, $value, $arg) = @_;
\&      
\&      my $is_valid = $value =~ /^\e\-?[\ed]+$/;
\&      
\&      return $is_valid;
\&    }
\&  );
.Ve
.PP
Checking function receives three arguments,
First argument is Validator::Custom object,
Second argument is the value for checking,
Third argument is the argument of checking function.
.PP
Your Checking function must return true or false value.
.SS "add_filter"
.IX Subsection "add_filter"
Add a filtering function.
.PP
.Vb 1
\&  $vc\->add_filter(trim => sub { ... });
.Ve
.PP
Example:
.PP
.Vb 3
\&  $vc\->add_filter(
\&    trim => sub {
\&      my ($vc, $value, $arg) = @_;
\&      
\&      $value =~ s/^\es+//;
\&      $value =~ s/\es+$//;
\&      
\&      return $value;
\&    }
\&  );
.Ve
.SS "check"
.IX Subsection "check"
Execute a checking function.
.PP
.Vb 2
\&  my $is_valid = $vc\->check($value, \*(Aqint\*(Aq);
\&  my $is_valid = $vc\->check($value, \*(Aqint\*(Aq, $arg);
.Ve
.PP
First argument is the value for checking.
Second argument is the name of the checking funcion.
Third argument is the argument of the checking function.
.SS "check_each"
.IX Subsection "check_each"
Execute a checking function to all elements of array reference.
If more than one element is invalid, \f(CW\*(C`check_each\*(C'\fR method return false.
.PP
.Vb 2
\&  my $is_valid = $vc\->check_each($values, \*(Aqint\*(Aq);
\&  my $is_valid = $vc\->check_each($values, \*(Aqint\*(Aq, $arg);
.Ve
.PP
First argument is the values for checking, which must be array reference.
Second argument is the name of the checking funcion.
Third argument is the argument of the checking function.
.SS "filter"
.IX Subsection "filter"
Execute a filtering function.
.PP
.Vb 2
\&  my $new_value = $vc\->filter($value, \*(Aqtrim\*(Aq);
\&  my $new_value = $vc\->filter($value, \*(Aqtrim\*(Aq, $arg);
.Ve
.PP
First argument is the value for filtering.
Second argument is the name of the filtering funcion.
Third argument is the argument of the filtering function.
.SS "filter_each"
.IX Subsection "filter_each"
Execute a filtering function to all elements of array reference.
.PP
.Vb 2
\&  my $new_values = $vc\->filter_each($values, \*(Aqtrim\*(Aq);
\&  my $new_values = $vc\->filter_each($values, \*(Aqtrim\*(Aq, $arg);
.Ve
.PP
First argument is the values for filtering, which must be array reference.
Second argument is the name of the filtering funcion.
Third argument is the argument of the filtering function.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Show you some examples to do some validation.
.PP
Password checking:
.PP
.Vb 2
\&  my $password = \*(Aqabc\*(Aq;
\&  my $password2 = \*(Aqabc\*(Aq;
\&  
\&  my $validation = $vc\->validation;
\&  
\&  if (!length $password) {
\&    $validation\->add_failed(password => \*(Aqpassword must have length\*(Aq);
\&  }
\&  elsif (!$vc\->check($password, \*(Aqascii\*(Aq)) {
\&    $validation\->add_failed(password => \*(Aqpassword contains invalid characters\*(Aq);
\&  }
\&  elsif ($password ne $password2) {
\&    $validation\->add_failed(password => "two passwords don\*(Aqt match");
\&  }
\&  
\&  if ($validation\->is_valid) {
\&    # ...
\&  }
\&  else {
\&    # ...
\&  }
.Ve
.PP
Check box, selected at least 1, one of the given values:
.PP
.Vb 1
\&  my $favorite = [\*(Aq001\*(Aq, \*(Aq002\*(Aq];
\&
\&  my $validation = $vc\->validation;
\&  
\&  if (@$favorite == 0) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite must be selected at least 1\*(Aq);
\&  }
\&  elsif (!$vc\->check($favorite, \*(Aqin\*(Aq, [\*(Aq001\*(Aq, \*(Aq002\*(Aq, \*(Aq003\*(Aq])) {
\&    $validation\->add_failed(favorite => \*(Aqfavorite have invalid value\*(Aq);
\&  }
\&  
\&  if ($validtion\->is_valid) {
\&    # ...
\&  }
\&  else {
\&    # ...
\&  }
.Ve
.PP
Convert date string to Time::Piece object.
.PP
.Vb 1
\&  my $date = \*(Aq2014/05/16\*(Aq;
\&  
\&  my $validation = $vc\->validation;
\&  
\&  my $date_tp;
\&  if (!length $date) {
\&    $validation\->add_failed(date => \*(Aqdate must have length\*(Aq);
\&  }
\&  else {
\&    eval { $date_tp = Time::Piece\->strptime($date, \*(Aq%Y/%m/%d\*(Aq) };
\&    if (!$date_tp) {
\&      $validation\->add_failed(date => \*(Aqdate value is invalid\*(Aq);
\&    }
\&  }
.Ve
.PP
Convert datetime string to Time::Piece object.
.PP
.Vb 1
\&  my $datetime = \*(Aq2014/05/16 12:30:40\*(Aq;
\&  
\&  my $validation = $vc\->validation;
\&  
\&  my $datetime_tp;
\&  if (!length $datetime) {
\&    $validation\->add_failed(datetime => \*(Aqdatetime must have length\*(Aq);
\&  }
\&  else {
\&    eval { $datetime_tp = Time::Piece\->strptime($datetime, \*(Aq%Y/%m/%d %H:%M:%S\*(Aq) };
\&    if (!$datetime_tp) {
\&      $validation\->add_failed(datetime => \*(Aqdatetime value is invalid\*(Aq);
\&    }
\&  }
.Ve
.SH "FAQ"
.IX Header "FAQ"
.SS "I use Validator::Custom 0.xx yet. I want to see documentation of Version 0.xx."
.IX Subsection "I use Validator::Custom 0.xx yet. I want to see documentation of Version 0.xx."
See Validator::Custom::Document::Version0.
This is complete document for Validator::Custom version 0.xx.
.SS "What point I take care of in Version 1.xx."
.IX Subsection "What point I take care of in Version 1.xx."
.IP "\(bu" 4
\&\f(CW\*(C`in_array\*(C'\fR constraint function is renamed to \f(CW\*(C`in\*(C'\fR checking function.
.IP "\(bu" 4
\&\f(CW\*(C`trim\*(C'\fR filtering function becomes triming unicode space characters, not only \f(CW\*(C`[ \et\en\er\ef]\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`decimal\*(C'\fR constraint is renamed to \f(CW\*(C`number\*(C'\fR checking function and simplified.
.IP "\(bu" 4
\&\f(CW\*(C`date_to_timepiece\*(C'\fR checking function doesn't exist.
About alternative way, see the topic \*(L"Convert date string to Time::Piece object\*(R" in \*(L"\s-1EXAMPLES\*(R".\s0
.IP "\(bu" 4
\&\f(CW\*(C`datetime_to_timepiece\*(C'\fR checking function doesn't exists.
About alternative way, see the topic \*(L"Convert datetime string to Time::Piece object\*(R" in \*(L"\s-1EXAMPLES\*(R".\s0
.SS "How to create the corresponding checking functions in Version 0.xx constraint functions."
.IX Subsection "How to create the corresponding checking functions in Version 0.xx constraint functions."
I show some examples.
.PP
space
.PP
.Vb 4
\&  $vc\->add_check(space => sub {
\&    my ($vc, $value, $arg) = @_;
\&    return defined $value && $value =~ \*(Aq^[ \et\en\er\ef]*$\*(Aq ? 1 : 0;
\&  });
.Ve
.PP
http_url
.PP
.Vb 4
\&  $vc\->add_check(http_url => sub {
\&    my ($vc, $value, $arg) = @_;
\&    return defined $value && $value =~ /^s?https?:\e/\e/[\-_.!~*\*(Aq()a\-zA\-Z0\-9;\e/?:\e@&=+\e$,%#]+$/ ? 1 : 0;
\&  });
.Ve
.PP
decimal
.PP
.Vb 2
\&  $vc\->add_check(decimal => sub {
\&    my ($vc, $value, $arg) = @_;
\&
\&    return undef unless defined $value;
\&    
\&    my $digits_tmp = $arg;
\&    
\&    # Digit
\&    my $digits;
\&    if (defined $digits_tmp) {
\&      if (ref $digits_tmp eq \*(AqARRAY\*(Aq) {
\&        $digits = $digits_tmp;
\&      }
\&      else {
\&        $digits = [$digits_tmp, undef];
\&      }
\&    }
\&    else {
\&      $digits = [undef, undef];
\&    }
\&    
\&    # Regex
\&    my $re;
\&    if (defined $digits\->[0] && defined $digits\->[1]) {
\&      $re = qr/^[0\-9]{1,$digits\->[0]}(\e.[0\-9]{0,$digits\->[1]})?$/;
\&    }
\&    elsif (defined $digits\->[0]) {
\&      $re = qr/^[0\-9]{1,$digits\->[0]}(\e.[0\-9]*)?$/;
\&    }
\&    elsif (defined $digits\->[1]) {
\&      $re = qr/^[0\-9]+(\e.[0\-9]{0,$digits\->[1]})?$/;
\&    }
\&    else {
\&      $re = qr/^[0\-9]+(\e.[0\-9]*)?$/;
\&    }
\&    
\&    # Check value
\&    if ($value =~ /$re/) {
\&      return 1;
\&    }
\&    else {
\&      return 0;
\&    }
\&  }
.Ve
.SS "How to create the corresponding filtering functions in Version 0.xx constraint functions."
.IX Subsection "How to create the corresponding filtering functions in Version 0.xx constraint functions."
I show some examples.
.PP
trim_collapse
.PP
.Vb 2
\&  $vc\->add_filter(trim_collapse => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&    
\&    $value =~ s/[ \et\en\er\ef]+/ /g;
\&    $value =~ s/^[ \et\en\er\ef]*(.*?)[ \et\en\er\ef]*$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.PP
trim_lead
.PP
.Vb 2
\&  $vc\->add_filter(trim_lead => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&
\&    $value =~ s/^[ \et\en\er\ef]+(.*)$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.PP
trim_trail
.PP
.Vb 2
\&  $vc\->add_filter(trim_trail => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&
\&    $value =~ s/^(.*?)[ \et\en\er\ef]+$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.PP
trim_uni
.PP
.Vb 2
\&  $vc\->add_filter(trim_uni => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&
\&    $value =~ s/^\es*(.*?)\es*$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.PP
trim_uni_collapse
.PP
.Vb 2
\&  $vc\->add_filter(trim_uni_collapse => sub {
\&    my ($vc, $value, $arg) = @_;
\&
\&    return undef unless defined $value;
\&    
\&    $value =~ s/\es+/ /g;
\&    $value =~ s/^\es*(.*?)\es*$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.PP
trim_uni_lead
.PP
.Vb 2
\&  $vc\->add_filter(trim_uni_lead => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&    
\&    $value =~ s/^\es+(.*)$/$1/ms;
\&    
\&    return $value;
\&  });
.Ve
.PP
trim_uni_trail
.PP
.Vb 2
\&  $vc\->add_filter(trim_uni_trail => sub {
\&    my ($vc, $value, $arg) = @_;
\&    
\&    return undef unless defined $value;
\&
\&    $value =~ s/^(.*?)\es+$/$1/ms;
\&
\&    return $value;
\&  });
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.PP
<http://github.com/yuki\-kimoto/Validator\-Custom>
.SH "COPYRIGHT & LICENCE"
.IX Header "COPYRIGHT & LICENCE"
Copyright 2009\-2017 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
