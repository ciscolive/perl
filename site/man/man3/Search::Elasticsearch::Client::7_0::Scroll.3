.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Search::Elasticsearch::Client::7_0::Scroll 3"
.TH Search::Elasticsearch::Client::7_0::Scroll 3 "2020-09-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Search::Elasticsearch::Client::7_0::Scroll \- A helper module for scrolled searches
.SH "VERSION"
.IX Header "VERSION"
version 7.30
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Search::Elasticsearch;
\&
\&    my $es     = Search::Elasticsearch\->new;
\&
\&    my $scroll = $es\->scroll_helper(
\&        index       => \*(Aqmy_index\*(Aq,
\&        body => {
\&            query   => {...},
\&            size    => 1000,
\&            sort    => \*(Aq_doc\*(Aq
\&        }
\&    );
\&
\&    say "Total hits: ". $scroll\->total;
\&
\&    while (my $doc = $scroll\->next) {
\&        # do something
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \fIscrolled search\fR is a search that allows you to keep pulling results
until there are no more matching results, much like a cursor in an \s-1SQL\s0
database.
.PP
Unlike paginating through results (with the \f(CW\*(C`from\*(C'\fR parameter in
\&\fBsearch()\fR),
scrolled searches take a snapshot of the current state of the index. Even
if you keep adding new documents to the index or updating existing documents,
a scrolled search will only see the index as it was when the search began.
.PP
This module is a helper utility that wraps the functionality of the
\&\fBsearch()\fR and
\&\fBscroll()\fR methods to make
them easier to use.
.PP
This class does Search::Elasticsearch::Client::7_0::Role::Scroll and
Search::Elasticsearch::Role::Is_Sync.
.SH "USE CASES"
.IX Header "USE CASES"
There are two primary use cases:
.SS "Pulling enough results"
.IX Subsection "Pulling enough results"
Perhaps you want to group your results by some field, and you don't know
exactly how many results you will need in order to return 10 grouped
results.  With a scrolled search you can keep pulling more results
until you have enough.  For instance, you can search emails in a mailing
list, and return results grouped by \f(CW\*(C`thread_id\*(C'\fR:
.PP
.Vb 1
\&    my (%groups,@results);
\&
\&    my $scroll = $es\->scroll_helper(
\&        index => \*(Aqmy_emails\*(Aq,
\&        type  => \*(Aqemail\*(Aq,
\&        body  => { query => {... some query ... }}
\&    );
\&
\&    my $doc;
\&    while (@results < 10 and $doc = $scroll\->next) {
\&
\&        my $thread = $doc\->{_source}{thread_id};
\&
\&        unless ($groups{$thread}) {
\&            $groups{$thread} = [];
\&            push @results, $groups{$thread};
\&        }
\&        push @{$groups{$thread}},$doc;
\&
\&    }
.Ve
.SS "Extracting all documents"
.IX Subsection "Extracting all documents"
Often you will want to extract all (or a subset of) documents in an index.
If you want to change your type mappings, you will need to reindex all of your
data. Or perhaps you want to move a subset of the data in one index into
a new dedicated index. In these cases, you don't care about sort
order, you just want to retrieve all documents which match a query, and do
something with them. For instance, to retrieve all the docs for a particular
\&\f(CW\*(C`client_id\*(C'\fR:
.PP
.Vb 12
\&    my $scroll = $es\->scroll_helper(
\&        index       => \*(Aqmy_index\*(Aq,
\&        size        => 1000,
\&        body        => {
\&            query => {
\&                match => {
\&                    client_id => 123
\&                }
\&            },
\&            sort => \*(Aq_doc\*(Aq
\&        }
\&    );
\&
\&    while (my $doc = $scroll\->next) {
\&        # do something
\&    }
.Ve
.PP
Very often the \fIsomething\fR that you will want to do with these results
involves bulk-indexing them into a new index. The easiest way to
do this is to use the built-in \*(L"\fBreindex()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct
functionality provided by Elasticsearch.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new()"""
.el .SS "\f(CWnew()\fP"
.IX Subsection "new()"
.Vb 1
\&    use Search::Elasticsearch;
\&
\&    my $es = Search::Elasticsearch\->new(...);
\&    my $scroll = $es\->scroll_helper(
\&        scroll         => \*(Aq1m\*(Aq,            # optional
\&        %search_params
\&    );
.Ve
.PP
The \*(L"\fBscroll_helper()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct method loads
Search::Elasticsearch::Client::7_0::Scroll class and calls \*(L"\fBnew()\fR\*(R",
passing in any arguments.
.PP
You can specify a \f(CW\*(C`scroll\*(C'\fR duration (which defaults to \f(CW"1m"\fR).
Any other parameters are passed directly to \*(L"\fBsearch()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct.
.PP
The \f(CW\*(C`scroll\*(C'\fR duration tells Elasticearch how long it should keep the scroll
alive.  \fBNote\fR: this duration doesn't need to be long enough to process
all results, just long enough to process a single \fBbatch\fR of results.
The expiry gets renewed for another \f(CW\*(C`scroll\*(C'\fR period every time new
a new batch of results is retrieved from the cluster.
.PP
By default, the \f(CW\*(C`scroll_id\*(C'\fR is passed as the \f(CW\*(C`body\*(C'\fR to the
scroll request.
.PP
The \f(CW\*(C`scroll\*(C'\fR request uses \f(CW\*(C`GET\*(C'\fR by default.  To use \f(CW\*(C`POST\*(C'\fR instead,
set send_get_body_as to
\&\f(CW\*(C`POST\*(C'\fR.
.ie n .SS """next()"""
.el .SS "\f(CWnext()\fP"
.IX Subsection "next()"
.Vb 2
\&    $doc  = $scroll\->next;
\&    @docs = $scroll\->next($num);
.Ve
.PP
The \f(CW\*(C`next()\*(C'\fR method returns the next result, or the next \f(CW$num\fR results
(pulling more results if required).  If all results have been exhausted,
it returns an empty list.
.ie n .SS """drain_buffer()"""
.el .SS "\f(CWdrain_buffer()\fP"
.IX Subsection "drain_buffer()"
.Vb 1
\&    @docs = $scroll\->drain_buffer;
.Ve
.PP
The \f(CW\*(C`drain_buffer()\*(C'\fR method returns all of the documents currently in the
buffer, without fetching any more from the cluster.
.ie n .SS """refill_buffer()"""
.el .SS "\f(CWrefill_buffer()\fP"
.IX Subsection "refill_buffer()"
.Vb 1
\&    $total = $scroll\->refill_buffer;
.Ve
.PP
The \f(CW\*(C`refill_buffer()\*(C'\fR method fetches the next batch of results from the
cluster, stores them in the buffer, and returns the total number of docs
currently in the buffer.
.ie n .SS """buffer_size()"""
.el .SS "\f(CWbuffer_size()\fP"
.IX Subsection "buffer_size()"
.Vb 1
\&    $total = $scroll\->buffer_size;
.Ve
.PP
The \f(CW\*(C`buffer_size()\*(C'\fR method returns the total number of docs currently in
the buffer.
.ie n .SS """finish()"""
.el .SS "\f(CWfinish()\fP"
.IX Subsection "finish()"
.Vb 1
\&    $scroll\->finish;
.Ve
.PP
The \f(CW\*(C`finish()\*(C'\fR method clears out the buffer, sets \*(L"\fBis_finished()\fR\*(R" to \f(CW\*(C`true\*(C'\fR
and tries to clear the \f(CW\*(C`scroll_id\*(C'\fR on Elasticsearch.  This \s-1API\s0 is only
supported since v0.90.6, but the call to \f(CW\*(C`clear_scroll\*(C'\fR is wrapped in an
\&\f(CW\*(C`eval\*(C'\fR so the \f(CW\*(C`finish()\*(C'\fR method can be safely called with any version
of Elasticsearch.
.PP
When the \f(CW$scroll\fR instance goes out of scope, \*(L"\fBfinish()\fR\*(R" is called
automatically if required.
.ie n .SS """is_finished()"""
.el .SS "\f(CWis_finished()\fP"
.IX Subsection "is_finished()"
.Vb 1
\&    $bool = $scroll\->is_finished;
.Ve
.PP
A flag which returns \f(CW\*(C`true\*(C'\fR if all results have been processed or
\&\*(L"\fBfinish()\fR\*(R" has been called.
.SH "INFO ACCESSORS"
.IX Header "INFO ACCESSORS"
The information from the original search is returned via the following
accessors:
.ie n .SS """total"""
.el .SS "\f(CWtotal\fP"
.IX Subsection "total"
The total number of documents that matched your query.
.ie n .SS """max_score"""
.el .SS "\f(CWmax_score\fP"
.IX Subsection "max_score"
The maximum score of any documents in your query.
.ie n .SS """aggregations"""
.el .SS "\f(CWaggregations\fP"
.IX Subsection "aggregations"
Any aggregations that were specified, or \f(CW\*(C`undef\*(C'\fR
.ie n .SS """facets"""
.el .SS "\f(CWfacets\fP"
.IX Subsection "facets"
Any facets that were specified, or \f(CW\*(C`undef\*(C'\fR
.ie n .SS """suggest"""
.el .SS "\f(CWsuggest\fP"
.IX Subsection "suggest"
Any suggestions that were specified, or \f(CW\*(C`undef\*(C'\fR
.ie n .SS """took"""
.el .SS "\f(CWtook\fP"
.IX Subsection "took"
How long the original search took, in milliseconds
.ie n .SS """took_total"""
.el .SS "\f(CWtook_total\fP"
.IX Subsection "took_total"
How long the original search plus all subsequent batches took, in milliseconds.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
\&\*(L"\fBsearch()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct
.IP "\(bu" 4
\&\*(L"\fBscroll()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct
.IP "\(bu" 4
\&\*(L"\fBreindex()\fR\*(R" in Search::Elasticsearch::Client::7_0::Direct
.SH "AUTHOR"
.IX Header "AUTHOR"
Enrico Zimuel <enrico.zimuel@elastic.co>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Elasticsearch \s-1BV.\s0
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
