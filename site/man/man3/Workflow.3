.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow 3"
.TH Workflow 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow \- Simple, flexible system to implement workflows
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.15 of Workflow
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Workflow::Factory qw( FACTORY );
\&
\& # Defines a workflow of type \*(Aqmyworkflow\*(Aq
\& my $workflow_conf  = \*(Aqworkflow.xml\*(Aq;
\&
\& # contents of \*(Aqworkflow.xml\*(Aq
\&
\& <workflow>
\&     <type>myworkflow</type>
\&     <time_zone>local</time_zone>
\&     <description>This is my workflow.</description>
\&
\&     <state name="INITIAL">
\&         <action name="upload file" resulting_state="uploaded" />
\&     </state>
\&     <state name="uploaded" autorun="yes">
\&         <action name="verify file" resulting_state="verified file">
\&              <!\-\- everyone other than \*(AqCWINTERS\*(Aq must verify \-\->
\&              <condition test="$context\->{user} ne \*(AqCWINTERS\*(Aq" />
\&         </action>
\&         <action name="null" resulting_state="annotated">
\&              <condition test="$context\->{user} eq \*(AqCWINTERS\*(Aq" />
\&         </action>
\&     </state>
\&     <state name="verified file">
\&         <action name="annotate">
\&             <condition name="can_annotate" />
\&         </action>
\&         <action name="null">
\&             <condition name="!can_annotate" />
\&         </action>
\&     </state>
\&     <state name="annotated" autorun="yes" may_stop="yes">
\&         <action name="null" resulting_state="finished">
\&            <condition name="completed" />
\&         </action>
\&     </state>
\&     <state name="finished" />
\& </workflow>
\&
\& # Defines actions available to the workflow
\& my $action_conf    = \*(Aqaction.xml\*(Aq;
\&
\& # contents of \*(Aqaction.xml\*(Aq
\&
\& <actions>
\&     <action name="upload file" class="MyApp::Action::Upload">
\&         <field name="path" label="File Path"
\&                description="Path to file" is_required="yes" />
\&     </action>
\&
\&     <action name="verify file" class="MyApp::Action::Verify">
\&         <validator name="filesize_cap">
\&             <arg>$file_size</arg>
\&         </validator>
\&     </action>
\&
\&     <action name="annotate"    class="MyApp::Action::Annotate" />
\&
\&     <action name="null"        class="Workflow::Action::Null" />
\& </actions>
\&
\& # Defines conditions available to the workflow
\& my $condition_conf = \*(Aqcondition.xml\*(Aq;
\&
\& # contents of \*(Aqcondition.xml\*(Aq
\&
\& <conditions>
\&     <condition name="can_annotate"
\&                class="MyApp::Condition::CanAnnotate" />
\& </conditions>
\&
\& # Defines validators available to the actions
\& my $validator_conf = \*(Aqvalidator.xml\*(Aq;
\&
\& # contents of \*(Aqvalidator.xml\*(Aq
\&
\& <validators>
\&     <validator name="filesize_cap" class="MyApp::Validator::FileSizeCap">
\&         <param name="max_size" value="20M" />
\&     </validator>
\& </validators>
\&
\& # Stock the factory with the configurations; we can add more later if
\& # we want
\& $self\->_factory()\->add_config_from_file(
\&     workflow   => $workflow_conf,
\&     action     => $action_conf,
\&     condition  => $condition_conf,
\&     validator  => $validator_conf
\& );
\&
\& # Instantiate a new workflow...
\& my $workflow = $self\->_factory()\->create_workflow( \*(Aqmyworkflow\*(Aq );
\& print "Workflow ", $workflow\->id, " ",
\&       "currently at state ", $workflow\->state, "\en";
\&
\& # Display available actions...
\& print "Available actions: ", $workflow\->get_current_actions, "\en";
\&
\& # Get the data needed for action \*(Aqupload file\*(Aq (assumed to be
\& # available in the current state) and display the fieldname and
\& # description
\&
\& print "Action \*(Aqupload file\*(Aq requires the following fields:\en";
\& foreach my $field ( $workflow\->get_action_fields( \*(AqFOO\*(Aq ) ) {
\&     print $field\->name, ": ", $field\->description,
\&           "(Required? ", $field\->is_required, ")\en";
\& }
\&
\& # Add data to the workflow context for the validators, conditions and
\& # actions to work with
\&
\& my $context = $workflow\->context;
\& $context\->param( current_user => $user );
\& $context\->param( sections => \e@sections );
\& $context\->param( path => $path_to_file );
\&
\& # Execute one of them
\& $workflow\->execute_action( \*(Aqupload file\*(Aq );
\&
\& print "New state: ", $workflow\->state, "\en";
\&
\& # Later.... fetch an existing workflow
\& my $id = get_workflow_id_from_user( ... );
\& my $workflow = $self\->_factory()\->fetch_workflow( \*(Aqmyworkflow\*(Aq, $id );
\& print "Current state: ", $workflow\->state, "\en";
.Ve
.SH "QUICK START"
.IX Header "QUICK START"
The \fIeg/ticket/\fR directory contains a configured workflow system.
You can access the same data and logic in two ways:
.IP "\(bu" 4
a command-line application (ticket.pl)
.IP "\(bu" 4
a \s-1CGI\s0 script               (ticket.cgi)
.IP "\(bu" 4
a web application          (ticket_web.pl)
.PP
To initialize:
.PP
.Vb 1
\&        perl ticket.pl \-\-db
.Ve
.PP
To run the command-line application:
.PP
.Vb 1
\&        perl ticket.pl
.Ve
.PP
To access the database and data from \s-1CGI,\s0 add the relevant
configuration for your web server and call ticket.cgi:
.PP
.Vb 1
\&        http://www.mysite.com/workflow/ticket.cgi
.Ve
.PP
To start up the standalone web server:
.PP
.Vb 1
\&        perl ticket_web.pl
.Ve
.PP
(Barring changes to HTTP::Daemon and forking the standalone server
won't work on Win32; use \s-1CGI\s0 instead, although patches are always
welcome.)
.PP
For more info, see \fIeg/ticket/README\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
This is a standalone workflow system. It is designed to fit into your
system rather than force your system to fit to it. You can save
workflow information to a database or the filesystem (or a custom
storage). The different components of a workflow system can be
included separately as libraries to allow for maximum reusibility.
.SS "User Point of View"
.IX Subsection "User Point of View"
As a user you only see two components, plus a third which is really
embedded into another:
.IP "\(bu" 4
Workflow::Factory \- The factory is your interface for creating new
workflows and fetching existing ones. You also feed all the necessary
configuration files and/or data structures to the factory to
initialize it.
.IP "\(bu" 4
Workflow \- When you get the workflow object from the workflow
factory you can only use it in a few ways \*(-- asking for the current
state, actions available for the state, data required for a particular
action, and most importantly, executing a particular action. Executing
an action is how you change from one state to another.
.IP "\(bu" 4
Workflow::Context \- This is a blackboard for data from your
application to the workflow system and back again. Each instantiation
of a Workflow has its own context, and actions executed by the
workflow can read data from and deposit data into the context.
.SS "Developer Point of View"
.IX Subsection "Developer Point of View"
The workflow system has four basic components:
.IP "\(bu" 4
\&\fBworkflow\fR \- The workflow is a collection of states; you define the
states, how to move from one state to another, and under what
conditions you can change states.
.Sp
This is represented by the Workflow object. You normally do not
need to subclass this object for customization.
.IP "\(bu" 4
\&\fBaction\fR \- The action is defined by you or in a separate library. The
action is triggered by moving from one state to another and has access
to the workflow and more importantly its context.
.Sp
The base class for actions is the Workflow::Action class.
.IP "\(bu" 4
\&\fBcondition\fR \- Within the workflow you can attach one or more
conditions to an action. These ensure that actions only get executed
when certain conditions are met. Conditions are completely arbitrary:
typically they will ensure the user has particular access rights, but
you can also specify that an action can only be executed at certain
times of the day, or from certain \s-1IP\s0 addresses, and so forth. Each
condition is created once at startup then passed a context to check
every time an action is checked to see if it can be executed.
.Sp
The base class for conditions is the Workflow::Condition class.
.IP "\(bu" 4
\&\fBvalidator\fR \- An action can specify one or more validators to ensure
that the data available to the action is correct. The data to check
can be as simple or complicated as you like. Each validator is created
once then passed a context and data to check every time an action is
executed.
.Sp
The base class for validators is the Workflow::Validator class.
.SH "WORKFLOW BASICS"
.IX Header "WORKFLOW BASICS"
.SS "Just a Bunch of States"
.IX Subsection "Just a Bunch of States"
A workflow is just a bunch of states with rules on how to move between
them. These are known as transitions and are triggered by some sort of
event. A state is just a description of object properties. You can
describe a surprisingly large number of processes as a series of
states and actions to move between them. The application shipped with
this distribution uses a fairly common application to illustrate: the
trouble ticket.
.PP
When you create a workflow you have one action available to you:
create a new ticket ('create issue'). The workflow has a state
\&'\s-1INITIAL\s0' when it is first created, but this is just a bootstrapping
exercise since the workflow must always be in some state.
.PP
The workflow action 'create issue' has a property 'resulting_state',
which just means: if you execute me properly the workflow will be in
the new state '\s-1CREATED\s0'.
.PP
All this talk of 'states' and 'transitions' can be confusing, but just
match them to what happens in real life \*(-- you move from one action to
another and at each step ask: what happens next?
.PP
You create a trouble ticket: what happens next? Anyone can add
comments to it and attach files to it while administrators can edit it
and developers can start working on it. Adding comments does not
really change what the ticket is, it just adds
information. Attachments are the same, as is the admin editing the
ticket.
.PP
But when someone starts work on the ticket, that is a different
matter. When someone starts work they change the answer to: what
happens next? Whenever the answer to that question changes, that means
the workflow has changed state.
.SS "Discover Information from the Workflow"
.IX Subsection "Discover Information from the Workflow"
In addition to declaring what the resulting state will be from an
action the action also has a number of 'field' properties that
describe that data it required to properly execute it.
.PP
This is an example of discoverability. This workflow system is setup
so you can ask it what you can do next as well as what is required to
move on. So to use our ticket example we can do this, creating the
workflow and asking it what actions we can execute right now:
.PP
.Vb 2
\& my $wf = Workflow::$self\->_factory()\->create_workflow( \*(AqTicket\*(Aq );
\& my @actions = $wf\->get_current_actions;
.Ve
.PP
We can also interrogate the workflow about what fields are necessary
to execute a particular action:
.PP
.Vb 6
\& print "To execute the action \*(Aqcreate issue\*(Aq you must provide:\en\en";
\& my @fields = $wf\->get_action_fields( \*(Aqcreate issue\*(Aq );
\& foreach my $field ( @fields ) {
\&     print $field\->name, " (Required? ", $field\->is_required, ")\en",
\&           $field\->description, "\en\en";
\& }
.Ve
.SS "Provide Information to the Workflow"
.IX Subsection "Provide Information to the Workflow"
To allow the workflow to run into multiple environments we must have a
common way to move data between your application, the workflow and the
code that moves it from one state to another.
.PP
Whenever the Workflow::Factory creates a new workflow it associates
the workflow with a Workflow::Context object. The context is what
moves the data from your application to the workflow and the workflow
actions.
.PP
For instance, the workflow has no idea what the 'current user' is. Not
only is it unaware from an application standpoint but it does not
presume to know where to get this information. So you need to tell it,
and you do so through the context.
.PP
The fact that the workflow system proscribes very little means it can
be used in lots of different applications and interfaces. If a system
is too closely tied to an interface (like the web) then you have to
create some potentially ugly hacks to create a more convenient avenue
for input to your system (such as an e\-mail approving a document).
.PP
The Workflow::Context object is extremely simple to use \*(-- you ask
a workflow for its context and just get/set parameters on it:
.PP
.Vb 2
\& # Get the username from the Apache object
\& my $username = $r\->connection\->user;
\&
\& # ...set it in the context
\& $wf\->context\->param( user => $username );
\&
\& # somewhere else you\*(Aqll need the username:
\&
\& $news_object\->{created_by} = $wf\->context\->param( \*(Aquser\*(Aq );
.Ve
.SS "Controlling What Gets Executed"
.IX Subsection "Controlling What Gets Executed"
A typical process for executing an action is:
.IP "\(bu" 4
Get data from the user
.IP "\(bu" 4
Fetch a workflow
.IP "\(bu" 4
Set the data from the user to the workflow context
.IP "\(bu" 4
Execute an action on the context
.PP
When you execute the action a number of checks occur. The action needs
to ensure:
.IP "\(bu" 4
The data presented to it are valid \*(-- date formats, etc. This is done
with a validator, more at Workflow::Validator
.IP "\(bu" 4
The environment meets certain conditions \*(-- user is an administrator,
etc. This is done with a condition, more at Workflow::Condition
.PP
Once the action passes these checks and successfully executes we
update the permanent workflow storage with the new state, as long as
the application has declared it.
.SH "WORKFLOWS ARE OBSERVABLE"
.IX Header "WORKFLOWS ARE OBSERVABLE"
.SS "Purpose"
.IX Subsection "Purpose"
It's useful to have your workflow generate events so that other parts
of a system can see what's going on and react. For instance, say you
have a new user creation process. You want to email the records of all
users who have a first name of 'Sinead' because you're looking for
your long-lost sister named 'Sinead'. You'd create an observer class
like:
.PP
.Vb 1
\& package FindSinead;
\&
\& sub update {
\&     my ( $class, $wf, $event, $new_state ) = @_;
\&     return unless ( $event eq \*(Aqstate change\*(Aq );
\&     return unless ( $new_state eq \*(AqCREATED\*(Aq );
\&     my $context = $wf\->context;
\&     return unless ( $context\->param( \*(Aqfirst_name\*(Aq ) eq \*(AqSinead\*(Aq );
\&
\&     my $user = $context\->param( \*(Aquser\*(Aq );
\&     my $username = $user\->username;
\&     my $email    = $user\->email;
\&     my $mailer = get_mailer( ... );
\&     $mailer\->send( \*(Aqfoo@bar.com\*(Aq,\*(AqFound her!\*(Aq,
\&                    "We found Sinead under \*(Aq$username\*(Aq at \*(Aq$email\*(Aq );
\& }
.Ve
.PP
And then associate it with your workflow:
.PP
.Vb 4
\& <workflow>
\&     <type>SomeFlow</type>
\&     <observer class="FindSinead" />
\&     ...
.Ve
.PP
Every time you create/fetch a workflow the associated observers are
attached to it.
.SS "Events Generated"
.IX Subsection "Events Generated"
You can attach listeners to workflows and catch events at a few points
in the workflow lifecycle; these are the events fired:
.IP "\(bu" 4
\&\fBcreate\fR \- Issued after a workflow is first created.
.Sp
No additional parameters.
.IP "\(bu" 4
\&\fBfetch\fR \- Issued after a workflow is fetched from the persister.
.Sp
No additional parameters.
.IP "\(bu" 4
\&\fBsave\fR \- Issued after a workflow is successfully saved.
.Sp
No additional parameters.
.IP "\(bu" 4
\&\fBexecute\fR \- Issued after a workflow is successfully executed and
saved.
.Sp
Adds the parameters \f(CW$old_state\fR, \f(CW$action_name\fR and \f(CW$autorun\fR.
\&\f(CW$old_state\fR includes the state of the workflow before the action
was executed, \f(CW$action_name\fR is the action name that was executed and
\&\f(CW$autorun\fR is set to 1 if the action just executed was started
using autorun.
.IP "\(bu" 4
\&\fBstate change\fR \- Issued after a workflow is successfully executed,
saved and results in a state change. The event will not be fired if
you executed an action that did not result in a state change.
.Sp
Adds the parameters \f(CW$old_state\fR, \f(CW$action\fR and \f(CW$autorun\fR.
\&\f(CW$old_state\fR includes the state of the workflow before the action
was executed, \f(CW$action\fR is the action name that was executed and
\&\f(CW$autorun\fR is set to 1 if the action just executed was autorun.
.IP "\(bu" 4
\&\fBadd history\fR \- Issued after one or more history objects added to a
workflow object.
.Sp
The additional argument is an arrayref of all Workflow::History
objects added to the workflow. (Note that these will not be persisted
until the workflow is persisted.)
.SS "Configuring"
.IX Subsection "Configuring"
You configure the observers directly in the 'workflow' configuration
item. Each 'observer' may have either a 'class' or 'sub' entry within
it that defines the observer's location.
.PP
We load these classes at startup time. So if you specify an observer
that doesn't exist you see the error when the workflow system is
initialized rather than the system tries to use the observer.
.PP
For instance, the following defines two observers:
.PP
.Vb 3
\& <workflow>
\&   <type>ObservedItem</type>
\&   <description>This is...</description>
\&
\&   <observer class="SomeObserver" />
\&   <observer sub="SomeOtherObserver::Functions::other_sub" />
.Ve
.PP
In the first declaration we specify the class ('SomeObserver') that
will catch observations using its \f(CW\*(C`update()\*(C'\fR method. In the second
we're naming exactly the subroutine ('\fBother_sub()\fR' in the class
\&'SomeOtherObserver::Functions') that will catch observations.
.PP
All configured observers get all events. It's up to each observer to
figure out what it wants to handle.
.SH "WORKFLOW METHODS"
.IX Header "WORKFLOW METHODS"
The following documentation is for the workflow object itself rather
than the entire system.
.SS "Object Methods"
.IX Subsection "Object Methods"
\fIexecute_action( \f(CI$action_name\fI, \f(CI$autorun\fI )\fR
.IX Subsection "execute_action( $action_name, $autorun )"
.PP
Execute the action \f(CW$action_name\fR. Typically this changes the state
of the workflow. If \f(CW$action_name\fR is not in the current state, fails
one of the conditions on the action, or fails one of the validators on
the action an exception is thrown. \f(CW$autorun\fR is used internally and
is set to 1 if the action was executed using autorun.
.PP
After the action has been successfully executed and the workflow saved
we issue a 'execute' observation with the old state, action name and
an autorun flag as additional parameters.
So if you wanted to write an observer you could create a
method with the signature:
.PP
.Vb 5
\& sub update {
\&     my ( $class, $workflow, $action, $old_state, $action_name, $autorun )
\&        = @_;
\&     if ( $action eq \*(Aqexecute\*(Aq ) { .... }
\& }
.Ve
.PP
We also issue a 'change state' observation if the executed action
resulted in a new state. See \*(L"\s-1WORKFLOWS ARE OBSERVABLE\*(R"\s0 above for how
we use and register observers and Class::Observable for more
general information about observers as well as implementation details.
.PP
Returns: new state of workflow
.PP
\fIget_current_actions( \f(CI$group\fI )\fR
.IX Subsection "get_current_actions( $group )"
.PP
Returns a list of action names available from the current state for
the given environment. So if you keep your \f(CW\*(C`context()\*(C'\fR the same if
you call \f(CW\*(C`execute_action()\*(C'\fR with one of the action names you should
not trigger any condition error since the action has already been
screened for conditions.
If you want to divide actions in groups (for example state change group,
approval group, which have to be shown at different places on the page) add group property
to your action
.PP
<action name=\*(L"terminate request\*(R"  group=\*(L"state change\*(R"  class=\*(L"MyApp::Action::Terminate\*(R" />
<action name=\*(L"approve request\*(R"  group=\*(L"approval\*(R"  class=\*(L"MyApp::Action::Approve\*(R" />
.PP
my \f(CW@actions\fR = \f(CW$wf\fR\->get_current_actions(\*(L"approval\*(R");
.PP
\&\f(CW$group\fR should be string that reperesents desired group name. In \f(CW@actions\fR you will get
list of action names available from the current state for the given environment limited by group.
\&\f(CW$group\fR is optional parameter.
.PP
Returns: list of strings representing available actions
.PP
\fIget_action_fields( \f(CI$action_name\fI )\fR
.IX Subsection "get_action_fields( $action_name )"
.PP
Return a list of Workflow::Action::InputField objects for the given
\&\f(CW$action_name\fR. If \f(CW$action_name\fR not in the current state or not
accessible by the environment an exception is thrown.
.PP
Returns: list of Workflow::Action::InputField objects
.PP
\fIadd_history( @( \e%params | \f(CI$wf_history_object\fI ) )\fR
.IX Subsection "add_history( @( %params | $wf_history_object ) )"
.PP
Adds any number of histories to the workflow, typically done by an
action in \f(CW\*(C`execute_action()\*(C'\fR or one of the observers of that
action. This history will not be saved until \f(CW\*(C`execute_action()\*(C'\fR is
complete.
.PP
You can add a list of either hashrefs with history information in them
or full Workflow::History objects. Trying to add anything else will
result in an exception and \fBnone\fR of the items being added.
.PP
Successfully adding the history objects results in a 'add history'
observation being thrown. See \*(L"\s-1WORKFLOWS ARE OBSERVABLE\*(R"\s0 above for
more.
.PP
Returns: nothing
.PP
\fI\f(BIget_history()\fI\fR
.IX Subsection "get_history()"
.PP
Returns list of history objects for this workflow. Note that some may
be unsaved if you call this during the \f(CW\*(C`execute_action()\*(C'\fR process.
.PP
\fI\f(BIget_unsaved_history()\fI\fR
.IX Subsection "get_unsaved_history()"
.PP
Returns list of all unsaved history objects for this workflow.
.PP
\fI\f(BIclear_history()\fI\fR
.IX Subsection "clear_history()"
.PP
Clears all transient history objects from the workflow object, \fBnot\fR
from the long-term storage.
.PP
\fIset( \f(CI$property\fI, \f(CI$value\fI )\fR
.IX Subsection "set( $property, $value )"
.PP
Method used to overwrite Class::Accessor so only certain callers can set
properties caller has to be a Workflow namespace package.
.PP
Sets property to value or throws Workflow::Exception
.SS "Properties"
.IX Subsection "Properties"
Unless otherwise noted, properties are \fBread-only\fR.
.PP
\fIConfiguration Properties\fR
.IX Subsection "Configuration Properties"
.PP
Some properties are set in the configuration file for each
workflow. These remain static once the workflow is instantiated.
.PP
\&\fBtype\fR
.PP
Type of workflow this is. You may have many individual workflows
associated with a type or you may have many different types
running in a single workflow engine.
.PP
\&\fBdescription\fR
.PP
Description (usually brief, hopefully with a \s-1URL...\s0)  of this
workflow.
.PP
\&\fBtime_zone\fR
.PP
Workflow uses the DateTime module to create all date objects. The time_zone
parameter allows you to pass a time zone value directly to the DateTime
new method for all cases where Workflow needs to create a date object.
See the DateTime module for acceptable values.
.PP
\fIDynamic Properties\fR
.IX Subsection "Dynamic Properties"
.PP
You can get the following properties from any workflow object.
.PP
\&\fBid\fR
.PP
\&\s-1ID\s0 of this workflow. This will \fBalways\fR be defined, since when the
Workflow::Factory creates a new workflow it first saves it to
long-term storage.
.PP
\&\fBstate\fR
.PP
The current state of the workflow.
.PP
\&\fBlast_update\fR (read-write)
.PP
Date of the workflow's last update.
.PP
\fIcontext (read-write, see below)\fR
.IX Subsection "context (read-write, see below)"
.PP
A Workflow::Context object associated with this workflow. This
should never be undefined as the Workflow::Factory sets an empty
context into the workflow when it is instantiated.
.PP
If you add a context to a workflow and one already exists, the values
from the new workflow will overwrite values in the existing
workflow. This is a shallow merge, so with the following:
.PP
.Vb 5
\& $wf\->context\->param( drinks => [ \*(Aqcoke\*(Aq, \*(Aqpepsi\*(Aq ] );
\& my $context = Workflow::Context\->new();
\& $context\->param( drinks => [ \*(Aqbeer\*(Aq, \*(Aqwine\*(Aq ] );
\& $wf\->context( $context );
\& print \*(AqCurrent drinks: \*(Aq, join( \*(Aq, \*(Aq, @{ $wf\->context\->param( \*(Aqdrinks\*(Aq ) } );
.Ve
.PP
You will see:
.PP
.Vb 1
\& Current drinks: beer, wine
.Ve
.SS "Internal Methods"
.IX Subsection "Internal Methods"
\fIinit( \f(CI$id\fI, \f(CI$current_state\fI, \e%workflow_config, \e@wf_states )\fR
.IX Subsection "init( $id, $current_state, %workflow_config, @wf_states )"
.PP
\&\fB\s-1THIS SHOULD ONLY BE CALLED BY THE\s0\fR Workflow::Factory. Do not call
this or the \f(CW\*(C`new()\*(C'\fR method yourself \*(-- you will only get an
exception. Your only interface for creating and fetching workflows is
through the factory.
.PP
This is called by the inherited constructor and sets the
\&\f(CW$current_state\fR value to the property \f(CW\*(C`state\*(C'\fR and uses the other
non-state values from \f(CW\*(C`\e%config\*(C'\fR to set parameters via the inherited
\&\f(CW\*(C`param()\*(C'\fR.
.PP
\fI_get_action( \f(CI$action_name\fI )\fR
.IX Subsection "_get_action( $action_name )"
.PP
Retrieves the action object associated with \f(CW$action_name\fR in the
current workflow state. This will throw an exception if:
.IP "\(bu" 4
No workflow state exists with a name of the current state. (This is
usually some sort of configuration error and should be caught at
initialization time, so it should not happen.)
.IP "\(bu" 4
No action \f(CW$action_name\fR exists in the current state.
.IP "\(bu" 4
No action \f(CW$action_name\fR exists in the workflow universe.
.IP "\(bu" 4
One of the conditions for the action in this state is not met.
.PP
\fI_get_workflow_state( [ \f(CI$state\fI ] )\fR
.IX Subsection "_get_workflow_state( [ $state ] )"
.PP
Return the Workflow::State object corresponding to \f(CW$state\fR, which
defaults to the current state.
.PP
\fI_set_workflow_state( \f(CI$wf_state\fI )\fR
.IX Subsection "_set_workflow_state( $wf_state )"
.PP
Assign the Workflow::State object \f(CW$wf_state\fR to the workflow.
.PP
\fI_get_next_state( \f(CI$action_name\fI )\fR
.IX Subsection "_get_next_state( $action_name )"
.PP
Returns the name of the next state given the action
\&\f(CW$action_name\fR. Throws an exception if \f(CW$action_name\fR not contained
in the current state.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
The configuration of Workflow is done using the format of your choice, currently
\&\s-1XML\s0 and Perl is implemented, but additional formats can be added, please refer
to Workflow::Config, for implementation details.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.IP "Class::Accessor" 4
.IX Item "Class::Accessor"
.PD 0
.IP "Class::Factory" 4
.IX Item "Class::Factory"
.IP "Class::Observable" 4
.IX Item "Class::Observable"
.IP "DateTime" 4
.IX Item "DateTime"
.IP "DateTime::Format::Strptime" 4
.IX Item "DateTime::Format::Strptime"
.IP "Exception::Class" 4
.IX Item "Exception::Class"
.IP "Log::Dispatch" 4
.IX Item "Log::Dispatch"
.IP "Log::Log4perl" 4
.IX Item "Log::Log4perl"
.IP "Safe" 4
.IX Item "Safe"
.IP "XML::Simple" 4
.IX Item "XML::Simple"
.IP "\s-1DBI\s0" 4
.IX Item "DBI"
.IP "Data::Dumper" 4
.IX Item "Data::Dumper"
.IP "Carp" 4
.IX Item "Carp"
.IP "File::Slurp" 4
.IX Item "File::Slurp"
.PD
.SS "\s-1DEPENDENCIES FOR THE EXAMPLE APPLICATION\s0"
.IX Subsection "DEPENDENCIES FOR THE EXAMPLE APPLICATION"
.IP "\s-1CGI\s0" 4
.IX Item "CGI"
.PD 0
.IP "CGI::Cookie" 4
.IX Item "CGI::Cookie"
.IP "DBD::SQLite" 4
.IX Item "DBD::SQLite"
.IP "HTTP::Daemon" 4
.IX Item "HTTP::Daemon"
.IP "HTTP::Request" 4
.IX Item "HTTP::Request"
.IP "HTTP::Response" 4
.IX Item "HTTP::Response"
.IP "HTTP::Status" 4
.IX Item "HTTP::Status"
.IP "Template (Template Toolkit)" 4
.IX Item "Template (Template Toolkit)"
.PD
.PP
For Win32 systems you can get the Template Toolkit and DBD::SQLite
PPDs from TheoryX:
.IP "\(bu" 4
<http://theoryx5.uwinnipeg.ca/cgi\-bin/ppmserver?urn:/PPMServer58>
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
.SS "XML::Simple"
.IX Subsection "XML::Simple"
\&\s-1CPAN\s0 testers reports however do demonstrate a problem with one of the
dependencies of Workflow, namely XML::Simple.
.PP
The XML::Simple makes use of Lib::XML::SAX or XML::Parser, the default.
.PP
In addition an XML::Parser can makes use of plugin parser and some of these
might not be able to parse the \s-1XML\s0 utilized in Workflow. The problem have been
observed with \s-1XML::SAX::RTF\s0.
.PP
The following diagnostic points to the problem:
.PP
.Vb 3
\&        No _parse_* routine defined on this driver (If it is a filter, remember to
\&        set the Parent property. If you call the parse() method, make sure to set a
\&        Source. You may want to call parse_uri, parse_string or parse_file instead.)
.Ve
.PP
Your \s-1XML::SAX\s0 configuration is located in the file:
.PP
.Vb 1
\&        XML/SAX/ParserDetails.ini
.Ve
.SS "Perl 5.8.x"
.IX Subsection "Perl 5.8.x"
\&\s-1CPAN\s0 testers reports indicate an issue with observers for Perl 5.8.8
.PP
.Vb 8
\&    #   Failed test \*(AqOne observation sent on workflow fetch to two observers\*(Aq
\&    #   at t/workflow.t line 79.
\&    #          got: \*(Aq4\*(Aq
\&    #     expected: \*(Aq2\*(Aq
\&    # Looks like you failed 1 test of 35.
\&    t/workflow.t .......................
\&    Dubious, test returned 1 (wstat 256, 0x100)
\&    Failed 1/35 subtests
.Ve
.PP
The issue is being investigated further, so this information is to be regarded
as a warning before you dig too much into the issue.
.PP
See also:
.PP
<http://www.cpantesters.org/cpan/report/fc85ca1c\-e46e\-11e2\-891c\-ff8a40f4ab3d>
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Known bugs and limitations can be seen in \s-1RT:\s0
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Workflow>
.SH "BUG REPORTING"
.IX Header "BUG REPORTING"
Bug reporting should be done either via Request Tracker (\s-1RT\s0)
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Workflow>
.PP
Or via email
.PP
\&\f(CW\*(C`bug\-test\-timer at rt.cpan.org\*(C'\fR
.PP
A list of currently known issues can be seen via examining the \s-1RT\s0 queue for
Workflow.
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Workflow>
.SH "TEST"
.IX Header "TEST"
The test suite can be run using, Module::Build
.PP
.Vb 1
\&        % ./Build test
.Ve
.PP
Some of the tests are reserved for the developers and are only run of the
environment variable \s-1TEST_AUTHOR\s0 is set to true.
.SH "TEST COVERAGE"
.IX Header "TEST COVERAGE"
This is the current test coverage of Workflow version 1.32, with the \s-1TEST_AUTHOR\s0
flag enabled.
.PP
.Vb 10
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&        File                           stmt   bran   cond    sub    pod   time  total
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\&        blib/lib/Workflow.pm           79.8   50.0   50.0   87.5  100.0    9.9   71.6
\&        blib/lib/Workflow/Action.pm    90.8   66.7    n/a   88.2  100.0    4.1   89.9
\&        ...flow/Action/InputField.pm   97.0   92.9   87.5  100.0  100.0    5.9   95.8
\&        ...Workflow/Action/Mailer.pm  100.0    n/a    n/a  100.0  100.0    0.1  100.0
\&        ...b/Workflow/Action/Null.pm  100.0    n/a    n/a  100.0  100.0    0.2  100.0
\&        blib/lib/Workflow/Base.pm      96.6   86.4  100.0  100.0  100.0    9.6   95.0
\&        ...lib/Workflow/Condition.pm  100.0    n/a    n/a  100.0  100.0    0.8  100.0
\&        ...low/Condition/Evaluate.pm   59.0   16.7   33.3   87.5  100.0    0.9   53.0
\&        ...flow/Condition/HasUser.pm   57.7    0.0    0.0   71.4  100.0    0.1   51.2
\&        blib/lib/Workflow/Config.pm    96.2   81.2   33.3  100.0  100.0    6.1   92.2
\&        ...b/Workflow/Config/Perl.pm   96.8   75.0   66.7  100.0  100.0    4.1   91.0
\&        ...ib/Workflow/Config/XML.pm   92.3   50.0   60.0  100.0  100.0    4.9   81.4
\&        blib/lib/Workflow/Context.pm  100.0    n/a    n/a  100.0  100.0    0.4  100.0
\&        ...lib/Workflow/Exception.pm   89.2   50.0    n/a   91.7  100.0    3.1   89.5
\&        blib/lib/Workflow/Factory.pm   86.3   61.2   37.5   92.3  100.0   19.6   75.4
\&        blib/lib/Workflow/History.pm  100.0   87.5    n/a  100.0  100.0    1.8   98.1
\&        ...lib/Workflow/Persister.pm   90.5   75.0   57.1   88.9  100.0    1.9   87.5
\&        ...Workflow/Persister/DBI.pm   75.3   51.2   25.0   83.3  100.0    7.4   67.5
\&        ...er/DBI/AutoGeneratedId.pm   77.8   40.0    n/a  100.0  100.0    0.4   70.1
\&        ...ersister/DBI/ExtraData.pm   25.9    0.0    0.0   71.4  100.0    0.1   22.9
\&        ...rsister/DBI/SequenceId.pm   56.2    0.0    0.0   75.0  100.0    0.3   53.1
\&        ...orkflow/Persister/File.pm   94.4   48.0   33.3  100.0  100.0    2.1   83.1
\&        ...low/Persister/RandomId.pm  100.0    n/a  100.0  100.0  100.0    1.8  100.0
\&        ...rkflow/Persister/SPOPS.pm   89.6   50.0    n/a  100.0  100.0    0.3   85.0
\&        ...orkflow/Persister/UUID.pm  100.0    n/a    n/a  100.0  100.0    0.2  100.0
\&        blib/lib/Workflow/State.pm     74.4   44.2   25.0   91.7  100.0   11.0   64.3
\&        ...lib/Workflow/Validator.pm  100.0  100.0    n/a  100.0  100.0    1.1  100.0
\&        ...dator/HasRequiredField.pm   90.0   50.0    n/a  100.0  100.0    0.6   86.7
\&        ...dator/InEnumeratedType.pm  100.0  100.0    n/a  100.0  100.0    0.4  100.0
\&        ...ator/MatchesDateFormat.pm   93.3   70.0   66.7  100.0  100.0    0.8   88.2
\&        Total                          83.9   54.7   39.7   93.0  100.0  100.0   76.8
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.Ve
.PP
Activities to get improved coverage are ongoing.
.SH "QUALITY ASSURANCE"
.IX Header "QUALITY ASSURANCE"
The Workflow project utilizes Perl::Critic in an attempt to avoid common
pitfalls and programming mistakes.
.PP
The static analysis performed by Perl::Critic is integrated into the \*(L"\s-1TEST\*(R"\s0
tool chain and is performed either by running the test suite.
.PP
.Vb 1
\&        % ./Build test
.Ve
.PP
Or by running the test file containing the Perl::Critic tests explicitly.
.PP
.Vb 1
\&        % ./Build test \-\-verbose 1 \-\-test_files t/04_critic.t
.Ve
.PP
Or
.PP
.Vb 1
\&        % perl t/critic.t
.Ve
.PP
The test does however require that the \s-1TEST_AUTHOR\s0 flag is set since this is
regarded as a part of the developer tool chain and we do not want to disturb
users and \s-1CPAN\s0 testers with this.
.PP
The following policies are disabled
.IP "\(bu" 4
Perl::Critic::Policy::ValuesAndExpressions::ProhibitMagicNumbers
.IP "\(bu" 4
Perl::Critic::Policy::Subroutines::ProhibitExplicitReturnUndef
.IP "\(bu" 4
Perl::Critic::Policy::NamingConventions::ProhibitAmbiguousNames
.IP "\(bu" 4
Perl::Critic::Policy::ValuesAndExpressions::ProhibitConstantPragma
.PP
The complete policy configuration can be found in t/perlcriticrc.
.PP
Currently a large number other policies are disabled, but these are being
addressed as ongoing work and they will either be listed here or changes will
be applied, which will address the Workflow code's problematic areas from
Perl::Critic perspective.
.SH "CODING STYLE"
.IX Header "CODING STYLE"
Currently the code is formatted using Perl::Tidy. The resource file can be
downloaded from the central repository.
.PP
.Vb 1
\&        notes/perltidyrc
.Ve
.SH "PROJECT"
.IX Header "PROJECT"
The Workflow project is currently hosted with SourceForge.net and is listed on
Ohloh.
.IP "\s-1SF\s0.net: <http://perl\-workflow.sf.net>" 4
.IX Item "SF.net: <http://perl-workflow.sf.net>"
.PD 0
.IP "Ohloh: <https://www.ohloh.net/p/perl\-Workflow>" 4
.IX Item "Ohloh: <https://www.ohloh.net/p/perl-Workflow>"
.PD
.SS "\s-1REPOSITORY\s0"
.IX Subsection "REPOSITORY"
The code is kept under revision control using Subversion:
.IP "<https://perl\-workflow.svn.sourceforge.net/svnroot/perl\-workflow>" 4
.IX Item "<https://perl-workflow.svn.sourceforge.net/svnroot/perl-workflow>"
.SS "\s-1MAILING LIST\s0"
.IX Subsection "MAILING LIST"
The Workflow project has a mailing list for discussion of issues and
development. The list is low-traffic.
.IP "<http://sourceforge.net/mail/?group_id=177533> (including archive)" 4
.IX Item "<http://sourceforge.net/mail/?group_id=177533> (including archive)"
.SS "\s-1RSS FEEDS\s0"
.IX Subsection "RSS FEEDS"
.PD 0
.IP "Commit log <http://rss.gmane.org/messages/excerpts/gmane.comp.lang.perl.modules.workflow.scm>" 4
.IX Item "Commit log <http://rss.gmane.org/messages/excerpts/gmane.comp.lang.perl.modules.workflow.scm>"
.IP "Ohloh news <https://www.ohloh.net/p/perl\-Workflow/messages.rss>" 4
.IX Item "Ohloh news <https://www.ohloh.net/p/perl-Workflow/messages.rss>"
.IP "\s-1CPAN\s0 testers reports <http://cpantesters.perl.org/show/Workflow.rss> in matrix:" 4
.IX Item "CPAN testers reports <http://cpantesters.perl.org/show/Workflow.rss> in matrix:"
.PD
.SS "\s-1OTHER RESOURCES\s0"
.IX Subsection "OTHER RESOURCES"
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Workflow>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Workflow>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Workflow>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
November 2010 talk 'Workflow' given at Nordic Perl Workshop 2010 in Reykjavik,
Iceland by jonasbn
<http://www.slideshare.net/jonasbn/workflow\-npw2010>
.IP "\(bu" 4
August 2010 talk 'Workflow' given at YAPC::Europe 2010 in Pisa, Italy by jonasbn
<http://www.slideshare.net/jonasbn/workflow\-yapceu2010>
.IP "\(bu" 4
October 2004 talk 'Workflows in Perl' given to
pgh.pm by Chris Winters: <http://www.cwinters.com/pdf/workflow_pgh_pm.pdf>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 Chris Winters and Arvato Direct;
Copyright (c) 2004\-2017 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonas B. Nielsen (jonasbn) <jonasbn@cpan.org>, current maintainer.
.PP
Chris Winters <chris@cwinters.com>, original author.
.PP
The following folks have also helped out (listed here in no particular order):
.PP
Bug report from Petr Pisar resulted in release 1.48
.PP
Bug report from Tina Mu\*:ller (tinita) resulted in release 1.47
.PP
Patch from Oliver Welter resulting in release 1.46
.PP
Bug report from Slaven ReziX resulting in maintenance release 1.45
.PP
Feature and bug fix by dtikhonov resulting in 1.40 (first pull request on Github)
.PP
Se\*'rgio Alves, patch to timezone handling for workflow history deserialized using
\&\s-1DBI\s0 persister resulting in 1.38
.PP
Heiko Schlittermann for context serialization patch resulting in 1.36
.PP
Scott Harding, for lazy evaluation of conditions and for nested conditions, see
Changes file: 1.35
.PP
Oliver Welter, patch implementing custom workflows, see Changes file: 1.35 and
patch related to this in 1.37 and factory subclassing also in 1.35. Improvements
in logging for condition validation in 1.43 and 1.44
.PP
Steven van der Vegt, patch for autorun in initial state and improved exception
handling for validators, see Changes file: 1.34_1
.PP
Andrew O'Brien, patch implementing dynamic reloaded of flows, see Changes file:
1.33
.PP
Sergei Vyshenski, bug reports \- addressed and included in 1.33, Sergei also
maintains the FreeBSD port
.PP
Alejandro Imass, improvements and clarifications, see Changes file: 1.33
.PP
Danny Sadinoff, patches to give better control of initial state and history
records for workflow, see Changes file: 1.33
.PP
Thomas Erskine, for patch adding new accessors and fixing several bugs see
Changes file 1.33
.PP
Ivan Paponov, for patch implementing action groups, see Changes file, 1.33
.PP
Robert Stockdale, for patch implementing dynamic names for conditions, see
Changes file, 1.32
.PP
Jim Brandt, for patch to Workflow::Config::XML. See Changes file, 0.27 and 0.30
.PP
Alexander Klink, for: patches resulting in 0.23, 0.24, 0.25, 0.26 and 0.27
.PP
Michael Bell, for patch resulting in 0.22
.PP
Martin Bartosch, for bug reporting and giving the solution not even using a
patch (0.19 to 0.20) and a patch resulting in 0.21
.PP
Randal Schwartz, for testing 0.18 and swiftly giving feedback (0.18 to 0.19)
.PP
Chris Brown, for a patch to Workflow::Config::Perl (0.17 to 0.18)
.PP
Dietmar Hanisch <Dietmar.Hanisch@Bertelsmann.de> \- Provided
most of the good ideas for the module and an excellent example of
everyday use.
.PP
Tom Moertel <tmoertel@cpan.org> gave me the idea for being
able to attach event listeners (observers) to the process.
.PP
Michael Roberts <michael@vivtek.com> graciously released the
\&'Workflow' namespace on \s-1CPAN\s0; check out his Workflow toolkit at
<http://www.vivtek.com/wftk.html>.
.PP
Michael Schwern <schwern@pobox.org> barked via \s-1RT\s0 about a
dependency problem and \s-1CPAN\s0 naming issue.
.PP
Jim Smith <jgsmith@tamu.edu> \- Contributed patches (being able
to subclass Workflow::Factory) and good ideas.
.PP
Martin Winkler <mw@arsnavigandi.de> \- Pointed out a bug and a
few other items.
