.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::QuickDB::Pool 3"
.TH DBIx::QuickDB::Pool 3 "2020-08-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::QuickDB::Pool \- Define a pool of databases to clone on demand.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library lets you define a pool of databases to clone on demand. This lets
you incrementally build databases starting with a driver. Each database you
build can either be based of a previous one, or started from scratch.
.PP
This tool lets you buid multiple nested clean database trees. You can then
clone instances off these clean ones as needed.
.PP
This library can spin up clean copies of databases at any states you define,
and it can do so \s-1FAST\s0 by cloning data directories instead of building
everything back up from nothing.
.PP
This library will build databases on demand, no cost for databases you define
but never use.
.PP
This library will rebuild databases when schema files or installed database
version change.
.PP
This library can be used by concurrent processes that may try to build/consume
the same databases from the same cache dir.
.SH "DECLARATIVE SYNOPSIS"
.IX Header "DECLARATIVE SYNOPSIS"
.SS "\s-1YOUR POOL LIBRARY\s0"
.IX Subsection "YOUR POOL LIBRARY"
.Vb 3
\&    package My::Pool;
\&    use strict;
\&    use warnings;
\&
\&    use DBIx::QuickDB::Pool cache_dir => "$ENV{HOME}/databases";
\&
\&    # This will define a clean database called \*(AqPostgreSQL\*(Aq that we can always
\&    # clone, or build on top of.
\&    driver \*(AqPostgreSQL\*(Aq;
\&
\&    build schema => (
\&        # This one will be built on top of a clone of the \*(AqPostgreSQL\*(Aq clean
\&        # db.
\&        from => \*(AqPostgreSQL\*(Aq,
\&
\&        # You must provide a way to invalidate the current, usually this would
\&        # return a sha1 of the schema files or similar. If you do not want it
\&        # to detect changes just have the subroutine return a string such as
\&        # "never changes".
\&        checksum => sub { ...; return "something" },
\&
\&        # Any database you define, apart from drivers, needs a build callback
\&        build => sub {
\&            my $class = shift; # The current package
\&            my ($db) = @_;
\&
\&            # $db will already be started for you, and will be stopped as soon
\&            # as this sub returns.
\&
\&            @ Load the schema
\&            $db\->load_sql(myapp => "path/to/myapp_schema.sql");
\&        },
\&    );
\&
\&    build scenario_foo => (
\&        from => \*(Aqschema\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqfoo\*(Aq ...
\&        },
\&    );
\&
\&    build scenario_bar => (
\&        from => \*(Aqschema\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqbar\*(Aq ...
\&        },
\&    );
\&
\&    build scenario_foo_and_bar => (
\&        from => \*(Aqfoo\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqbar\*(Aq ...
\&        },
\&    );
\&
\&    1;
.Ve
.SS "\s-1POOL CONSUMERS\s0"
.IX Subsection "POOL CONSUMERS"
.Vb 2
\&    # This will import db() from the My::Pool library.
\&    use Importer \*(AqMy::Pool\*(Aq => \*(Aqdb\*(Aq;
\&
\&    # This will return a new clone of foo, changing it will not effect the
\&    # original \*(Aqfoo\*(Aq built by the library.
\&    my $clone_of_foo = db(\*(Aqfoo\*(Aq);
\&
\&    # Same for bar
\&    my $clone_of_bar = db(\*(Aqbar\*(Aq);
\&
\&    # This gets a NEW clone of \*(Aqfoo\*(Aq. Changes in this db will NOT effect
\&    # $clone_of_foo.
\&    my $other_clone_of_foo = db(\*(Aqfoo\*(Aq);
\&
\&    ... Change Schema ...
\&
\&    # This will rebuild schema, then rebuild foo using the new schema.
\&    # (If update_checksums has not been turned off)
\&    my $fresh_foo = db(\*(Aqfoo\*(Aq);
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.ie n .IP "$pool = \s-1\fBQDB_POOL\s0()\fR" 4
.el .IP "\f(CW$pool\fR = \s-1\fBQDB_POOL\s0()\fR" 4
.IX Item "$pool = QDB_POOL()"
This will return the instance of \f(CW\*(C`DBIx::QuickDB::Pool\*(C'\fR associated with your
package.
.ie n .IP "driver $DRIVER" 4
.el .IP "driver \f(CW$DRIVER\fR" 4
.IX Item "driver $DRIVER"
.PD 0
.ie n .IP "driver $DRIVER => (%SPEC)" 4
.el .IP "driver \f(CW$DRIVER\fR => (%SPEC)" 4
.IX Item "driver $DRIVER => (%SPEC)"
.PD
Define a new driver you can use as a basis for your database states.
.Sp
\&\f(CW$DRIVER\fR can be shorthand \f(CW\*(AqPostgreSQL\*(Aq\fR or it can be fully qualified if you
prefix it with a '+' \f(CW\*(Aq+DBIx::QuickDB::Driver::PostgreSQL\*(Aq\fR.
.Sp
The name will be the last part of the driver package name Example:
\&\f(CW\*(AqPostgreSQL\*(Aq\fR unless you override it.
.Sp
The following specifications are allowed:
.RS 4
.ie n .IP "name => $NAME" 4
.el .IP "name => \f(CW$NAME\fR" 4
.IX Item "name => $NAME"
You can use this to override the default database name.
.IP "checksum => sub { ... }" 4
.IX Item "checksum => sub { ... }"
.PD 0
.ie n .IP "checksum => ""method_name""" 4
.el .IP "checksum => ``method_name''" 4
.IX Item "checksum => method_name"
.PD
You can use this to override the default checksum calculator drivers use.
Normally the default will return a sha1 of the version information of the
locally installed database tools.
.Sp
This can be a subref, or the name of a method defined on your package.
.IP "build => sub { ... }" 4
.IX Item "build => sub { ... }"
.PD 0
.ie n .IP "build => ""method_name""" 4
.el .IP "build => ``method_name''" 4
.IX Item "build => method_name"
.PD
This is not necessary on a driver database, however if you want to do anything
to the clean database before anything builds off of it you can. If you only
have 1 schema to load you can pop it in here instead of creating a schema
specific database. Keep in mind you will have to manage checksum calculation
for both, and this will have to be rebuilt for both schema changes and db tool
version changes.
.Sp
This can be a subref, or the name of a method defined on your package.
.IP "driver_args => \e%ARGS" 4
.IX Item "driver_args => %ARGS"
You can pass in a hashref of arguments to pass into the driver when
initializing the database:
.Sp
.Vb 1
\&    driver_args => { verbose => 0, autostart => 0, autostop => 1 },
.Ve
.IP "clone_args => \e%ARGS" 4
.IX Item "clone_args => %ARGS"
Same as driver_args, except these are used when cloning a database. This will
be inherited by databases that are built off of this one.
.RE
.RS 4
.RE
.ie n .IP "build $NAME => (from => $PARENT_OR_DRIVER, build => \e&BUILDER, checksum => \e&CHECKSUM)" 4
.el .IP "build \f(CW$NAME\fR => (from => \f(CW$PARENT_OR_DRIVER\fR, build => \e&BUILDER, checksum => \e&CHECKSUM)" 4
.IX Item "build $NAME => (from => $PARENT_OR_DRIVER, build => &BUILDER, checksum => &CHECKSUM)"
.PD 0
.ie n .IP "build $NAME => (from => $PARENT_OR_DRIVER, build => $BUILDER_METHOD_NAME, checksum => $CHECKSUM_METHOD_NAME)" 4
.el .IP "build \f(CW$NAME\fR => (from => \f(CW$PARENT_OR_DRIVER\fR, build => \f(CW$BUILDER_METHOD_NAME\fR, checksum => \f(CW$CHECKSUM_METHOD_NAME\fR)" 4
.IX Item "build $NAME => (from => $PARENT_OR_DRIVER, build => $BUILDER_METHOD_NAME, checksum => $CHECKSUM_METHOD_NAME)"
.ie n .IP "build $NAME => (%SPEC)" 4
.el .IP "build \f(CW$NAME\fR => (%SPEC)" 4
.IX Item "build $NAME => (%SPEC)"
.PD
Define a new database state with the given \f(CW$NAME\fR.
.Sp
The following specifications are available:
.RS 4
.ie n .IP "from => $PARENT_OR_DRIVER" 4
.el .IP "from => \f(CW$PARENT_OR_DRIVER\fR" 4
.IX Item "from => $PARENT_OR_DRIVER"
This specifies the parent database or driver to build off of.
.IP "build => sub { ... }" 4
.IX Item "build => sub { ... }"
.PD 0
.ie n .IP "build => $BUILDER_METHOD_NAME" 4
.el .IP "build => \f(CW$BUILDER_METHOD_NAME\fR" 4
.IX Item "build => $BUILDER_METHOD_NAME"
.PD
Any database that is not a base driver needs to do build some kind of state to
be useful. An example is loading schema, or loading fixture data. This is where
you do that.
.Sp
.Vb 3
\&    sub {
\&        my $class = shift;
\&        my ($db) = @_;
\&
\&        # $db will already be started for you
\&        $db\->load_sql(myapp => "path/to/myapp_schema.sql");
\&
\&        # $db will be stopped for you automatically.
\&    }
.Ve
.IP "checksum => sub { ... }" 4
.IX Item "checksum => sub { ... }"
.PD 0
.ie n .IP "checksum => $CHECKSUM_METHOD_NAME" 4
.el .IP "checksum => \f(CW$CHECKSUM_METHOD_NAME\fR" 4
.IX Item "checksum => $CHECKSUM_METHOD_NAME"
.PD
This must return a string. If the data this database is built from will never
change you can return a constant string. If the data can change you should
probably either return a version string, or a sha1 of the data.
.Sp
This is used to check if a database needs to be rebuilt due to external
changes, such as a \f(CW\*(C`schema.sql\*(C'\fR file being modified.
.IP "clone_args => \e%ARGS" 4
.IX Item "clone_args => %ARGS"
You can pass in a hashref of arguments to pass into the driver when
cloning the database:
.Sp
.Vb 1
\&    clone_args => { verbose => 0, autostart => 0, autostop => 1 },
.Ve
.Sp
This will be inherited by databases that are built off of this one. This will
also override any that may have been inherited from a parent.
.RE
.RS 4
.RE
.ie n .IP "$db = db($NAME)" 4
.el .IP "\f(CW$db\fR = db($NAME)" 4
.IX Item "$db = db($NAME)"
Fetch a fresh clone of the specified database. This will be an isolated copy
that you can play with. Neither the original nor any other copy will be
effected by anything you do. When you are done simply disgard the copy.
.Sp
If the database, or ant of its parents have not been built yet, they will be
built before you get your fresh copy. The first time this is called may be
slow, but future calls will use cached data making them very fast.
.ie n .IP "@EXPORT_OK" 4
.el .IP "\f(CW@EXPORT_OK\fR" 4
.IX Item "@EXPORT_OK"
\&\f(CW\*(C`db()\*(C'\fR is added to your packages \f(CW@EXPORT_OK\fR variable on import. This allows
other modules to import the method in order to get clones of the databases you
defined.
.Sp
.Vb 1
\&    use Importer \*(AqMy::Pool\*(Aq => \*(Aqdb\*(Aq;
\&
\&    my $db = db(\*(Aqfoo\*(Aq);
.Ve
.SH "OO SYNOPSIS"
.IX Header "OO SYNOPSIS"
.Vb 1
\&    use DBIx::Class::Pool();
\&
\&    my $pool = DBIx::Class::Pool\->new(
\&        cache_dir => "$ENV{HOME}/databases",
\&    );
\&
\&    # This will define a clean database called \*(AqPostgreSQL\*(Aq that we can always
\&    # clone, or build on top of.
\&    $pool\->add_driver(\*(AqPostgreSQL\*(Aq);
\&
\&    $pool\->add_db(
\&        \*(Aqschema\*(Aq,
\&
\&        # This one will be built on top of a clone of the \*(AqPostgreSQL\*(Aq clean
\&        # db.
\&        from => \*(AqPostgreSQL\*(Aq,
\&
\&        # You must provide a way to invalidate the current, usually this would
\&        # return a sha1 of the schema files or similar. If you do not want it
\&        # to detect changes just have the subroutine return a string such as
\&        # "never changes".
\&        checksum => sub { ...; return "something" },
\&
\&        # Any database you define, apart from drivers, needs a build callback
\&        build => sub {
\&            my $class = shift; # The current package
\&            my ($db) = @_;
\&
\&            # $db will already be started for you, and will be stopped as soon
\&            # as this sub returns.
\&
\&            @ Load the schema
\&            $db\->load_sql(myapp => "path/to/myapp_schema.sql");
\&        },
\&    );
\&
\&    $pool\->add_db(
\&        \*(Aqscenario_foo\*(Aq,
\&        from => \*(Aqschema\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqfoo\*(Aq ...
\&        },
\&    );
\&
\&    $pool\->add_db(
\&        \*(Aqscenario_bar\*(Aq,
\&        from => \*(Aqschema\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqbar\*(Aq ...
\&        },
\&    );
\&
\&    $pool\->add_db(
\&        \*(Aqscenario_foo_and_bar\*(Aq,
\&        from => \*(Aqfoo\*(Aq,
\&        checksum => sub { ... },
\&        build => sub {
\&            my $class = shift;
\&            my ($db) = @_;
\&
\&            ... Load data for scenario \*(Aqbar\*(Aq ...
\&        },
\&    );
.Ve
.PP
And to then use the databases:
.PP
.Vb 3
\&    # This will return a new clone of foo, changing it will not effect the
\&    # original \*(Aqfoo\*(Aq built by the library.
\&    my $clone_of_foo = $pool\->fetch_db(\*(Aqfoo\*(Aq);
\&
\&    # Same for bar
\&    my $clone_of_bar = $pool\->fetch_db(\*(Aqbar\*(Aq);
\&
\&    # This gets a NEW clone of \*(Aqfoo\*(Aq. Changes in this db will NOT effect
\&    # $clone_of_foo.
\&    my $other_clone_of_foo = $pool\->fetch_db(\*(Aqfoo\*(Aq);
\&
\&    ... Change Schema ...
\&
\&    # This will rebuild schema, then rebuild foo using the new schema.
\&    # (If update_checksums has not been turned off)
\&    my $fresh_foo = $pool\->db(\*(Aqfoo\*(Aq);
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.ie n .IP "cache_dir => ""path/to/cache""" 4
.el .IP "cache_dir => ``path/to/cache''" 4
.IX Item "cache_dir => path/to/cache"
Required.
.Sp
Can only be specified at import or construction.
.Sp
No accessors.
.ie n .IP "library => $PACKAGE" 4
.el .IP "library => \f(CW$PACKAGE\fR" 4
.IX Item "library => $PACKAGE"
.PD 0
.ie n .IP "$pkg = $pool\->library" 4
.el .IP "\f(CW$pkg\fR = \f(CW$pool\fR\->library" 4
.IX Item "$pkg = $pool->library"
.PD
Set automatically from caller during construction unless specified.
.Sp
Can be read, but not modified.
.ie n .IP "update_checksums => $BOOL" 4
.el .IP "update_checksums => \f(CW$BOOL\fR" 4
.IX Item "update_checksums => $BOOL"
.PD 0
.ie n .IP "$bool = $pool\->\fBupdate_checksums()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$pool\fR\->\fBupdate_checksums()\fR" 4
.IX Item "$bool = $pool->update_checksums()"
.ie n .IP "$pool\->set_update_checksums($bool)" 4
.el .IP "\f(CW$pool\fR\->set_update_checksums($bool)" 4
.IX Item "$pool->set_update_checksums($bool)"
.PD
Defaults to true.
.Sp
Can be set during construction, or altered at any time.
.Sp
When true checksums will be recalculated every time a database is requested, if
any checksum has changed since the last time they were built then all db
downstream of the changed checksum will be rebuilt to account for the changes.
.Sp
Most of the time you want this to be on so that databases are rebuilt if schema
changes or a new version of the drivers are installed. However if you are not
worried about changes, or checksum calculation is expensive for your pool you
can turn this off.
.Sp
\&\fB\s-1NOTE:\s0\fR even when this is turned on, no exisitng/active databases will be
rebuilt. To get changes you need to close connections tot he db, stop it, and
request it again via \f(CW\*(C`db($NAME)\*(C'\fR or \f(CW\*(C`$pool\->fetch_db($NAME)\*(C'\fR to get an
updated build.
.ie n .IP "purge_old => $BOOL" 4
.el .IP "purge_old => \f(CW$BOOL\fR" 4
.IX Item "purge_old => $BOOL"
.PD 0
.ie n .IP "$bool = $pool\->\fBpurge_old()\fR" 4
.el .IP "\f(CW$bool\fR = \f(CW$pool\fR\->\fBpurge_old()\fR" 4
.IX Item "$bool = $pool->purge_old()"
.ie n .IP "$pool\->set_purge_old($bool)" 4
.el .IP "\f(CW$pool\fR\->set_purge_old($bool)" 4
.IX Item "$pool->set_purge_old($bool)"
.PD
Defaults to false.
.Sp
Can be set during construction or changed at any time.
.Sp
When true old builds will be deleted from cache whenever they expire.
.Sp
\&\fB\s-1NOTE:\s0\fR \s-1THIS IS NOT RECOMMENDED\s0 when multiple processes share a cache dir,
such as during concurrent unit testing.
.ie n .IP "verbose => $POSITIVE_INTEGER" 4
.el .IP "verbose => \f(CW$POSITIVE_INTEGER\fR" 4
.IX Item "verbose => $POSITIVE_INTEGER"
.PD 0
.ie n .IP "$POSITIVE_INTEGER = $pool\->\fBverbose()\fR" 4
.el .IP "\f(CW$POSITIVE_INTEGER\fR = \f(CW$pool\fR\->\fBverbose()\fR" 4
.IX Item "$POSITIVE_INTEGER = $pool->verbose()"
.ie n .IP "$pool\->set_verbose($POSITIVE_INTEGER)" 4
.el .IP "\f(CW$pool\fR\->set_verbose($POSITIVE_INTEGER)" 4
.IX Item "$pool->set_verbose($POSITIVE_INTEGER)"
.PD
Defaults to \f(CW0\fR.
.Sp
Can be set during construction or changed at any time.
.Sp
When set to \f(CW1\fR or greater diagnostics messages about what the pool is doing
will be printed. In addition database command output will be displayed unless
you have overriden the verbose parameter in the driver_args or clone_args
settings.
.Sp
When set to \f(CW2\fR or greater the diagnostic messages will be sent to \s-1STDERR\s0
instead of \s-1STDOUT.\s0
.Sp
When set to \f(CW3\fR or greater you will also see the output of the copy commands
that clone the database data directories.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1INTERFACE\s0"
.IX Subsection "INTERFACE"
.ie n .IP "$pool\->add_driver($DRIVER)" 4
.el .IP "\f(CW$pool\fR\->add_driver($DRIVER)" 4
.IX Item "$pool->add_driver($DRIVER)"
.PD 0
.ie n .IP "$pool\->add_driver($DRIVER, %SPEC)" 4
.el .IP "\f(CW$pool\fR\->add_driver($DRIVER, \f(CW%SPEC\fR)" 4
.IX Item "$pool->add_driver($DRIVER, %SPEC)"
.PD
Define a new driver you can use as a basis for your database states.
.Sp
\&\f(CW$DRIVER\fR can be shorthand \f(CW\*(AqPostgreSQL\*(Aq\fR or it can be fully qualified if you
prefix it with a '+' \f(CW\*(Aq+DBIx::QuickDB::Driver::PostgreSQL\*(Aq\fR.
.Sp
The name will be the last part of the driver package name Example:
\&\f(CW\*(AqPostgreSQL\*(Aq\fR unless you override it.
.Sp
The following specifications are allowed:
.RS 4
.ie n .IP "name => $NAME" 4
.el .IP "name => \f(CW$NAME\fR" 4
.IX Item "name => $NAME"
You can use this to override the default database name.
.IP "checksum => sub { ... }" 4
.IX Item "checksum => sub { ... }"
.PD 0
.ie n .IP "checksum => ""method_name""" 4
.el .IP "checksum => ``method_name''" 4
.IX Item "checksum => method_name"
.PD
You can use this to override the default checksum calculator drivers use.
Normally the default will return a sha1 of the version information of the
locally installed database tools.
.Sp
This can be a subref, or the name of a method defined on your package.
.IP "build => sub { ... }" 4
.IX Item "build => sub { ... }"
.PD 0
.ie n .IP "build => ""method_name""" 4
.el .IP "build => ``method_name''" 4
.IX Item "build => method_name"
.PD
This is not necessary on a driver database, however if you want to do anything
to the clean database before anything builds off of it you can. If you only
have 1 schema to load you can pop it in here instead of creating a schema
specific database. Keep in mind you will have to manage checksum calculation
for both, and this will have to be rebuilt for both schema changes and db tool
version changes.
.Sp
This can be a subref, or the name of a method defined on your package.
.IP "driver_args => \e%ARGS" 4
.IX Item "driver_args => %ARGS"
You can pass in a hashref of arguments to pass into the driver when
initializing the database:
.Sp
.Vb 1
\&    driver_args => { verbose => 0, autostart => 0, autostop => 1 },
.Ve
.IP "clone_args => \e%ARGS" 4
.IX Item "clone_args => %ARGS"
Same as driver_args, except these are used when cloning a database. This will
be inherited by databases that are built off of this one.
.RE
.RS 4
.RE
.ie n .IP "$pool\->add_db(from => $PARENT_OR_DRIVER, build => \e&BUILDER)" 4
.el .IP "\f(CW$pool\fR\->add_db(from => \f(CW$PARENT_OR_DRIVER\fR, build => \e&BUILDER)" 4
.IX Item "$pool->add_db(from => $PARENT_OR_DRIVER, build => &BUILDER)"
.PD 0
.ie n .IP "$pool\->add_db(from => $PARENT_OR_DRIVER, build => $BUILDER_METHOD_NAME)" 4
.el .IP "\f(CW$pool\fR\->add_db(from => \f(CW$PARENT_OR_DRIVER\fR, build => \f(CW$BUILDER_METHOD_NAME\fR)" 4
.IX Item "$pool->add_db(from => $PARENT_OR_DRIVER, build => $BUILDER_METHOD_NAME)"
.ie n .IP "$pool\->add_db(%SPEC)" 4
.el .IP "\f(CW$pool\fR\->add_db(%SPEC)" 4
.IX Item "$pool->add_db(%SPEC)"
.PD
Define a new database state with the given \f(CW$NAME\fR.
.Sp
The following specifications are available:
.RS 4
.ie n .IP "from => $PARENT_OR_DRIVER" 4
.el .IP "from => \f(CW$PARENT_OR_DRIVER\fR" 4
.IX Item "from => $PARENT_OR_DRIVER"
This specifies the parent database or driver to build off of.
.IP "build => sub { ... }" 4
.IX Item "build => sub { ... }"
.PD 0
.ie n .IP "build => $BUILDER_METHOD_NAME" 4
.el .IP "build => \f(CW$BUILDER_METHOD_NAME\fR" 4
.IX Item "build => $BUILDER_METHOD_NAME"
.PD
Any database that is not a base driver needs to do build some kind of state to
be useful. An example is loading schema, or loading fixture data. This is where
you do that.
.Sp
.Vb 3
\&    sub {
\&        my $class = shift;
\&        my ($db) = @_;
\&
\&        # $db will already be started for you
\&        $db\->load_sql(myapp => "path/to/myapp_schema.sql");
\&
\&        # $db will be stopped for you automatically.
\&    }
.Ve
.IP "checksum => sub { ... }" 4
.IX Item "checksum => sub { ... }"
.PD 0
.ie n .IP "checksum => $CHECKSUM_METHOD_NAME" 4
.el .IP "checksum => \f(CW$CHECKSUM_METHOD_NAME\fR" 4
.IX Item "checksum => $CHECKSUM_METHOD_NAME"
.PD
This must return a string. If the data this database is built from will never
change you can return a constant string. If the data can change you should
probably either return a version string, or a sha1 of the data.
.Sp
This is used to check if a database needs to be rebuilt due to external
changes, such as a \f(CW\*(C`schema.sql\*(C'\fR file being modified.
.IP "clone_args => \e%ARGS" 4
.IX Item "clone_args => %ARGS"
You can pass in a hashref of arguments to pass into the driver when
cloning the database:
.Sp
.Vb 1
\&    clone_args => { verbose => 0, autostart => 0, autostop => 1 },
.Ve
.Sp
This will be inherited by databases that are built off of this one. This will
also override any that may have been inherited from a parent.
.RE
.RS 4
.RE
.ie n .IP "$db = $pool\->fetch_db($NAME)" 4
.el .IP "\f(CW$db\fR = \f(CW$pool\fR\->fetch_db($NAME)" 4
.IX Item "$db = $pool->fetch_db($NAME)"
Fetch a fresh clone of the specified database. This will be an isolated copy
that you can play with. Neither the original nor any other copy will be
effected by anything you do. When you are done simply disgard the copy.
.Sp
If the database, or ant of its parents have not been built yet, they will be
built before you get your fresh copy. The first time this is called may be
slow, but future calls will use cached data making them very fast.
.ie n .IP "$pool\->clear_old_cache($age_in_seconds);" 4
.el .IP "\f(CW$pool\fR\->clear_old_cache($age_in_seconds);" 4
.IX Item "$pool->clear_old_cache($age_in_seconds);"
This will check all database directories in the cashe dir to see when they were
last cloned, if the last clone was at or before the specified age then the dir
will be deleted.
.SS "\s-1INTERNAL\s0"
.IX Subsection "INTERNAL"
Listed for completeness, but you should not use these, except maybe in a
subclass.
.PP
\fI\s-1DB BUILDING\s0\fR
.IX Subsection "DB BUILDING"
.ie n .IP "$pool\->\fBbuild_db()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBbuild_db()\fR" 4
.IX Item "$pool->build_db()"
.PD 0
.ie n .IP "$pool\->\fBbuild_via_clone()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBbuild_via_clone()\fR" 4
.IX Item "$pool->build_via_clone()"
.ie n .IP "$pool\->\fBbuild_via_driver()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBbuild_via_driver()\fR" 4
.IX Item "$pool->build_via_driver()"
.ie n .IP "$pool\->\fBvivify_db()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBvivify_db()\fR" 4
.IX Item "$pool->vivify_db()"
.ie n .IP "$pool\->\fBreclaim()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBreclaim()\fR" 4
.IX Item "$pool->reclaim()"
.PD
.PP
\fI\s-1CHECKSUM/CACHE VALIDATION\s0\fR
.IX Subsection "CHECKSUM/CACHE VALIDATION"
.ie n .IP "$pool\->\fBcache_check()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBcache_check()\fR" 4
.IX Item "$pool->cache_check()"
.PD 0
.ie n .IP "$pool\->\fBdriver_checksum()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBdriver_checksum()\fR" 4
.IX Item "$pool->driver_checksum()"
.PD
.PP
\fI\s-1IPC\s0\fR
.IX Subsection "IPC"
.ie n .IP "$pool\->\fBlock()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBlock()\fR" 4
.IX Item "$pool->lock()"
.PD 0
.ie n .IP "$pool\->\fBunlock()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBunlock()\fR" 4
.IX Item "$pool->unlock()"
.PD
.PP
\fI\s-1DIAGNOSTICS\s0\fR
.IX Subsection "DIAGNOSTICS"
.ie n .IP "$pool\->\fBthrow()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBthrow()\fR" 4
.IX Item "$pool->throw()"
.PD 0
.ie n .IP "$pool\->\fBalert()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBalert()\fR" 4
.IX Item "$pool->alert()"
.ie n .IP "$pool\->\fBdiag()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBdiag()\fR" 4
.IX Item "$pool->diag()"
.PD
.PP
\fI\s-1MISC\s0\fR
.IX Subsection "MISC"
.ie n .IP "$pool\->\fBexport()\fR" 4
.el .IP "\f(CW$pool\fR\->\fBexport()\fR" 4
.IX Item "$pool->export()"
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for DBIx-QuickDB can be found at
\&\fIhttps://github.com/exodist/DBIx\-QuickDB/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
