.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Chrome::DevToolsProtocol 3"
.TH Chrome::DevToolsProtocol 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Chrome::DevToolsProtocol \- asynchronous dispatcher for the DevTools protocol
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    # Usually, WWW::Mechanize::Chrome automatically creates a driver for you
\&    my $driver = Chrome::DevToolsProtocol\->new(
\&        port => 9222,
\&        host => \*(Aq127.0.0.1\*(Aq,
\&        auto_close => 0,
\&        error_handler => sub {
\&            # Reraise the error
\&            croak $_[1]
\&        },
\&    );
\&    $driver\->connect( new_tab => 1 )\->get
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """\->new( %args )"""
.el .SS "\f(CW\->new( %args )\fP"
.IX Subsection "->new( %args )"
.Vb 9
\&    my $driver = Chrome::DevToolsProtocol\->new(
\&        port => 9222,
\&        host => \*(Aq127.0.0.1\*(Aq,
\&        auto_close => 0,
\&        error_handler => sub {
\&            # Reraise the error
\&            croak $_[1]
\&        },
\&    );
.Ve
.PP
These members can mostly be set through the constructor arguments:
.IP "\fBhost\fR" 4
.IX Item "host"
The hostname to connect to
.IP "\fBport\fR" 4
.IX Item "port"
The port to connect to
.IP "\fBjson\fR" 4
.IX Item "json"
The \s-1JSON\s0 decoder used
.IP "\fBua\fR" 4
.IX Item "ua"
The Future::HTTP instance to talk to the Chrome DevTools
.IP "\fBtab\fR" 4
.IX Item "tab"
Which tab to reuse (if any)
.IP "\fBlog\fR" 4
.IX Item "log"
A premade Log::Log4perl object to act as logger
.IP "\fBon_message\fR" 4
.IX Item "on_message"
A callback invoked for every message
.IP "\fBtransport\fR" 4
.IX Item "transport"
The event-loop specific transport backend
.ie n .SS """\->future"""
.el .SS "\f(CW\->future\fP"
.IX Subsection "->future"
.Vb 1
\&    my $f = $driver\->future();
.Ve
.PP
Returns a backend-specific generic future
.ie n .SS """\->endpoint"""
.el .SS "\f(CW\->endpoint\fP"
.IX Subsection "->endpoint"
.Vb 1
\&    my $url = $driver\->endpoint();
.Ve
.PP
Returns the \s-1URL\s0 endpoint to talk to for the connected tab
.ie n .SS """\->add_listener"""
.el .SS "\f(CW\->add_listener\fP"
.IX Subsection "->add_listener"
.Vb 6
\&    my $l = $driver\->add_listener(
\&        \*(AqPage.domContentEventFired\*(Aq,
\&        sub {
\&            warn "The DOMContent event was fired";
\&        },
\&    );
\&
\&    # ...
\&
\&    undef $l; # stop listening
.Ve
.PP
Adds a callback for the given event name. The callback will be removed once
the return value goes out of scope.
.ie n .SS """\->remove_listener"""
.el .SS "\f(CW\->remove_listener\fP"
.IX Subsection "->remove_listener"
.Vb 1
\&    $driver\->remove_listener($l);
.Ve
.PP
Explicitly remove a listener.
.ie n .SS """\->log"""
.el .SS "\f(CW\->log\fP"
.IX Subsection "->log"
.Vb 1
\&    $driver\->log(\*(Aqdebug\*(Aq, "Warbling doodads", { doodad => \*(Aqthis\*(Aq } );
.Ve
.PP
Log a message
.ie n .SS """\->connect"""
.el .SS "\f(CW\->connect\fP"
.IX Subsection "->connect"
.Vb 1
\&    my $f = $driver\->connect()\->get;
.Ve
.PP
Asynchronously connect to the Chrome browser, returning a Future.
.ie n .SS """\->close"""
.el .SS "\f(CW\->close\fP"
.IX Subsection "->close"
.Vb 1
\&    $driver\->close();
.Ve
.PP
Shut down the connection to Chrome
.ie n .SS """\->sleep"""
.el .SS "\f(CW\->sleep\fP"
.IX Subsection "->sleep"
.Vb 1
\&    $driver\->sleep(0.2)\->get;
.Ve
.PP
Sleep for the amount of seconds in an event-loop compatible way
.ie n .SS """\->one_shot"""
.el .SS "\f(CW\->one_shot\fP"
.IX Subsection "->one_shot"
.Vb 1
\&    my $f = $driver\->one_shot(\*(AqPage.domContentEventFired\*(Aq)\->get;
.Ve
.PP
Returns a future that resolves when the event is received
.ie n .SS """$chrome\->json_get"""
.el .SS "\f(CW$chrome\->json_get\fP"
.IX Subsection "$chrome->json_get"
.Vb 1
\&    my $data = $driver\->json_get( \*(Aqversion\*(Aq )\->get;
.Ve
.PP
Requests an \s-1URL\s0 and returns decoded \s-1JSON\s0 from the future
.ie n .SS """$chrome\->send_packet"""
.el .SS "\f(CW$chrome\->send_packet\fP"
.IX Subsection "$chrome->send_packet"
.Vb 3
\&  $chrome\->send_packet(\*(AqPage.handleJavaScriptDialog\*(Aq,
\&      accept => JSON::true,
\&  );
.Ve
.PP
Sends a \s-1JSON\s0 packet to the remote end
.ie n .SS """$chrome\->send_message"""
.el .SS "\f(CW$chrome\->send_message\fP"
.IX Subsection "$chrome->send_message"
.Vb 5
\&  my $future = $chrome\->send_message(\*(AqDOM.querySelectorAll\*(Aq,
\&      selector => \*(Aqp\*(Aq,
\&      nodeId => $node,
\&  );
\&  my $nodes = $future\->get;
.Ve
.PP
This function expects a response. The future will not be resolved until Chrome
has sent a response to this query.
.ie n .SS """$chrome\->callFunctionOn"""
.el .SS "\f(CW$chrome\->callFunctionOn\fP"
.IX Subsection "$chrome->callFunctionOn"
.ie n .SS """$chrome\->evaluate"""
.el .SS "\f(CW$chrome\->evaluate\fP"
.IX Subsection "$chrome->evaluate"
.ie n .SS """$chrome\->eval"""
.el .SS "\f(CW$chrome\->eval\fP"
.IX Subsection "$chrome->eval"
.Vb 1
\&    my $result = $chrome\->eval(\*(Aq2+2\*(Aq);
.Ve
.PP
Evaluates a Javascript string and returns the result.
.ie n .SS """$chrome\->version_info"""
.el .SS "\f(CW$chrome\->version_info\fP"
.IX Subsection "$chrome->version_info"
.Vb 1
\&    print $chrome\->version_info\->get\->{"Protocol\-Version"};
.Ve
.PP
Returns the implemented ChromeDevTooslProtocol protocol version.
.ie n .SS """$chrome\->protocol_version"""
.el .SS "\f(CW$chrome\->protocol_version\fP"
.IX Subsection "$chrome->protocol_version"
.Vb 1
\&    print $chrome\->protocol_version\->get;
.Ve
.ie n .SS """$target\->getVersion"""
.el .SS "\f(CW$target\->getVersion\fP"
.IX Subsection "$target->getVersion"
Returns information about the Chrome instance we are connected to.
.ie n .SS """$chrome\->get_domains"""
.el .SS "\f(CW$chrome\->get_domains\fP"
.IX Subsection "$chrome->get_domains"
.Vb 1
\&    my $schema = $chrome\->get_domains\->get;
.Ve
.PP
Returns the topics of this Chrome DevToolsProtocol implementation.
.ie n .SS """$chrome\->list_tabs"""
.el .SS "\f(CW$chrome\->list_tabs\fP"
.IX Subsection "$chrome->list_tabs"
.Vb 1
\&  my @tabs = $chrome\->list_tabs\->get();
.Ve
.ie n .SS """$chrome\->new_tab"""
.el .SS "\f(CW$chrome\->new_tab\fP"
.IX Subsection "$chrome->new_tab"
.Vb 1
\&    my $new_tab = $chrome\->new_tab(\*(Aqhttps://www.google.com\*(Aq)\->get;
.Ve
.ie n .SS """$chrome\->activate_tab"""
.el .SS "\f(CW$chrome\->activate_tab\fP"
.IX Subsection "$chrome->activate_tab"
.Vb 1
\&    $chrome\->activate_tab( $tab )\->get
.Ve
.PP
Brings the tab to the foreground of the application
.ie n .SS """$chrome\->close_tab"""
.el .SS "\f(CW$chrome\->close_tab\fP"
.IX Subsection "$chrome->close_tab"
.Vb 1
\&    $chrome\->close_tab( $tab )\->get
.Ve
.PP
Closes the tab
.ie n .SS """$chrome\->getTargets"""
.el .SS "\f(CW$chrome\->getTargets\fP"
.IX Subsection "$chrome->getTargets"
.Vb 1
\&    my @targets = $chrome\->getTargets\->get;
.Ve
.PP
Gets the list of available targets
.ie n .SS """$target\->getTargetInfo"""
.el .SS "\f(CW$target\->getTargetInfo\fP"
.IX Subsection "$target->getTargetInfo"
.Vb 2
\&    my $info = $chrome\->getTargetInfo( $targetId )\->get;
\&    print $info\->{title};
.Ve
.PP
Returns information about the current target
.ie n .SS """$target\->createTarget"""
.el .SS "\f(CW$target\->createTarget\fP"
.IX Subsection "$target->createTarget"
.Vb 8
\&    my $targetId = $chrome\->createTarget(
\&        url => \*(Aqabout:blank\*(Aq,
\&        width => 1280,
\&        height => 800,
\&        newWindow => JSON::false,
\&        background => JSON::false,
\&    )\->get;
\&    print $targetId;
.Ve
.PP
Creates a new target, optionally in a new window
.ie n .SS """$target\->attachToTarget"""
.el .SS "\f(CW$target\->attachToTarget\fP"
.IX Subsection "$target->attachToTarget"
.Vb 4
\&    my $sessionId = $chrome\->attachToTarget(
\&        targetId => $targetId,
\&    )\->get;
\&    print $sessionId;
.Ve
.PP
Attaches to the target so we receive events generated by the target
.ie n .SS """$target\->closeTarget"""
.el .SS "\f(CW$target\->closeTarget\fP"
.IX Subsection "$target->closeTarget"
.Vb 3
\&    my $targetId = $chrome\->closeTarget(
\&        targetId => $targetId
\&    )\->get;
.Ve
.PP
Creates a new target
.ie n .SS """$target\->getWindowForTarget"""
.el .SS "\f(CW$target\->getWindowForTarget\fP"
.IX Subsection "$target->getWindowForTarget"
.Vb 2
\&    my $info = $chrome\->getWindowForTarget( $targetId )\->get;
\&    print $info\->{windowId};
.Ve
.PP
Returns information about the window of the current target
.ie n .SS """$chrome\->getBrowserContexts"""
.el .SS "\f(CW$chrome\->getBrowserContexts\fP"
.IX Subsection "$chrome->getBrowserContexts"
.Vb 1
\&    my @browserContextIds = $chrome\->getBrowserContexts\->get;
.Ve
.PP
Gets the list of available browser contexts. These are separate sets of user
cookies etc.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The inofficial Chrome debugger \s-1API\s0 documentation at
<https://github.com/buggerjs/bugger\-daemon/blob/master/README.md#api>
.PP
Chrome DevTools at <https://chromedevtools.github.io/devtools\-protocol/1\-2>
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/www\-mechanize\-chrome>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is <https://perlmonks.org/>.
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-Chrome>
or via mail to www\-mechanize\-Chrome\-Bugs@rt.cpan.org <mailto:www-mechanize-Chrome-Bugs@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2010\-2020 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
