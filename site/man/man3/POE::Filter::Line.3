.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "POE::Filter::Line 3"
.TH POE::Filter::Line 3 "2020-02-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Filter::Line \- serialize and parse terminated records (lines)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #!perl
\&
\&  use POE qw(Wheel::FollowTail Filter::Line);
\&
\&  POE::Session\->create(
\&    inline_states => {
\&      _start => sub {
\&        $_[HEAP]{tailor} = POE::Wheel::FollowTail\->new(
\&          Filename => "/var/log/system.log",
\&          InputEvent => "got_log_line",
\&          Filter => POE::Filter::Line\->new(),
\&        );
\&      },
\&      got_log_line => sub {
\&        print "Log: $_[ARG0]\en";
\&      }
\&    }
\&  );
\&
\&  POE::Kernel\->run();
\&  exit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Filter::Line parses stream data into terminated records.  The
default parser interprets newlines as the record terminator, and the
default serializer appends network newlines (\s-1CR/LF,\s0 or \*(L"\ex0D\ex0A\*(R") to
outbound records.
.PP
Record terminators are removed from the data POE::Filter::Line
returns.
.PP
POE::Filter::Line supports a number of other ways to parse lines.
Constructor parameters may specify literal newlines, regular
expressions, or that the filter should detect newlines on its own.
.SH "PUBLIC FILTER METHODS"
.IX Header "PUBLIC FILTER METHODS"
POE::Filter::Line's \fBnew()\fR method has some interesting parameters.
.SS "new"
.IX Subsection "new"
\&\fBnew()\fR accepts a list of named parameters.
.PP
In all cases, the data interpreted as the record terminator is
stripped from the data POE::Filter::Line returns.
.PP
\&\f(CW\*(C`InputLiteral\*(C'\fR may be used to parse records that are terminated by
some literal string.  For example, POE::Filter::Line may be used to
parse and emit C\-style lines, which are terminated with an \s-1ASCII NUL:\s0
.PP
.Vb 4
\&  my $c_line_filter = POE::Filter::Line\->new(
\&    InputLiteral => chr(0),
\&    OutputLiteral => chr(0),
\&  );
.Ve
.PP
\&\f(CW\*(C`OutputLiteral\*(C'\fR allows a filter to \fBput()\fR records with a different
record terminator than it parses.  This can be useful in applications
that must translate record terminators.
.PP
\&\f(CW\*(C`Literal\*(C'\fR is a shorthand for the common case where the input and
output literals are identical.  The previous example may be written
as:
.PP
.Vb 3
\&  my $c_line_filter = POE::Filter::Line\->new(
\&    Literal => chr(0),
\&  );
.Ve
.PP
An application can also allow POE::Filter::Line to figure out which
newline to use.  This is done by specifying \f(CW\*(C`InputLiteral\*(C'\fR to be
undef:
.PP
.Vb 4
\&  my $whichever_line_filter = POE::Filter::Line\->new(
\&    InputLiteral => undef,
\&    OutputLiteral => "\en",
\&  );
.Ve
.PP
\&\f(CW\*(C`InputRegexp\*(C'\fR may be used in place of \f(CW\*(C`InputLiteral\*(C'\fR to recognize
line terminators based on a regular expression.  In this example,
input is terminated by two or more consecutive newlines.  On output,
the paragraph separator is \*(L"\-\-\-\*(R" on a line by itself.
.PP
.Vb 4
\&  my $paragraph_filter = POE::Filter::Line\->new(
\&    InputRegexp => "([\ex0D\ex0A]{2,})",
\&    OutputLiteral => "\en\-\-\-\en",
\&  );
.Ve
.PP
\&\f(CW\*(C`MaxBuffer\*(C'\fR sets the maximum amount of data that the filter will hold onto 
while trying to find a line ending.  Defaults to 512 \s-1MB.\s0
.PP
\&\f(CW\*(C`MaxLength\*(C'\fR sets the maximum length of a line.  Defaults to 64 \s-1MB.\s0
.PP
If either the \f(CW\*(C`MaxLength\*(C'\fR or \f(CW\*(C`MaxBuffer\*(C'\fR constraint is exceeded,
\&\f(CW\*(C`POE::Filter::Line\*(C'\fR will throw an exception.
.SH "PUBLIC FILTER METHODS"
.IX Header "PUBLIC FILTER METHODS"
POE::Filter::Line has no additional public methods.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
POE::Filter::Line exports the \s-1FIRST_UNUSED\s0 constant.  This points to
the first unused element in the \f(CW$self\fR array reference.  Subclasses
should store their own data beginning here, and they should export
their own \s-1FIRST_UNUSED\s0 constants to help future subclassers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see POE::Filter for documentation regarding the base
interface.
.PP
The \s-1SEE ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.SH "BUGS"
.IX Header "BUGS"
The default input newline parser is a regexp that has an unfortunate
race condition.  First the regular expression:
.PP
.Vb 1
\&  /(\ex0D\ex0A?|\ex0A\ex0D?)/
.Ve
.PP
While it quickly recognizes most forms of newline, it can sometimes
detect an extra blank line.  This happens when a two-byte newline
character is broken between two reads.  Consider this situation:
.PP
.Vb 2
\&  some stream dataCR
\&  LFother stream data
.Ve
.PP
The regular expression will see the first \s-1CR\s0 without its corresponding
\&\s-1LF.\s0  The filter will properly return \*(L"some stream data\*(R" as a line.
When the next packet arrives, the leading \*(L"\s-1LF\*(R"\s0 will be treated as the
terminator for a 0\-byte line.  The filter will faithfully return this
empty line.
.PP
\&\fBIt is advised to specify literal newlines or use the autodetect
feature in applications where blank lines are significant.\fR
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Please see \s-1POE\s0 for more information about authors and contributors.
