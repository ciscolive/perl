.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::CSV::Unicode 3"
.TH Text::CSV::Unicode 3 "2020-10-14" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::CSV::Unicode \-	comma\-separated values manipulation routines
			with potentially wide character data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Text::CSV::Unicode;
\&
\&    $csv = Text::CSV::Unicode\->new();
\&
\&    # then use methods from Text::CSV
\&
\&    $version = Text::CSV::Unicode\->VERSION();   # get the module version
\&
\&    $csv = Text::CSV::Unicode\->new();   # create a new object
\&
\&    $status = $csv\->combine(@columns);  # combine columns into a string
\&    $line = $csv\->string();             # get the combined string
\&
\&    $status = $csv\->parse($line);       # parse a CSV string into fields
\&    @columns = $csv\->fields();          # get the parsed fields
\&
\&    $status = $csv\->status();           # get the most recent status
\&    $bad_argument = $csv\->error_input();# get the most recent bad argument
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::CSV::Unicode provides facilities for the composition and
decomposition of comma-separated values, based on Text::CSV.
Text::CSV::Unicode allows for input with wide character data
but does not permit control characters.
.SH "Incompatible Changes"
.IX Header "Incompatible Changes"
.SS "Option always_quote=>1 (v0.300)"
.IX Subsection "Option always_quote=>1 (v0.300)"
Before v0.300, the module behaviour defaulted to 
\&\f(CW\*(C`always_quote => 1\*(C'\fR in Text::CSV.  
This behaviour was only needed in tests.
.PP
To recreate the old behaviour:
.PP
.Vb 1
\&    $csv = Text::CSV::Unicode\->new( { always_quote => 1 } );
.Ve
.SH "DEPRECATED"
.IX Header "DEPRECATED"
The option \f(CW\*(C`binary => 1\*(C'\fR does not require this module.
.PP
This code issues a 'deprecated' warning and creates a 
Text::CSV object:
.PP
.Vb 1
\&    $csv = Text::CSV::Unicode\->new( { binary => 1 } );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\s-1VERSION\s0" 4
.IX Item "VERSION"
This function may be called as a class or an object method.
As a class method, it returns the currrent module version.
As an object method, it returns the version of the underlying
Text::CSV module.
.IP "version" 4
.IX Item "version"
An object method: it returns the backend module version.
.IP "new" 4
.IX Item "new"
.Vb 1
\&    $csv = Text::CSV::Unicode\->new( [{ binary => 1 }] );
.Ve
.Sp
This function may be called as a class method.
It returns a reference to a newly created object.
.Sp
\&\f(CW\*(C`binary => 0\*(C'\fR allows the same \s-1ASCII\s0 input as Text::CSV.
.Sp
\&\f(CW\*(C`binary => 1\*(C'\fR allows for all Unicode
characters in the input (including \er and \en):
the same functionality as \f(CW\*(C`Text::CSV\->new( { binary => 1 }\*(C'\fR.
.IP "combine" 4
.IX Item "combine"
.Vb 1
\&    $status = $csv\->combine(@columns);
.Ve
.Sp
This object function constructs a \s-1CSV\s0 string from the arguments,
returning success or failure.  Failure can result from lack of
arguments or an argument containing an invalid character.
.Sp
Silently accepts undef values in input and treats as an empty string.
.IP "parse" 4
.IX Item "parse"
.Vb 1
\&    $status = $csv\->parse($line);
.Ve
.Sp
This object function decomposes a \s-1CSV\s0 string into fields, returning
success or failure.  Failure can result from a lack of argument or
the given \s-1CSV\s0 string is improperly formatted.  
Upon failure, the value returned by \f(CW\*(C`fields()\*(C'\fR is undefined
and \f(CW\*(C`error_input()\*(C'\fR can be called to retrieve the invalid argument.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
None
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
See \s-1HASH\s0 option to \f(CW\*(C`\->new\*(C'\fR.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
perl 5.8.0
.PP
Text::CSV 1.0
.SH "VERSION"
.IX Header "VERSION"
0.400
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Barker <rmbarker@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::CSV
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2007, 2008, 2010, 2011, 2012, 2018 Robin Barker.  
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
The documentation of Text::CSV::Unicode methods that are inherited 
from Text::CSV is taken from Text::CSV 0.01 (with some reformatting) 
and is Copyright (c) 1997 Alan Citterman.
