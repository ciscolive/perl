.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::DNS 3"
.TH Test::DNS 3 "2019-04-22" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::DNS \- Test DNS queries and zone configuration
.SH "VERSION"
.IX Header "VERSION"
version 0.203
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module helps you write tests for \s-1DNS\s0 queries. You could test your domain
configuration in the world or on a specific \s-1DNS\s0 server, for example.
.PP
.Vb 2
\&    use Test::DNS;
\&    use Test::More tests => 4;
\&
\&    my $dns = Test::DNS\->new();
\&
\&    $dns\->is_ptr( \*(Aq1.2.3.4\*(Aq => \*(Aqsingle.ptr.record.com\*(Aq );
\&    $dns\->is_ptr( \*(Aq1.2.3.4\*(Aq => [ \*(Aqone.ptr.record.com\*(Aq, \*(Aqtwo.ptr.record.com\*(Aq ] );
\&    $dns\->is_ns( \*(Aqgoogle.com\*(Aq => [ map "ns$_.google.com", 1 .. 4 ] );
\&    $dns\->is_a( \*(Aqns1.google.com\*(Aq => \*(Aq216.239.32.10\*(Aq );
\&
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Test::DNS allows you to run tests which translate as \s-1DNS\s0 queries. It's simple to
use and abstracts all the difficult query checks from you. It has a built-in
tests naming scheme so you don't have to name your tests (as shown in all
the examples) even though it supports the option.
.PP
.Vb 2
\&    use Test::DNS;
\&    use Test::More tests => 1;
\&
\&    my $dns = Test::DNS\->new( nameservers => [ \*(Aqmy.dns.server\*(Aq ] );
\&    $dns\->is_ptr( \*(Aq1.1.1.1\*(Aq => \*(Aqmy_new.mail.server\*(Aq );
.Ve
.PP
That was a complete test script that will fetch the \s-1PTR\s0 (if there is one), warns
if it's missing one (an option you can remove via the \fIwarnings\fR attribute) and
checks against the domain you gave. You could also give for each test an
arrayref of expected values. That's useful if you want to check multiple values.
For example:
.PP
.Vb 2
\&    use Test::DNS;
\&    use Test::More tests => 1;
\&
\&    my $dns = Test::DNS\->new();
\&    $dns\->is_ns( \*(Aqmy.domain\*(Aq => [ \*(Aqns1.my.domain\*(Aq, \*(Aqns2.my.domain\*(Aq ] );
\&    # or
\&    $dns\->is_ns( \*(Aqmy.domain\*(Aq => [ map "ns$_.my.domain", 1 .. 5 ] );
.Ve
.PP
You can set the \fIfollow_cname\fR option if your \s-1PTR\s0 returns a \s-1CNAME\s0 instead of an
A record and you want to test the A record instead of the \s-1CNAME.\s0 This happened
to me at least twice and fumbled my tests. I was expecting an A record, but got
a \s-1CNAME\s0 to an A record. This is obviously legal \s-1DNS\s0 practices, so using the
\&\fIfollow_cname\fR attribute listed below, the test went with flying colors. This
is a recursive \s-1CNAME\s0 to A record function so you could handle multiple \s-1CNAME\s0
chaining if one has such an odd case.
.PP
New in version 0.04 is the option to give a hashref as the testing values (not
including a test name as well), which makes things much easier to test if you
want to run multiple tests and don't want to write multiple lines. This helps
connect Test::DNS with freshly-parsed data (YAML/JSON/XML/etc.).
.PP
.Vb 3
\&    use Test::DNS;
\&    use YAML \*(AqLoadFile\*(Aq;
\&    use Test::More tests => 2;
\&
\&    my $dns = Test::DNS\->new();
\&    # running two DNS tests in one command!
\&    $dns\->is_ns( {
\&        \*(Aqfirst.domain\*(Aq  => [ map { "ns$_.first.domain"  } 1 .. 4 ],
\&        \*(Aqsecond.domain\*(Aq => [ map { "ns$_.second.domain" } 5, 6   ],
\&    } );
\&
\&    my $tests = LoadFile(\*(Aqtests.yaml\*(Aq);
\&    $dns\->is_a( $tests, delete $tests\->{\*(Aqname\*(Aq} ); # $tests is a hashref
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
This module is completely Object Oriented, nothing is exported.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "nameservers($arrayref)"
.IX Subsection "nameservers($arrayref)"
Same as in Net::DNS. Sets the nameservers, accepts an arrayref.
.PP
.Vb 3
\&    my $dns = Test::DNS\->new(
\&        \*(Aqnameservers\*(Aq => [ \*(AqIP1\*(Aq, \*(AqDOMAIN\*(Aq ],
\&    );
.Ve
.SS "warnings($boolean)"
.IX Subsection "warnings($boolean)"
Do you want to output warnings from the module (in valid \s-1TAP\s0), such as when a
record doesn't a query result or incorrect types?
.PP
This helps avoid common misconfigurations. You should probably keep it, but if
it bugs you, you can stop it using:
.PP
.Vb 3
\&    my $dns = Test::DNS\->new(
\&        \*(Aqwarnings\*(Aq => 0,
\&    );
.Ve
.PP
Default: 1 (on).
.SS "follow_cname($boolean)"
.IX Subsection "follow_cname($boolean)"
When fetching an A record of a domain, it may resolve to a \s-1CNAME\s0 instead of an A
record. That would result in a false-negative of sorts, in which you say \*(L"well,
yes, I meant the A record the \s-1CNAME\s0 record points to\*(R" but Test::DNS doesn't
know that.
.PP
If you want want Test::DNS to follow every \s-1CNAME\s0 recursively till it reaches the
actual A record and compare \fBthat\fR A record, use this option.
.PP
.Vb 3
\&    my $dns = Test::DNS\->new(
\&        \*(Aqfollow_cname\*(Aq => 1,
\&    );
.Ve
.PP
Default: 0 (off).
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.ie n .SS "is_a( $domain, $ips, [$test_name] )"
.el .SS "is_a( \f(CW$domain\fP, \f(CW$ips\fP, [$test_name] )"
.IX Subsection "is_a( $domain, $ips, [$test_name] )"
Check the A record resolving of domain or subdomain.
.PP
\&\f(CW$ip\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_a( \*(Aqdomain\*(Aq => \*(AqIP\*(Aq );
\&
\&    $dns\->is_a( \*(Aqdomain\*(Aq, [ \*(AqIP1\*(Aq, \*(AqIP2\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_ns( $domain, $ips, [$test_name] )"
.el .SS "is_ns( \f(CW$domain\fP, \f(CW$ips\fP, [$test_name] )"
.IX Subsection "is_ns( $domain, $ips, [$test_name] )"
Check the \s-1NS\s0 record resolving of a domain or subdomain.
.PP
\&\f(CW$ip\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_ns( \*(Aqdomain\*(Aq => \*(AqIP\*(Aq );
\&
\&    $dns\->is_ns( \*(Aqdomain\*(Aq, [ \*(AqIP1\*(Aq, \*(AqIP2\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_ptr( $ip, $domains, [$test_name] )"
.el .SS "is_ptr( \f(CW$ip\fP, \f(CW$domains\fP, [$test_name] )"
.IX Subsection "is_ptr( $ip, $domains, [$test_name] )"
Check the \s-1PTR\s0 records of an \s-1IP.\s0
.PP
\&\f(CW$domains\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_ptr( \*(AqIP\*(Aq => \*(Aqptr.records.domain\*(Aq );
\&
\&    $dns\->is_ptr( \*(AqIP\*(Aq, [ \*(Aqfirst.ptr.domain\*(Aq, \*(Aqsecond.ptr.domain\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_mx( $domain, $domains, [$test_name] )"
.el .SS "is_mx( \f(CW$domain\fP, \f(CW$domains\fP, [$test_name] )"
.IX Subsection "is_mx( $domain, $domains, [$test_name] )"
Check the \s-1MX\s0 records of a domain.
.PP
\&\f(CW$domains\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_mx( \*(Aqdomain\*(Aq => \*(Aqmailer.domain\*(Aq );
\&
\&    $dns\->is_ptr( \*(Aqdomain\*(Aq, [ \*(Aqmailer1.domain\*(Aq, \*(Aqmailer2.domain\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_cname( $domain, $domains, [$test_name] )"
.el .SS "is_cname( \f(CW$domain\fP, \f(CW$domains\fP, [$test_name] )"
.IX Subsection "is_cname( $domain, $domains, [$test_name] )"
Check the \s-1CNAME\s0 records of a domain.
.PP
\&\f(CW$domains\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_cname( \*(Aqdomain\*(Aq => \*(Aqsub.domain\*(Aq );
\&
\&    $dns\->is_cname( \*(Aqdomain\*(Aq, [ \*(Aqsub1.domain\*(Aq, \*(Aqsub2.domain\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_txt( $domain, $txt, [$test_name] )"
.el .SS "is_txt( \f(CW$domain\fP, \f(CW$txt\fP, [$test_name] )"
.IX Subsection "is_txt( $domain, $txt, [$test_name] )"
Check the \s-1TXT\s0 records of a domain.
.PP
\&\f(CW$txt\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_txt( \*(Aqdomain\*(Aq => \*(Aqv=spf1 \-all\*(Aq );
\&
\&    $dns\->is_txt( \*(Aqdomain\*(Aq, [ \*(Aqsub1.domain\*(Aq, \*(Aqsub2.domain\*(Aq ] );
.Ve
.PP
Returns false if the assertion fails.
.ie n .SS "is_record( $type, $input, $expected, [$test_name] )"
.el .SS "is_record( \f(CW$type\fP, \f(CW$input\fP, \f(CW$expected\fP, [$test_name] )"
.IX Subsection "is_record( $type, $input, $expected, [$test_name] )"
The general function all the other is_* functions run.
.PP
\&\f(CW$type\fR is the record type (\s-1CNAME, A, NS, PTR, MX,\s0 etc.).
.PP
\&\f(CW$input\fR is the domain or \s-1IP\s0 you're testing.
.PP
\&\f(CW$expected\fR can be an arrayref.
.PP
\&\f(CW$test_name\fR is not mandatory.
.PP
.Vb 1
\&    $dns\->is_record( \*(AqCNAME\*(Aq, \*(Aqdomain\*(Aq, \*(Aqsub.domain\*(Aq, \*(Aqtest_name\*(Aq );
.Ve
.PP
Returns false if the assertion fails.
.SS "\s-1BUILD\s0"
.IX Subsection "BUILD"
Moose builder method. Do not call it or override it. :)
.SH "HASH FORMAT"
.IX Header "HASH FORMAT"
The hash format option (since version 0.04) allows you to run the tests using a
single hashref with an optional parameter for the test_name. The count is no
longer 1 (as it is with single tests), but each key/value pair represents a test
case.
.PP
.Vb 5
\&    # these are 2 tests
\&    $dns\->is_ns( {
\&        \*(Aqfirst.domain\*(Aq  => [ map { "ns$_.first.domain"  } 1 .. 4 ],
\&        \*(Aqsecond.domain\*(Aq => [ map { "ns$_.second.domain" } 5, 6   ],
\&    } );
\&
\&    # number of tests: keys %{$tests}, test name: $tests\->{\*(Aqname\*(Aq}
\&    $dns\->is_a( $tests, delete $tests\->{\*(Aqname\*(Aq} ); # $tests is a hashref
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Moose
.PP
Net::DNS
.PP
Test::Deep
.SH "AUTHOR"
.IX Header "AUTHOR"
Sawyer X, \f(CW\*(C`<xsawyerx at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-test\-dns at rt.cpan.org\*(C'\fR, or
through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-DNS>. I will be notified,
and then you'll automatically be notified of progress on your bug as I make
changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::DNS
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
Github
.Sp
<http://github.com/xsawyerx/test\-dns>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test\-DNS>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Test\-DNS>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Test\-DNS>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Test\-DNS/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2019 Sawyer X.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sawyer X <xsawyerx@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2019 by Sawyer X.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
