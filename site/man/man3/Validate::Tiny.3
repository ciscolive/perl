.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Validate::Tiny 3"
.TH Validate::Tiny 3 "2016-11-09" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Validate::Tiny \- Minimalistic data validation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Filter and validate user input from forms, etc.
.PP
.Vb 1
\&    use Validate::Tiny \*(Aq:all\*(Aq;
\&
\&    my $rules = {
\&
\&        # List of fields to look for
\&        fields => [qw/name email pass pass2 gender/],
\&
\&        # Filters to run on all fields
\&        filters => [
\&
\&            # Remove spaces from all
\&            qr/.+/ => filter(qw/trim strip/),
\&
\&            # Lowercase email
\&            email => filter(\*(Aqlc\*(Aq),
\&
\&            # Remove non\-alphanumeric symbols from
\&            # both passwords
\&            qr/pass?/ => sub {
\&                $_[0] =~ s/\eW/./g;
\&                $_[0];
\&            },
\&        ],
\&
\&        # Checks to perform on all fields
\&        checks => [
\&
\&            # All of these are required
\&            [qw/name email pass pass2/] => is_required(),
\&
\&            # pass2 must be equal to pass
\&            pass2 => is_equal(\*(Aqpass\*(Aq),
\&
\&            # custom sub validates an email address
\&            email => sub {
\&                my ( $value, $params ) = @_;
\&                return if Email::Valid\->address($value);
\&                return \*(AqInvalid email\*(Aq;
\&            },
\&
\&            # custom sub to validate gender
\&            gender => sub {
\&                my ( $value, $params ) = @_;
\&                return if $value eq \*(AqM\*(Aq || $value eq \*(AqF\*(Aq;
\&                return \*(AqInvalid gender\*(Aq;
\&            }
\&
\&        ]
\&    };
\&
\&    # Validate the input agains the rules
\&    my $result = validate( $input, $rules );
\&
\&    if ( $result\->{success} ) {
\&        my $values_hash = $result\->{data};
\&        ...
\&    }
\&    else {
\&        my $errors_hash = $result\->{error};
\&        ...
\&    }
.Ve
.PP
Or if you prefer an \s-1OOP\s0 approach:
.PP
.Vb 1
\&    use Validate::Tiny;
\&
\&    my $v = Validate::Tiny\->new( %args );
\&    $v\->check( $input, $rules );
\&
\&    if ( $v\->success ) {
\&        my $values_hash = $v\->data;
\&        my $name        = $v\->data(\*(Aqname\*(Aq);
\&        my $email       = $v\->data(\*(Aqemail\*(Aq);
\&        ...;
\&    }
\&    else {
\&        my $errors_hash = $v\->error;
\&        my $name_error  = $v\->error(\*(Aqname\*(Aq);
\&        my $email_error = $v\->error(\*(Aqemail\*(Aq);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a simple, light and minimalistic way of validating
user input. Except perl core modules and some test modules it has no other
dependencies, which is why it does not implement any complicated checks
and filters such as email and credit card matching. The basic idea of this
module is to provide the validation functionality, and leave it up to the
user to write their own data filters and checks. If you need a complete
data validation solution that comes with many ready features, I recommend
you to take a look at Data::FormValidator. If your validation logic is
not too complicated or your form is relatively short, this module is a
decent candidate for your project.
.SH "LOGIC"
.IX Header "LOGIC"
The basic principle of data/form validation is that any user input must be
sanitized and checked for errors before used in the logic of the program.
Validate::Tiny breaks this process in three steps:
.IP "1." 4
Specify the fields you want to work with via \*(L"fields\*(R".  All others will
be disregarded.
.IP "2." 4
Filter the fields' values using \*(L"filters\*(R". A filter can be as simple as
changing to lower case or removing excess white space, or very complicated
such as parsing and removing \s-1HTML\s0 tags.
.IP "3." 4
Perform a series of \*(L"checks\*(R" on the filtered values, to make sure they
match the requirements. Again, the checks can be very simple as in
checking if the value was defined, or very complicated as in checking if
the value is a valid credit card number.
.PP
The validation returns a hash ref which contains \f(CW\*(C`success\*(C'\fR => 1|0,
\&\f(CW\*(C`data\*(C'\fR and \f(CW\*(C`error\*(C'\fR hashes. If success is 1, \f(CW\*(C`data\*(C'\fR will contain the
filtered values, otherwise \f(CW\*(C`error\*(C'\fR will contain the error messages for
each field.
.SH "EXPORT"
.IX Header "EXPORT"
This module does not automatically export anything. You can optionally
request any of the below subroutines or use ':all' to export all.
.SH "RULES"
.IX Header "RULES"
Rules provide the specifications for the three step validation
process.  They are represented as a hash, containing references to the
following three arrays: \*(L"fields\*(R", \*(L"filters\*(R" and \*(L"checks\*(R".
.PP
.Vb 5
\&    my %rules = (
\&        fields  => \e@field_names,
\&        filters => \e@filters_array,
\&        checks  => \e@checks_array
\&    );
.Ve
.SS "fields"
.IX Subsection "fields"
An array containing the names of the fields that must be filtered, checked
and returned. All others will be disregarded. As of version 0.981 you can
use an empty array for \f(CW\*(C`fields\*(C'\fR, which will work on all input fields.
.PP
.Vb 1
\&    my @field_names = qw/username email password password2/;
.Ve
.PP
or
.PP
.Vb 1
\&    my @field_names = ();   # Use all input fields
.Ve
.SS "filters"
.IX Subsection "filters"
An array containing name matches and filter subs. The array must have an
even number of elements. Each \fIodd\fR element is a field name match and
each \fIeven\fR element is a reference to a filter subroutine or a chain of
filter subroutines. A filter subroutine takes one parameter \- the value to
be filtered, and returns the modified value.
.PP
.Vb 5
\&    my @filters_array = (
\&        email => sub { return lc $_[0] },    # Lowercase the email
\&        password =>
\&          sub { $_[0] =~ s/\es//g; $_[0] }    # Remove spaces from password
\&    );
.Ve
.PP
The field name is matched with the perl smart match operator, so you could
have a regular expression or a reference to an array to match several
fields:
.PP
.Vb 2
\&    my @filters_array = (
\&        qr/.+/ => sub { lc $_[0] },    # Lowercase ALL
\&
\&        [qw/password password2/] => sub {    # Remove spaces from both
\&            $_[0] =~ s/\es//g;                # password and password2
\&            $_[0];
\&        }
\&    );
.Ve
.PP
Instead of a single filter subroutine, you can pass an array of
subroutines to provide a chain of filters:
.PP
.Vb 3
\&    my @filters_array = (
\&        qr/.+/ => [ sub { lc $_[0] }, sub { ucfirst $_[0] } ]
\&    );
.Ve
.PP
The above example will first lowercase the value then uppercase its first
letter.
.PP
Some simple text filters are provided by the \*(L"\fBfilter()\fR\*(R" subroutine.
.PP
.Vb 1
\&    use Validate::Tiny qw/validate :util/;
\&
\&    my @filters_array = (
\&        name => filter(qw/strip trim lc/)
\&    );
.Ve
.PP
\fIAdding custom filters\fR
.IX Subsection "Adding custom filters"
.PP
This module exposes \f(CW\*(C`our %FILTERS\*(C'\fR, a hash containing available filters.
To add a filter, add a new key-value to this hash:
.PP
.Vb 5
\&    $Validate::Tiny::FILTERS{only_digits} = sub {
\&        my $val = shift // return;
\&        $val =~ s/\eD//g;
\&        return $val;
\&    };
.Ve
.PP
\fIFilter Support Routines\fR
.IX Subsection "Filter Support Routines"
.PP
filter
.IX Subsection "filter"
.PP
.Vb 1
\&    filter( $name1, $name2, ... );
.Ve
.PP
Provides a shortcut to some basic text filters. In reality, it returns a
list of anonymous subs, so the following:
.PP
.Vb 5
\&    my $rules = {
\&        filters => [
\&            email => filter(\*(Aqlc\*(Aq, \*(Aqucfirst\*(Aq)
\&        ]
\&    };
.Ve
.PP
is equivalent to this:
.PP
.Vb 5
\&    my $rules = {
\&        filters => [
\&            email => [ sub{ lc $_[0] }, sub{ ucfirst $_[0] } ]
\&        ]
\&    };
.Ve
.PP
It provides a shortcut for the following filters:
.IP "trim" 4
.IX Item "trim"
Removes leading and trailing white space.
.IP "strip" 4
.IX Item "strip"
Shrinks two or more white spaces to one.
.IP "lc" 4
.IX Item "lc"
Lower case.
.IP "uc" 4
.IX Item "uc"
Upper case.
.IP "ucfirst" 4
.IX Item "ucfirst"
Upper case first letter
.SS "checks"
.IX Subsection "checks"
An array ref containing name matches and check subs. The array must have
an even number of elements. Each \fIodd\fR element is a field name match and
each \fIeven\fR element is a reference to a check subroutine or a chain of
check subroutines.
.PP
A check subroutine takes three parameters \- the value to be checked, a
reference to the filtered input hash and a scalar with the name of the
checked field.
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    checks => [
\&        does_exist => sub {
\&            my ( $value, $params, $keys ) = @_;
\&            return "Key doesn\*(Aqt exist in input data"
\&              unless exists( $params\->{$key} );
\&        }
\&    ]
.Ve
.PP
A check subroutine must return undef if the check passes or a scalar containing
an error message if the check fails.  The message is not interpreted by
Validate::Tiny, so may take any form, e.g. a string, a reference to
an error object, etc.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    # Make sure the password is good
\&    sub is_good_password {
\&        my ( $value, $params ) = @_;
\&
\&        if ( !defined $value or $value eq \*(Aq\*(Aq ) {
\&            return;
\&        }
\&
\&        if ( length($value) < 6 ) {
\&            return "The password is too short";
\&        }
\&
\&        if ( length($value) > 40 ) {
\&            return "The password is too long";
\&        }
\&
\&        if ( $value eq $params\->{username} ) {
\&            return "Your password can not be the same as your username";
\&        }
\&
\&        # At this point we\*(Aqre happy with the password
\&        return;
\&    }
\&
\&    my $rules = {
\&        fields => [qw/username password/],
\&        checks => [
\&            password => \e&is_good_password
\&        ]
\&    };
.Ve
.PP
It may be a bit counter-intuitive for some people to return undef when the
check passes and an error message when it fails. If you have a huge problem with
this concept, then this module may not be right for you.
.PP
\&\fBImportant!\fR Notice that in the beginning of \f(CW\*(C`is_good_password\*(C'\fR we check
if \f(CW$value\fR is defined and return undef if it is not. This is because it
is not the job of \f(CW\*(C`is_good_password\*(C'\fR to check if \f(CW\*(C`password\*(C'\fR is required.
Its job is to determine if the password is good. Consider the following
example:
.PP
.Vb 8
\&    # Password is required and it must pass the check for good password
\&    #
\&    my $rules = {
\&        fields => [qw/username password/],
\&        checks => [
\&            password => [ is_required(), \e&is_good_password ]
\&        ]
\&    };
.Ve
.PP
and this one too:
.PP
.Vb 10
\&    # Password is not required, but if it\*(Aqs provided then
\&    # it must pass the is_good_password constraint.
\&    #
\&    my $rules = {
\&        fields => [qw/username password/],
\&        checks => [
\&            username => is_required(),
\&            password => \e&is_good_password
\&        ]
\&    };
.Ve
.PP
The above examples show how we make sure that \f(CW\*(C`password\*(C'\fR is defined and
not empty before we check if it is a good password.  Of course we can
check if \f(CW\*(C`password\*(C'\fR is defined inside \f(CW\*(C`is_good_password\*(C'\fR, but it would
be redundant. Also, this approach will fail if \f(CW\*(C`password\*(C'\fR is not
required, but must pass the rules for a good password if provided.
.PP
\fIChaining\fR
.IX Subsection "Chaining"
.PP
The above example also shows that chaining check subroutines is available
in the same fashion as chaining filter subroutines.  The difference
between chaining filters and chaining checks is that a chain of filters
will always run \fBall\fR filters, and a chain of checks will exit after the
first failed check and return its error message.  This way the
\&\f(CW\*(C`$result\->{error}\*(C'\fR hash always has a single error message per field.
.PP
\fIUsing closures\fR
.IX Subsection "Using closures"
.PP
When writing reusable check subroutines, sometimes you will want to be
able to pass arguments. Returning closures (anonymous subs) is the
recommended approach:
.PP
.Vb 8
\&    sub is_long_between {
\&        my ( $min, $max ) = @_;
\&        return sub {
\&            my $value = shift;
\&            return if length($value) >= $min && length($value) <= $max;
\&            return "Must be between $min and $max symbols";
\&        };
\&    }
\&
\&    my $rules = {
\&        fields => qw/password/,
\&        checks => [
\&            password => is_long_between( 6, 40 )
\&        ]
\&    };
.Ve
.PP
\fICheck Support Routines\fR
.IX Subsection "Check Support Routines"
.PP
Validate::Tiny provides a number of predicates to simplify writing
rules.  They may be passed an optional error message.  Like those
returned by custom check routines, the message is not interpreted by
Validate::Tiny, so may take any form, e.g. a string, a reference to an
error object, etc.
.PP
is_required
.IX Subsection "is_required"
.PP
.Vb 1
\&    is_required( $optional_error_message );
.Ve
.PP
\&\f(CW\*(C`is_required\*(C'\fR provides a shortcut to an anonymous subroutine that
checks if the matched field is defined and it is not an empty
string.
Optionally, you can provide a custom error message. The default is the string,  \fIRequired\fR.
.PP
is_required_if
.IX Subsection "is_required_if"
.PP
.Vb 1
\&    is_required_if( $condition, $optional_error_message );
.Ve
.PP
Require a field conditionally. The condition can be either a scalar or a
code reference that returns true/false value. If the condition is a code
reference, it will be passed the \f(CW$params\fR hash with all filtered fields.
Optionally, you can provide a custom error message. The default is the string,  \fIRequired\fR.
.PP
Example:
.PP
.Vb 10
\&    my $rules = {
\&        fields => [qw/country state/],
\&        checks => [
\&            country => is_required(),
\&            state   => is_required_if(
\&                sub {
\&                    my $params = shift;
\&                    return $params\->{country} eq \*(AqUSA\*(Aq;
\&                },
\&                "Must select a state if you\*(Aqre in the USA"
\&            )
\&        ]
\&    };
.Ve
.PP
Second example:
.PP
.Vb 10
\&    our $month = \*(AqOctober\*(Aq;
\&    my $rules = {
\&        fields => [\*(Aqmustache\*(Aq],
\&        checks => [
\&            mustache => is_required_if(
\&                $month eq \*(AqOctober\*(Aq,
\&                "You must grow a mustache this month!"
\&            )
\&        ]
\&    };
.Ve
.PP
is_existing
.IX Subsection "is_existing"
.PP
.Vb 1
\&    is_existing( $optional_error_message );
.Ve
.PP
Much like \f(CW\*(C`is_required\*(C'\fR, but checks if the field contains any value, even an
empty string and \f(CW\*(C`undef\*(C'\fR.
Optionally, you can provide a custom error message. The default is the string,  \fIMust be defined\fR.
.PP
is_equal
.IX Subsection "is_equal"
.PP
.Vb 1
\&    is_equal( $other_field_name, $optional_error_message );
.Ve
.PP
\&\f(CW\*(C`is_equal\*(C'\fR checks if the value of the matched field is the same as the
value of another field within the input hash.
Optionally, you can provide a custom error message. The default is the string,  \fIInvalid value\fR.
.PP
Example:
.PP
.Vb 5
\&    my $rules = {
\&        checks => [
\&            password2 => is_equal("password", "Passwords don\*(Aqt match")
\&        ]
\&    };
.Ve
.PP
is_long_between
.IX Subsection "is_long_between"
.PP
.Vb 1
\&    is_long_between( $min, $max, $optional_error_message );
.Ve
.PP
Checks if the length of the value is >= \f(CW$min\fR and <= \f(CW$max\fR. Optionally
you can provide a custom error message. The default is the string,  \fIInvalid value\fR.
.PP
Example:
.PP
.Vb 5
\&    my $rules = {
\&        checks => [
\&            username => is_long_between( 6, 25, \*(AqBad username\*(Aq )
\&        ]
\&    };
.Ve
.PP
is_long_at_least
.IX Subsection "is_long_at_least"
.PP
.Vb 1
\&    is_long_at_least( $length, $optional_error_message );
.Ve
.PP
Checks if the length of the value is >= \f(CW$length\fR. Optionally you can
provide a custom error message. The default is the string,  \fIMust be at least \f(CI%i\fI
symbols\fR.
.PP
Example:
.PP
.Vb 5
\&    my $rules = {
\&        checks => [
\&            zip_code => is_long_at_least( 5, \*(AqBad zip code\*(Aq )
\&        ]
\&    };
.Ve
.PP
is_long_at_most
.IX Subsection "is_long_at_most"
.PP
.Vb 1
\&    is_long_at_most( $length, $optional_error_message );
.Ve
.PP
Checks if the length of the value is <= \f(CW$length\fR. Optionally you can
provide a custom error message. The default is the string,  \fIMust be at the most \f(CI%i\fI
symbols\fR.
.PP
Example:
.PP
.Vb 5
\&    my $rules = {
\&        checks => [
\&            city_name => is_long_at_most( 40, \*(AqCity name is too long\*(Aq )
\&        ]
\&    };
.Ve
.PP
is_a
.IX Subsection "is_a"
.PP
.Vb 1
\&    is_a ( $class, $optional_error_message );
.Ve
.PP
Checks if the value is an instance of a class. This can be particularly
useful, when you need to parse dates or other user input that needs to get
converted to an object. Since the filters get executed before checks, you
can use them to instantiate the data, then use \f(CW\*(C`is_a\*(C'\fR to check if you got
a successful object.
Optionally you can provide a custom error message. The default is the string,  \fIInvalid value\fR.
.PP
Example:
.PP
.Vb 2
\&    use DateTime::Format::Natural;
\&    use Try::Tiny;
\&
\&    my $parser = DateTime::Format::Natural\->new;
\&
\&    my $rules = {
\&        fields  => [\*(Aqdate\*(Aq],
\&
\&        filters => [
\&            date => sub {
\&                try {
\&                    $parser\->parse_datetime( $_[0] );
\&                }
\&                catch {
\&                    $_[0]
\&                }
\&            }
\&        ],
\&
\&        checks => [
\&            date => is_a("DateTime", "Ivalid date")
\&        ]
\&    };
.Ve
.PP
is_like
.IX Subsection "is_like"
.PP
.Vb 1
\&    is_like ( $regexp, $optional_error_message );
.Ve
.PP
Checks if the value matches a regular expression.
Optionally you can provide a custom error message. The default is the string,  \fIInvalid value\fR.
.PP
Example:
.PP
.Vb 5
\&    my $rules = {
\&        checks => [
\&            username => is_like( qr/^[a\-z0\-9_]{6,20}$/, "Bad username" )
\&        ]
\&    };
.Ve
.PP
is_in
.IX Subsection "is_in"
.PP
.Vb 1
\&    is_in ( $arrayref, $optional_error_message );
.Ve
.PP
Checks if the value matches a set of values.
Optionally you can provide a custom error message. The default is the string,  \fIInvalid value\fR.
.PP
.Vb 1
\&    Example:
\&
\&    my @cities = qw/Alchevsk Kiev Odessa/;
\&    my $rules = {
\&        checks => [
\&            city => is_in( \e@cities, "We only deliver to " . join(\*(Aq,\*(Aq, @cities))
\&        ]
\&    };
.Ve
.SH "PROCEDURAL INTERFACE"
.IX Header "PROCEDURAL INTERFACE"
.SS "validate"
.IX Subsection "validate"
.Vb 1
\&    use Validate::Tiny qw/validate/;
\&
\&    my $result = validate( \e%input, \e%rules );
.Ve
.PP
Validates user input against a set of rules. The input is expected to be a
reference to a hash.
.PP
\fIReturn value\fR
.IX Subsection "Return value"
.PP
\&\f(CW\*(C`validate\*(C'\fR returns a hash ref with three elements:
.PP
.Vb 1
\&    my $result = validate(\e%input, \e%rules);
\&
\&    # Now $result looks like this
\&    $result = {
\&        success => 1,       # or 0 if checks didn\*(Aqt pass
\&        data    => \e%data,
\&        error   => \e%error
\&    };
.Ve
.PP
If \f(CW\*(C`success\*(C'\fR is 1 all of the filtered input will be in \f(CW%data\fR,
otherwise the error messages will be stored in \f(CW%error\fR. If \f(CW\*(C`success\*(C'\fR is
0, \f(CW%data\fR may or may not contain values, but its use is not recommended.
.SH "OBJECT INTERFACE"
.IX Header "OBJECT INTERFACE"
.ie n .SS "new( %args )"
.el .SS "new( \f(CW%args\fP )"
.IX Subsection "new( %args )"
At this point the only argument you can use in \f(CW%args\fR is \f(CW\*(C`filters\*(C'\fR,
which should be a hashref with additional filters to be added to the
\&\f(CW%FILTERS\fR hash.
.PP
.Vb 9
\&    my $v = Validate::Tiny\->new(
\&        filters => {
\&            only_digits => sub {
\&                my $val = shift // return;
\&                $val =~ s/\eD//g;
\&                return $val;
\&            }
\&        }
\&    );
.Ve
.ie n .SS "check( \e%input, %rules )"
.el .SS "check( \e%input, \f(CW%rules\fP )"
.IX Subsection "check( %input, %rules )"
Checks the input agains the rules and initalized internal result state.
.PP
.Vb 3
\&    my %input = ( bar => \*(Aqabc\*(Aq );
\&    my %rules = ( fields => [\*(Aqbar\*(Aq], filters => filter(\*(Aquc\*(Aq) );
\&    $v\->check( \e%input, \e%rules );
\&
\&    if ( $v\->success ) {
\&        ...;
\&    }
.Ve
.SS "success"
.IX Subsection "success"
Returns a true value if the input passed all the rules.
.SS "data"
.IX Subsection "data"
Returns a hash reference to all filtered fields. If called with a
parameter, it will return the value of that field or croak if there is no
such field defined in the fields array.
.PP
.Vb 2
\&    my $all_fields = $result\->data;
\&    my $email      = $result\->data(\*(Aqemail\*(Aq);
.Ve
.SS "error"
.IX Subsection "error"
Returns a hash reference to all error messages. If called with a
parameter, it will return the error message of that field, or croak if
there is no such field.
.PP
.Vb 2
\&    my $errors = $result\->error;
\&    my $email = $result\->error(\*(Aqemail\*(Aq);
.Ve
.SS "to_hash"
.IX Subsection "to_hash"
Return a result hash, much like using the procedural interface. See the
output of \*(L"validate\*(R" for more information.
.SH "I18N"
.IX Header "I18N"
A check function is considered failing if it returns a value. In the above
examples we showed you how to return error strings. If you want to
internationalize your errors, you can make your check closures return
Locale::Maketext functions, or any other i18n values.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::FormValidator
.SH "BUGS"
.IX Header "BUGS"
Bug reports and patches are welcome. Reports which include a failing
Test::More style test are helpful and will receive priority.
.PP
You may also fork the module on Github:
https://github.com/naturalist/Validate\*(--Tiny
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    Stefan G. (cpan: MINIMAL) \- minimal@cpan.org
.Ve
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.Vb 7
\&    Viktor Turskyi (cpan: KOORCHIK) \- koorchik@cpan.org
\&    Ivan Simonik (cpan: SIMONIKI) \- simoniki@cpan.org
\&    Daya Sagar Nune (cpan: DAYANUNE) \- daya.webtech@gmail.com
\&    val \- valkoles@gmail.com
\&    Patrice Clement (cpan: MONSIEURP) \- monsieurp@gentoo.org
\&    Graham Ollis (cpan: PLICEASE)
\&    Diab Jerius (cpan DJERIUS)
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
This program is free software; you can redistribute it and/or modify it
under the terms as perl itself.
