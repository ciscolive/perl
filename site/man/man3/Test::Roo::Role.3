.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Roo::Role 3"
.TH Test::Roo::Role 3 "2014-08-05" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Roo::Role \- Composable role for Test::Roo
.SH "VERSION"
.IX Header "VERSION"
version 1.004
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A testing role:
.PP
.Vb 3
\&    # t/lib/MyTestRole.pm
\&    package MyTestRole;
\&    use Test::Roo::Role; # loads Moo::Role and Test::More
\&
\&    requires \*(Aqclass\*(Aq;
\&
\&    test \*(Aqobject creation\*(Aq => sub {
\&        my $self = shift;
\&        require_ok( $self\->class );
\&        my $obj  = new_ok( $self\->class );
\&    };
\&
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines test behaviors as a Moo::Role.
.SH "USAGE"
.IX Header "USAGE"
Importing Test::Roo::Role also loads Moo::Role (which gives you
strictures with fatal warnings and other goodies).
.PP
Importing also loads Test::More.  Any import arguments are passed through to
Test::More's \f(CW\*(C`import\*(C'\fR method.
.SS "Creating and requiring fixtures"
.IX Subsection "Creating and requiring fixtures"
You can create fixtures with normal Moo syntax.  You can even make them lazy
if you want and require the composing class to provide the builder:
.PP
.Vb 3
\&    has fixture => (
\&        is => \*(Aqlazy\*(Aq
\&    );
\&
\&    requires \*(Aq_build_fixture\*(Aq;
.Ve
.PP
Because this is a Moo::Role, you can require any method you like, not
just builders.
.PP
See Moo::Role and Role::Tiny for everything you can do with roles.
.SS "Setup and teardown"
.IX Subsection "Setup and teardown"
You can add method modifiers around the \f(CW\*(C`setup\*(C'\fR and \f(CW\*(C`teardown\*(C'\fR methods and
these will be run before tests begin and after tests finish (respectively).
.PP
.Vb 1
\&    before  setup     => sub { ... };
\&
\&    after   teardown  => sub { ... };
.Ve
.PP
You can also add method modifiers around \f(CW\*(C`each_test\*(C'\fR, which will be
run before and after \fBevery\fR individual test.  You could use these to
prepare or reset a fixture.
.PP
.Vb 1
\&    has fixture => ( is => \*(Aqlazy, clearer => 1, predicate => 1 );
\&
\&    after  each_test => sub { shift\->clear_fixture };
.Ve
.PP
Roles may also modify \f(CW\*(C`setup\*(C'\fR, \f(CW\*(C`teardown\*(C'\fR, and \f(CW\*(C`each_test\*(C'\fR, so the order
that modifiers will be called will depend on when roles are composed.  Be
careful with \f(CW\*(C`each_test\*(C'\fR, though, because the global effect may make
composition more fragile.
.PP
You can call test functions in modifiers. For example, you could
confirm that something has been set up or cleaned up.
.PP
.Vb 1
\&    before each_test => sub { ok( ! shift\->has_fixture ) };
.Ve
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
Loading Test::Roo::Role exports a single subroutine into the calling package
to declare tests.
.SS "test"
.IX Subsection "test"
.Vb 1
\&    test $label => sub { ... };
.Ve
.PP
The \f(CW\*(C`test\*(C'\fR function adds a subtest.  The code reference will be called with
the test object as its only argument.
.PP
Tests are run in the order declared, so the order of tests from roles will
depend on when they are composed relative to other test declarations.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
