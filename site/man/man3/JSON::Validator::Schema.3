.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JSON::Validator::Schema 3"
.TH JSON::Validator::Schema 3 "2020-10-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Validator::Schema \- Base class for JSON::Validator schemas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  package JSON::Validator::Schema::SomeSchema;
\&  use Mojo::Base "JSON::Validator::Schema";
\&  has specification => "https://api.example.com/my/spec.json#";
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JSON::Validator::Schema is the base class for
JSON::Validator::Schema::Draft4,
JSON::Validator::Schema::Draft6 and
JSON::Validator::Schema::Draft7.
.PP
JSON::Validator::Schema is currently \s-1EXPERIMENTAL,\s0 and most probably will
change over the next versions as
<https://github.com/mojolicious/json\-validator/pull/189> (or a competing \s-1PR\s0)
evolves.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "errors"
.IX Subsection "errors"
.Vb 1
\&  my $array_ref = $schema\->errors;
.Ve
.PP
Holds the errors after checking \*(L"data\*(R" against \*(L"specification\*(R".
\&\f(CW$array_ref\fR containing no elements means \*(L"data\*(R" is valid. Each element in
the array-ref is a JSON::Validator::Error object.
.PP
This attribute is \fInot\fR changed by \*(L"validate\*(R". It only reflects if the
\&\f(CW$schema\fR is valid.
.SS "id"
.IX Subsection "id"
.Vb 2
\&  my $str    = $schema\->id;
\&  my $schema = $schema\->id($str);
.Ve
.PP
Holds the \s-1ID\s0 for this schema. Usually extracted from \f(CW"$id"\fR or \f(CW"id"\fR in
\&\*(L"data\*(R".
.SS "moniker"
.IX Subsection "moniker"
.Vb 2
\&  $str    = $schema\->moniker;
\&  $schema = $self\->moniker("some_name");
.Ve
.PP
Used to get/set the moniker for the given schema. Will be \*(L"draft04\*(R" if
\&\*(L"specification\*(R" points to a \s-1JSON\s0 Schema draft \s-1URL,\s0 and fallback to
empty string if unable to guess a moniker name.
.PP
This attribute will (probably) detect more monikers from a given
\&\*(L"specification\*(R" or \f(CW\*(C`/id\*(C'\fR in the future.
.SS "specification"
.IX Subsection "specification"
.Vb 2
\&  my $str    = $schema\->specification;
\&  my $schema = $schema\->specification($str);
.Ve
.PP
The \s-1URL\s0 to the specification used when checking for \*(L"errors\*(R". Usually
extracted from \f(CW"$schema"\fR or \f(CW"schema"\fR in \*(L"data\*(R".
.SH "METHODS"
.IX Header "METHODS"
.SS "bundle"
.IX Subsection "bundle"
.Vb 1
\&  my $bundled = $schema\->bundle;
.Ve
.PP
\&\f(CW$bundled\fR is a new JSON::Validator::Schema object where none of the \*(L"$ref\*(R"
will point to external resources. This can be useful, if you want to have a
bunch of files locally, but hand over a single file to a client.
.PP
.Vb 2
\&  Mojo::File\->new("client.json")
\&    \->spurt(Mojo::JSON::to_json($schema\->bundle\->data));
.Ve
.SS "coerce"
.IX Subsection "coerce"
.Vb 3
\&  my $schema   = $schema\->coerce("booleans,defaults,numbers,strings");
\&  my $schema   = $schema\->coerce({booleans => 1});
\&  my $hash_ref = $schema\->coerce;
.Ve
.PP
Set the given type to coerce. Before enabling coercion this module is very
strict when it comes to validating types. Example: The string \f(CW"1"\fR is not
the same as the number \f(CW1\fR. Note that it will also change the internal
data-structure of the validated data: Example:
.PP
.Vb 2
\&  $schema\->coerce({numbers => 1});
\&  $schema\->data({properties => {age => {type => "integer"}}});
\&
\&  my $input = {age => "42"};
\&  $schema\->validate($input);
\&  # $input\->{age} is now an integer 42 and not the string "42"
.Ve
.SS "contains"
.IX Subsection "contains"
See \*(L"contains\*(R" in Mojo::JSON::Pointer.
.SS "data"
.IX Subsection "data"
.Vb 4
\&  my $hash_ref = $schema\->data;
\&  my $schema   = $schema\->data($bool);
\&  my $schema   = $schema\->data($hash_ref);
\&  my $schema   = $schema\->data($url);
.Ve
.PP
Will set a structure representing the schema. In most cases you want to
use \*(L"resolve\*(R" instead of \*(L"data\*(R".
.SS "get"
.IX Subsection "get"
.Vb 2
\&  my $data = $schema\->get($json_pointer);
\&  my $data = $schema\->get($json_pointer, sub { my ($data, $json_pointer) = @_; });
.Ve
.PP
Called with one argument, this method acts like \*(L"get\*(R" in Mojo::JSON::Pointer,
while if called with two arguments it will work like
\&\*(L"schema_extract\*(R" in JSON::Validator::Util instead:
.PP
.Vb 1
\&  JSON::Validator::Util::schema_extract($schema\->data, sub { ... });
.Ve
.PP
The second argument can be \f(CW\*(C`undef()\*(C'\fR, if you don't care about the callback.
.PP
See \*(L"get\*(R" in Mojo::JSON::Pointer.
.SS "new"
.IX Subsection "new"
.Vb 3
\&  my $schema = JSON::Validator::Schema\->new($data);
\&  my $schema = JSON::Validator::Schema\->new($data, %attributes);
\&  my $schema = JSON::Validator::Schema\->new(%attributes);
.Ve
.PP
Construct a new JSON::Validator::Schema object. Passing on \f(CW$data\fR as the
first argument will cause \*(L"resolve\*(R" to be called, meaning the constructor
might throw an exception if the schema could not be successfully resolved.
.SS "resolve"
.IX Subsection "resolve"
.Vb 2
\&  $schema = $schema\->resolve;
\&  $schema = $schema\->resolve($data);
.Ve
.PP
Used to resolve \*(L"data\*(R" or \f(CW$data\fR and store the resolved schema in \*(L"data\*(R".
If \f(CW$data\fR is an \f(CW$url\fR on contains \*(L"$ref\*(R" pointing to an \s-1URL,\s0 then these
schemas will be downloaded and resolved as well.
.SS "validate"
.IX Subsection "validate"
.Vb 1
\&  my @errors = $schema\->validate($any);
.Ve
.PP
Will validate \f(CW$any\fR against the schema defined in \*(L"data\*(R". Each element in
\&\f(CW@errors\fR is a JSON::Validator::Error object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
JSON::Validator.
