.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Text::PDF::Objind 3"
.TH Text::PDF::Objind 3 "2016-08-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::PDF::Objind \- PDF indirect object reference. Also acts as an abstract
superclass for all elements in a PDF file.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
Instance variables differ from content variables in that they all start with
a space.
.IP "parent" 4
.IX Item "parent"
For an object which is a reference to an object in some source, this holds the
reference to the source object, so that should the reference have to be
de-referenced, then we know where to go and get the info.
.IP "objnum (R)" 4
.IX Item "objnum (R)"
The object number in the source (only for object references)
.IP "objgen (R)" 4
.IX Item "objgen (R)"
The object generation in the source
.Sp
There are other instance variables which are used by the parent for file control.
.IP "isfree" 4
.IX Item "isfree"
This marks whether the object is in the free list and available for re-use as
another object elsewhere in the file.
.IP "nextfree" 4
.IX Item "nextfree"
Holds a direct reference to the next free object in the free list.
.SH "METHODS"
.IX Header "METHODS"
.SS "Text::PDF::Objind\->\fBnew()\fP"
.IX Subsection "Text::PDF::Objind->new()"
Creates a new indirect object
.SS "uid"
.IX Subsection "uid"
Returns a Unique id for this object, creating one if it didn't have one before
.ie n .SS "$r\->release"
.el .SS "\f(CW$r\fP\->release"
.IX Subsection "$r->release"
Releases \s-1ALL\s0 of the memory used by this indirect object, and all of its
component/child objects.  This method is called automatically by
\&'\f(CW\*(C`Text::PDF::File\->release\*(C'\fR' (so you don't have to call it yourself).
.PP
\&\fB\s-1NOTE\s0\fR, that it is important that this method get called at some point prior
to the actual destruction of the object.  Internally, \s-1PDF\s0 files have an
enormous amount of cross-references and this causes circular references within
our own internal data structures.  Calling '\f(CW\*(C`release()\*(C'\fR' forces these circular
references to be cleaned up and the entire internal data structure purged.
.PP
\&\fBDeveloper note:\fR As part of the brute-force cleanup done here, this method
will throw a warning message whenever unexpected key values are found within
the \f(CW\*(C`Text::PDF::Objind\*(C'\fR object.  This is done to help ensure that unexpected
and unfreed values are brought to your attention, so you can bug us to keep the
module updated properly; otherwise the potential for memory leaks due to
dangling circular references will exist.
.ie n .SS "$r\->val"
.el .SS "\f(CW$r\fP\->val"
.IX Subsection "$r->val"
Returns the val of this object or reads the object and then returns its value.
.PP
Note that all direct subclasses *must* make their own versions of this subroutine
otherwise we could be in for a very deep loop!
.ie n .SS "$r\->realise"
.el .SS "\f(CW$r\fP\->realise"
.IX Subsection "$r->realise"
Makes sure that the object is fully read in, etc.
.ie n .SS "$r\->outobjdeep($fh, $pdf)"
.el .SS "\f(CW$r\fP\->outobjdeep($fh, \f(CW$pdf\fP)"
.IX Subsection "$r->outobjdeep($fh, $pdf)"
If you really want to output this object, then you must need to read it first.
This also means that all direct subclasses must subclass this method or loop forever!
.ie n .SS "$r\->outobj($fh)"
.el .SS "\f(CW$r\fP\->outobj($fh)"
.IX Subsection "$r->outobj($fh)"
If this is a full object then outputs a reference to the object, otherwise calls
outobjdeep to output the contents of the object at this point.
.ie n .SS "$r\->elementsof"
.el .SS "\f(CW$r\fP\->elementsof"
.IX Subsection "$r->elementsof"
Abstract superclass function filler. Returns self here but should return
something more useful if an array.
.ie n .SS "$r\->empty"
.el .SS "\f(CW$r\fP\->empty"
.IX Subsection "$r->empty"
Empties all content from this object to free up memory or to be read to pass
the object into the free list. Simplistically undefs all instance variables
other than object number and generation.
.ie n .SS "$r\->merge($objind)"
.el .SS "\f(CW$r\fP\->merge($objind)"
.IX Subsection "$r->merge($objind)"
This merges content information into an object reference place-holder.
This occurs when an object reference is read before the object definition
and the information in the read data needs to be merged into the object
place-holder
.ie n .SS "$r\->is_obj($pdf)"
.el .SS "\f(CW$r\fP\->is_obj($pdf)"
.IX Subsection "$r->is_obj($pdf)"
Returns whether this object is a full object with its own object number or
whether it is purely a sub-object. \f(CW$pdf\fR indicates which output file we are
concerned that the object is an object in.
.ie n .SS "$r\->copy($inpdf, $res, $unique, $outpdf, %opts)"
.el .SS "\f(CW$r\fP\->copy($inpdf, \f(CW$res\fP, \f(CW$unique\fP, \f(CW$outpdf\fP, \f(CW%opts\fP)"
.IX Subsection "$r->copy($inpdf, $res, $unique, $outpdf, %opts)"
Returns a new copy of this object.
.PP
\&\f(CW$inpdf\fR gives the source pdf object for the object to be copied. \f(CW$outpdf\fR gives the
target pdf for the object to be copied into. \f(CW$outpdf\fR may be undefined. \f(CW$res\fR may be
defined in which case the object is copied into that object. \f(CW$unique\fR controls
recursion. if \f(CW$unique\fR is non zero then new objects are always created and recursion
always occurs. But each time recursion occurs, \f(CW$unique\fR is incremented. Thus is \f(CW$unique\fR
starts with a negative value it is possible to stop the recursion at a certain depth. Of
course for a positive value of \f(CW$unique\fR, recursion always occurs.
.PP
If \f(CW$unique\fR is 0 then recursion only occurs if \f(CW$outpdf\fR is not the same as \f(CW$inpdf\fR. In this
case, a cache is held in \f(CW$outpdf\fR to see whether a previous copy of the same object has
been made. If so, then that previous copy is returned otherwise a new object is made and
added to the cache and recursed into.
.PP
Objects that are full objects with their own id numbers are correspondingly full objects
in the output pdf.
