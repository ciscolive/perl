.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::Curl::Promiser 3"
.TH Net::Curl::Promiser 3 "2020-07-28" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Curl::Promiser \- Asynchronous libcurl <https://curl.haxx.se/libcurl/>, the easy way!
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::Curl::Multi is powerful but tricky to use: polling, callbacks,
timers, etc. This module does all of that for you and puts a Promise
interface on top of it, so asynchronous I/O becomes almost as simple as
synchronous I/O.
.PP
Net::Curl::Promiser itself is a base class; you’ll need to use
a subclass that works with your chosen event interface.
.PP
This distribution provides the following usable subclasses:
.IP "\(bu" 4
Net::Curl::Promiser::Mojo (for Mojolicious)
.IP "\(bu" 4
Net::Curl::Promiser::AnyEvent (for AnyEvent)
.IP "\(bu" 4
Net::Curl::Promiser::IOAsync (for IO::Async)
.IP "\(bu" 4
Net::Curl::Promiser::Select (for manually-written
\&\f(CW\*(C`select()\*(C'\fR loops)
.PP
If the event interface you want to use isn’t compatible with one of the
above, you’ll need to create your own Net::Curl::Promiser subclass.
This is undocumented but pretty simple; have a look at the ones above as
well as another based on Linux’s \fBepoll\fR\|(7) in the distribution’s
\&\fI/examples\fR.
.SH "MEMORY LEAK DETECTION"
.IX Header "MEMORY LEAK DETECTION"
This module will, by default, \f(CW\*(C`warn()\*(C'\fR if its objects are \f(CW\*(C`DESTROY()\*(C'\fRed
during Perl’s global destruction phase. To suppress this behavior, set
\&\f(CW$Net::Curl::Promiser::IGNORE_MEMORY_LEAKS\fR to a truthy value.
.SH "PROMISE IMPLEMENTATION"
.IX Header "PROMISE IMPLEMENTATION"
This class’s default Promise implementation is Promise::ES6.
You can use a different one by overriding the \f(CW\*(C`PROMISE_CLASS()\*(C'\fR method in
a subclass, as long as the substitute class’s \f(CW\*(C`new()\*(C'\fR method works the
same way as Promise::ES6’s (which itself follows the ECMAScript standard).
.PP
(\s-1NB:\s0 Net::Curl::Promiser::Mojo uses Mojo::Promise instead of
Promise::ES6.)
.SS "\fBExperimental\fP Promise::XS support"
.IX Subsection "Experimental Promise::XS support"
Try out experimental Promise::XS support by running with
\&\f(CW\*(C`NET_CURL_PROMISER_PROMISE_ENGINE=Promise::XS\*(C'\fR in your environment.
This will override \f(CW\*(C`PROMISE_CLASS()\*(C'\fR.
.SH "DESIGN NOTES"
.IX Header "DESIGN NOTES"
Internally each instance of this class uses an instance of
Net::Curl::Multi and an instance of Net::Curl::Promiser::Backend.
(The latter, in turn, is subclassed to provide logic specific to
each event interface.) These are kept separate to avoid circular references.
.SH "GENERAL-USE METHODS"
.IX Header "GENERAL-USE METHODS"
The following are of interest to any code that uses this module:
.SS "\fI\s-1CLASS\s0\fP\->new(@ARGS)"
.IX Subsection "CLASS->new(@ARGS)"
Instantiates this class, including creation of an underlying
Net::Curl::Multi object.
.ie n .SS "promise($EASY) = \fI\s-1OBJ\s0\fP\->add_handle( $EASY )"
.el .SS "promise($EASY) = \fI\s-1OBJ\s0\fP\->add_handle( \f(CW$EASY\fP )"
.IX Subsection "promise($EASY) = OBJ->add_handle( $EASY )"
A passthrough to the underlying Net::Curl::Multi object’s
method of the same name, but the return is given as a Promise object.
.PP
That promise resolves with the passed-in \f(CW$EASY\fR object.
It rejects with either the error given to \f(CW\*(C`fail_handle()\*(C'\fR or the
error that Net::Curl::Multi object’s \f(CW\*(C`info_read()\*(C'\fR returns.
.PP
\&\fB\s-1IMPORTANT:\s0\fR As with libcurl itself, HTTP-level failures
(e.g., 4xx and 5xx responses) are \fB\s-1NOT\s0\fR considered failures at this level.
.ie n .SS "$obj = \fI\s-1OBJ\s0\fP\->cancel_handle( $EASY )"
.el .SS "\f(CW$obj\fP = \fI\s-1OBJ\s0\fP\->cancel_handle( \f(CW$EASY\fP )"
.IX Subsection "$obj = OBJ->cancel_handle( $EASY )"
Prematurely cancels \f(CW$EASY\fR. The associated promise will be abandoned
in pending state, never to resolve nor reject.
.PP
Returns \fI\s-1OBJ\s0\fR.
.ie n .SS "$obj = \fI\s-1OBJ\s0\fP\->fail_handle( $EASY, $REASON )"
.el .SS "\f(CW$obj\fP = \fI\s-1OBJ\s0\fP\->fail_handle( \f(CW$EASY\fP, \f(CW$REASON\fP )"
.IX Subsection "$obj = OBJ->fail_handle( $EASY, $REASON )"
Like \f(CW\*(C`cancel_handle()\*(C'\fR but rejects \f(CW$EASY\fR’s associated promise
with the given \f(CW$REASON\fR.
.PP
Returns \fI\s-1OBJ\s0\fR.
.ie n .SS "$obj = \fI\s-1OBJ\s0\fP\->setopt( … )"
.el .SS "\f(CW$obj\fP = \fI\s-1OBJ\s0\fP\->setopt( … )"
.IX Subsection "$obj = OBJ->setopt( … )"
A passthrough to the underlying Net::Curl::Multi object’s
method of the same name. Returns \fI\s-1OBJ\s0\fR to facilitate chaining.
.PP
This class requires control of certain Net::Curl::Multi options;
if you attempt to set one of these here you’ll get an exception.
.ie n .SS "$obj = \fI\s-1OBJ\s0\fP\->handles( … )"
.el .SS "\f(CW$obj\fP = \fI\s-1OBJ\s0\fP\->handles( … )"
.IX Subsection "$obj = OBJ->handles( … )"
A passthrough to the underlying Net::Curl::Multi object’s
method of the same name.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the distribution’s \fI/examples\fR directory.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Curl::Simple implements a similar idea to this module but
doesn’t return promises. It has a more extensive interface that provides
a more “perlish” experience than Net::Curl::Easy.
.PP
If you use AnyEvent, then AnyEvent::XSPromises with
AnyEvent::YACurl may be a nicer fit for you.
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/FGasper/p5\-Net\-Curl\-Promiser>
.SH "LICENSE & COPYRIGHT"
.IX Header "LICENSE & COPYRIGHT"
Copyright 2019\-2020 Gasper Software Consulting.
.PP
This library is licensed under the same terms as Perl itself.
