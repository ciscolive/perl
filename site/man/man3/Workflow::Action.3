.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Workflow::Action 3"
.TH Workflow::Action 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Workflow::Action \- Base class for Workflow actions
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.09 of this package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\& # Configure the Action...
\& <action name="CreateUser"
\&         class="MyApp::Action::CreateUser">
\&   <field name="username" is_required="yes"/>
\&   <field name="email" is_required="yes"/>
\&   <validator name="IsUniqueUser">
\&       <arg>$username</arg>
\&   </validator>
\&   <validator name="IsValidEmail">
\&       <arg>$email</arg>
\&   </validator>
\& </action>
\&
\& # Define the action
\&
\& package MyApp::Action::CreateUser;
\&
\& use base qw( Workflow::Action );
\& use Workflow::Exception qw( workflow_error );
\&
\& sub execute {
\&     my ( $self, $wf ) = @_;
\&     my $context = $wf\->context;
\&
\&     # Since \*(Aqusername\*(Aq and \*(Aqemail\*(Aq have already been validated we
\&     # don\*(Aqt need to check them for uniqueness, well\-formedness, etc.
\&
\&     my $user = eval {
\&         User\->create({ username => $context\->param( \*(Aqusername\*(Aq ),
\&                        email    => $context\->param( \*(Aqemail\*(Aq ) })
\&     };
\&
\&     # Wrap all errors returned...
\&
\&     if ( $@ ) {
\&         workflow_error
\&             "Cannot create new user with name \*(Aq", $context\->param( \*(Aqusername\*(Aq ), "\*(Aq: $EVAL_ERROR";
\&     }
\&
\&     # Set the created user in the context for the application and/or
\&     # other actions (observers) to use
\&
\&     $context\->param( user => $user );
\&
\&     # return the username since it might be used elsewhere...
\&     return $user\->username;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for all Workflow Actions. You do not have to
use it as such but it is strongly recommended.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
You configure your actions and map them to a specific module in your actions
configuration file using the syntax
above and that shown in Workflow. In some cases, you'll have actions
that apply to all workflows. In more elaborate configurations, you may have
one workflow server loading multiple workflows and multiple actions for each.
In these
cases, you'll have multiple workflow types and you may want actions
with the same names to have different behaviors for each type.
.PP
For example, you may have a workflow type Ticket and another type Order_Parts.
They both may have a Submit action, but you'll want the Submit to be different
for each.
.PP
You can specify a type in your actions configuration to associate that action
with that workflow type. If you don't provide a type, the action is available
to all types. For example:
.PP
.Vb 6
\&  <actions>
\&    <type>Ticket</type>
\&    <description>Actions for the Ticket workflow only.</description>
\&    <action name="TIX_NEW"
\&           class="TestApp::Action::TicketCreate">
\&  ...Addtional configuration...
.Ve
.PP
The type must match an existing workflow type or the action will never
be called.
.SH "ADDITIONAL ATTRIBUTES"
.IX Header "ADDITIONAL ATTRIBUTES"
You can validate additional attributes in of your action by doing two things:
.IP "\(bu" 4
Set \f(CW$Workflow::Factory::VALIDATE_ACTION_CONFIG\fR to 1.
.IP "\(bu" 4
Provide function \fBvalidate_config()\fR in your action class.
.PP
Then, this function will be called with all the acton attributes when
it is parsed.  For exmaple, if your action \s-1XML\s0 looks like this:
.PP
.Vb 1
\&  <action name="BEGIN" class="My::Class" when="NOW">
.Ve
.PP
You can validate it like this:
.PP
.Vb 7
\&  sub My::Class::validate_config {
\&    my $config = shift;
\&    unless (\*(AqNOW\*(Aq eq $config\->{when}) {
\&      configuration_error "\`$$config{when}\*(Aq is not a valid value " .
\&                          "for \`when\*(Aq";
\&    }
\&  }
.Ve
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "Public Methods"
.IX Subsection "Public Methods"
\fI\f(BInew()\fI\fR
.IX Subsection "new()"
.PP
Subclasses may override this method, but it's not very common. It is
called when you invoke a method in your Workflow object that returns
an Action object, for example, methods such as \f(CW$wf\fR\->_get_action will
call this method.
.PP
\&\fBYour action classes usually subclass directly from Workflow::Action
and they \f(BIdon't\fB need to override this method at all\fR. However, under
some circumstances, you may find the need to extend your action
classes.
.PP
Suppose you want to define some extra properties to actions but you
also want for some of these properties to depend on a particular
state. For example, the action \*(L"icon\*(R" will almost allways be the same,
but the action \*(L"index\*(R" will depend on state, so you can display your
actions in a certain order according to that particular state. Here is
an example on how you easily do this by overriding \fBnew()\fR:
.PP
1) Set the less changing properties in your action definition:
.PP
.Vb 6
\&  <actions>
\&    <type>foo</type>
\&    <action name="Browse"
\&      type="menu_button" icon="list_icon"
\&      class="actual::action::class">
\&    </action>
.Ve
.PP
2) Set the state dependant properties in the state definition:
.PP
.Vb 12
\& <state name="INITIAL">
\&   <description>
\&     Manage Manufaturers
\&   </description>
\&   <action index="0" name="Browse" resulting_state="BROWSE">
\&     <condition name="roleis_oem_mgmt"/>
\&   </action>
\&   <action index="1" name="Create" resulting_state="CREATE">
\&     <condition name="roleis_oem_mgmt"/>
\&   </action>
\&   <action index="2" name="Back" resulting_state="CLOSED"/>
\& </state>
.Ve
.PP
3) Craft a custom action base class
.PP
.Vb 1
\&  package your::action::base::class;
\&
\&  use warnings;
\&  use strict;
\&
\&  use base qw( Workflow::Action );
\&  use Workflow::Exception qw( workflow_error );
\&
\&  # extra action class properties
\&  my @EXTRA_PROPS = qw( index icon type data );
\&  _\|_PACKAGE_\|_\->mk_accessors(@EXTRA_PROPS);
\&
\&  sub new {
\&    my ($class, $wf, $params) = @_;
\&    my $self = $class\->SUPER::new($wf, $params);
\&    # set only our extra properties from action class def
\&    foreach my $prop (@EXTRA_PROPS) {
\&      next if ( $self\->$prop );
\&      $self\->$prop( $params\->{$prop} );
\&    }
\&    # override specific extra action properties according to state
\&    my $wf_state = $wf\->_get_workflow_state;
\&    my $action = $wf_state\->{_actions}\->{$self\->name};
\&    $self\->index($action\->{index});
\&    return $self;
\&  }
\&
\&
\&  1;
.Ve
.PP
\&\fBNote\fR: this hack takes advantage of the fact that the \s-1XML\s0 parser
picks up the extra parameters and add them to the action hash of the
current \f(CW$wf_state\fR. Your milage may vary.
.PP
4) Use your custom action base class instead of the default
.PP
.Vb 1
\&  package actual::action::class;
\&
\&  use warnings;
\&  use strict;
\&
\&  use base qw( your::base::action::class );
\&  use Workflow::Exception qw( workflow_error );
\&
\&  sub execute {
\&    ...
\&  }
\&
\&  1;
.Ve
.SS "Private Methods"
.IX Subsection "Private Methods"
\fIinit( \f(CI$workflow\fI, \e%params )\fR
.IX Subsection "init( $workflow, %params )"
.PP
init is called in conjuction with the overall workflow initialization.
.PP
It sets up the necessary validators based on the on configured actions, input fields and required fields.
.PP
\fIadd_field( \f(CI@fields\fI )\fR
.IX Subsection "add_field( @fields )"
.PP
Add one or more Workflow::Action::InputFields to the action.
.PP
\fI\f(BIrequired_fields()\fI\fR
.IX Subsection "required_fields()"
.PP
Return a list of Workflow::Action::InputField objects that are required.
.PP
\fI\f(BIoptional_fields()\fI\fR
.IX Subsection "optional_fields()"
.PP
Return a list of Workflow::Action::InputField objects that are optional.
.PP
\fI\f(BIfields()\fI\fR
.IX Subsection "fields()"
.PP
Return a list of all Workflow::Action::InputField objects
associated with this action.
.PP
\fIadd_validators( \f(CI@validator_config\fI )\fR
.IX Subsection "add_validators( @validator_config )"
.PP
Given the 'validator' configuration declarations in the action
configuration, ask the Workflow::Factory for the
Workflow::Validator object associated with each name and store that
along with the arguments to be used, runtime and otherwise.
.PP
\fI\f(BIget_validators()\fI\fR
.IX Subsection "get_validators()"
.PP
Get a list of all the validator hashrefs, each with two keys:
\&'validator' and 'args'. The 'validator' key contains the appropriate
Workflow::Validator object, while 'args' contains an arrayref of
arguments to pass to the validator, some of which may need to be
evaluated at runtime.
.PP
\fIvalidate( \f(CI$workflow\fI )\fR
.IX Subsection "validate( $workflow )"
.PP
Run through all validators for this action. If any fail they will
throw a Workflow::Exception, the validation subclass.
.PP
\fIexecute( \f(CI$workflow\fI )\fR
.IX Subsection "execute( $workflow )"
.PP
Subclasses \fBmust\fR implement \*(-- this will perform the actual
work. It's not required that you return anything, but if the action
may be used in a Workflow::State object that has multiple resulting
states you should return a simple scalar for a return value.
.PP
\fIadd_fields\fR
.IX Subsection "add_fields"
.PP
Method to add fields to the workflow. The method takes an array of
fields.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Workflow
.PP
Workflow::Factory
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2004 Chris Winters. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Winters <chris@cwinters.com>
