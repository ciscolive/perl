.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MooseX::ShortCut::BuildInstance 3"
.TH MooseX::ShortCut::BuildInstance 3 "2016-08-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::ShortCut::BuildInstance \- A shortcut to build Moose instances
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        #!/user/bin/env perl
\&        package Mineral;
\&        use Moose;
\&        use Types::Standard qw( Enum );
\&
\&        has \*(Aqtype\*(Aq =>(
\&                        isa => Enum[qw( Quartz Diamond Basalt Granite )],
\&                        is => \*(Aqro\*(Aq
\&                );
\&
\&        package Identity;
\&        use Moose::Role;
\&
\&        has \*(Aqname\*(Aq =>( is => \*(Aqro\*(Aq );
\&
\&        use lib \*(Aq../../../lib\*(Aq;
\&        use MooseX::ShortCut::BuildInstance qw( should_re_use_classes build_instance );
\&        should_re_use_classes( 1 );# To reuse build_instance
\&        use Test::More;
\&        use Test::Moose;
\&
\&        # First build of instance
\&        my      $paco = build_instance(
\&                        package => \*(AqPet::Rock\*(Aq,
\&                        superclasses =>[\*(AqMineral\*(Aq],
\&                        roles =>[\*(AqIdentity\*(Aq],
\&                        type => \*(AqQuartz\*(Aq,
\&                        name => \*(AqPaco\*(Aq,
\&                );
\&
\&        does_ok( $paco, \*(AqIdentity\*(Aq, \*(AqCheck that the \*(Aq . $paco\->meta\->name . \*(Aq has an \-Identity\-\*(Aq );
\&        print\*(AqMy \*(Aq . $paco\->meta\->name . \*(Aq made from \-\*(Aq . $paco\->type . \*(Aq\- (a \*(Aq .
\&        ( join \*(Aq, \*(Aq, $paco\->meta\->superclasses ) . \*(Aq) is called \-\*(Aq . $paco\->name . "\-\en";
\&
\&        # Next instance (If you don\*(Aqt want to call build_instance again)
\&        my $Fransisco = Pet::Rock\->new(
\&                type => \*(AqDiamond\*(Aq,
\&                name => \*(AqFransisco\*(Aq,
\&        );
\&        does_ok( $Fransisco, \*(AqIdentity\*(Aq, \*(AqCheck that the \*(Aq . $Fransisco\->meta\->name . \*(Aq has an \-Identity\-\*(Aq );
\&        print\*(AqMy \*(Aq . $Fransisco\->meta\->name . \*(Aq made from \-\*(Aq . $Fransisco\->type . \*(Aq\- (a \*(Aq .
\&        ( join \*(Aq, \*(Aq, $Fransisco\->meta\->superclasses ) . \*(Aq) is called \-\*(Aq . $Fransisco\->name . "\-\en";
\&
\&        # Another instance (reusing build_instance)
\&        my $Gonzalo = build_instance(
\&                        package => \*(AqPet::Rock\*(Aq,
\&                        superclasses =>[\*(AqMineral\*(Aq],
\&                        roles =>[\*(AqIdentity\*(Aq],
\&                        type => \*(AqGranite\*(Aq,
\&                        name => \*(AqGonzalo\*(Aq,
\&                );
\&        does_ok( $Gonzalo, \*(AqIdentity\*(Aq, \*(AqCheck that the \*(Aq . $Gonzalo\->meta\->name . \*(Aq has an \-Identity\-\*(Aq );
\&        print\*(AqMy \*(Aq . $Gonzalo\->meta\->name . \*(Aq made from \-\*(Aq . $Gonzalo\->type . \*(Aq\- (a \*(Aq .
\&        ( join \*(Aq, \*(Aq, $Gonzalo\->meta\->superclasses ) . \*(Aq) is called \-\*(Aq . $Gonzalo\->name . "\-\en";
\&        done_testing();
\&
\&    ##############################################################################
\&    # Output of SYNOPSIS
\&    # 01:ok 1 \- Check that the Pet::Rock has an \-Identity\-
\&    # 02:My Pet::Rock made from \-Quartz\- (a Mineral) is called \-Paco\-
\&    # 01:ok 1 \- Check that the Pet::Rock has an \-Identity\-
\&    # 02:My Pet::Rock made from \-Diamond\- (a Mineral) is called \-Fransisco\-
\&    # 01:ok 1 \- Check that the Pet::Rock has an \-Identity\-
\&    # 02:My Pet::Rock made from \-Granite\- (a Mineral) is called \-Gonzalo\-
\&    # 03:1..3
\&    ##############################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a shortcut to custom build Moose class instances on the fly.
The goal is to compose unique instances of Moose classes on the fly using a single
function call with information describing required attributes, methods, inherited
classes, and roles as well as any desired instance settings.  This package will
check for and fill in any missing pieces as needed so that your call can either be
complex or very simple.  The goal is to provide configurable instance building
without stringing together a series of Class\->method( \f(CW%args\fR ) calls.
.PP
The package can also be used as a class factory with the should_re_use_classes
 method.
.PP
Even though this is a Moose based class it provides a functional interface.
.SH "WARNING(S)"
.IX Header "WARNING(S)"
Moose (and I think perl 5) can't have two classes with the same name but
different guts coexisting! This means that if you build a class (package) name
on the fly while building an instance and then recompose a new class (package) with
the same name but different functionality (different attributes, methods, inherited
classes or roles) while composing a new instance on the fly then all calls
to the old instance will use the new class functionality for execution. (Usually
causing hard to troubleshoot failures).  This is also true if you re-build a
prebuilt class name inititally installed with 'use'.
.PP
MooseX::ShortCut::BuildInstance will warn if you overwrite named classes (packages)
built on top of another class (package) also built by MooseX::ShortCut::BuildInstance.
If you are using the 'build_instance' method to generate multiple instances of
the same class (by 'package' name) with different attribute settings but built
with the same functionality then you need to understand the purpose of the
\&\f(CW$re_use_classes\fR global variable.
An alternative to multiple calls straight to 'build_instance' is to call
build_class separately and then just call \->new
against the resulting class name over and over again.  Another alternative is to
leave the 'package' argument out of 'build_instance' and let this class create a
unique by-instance anonymous class/package name.
.PP
MooseX::ShortCut::BuildInstance will also warn (but not stop you) if you try to
overwrite a pre-loaded package initially installed with 'use' or 'require'.
.PP
The Types module in this package uses Type::Tiny which can, in the
background, use Type::Tiny::XS.  While in general this is a good thing you will
need to make sure that Type::Tiny::XS is version 0.010 or newer since the older
ones didn't support the 'Optional' method.
.PP
This package will clone the passed arguments to build_class and
build_instance since the references are destructivly parsed.
If that is not what you want then use the method set_args_cloning
 to manage the desired process.  Where this is likley
to go south is if your passed arguments contain a deep perl data set or reference
that you want shared.  In this case clone only the bits you want cloned on the
script side.
.SH "Functions for Export"
.IX Header "Functions for Export"
.ie n .SS "build_instance( %args|\e%args )"
.el .SS "build_instance( \f(CW%args\fP|\e%args )"
.IX Subsection "build_instance( %args|%args )"
.RS 4
\&\fBDefinition:\fR This method is used to create a Moose instance on the fly.
\&\fIIt assumes that you do not have the class pre-built and will look for the
needed information to compose a new class as well.\fR  Basically this passes the
\&\f(CW%args\fR intact to build_class first.  All the
relevant class building pieces will be used and removed from the args and then
this method will run \f(CW$returned_class_name\fR\->new( \f(CW%remaining_args\fR ) with what is
left.
.Sp
\&\fBAccepts:\fR a hash or hashref of arguments.  They must include the
necessary information to build a class.  \fI(if you already have a class just
call \f(CI$class\fI\->new( \f(CI%args\fI ); instead of this method!)\fR This hashref can also
contain any attribute settings for the instance as well.  See
build_class for more information.
.Sp
\&\fBReturns:\fR This will return a blessed instance of your new class with
the passed attribute settings implemented.
.RE
.ie n .SS "build_class( %args|\e%args )"
.el .SS "build_class( \f(CW%args\fP|\e%args )"
.IX Subsection "build_class( %args|%args )"
.RS 4
\&\fBDefinition:\fR This function is used to compose a Moose class on the fly.  The
the goal is to allow for as much or as little class definition as you want to be
provided by one function call.  The goal is also to remove as much of the boilerplate
and logic sequences for class building as possible and let this package handle that.
The function begins by using the Moose::Meta::Class\->class(%args) method.
For this part the function specifically uses the argument callouts 'package',
\&'superclasses', and 'roles'.  Any necessary missing pieces will be provided. \fIEven
though Moose::Meta::Class\->class(%args) allows for the package name to be called
as the first element of an odd numbered list this implementation does not.  To define
a 'package' name it must be set as the value of the 'package' key in the \f(CI%args\fI.\fR
This function then takes the following arguements; 'add_attributes', 'add_methods',
and 'add_roles_in_sequence' and implements them in that order.   The
implementation of these values is done with Moose::Util 'apply_all_roles'
and the meta capability in Moose.
.Sp
\&\fBAccepts:\fR a hash or hashref of arguments.  Six keys are stripped from the hash or
hash ref of arguments.  \fIThese keys are always used to build the class.  They are
never passed on to \f(CI%remaining_args\fI.\fR
.Sp
.RS 4
\&\fBThe first three key\->value pairs are consumed simultaneously\fR.  They are;
.Sp
.RS 4
\&\fBpackage:\fR This is the name (a string) that the new instance of
a this class is blessed under.  If this key is not provided the package
will generate a generic name.  This will overwrite any class
built earlier with the same name.
.Sp
.RS 4
\&\fBaccepts:\fR a string
.RE
.RE
.RS 4
.Sp
\&\fBsuperclasses:\fR this is intentionally the same key from
Moose::Meta::Class\->create.
.Sp
.RS 4
\&\fBaccepts:\fR a recognizable (by Moose) class name
.RE
.RE
.RS 4
.Sp
\&\fBroles:\fR this is intentionally the same key from Moose::Meta::Class
\&\->create.
.Sp
.RS 4
\&\fBaccepts:\fR a recognizable (by Moose) class name
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBThe second three key\->value pairs are consumed in the following
sequence\fR.  They are;
.Sp
.RS 4
\&\fBadd_attributes:\fR this will add attributes to the class using the
Moose::Meta::Class\->add_attribute method.  Because these definitions
are passed as key / value pairs in a hash ref they are not added in
any specific order.
.Sp
.RS 4
\&\fBaccepts:\fR a hash ref where the keys are attribute names and the values
are hash refs of the normal definitions used to define a Moose attribute.
.RE
.RE
.RS 4
.Sp
\&\fBadd_methods:\fR  this will add methods to the class using the
Moose::Meta::Class\->add_method method.  Because these definitions
are passed as key / value pairs in a hash ref they are not added in
any specific order.
.Sp
.RS 4
\&\fBaccepts:\fR a hash ref where the keys are method names and the values
are anonymous subroutines or subroutine references.
.RE
.RE
.RS 4
.Sp
\&\fBadd_roles_in_sequence:\fR this will compose, in sequence, each role in
the array ref into the class built on the prior three arguments using
Moose::Util apply_all_roles.  This will allow an added role to
\&'require' elements of a role earlier in the sequence.  The roles
implemented with the role key are installed first and in a
group. Then these roles are installed one at a time.
.Sp
.RS 4
\&\fBaccepts:\fR an array ref list of roles recognizable (by Moose) as roles
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR This will check the caller and see if it wants an array or a
scalar.  In array context it returns the new class name and a hash ref of the
unused hash key/value pairs.  These are presumably the arguments for the
instance.  If the requested return is a scalar it just returns the name of
the newly created class.
.RE
.ie n .SS "should_re_use_classes( $bool )"
.el .SS "should_re_use_classes( \f(CW$bool\fP )"
.IX Subsection "should_re_use_classes( $bool )"
.RS 4
This sets/changes the global variable
MooseX::ShortCut::BuildInstance::re_use_classes
.RE
.ie n .SS "set_class_immutability( $bool )"
.el .SS "set_class_immutability( \f(CW$bool\fP )"
.IX Subsection "set_class_immutability( $bool )"
.RS 4
This sets/changes the global variable
MooseX::ShortCut::BuildInstance::make_classes_immutable
.RE
.ie n .SS "set_args_cloning( $bool )"
.el .SS "set_args_cloning( \f(CW$bool\fP )"
.IX Subsection "set_args_cloning( $bool )"
.RS 4
This sets/changes the global variable
MooseX::ShortCut::BuildInstance::should_clone_args
.RE
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$MooseX::ShortCut::BuildInstance::anonymous_class_count"
.el .SS "\f(CW$MooseX::ShortCut::BuildInstance::anonymous_class_count\fP"
.IX Subsection "$MooseX::ShortCut::BuildInstance::anonymous_class_count"
This is an integer that increments and appends to the anonymous package name
for each new anonymous package (class) created.
.ie n .SS "$MooseX::ShortCut::BuildInstance::built_classes"
.el .SS "\f(CW$MooseX::ShortCut::BuildInstance::built_classes\fP"
.IX Subsection "$MooseX::ShortCut::BuildInstance::built_classes"
This is a hashref that tracks the class names ('package's) built buy this class
to manage duplicate build behaviour.
.ie n .SS "$MooseX::ShortCut::BuildInstance::re_use_classes"
.el .SS "\f(CW$MooseX::ShortCut::BuildInstance::re_use_classes\fP"
.IX Subsection "$MooseX::ShortCut::BuildInstance::re_use_classes"
This is a boolean (1|0) variable that tracks if the class should overwrite or
re-use a package name (and the defined class) from a prior 'build_class' call.
If the package name is overwritten it will cluck <https://metacpan.org/pod/Carp#SYNOPSIS>
in warning since any changes will affect active instances of prior class builds
with the same name.  If you wish to avoid changing old built behaviour at the risk
of not installing new behaviour then set this variable to true.  \fINo warning will
be provided if new requested class behaviour is discarded.\fR The class reuse behaviour
can be changed with the exported method should_re_use_classes
\&.  This does not apply to pre-loaded classes.
For pre-loaded classes this package will cluck and then overwrite every time.
.Sp
.RS 4
\&\fBDefault:\fR False = warn then overwrite
.RE
.ie n .SS "$MooseX::ShortCut::BuildInstance::make_classes_immutable"
.el .SS "\f(CW$MooseX::ShortCut::BuildInstance::make_classes_immutable\fP"
.IX Subsection "$MooseX::ShortCut::BuildInstance::make_classes_immutable"
This is a boolean (1|0) variable that manages whether a class is immutabilized at the end of
creation.  This can be changed with the exported method set_class_immutability
\&.
.Sp
.RS 4
\&\fBDefault:\fR True = always immutabilize classes after building
.RE
.ie n .SS "$MooseX::ShortCut::BuildInstance::should_clone_args"
.el .SS "\f(CW$MooseX::ShortCut::BuildInstance::should_clone_args\fP"
.IX Subsection "$MooseX::ShortCut::BuildInstance::should_clone_args"
This is a boolean (1|0) variable that manages whether a the arguments passed to
build_instance and build_class
 are cloned (using Clone )  the arguments
to both of these are processed destructivly so generally you would want them cloned
but not in every case.  If you want cloning to be managed on the script side set this
global variable to 0.  Where this is likley to be helpful is if your passed arguments
contain a deep perl data set or reference that you want shared.  In this case clone only
the bits you want cloned on the script side.
.Sp
.RS 4
\&\fBDefault:\fR True = always clone arguments
.RE
.SH "Build/Install from Source"
.IX Header "Build/Install from Source"
.RS 4
\&\fB1.\fR Download a compressed file with the code
.Sp
\&\fB2.\fR Extract the code from the compressed file.
.Sp
.RS 4
If you are using tar this should work:
.Sp
.Vb 1
\&        tar \-zxvf Spreadsheet\-XLSX\-Reader\-LibXML\-v0.xx.tar.gz
.Ve
.RE
.RE
.RS 4
.Sp
\&\fB3.\fR Change (cd) into the extracted directory
.Sp
\&\fB4.\fR Run the following
.Sp
.RS 4
(For Windows find what version of make was used to compile your perl)
.Sp
.Vb 1
\&        perl  \-V:make
.Ve
.Sp
(for Windows below substitute the correct make function (s/make/dmake/g)?)
.RE
.RE
.RS 4
.Sp
.Vb 1
\&        >perl Makefile.PL
\&
\&        >make
\&
\&        >make test
\&
\&        >make install # As sudo/root
\&
\&        >make clean
.Ve
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
MooseX\-ShortCut\-BuildInstance/issues <https://github.com/jandrew/MooseX-ShortCut-BuildInstance/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Increase test coverage
 <https://coveralls.io/github/jandrew/MooseX-ShortCut-BuildInstance?branch=master>
.Sp
\&\fB2.\fR Add an explicit 'export' setup call using Moose::Exporter as an action key in 
\&'build_class'
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.RS 4
Jed Lund
.Sp
jandrew@cpan.org
.RE
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund
.SH "Dependencies"
.IX Header "Dependencies"
.RS 4
version
.Sp
5.010 <http://perldoc.perl.org/perl5100delta.html> (for use of
defined or <http://perldoc.perl.org/perlop.html#Logical-Defined-Or> //)
.Sp
Moose
.Sp
Moose::Meta::Class
.Sp
Carp \- cluck
.Sp
Moose::Exporter
.Sp
Moose::Util \- apply_all_roles
.Sp
Moose::Exporter
.Sp
Type::Tiny \- 1.000
.Sp
Data::Dumper
.Sp
MooseX::ShortCut::BuildInstance::Types
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Moose::Meta::Class \->create
.Sp
Moose::Util \->with_traits
.Sp
MooseX::ClassCompositor
.Sp
Log::Shiras::Unhide
.Sp
.RS 4
All debug lines in this module are warn statements and are hidden behind 
\&'###InternalBuilDInstancE'.  When exposed they can be redirected to log files with 
Log::Shiras::TapWarn.
.RE
.RE
.RS 4
.RE
