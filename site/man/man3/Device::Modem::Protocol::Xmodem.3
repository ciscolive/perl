.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Device::Modem::Protocol::Xmodem 3"
.TH Device::Modem::Protocol::Xmodem 3 "2020-06-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Device::Modem::Protocol::Xmodem
.SH "Xmodem::Block"
.IX Header "Xmodem::Block"
Class that represents a single Xmodem data block.
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 11
\&        my $b = Xmodem::Block\->new( 1, \*(AqMy Data...<until\-128\-chars>...\*(Aq );
\&        if( defined $b ) {
\&                # Ok, block instanced, verify its checksum
\&                if( $b\->verify( \*(Aqchecksum\*(Aq, <my_chksum> ) ) {
\&                        ...
\&                } else {
\&                        ...
\&                }
\&        } else {
\&                # No block
\&        }
\&
\&        # Calculate checksum, crc16, 32, ...
\&        $crc16 = $b\->crc16();
\&        $crc32 = $b\->crc32();
\&        $chksm = $b\->checksum();
.Ve
.SH "Xmodem::Buffer"
.IX Header "Xmodem::Buffer"
Class that implements an Xmodem receive buffer of data blocks. Every block of data
is represented by a \f(CW\*(C`Xmodem::Block\*(C'\fR object.
.PP
Blocks can be \fBpush\fRed and \fBpop\fRped from the buffer. You can retrieve the \fBlast\fR
block, or the list of \fBblocks\fR from buffer.
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 2
\&        my $buf = Xmodem::Buffer\->new();
\&        my $b1  = Xmodem::Block\->new(1, \*(AqData...\*(Aq);
\&
\&        $buf\->push($b1);
\&
\&        my $b2  = Xmodem::Block\->new(2, \*(AqMore data...\*(Aq);
\&        $buf\->push($b2);
\&
\&        my $last_block = $buf\->last();
\&
\&        print \*(Aqnow I have \*(Aq, scalar($buf\->blocks()), \*(Aq in the buffer\*(Aq;
\&
\&        # TODO document replace() function ???
.Ve
.SH "Xmodem::Constants"
.IX Header "Xmodem::Constants"
Package that contains all useful Xmodem protocol constants used in handshaking and
data blocks encoding procedures
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 6
\&        Xmodem::Constants::soh ........... \*(Aqstart of header\*(Aq
\&        Xmodem::Constants::eot ........... \*(Aqend of trasmission\*(Aq
\&        Xmodem::Constants::ack ........... \*(Aqacknowlegded\*(Aq
\&        Xmodem::Constants::nak ........... \*(Aqnot acknowledged\*(Aq
\&        Xmodem::Constants::can ........... \*(Aqcancel\*(Aq
\&        Xmodem::Constants::C   ........... \`C\*(Aq ASCII char
\&
\&        Xmodem::Constants::XMODEM ........ basic xmodem protocol
\&        Xmodem::Constants::XMODEM_1K ..... xmodem protocol with 1k blocks
\&        Xmodem::Constants::XMODEM_CRC .... xmodem protocol with CRC checks
\&
\&        Xmodem::Constants::CHECKSUM ...... type of block checksum
\&        Xmodem::Constants::CRC16 ......... type of block crc16
\&        Xmodem::Constants::CRC32 ......... type of block crc32
.Ve
.SH "Xmodem::Receiver"
.IX Header "Xmodem::Receiver"
Control class to initiate and complete a \f(CW\*(C`X\-modem\*(C'\fR file transfer in receive mode
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 5
\&        my $recv = Xmodem::Receiver\->new(
\&                modem    => {Device::Modem object},
\&                filename => \*(Aqname of file\*(Aq,
\&                XXX protocol => \*(Aqxmodem\*(Aq | \*(Aqxmodem\-crc\*(Aq, | \*(Aqxmodem\-1k\*(Aq
\&        );
\&
\&        $recv\->run();
.Ve
.SS "Object methods"
.IX Subsection "Object methods"
.IP "\fBabort_transfer()\fR" 4
.IX Item "abort_transfer()"
Sends a \fBcancel\fR char (\f(CW\*(C`can\*(C'\fR), that signals to sender that transfer is aborted. This is
issued if we receive a bad block number, which usually means we got a bad line.
.IP "\fBmodem()\fR" 4
.IX Item "modem()"
Returns the underlying Device::Modem object.
.IP "\fBreceive_message()\fR" 4
.IX Item "receive_message()"
Retrieves message from modem and if a block is detected it breaks it into appropriate
parts.
.IP "\fBrun()\fR" 4
.IX Item "run()"
Starts a new transfer until file receive is complete. The only parameter accepted
is the (optional) local filename to be written.
.IP "\fBsend_ack()\fR" 4
.IX Item "send_ack()"
Sends an acknowledge (\f(CW\*(C`ack\*(C'\fR) char, to signal that we received and stored a correct block
Resets count of timeouts and returns the \f(CW\*(C`Xmodem::Block\*(C'\fR object of the data block
received.
.IP "\fBsend_timeout()\fR" 4
.IX Item "send_timeout()"
Sends a \fBtimeout\fR (\f(CW\*(C`nak\*(C'\fR) char, to signal that we received a bad block header (either
a bad start char or a bad block number), or a bad data checksum. Increments count
of timeouts and at ten timeouts, aborts transfer.
.SS "See also"
.IX Subsection "See also"
.IP "\- Device::Modem" 4
.IX Item "- Device::Modem"
