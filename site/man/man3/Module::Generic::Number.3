.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Module::Generic::Number 3"
.TH Module::Generic::Number 3 "2020-07-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Module::Generic::Number \- Number Manipulation Object Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    my $n = Module::Generic::Number\->new( 10 );
\&    # or
\&    my $n = Module::Generic::Number\->new( 10, 
\&    {
\&        thousand => \*(Aq,\*(Aq,
\&        decimal => \*(Aq.\*(Aq,
\&        precision => 2,
\&        # Currency symbol
\&        symbol => \*(Aq€\*(Aq,
\&        # Display currency symbol before or after the number
\&        precede => 1,
\&    });
\&    # or, to get all the defaults based on language code
\&    my $n = Module::Generic::Number\->new( 10, 
\&    {
\&        lang => \*(Aqfr_FR\*(Aq,
\&    });
\&    # this would set the decimal separator to \*(Aq,\*(Aq, the thousand separator to \*(Aq \*(Aq, and precede to 0 (false).
\&    print( "Number is: $n\en" );
\&    # prints: 10
\&
\&    $n ** 2 # 100
\&    # and all other operators work
\&
\&    my $n_neg = Module::Generic::Number\->new( \-10 );
\&    $n_neg\->abs # 10
\&    $n\->atan # 1.47112767430373
\&    $n\->atan2(2) # 1.37340076694502
\&    $n\->cbrt # 2.15443469003188
\&    $n\->cbrt\->ceil # 3
\&    $n\->clone # Cloning the number object
\&    $n\->cos # \-0.839071529076452
\&    $n\->currency # €
\&    $n\->decimal # .
\&    $n\->exp # 22026.4657948067
\&    $n\->cbrt\->floor # 2
\&    $n *= 100;
\&    $n\->format # 1,000.00
\&    $n\->format( 0 ) # 1,000
\&    $n\->format_binary # 1111101000
\&    my $n2 = $n\->clone;
\&    $n2 += 24
\&    $n2\->format_bytes # 1K
\&    $n2\->format_hex # 0x400
\&    $n2\->format_money # € 1,024.00
\&    $n2\->format_money( \*(Aq$\*(Aq ) # $1,024.00
\&    $n2\->format_negative # \-1,024.00
\&    $n2\->format_picture( \*(Aq(x)\*(Aq ) # (1,024.00)
\&    $n2\->formatter( $new_Number_Format_object );
\&    $n\->from_binary( "1111101000" ) # 1000
\&    $n\->from_hex( "0x400" ) # 1000
\&    my $n3 = $n\->clone( 3.14159265358979323846 )\->int # 3
\&    $n3\->is_even # false
\&    $n3\->is_odd # true
\&    # Uses POSIX::signbit
\&    $n3\->is_negative # 0
\&    $n3\->is_positive # 1
\&    $n\->log # 6.90775527898214
\&    $n\->log2 # 9.96578428466209
\&    $n\->log10 # 3
\&    $n\->max( 2000 ) # 2000
\&    $n\->min( 2000 ) # 1000
\&    $n\->mod( 3 ) # 1
\&    my $fmt = $n\->new_formatter({
\&        thousand => \*(Aq.\*(Aq,
\&        decimal => \*(Aq,\*(Aq,
\&        symbol => \*(Aq€\*(Aq,
\&        precision => 2,
\&        precede => 0,
\&    });
\&    my $perm = Module::Generic::Number\->new( \*(Aq0700\*(Aq );
\&    $perm\->oct # 448
\&    printf( "%o\en", 448 ) # 700
\&    $n\->clone( 2 )\->pow( 3 ) # 8
\&    # Change position of the currency sign
\&    $n\->precede( 1 ) # Set it to precede the number
\&    # Change precision
\&    $n\->precision( 0 )
\&    # Based on 1000
\&    $n\->rand # For example, returns 77.775465338589
\&    $n\->rand\->int # For example, would return a random integer 77
\&    $n\->clone( 3.14159265358979323846 )\->round( 4 ) # 3.1416
\&    $n\->sin # 0.826879540532003
\&    $n2\->sqrt # 32
\&    $n\->symbol # €
\&    $n\->tan # 1.47032415570272
\&    $n\->thousand # ,
\&    $n\->unformat( "€ 1,024.00" ) # 1024
.Ve
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\&    v0.4.0
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The purpos of this class/package is to provide a lightweight object-oriented approach to number manipulation.
.PP
This uses perl core functions and \s-1POSIX\s0 functions only. This module's methods act as a wrapper to them.
.PP
The object is overloaded, so it returns the embedded number when used as a string.
.PP
.Vb 1
\&    print( "I have $n friends\en" );
.Ve
.PP
Would produce: I have 1000 friends
.PP
Because the object is overloaded, you can use the variable with any perl operators, such as:
.PP
.Vb 4
\&    $n /= 2 # 5
\&    $n + 3 # 8
\&    $n **= 2 # $n is now 64
\&    # etc...
.Ve
.PP
Module::Generic::Number also handles infinity and numbers that are not numbers, a.k.a. \f(CW\*(C`NaN\*(C'\fR. Ot uses 2 special classes: Module::Generic::Infinity and Module::Generic::Nan
.PP
While \f(CW\*(C`NaN\*(C'\fR is very straightforward, \f(CW\*(C`Inf\*(C'\fR or \f(CW\*(C`\-Inf\*(C'\fR is a bit trickier, because although it is not a number, it is still possible to perform some operations. For example :
.PP
.Vb 2
\&    # Here the use of abs is meaningless, and just to test chaining
\&    $inf\->abs\->max(10)\->floor
.Ve
.PP
Would yield \f(CW\*(C`Inf\*(C'\fR object (Module::Generic::Infinity), but
.PP
.Vb 1
\&    $inf\->abs\->max(10)\->mod(3)
.Ve
.PP
Would yield a \f(CW\*(C`NaN\*(C'\fR object (Module::Generic::Nan) and of course
.PP
.Vb 1
\&    $inf\->abs\->min(10)
.Ve
.PP
Would yield \f(CW10\fR as a Module::Generic::Number object, so the results possibly becomes an object of a different class based on the result.
.PP
Operators also works on the infinity object:
.PP
.Vb 2
\&    my $inf = Module::Generic::Infinity\->ne( \-Inf );
\&    $inf *= \-1 # Yields a new infinity object with value Inf
.Ve
.PP
Those are just basic arithmetics wrapped in object to enable object oriented interface and chaining. It does not do anything special and rely on perl and \s-1POSIX\s0 for computation, depending on the function.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Provided with a number, some optional parameters and this returns a new object.
.PP
Possible optional parameters are:
.IP "\fIdecimal\fR" 4
.IX Item "decimal"
Specifies the decimal separator. This can also be changed or retrieved with the method \*(L"decimal\*(R"
.IP "\fIgrouping\fR" 4
.IX Item "grouping"
The sizes of the groups of digits, except for currency values. unpack( \*(L"C*\*(R", \f(CW$grouping\fR ) will give the number in question. This is typically 3.
.IP "\fIlang\fR" 4
.IX Item "lang"
If provided with a language tag as specified in rfc5646 <https://tools.ietf.org/html/rfc5646>, and this will the number format properties based on the locale dictionary. It uses \*(L"setlocale\*(R" in \s-1POSIX\s0 to achieve that, but without disturbing your own locale settings.
.Sp
WIth the number format properties retrieved, it will populate the other parameters here, if not provided already. For example :
.Sp
.Vb 2
\&    my $n = Module::Generic::Number\->new( 1000, { lang => \*(Aqfr_FR\*(Aq });
\&    $n\->format # 1.000,00 €
.Ve
.Sp
Would set the thousand separator to \f(CW\*(C`.\*(C'\fR, the decimal separator to \f(CW\*(C`,\*(C'\fR, the currency symbol to \f(CW\*(C`€\*(C'\fR and precede to false.
.Sp
.Vb 4
\&    my $n = Module::Generic::Number\->new( 1000, {
\&        lang => \*(Aqfr_FR\*(Aq,
\&        precede => 1,
\&    });
.Ve
.Sp
Uses the standard default format properties, except for precede which we set to true
.Sp
.Vb 1
\&    $n\->format # € 1.000,00
.Ve
.Sp
When no \fIlang\fR is provided, it uses the default language set in the system to retrieve the number formatting properties.
.Sp
Any of those properties can be overriden by specifying its value when creating an object.
.IP "\fIposition_neg\fR" 4
.IX Item "position_neg"
Boolea value to define whether the negative sign (typically \*(L"\-\*(R") should be positioned at the begining (true) or at the end (false) of the negative numbers.
.IP "\fIposition_pos\fR" 4
.IX Item "position_pos"
Boolea value to define whether the positive sign (typically and empty string) should be positioned at the begining (true) or at the end (false) of the positive numbers.
.IP "\fIprecede\fR" 4
.IX Item "precede"
If set to true, this will set the currency symbol before the number and when set to false, it will set it after the number
.Sp
This can also be changed or retrieved with the method \*(L"precede\*(R"
.IP "\fIprecede_neg\fR" 4
.IX Item "precede_neg"
If set to true, this will set the currency symbol before the negative number and when set to false, it will set it after the negative number
.Sp
This can also be changed or retrieved with the method \*(L"precede_neg\*(R"
.IP "\fIprecision\fR" 4
.IX Item "precision"
Sets the decimal precision of the number.  This can also be changed or retrieved with the method \*(L"precision\*(R"
.IP "\fIsign_neg\fR" 4
.IX Item "sign_neg"
The character used to denote negative currency values, usually a minus sign.
.IP "\fIsign_pos\fR" 4
.IX Item "sign_pos"
The separator between groups of digits before the decimal point, except for currency values.
.IP "\fIspace\fR" 4
.IX Item "space"
Boolean value to define whether there should be a space between the currency sign and the number value.
.IP "\fIspace_neg\fR" 4
.IX Item "space_neg"
Boolean value to define whether there should be a space between the currency sign and the number value for negative numbers.
.IP "\fIsymbol\fR" 4
.IX Item "symbol"
Sets the currency symbol to be used upon formatting of the number as money with the method \*(L"format_money\*(R"
.Sp
.Vb 1
\& This can also be changed or retrieved with the method L</"symbol">
.Ve
.IP "\fIthousand\fR" 4
.IX Item "thousand"
Sets the thousand separator to be used uppon formatting.
.Sp
.Vb 1
\& This can also be changed or retrieved with the method L</"thousand">
.Ve
.SS "abs"
.IX Subsection "abs"
Return the absolute value of the number object. Same as \*(L"abs\*(R" in perlfunc
.SS "atan"
.IX Subsection "atan"
Returns the arcus tangent for the number object. See \*(L"atan\*(R" in \s-1POSIX\s0
.PP
.Vb 3
\&    # Assuming $n is an object for 1000
\&    # atan2( Y, X ). Y = 1000 here
\&    $n\->atan2( 20 ) # produces 1.55079899282175
.Ve
.SS "atan2"
.IX Subsection "atan2"
Returns the arctangent of Y/X in the range \-PI to \s-1PI.\s0 See \*(L"atan2\*(R" in perlfunc
.SS "as_string"
.IX Subsection "as_string"
Returns the object string as a string.
.PP
.Vb 6
\&    my $n = Module::Generic::Number\->new( 1000 );
\&    print( "I have $n books\en" );
\&    # I have 1000 books
\&    # But better like ths:
\&    printf( "I have %s bools\en", $n\->format( 0 ) );
\&    # I have 1,000 books
.Ve
.SS "cbrt"
.IX Subsection "cbrt"
Returns the cube root. See \*(L"cbrt\*(R" in \s-1POSIX\s0
.SS "ceil"
.IX Subsection "ceil"
Returns the smallest integer value greater than or equal to the number object. See \*(L"ceil\*(R" in \s-1POSIX\s0
.PP
.Vb 2
\&    # Assuming $n is an object for 3.14159265358979323846
\&    $n\->ceil # 4
.Ve
.SS "chr"
.IX Subsection "chr"
Returns the character matching our number object. See \*(L"chr\*(R" in perlfunc
.PP
.Vb 2
\&    # Assuming $n is 74
\&    $n\->chr # J
.Ve
.SS "clone"
.IX Subsection "clone"
Returns a clone of the current object, keeping its original formatting properties
.PP
It can take an optional number that will be used
.PP
.Vb 4
\&    my $n = Moduke::Generic::Number\->new( 1000 );
\&    # $n is no 1000 with thousand separator set to "","", etc
\&    my $n2 = $n\->clone( 2020 );
\&    # Same properties as $n, but now the number is 2020 instead of 1000 and this is a new object
.Ve
.SS "cos"
.IX Subsection "cos"
Returns the cosine of the number object. See \*(L"cos\*(R" in perlfunc
.SS "currency"
.IX Subsection "currency"
Sets or gets the currency symbol to be used for formatting the number object with \*(L"format_money\*(R"
.SS "decimal"
.IX Subsection "decimal"
Sets or gets the decimal separator to be used for formatting the number object
.SS "exp"
.IX Subsection "exp"
Returns the natural logarithm base to the power of the number object. See \*(L"exp\*(R" in perlfunc
.PP
.Vb 2
\&    # Assuming the number object is 2
\&    $n\->exp # 7.38905609893065
.Ve
.SS "floor"
.IX Subsection "floor"
Returns the largest integer value less than or equal to the number object. See \*(L"floor\*(R" in \s-1POSIX\s0
.PP
.Vb 2
\&    # Assuming $n is an object for 3.14159265358979323846
\&    $n\->ceil # 3
.Ve
.SS "format"
.IX Subsection "format"
Provided with an optional precision and this format the number in a human readable way using thousand and decimal separators and floating number precision
.PP
.Vb 1
\&    $n\->format # 1,000.00
.Ve
.SS "format_binary"
.IX Subsection "format_binary"
.Vb 2
\&    # Assuming the number object is 1000
\&    $n\->format_binary # 1111101000
.Ve
.SS "format_bytes"
.IX Subsection "format_bytes"
.Vb 2
\&    # Assuming the number object is 1,234,567
\&    $n\->format_bytes # 1.18M
.Ve
.SS "format_hex"
.IX Subsection "format_hex"
.Vb 2
\&    # Assuming the number object is 1000
\&    $n\->format_hex # 0x3E8
.Ve
.SS "format_money"
.IX Subsection "format_money"
Provided with an optional precision, this format the number object, using the inital format parameters specified during object instantiation.
.PP
.Vb 2
\&    # Assuming the number object is 1000
\&    $n\->format_money # € 1,000.00
.Ve
.SS "format_negative"
.IX Subsection "format_negative"
Provided with a format which must includes the character \f(CW\*(C`x\*(C'\fR and this format the number object, assuming it is negative.
.PP
For example, suitable for accounting:
.PP
.Vb 1
\&    $n\->format_negative( \*(Aq(x)\*(Aq ); # (1,000)
.Ve
.SS "format_picture"
.IX Subsection "format_picture"
Format the string based on the patter provided
.PP
.Vb 1
\&    $n\->format_picture( \*(Aq##,###.##\*(Aq ); # 1,000.00
.Ve
.SS "formatter"
.IX Subsection "formatter"
Sets or gets the Number::Format object used for formatting.
.SS "from_binary"
.IX Subsection "from_binary"
Returns a number object based on a binary number.
.PP
.Vb 1
\&    my $n2 = $n\->from_binary( "1111101000" ); # 1000
.Ve
.SS "from_hex"
.IX Subsection "from_hex"
Returns a number object based on an hex number.
.PP
.Vb 1
\&    my $n2 = $n\->from_hex( "0x400" ); # 1024
.Ve
.SS "grouping"
.IX Subsection "grouping"
The sizes of the groups of digits, except for currency values. unpack( \*(L"C*\*(R", \f(CW$grouping\fR ) will reveal the number in question.
.SS "int"
.IX Subsection "int"
Returns the integer portion of the number object. See \*(L"int\*(R" in perlfunc for more details.
.PP
.Vb 2
\&    # Assuming $n is an object for 3.14159265358979323846
\&    $n\->int # 3
.Ve
.SS "is_even"
.IX Subsection "is_even"
Returns true if the number is even, i.e. if the modulus of the number divided by 2 is 0.
.PP
See \*(L"is_odd\*(R"
.SS "is_finite"
.IX Subsection "is_finite"
Rturns true if the number is finite, i.e. not infinity. See \*(L"isfinite\*(R" in \s-1POSIX\s0
.SS "is_float"
.IX Subsection "is_float"
Returns true if the number is a floating decimal number. It uses \*(L"modf\*(R" in \s-1POSIX\s0 to find out.
.SS "is_infinite"
.IX Subsection "is_infinite"
Rturns true if the number is infinite. See \*(L"isinf\*(R" in \s-1POSIX\s0
.SS "is_int"
.IX Subsection "is_int"
Returns true if the number is an integer. It uses \*(L"modf\*(R" in \s-1POSIX\s0 to find out.
.SS "is_nan"
.IX Subsection "is_nan"
Returns true if the number is not a number, i.e. NaN. See \*(L"isnan\*(R" in \s-1POSIX\s0
.SS "is_negative"
.IX Subsection "is_negative"
Returns true if the number object is negative, false otherwise. See \*(L"signbit\*(R" in \s-1POSIX\s0
.SS "is_normal"
.IX Subsection "is_normal"
Returns true if the argument is normal (that is, not a subnormal/denormal, and not an infinity, or a not-a-number). See \*(L"isnormal\*(R" in \s-1POSIX\s0
.SS "is_odd"
.IX Subsection "is_odd"
Returns true if the number is odd, i.e. if the modulus of the number divided by 2 is 1.
.PP
See \*(L"is_even\*(R"
.SS "is_positive"
.IX Subsection "is_positive"
Returns true if the number object is positive, false otherwise. See \*(L"signbit\*(R" in \s-1POSIX\s0
.SS "lang"
.IX Subsection "lang"
Returns the current language used for the number formatting properties.
.SS "length"
.IX Subsection "length"
Returns the number of digits this number object contains. The value returned is a Module::Generic::Number object
.SS "locale"
.IX Subsection "locale"
Same as \*(L"lang\*(R"
.SS "log"
.IX Subsection "log"
Returns the natural logarithm of the number object. See \*(L"log\*(R" in perlfunc for more details.
.PP
.Vb 1
\&    $n\->log # 6.90775527898214
.Ve
.SS "log2"
.IX Subsection "log2"
Logarithm base two of the number object. See \*(L"log2\*(R" in \s-1POSIX\s0 for more details.
.PP
.Vb 1
\&    $n\->log2 # 9.96578428466209
.Ve
.SS "log10"
.IX Subsection "log10"
Returns the 10\-base logarithm of the number object. See \*(L"log10\*(R" in \s-1POSIX\s0 for more details.
.PP
.Vb 1
\&    $n\->log10 # 3
.Ve
.SS "max"
.IX Subsection "max"
Returns the highest number of either the number object, or the additional number provided as arguement. If the latter is undef, the number object is returned. See \*(L"fmax\*(R" in \s-1POSIX\s0
.PP
.Vb 1
\&    $n\->max( 2000 ) # 2000
.Ve
.PP
Returns the lowest number of either the number object, or the additional number provided as arguement. If the latter is undef, the number object is returned. See \*(L"fmin\*(R" in \s-1POSIX\s0
.PP
.Vb 1
\&    $n\->min( 2000 ) # 2000
.Ve
.SS "mod"
.IX Subsection "mod"
Returns the remainder for the number bject divided by another number provided as additional argument. See \*(L"fmod\*(R" in \s-1POSIX\s0 for more details.
.PP
.Vb 2
\&    # Assuming 1000
\&    $n\->mod(3) # 1
.Ve
.SS "new_formatter"
.IX Subsection "new_formatter"
Given an optional hash of parameters similar to the oens provided to \*(L"new\*(R" and this return a new Number::Format object or undef with an \*(L"error\*(R" in Module::Generic set upon error
.SS "oct"
.IX Subsection "oct"
Provided an octal value, this returns the corresponding number as an object. See \*(L"oct\*(R" in perlfunc for more details.
.SS "position_neg"
.IX Subsection "position_neg"
Set to true or false if the negative sign (typically \*(L"\-\*(R") should be positioned at the begining (true) or at the end (false) of the number.
.SS "position_pos"
.IX Subsection "position_pos"
Set to true or false if the positive sign (typically "\*(L", i.e. empty, but could be set to \*(R"+") should be positioned at the begining (true) or at the end (false) of the number.
.SS "pow"
.IX Subsection "pow"
Returns the number object to the power of the number provided as arguments. See \*(L"pow\*(R" in \s-1POSIX\s0 for more details.
.PP
.Vb 2
\&    # Assuming $n is an object representing 2
\&    $n\->pow( 3 ) # 8
.Ve
.SS "precede"
.IX Subsection "precede"
Sets or gets the \fIprecede\fR property of this object. This is used by Number::Format to determine if the currency symbol should be set before or after the number
.SS "precede_neg"
.IX Subsection "precede_neg"
Sets or gets the \fIprecede_neg\fR property of this object. This is used by Number::Format to determine if the currency symbol should be set before or after the number when it is a negative number.
.SS "precision"
.IX Subsection "precision"
Sets or gets the floating precision of the number.
.PP
.Vb 3
\&    # Assuming $n is an object for 3.14159265358979323846
\&    $n\->precision( 4 );
\&    $n\->format # 3.1416
.Ve
.SS "rand"
.IX Subsection "rand"
Returns a random fractional number greater than or equal to 0 and less than the value of the number object.
See \*(L"rand\*(R" in perlfunc for more information.
.SS "round"
.IX Subsection "round"
Provided with an optional precision, this will round the number object. Internally it uses \*(L"sprintf\*(R" in perldoc to achieve that.
.SS "sign_neg"
.IX Subsection "sign_neg"
Sets or gets the \fIsign_neg\fR property of this object. The character used to denote negative currency values, usually a minus sign.
.SS "sign_pos"
.IX Subsection "sign_pos"
Sets or gets the \fIsign_pos\fR property of this object. The character used to denote nonnegative currency values, usually the empty string.
.SS "sin"
.IX Subsection "sin"
Returns the sine of the number object. See \*(L"sine\*(R" in perlfunc for more details.
.SS "space"
.IX Subsection "space"
Sets or gets the \fIspace\fR property of this object. 1 if a space is inserted between the currency symbol and the currency value for non-negative values, 0 otherwise.
.SS "space_neg"
.IX Subsection "space_neg"
Sets or gets the \fIspace_neg\fR property of this object. 1 if a space is inserted between the currency symbol and the currency value for negative values, 0 otherwise.
.SS "sqrt"
.IX Subsection "sqrt"
Return the positive square root of the number object. See \*(L"sqrt\*(R" in perlfunc for more details.
.SS "symbol"
.IX Subsection "symbol"
Set or gets the currency symbol to be used in \*(L"format_money\*(R"
.SS "tan"
.IX Subsection "tan"
Returns the tangent of the number object. See \*(L"tan\*(R" in \s-1POSIX\s0 for more details.
.SS "thousand"
.IX Subsection "thousand"
Set or gets the thousand separator used in formatting the number.
.SS "unformat"
.IX Subsection "unformat"
Provided with a string containing a number, and this returns a number as a Module::Generic::Number object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Module::Generic::Scalar, Module::Generic::Array, Module::Generic::Boolean, Module::Generic::Hash, Module::Generic::Dynamic
.PP
Math::BigInt
.SH "AUTHOR"
.IX Header "AUTHOR"
Jacques Deguest <\fIjack@deguest.jp\fR>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2000\-2020 \s-1DEGUEST\s0 Pte. Ltd.
.PP
You can use, copy, modify and redistribute this package and associated
files under the same terms as Perl itself.
