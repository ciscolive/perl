.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::ExcelXML 3"
.TH Spreadsheet::Reader::ExcelXML 3 "2017-04-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::ExcelXML \- Read xlsx/xlsm/xml extention Excel files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following uses the 'TestBook.xlsx' file found in the t/test_files/ folder of the package
.PP
.Vb 4
\&        #!/usr/bin/env perl
\&        use strict;
\&        use warnings;
\&        use Spreadsheet::Reader::ExcelXML;
\&
\&        my $parser   = Spreadsheet::Reader::ExcelXML\->new();
\&        my $workbook = $parser\->parse( \*(AqTestBook.xlsx\*(Aq );
\&
\&        if ( !defined $workbook ) {
\&                die $parser\->error(), "\en";
\&        }
\&
\&        for my $worksheet ( $workbook\->worksheets() ) {
\&
\&                my ( $row_min, $row_max ) = $worksheet\->row_range();
\&                my ( $col_min, $col_max ) = $worksheet\->col_range();
\&
\&                for my $row ( $row_min .. $row_max ) {
\&                        for my $col ( $col_min .. $col_max ) {
\&
\&                                my $cell = $worksheet\->get_cell( $row, $col );
\&                                next unless $cell;
\&
\&                                print "Row, Col    = ($row, $col)\en";
\&                                print "Value       = ", $cell\->value(),       "\en";
\&                                print "Unformatted = ", $cell\->unformatted(), "\en";
\&                                print "\en";
\&                        }
\&                }
\&                last;# In order not to read all sheets
\&        }
\&
\&        ###########################
\&        # SYNOPSIS Screen Output
\&        # 01: Row, Col    = (0, 0)
\&        # 02: Value       = Category
\&        # 03: Unformatted = Category
\&        # 04:
\&        # 05: Row, Col    = (0, 1)
\&        # 06: Value       = Total
\&        # 07: Unformatted = Total
\&        # 08:
\&        # 09: Row, Col    = (0, 2)
\&        # 10: Value       = Date
\&        # 11: Unformatted = Date
\&        # 12:
\&        # 13: Row, Col    = (1, 0)
\&        # 14: Value       = Red
\&        # 16: Unformatted = Red
\&        # 17:
\&        # 18: Row, Col    = (1, 1)
\&        # 19: Value       = 5
\&        # 20: Unformatted = 5
\&        # 21:
\&        # 22: Row, Col    = (1, 2)
\&        # 23: Value       = 2017\-2\-14 #(shows as 2/14/2017 in the sheet)
\&        # 24: Unformatted = 41318
\&        # 25:
\&        # More intermediate rows ...
\&        # 82:
\&        # 83: Row, Col    = (6, 2)
\&        # 84: Value       = 2016\-2\-6 #(shows as 2/6/2016 in the sheet)
\&        # 85: Unformatted = 40944
\&        ###########################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an Excel spreadsheet reading package that should parse all excel files with the
extentions .xlsx, .xlsm, .xml \fIExcel 2003 xml
 <https://en.wikipedia.org/wiki/Microsoft_Office_XML_formats> (SpreadsheetML
 <https://en.wikipedia.org/wiki/SpreadsheetML>)\fR that can be opened in the Excel 2007+
applications.  The quick-start example provided in the \s-1SYNOPSIS\s0 attempts to follow the
example from Spreadsheet::ParseExcel (.xls binary file reader) as close as possible.
There are additional methods and other approaches that can be used by this package for
spreadsheet reading but the basic access to data from newer xml based Excel files can be
as simple as above.
.PP
This is not the only perl package able to parse .xlsx files on \s-1METACPAN.\s0  For
now it does appear to be the only package that will parse .xlsm and Excel 2003 .xml
workbooks.
.PP
There is some documentation throughout this package for users who intend to extend the
package but the primary documentation is intended for the person who uses the package as
is.  Parsing through an Excel workbook is done with three levels of classes;
.SS "Workbook level (This doc)"
.IX Subsection "Workbook level (This doc)"
.IP "\(bu" 4
General attribute settings that affect parsing of the file in general
.IP "\(bu" 4
The place to set workbook level output formatting
.IP "\(bu" 4
Object methods to retreive document level metadata and worksheets
.SS "Worksheet level"
.IX Subsection "Worksheet level"
.IP "\(bu" 4
Object methods to return specific cell instances/data
.IP "\(bu" 4
Access to some worksheet level format information (more access pending)
.IP "\(bu" 4
The place to customize
data output formats targeting specific cell ranges
.SS "Cell level"
.IX Subsection "Cell level"
.IP "\(bu" 4
Access to the cell contents
.IP "\(bu" 4
Access to the cell formats (more access pending)
.PP
There are some differences from the Spreadsheet::ParseExcel package.  For instance
in the \s-1SYNOPSIS\s0 the '$parser' and the '$workbook' are actually the same
class for this package.  You could therefore combine both steps by calling \->new with
the 'file' attribute called out.  The test for load success would then rely on the
method file_opened.   Afterward it is still possible to call \->error
on the instance.  Another difference is the data formatter and specifically date
handling.  This package leverages Spreadsheet::Reader::Format to allows for a
simple pluggable custom output format that is very flexible as well as handling dates
in the Excel file older than 1\-January\-1900.  I leveraged coercions from Type::Tiny
 to do this but anything that follows that general format will work
here.
.PP
The why and nitty gritty of design choices I made are in the Architecture Choices
 section.  Some pitfalls are outlined in the Warnings
section.  Read the full documentation for all opportunities!
.SS "Primary Methods"
.IX Subsection "Primary Methods"
These are the primary ways to use this class.  They can be used to open a workbook,
investigate information at the workbook level, and provide ways to access sheets in
the workbook.
.PP
All methods are object methods and should be implemented on the object instance.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        my @worksheet_array = $workbook_instance\->worksheets;
.Ve
.PP
\fIparse( \f(CI$file_name\fI|$file_handle, \f(CI$formatter\fI )\fR
.IX Subsection "parse( $file_name|$file_handle, $formatter )"
.Sp
.RS 4
\&\fBDefinition:\fR This is a convenience method to match \*(L"parse($filename, \f(CW$formatter\fR)\*(R" in Spreadsheet::ParseExcel.
It is one way to set the file attribute [and the formatter_inst attribute].
.Sp
\&\fBAccepts:\fR
.Sp
.Vb 2
\&        $file = see the L<file|/file> attribute for valid options (required) (required)
\&        [$formatter] = see the L<formatter_inst|/formatter_inst> attribute for valid options (optional)
.Ve
.Sp
\&\fBReturns:\fR an instance of the package (not cloned) when passing with the xlsx file successfully
opened or undef for failure.
.RE
.PP
\fIworksheets\fR
.IX Subsection "worksheets"
.Sp
.RS 4
\&\fBDefinition:\fR This method will return an array (\fInot an array reference\fR) containing a list of references
to all worksheets in the workbook as objects.  This is not a reccomended method because it builds all
worksheet instance and returns an array of objects.  It is provided for compatibility to
Spreadsheet::ParseExcel.  For alternatives see the get_worksheet_names method and
the worksheet methods.  \fBIt also only returns the tabular worksheets in the
workbook.  All chart sheets are ignored!\fR
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an array ref of  Worksheet
objects for all worksheets in the workbook.
.RE
.PP
\fIworksheet( \f(CI$name\fI )\fR
.IX Subsection "worksheet( $name )"
.Sp
.RS 4
\&\fBDefinition:\fR This method will return an  object to read values in the identified
worksheet.  If no value is passed to \f(CW$name\fR then the 'next' worksheet in physical order
is returned. \fI'next' will \s-1NOT\s0 wrap\fR  It also only iterates through the 'worksheets'
in the workbook (not the 'chartsheets').
.Sp
\&\fBAccepts:\fR the \f(CW$name\fR string representing the name of the worksheet object you
want to open.  This name is the word visible on the tab when opening the spreadsheet
in Excel. (not the underlying zip member file name \- which can be different.  It will
not accept chart tab names.)
.Sp
\&\fBReturns:\fR a Worksheet object with the
ability to read the worksheet of that name.  It returns undef and sets the error attribute
if a 'chartsheet' is requested.  Or in 'next' mode it returns undef if past the last sheet.
.Sp
\&\fBExample:\fR using the implied 'next' worksheet;
.Sp
.Vb 4
\&        while( my $worksheet = $workbook\->worksheet ){
\&                print "Reading: " . $worksheet\->name . "\en";
\&                # get the data needed from this worksheet
\&        }
.Ve
.RE
.PP
\fIfile_name\fR
.IX Subsection "file_name"
.Sp
.RS 4
\&\fBDefinition:\fR If you pass a file \f(CW$location\fR/$name string to the attribute file then before
the package converts it to a file handle it will store the string.  You can retreive that string
with this method.  This is true if you pass a string to the parse
 method as well.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR the \f(CW$location\fR/$name file string if available.
.RE
.PP
\fIfile_opened\fR
.IX Subsection "file_opened"
.Sp
.RS 4
\&\fBDefinition:\fR This method is the test for success that should be used when opening a workbook
using the \->new method.  This allows for the object to store the error without dying
entirely.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 if the workbook file was successfully opened
.Sp
\&\fBExample:\fR
.Sp
.Vb 1
\&        use Spreadsheet::Reader::ExcelXML qw( :just_the_data );
\&
\&        my $workbook  = Spreadsheet::Reader::ExcelXML\->new( file => \*(AqTestBook.xlsx\*(Aq );
\&
\&        if ( !$workbook\->file_opened ) {
\&                die $workbook\->error(), "\en";
\&        }
\&
\&        for my $worksheet ( $workbook\->worksheets ) {
\&
\&                print "Reading worksheet named: " . $worksheet\->get_name . "\en";
\&
\&                while( 1 ){
\&                        my $cell = $worksheet\->get_next_value;
\&                        print "Cell is: $cell\en";
\&                        last if $cell eq \*(AqEOF\*(Aq;
\&                }
\&        }
.Ve
.RE
.PP
\fIget_sheet_names\fR
.IX Subsection "get_sheet_names"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns an array ref of all the sheet names (tabs) in the
workbook in order.  (It includes chartsheets.)
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an array ref of strings
.RE
.PP
\fIworksheet_name( \f(CI$position\fI )\fR
.IX Subsection "worksheet_name( $position )"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the name of the worksheet in that \f(CW$position\fR. (counting from zero)
interspersed chartsheets in the file are not considered to hold a position by this accounting.
.Sp
\&\fBAccepts:\fR \f(CW$position\fR (an integer)
.Sp
\&\fBReturns:\fR the worksheet name
.Sp
\&\fBExample:\fR To return only worksheet positions 2 through 4 without building them all at once
.Sp
.Vb 4
\&        for $x (2..4){
\&                my $worksheet = $workbook\->worksheet( $workbook\->worksheet_name( $x ) );
\&                # Read the worksheet here
\&        }
.Ve
.RE
.PP
\fIget_worksheet_names\fR
.IX Subsection "get_worksheet_names"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns an array ref of all the worksheet names (tabs) in the
workbook in order.  (No chartsheets.)
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an array ref of strings
.Sp
\&\fBExample:\fR Another way to parse a workbook without building all the sheets at
once is;
.Sp
.Vb 4
\&        for $sheet_name ( @{$workbook\->worksheet_names} ){
\&                my $worksheet = $workbook\->worksheet( $sheet_name );
\&                # Read the worksheet here
\&        }
.Ve
.RE
.PP
\fIworksheet_count\fR
.IX Subsection "worksheet_count"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the total number of recorded worksheets
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$total\fR \- a count of all worksheets (only)
.RE
.SS "Attributes"
.IX Subsection "Attributes"
Data passed to new when creating an instance.  For modification of these attributes
see the listed 'attribute methods'. For general information on attributes see
Moose::Manual::Attributes.  For additional lesser used workbook options see
Secondary Methods.  There are several grouped default values
for these attributes documented in the Flags section.
.PP
\&\fBExample\fR
.PP
.Vb 1
\&        $workbook_instance = Spreadsheet::Reader::ExcelXML\->new( %attributes )
.Ve
.PP
\&\fInote: if the file information is not included in the initial \f(CI%attributes\fI then it must be
set by one of the attribute setter methods below or the parse
 method before the rest of the package
can be used.\fR
.PP
\fIfile\fR
.IX Subsection "file"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds the file handle for the top level workbook.  If a
file name is passed it is coerced into an IO::File handle and stored that way.  The
originaly file name can be retrieved with the method file_name.
.Sp
\&\fBDefault\fR no default
.Sp
\&\fBRequired:\fR yes
.Sp
\&\fBRange\fR any unencrypted xlsx|xlsm|xml file that can be opened in Microsoft Excel 2007+.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_file( \f(CB$file\fB|$file_handle )\fR
.Sp
.RS 4
\&\fBDefinition:\fR change the file value in the attribute (this will reboot the workbook instance)
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIerror_inst\fR
.IX Subsection "error_inst"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds an 'error' object instance.  It should have several
methods for managing errors.  Currently no error codes or error language translation
options are available but this should make implementation of that easier.
.Sp
\&\fBDefault:\fR a Spreadsheet::Reader::ExcelXML::Error instance with the attributes set
as;
.Sp
.Vb 1
\&        ( should_warn => 0 )
.Ve
.Sp
\&\fBRange:\fR See the 'Exported methods' section below for methods required by the workbook.
The error instance must also be able to extract the error string from a passed error
object as well.  For now the current implementation will attempt \->as_string first
and then \->message if an object is passed.
.Sp
\&\fBattribute methods\fR Methods provided to manage this attribute
.Sp
.RS 4
\&\fBget_error_inst\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns this instance
.RE
.RE
.RS 4
.Sp
\&\fBhas_error_inst\fR
.Sp
.RS 4
\&\fBDefinition:\fR indicates in the error instance has been set
.RE
.RE
.RS 4
.Sp
\&\fBExported methods:\fR
.Sp
The following methods are exported (delegated) to the workbook level
from the stored instance of this class.  Links are provided to the default implemenation;
.Sp
.RS 4
\&\*(L"error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"set_error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"clear_error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"set_warnings\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"if_warn\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"should_spew_longmess\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"spewing_longmess\*(R" in Spreadsheet::Reader::ExcelXML::Error
.Sp
\&\*(L"has_error\*(R" in Spreadsheet::Reader::ExcelXML::Error
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIformatter_inst\fR
.IX Subsection "formatter_inst"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds a 'formatter' object instance.  This instance does all
the heavy lifting to transform raw text into desired output.  It does include
a role that interprets the excel format string
 <https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-2d450d95-2630-43b8-bf06-ccee7cbe6864?ui=en-US&rs=en-US&ad=US>
into a Type::Tiny coercion.  The default case is actually built from a number of
different elements using MooseX::ShortCut::BuildInstance on the fly so you can
just call out the replacement base class or role rather than fully building
the formatter prior to calling new on the workbook.  However the naming of the interface
|http://www.cs.utah.edu/~germain/PPS/Topics/interfaces.html> is locked and should not be
tampered with since it manages the methods to be imported into the workbook;
.Sp
\&\fBDefault\fR An instance built with MooseX::ShortCut::BuildInstance from the following
arguments (note the instance itself is not built here)
	{
		superclasses => ['Spreadsheet::Reader::ExcelXML::FmtDefault'], # base class
		add_roles_in_sequence =>[qw(
			Spreadsheet::Reader::ExcelXML::ParseExcelFormatStrings # role containing the heavy lifting methods
			Spreadsheet::Reader::ExcelXML::FormatInterface # the interface
		)],
		package => 'FormatInstance', # a formality more than anything
	}
.Sp
\&\fBRange:\fR A replacement formatter instance or a set of arguments that will lead to building an acceptable
formatter instance.  See the 'Exported methods'section below for all methods required methods for the
workbook.  The FormatInterface is required by name so a replacement of that role requires the same name.
.Sp
\&\fBattribute methods\fR Methods provided to manage this attribute
.Sp
.RS 4
\&\fBget_formatter_inst\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the stored formatter instance
.RE
.RE
.RS 4
.Sp
\&\fBset_formatter_inst\fR
.Sp
.RS 4
\&\fBDefinition:\fR sets the formatter instance
.RE
.RE
.RS 4
.Sp
\&\fBExported methods:\fR
.Sp
Additionally the following methods are exported (delegated) to the workbook level
from the stored instance of this class.  Links are provided to the default implemenation;
.Sp
.RS 4
\&\fBExample:\fR name_the_workbook_uses_to_access_the_method => \fBLink to the default source of the method\fR
.Sp
get_formatter_region => \*(L"get_excel_region\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
has_target_encoding => \*(L"has_target_encoding\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
get_target_encoding => \*(L"get_target_encoding\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
set_target_encoding => \*(L"set_target_encoding( \f(CW$encoding\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
change_output_encoding => \*(L"change_output_encoding( \f(CW$string\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
set_defined_excel_formats => \*(L"set_defined_excel_formats( \f(CW%args\fR )\*(R" in Spreadsheet::Reader::Format::FmtDefault
.Sp
get_defined_conversion => \*(L"get_defined_conversion( \f(CW$position\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.Sp
parse_excel_format_string => \*(L"parse_excel_format_string( \f(CW$string\fR, \f(CW$name\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.Sp
set_date_behavior => \*(L"set_date_behavior( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.Sp
set_european_first => \*(L"set_european_first( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.Sp
set_formatter_cache_behavior => \*(L"set_cache_behavior( \f(CW$bool\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.Sp
set_workbook_for_formatter => \*(L"set_workbook_inst( \f(CW$instance\fR )\*(R" in Spreadsheet::Reader::Format::ParseExcelFormatStrings
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcount_from_zero\fR
.IX Subsection "count_from_zero"
.Sp
.RS 4
\&\fBDefinition:\fR Excel spreadsheets count from 1.  Spreadsheet::ParseExcel
counts from zero.  This allows you to choose either way.
.Sp
\&\fBDefault\fR 1
.Sp
\&\fBRange\fR 1 = counting from zero like Spreadsheet::ParseExcel,
0 = Counting from 1 like Excel
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBcounting_from_zero\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIfile_boundary_flags\fR
.IX Subsection "file_boundary_flags"
.Sp
.RS 4
\&\fBDefinition:\fR When you request data to the right of the last column or below
the last row of the data this package can return '\s-1EOR\s0' or '\s-1EOF\s0' to indicate that
state.  This is especially helpful in 'while' loops.  The other option is to
return 'undef'.  This is problematic if some cells in your table are empty which
also returns undef.   The determination for what constitues the last column and
row is selected with the attributes empty_is_end, values_only
, and spaces_are_empty.
.Sp
\&\fBDefault\fR 1
.Sp
\&\fBRange\fR 1 = return '\s-1EOR\s0' or '\s-1EOF\s0' flags as appropriate, 0 = return undef when
requesting a position that is out of bounds
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBboundary_flag_setting\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIempty_is_end\fR
.IX Subsection "empty_is_end"
.Sp
.RS 4
\&\fBDefinition:\fR The excel convention is to read the table left to right and top
to bottom.  Some tables have an uneven number of columns with real data from row
to row.  This allows the several methods that excersize a 'next' function to wrap
after the last element with data rather than going to the max column.  This also
can combine with the attribute file_boundary_flags to
trigger '\s-1EOR\s0' flags after the last data element and before the sheet max column
when not implementing 'next' functionality.  It will also return '\s-1EOF\s0' if the
remaining rows are empty even if the max row is farther on.
.Sp
\&\fBDefault\fR 0
.Sp
\&\fBRange\fR 0 = treat all columns short of the max column for the sheet as being in
the table, 1 = treat all cells after the last cell with data as past the end of
the row.  This will be most visible when
boundary flags are turned on or next functionality is
used in the context of the attribute values_only.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBis_empty_the_end\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIvalues_only\fR
.IX Subsection "values_only"
.Sp
.RS 4
\&\fBDefinition:\fR Excel will store information about a cell even if it only contains
formatting data.  In many cases you only want to see cells that actually have
values.  This attribute will change the package behaviour regarding cells that have
formatting stored against that cell but no actual value.  If values in the cells
exist as zero length strings or spaces only you can also set those to empty with
the attribute spaces_are_empty.
.Sp
\&\fBDefault\fR 0
.Sp
\&\fBRange\fR 1 = return 'undef' for cells with formatting only,
0 = return the result of empty_return_type (or cell objects)
for cells that only contain formatting.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_values_only\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIfrom_the_edge\fR
.IX Subsection "from_the_edge"
.Sp
.RS 4
\&\fBDefinition:\fR Some data tables start in the top left corner.  Others do not.  I
don't reccomend that practice but when aquiring data in the wild it is often good
to adapt.  This attribute sets whether the file percieves the min_col
 and min_row
 as the top left edge of the sheeto or
from the top row with data and starting from the leftmost column with data.
.Sp
\&\fBDefault\fR 1
.Sp
\&\fBRange\fR 1 = treat the top left corner of the sheet as the beginning of rows and
columns even if there is no data in the top row or leftmost column, 0 = Set the
minimum row and minimum columns to be the first row and first column with data
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBstarts_at_the_edge\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the attribute state
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIcache_positions\fR
.IX Subsection "cache_positions"
.Sp
.RS 4
\&\fBDefinition:\fR Using the standard architecture this parser would go back and
read the sharedStrings and styles files sequentially from the beginning each
time it had to access a sub elelement.  This trade-off is generally not desired
for these two files since the data is generally stored in a less than sequential
fasion.  The solution is to cache these files as they are read the first time so
that a second pass through is not necessary to retreive an earlier element.  The
only time this doesn't make sence is if either of the files would overwhelm \s-1RAM\s0 if
cached.  The package has file size break points below which the files will cache.
The thinking is that above these points the \s-1RAM\s0 is at risk of being overwhelmed
and that not crashing and slow is better than a possible out-of-memory state.
This attribute allows you to change those break points based on the target machine
you are running on.  The breaks are set on the byte size of the sub file not on the
cached expansion of the sub file.  In general the styles file is cached into a hash
and the shared strings file is cached into an array ref.  The attribute
group_return_type also affects the size of the cache for the
sharedStrings file since it will not cache the string formats unless the attribute
is set to 'instance'.  There is also a setting for caching worksheet data.  Some
worksheet row position settings will always be cached in order to speed up multiple
reads over the same sheet or to query meta data about the rows.  However, this
cache level is set lower since the row caching creates much deeper data structures.
.Sp
\&\fBDefault\fR
.Sp
.Vb 5
\&        {
\&                shared_strings_interface => 5242880,# 5 MB
\&                styles_interface => 5242880,# 5 MB
\&                worksheet_interface => 2097152,# 2 MB
\&        }
.Ve
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBcache_positions\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the full attribute settings as a hashref
.RE
.RE
.RS 4
.Sp
\&\fBget_cache_size( (shared_strings_interface|styles_interface|worksheet_interface) )\fR
.Sp
.RS 4
\&\fBDefinition:\fR return the max file size allowed to cache for the indicated interface
.RE
.RE
.RS 4
.Sp
\&\fBset_cache_size( \f(CB$target_interface\fB =\fR \f(CW$max_file_size\fR )>
.Sp
.RS 4
\&\fBDefinition:\fR set the \f(CW$max_file_size\fR in bytes to be cached for the indicated \f(CW$target_interface\fR
.RE
.RE
.RS 4
.Sp
\&\fBhas_cache_size( \f(CB$target_interface\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns true if the \f(CW$target_interface\fR has a cache size set
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIshow_sub_file_size\fR
.IX Subsection "show_sub_file_size"
.Sp
.RS 4
\&\fBDefinition:\fR Especially for zip (xlsx and xlsm) files you may not know how big the
file is and want to the package to tell you what size it thinks the file is.  This
attribute turns on a warning statment that prints to \s-1STDERR\s0 with information on the
size of potientially cached files.
.Sp
\&\fBDefault\fR 0
.Sp
\&\fBRange\fR 0 = don't warn the file size, 1 = send the potentially cached file sizes to
\&\s-1STDERR\s0 for review
.RE
.PP
\fIgroup_return_type\fR
.IX Subsection "group_return_type"
.Sp
.RS 4
\&\fBDefinition:\fR Traditionally ParseExcel returns a cell object with lots of methods
to reveal information about the cell.  In reality the extra information is not used very
much (witness the popularity of Spreadsheet::XLSX).  Because many users don't need or
want the extra cell formatting information it is possible to get either the raw xml value,
the raw visible cell value (seen in the Excel format bar), or the formatted cell value
returned either the way the Excel file specified or the way you specify
 instead of a Cell instance with
all the data.  All empty cells return undef no matter what.
.Sp
\&\fBDefault\fR instance
.Sp
\&\fBRange\fR instance = returns a populated Spreadsheet::Reader::ExcelXML::Cell instance,
xml_value = returns the string stored in the xml file \- for xml based sheets this can sometimes
be different thant the visible value in the cell or formula bar.  unformatted = returns just the
raw visible value of the cell shown in the Excel formula bar, value = returns just the formatted
value stored in the excel cell
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_group_return_type\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIempty_return_type\fR
.IX Subsection "empty_return_type"
.Sp
.RS 4
\&\fBDefinition:\fR Traditionally Spreadsheet::ParseExcel returns an empty string for cells
with unique formatting but no stored value.  It may be that the more accurate way of returning
undef works better for you.  This will turn that behaviour on.
.Sp
\&\fBDefault\fR empty_string
.Sp
\&\fBRange\fR
	empty_string = populates the unformatted value with '' even if it is set to undef
	undef_string = if excel stores undef for an unformatted value it will return undef
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_empty_return_type\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIspread_merged_values\fR
.IX Subsection "spread_merged_values"
.Sp
.RS 4
\&\fBDefinition:\fR In Excel you visibly see the value of the primary cell in a merged range displayed
in all the cells.  This attribute lets the code see the primary value show in each of the merged
cells.  There is some mandatory caching to pull this off so it will consume more memory.
.Sp
\&\fBDefault\fR 0 (To match the Excel formula bar, VBscript, and Spreadsheet::ParseExcel)
.Sp
\&\fBRange\fR 0 = don't spread the primary value, 1 = spread the primary value
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBspreading_merged_values\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIskip_hidden\fR
.IX Subsection "skip_hidden"
.Sp
.RS 4
\&\fBDefinition:\fR Like the previous attribute this attempts to match a visual effect in Excel.
Even though hidden cells still contain values you can't see them visibly.  This allows
you to skip hidden rows and columns (not hidden sheets).  The one gotcha is Excel will
place the primary value in the new primary merged cell (formula bar) if a merge range is
only partially obscured to include the original primary cell.  This package can't do that.
Either spread the primary to all cells or none.
.Sp
\&\fBDefault\fR 0 (To match VBscript and Spreadsheet::ParseExcel)
.Sp
\&\fBRange\fR 0 = don't skip hidden rows and columns, 1 = skip hidden rows and columns
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBshould_skip_hidden\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIspaces_are_empty\fR
.IX Subsection "spaces_are_empty"
.Sp
.RS 4
\&\fBDefinition:\fR Some auto file generators tend to add empty strings or strings with spaces to
fill empty cells.  There may be some visual value in this but they can slow down parsing scripts.
this attribute allows the sheet to treat spaces as empty or undef instead of cells with values.
.Sp
\&\fBDefault\fR 0 (To match Excel and Spreadsheet::ParseExcel)
.Sp
\&\fBRange\fR 0 = cells with zero length strings and spaces are considered to have 'values", 1 = There must
be something other than spaces or a zero length string for the cell to have value.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBare_spaces_empty\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fImerge_data\fR
.IX Subsection "merge_data"
.Sp
.RS 4
\&\fBDefinition:\fR For zip based worksheets the merge data is stored at the end of the file.  In order for
the parser to arrive at that point it has to read through the whole sheet first.  For big worksheet
files this is very slow.  If you are willing to not know or implement cell merge information then turn
this off and the sheet should load much faster.
.Sp
\&\fBDefault\fR 1 (collect merge data)
.Sp
\&\fBRange\fR 1 = The merge data is parsed from the worksheet file when it is opened, 0 = No merge data is
parsed.  The effect is equal to the cell merges dissapearing.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBcollecting_merge_data\fR
.Sp
.RS 4
\&\fBDefinition:\fR a way to check the current attribute setting
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SS "\s-1FLAGS\s0"
.IX Subsection "FLAGS"
The parameter list (Attributes) that are possible to pass to \->new is somewhat long.
Therefore you may want a shortcut that aggregates some set of attribute settings that
are not the defaults but wind up being boilerplate.  I have provided possible
alternate sets like this and am open to providing others that are suggested.  The
flags will have a : in front of the identifier and will be passed to the class in the
\&'use' statement for consumption by the import method.  The flags can be stacked and
where there is conflict between the flag settings the rightmost passed flag setting is
used. If everything in the flag but one or two settings are desirable still use the flag and
then overwrite those settings when calling new.
.PP
Example;
.PP
.Vb 1
\&        use Spreadsheet::Reader::ExcelXML v0.2 qw( :alt_default :debug );
.Ve
.PP
\fI:alt_default\fR
.IX Subsection ":alt_default"
.PP
This is intended for a deep look at data and skip formatting cells.
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
values_only => 1
.Sp
count_from_zero => 0
.Sp
empty_is_end => 1
.RE
.RE
.RS 4
.RE
.PP
\fI:just_the_data\fR
.IX Subsection ":just_the_data"
.PP
This is intended for a shallow look at data with value formatting implemented
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
count_from_zero => 0
.Sp
values_only => 1
.Sp
empty_is_end => 1
.Sp
group_return_type => 'value'
.Sp
from_the_edge => 0
.Sp
empty_return_type => 'undef_string'
.Sp
spaces_are_empty => 1
.Sp
merge_data => 0
.Sp
column_formats => 0
.RE
.RE
.RS 4
.RE
.PP
\fI:just_raw_data\fR
.IX Subsection ":just_raw_data"
.PP
This is intended for a shallow look at raw text and skips all formatting including number formats.
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
count_from_zero => 0
.Sp
values_only => 1
.Sp
empty_is_end => 1
.Sp
group_return_type => 'xml_value'
.Sp
from_the_edge => 0,
.Sp
empty_return_type => 'undef_string'
.Sp
spaces_are_empty => 1
.Sp
merge_data => 0
.Sp
column_formats => 0
.RE
.RE
.RS 4
.RE
.PP
\fI:like_ParseExcel\fR
.IX Subsection ":like_ParseExcel"
.PP
This is a way to force some of the other groups back to instance and count from zero
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
count_from_zero => 1
.Sp
group_return_type => 'instance'
.RE
.RE
.RS 4
.RE
.PP
\fI:debug\fR
.IX Subsection ":debug"
.PP
This is a way to turn on as much reporting as possible
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
error_inst \->
.Sp
.Vb 5
\&        error_inst =>{
\&                superclasses => [\*(AqSpreadsheet::Reader::ExcelXML::Error\*(Aq],
\&                package => \*(AqErrorInstance\*(Aq,
\&                should_warn => 1,
\&        }
.Ve
.Sp
show_sub_file_size => 1
.RE
.RE
.RS 4
.RE
.PP
\fI:lots_of_ram\fR
.IX Subsection ":lots_of_ram"
.PP
This opens the caching size allowances way up
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
cache_positions \->
.Sp
.Vb 5
\&        cache_positions =>{
\&                shared_strings_interface => 209715200,# 200 MB
\&                styles_interface => 209715200,# 200 MB
\&                worksheet_interface => 209715200,# 200 MB
\&        },
.Ve
.RE
.RE
.RS 4
.RE
.PP
\fI:less_ram\fR
.IX Subsection ":less_ram"
.PP
This tightens caching size allowances way down
.Sp
.RS 4
\&\fBDefault attribute differences\fR
.Sp
.RS 4
cache_positions \->
.Sp
.Vb 5
\&        cache_positions =>{
\&                shared_strings_interface => 10240,# 10 KB
\&                styles_interface => 10240,# 10 KB
\&                worksheet_interface => 1024,# 1 KB
\&        },
.Ve
.RE
.RE
.RS 4
.RE
.SS "Secondary Methods"
.IX Subsection "Secondary Methods"
These are additional ways to use this class.  They can be used to open an .xlsx workbook.
They are also ways to investigate information at the workbook level.  For information on
how to retrieve data from the worksheets see the
Worksheet and
Cell documentation.  For additional workbook
options see the Secondary Methods
and the Attributes sections.  The attributes section specifically contains
all the methods used to adjust the attributes of this class.
.PP
All methods are object methods and should be implemented on the object instance.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        my @worksheet_array = $workbook_instance\->worksheets;
.Ve
.PP
\fIget_epoch_year\fR
.IX Subsection "get_epoch_year"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the epoch year defined by the Excel workbook.  The epoch year
affects the way dates are processed in the formatter Spreadsheet::Reader::Format
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1900 = Windows Excel or 1904 = Apple Excel
.RE
.PP
\fIhas_epoch_year\fR
.IX Subsection "has_epoch_year"
.Sp
.RS 4
\&\fBDefinition:\fR This indicates if an epoch_year has been determined for the workbook (yet)
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR 1 = yes there is one, 0 = nothing (yet)
.RE
.PP
\fIget_sheet_name( \f(CI$Int\fI )\fR
.IX Subsection "get_sheet_name( $Int )"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the sheet name for a given physical position
in the workbook from left to right. It counts from zero even if the workbook is in
\&'count_from_one' mode.  B(It will return chart names but chart tab names cannot currently
be converted to worksheets). You may actually want worksheet_name
instead of this function.
.Sp
\&\fBAccepts:\fR integers
.Sp
\&\fBReturns:\fR the sheet name (both worksheet and chartsheet )
.RE
.PP
\fIsheet_count\fR
.IX Subsection "sheet_count"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the total number of recorded sheets
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$total\fR \- a count of all sheets (including chartsheets and worksheets)
.RE
.PP
\fIget_sheet_info( \f(CI$name\fI )\fR
.IX Subsection "get_sheet_info( $name )"
.Sp
.RS 4
\&\fBDefinition:\fR This returns any stored metadata about the sheet in a hashref
.Sp
\&\fBAccepts:\fR \f(CW$name\fR
.Sp
\&\fBReturns:\fR a hashref of sheet metadata ( a pretty thin list still )
.RE
.PP
\fIget_rel_info( \f(CI$relId\fI )\fR
.IX Subsection "get_rel_info( $relId )"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the sheet name for the \f(CW$relId\fR
.Sp
\&\fBAccepts:\fR \f(CW$relId\fR ex; 'rId5'
.Sp
\&\fBReturns:\fR The sheet \f(CW$name\fR associated with that relId
.RE
.PP
\fIget_id_info( \f(CI$Id\fI )\fR
.IX Subsection "get_id_info( $Id )"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the sheet name for the \f(CW$Id\fR
.Sp
\&\fBAccepts:\fR \f(CW$Id\fR (an integer) ex; '2'
.Sp
\&\fBReturns:\fR The sheet \f(CW$name\fR associated with that Id
.RE
.PP
\fIget_chartsheet_names\fR
.IX Subsection "get_chartsheet_names"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns an array ref of all the chartsheet names (tabs) in the
workbook in order.  (No worksheets.)
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an array ref of strings
.RE
.PP
\fIchartsheet_name( \f(CI$position\fI )\fR
.IX Subsection "chartsheet_name( $position )"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the name of the chartsheet in that \f(CW$position\fR. (counting from zero)
interspersed worksheets in the file are not considered to hold a position by this accounting.
.Sp
\&\fBAccepts:\fR \f(CW$position\fR (an integer)
.Sp
\&\fBReturns:\fR the chartsheet name
.RE
.PP
\fIchartsheet_count\fR
.IX Subsection "chartsheet_count"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the total number of recorded chartsheets
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$total\fR \- a count of all chartsheets (only)
.RE
.PP
\fIcreator\fR
.IX Subsection "creator"
.Sp
.RS 4
\&\fBDefinition:\fR Returns the recorded creator of the file from the parsed metadata
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a string
.RE
.PP
\fImodified_by\fR
.IX Subsection "modified_by"
.Sp
.RS 4
\&\fBDefinition:\fR Returns the recorded last entity to modify the file from the parsed metadata
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a string
.RE
.PP
\fIdate_created\fR
.IX Subsection "date_created"
.Sp
.RS 4
\&\fBDefinition:\fR Returns the date that Excel recorded for the file creation
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a string (YYYY-MM-DD)
.RE
.PP
\fIdate_modified\fR
.IX Subsection "date_modified"
.Sp
.RS 4
\&\fBDefinition:\fR Returns the date that Excel recorded for the last file modification
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a string (YYYY-MM-DD)
.RE
.PP
\fIin_the_list\fR
.IX Subsection "in_the_list"
.Sp
.RS 4
\&\fBDefinition:\fR This is a predicate method that indicates if the 'next'
worksheet function has been implemented at least once.
.Sp
\&\fBAccepts:\fRnothing
.Sp
\&\fBReturns:\fR true = 1, false = 0
.RE
.PP
\fIstart_at_the_beginning\fR
.IX Subsection "start_at_the_beginning"
.Sp
.RS 4
\&\fBDefinition:\fR This restarts the 'next' worksheet at the first worksheet.  This
method is only useful in the context of the worksheet
function.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.SS "Architecture Choices"
.IX Subsection "Architecture Choices"
This is yet another package for parsing Excel xml or 2007+ (and 2003+ xml) workbooks.
There are two other options for 2007+ \s-1XLSX\s0 parsing (but not 2003 xml parsing) on \s-1CPAN.\s0
(Spreadsheet::ParseXLSX and Spreadsheet::XLSX)  In general if either of them
already work for you without issue then there is probably no compelling reason to
switch to this package.  However, the goals of this package which may provide
differentiation are five fold.  First, as close as possible produce the same output as
is visible in an excel spreadsheet with exposure to underlying settings from Excel.
Second, adhere as close as is reasonable to the Spreadsheet::ParseExcel \s-1API\s0 (where
it doesn't conflict with the first objective) so that less work would be needed to
integrate ParseExcel and this package.  An addendum to the second goal is this package
will not expose elements of the object hash for use by the consuming program.  This
package will either return an unblessed hash with the equivalent elements to the
Spreadsheet::ParseExcel output (instead of a class instance) or it will provide methods
to provide these sets of data.  The third goal is to read the excel files in a 'just in
time' manner without storing all the data in memory.  The intent is to minimize the
footprint of large file reads.  Initially I did this using XML::LibXML but it
eventually proved to not play well <http://www.perlmonks.org/?node_id=1151609> with
Moose ( or perl? ) garbage collection so this package uses a pure perl xml parser.
In general this means that design decisions will generally sacrifice speed to keep \s-1RAM\s0
consumption low.  Since the data in the sheet is parsed just in time the information that
is not contained in the primary meta-data headers will not be available for review until
the sheet parses to that point.  In
cases where the parser has made choices that prioritize speed over \s-1RAM\s0 savings there will
generally be an attribute available to turn that decision off.
Fourth, Excel files get abused in the wild.  In general the Microsoft (\s-1TM\s0) Excel
application handles these mangled files gracefully. The goal is to be able to read any
xml based spreadsheet Excel can read from the supported extention list.  Finally, this
parser supports the Excel 2003 xml format.  All in all this package solves many of the
issues I found parsing Excel in the wild.  I hope it solves some of yours as well.
.SS "Warnings"
.IX Subsection "Warnings"
\&\fB1.\fRThis package uses Archive::Zip.  Not all versions of Archive::Zip work for everyone.
I have tested this with Archive::Zip 1.30.  Please let me know if this does not work with a
sucessfully installed (read passed the full test suit) version of Archive::Zip newer than that.
.PP
\&\fB2.\fR Not all workbook sheets (tabs) are created equal!  Some Excel sheet tabs are only a
chart.  These tabs are 'chartsheets'.  The methods with 'worksheet' in the name only act on
the sub set of tabs that are worksheets.  Future methods with 'chartsheet' in the name will
focus on the subset of sheets that are chartsheets.  Methods with just 'sheet' in the name
have the potential to act on both.  The documentation for the chartsheet level class is
found in Spreadsheet::Reader::ExcelXML::Chartsheet (still under construction).
All chartsheet classes do not provide access to cells.
.PP
\&\fB3.\fR This package supports reading xlsm files (Macro enabled Excel 2007+ workbooks).
xlsm files allow for binaries to be embedded that may contain malicious code.  However,
other than unzipping the excel file no work is done by this package with the sub-file
\&'vbaProject.bin' containing the binaries.  This package does not provide an \s-1API\s0 to that
sub-file and I have no intention of doing so.  Therefore my research indicates there should
be no risk of virus activation while parsing even an infected xlsm file with this package
but I encourage you to use your own judgement in this area. \fBcaveat utilitor!
 <https://en.wiktionary.org/wiki/Appendix:List_of_Latin_phrases>\fR
.PP
\&\fB4.\fR This package will read some files with 'broken' xml.  In general this should be
transparent but in the case of the maximum row value and the maximum column value for a
worksheet it can cause some surprising problems.  This includes the possibility that the
maximum values are initially stored as 'undef' if the sheet does not provide them in the
metadata as expected.  \fIThese values are generally never available in Excel 2003 xml
files.\fR  The answer to the methods \*(L"row_range\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet
and \*(L"col_range\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet will then change as more
of the sheet is parsed.  You can use the attribute file_boundary_flags
 or the methods \*(L"get_next_value\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet
or \*(L"fetchrow_arrayref\*(R" in Spreadsheet::Reader::ExcelXML::Worksheet as alternates to
pre-testing for boundaries when iterating.  The primary cause of these broken \s-1XML\s0
elements in Excel 2007+ files are non-XML applications writing to or editing the
underlying xml.  If you have an example of other broken xml files readable by the
Excel application that are not parsable by this package please submit them
 <https://github.com/jandrew/Spreadsheet-XLSX-Reader-LibXML/issues> to my github repo
so I can work to improve this package.  If you don't want your test case included
with the distribution I will use it to improve the package without publishing it.
.PP
\&\fB5.\fR I reserve the right to tweak the sub file caching breakpoints
over the next few releases.  The goal is to have a default that appears to be the
best compromise by 2017\-1\-1.
.PP
\&\fB6.\fR This package provides  support for SpreadsheetML
 <https://odieweblog.wordpress.com/2012/02/12/how-to-read-and-write-office-2003-excel-xml-files/>
(Excel 2003) .xml extention documents.  These files should include the header;
.PP
.Vb 1
\&        <?mso\-application progid="Excel.Sheet"?>
.Ve
.PP
to indicate their intended format.  Please submit any cases that
appear to behave differently than expected for .xml extention files that are
readable by the Excel application.  I am also interested in cases where an out of
memory error occurs with an .xml extension file.  This warning will stay till
2017\-1\-1.
.PP
\&\fB7.\fR This package uses two classes at the top to handle cleanup for some self
referential <http://perldoc.perl.org/5.8.9/perlobj.html#Two-Phased-Garbage-Collection>
object organization that I use.  As a result the action taken on this package is
(mostly) implemented in Spreadsheet::Reader::ExcelXML::Workbook code.  I documented
most of that code \s-1API\s0 here.  If you want to look at the raw code go there.
.SH "BUILD / INSTALL from Source"
.IX Header "BUILD / INSTALL from Source"
\&\fB0.\fR Using cpanm <https://metacpan.org/pod/App::cpanminus> is much easier
than a source build!
.PP
.Vb 1
\&        cpanm Spreadsheet::Reader::ExcelXML
.Ve
.PP
And then if you feel kindly App::cpanminus::reporter
.PP
.Vb 1
\&        cpanm\-reporter
.Ve
.PP
\&\fB1.\fR Download a compressed file with this package code from your favorite source
.Sp
.RS 4
github <https://github.com/jandrew/p5-spreadsheet-reader-excelxml>
.Sp
Meta::CPAN <https://metacpan.org/pod/Spreadsheet::Reader::ExcelXML>
.Sp
\&\s-1CPAN\s0 <http://search.cpan.org/~jandrew/Spreadsheet-Reader-ExcelXML/>
.RE
.PP
\&\fB2.\fR Extract the code from the compressed file.
.Sp
.RS 4
If you are using tar on a .tar.gz file this should work:
.Sp
.Vb 1
\&        tar \-zxvf Spreadsheet\-Reader\-ExcelXML\-v0.xx.tar.gz
.Ve
.RE
.PP
\&\fB3.\fR Change (cd) into the extracted directory
.PP
\&\fB4.\fR Run the following
.Sp
.RS 4
(for Windows find what version of make was used to compile your perl)
.Sp
.Vb 1
\&        perl  \-V:make
.Ve
.Sp
(then for Windows substitute the correct make function (s/make/dmake/g)? below)
.RE
.PP
.Vb 1
\&        perl Makefile.PL
\&
\&        make
\&
\&        make test
\&
\&        make install # As sudo/root
\&
\&        make clean
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::Format/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-excelxml/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Write a chartsheet parser and functions
.Sp
\&\fB2.\fR Add a pivot table reader (Not just read the values from the sheet)
.Sp
\&\fB3.\fR Add calc chain methods
.Sp
\&\fB4.\fR Add more exposure to workbook/worksheet formatting values
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.RS 4
Jed Lund
.Sp
jandrew@cpan.org
.RE
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
This is the (likely incomplete) list of people who have helped
make this distribution what it is, either via code contributions,
patches, bug reports, help with troubleshooting, etc. A huge
\&'thank you' to all of them.  Most were contributors to
Spreadsheet::XLSX::Reader::LibXML but the contributions have
(hopefully) not been lost.
.Sp
.RS 4
Frank Maas <https://github.com/Frank071>
.Sp
Stuart Watt <https://github.com/morungos>
.Sp
Toby Inkster <https://github.com/tobyink>
.Sp
Breno G. de Oliveira <https://github.com/garu>
.Sp
Bill Baker <https://github.com/wdbaker54>
.Sp
H.Merijin Brand <https://github.com/Tux>
.Sp
Todd Eigenschink <mailto:todd@xymmetrix.com>
.Sp
Slaven Rezić <https://metacpan.org/author/SREZIC>
.RE
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016, 2017 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
perl 5.010
.Sp
Archive::Zip
.Sp
Carp
.Sp
Clone
.Sp
DateTime::Format::Flexible
.Sp
DateTimeX::Format::Excel
.Sp
IO::File
.Sp
Moose \- 2.1213
.Sp
MooseX::HasDefaults::RO
.Sp
MooseX::ShortCut::BuildInstance \- 1.032
.Sp
MooseX::StrictConstructor
.Sp
Type::Tiny \- 1.000
.Sp
version \- 0.077
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::Read \- generic Spreadsheet reader
.Sp
Spreadsheet::ParseExcel \- Excel binary files from 2003 and earlier
.Sp
Spreadsheet::ParseXLSX \- Excel version 2007 and later
.Sp
Spreadsheet::XLSX \- Excel version 2007 and later (Very rough)
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
