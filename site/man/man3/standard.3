.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "standard 3"
.TH standard 3 "2020-08-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
standard \- Enforce Standard Perl syntax with Guacamole
.SH "VERSION"
.IX Header "VERSION"
version 0.007
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use standard;
\&    # Now you will get a warning if you don\*(Aqt conform to Standard Perl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBStandard Perl\fR aims to use only the syntax that makes Perl easy to parse.
A Perl static parser such as Guacamole isn't that hard if we avoid a small
set of constructs that cause parser ambiguities.
.PP
These changes are described below. Over time, this documentation will explain
the standard itself versus the differences between this subset and what the
perl interpreter supports.
.SH "DIFFERENCES"
.IX Header "DIFFERENCES"
.SS "Things not supported"
.IX Subsection "Things not supported"
This list covers constructs that the perl interpreter understands (for whatever
value of \*(L"understand\*(R" is) but that that Standard Perl does not support.
.IP "\(bu" 4
Auto-quoting
.Sp
Perl's auto-quoting rules are... rather elaborate and awkward. Much of it is
unknown and can even depend on lowercase vs. uppercase and specific letters with
special meaning to the interpreter and not the user.
.Sp
Thus, a string in Standard Perl is always quoted.
.Sp
.Vb 2
\&    $foo{key}   # not ok
\&    $foo{\*(Aqkey\*(Aq} # ok
\&
\&    %hash = ( foo   => \*(Aqbar\*(Aq ); # not ok
\&    %hash = ( \*(Aqfoo\*(Aq => \*(Aqbar\*(Aq ); # ok
.Ve
.IP "\(bu" 4
HEREDOCs
.Sp
HEREDOCs are a monstrosity for parsers and cannot be expressed with a \s-1BNF.\s0 It is
thus not supported.
.Sp
.Vb 4
\&    # This will fail
\&    my $value = << \*(Aq_END_OF_VALUE\*(Aq;
\&    ...
\&    _END_OF_VALUE
\&
\&    # This is an alternative
\&    my $value =
\&    q{...
\&    };
\&
\&    # This is another alternative:
\&    my $value = q{
\&    ...
\&    } =~ s/^\en//r;
.Ve
.IP "\(bu" 4
Indirect object notation
.Sp
.Vb 2
\&    my $instance = new Class;    # not ok
\&    my $instance = Class\->new(); # ok
.Ve
.IP "\(bu" 4
Bareword filehandles
.Sp
.Vb 3
\&    open FOO, ...    # not ok
\&    open my $fh, ... # ok
\&    open $fh, ...    # also ok
\&
\&    print STDOUT $foo; # also ok
\&    print STDERR $foo; # also ok
\&
\&    while ( <FOO>   ) {...} # not ok
\&    while ( <$foo>  ) {...} # ok
\&    while ( <STDIN> ) {...} # also ok
.Ve
.Sp
The following bareword filehandles are supported:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`STDIN\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`STDOUT\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`STDERR\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`ARGV\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`ARGVOUT\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`DATA\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
Printing to filehandles with no brace
.Sp
.Vb 2
\&    print $fh $foo;   # not ok
\&    print {$fh} $foo; # ok
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`_\*(C'\fR in file operations
.Sp
.Vb 2
\&    if ( \-f $foo && \-r _ )    {...} # not ok
\&    if ( \-f $foo && \-r $foo ) {...} $ ok
.Ve
.Sp
\&\f(CW\*(C`_\*(C'\fR is an ambiguous bareword identifier. For example, using it in
\&\f(CW\*(C`print\*(C'\fR is parsed different than when used with \f(CW\*(C`\-r\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`given\*(C'\fR / \f(CW\*(C`when\*(C'\fR / \f(CW\*(C`default\*(C'\fR
.Sp
Not supported.
.SS "Things we changed"
.IX Subsection "Things we changed"
The following are limitations that Standard Perl has which the perl
interpreter doesn't.
.PP
\fIQ\-Like values delimiters\fR
.IX Subsection "Q-Like values delimiters"
.PP
Q\-Like values are one of the following: \f(CW\*(C`q\*(C'\fR, \f(CW\*(C`qq\*(C'\fR, \f(CW\*(C`qw\*(C'\fR, \f(CW\*(C`qx\*(C'\fR, \f(CW\*(C`qr\*(C'\fR
.PP
However, the following limitations also apply to: \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR \f(CW\*(C`tr///\*(C'\fR,
and \f(CW\*(C`y///\*(C'\fR.
.IP "\(bu" 4
No nested delimiters
.Sp
.Vb 2
\&    $val = q< <> >;    # not ok
\&    $val = q< \e<\e> >;  # ok
.Ve
.Sp
If you want to use the delimiter within delimited space, escape it.
.IP "\(bu" 4
Limited delimiters
.Sp
Only the following delimiters are supported:
.Sp
\&\f(CW\*(C`()\*(C'\fR, \f(CW\*(C`[]\*(C'\fR, \f(CW\*(C`{}\*(C'\fR, \f(CW\*(C`< >\*(C'\fR, \f(CW\*(C`//\*(C'\fR, \f(CW\*(C`!!\*(C'\fR, and \f(CW\*(C`||\*(C'\fR.
.Sp
.Vb 7
\&    $val = q(...) # ok
\&    $val = q[...] # ok
\&    $val = q{...} # ok
\&    $val = q<...> # ok
\&    $val = q/.../ # ok
\&    $val = q!...! # ok
\&    $val = q|...| # ok
\&
\&    $val = q@...@    # not ok
\&    $val = q#...#    # not ok
\&    $val = q Z ... Z # not ok
.Ve
.IP "\(bu" 4
No spaces between before delimiters:
.Sp
.Vb 4
\&    q <foo> # not ok
\&    q<foo>  # ok
\&    q ()    # not ok
\&    q()     # ok
.Ve
.PP
\fISubroutines\fR
.IX Subsection "Subroutines"
.IP "\(bu" 4
\&\fBAll\fR subroutines must use parentheses
.Sp
.Vb 2
\&    foo $bar   # not ok
\&    foo($bar)  # ok
.Ve
.Sp
There is an exception for methods:
.Sp
.Vb 2
\&    $foo\->bar()         # ok
\&    $foo\->bar           # also ok
\&
\&    $foo\->bar()\->baz()  # ok
\&    $foo\->bar\->baz      # also ok
.Ve
.IP "\(bu" 4
Subroutines can have attributes and signatures
.Sp
Standard Perl accepts both attributes and signatures.
.IP "\(bu" 4
All subroutine prototypes must be declared using an attribute
.Sp
.Vb 2
\&    sub foo ($)           {...} # signature, not prototype
\&    sub foo :prototype($) {...} # prototype, not signature
.Ve
.IP "\(bu" 4
Prototypes do not change the parsing rules
.Sp
.Vb 2
\&    first {...} @foo         # not ok
\&    first( sub {...}, @foo ) # ok
.Ve
.Sp
We are looking into allowing developers to have their grammars hooking
up to the Guacamole parser so it could allow to extend Standard Perl.
This will be useful for stuff like List::Util, Dancer2,
Mojolicious::Lite, Moose, etc.
.Sp
Having said that, Standard Perl doesn't accept this.
.PP
\fIClass names\fR
.IX Subsection "Class names"
.IP "\(bu" 4
Left of arrow is always an invocant, never a function
.Sp
.Vb 1
\&    Foo\->new(); # always a class, never a function "Foo"
.Ve
.Sp
This is tricky because the perl interpreter might see a function called
\&\f(CW\*(C`foo\*(C'\fR in the same scope and call that instead. This would mean that
Standard Perl and the perl interpreter would report different results.
.Sp
We have a shim layer in standard that checks for this and alerts if
this will happen, so you never hit this issue when using \f(CW\*(C`standard\*(C'\fR.
.Sp
We advise other parsers who use Standard Perl \s-1BNF\s0 to include this part.
.IP "\(bu" 4
Namespaces cannot end with a double colon
.Sp
.Vb 2
\&    Foo\->bar();   # ok
\&    Foo::\->bar(); # not ok
.Ve
.Sp
This might be changed.
.PP
\fIDereferencing\fR
.IX Subsection "Dereferencing"
.IP "\(bu" 4
Prefixed dereferencing is only supported with braces
.Sp
.Vb 3
\&    @$foo    # not ok
\&    @{$foo}  # ok
\&    $foo\->@* # ok
.Ve
.PP
\fIExpressions\fR
.IX Subsection "Expressions"
.IP "\(bu" 4
\&\f(CW\*(C`map\*(C'\fR that attempts to return a pair must use parenthesis
.Sp
.Vb 2
\&    map {   $_ => 1   }, @foo  # not ok
\&    map { ( $_ => 1 ) }, @foo  # ok
.Ve
.PP
\fIEval\fR
.IX Subsection "Eval"
.IP "\(bu" 4
\&\f(CW\*(C`eval\*(C'\fR only supports a block, not an expression
.Sp
.Vb 2
\&    eval { ... }   # ok
\&    eval " ... "   # not ok
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Guacamole
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Sawyer X
.IP "\(bu" 4
Vickenty Fesunov
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Sawyer X.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The MIT (X11) License
.Ve
