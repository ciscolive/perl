.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Bash::Completion::Generator 3"
.TH Term::Bash::Completion::Generator 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Bash::Completion::Generator \- Generate bash completion scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # use default bash completion options
\&  generate_bash_completion_function(\*(Aqmy_command\*(Aq, [\*(Aqoption1\*(Aq, \*(Aq\*(Aqoption2\*(Aq]) ;
\&        
\&  # fine tune with the bash completion options
\&  generate_bash_completion_function(\*(Aqmy_command\*(Aq, [\*(Aqoption1\*(Aq, \*(Aq\*(Aqoption2\*(Aq], \*(Aq\-*\*(Aq, 0, \*(Aq\-o plusdirs\*(Aq)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Generate bash completion functions or perl scripts to dynamically provide completion for an application.
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
If you application or scripts have more than one or two options and you run a bash shell, it is 
advisable you provide a completion file for your application.
.PP
A completion file provides information to bash so when your user presses [tab], on the command line,
possible completion is provided to the user.
.PP
This module provide you with subroutines to create the completion scripts. The completion scripts are
either simple bash functions or scripts that allow you to dynamically generate completion. The scripts
can be written in any language. This module generate scripts that are written in perl.
.PP
The perl scripts can be generated  by calling the subroutine i this module or by running
the \fIgenerate_perl_completion_script\fR script installed with this module.
.PP
The generated scripts can provide completion for applications written in any language. A good place to
generate completion is in your \fIBuild.PL\fR or \fIMakefile.PL\fR. Remember to test your completions too.
.SH "BASH COMPLETION DOCUMENTATION"
.IX Header "BASH COMPLETION DOCUMENTATION"
Run 'man bash' on your prompt and search for 'Programmable Completion'.
.PP
bash\-completion\-20060301.tar.gz library, an older but useful archive of completion functions for common
commands.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "generate_perl_completion_script($command, \e@completion_list)"
.IX Subsection "generate_perl_completion_script($command, @completion_list)"
Generates a perl script that can be used to dynamically generate completion for the bash 
command line.
.PP
Tree::Trie is used in the script to do the basic look-up. Tree::Trie was installed as
dependency to this module. Modify the generated script to implement your completion logic.
.PP
You can also use the \fIgenerate_perl_completion_script\fR script to create the perl completion
script from the command line.
.PP
\&\fIArguments\fR
.IP "\(bu" 2
\&\f(CW$command\fR \- a string containing the command name
.IP "\(bu" 2
\&\e@completion_list \- list of options to create completion for
.Sp
the options can be simple strings or a Getopt::Long specifications
.PP
\&\fIReturns\fR \- an array containing:
.IP "\(bu" 2
a string containing the bash completion command
.IP "\(bu" 2
a string containing the perl script
.PP
\&\fIExceptions\fR \- carps if \f(CW$command\fR is not defined
.PP
\&\fBsource\fR the following line in your \fI~/.bashrc\fR:
.PP
\&\s-1EOC\s0
.PP
\&\f(CW$perl_completion_script\fR .= <<\*(L"\s-1EOC\*(R"\s0 ;
\&\fBcomplete\fR \f(CW$bash_completion_arguments\fR
.PP
\&\s-1EOC\s0
.PP
\&\f(CW$perl_completion_script\fR .= <<'\s-1EOC\s0' ;
Replace \fIperl_completion_script\fR with the name you saved the script under. The script has to
be executable and somewhere in the path.
.PP
The script will receive these arguments from bash:
.PP
\&\f(CW@ARGV\fR
|\- 0 = command
|\- 1 = word_to_complete
`\- 2 = word_before_the_word_to_complete
.PP
You return possible completion you want separated by \fI\en\fR. Return nothing if you
want the default bash completion to be run which is possible because of the <\-o defaul>
passed to the \fBcomplete\fR command.
.PP
Note! You may have to re-run the \fBcomplete\fR command after you modify your perl script.
.ie n .SS "generate_bash_completion_function($command, \e@completion_list, $completion_prefix, $single_and_double_dash, $complete_options)"
.el .SS "generate_bash_completion_function($command, \e@completion_list, \f(CW$completion_prefix\fP, \f(CW$single_and_double_dash\fP, \f(CW$complete_options\fP)"
.IX Subsection "generate_bash_completion_function($command, @completion_list, $completion_prefix, $single_and_double_dash, $complete_options)"
Generates a bash function that provides completion for the options passed as parameter.
The options can be simple strings like 'output_directory' or 'a' or Getopt::Long specifications 
like 'j|jobs=i', 'd|display_documentation:s', or 'o'.
.PP
Note that the options do not have any dash at the start.
.PP
\&\fIArguments\fR
.IP "\(bu" 2
\&\f(CW$command\fR \- a string containing the command name
.IP "\(bu" 2
\&\e@completion_list \- list of options to create completion for
.Sp
the options can be simple strings or a Getopt::Long specifications
.IP "\(bu" 2
\&\f(CW$completion_prefix\fR \- see bash manual ; default is '\-*'
.IP "\(bu" 2
\&\f(CW$single_and_double_dash\fR \- boolean variable ; default is 1
.Sp
0 \- single dash for single letter options, double dash for multiple letters options
1 \- all options have single and double dash
.IP "\(bu" 2
\&\f(CW$complete_options\fR \- string containing the options passed to \fIcomplete\fR ; default is '\-o default'
.PP
\&\fIReturns\fR \- a string containing the bash completion script
.PP
\&\fIExceptions\fR \- carps if \f(CW$command\fR is not defined
.SS "de_getop_ify_list(\e@completion_list)"
.IX Subsection "de_getop_ify_list(@completion_list)"
Split Getopt::Long option definitions and remove type information
.PP
\&\fIArguments\fR
.IP "\(bu" 2
\&\e@completion_list \- list of options to create completion for
.Sp
the options can be simple strings or a Getopt::Long specifications
.PP
\&\fIReturns\fR \- an array reference
.PP
\&\fIExceptions\fR \- carps if \f(CW$completion_list\fR is not defined
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
None so far.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&        Nadim ibn hamouda el Khemir
\&        CPAN ID: NH
\&        mailto: nadim@cpan.org
.Ve
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Term::Bash::Completion::Generator
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Term\-Bash\-Completion\-Generator>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
Please report any bugs or feature requests to  L <bug\-term\-bash\-completion\-generator@rt.cpan.org>.
.Sp
We will be notified, and then you'll automatically be notified of progress on
your bug as we make changes.
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Term\-Bash\-Completion\-Generator>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Getopt::Long
.PP
Tree::Trie
.PP
<http://fvue.nl/wiki/Bash_completion_lib>
