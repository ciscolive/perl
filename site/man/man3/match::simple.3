.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "match::simple 3"
.TH match::simple 3 "2017-01-31" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
match::simple \- simplified clone of smartmatch operator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use v5.10;
\&   use match::simple;
\&   
\&   if ($this |M| $that)
\&   {
\&      say "$this matches $that";
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
match::simple provides a simple match operator \f(CW\*(C`|M|\*(C'\fR that acts like
a sane subset of the (as of Perl 5.18) deprecated smart match operator.
Unlike smart match, the behaviour of the match is determined entirely by
the operand on the right hand side.
.IP "\(bu" 4
If the right hand side is \f(CW\*(C`undef\*(C'\fR, then there is only a match if the left
hand side is also \f(CW\*(C`undef\*(C'\fR.
.IP "\(bu" 4
If the right hand side is a non-reference, then the match is a simple string
match.
.IP "\(bu" 4
If the right hand side is a reference to a regexp, then the left hand is
evaluated .
.IP "\(bu" 4
If the right hand side is a code reference, then it is called in a boolean
context with the left hand side being passed as an argument.
.IP "\(bu" 4
If the right hand side is an object which provides a \f(CW\*(C`MATCH\*(C'\fR method, then
it this is called as a method, with the left hand side being passed as an
argument.
.IP "\(bu" 4
If the right hand side is an object which overloads \f(CW\*(C`~~\*(C'\fR, then a true
smart match is performed.
.IP "\(bu" 4
If the right hand side is an arrayref, then the operator recurses into the
array, with the match succeeding if the left hand side matches any array
element.
.IP "\(bu" 4
If any other value appears on the right hand side, the operator will croak.
.PP
If you don't like the crazy Sub::Infix operator, you can alternatively
export a more normal function:
.PP
.Vb 2
\&   use v5.10;
\&   use match::simple qw(match);
\&   
\&   if (match($this, $that))
\&   {
\&      say "$this matches $that";
\&   }
.Ve
.PP
If you're making heavy use of this module, then this is probably your best
option, as it runs significantly faster.
.SS "\s-1XS\s0 Backend"
.IX Subsection "XS Backend"
If you install match::simple::XS, a faster XS-based implementation will be
used instead of the pure Perl functions. Depending on what sort of match you
are doing, this is likely to be several times faster. In extreme cases, such
as matching a string in an arrayref, it can be twenty-five times faster, or
more. However, where \f(CW$that\fR is a single regexp, it's around 30% slower.
Overall though, I think the performance improvement is worthwhile.
.PP
If you want to take advantage of this speed up, use the \f(CW\*(C`match\*(C'\fR function
rather than the \f(CW\*(C`|M|\*(C'\fR operator. Otherwise all your gains will be lost to
the slow implementation of operator overloading.
.PP
The constant \f(CW\*(C`match::simple::IMPLEMENTATION\*(C'\fR tells you which backend
is currently in use.
.SS "Environment"
.IX Subsection "Environment"
Setting the \f(CW\*(C`MATCH_SIMPLE_IMPLEMENTATION\*(C'\fR environment variable to \*(L"\s-1PP\*(R"\s0
encourages match::simple to use the pure Perl backend.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs to
<http://rt.cpan.org/Dist/Display.html?Queue=match\-simple>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
match::smart.
.PP
This module uses Exporter::Tiny.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2013\-2014, 2017 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
