.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Control::CLI::Extreme 3"
.TH Control::CLI::Extreme 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Control::CLI::Extreme \- Interact with CLI of Extreme Networking products over any of Telnet, SSH or Serial port
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Control::CLI::Extreme;
.Ve
.SS "Connecting with Telnet"
.IX Subsection "Connecting with Telnet"
.Vb 7
\&        # Create the object instance for Telnet
\&        $cli = new Control::CLI::Extreme(\*(AqTELNET\*(Aq);
\&        # Connect to host
\&        $cli\->connect(  Host            => \*(Aqhostname\*(Aq,
\&                        Username        => $username,
\&                        Password        => $password,
\&                     );
.Ve
.SS "Connecting with \s-1SSH\s0 \- password authentication"
.IX Subsection "Connecting with SSH - password authentication"
.Vb 7
\&        # Create the object instance for SSH
\&        $cli = new Control::CLI::Extreme(\*(AqSSH\*(Aq);
\&        # Connect to host
\&        $cli\->connect(  Host            => \*(Aqhostname\*(Aq,
\&                        Username        => $username,
\&                        Password        => $password,
\&                     );
.Ve
.SS "Connecting with \s-1SSH\s0 \- publickey authentication"
.IX Subsection "Connecting with SSH - publickey authentication"
.Vb 9
\&        # Create the object instance for SSH
\&        $cli = new Control::CLI::Extreme(\*(AqSSH\*(Aq);
\&        # Connect to host
\&        $cli\->connect(  Host            => \*(Aqhostname\*(Aq,
\&                        Username        => $username,
\&                        PublicKey       => \*(Aq.ssh/id_dsa.pub\*(Aq,
\&                        PrivateKey      => \*(Aq.ssh/id_dsa\*(Aq,
\&                        Passphrase      => $passphrase,
\&                     );
.Ve
.SS "Connecting via Serial port"
.IX Subsection "Connecting via Serial port"
.Vb 11
\&        # Create the object instance for Serial port e.g. /dev/ttyS0 or COM1
\&        $cli = new Control::CLI::Extreme(\*(AqCOM1\*(Aq);
\&        # Connect to host
\&        $cli\->connect(  BaudRate        => 9600,
\&                        Parity          => \*(Aqnone\*(Aq,
\&                        DataBits        => 8,
\&                        StopBits        => 1,
\&                        Handshake       => \*(Aqnone\*(Aq,
\&                        Username        => $username,
\&                        Password        => $password,
\&                     );
.Ve
.SS "Sending commands once connected and disconnecting"
.IX Subsection "Sending commands once connected and disconnecting"
.Vb 1
\&        $cli\->enable;
\&
\&        # Configuration commands
\&        $cli\->return_result(1);
\&        $cli\->cmd(\*(Aqconfig terminal\*(Aq) or die $cli\->last_cmd_errmsg;
\&        $cli\->cmd(\*(Aqno banner\*(Aq) or die $cli\->last_cmd_errmsg;
\&        $cli\->cmd(\*(Aqexit\*(Aq) or die $cli\->last_cmd_errmsg;
\&
\&        # Show commands
\&        $cli\->device_more_paging(0);
\&        $cli\->return_result(0);
\&        $config = $cli\->cmd(\*(Aqshow running\-config\*(Aq);
\&        die $cli\->last_cmd_errmsg unless $cli\->last_cmd_success;
\&        print $config;
\&
\&        $cli\->disconnect;
.Ve
.SS "Configuring multiple Extreme Networking products simultaneously in non-blocking mode"
.IX Subsection "Configuring multiple Extreme Networking products simultaneously in non-blocking mode"
.Vb 1
\&        use Control::CLI::Extreme qw(poll);             # Export class poll method
\&
\&        sub hostError { # Prepend hostname before error its cli object generated
\&                my ($host, $errmsg) = @_;
\&                die "\en$host \-> $errmsg"; 
\&        }
\&
\&        sub bulkDo { # Repeat for all hosts
\&                my ($cliHashRef, $method, $argsRef) = @_;
\&        
\&                foreach my $host (keys %$cliHashRef) { # Call $method for every object
\&                        my $codeRef = $cliHashRef\->{$host}\->can($method);
\&                        $codeRef\->($cliHashRef\->{$host}, @$argsRef);
\&                }
\&                poll(   # Poll all objects for completion of $method
\&                        Object_list     =>      $cliHashRef,
\&                        Poll_code       =>      sub { local $| = 1; print \*(Aq.\*(Aq },
\&                );
\&                print " done!\en";
\&        
\&                if ($method =~ /^cmd/) { # Check that command was accepted
\&                        foreach my $host (keys %$cliHashRef) {
\&                                unless ($cliHashRef\->{$host}\->last_cmd_success) {
\&                                        print "\en\- $host error:\en", $cliHashRef\->{$host}\->last_cmd_errmsg, "\en\en";
\&                                }
\&                        }
\&                }
\&        }
\&
\&        # Create and Connect all the object instances
\&        foreach my $host (@DeviceIPs) {
\&                $cli{$host} = new Control::CLI::Extreme(
\&                        Use             => \*(AqSSH\*(Aq,               # or TELNET (or lots of serial ports!)
\&                        Blocking        => 0,                   # Use non\-blocking mode
\&                        Errmode         => [\e&hostError, $host],# Error handler will add host\-ip to msg
\&                );
\&                $cli{$host}\->connect(
\&                        Host            =>      $host,
\&                        Username        =>      $username,
\&                        Password        =>      $password,
\&                );
\&        }
\&        print "Connecting to all hosts ";
\&        poll(   # Poll all objects for completion of connect
\&                Object_list     =>      \e%cli,
\&                Poll_code       =>      sub { local $| = 1; print \*(Aq.\*(Aq },
\&        );
\&        print " done!\en";
\&
\&        print "Entering PrivExec on all hosts ";
\&        bulkDo(\e%cli, \*(Aqenable\*(Aq);
\&
\&        print "Entering Config mode on all hosts ";
\&        bulkDo(\e%cli, \*(Aqcmd\*(Aq, [\*(Aqconfig terminal\*(Aq]);
\&
\&        print "Pushing config command on all hosts ";
\&        bulkDo(\e%cli, \*(Aqcmd\*(Aq, [\*(Aqsnmp\-server contact Jack\*(Aq]);
\&
\&        print "Disconnecting from all hosts ";
\&        bulkDo(\e%cli, \*(Aqdisconnect\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Control::CLI::Extreme is a sub-class of Control::CLI allowing \s-1CLI\s0 interaction customized for Extreme (including ex\-Avaya/ex Nortel Enterprise) Networking products over any of Telnet, \s-1SSH\s0 or Serial port. It is a drop in replacement for the Control::CLI::AvayaData module following the transfer of the Avaya Data business unit to Extreme Networks.
This class supports all of Extreme Summit, Virtual Services Platform (\s-1VSP\s0), Private Label Switches (\s-1APLS DSG\s0 BoxTypes), Ethernet Routing Switch (\s-1ERS\s0) and ex-Nortel Enterprise (Bay Networks heritage) platforms. Currently supported devices:
.IP "\(bu" 2
\&\s-1VSP\s0 XA\-1x00, 4x00, 7x00, 8x00, 9000
.IP "\(bu" 2
\&\s-1XOS\s0 Summit switches
.IP "\(bu" 2
\&\s-1ERS\s0 models 2500, 3x00, 4x00, 5x00
.IP "\(bu" 2
Wireless Wing APs and Controllers
.IP "\(bu" 2
\&\s-1SLX\s0 Data Center switches
.IP "\(bu" 2
\&\s-1ISW\s0 industrial switches
.IP "\(bu" 2
Series200 models 210, 220
.IP "\(bu" 2
ERS/Passport models 1600, 8300, 8600, 8800
.IP "\(bu" 2
\&\s-1APLS DSG\s0 models 6248, 7648, 7480, 8032, 9032
.IP "\(bu" 2
\&\s-1SR\s0 models 2330, 4134
.IP "\(bu" 2
\&\s-1WLAN\s0 91xx
.IP "\(bu" 2
\&\s-1WLAN\s0(\s-1WC\s0) 81x0
.IP "\(bu" 2
\&\s-1WLAN\s0(\s-1WSS\s0) 2350, 236x, 238x
.IP "\(bu" 2
\&\s-1BPS 2000, ES 460, ES 470\s0
.IP "\(bu" 2
Baystack models 325, 425
.IP "\(bu" 2
Accelar/Passport models 1000, 1100, 1200
.PP
The devices supported by this module can have an inconsistent \s-1CLI\s0 (in terms of syntax, login sequences, terminal width-length-paging, prompts) and in some cases two separate \s-1CLI\s0 syntaxes are available on the same product.
This class is written so that all the above products can be \s-1CLI\s0 scripted in a consistent way regardless of their underlying \s-1CLI\s0 variants. The \s-1CLI\s0 commands themselves might still vary across the different products though, even here, for certain common functions (like entering privExec mode or disabling terminal more paging) a generic method is provided by this class.
.PP
Control::CLI::Extreme is a sub-class of Control::CLI (which is required) and therefore the above functionality can also be performed in a consistent manner regardless of the underlying connection type which can be any of Telnet, \s-1SSH\s0 or Serial port connection. For \s-1SSH,\s0 only SSHv2 is supported with either password or publickey authentication.
Furthermore this module leverages the non-blocking capaility of Control::CLI version 2.00 and is thus capable of operating in a non-blocking fashion for all its methods so that it can be used to drive multiple Extreme devices simultaneously without resorting to Perl threads (see examples directory).
.PP
Other refinements of this module over and above the basic functionality of Control::CLI are:
.IP "\(bu" 4
On the stackable BaystackERS products the connect & login methods will automatically steer through the banner and menu interface (if seen) to reach the desired \s-1CLI\s0 interface.
.IP "\(bu" 4
There is no need to set the prompt string in any of this module's methods since it knows exactly what to expect from any of the supported Extreme products. Furthermore the prompt string is automatically internally set to match the actual prompt of the connected device (rather than using a generic regular expression such as '*[#>]$'). This greatly reduces the risk that the generic regular expression might trigger on a fake prompt embedded in the output stream from the device.
.IP "\(bu" 4
The connect method of this module automatically takes care of login for Telnet and Serial port access (where authentication is not part of the actual connection, unlike \s-1SSH\s0) and so provides a consistent scripting approach whether the underlying connection is \s-1SSH\s0 or either Telnet or Serial port.
.IP "\(bu" 4
Automatic handling of output paged with \-\-more\*(-- prompts, including the ability to retrieve an exact number of pages of output.
.IP "\(bu" 4
A number of attributes are made available to find out basic information about the connected Extreme device.
.IP "\(bu" 4
Ability to detect whether a \s-1CLI\s0 command generated an error on the remote host and ability to report success or failure of the issued command as well as the error message details.
.PP
Note that all the extra functionality that this module offers over and above Control::CLI, is only possible if connected to an Extreme (or ex Avaya/Nortel) device. To make sure that the connected device is supported, the family_type attribute can be inspected to make sure it is not set to 'generic'; see \fBattribute()\fR.
.PP
In the syntax layout below, square brackets \fB[]\fR represent optional parameters.
All Control::CLI::Extreme method arguments are case insensitive.
.SH "OBJECT CONSTRUCTOR"
.IX Header "OBJECT CONSTRUCTOR"
Used to create an object instance of Control::CLI::Extreme
.IP "\fB\fBnew()\fB\fR \- create a new Control::CLI::Extreme object" 4
.IX Item "new() - create a new Control::CLI::Extreme object"
.Vb 1
\&  $obj = new Control::CLI::Extreme (\*(AqTELNET\*(Aq|\*(AqSSH\*(Aq|\*(Aq<COM_port_name>\*(Aq);
\&
\&  $obj = new Control::CLI::Extreme (
\&
\&        # same as in Control::CLI :
\&        Use                      => \*(AqTELNET\*(Aq|\*(AqSSH\*(Aq|\*(Aq<COM_port_name>\*(Aq,
\&        [Timeout                 => $secs,]
\&        [Connection_timeout      => $secs,]
\&        [Errmode                 => $errmode,]
\&        [Errmsg_format           => $msgFormat,]
\&        [Return_reference        => $flag,]
\&        [Prompt                  => $prompt,]
\&        [Username_prompt         => $usernamePrompt,]
\&        [Password_prompt         => $passwordPrompt,]
\&        [Input_log               => $fhOrFilename,]
\&        [Output_log              => $fhOrFilename,]
\&        [Dump_log                => $fhOrFilename,]
\&        [Blocking                => $flag,]
\&        [Prompt_credentials      => $flag,]
\&        [Read_attempts           => $numberOfReadAttemps,]
\&        [Readwait_timer          => $millisecs,]
\&        [Data_with_error         => $flag,]
\&        [Read_block_size         => $bytes,]
\&        [Output_record_separator => $ors,]
\&        [Terminal_type           => $string,]
\&        [Window_size             => [$width, $height],]
\&        [Report_query_status     => $flag,]
\&        [Debug                   => $debugFlag,]
\&
\&        # added in Control::CLI::Extreme :
\&        [Return_result           => $flag,]
\&        [More_paging             => $numberOfPages,]
\&        [Cmd_confirm_prompt      => $string,]
\&        [Cmd_initiated_prompt    => $string,]
\&        [Cmd_feed_timeout        => $value,]
\&        [Console                 => $string,]
\&        [Wake_console            => $string,]
\&        [Debug_file              => $fhOrFilename,]
\&  );
.Ve
.Sp
This is the constructor for Control::CLI::Extreme objects. A new object is returned on success. On failure the error mode action defined by \*(L"errmode\*(R" argument is performed. If the \*(L"errmode\*(R" argument is not specified the default is to croak. See \fBerrmode()\fR for a description of valid settings.
The first parameter, or \*(L"use\*(R" argument, is required and should take value either \*(L"\s-1TELNET\*(R"\s0 or \*(L"\s-1SSH\*(R"\s0 (case insensitive) or the name of the Serial port such as \*(L"\s-1COM1\*(R"\s0 or \*(L"/dev/ttyS0\*(R". The other arguments are optional and are just shortcuts to methods of the same name.
The Control::CLI::Extreme constructor accpets all arguments supported by the Control::CLI constructor (which are passed to it) and defines some new arguments specific to itself.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
Methods which can be run on a previously created Control::CLI::Extreme instance
.SS "Main I/O Object Methods"
.IX Subsection "Main I/O Object Methods"
.IP "\fB\fBconnect()\fB & \fBconnect_poll()\fB\fR \- connect to host" 4
.IX Item "connect() & connect_poll() - connect to host"
.Vb 1
\&  $ok = $obj\->connect("$host[ $port]");
\&
\&  ($ok, $output || $outputRef) = $obj\->connect("$host[ $port]");
\&
\&  $ok = $obj\->connect(
\&        [Host                   => $host,]
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [PublicKey              => $publicKey,]
\&        [PrivateKey             => $privateKey,]
\&        [Passphrase             => $passphrase,]
\&        [Prompt_credentials     => $flag,]
\&        [BaudRate               => $baudRate,]
\&        [ForceBaud              => $flag,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Timeout                => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Callback               => \e&codeRef,]
\&        [Atomic_connect         => $flag,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
\&
\&  ($ok, $output || $outputRef) = $obj\->connect(
\&        [Host                   => $host,]
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [PublicKey              => $publicKey,]
\&        [PrivateKey             => $privateKey,]
\&        [Passphrase             => $passphrase,]
\&        [Prompt_credentials     => $flag,]
\&        [BaudRate               => $baudRate,]
\&        [ForceBaud              => $flag,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Timeout                => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Return_reference       => $flag,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Callback               => \e&codeRef,]
\&        [Atomic_connect         => $flag,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->connect_poll();
\&
\&  ($ok, $output || $outputRef) = $obj\->connect_poll();
.Ve
.Sp
This method connects to the host device. The connection will use either Telnet, \s-1SSH\s0 or Serial port, depending on how the object was created with the \fBnew()\fR constructor.
On success a true (1) value is returned. On time-out or other connection failures the error mode action is performed. See \fBerrmode()\fR.
In the first & third forms only a success/failure value is returned in scalar context, while in the second & fourth forms, in list context, both the success/failure value is returned as well as any output received from the host device during the connect/login sequence; the latter is either the output itself or a reference to that output, depending on the object setting of return_reference or the argument override provided in this method.
.Sp
This method overrides \fBControl::CLI::connect()\fR and calls both the \fBControl::CLI::connect()\fR method as well as the \fBlogin()\fR method from this class. This allows the \fBconnect()\fR method to seamlessly handle connection and login for both \s-1SSH\s0 (which normally handles authentication as part of the connection process) and Telnet and Serial port access (for which authentication needs to be dealt with after connection). In short, by calling the \fBconnect()\fR method it is not necessary to call the \fBlogin()\fR method afterwards.
.Sp
In non-blocking mode (blocking disabled) the \fBconnect()\fR method will immediately return with a false, but defined, value of 0. You will then need to call the \fBconnect_poll()\fR method at regular intervals until it returns a true (1) value indicating that the connection and login is complete. Note that for this method to work (with \s-1TELNET\s0 or \s-1SSH\s0) in non-blocking mode IO::Socket::IP needs to be installed (IO::Socket:INET will always produce a blocking \s-1TCP\s0 socket setup).
.Sp
The \*(L"host\*(R" argument is required by both Telnet and \s-1SSH.\s0 All the other arguments are optional.
If username/password or \s-1SSH\s0 Passphrase are not provided but are required and prompt_credentials is true, the method will automatically prompt the user for them; otherwise the error mode action is performed. The \*(L"errmode\*(R" argument is provided to override the global setting of the object error mode action. See \fBerrmode()\fR.
The \*(L"prompt_credentials\*(R" argument is provided to override the global setting of the parameter by the same name which is by default false. See \fBprompt_credentials()\fR.
The \*(L"read_attempts\*(R" argument is simply fed to the \fBlogin()\fR method. See \fBlogin()\fR.
The \*(L"connection_timeout\*(R" argument can be used to set a connection timeout when establishing Telnet and \s-1SSH TCP\s0 connections; this is fed to \fBControl::CLI::connect()\fR. Whereas the \*(L"timeout\*(R" argument is the normal timeout used for reading the connection once established; this is fed to \fBlogin()\fR.
The \*(L"terminal_type\*(R" and \*(L"window_size\*(R" arguments are Control::CLI arguments and are not overrides, they will change the object parameter as these settings are only applied during a connection. It is not necessary to set these for Extreme devices.
Which other arguments are used depends on the whether the object was created for Telnet, \s-1SSH\s0 or Serial port.
.RS 4
.IP "\(bu" 4
For Telnet, these arguments are used:
.Sp
.Vb 1
\&  $ok = $obj\->connect("$host[ $port]");
\&
\&  $ok = $obj\->connect(
\&        Host                    => $host,
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Atomic_connect         => $flag,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
If not specified, the default port number for Telnet is 23. The wake_console argument is only relevant when connecting to a Telnet port other than 23 (i.e. to a Terminal Server device) or if \fBconsole()\fR has been manually set; see \fBconsole()\fR. In which case, the \fBlogin()\fR method, which is called by \fBconnect()\fR, will automatically send the wake_console string sequence to the attached device to alert it of the connection. The default sequence will work across all Extreme Networking products but can be overridden by using the wake_console argument. See \fBwake_console()\fR.
Another reason to use the wake_console is when connecting via Telnet to an \s-1XOS\s0 switch which is configured with a 'before\-login' banner which has to be acknowledged. In this case the \s-1XOS\s0 switch will not request a login until the user has hit a key. In this case make sure to set the Console argument to 1 in the object constructor (the default wake_console string '\en' will then be sent and there is no need to specify a different wake_console string in the \fBconnect()\fR method).
.IP "\(bu" 4
For \s-1SSH,\s0 these arguments are used:
.Sp
.Vb 1
\&  $ok = $obj\->connect("$host[ $port]");
\&
\&  $ok = $obj\->connect(
\&        Host                    => $host,
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [PublicKey              => $publicKey,]
\&        [PrivateKey             => $privateKey,]
\&        [Passphrase             => $passphrase,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Callback               => \e&codeRef,]
\&        [Atomic_connect         => $flag,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
If not specified, the default port number for \s-1SSH\s0 is 22. The wake_console argument is only relevant when connecting to a \s-1SSH\s0 port other than 22 (i.e. to a Terminal Server device) or if \fBconsole()\fR has been manually set; see \fBconsole()\fR. In which case, the \fBlogin()\fR method, which is called by \fBconnect()\fR, will automatically send the wake_console string sequence to the attached device to alert it of the connection. The default sequence will work across all Extreme Networking products but can be overridden by using the wake_console argument. See \fBwake_console()\fR.
.Sp
A username must always be provided for all \s-1SSH\s0 connections. If not provided and prompt_credentials is true then this method will prompt for it.
Once the \s-1SSH\s0 conection is established, this method will attempt one of two possible authentication types, based on the accepted authentications of the remote host:
.RS 4
.IP "\(bu" 4
\&\fBPublickey authentication\fR : If the remote host accepts it and the method was supplied with public/private keys. The public/private keys need to be in OpenSSH format. If the private key is protected by a passphrase then this must also be provided or, if prompt_credentials is true, this method will prompt for the passphrase. If publickey authentication fails for any reason and password authentication is possible, then password authentication is attempted next; otherwise the error mode action is performed. See \fBerrmode()\fR.
.IP "\(bu" 4
\&\fBPassword authentication\fR : If the remote host accepts either 'password' or 'keyboard\-interactive' authentication methods. A password must be provided or, if prompt_credentials is true, this method will prompt for the password. If password authentication fails for any reason the error mode action is performed. See \fBerrmode()\fR. \s-1VOSS VSP\s0 hosts can be configured for either 'password' or 'keyboard\-interactive' authentication. Use of either of these \s-1SSH\s0 authentication methods (which both ultimately provide username & password credentials to the \s-1SSH\s0 server) remains completely transparent to the code using this class.
.RE
.RS 4
.RE
.IP "\(bu" 4
For Serial port, these arguments are used:
.Sp
.Vb 10
\&  $ok = $obj\->connect(
\&        [BaudRate               => $baudRate,]
\&        [ForceBaud              => $flag,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
If arguments \*(L"baudrate\*(R", \*(L"parity\*(R", \*(L"databits\*(R", \*(L"stopbits\*(R" and \*(L"handshake\*(R" are not specified, the defaults are: Baud Rate = 9600, Data Bits = 8, Parity = none, Stop Bits = 1, Handshake = none. These default values will work on all Extreme Networking products with default settings.
Allowed values for these arguments are the same allowed by \fBControl::CLI::connect()\fR.
.Sp
On Windows systems the underlying Win32::SerialPort module can have issues with some serial ports, and fail to set the desired baudrate (see bug report https://rt.cpan.org/Ticket/Display.html?id=120068); if hitting that problem (and no official Win32::SerialPort fix is yet available) set the ForceBaud argument; this will force Win32::SerialPort into setting the desired baudrate even if it does not think the serial port supports it.
.Sp
For a serial connection, this method \- or to be precise the \fBlogin()\fR method which is called by \fBconnect()\fR \- will automatically send the wake_console string sequence to the attached device to alert it of the connection. The default sequence will work across all Extreme Networking products but can be overridden by using the wake_console argument.
.RE
.RS 4
.Sp
If using the \fBconnect()\fR method in non-blocking mode, the following example illustrates how this works:
.Sp
.Vb 2
\&        $ok = $obj\->connect(Host => $ip\-address, Blocking => 0);
\&        until ($ok) { # This loop will be executed while $ok = 0
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->connect_poll;
\&        }
.Ve
.Sp
Or, if you have set an error mode action of 'return':
.Sp
.Vb 3
\&        $ok = $obj\->connect(Host => $ip\-address, Blocking => 0, Errmode => \*(Aqreturn\*(Aq);
\&        die $obj\->errmsg unless defined $ok;    # Error connecting
\&        until ($ok) { # This loop will be executed while $ok = 0
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->connect_poll;
\&                die $obj\->errmsg unless defined $ok;    # Error or timeout connecting
\&        }
.Ve
.RE
.IP "\fB\fBlogin()\fB & \fBlogin_poll()\fB\fR \- handle login for Telnet / Serial port; also set the host \s-1CLI\s0 prompt" 4
.IX Item "login() & login_poll() - handle login for Telnet / Serial port; also set the host CLI prompt"
.Vb 10
\&  $ok = $obj\->login(
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
\&
\&  ($ok, $output || $outputRef) = $obj\->login(
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Blocking               => $flag,]
\&        [Errmode                => $errmode,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->login_poll();
\&
\&  ($ok, $output || $outputRef) = $obj\->login_poll();
.Ve
.Sp
This method handles login authentication for Telnet and Serial port access (also for \s-1SSH\s0 access in the case of the \s-1WLAN2300 WSS\s0 controllers, since they use no \s-1SSH\s0 authentication but instead use an interactive login once the \s-1SSH\s0 connection is established). For all connection types (including \s-1SSH\s0) it also performs all the necessary steps to get to a \s-1CLI\s0 prompt; for instance on the Baystack / Stackable \s-1ERS\s0 platforms it will skip the Banner and/or Menu interface. Over a serial port connection or a ssh or telnet connection over a port other than default 22 or 23 respectively (indicating a Terminal Server connection) or if \fBconsole()\fR was manually set, it will automatically generate a wake_console sequence to wake up the attached device into producing either a login banner or \s-1CLI\s0 prompt. This sequence can be overridden by using the wake_console argument; setting this argument to the empty string will disable the wake_console sequence. Likewise use of \fBconsole()\fR can be used to control, force or disable the wake_console sequence; see \fBwake_console()\fR and \fBconsole()\fR.
.Sp
On success the method returns a true (1) value. On failure the error mode action is performed. See \fBerrmode()\fR.
In non-blocking mode (blocking disabled) the \fBlogin()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBlogin_poll()\fR method at regular intervals until it returns a true (1) value indicating that the login is complete.
In the first form only a success/failure value is returned in scalar context, while in the second form, in list context, both the success/failure value is returned as well as any output received from the host device during the login sequence; the latter is either the output itself or a reference to that output, depending on the object setting of return_reference or the argument override provided in this method.
This method internally uses the \fBreadwait()\fR method and by default sets the read_attemps for it to 10 (which is a safe value to ensure proper connection to any Extreme Networking device); the read_attempts argument provided by \fBlogin()\fR can be used to override that value. The non_recognized_login argument flag controls whether the method should immediately return when an initial login output sequence is not recognized or whether the method should keep trying to read login output until either a recognized login prompt is detected or expiry of the timeout. The generic_login argument flag disables extended discovery if it is desired to connect to non Extreme devices using this class.
.Sp
Once a valid Extreme Networking \s-1CLI\s0 prompt is detected (using pre-configured pattern match strings), this method records the actual \s-1CLI\s0 prompt of the host device for the remainder of the session by automatically invoking the \fBprompt()\fR method with a new pattern match string based on the actual device \s-1CLI\s0 prompt. This ensures a more robust behaviour where the chances of triggering on a fake prompt embedded in the device output data is greatly reduced.
At the same time this method will also set the \-\-more\*(-- prompt used by the device when paging output as well as a number of attributes depending on what family_type was detected for the host device. See \fBattribute()\fR.
.Sp
Note that this method is automatically invoked by the \fBconnect()\fR method and therefore should seldom need to be invoked by itself. A possible reason to invoke this method on its own could be if initially connecting to, say, an \s-1ERS8800\s0 device and from there initiating a telnet/ssh connection onto a Stackable device (i.e. telnet/ssh hopping); since we are connecting to a new device the \fBlogin()\fR method must be invoked to set the new prompts accordingly as well as re-setting all the device attributes. An example follows:
.Sp
.Vb 10
\&        # Initial connection could use Telnet or SSH, depending on how object was constructed
\&        # Connect to 1st device, e.g. via out\-of\-band mgmt
\&        $cli\->connect(
\&                Host            => \*(Aq<ERS8800 IP address>\*(Aq,
\&                Username        => \*(Aqrwa\*(Aq,
\&                Password        => \*(Aqrwa\*(Aq,
\&        );
\&        # From there connect to another device, perhaps on inband mgmt
\&        # NOTE: use print() not cmd() as there is no prompt coming back, but the login screen of the stackable
\&        $cli\->print("telnet <Stackable IP address>");
\&        # Call login() to authenticate, detect the device, reset appropriate attributes 
\&        $cli\->login(
\&                Username        => \*(AqRW\*(Aq,
\&                Password        => \*(AqRW\*(Aq,
\&        );
\&        # Execute commands on target stackable device
\&        $output = $cli\->cmd("show running\-config");
\&        print $output;
\&        [...]
\&        # If you want to return to the first device..
\&        # NOTE: use print() not cmd() as the next prompt will be from the ERS8800, not the stackable anymore
\&        $cli\->print("logout");
\&        # Call login() to detect the device and reset appropriate attributes (no authentication needed though)
\&        $cli\->login;
\&        # Now we are back on the 1st device
\&        $output = $cli\->cmd("show sys info");
\&        print $output;
\&        [...]
.Ve
.Sp
If using the \fBlogin()\fR method in non-blocking mode, the following examples illustrate how this works:
.RS 4
.IP "\(bu" 4
If you do not care to retrieve the login sequence output:
.Sp
.Vb 2
\&        $ok = $obj\->login(Username => "admin", Password => "pwd", Blocking => 0);
\&        until ($ok) { # This loop will be executed while $ok = 0
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->login_poll;
\&        }
.Ve
.IP "\(bu" 4
If you want to retrieve the login output sequence along the way (even in case of error/timeout):
.Sp
.Vb 3
\&        ($ok, $output) = $obj\->login(Username => "admin", Password => "pwd", Blocking => 0, Errmode => \*(Aqreturn\*(Aq);
\&        die $obj\->errmsg unless defined $ok;    # Login failed
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                ($ok, $partialOutput) = $obj\->login_poll;
\&                die $obj\->errmsg unless defined $ok;    # Login failed or timeout
\&                $output .= $partialOutput;
\&        }
\&        print "Complete login sequence output:\en", $output;
.Ve
.IP "\(bu" 4
If you only want to retrieve the full login sequence output at the end:
.Sp
.Vb 2
\&        $ok = $obj\->login(Username => "admin", Password => "pwd", Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->login_poll;
\&        }
\&        print "Complete login sequence output:\en", ($obj\->login_poll)[1];
.Ve
.RE
.RS 4
.RE
.IP "\fB\fBcmd()\fB & \fBcmd_poll()\fB\fR \- Sends a \s-1CLI\s0 command to host and returns result or output" 4
.IX Item "cmd() & cmd_poll() - Sends a CLI command to host and returns result or output"
Backward compatible syntax:
.Sp
.Vb 1
\&  $result || $output || $outputRef = $obj\->cmd($cliCommand);
\&
\&  $result || $output || $outputRef = $obj\->cmd(
\&        [Command                => $cliCommand,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_confirm_prompt     => $ynPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
New syntax (for non-blocking use):
.Sp
.Vb 10
\&  $ok = $obj\->cmd(
\&        Poll_syntax             => 1,
\&        [Command                => $cliCommand,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_confirm_prompt     => $ynPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $result || $output || $outputRef) = $obj\->cmd($cliCommand);
\&
\&  ($ok, $result || $output || $outputRef) = $obj\->cmd(
\&        [Poll_syntax            => 1,]
\&        [Command                => $cliCommand,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_confirm_prompt     => $ynPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->cmd_poll();
\&
\&  ($ok, $result || $output || $outputRef) = $obj\->cmd_poll();
.Ve
.Sp
This method sends a \s-1CLI\s0 command to the host and returns once a new \s-1CLI\s0 prompt is received from the host. The output record separator \- which is by default \*(L"\er\*(R" in this class; see \fBoutput_record_separator()\fR \- is automatically appended to the command string. If no command string is provided then this method will simply send the output record separator and expect a new prompt back.
Before sending the command to the host, any pending input data from host is read and flushed.
The \s-1CLI\s0 prompt expected by the \fBcmd()\fR method is either the object prompt previously set by any of \fBconnect()\fR, \fBlogin()\fR or \fBprompt()\fR; or it is the override prompt specified by the optional prompt method argument. If the reset_prompt flag is activated then the prompt match pattern is automatically reset using the same initial pattern match used by \fBconnect()\fR & \fBlogin()\fR to match the prompt for the first time; this is useful when executing a \s-1CLI\s0 command which will cause the \s-1CLI\s0 prompt to change (such as changing the switch name). If the reset_prompt flag is set any prompt supplied via the argument will be ignored.
.Sp
For backwards compatibility, in scalar context, the output data from the command is returned.
The new syntax, in scalar context returns the poll status, while in list context, both the poll status together with the output data are returned. Note that to disambiguate the new scalar context syntax the 'poll_syntax' argument needs to be set (while this is not strictly necessary in list context).
In non-blocking mode, the poll status will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBcmd_poll()\fR method at regular intervals until it returns a true (1) value indicating that the command has completed.
.Sp
When this method is retrieving the output of the command and the output is generated over multiple pages of output, each page paused with a \-\-more\*(-- prompt, the \fBcmd()\fR method will retrieve as many pages as defined globally by \fBmore_paging()\fR. If the optional \*(L"more_pages\*(R" argument is specified then this value will override the global setting of \fBmore_paging()\fR. Either way, if a value of 0 is specified, space characters are automatically fed to obtain all output until the next \s-1CLI\s0 prompt is received. Note that for best script performance it is recommended to disable more paging on the host device using the appropriate \s-1CLI\s0 command or the \fBdevice_more_paging()\fR method. The optional 'more_prompt' argument can be used to override the object more_prompt string though this should seldom be necessary as the correct more prompt string is automatically set by \fBconnect()\fR & \fBlogin()\fR. See \fBmore_prompt()\fR.
.Sp
If the command produces a Y/N confirmation prompt as certain Extreme Networking device \s-1CLI\s0 commands do (for example \*(L"boot\*(R" or \*(L"reset\*(R") this method will automatically detect the confirmation prompt and feed a 'y' to it as you would expect when scripting the device. If, for some reason, you wanted to feed a 'n' then refer to \fBcmd_prompted()\fR method instead. The optional 'cmd_confirm_prompt' argument can be used to override the object match string defined for this; see also \fBcmd_confirm_prompt()\fR.
.Sp
This method will either return the result of the command or the output. If return_result is set for the object, or it is set via the override \*(L"return_result\*(R" argument provided in this method, then only the result of the command is returned. In this case a true (1) value is returned if the command was executed without generating any error messages on the host device. While a false (0) value is returned if the command generated some error messages on the host device. The error message can be obtained via the \fBlast_cmd_errmsg()\fR method. See \fBlast_cmd_errmsg()\fR and \fBlast_cmd_success()\fR. This mode of operation is useful when sending configuration commands to the host device.
.Sp
If instead return_result is not set then this method will return either a hard reference to the output generated by the \s-1CLI\s0 command or the output itself. This will depend on the setting of return_reference; see \fBreturn_reference()\fR; the global setting of return_reference can also be overridden using the method argument by the same name.
Passing a refence to the output makes for much faster/efficient code, particularly if the output generated is large (for instance output of \*(L"show running-config\*(R").
The echoed command is automatically stripped from the output as well as the terminating \s-1CLI\s0 prompt (the last prompt received from the host device can be obtained with the \fBlast_prompt()\fR method).
This mode of operation is useful when sending show commands which retrieve information from the host device.
Note that in this mode (return_result not set), sending a config command will result in either a null string or a reference pointing to a null string being returned, unless that command generated some error message on the host device. In this case the return_result mode should be used instead.
.Sp
The progress_dots argument is provided as an override of the object method of the same name for the duration of this method; see \fBprogress_dots()\fR.
.Sp
On I/O failure to the host device, the error mode action is performed. See \fBerrmode()\fR.
If, after expiry of the configured timeout \- see \fBtimeout()\fR \-, output is no longer received from host and no valid \s-1CLI\s0 prompt has been seen, the method will send an additional carriage return character and automatically fall back on the initial generic prompt for a further 10% of the configured timeout. If even that prompt is not seen after this further timeout then the error mode action is performed. See \fBerrmode()\fR.
So even if the \s-1CLI\s0 prompt is changed by the issued command (e.g. changing the system-name or quitting the debug shell) this method should be able to recover since it will automatically revert to the initial generic prompt, but this will happen after expiry of the configured timeout. In this case, to avoid waiting expiry of timeout, set the reset_prompt argument. Here is an example showing how to revert to the normal \s-1CLI\s0 prompt when quitting the shell:
.Sp
.Vb 9
\&        $obj\->cmd(\*(Aqpriv\*(Aq);
\&        # Before entering the shell we need to set the prompt to match the shell prompt
\&        $obj\->prompt(\*(Aq\-> $\*(Aq);
\&        # Now enter the shell
\&        $obj\->cmd(\*(Aqshell\*(Aq);
\&        $obj\->cmd(\*(AqspyReport\*(Aq);
\&        [...other shell cmds issued here...]
\&        # When done, logout from shell, and revert to standard CLI prompt
\&        $obj\->cmd(Command => \*(Aqlogout\*(Aq, Reset_prompt => 1);
.Ve
.Sp
Alternatively, since accessing the shell now requires a priv & shell password, if you only need to execute a few shell commands you can assume that the shell prompt is a prompt belonging to the shell command and use \fBcmd_prompted()\fR instead; the following example does the same thing as the previous example but does not need to change the prompt:
.Sp
.Vb 12
\&        # Enter the shell and execute shell commands all in one go
\&        $obj\->cmd_prompted(
\&                        Command                 => \*(Aqpriv\*(Aq,
\&                        Feed                    => $privPassword,
\&        );
\&        $obj\->cmd_prompted(
\&                        Command                 => \*(Aqshell\*(Aq,
\&                        Cmd_initiated_prompt    => \*(Aq(:|\->) $\*(Aq,
\&                        Feed                    => $shellPassword,
\&                        Feed                    => \*(AqspyReport\*(Aq,
\&                        Feed                    => \*(Aqlogout\*(Aq,
\&        );
.Ve
.Sp
If the issued command returns no prompt (e.g. logout), consider using \fBprint()\fR instead of \fBcmd()\fR or, if logging out, simply use the \fBdisconnect()\fR method.
.Sp
If the issued command produces a Y/N confirmation prompt but does not return a regular prompt (e.g. reset, boot) there are two possible approaches. On some Extreme Networking devices (e.g. PassportERS family_type) you can append '\-y' to the command being sent to suppress the Y/N confirmation prompt, in which case you can simply do:
.Sp
.Vb 3
\&        $cli\->print(\*(Aqreset \-y\*(Aq);
\&        sleep 1; # Do not disconnect before switch has time to process last command...
\&        $cli\->disconnect;
.Ve
.Sp
However, other Extreme Networking devices do not accept a '\-y' appended to the reset/boot commands (e.g. BaystackERS family_type); on these devices use this sequence:
.Sp
.Vb 5
\&        $cli\->print(\*(Aqreset\*(Aq);
\&        $cli\->waitfor($cli\->cmd_confirm_prompt);
\&        $cli\->print(\*(Aqy\*(Aq);
\&        sleep 1; # Do not disconnect before switch has time to process last command...
\&        $cli\->disconnect;
.Ve
.Sp
In non-blocking mode (blocking disabled) the \fBcmd()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBcmd_poll()\fR method at regular intervals until it returns a true (1) value indicating that the command is complete. The following example illustrates:
.RS 4
.IP "\(bu" 4
If you do not care to retrieve any output from the command:
.Sp
.Vb 2
\&        $ok = $obj\->cmd(Poll_syntax => 1, Command => "set command", Blocking => 0);
\&        until ($ok) { # This loop will be executed while $ok = 0
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->cmd_poll;
\&        }
.Ve
.IP "\(bu" 4
If you want to retrieve the command output sequence along the way:
.Sp
.Vb 3
\&        ($ok, $output) = $obj\->cmd(Command => "show command", Blocking => 0, Errmode => \*(Aqreturn\*(Aq);
\&        die $obj\->errmsg unless defined $ok;    # Login failed
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                ($ok, $partialOutput) = $obj\->cmd_poll;
\&                die $obj\->errmsg unless defined $ok;    # Login failed or timeout
\&                $output .= $partialOutput;
\&        }
\&        print "Complete command output:\en", $output;
.Ve
.IP "\(bu" 4
If you only want to retrieve the command output at the end:
.Sp
.Vb 2
\&        $ok = $obj\->cmd(Poll_syntax => 1, Command => "show command", Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->cmd_poll;
\&        }
\&        print "Complete command output:\en", ($obj\->cmd_poll)[1];
.Ve
.RE
.RS 4
.RE
.IP "\fB\fBcmd_prompted()\fB\fR \- Sends a \s-1CLI\s0 command to host, feeds additional requested data and returns result or output" 4
.IX Item "cmd_prompted() - Sends a CLI command to host, feeds additional requested data and returns result or output"
Backward compatible syntax:
.Sp
.Vb 1
\&  $result || $output || $outputRef = $obj\->cmd_prompted($cliCommand, @feedData);
\&
\&  $result || $output || $outputRef = $obj\->cmd_prompted(
\&        [Command                => $cliCommand,]
\&        [Feed                   => $feedData1,
\&         [Feed                  => $feedData2,
\&          [Feed                 => $feedData3,
\&            ... ]]]
\&        [Feed_list              => \e@arrayRef,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_initiated_prompt   => $cmdPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
New syntax (for non-blocking use):
.Sp
.Vb 10
\&  $ok = $obj\->cmd_prompted(
\&        Poll_syntax             => 1,
\&        [Command                => $cliCommand,]
\&        [Feed                   => $feedData1,
\&         [Feed                  => $feedData2,
\&          [Feed                 => $feedData3,
\&            ... ]]]
\&        [Feed_list              => \e@arrayRef,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_initiated_prompt   => $cmdPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $result || $output || $outputRef) = $obj\->cmd_prompted(
\&        [Poll_syntax            => 1,]
\&        [Command                => $cliCommand,]
\&        [Feed                   => $feedData1,
\&         [Feed                  => $feedData2,
\&          [Feed                 => $feedData3,
\&            ... ]]]
\&        [Feed_list              => \e@arrayRef,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_initiated_prompt   => $cmdPrompt,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Return_reference       => $flag,]
\&        [Return_result          => $flag,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->cmd_poll();
\&
\&  ($ok, $result || $output || $outputRef) = $obj\->cmd_poll();
.Ve
.Sp
This method is identical to \fBcmd()\fR except that it will not automaticaly feed a 'y' to Y/N confirmation prompts but in a more general manner will detect any prompts generated by the issued \s-1CLI\s0 command (whether these are Y/N confirmation prompts or simply prompts for additional information the \s-1CLI\s0 command requires) and will feed whatever data has been provided to the method. In the first form of the backward compatible syntax, data can be provided as an array while in all other cases data is provided either as any number of \*(L"feed\*(R" arguments or via a \*(L"feed_list\*(R" array reference. In fact both \*(L"feed\*(R" and \*(L"feed_list\*(R" arguments can be provided, multiple times, in which case the data is chained in the same order in which it was provided to the method.
Note that to disambiguate the new syntaxes, then either the \*(L"command\*(R" or \*(L"poll_syntax\*(R" arguments must be the first argument supplied, otherwise the first form of the backward compatible syntax is expected.
.Sp
The prompt used to detect \s-1CLI\s0 command prompts can be set via the \fBcmd_initiated_prompt()\fR or via the override method argument by te same name.
An example using \fBcmd_prompted()\fR is shown in the \fBcmd()\fR section above.
.IP "\fB\fBattribute()\fB & \fBattribute_poll()\fB\fR \- Return device attribute value" 4
.IX Item "attribute() & attribute_poll() - Return device attribute value"
Backward compatible syntax:
.Sp
.Vb 1
\&  $value = $obj\->attribute($attribute);
\&
\&  $value = $obj\->attribute(
\&        Attribute               => $attribute,
\&        [Reload                 => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
New syntax (for non-blocking use):
.Sp
.Vb 8
\&  $ok = $obj\->attribute(
\&        Poll_syntax             => 1,
\&        Attribute               => $attribute,
\&        [Reload                 => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $value) = $obj\->attribute($attribute);
\&
\&  ($ok, $value) = $obj\->attribute(
\&        [Poll_syntax            => 1,]
\&        Attribute               => $attribute,
\&        [Reload                 => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->attribute_poll();
\&
\&  ($ok, $value) = $obj\->attribute_poll();
.Ve
.Sp
When connecting to an Extreme Networking device a certain number of attributes are automatically recorded if the information is readily available and does not require additional \s-1CLI\s0 commands.
The \fBattribute()\fR method allows to retrieve the value of such attributes.
If the attribute is already set, then the method simply returns its value.
If on the other hand the requested attribute is not yet set, then in this case the method will issue the necessary \s-1CLI\s0 command to find the relevant information to set the attribute (or multiple attributes since in some cases a \s-1CLI\s0 command yields information for multiple attributes) and will then return its value. Any subsequent lookup for the same attribute name will no longer need to issue \s-1CLI\s0 commands.
If the \*(L"reload\*(R" flag is true, then even if the attribute was already set the method will verify the setting on the connected device by re-issuing the necessary commands.
In case of any \s-1IO\s0 failures while issuing \s-1CLI\s0 commands the error mode action is performed.
.Sp
Once a connection is established (including login) the \fIfamily_type\fR attribute is always set.
As long as it is set to a valid Extreme Networking product type, then all other global attributes are available as well as all the relevant attributes for the family type specified (a full list of available attributes is returned by specifying attribute \fIall\fR). Attributes for other product families different from the current value of \fIfamily_type\fR will be undefined.
If the \fIfamily_type\fR attribute is not yet set or is set to \fBgeneric\fR then all other attributes, including the other Global ones, will be undefined.
.Sp
Valid attributes and their possible values follow.
.Sp
Global attributes which apply to any product family type:
.RS 4
.IP "\(bu" 4
\&\fIfamily_type\fR:
.RS 4
.IP "\(bu" 4
\&\fBExtremeXOS\fR : ExtremeXOS Summit switch
.IP "\(bu" 4
\&\fBBaystackERS\fR : Any of Baystack, \s-1BPS, ES,\s0 Stackable \s-1ERS\s0 (\s-1ERS\-2500,\s0 ERS\-3x00, ERS\-4x00, ERS\-5x00), Stackable \s-1VSP\s0 (\s-1VSP\-7000\s0), \s-1WLAN8100\s0
.IP "\(bu" 4
\&\fBPassportERS\fR : Any of Passport/ERS\-1600, Passport/ERS\-8x00, \s-1VOSS\s0 VSPs (\s-1VSP\-9000, VSP\-8000, VSP\-7200, VSP\-4000\s0), \s-1APLS DSG\s0 BoxTypes
.IP "\(bu" 4
\&\fB\s-1ISW\s0\fR : \s-1ISW\s0 industrial switches
.IP "\(bu" 4
\&\fBWing\fR : Wireless Wing APs and Controllers
.IP "\(bu" 4
\&\fBSeries200\fR : Series200 switches
.IP "\(bu" 4
\&\fB\s-1SLX\s0\fR : \s-1SLX\s0 Data Center switches
.IP "\(bu" 4
\&\fB\s-1WLAN9100\s0\fR : \s-1WLAN\s0 91xx Access Points
.IP "\(bu" 4
\&\fBSecureRouter\fR : Any of the Secure Router 2330 & 4134 series
.IP "\(bu" 4
\&\fB\s-1WLAN2300\s0\fR : \s-1WLAN WSS2300\s0 Controllers
.IP "\(bu" 4
\&\fBAccelar\fR : Any of the old Accelar 1000, 1100, 1200
.IP "\(bu" 4
\&\fBgeneric\fR : Not an Extreme Networking product; equivalent functionality to Control::CLI
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fImodel\fR: Device model e.g. X460G2\-24t\-10G4, \s-1VSP\-8284\-XSQ, ERS\-4526\-GTX\-PWR\s0; The model naming will usually be in the format <VSP|ERS|ES|WC>\-<number>\-<type>\-<subtype>. This attribute will remain undefined if connected to the Standby \s-1CPU\s0 of a PassportERS device. Typical \s-1ISW\s0 formatting is \s-1ISW_8\-10/100P_4\-SFP\s0 or ISW_4GbP_2GbT_2\-SFP.
.IP "\(bu" 4
\&\fIsysname\fR: System name of the device. This attribute will remain undefined if connected to the Standby \s-1CPU\s0 of a PassportERS device.
.IP "\(bu" 4
\&\fIbase_mac\fR: Base \s-1MAC\s0 address of the device in string format xx-xx-xx-xx-xx-xx. This is the base \s-1MAC\s0 address from which all other device MACs (\s-1VLAN,\s0 Port, etc) are derived. This attribute is useful for maintaining a unique reference for the device. This attribute will remain undefined if connected to the Standby \s-1CPU\s0 of a PassportERS device.
.IP "\(bu" 4
\&\fIis_acli\fR: Flag; \fBtrue\fR\|(1) for Cisco like acli mode which has PrivExec & Config modes; \fBfalse\fR\|(0) otherwise.
So for family types \fBBaystackERS\fR, \fBSecureRouter\fR, \fB\s-1WLAN2300\s0\fR, \fB\s-1WLAN9100\s0\fR, \fB\s-1ISW\s0\fR, \fBWing\fR, \fBSeries200\fR, \fB\s-1SLX\s0\fR and \fBPassportERS\fR (the latter in acli mode) this flag is true.
Whereas for family types \fBExtremeXOS\fR, \fBAccelar\fR, \fBgeneric\fR and \fBPassportERS\fR (the latter in cli mode) this flag is false.
.IP "\(bu" 4
\&\fIis_nncli\fR: Flag; alias for above \fIis_acli\fR attribute as nncli is historically how this \s-1CLI\s0 mode was called in Nortel days
.IP "\(bu" 4
\&\fIsw_version\fR: Run time software version
.IP "\(bu" 4
\&\fIfw_version\fR: BootROM / Boot Monitor / Firmware / Linux verson, if applicable, undef otherwise
.IP "\(bu" 4
\&\fIslots\fR: Returns a list (array reference) of all valid slot numbers (or unit numbers in a stack) or interface types (in the case of \s-1ISW\s0 there are FastEthernet & GigabitEtherne interfaces); returns an empty list if the device ports have no slot number associated (e.g. a BaystackERS or ExtremeXOS switch in non\-stacking/standalone mode) and undefined if no slot/port information could be retrieved from the device, e.g. if connected to the Standby \s-1CPU\s0 of a PassportERS device
.IP "\(bu" 4
\&\fIports\fR: If the \fIslots\fR attribute is defined, this attribute returns an array (slots are numbers) or hash (slots are names; in the case of \s-1ISW,\s0 names 'FastEthernet' and 'GigabitEthernet') reference where the index/key is the slot number (valid slot/key numbers are provided by the \fIslots\fR attribute) and the array/hash elements are a list (array references) of valid ports for that particular slot. Note that for 40GbE/100GbE channelized ports the 10GbE/25GbE sub interfaces will be listed in port/subport fashion in this list; e.g. channelized ports 1/2/1\-1/2/4 will be seen as ports 2/1,2/2,2/3,2/4 on the port list for slot 1.
If the \fIslots\fR attribute is defined but empty (i.e. there is no slot number associated to available ports \- e.g. a BaystackERS switch in standalone mode), this attribute returns a list (array reference) of valid port numbers for the device. (The test script for this class \- extreme.cli.t \- has an attribute method that shows how to decode the slot & port attributes).
.IP "\(bu" 4
\&\fIbaudrate\fR: Console port configured baudrate. This attribute only works with devices where the baudrate is configurable or shown by the system (i.e. only PassportERS and BaystackERS devices with the exceptions of \s-1ERS\-4000\s0 units and standby \s-1CPU\s0 of a \s-1VSP9000/VSP8600\s0). On these devices this attribute will return a defined value. On other devices where the baudrate is not configurable or not shown, an undef value is returned, and in this case it is safe to assume that the valid baudrate is 9600 (with the exception of ExtremeXOS X690 or X870 series switches where it is 115200)
.IP "\(bu" 4
\&\fImax_baud\fR: Maximum configurable value of baudrate on device's console port. This attribute only works with devices where the baudrate is configurable (i.e. only PassportERS and BaystackERS devices with the exceptions of \s-1ERS\-4000\s0 units andStandby \s-1CPU\s0 of a \s-1VSP9000\s0). On these devices this attribute will return a defined value. On other devices where the baudrate is not configurable an undef value is returned, and in this case it is safe to assume that the only valid baudrate is the one returned by the \fIbaudrate\fR attribute.
.RE
.RS 4
.Sp
Attributes which only apply to \fBPassportERS\fR family type:
.IP "\(bu" 4
\&\fIis_voss\fR: Flag; \fBtrue\fR\|(1) if the device is a PassportERS \s-1VSP\s0 model (only \fImodel\fR VSP-xxxx) or is an Extreme Product Label Switch (\s-1APLS\s0) (\fIis_apls\fR is true); \fBfalse\fR\|(0) otherwise.
.IP "\(bu" 4
\&\fIis_apls\fR: Flag; \fBtrue\fR\|(1) if an Extreme Product Label Switch (\s-1APLS\s0); \fBfalse\fR\|(0) otherwise.
.IP "\(bu" 4
\&\fIapls_box_type\fR: Box Type of an Extreme Product Label Switch (\s-1APLS\s0); only set if \fIis_apls\fR is true, undefined otherwise.
.IP "\(bu" 4
\&\fIbrand_name\fR: Brand Name of an Extreme Product Label Switch (\s-1APLS\s0) or a \s-1VOSS VSP\s0; only set if \fIis_voss\fR is true, undefined otherwise.
.IP "\(bu" 4
\&\fIis_master_cpu\fR: Flag; \fBtrue\fR\|(1) if connected to a Master \s-1CPU\s0; \fBfalse\fR\|(0) otherwise
.IP "\(bu" 4
\&\fIis_dual_cpu\fR: Flag; \fBtrue\fR\|(1) if 2 CPUs are present in the chassis; \fBfalse\fR\|(0) otherwise
.IP "\(bu" 4
\&\fIcpu_slot\fR: Slot number of the \s-1CPU\s0 we are connected to
.IP "\(bu" 4
\&\fIis_ha\fR: Flag; \fBtrue\fR\|(1) if HA-mode is enabled; \fBfalse\fR\|(0) otherwise; undef if not applicable
.IP "\(bu" 4
\&\fIstp_mode\fR: Spanning tree operational mode; possible values: \fBstpg\fR (802.1D), \fBrstp\fR (802.1W), \fBmstp\fR (802.1S)
.IP "\(bu" 4
\&\fIoob_ip\fR: Out-of-band \s-1IP\s0 address of Master \s-1CPU\s0 (this attribute is only set when connected to the Master \s-1CPU\s0)
.IP "\(bu" 4
\&\fIoob_virt_ip\fR: Out-of-band Virtual \s-1IP\s0 address (this attribute is only set when connected to the Master \s-1CPU\s0)
.IP "\(bu" 4
\&\fIoob_standby_ip\fR: Out-of-band \s-1IP\s0 address of Standby \s-1CPU\s0 (this attribute is only set when connected to the Master \s-1CPU\s0)
.IP "\(bu" 4
\&\fIis_oob_connected\fR: Flag; \fBtrue\fR\|(1) if the connection to the device is to either the oob_ip or oob_virt_ip \s-1IP\s0 address; \fBfalse\fR\|(0) otherwise (this attribute is only set when connected to the Master \s-1CPU\s0; it will be undefined if connected to a Standby \s-1CPU\s0)
.RE
.RS 4
.Sp
Attributes which only apply to \fBBaystackERS\fR family type:
.IP "\(bu" 4
\&\fIunit_number\fR: Unit number we are connected to (Generaly the base unit, except when connecting via Serial) if a stack; undef otherwise
.IP "\(bu" 4
\&\fIbase_unit\fR: Base unit number, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIswitch_mode\fR:
.RS 4
.IP "\(bu" 4
\&\fBSwitch\fR : Standalone switch
.IP "\(bu" 4
\&\fBStack\fR : Stack of switches
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIstack_size\fR: Number of units in the stack, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIstp_mode\fR: Spanning tree operational mode; possible values: \fBstpg\fR (802.1D), \fBrstp\fR (802.1W), \fBmstp\fR (802.1S)
.IP "\(bu" 4
\&\fImgmt_vlan\fR: In-band management \s-1VLAN\s0 number
.IP "\(bu" 4
\&\fImgmt_ip\fR: In-band management \s-1IP\s0 address
.IP "\(bu" 4
\&\fIoob_ip\fR: Out-of-band \s-1IP\s0 address (only defined on devices which have an \s-1OOB\s0 port and have an \s-1IP\s0 address configured on it)
.IP "\(bu" 4
\&\fIis_oob_connected\fR: Flag; \fBtrue\fR\|(1) if the connection to the device is to the oob_ip \s-1IP\s0 address; \fBfalse\fR\|(0) otherwise
.RE
.RS 4
.Sp
Attributes which only apply to \fBExtremeXOS\fR family type:
.IP "\(bu" 4
\&\fIis_xos\fR: Flag; \fBtrue\fR\|(1) if the device is an ExtremeXOS switch; \fBfalse\fR\|(0) otherwise.
.IP "\(bu" 4
\&\fIunit_number\fR: Unit number we are connected to (Generaly the master unit, except when connecting via Serial) if a stack; undef otherwise
.IP "\(bu" 4
\&\fImaster_unit\fR: Master unit number, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIswitch_mode\fR:
.RS 4
.IP "\(bu" 4
\&\fBSwitch\fR : Standalone switch
.IP "\(bu" 4
\&\fBStack\fR : Stack of switches
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIstack_size\fR: Number of units in the stack, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIstp_mode\fR: Spanning tree operational mode; possible values: \fBstpg\fR (802.1D), \fBrstp\fR (802.1W), \fBmstp\fR (802.1S)
.IP "\(bu" 4
\&\fIoob_ip\fR: Out-of-band \s-1IP\s0 address (only defined on devices which have an \s-1OOB\s0 port and have an \s-1IP\s0 address configured on it)
.IP "\(bu" 4
\&\fIis_oob_connected\fR: Flag; \fBtrue\fR\|(1) if the connection to the device is to the oob_ip \s-1IP\s0 address; \fBfalse\fR\|(0) otherwise
.RE
.RS 4
.Sp
Attributes which only apply to \fB\s-1ISW\s0\fR family type:
.IP "\(bu" 4
\&\fIis_isw\fR: Flag; \fBtrue\fR\|(1) if the device is an \s-1ISW\s0 industrial switch; \fBfalse\fR\|(0) otherwise.
.RE
.RS 4
.Sp
Attributes which only apply to \fBWing\fR family type:
.IP "\(bu" 4
\&\fIis_wing\fR: Flag; \fBtrue\fR\|(1) if the device is a Wing \s-1AP\s0 or Controller; \fBfalse\fR\|(0) otherwise.
.RE
.RS 4
.Sp
Attributes which only apply to \fBSeries200\fR family type:
.IP "\(bu" 4
\&\fIunit_number\fR: Unit number we are connected to (always the stack manager unit) if a stack; undef otherwise
.IP "\(bu" 4
\&\fImanager_unit\fR: Stack Manager unit number, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIswitch_mode\fR:
.RS 4
.IP "\(bu" 4
\&\fBSwitch\fR : Standalone switch
.IP "\(bu" 4
\&\fBStack\fR : Stack of switches
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fIstack_size\fR: Number of units in the stack, if a stack; undef otherwise
.IP "\(bu" 4
\&\fIstp_mode\fR: Spanning tree operational mode; possible values: \fBstpg\fR (802.1D), \fBrstp\fR (802.1W), \fBmstp\fR (802.1S), \fBpvst\fR, \fBrpvst\fR
.IP "\(bu" 4
\&\fIoob_ip\fR: Out-of-band \s-1IP\s0 address (only defined on devices which have an \s-1OOB\s0 port and have an \s-1IP\s0 address configured on it)
.IP "\(bu" 4
\&\fIis_oob_connected\fR: Flag; \fBtrue\fR\|(1) if the connection to the device is to the oob_ip \s-1IP\s0 address; \fBfalse\fR\|(0) otherwise
.RE
.RS 4
.Sp
Attributes which only apply to \fB\s-1SLX\s0\fR family type:
.IP "\(bu" 4
\&\fIis_slx\fR: Flag; \fBtrue\fR\|(1) if the device is an \s-1SLX\s0 switch.
.IP "\(bu" 4
\&\fIis_slx_r\fR: Flag; \fBtrue\fR\|(1) if the device is an SLX-R switch.
.IP "\(bu" 4
\&\fIis_slx_s\fR: Flag; \fBtrue\fR\|(1) if the device is an SLX-S switch.
.IP "\(bu" 4
\&\fIis_slx_x\fR: Flag; \fBtrue\fR\|(1) if the device is an SLX-X switch.
.IP "\(bu" 4
\&\fIswitch_type\fR: Holds the numerical switch type of the \s-1SLX\s0 switch
.IP "\(bu" 4
\&\fIis_active_mm\fR: Flag; \fBtrue\fR\|(1) if connected to the Active Manager Module (\s-1MM\s0); currently always true on \s-1SLX9850\s0 chassis
.IP "\(bu" 4
\&\fIis_dual_mm\fR: Flag; \fBtrue\fR\|(1) if 2 Manager Module (\s-1MM\s0) are present in the \s-1SLX9850\s0 chassis; \fBfalse\fR\|(0) otherwise
.IP "\(bu" 4
\&\fImm_number\fR: Slot number of the Manager Module (\s-1MM\s0) we are connected to; 0 on non\-9850 \s-1SLX\s0
.IP "\(bu" 4
\&\fIis_ha\fR: Flag; \fBtrue\fR\|(1) if HA-mode is enabled; \fBfalse\fR\|(0) otherwise; undef if not applicable
.IP "\(bu" 4
\&\fIstp_mode\fR: Spanning tree operational mode; possible values: \fBstpg\fR (802.1D), \fBrstp\fR (802.1W), \fBmstp\fR (802.1S), \fBpvst\fR, \fBrpvst\fR
.IP "\(bu" 4
\&\fIoob_ip\fR: Out-of-band \s-1IP\s0 address of Active Manager Module (\s-1MM\s0)
.IP "\(bu" 4
\&\fIoob_virt_ip\fR: Out-of-band Chassis Virtual \s-1IP\s0 address
.IP "\(bu" 4
\&\fIoob_standby_ip\fR: Out-of-band \s-1IP\s0 address of Standby Manager Module (\s-1MM\s0)
.IP "\(bu" 4
\&\fIis_oob_connected\fR: Flag; \fBtrue\fR\|(1) if the connection to the device is to either the oob_ip or oob_virt_ip \s-1IP\s0 address; \fBfalse\fR\|(0) otherwise
.RE
.RS 4
.Sp
Attributes which only apply to \fBAccelar\fR family type:
.IP "\(bu" 4
\&\fIis_master_cpu\fR: Flag; \fBtrue\fR\|(1) if connected to a Master \s-1CPU\s0; \fBfalse\fR\|(0) otherwise
.IP "\(bu" 4
\&\fIis_dual_cpu\fR: Flag; \fBtrue\fR\|(1) if 2 CPUs are present in the chassis; \fBfalse\fR\|(0) otherwise
.RE
.RS 4
.Sp
All available attributes on a given connection
.IP "\(bu" 4
\&\fIall\fR: Retuns a list (array reference) of all valid attributes for the current connection; this will include all Global attributes as well as all attributes corresponding to the family type specified by \fIfamily_type\fR. This is useful for iterating through all available attributes in a foreach loop.
.RE
.RS 4
.Sp
In non-blocking mode (blocking disabled), if the attribute requested is not already set and thus \s-1CLI\s0 commands need to be sent to the connected device, the \fBattribute()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBattribute_poll()\fR method at regular intervals until it returns a true (1) value indicating that the command is complete. The following example illustrates:
.Sp
.Vb 2
\&        ($ok, $value) = $obj\->attribute(Attribute => $attribute, Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                ($ok, $value) = $obj\->attribute_poll;
\&        }
\&        print "Attribute $attribute value = ", $value, "\en" if defined $value;
\&        print "Attribute $attribute undefined\en" unless defined $value;
.Ve
.RE
.IP "\fB\fBchange_baudrate()\fB & \fBchange_baudrate_poll()\fB\fR \- Change baud rate on current serial connection" 4
.IX Item "change_baudrate() & change_baudrate_poll() - Change baud rate on current serial connection"
Changing only local serial port:
.Sp
.Vb 10
\&  $ok = $obj\->change_baudrate(
\&        Local_side_only         => 1,
\&        [BaudRate               => $baudRate,]
\&        [ForceBaud              => $flag,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Changing host and serial port together (backward compatible syntax):
.Sp
.Vb 1
\&  $baudrate = $obj\->change_baudrate($baudrate);
\&
\&  $baudrate = $obj\->change_baudrate(
\&        BaudRate                => $baudrate,
\&        [ForceBaud              => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Changing host and serial port together (new syntax for non-blocking use):
.Sp
.Vb 8
\&  $ok = $obj\->change_baudrate(
\&        Poll_syntax             => 1,
\&        BaudRate                => $baudrate,
\&        [ForceBaud              => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $baudrate) = $obj\->change_baudrate($baudrate);
\&
\&  ($ok, $baudrate) = $obj\->change_baudrate(
\&        [Poll_syntax            => 1,]
\&        BaudRate                => $baudrate,
\&        [ForceBaud              => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Polling method (only applicable in non-blocking mode):
.Sp
.Vb 1
\&  $ok = $obj\->change_baudrate_poll();
\&
\&  ($ok, $baudrate) = $obj\->change_baudrate_poll();
.Ve
.Sp
This method is only applicable to an already established Serial port connection and will return an error if the connection type is Telnet or \s-1SSH\s0 or if the object type is for Serial but no connection is yet established.
.Sp
If the 'local_side_only' argument is set this method will simply call the Control::CLI method by the same name which will simply change the baudrate (and/or parity, databits, stopbits, handshake) of the current serial connection without trying to also change the baudrate on the device we are connected to. This is equivalent to simply calling \fBSUPER::change_baudrate()\fR.
.Sp
Without the 'local_side_only' argument set, this method combines the knowledge of the Extreme device type we are connected to by automatically changing the baudrate configuration on the attached device before actually changing the baudrate of the connection. Thus if the attribute family_type is not yet defined or is set to 'generic' then an error will be returned. From this point onwards, the behaviour of this method upon failure will depend on whether a specific baudrate was provided or whether the desired baudrate was specified as 'max'. In the former case any failure to set the requested baudrate will trigger the error mode action whereas in the latter case it is assumed that the desire is to try and maximise the connection baudrate if possible but that we do not want to generate an error if that is not possible.
.Sp
The ability to change the baudrate configuration on the attached device is currently only available when the attribute family_type is either BaystackERS or PassportERS. For any other family_type (including 'generic', SecureRouter & \s-1WLAN2300\s0) this method will simply return success in 'max' mode and the error mode action otherwise (there is no way to change the baudrate configuration on SecureRouter & \s-1WLAN2300\s0 devices to a value other than 9600 baud; there is no knowledge on how to do so on 'generic' devices). Even on some BaystackERS or PassportERS devices it is not possible to change the baudrate (e.g. ERS\-4x00, Passport\-1600, Passport\-8300 and some \s-1APLS\s0 switches) and again this method will simply return success in 'max' mode and the error mode action otherwise.
.Sp
When changing the baudrate of the local connection this method calls \fBControl::CLI::change_baudrate()\fR which will restart the object serial connection with the new baudrate (in the background, the serial connection is actually disconnected and then re-connected) without losing the current \s-1CLI\s0 session.
If there is a problem restarting the serial port connection at the new baudrate then the error mode action is performed (now also in 'max' mode) \- see \fBerrmode()\fR.
If the baudrate was successfully changed the value of the new baudrate (a true value) is returned.
The advantage of using this method to increase the baudrate to a higher value than 9600 is that when retrieving commands which generate a large amount of output, this can be read in a lot faster if the baudrate is increased.
.Sp
Remember to restore the baudrate configuration of the attached device to default 9600 when done or anyone connecting to its serial port thereafter will have to guess the baudrate! To minimize the chance of this happening the disconnect & destroy methods for this class will automatically try to restore whatever baudrate was used when initially connecting to the device.
.Sp
Supported baudrates for this method are:
.RS 4
.IP "\(bu" 4
\&\fBBaystackERS\fR: 9600, 19200, 38400 or 'max' (where 'max' = 38400)
.IP "\(bu" 4
\&\fBPassportERS\fR: 9600, 19200, 38400, 57600, 115200 or 'max' (where 'max' = 115200)
.RE
.RS 4
.Sp
Follows an example:
.Sp
.Vb 10
\&        use Control::CLI;
\&        # Create the object instance for Serial port
\&        $cli = new Control::CLI(\*(AqCOM1\*(Aq);
\&        # Connect to switch
\&        $cli\->connect(
\&                        Baudrate        => 9600,
\&                        Username        => $username,
\&                        Password        => $password,
\&                );
\&        # Get the config
\&        $output = $cli\->cmd(
\&                        Command         => "show running\-config",
\&                        Progress_dots   => 100,
\&                );
\&        # Increase the baudrate
\&        $maxBaudrate = $cli\->change_baudrate(\*(Aqmax\*(Aq);
\&        print "Baudrate increased to $maxBaudrate" if $maxBaudrate;
\&        # Get the config a 2nd time (4 times faster on BaystackERS; 12 times faster PassportERS)
\&        $output = $cli\->cmd(
\&                        Command         => "show running\-config",
\&                        Progress_dots   => 100,
\&                );
\&        # Restore the baudrate
\&        $cli\->change_baudrate(9600);
\&        # Disconnect
\&        $cli\->disconnect;
.Ve
.Sp
In non-blocking mode (blocking disabled), the \fBchange_baudrate()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBchange_baudrate_poll()\fR method at regular intervals until it returns a true (1) value indicating that the change is complete. The following example illustrates:
.Sp
.Vb 2
\&        ($ok, $baudrate) = $obj\->change_baudrate(BaudRate => $baudrate, Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                ($ok, $baudrate) = $obj\->change_baudrate_poll;
\&        }
\&        print "New baudrate = ", $baudrate, "\en";
.Ve
.RE
.IP "\fB\fBenable()\fB & \fBenable_poll()\fB\fR \- Enter PrivExec mode" 4
.IX Item "enable() & enable_poll() - Enter PrivExec mode"
.Vb 1
\&  $ok = $obj\->enable($enablePassword);
\&
\&  $ok = $obj\->enable(
\&        [Password               => $enablePassword,]
\&        [Prompt_credentials     => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  $ok = $obj\->enable_poll();    # Only applicable in non\-blocking mode
.Ve
.Sp
This method checks whether the 'is_acli' attribute is set and, if so, whether the last prompt ends with '>'; if both conditions are true, it will flush any unread pending input from the device and will just send an 'enable' command to enter Priviledge Executive mode. If either of the above conditions are not met then this method will simply return a true (1) value.
The method can take a password argument which only applies to the \s-1WLAN2300\s0 series and in some older software versions of the \s-1ERS\-8300\s0 in \s-1NNCLI\s0 mode.
If a password is required, but not supplied, this method will try supplying first a blank password, then the same password which was used to connect/login and finally, if prompt_credentials is true for the object, prompt for it. On I/O failure, the error mode action is performed. See \fBerrmode()\fR.
The optional \*(L"prompt_credentials\*(R" argument is provided to override the global setting of the parameter by the same name which is by default false. See \fBprompt_credentials()\fR.
.Sp
In non-blocking mode (blocking disabled), the \fBenable()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBenable_poll()\fR method at regular intervals until it returns a true (1) value indicating that the change is complete. The following example illustrates:
.Sp
.Vb 2
\&        $ok = $obj\->enable(Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->enable_poll;
\&        }
.Ve
.IP "\fB\fBdevice_more_paging()\fB & \fBdevice_more_paging_poll()\fB\fR \- Enable/Disable more paging on host device" 4
.IX Item "device_more_paging() & device_more_paging_poll() - Enable/Disable more paging on host device"
.Vb 1
\&  $ok = $obj\->device_more_paging($flag);
\&
\&  $ok = $obj\->device_more_paging(
\&        Enable                  => $flag,
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  $ok = $obj\->device_more_paging_poll();        # Only applicable in non\-blocking mode
.Ve
.Sp
This method issues the necessary \s-1CLI\s0 commands to turn on/off \-\-more\*(-- paging on the connected device. It relies on the setting of family_type attribute \- see \fBattribute()\fR \- to send the appropriate commands.
If an error occurs while sending the necessary \s-1CLI\s0 commands, then the error mode action is performed. See \fBerrmode()\fR.
Returns a true value (1) on success.
.Sp
In non-blocking mode (blocking disabled), the \fBdevice_more_paging()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBdevice_more_paging_poll()\fR method at regular intervals until it returns a true (1) value indicating that the change is complete. The following example illustrates:
.Sp
.Vb 2
\&        $ok = $obj\->device_more_paging(Enable => 0, Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->device_more_paging_poll;
\&        }
.Ve
.IP "\fB\fBdevice_peer_cpu()\fB & \fBdevice_peer_cpu_poll()\fB\fR \- Connect to peer \s-1CPU\s0 on ERS8x00 / \s-1VSP9000\s0" 4
.IX Item "device_peer_cpu() & device_peer_cpu_poll() - Connect to peer CPU on ERS8x00 / VSP9000"
.Vb 8
\&  $ok = $obj\->device_peer_cpu(
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Blocking               => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  $ok = $obj\->device_peer_cpu_poll();   # Only applicable in non\-blocking mode
.Ve
.Sp
This method, only applicable on ERS8x00 and \s-1VSP9000,\s0 will try to connect to the peer \s-1CPU.\s0 On success a true (1) value is returned otherwise the error mode action is performed. See \fBerrmode()\fR.
It should not normally be necessary to provide username/password since the credentials used to connect to the current \s-1CPU\s0 will automatically be used. If not so, or to override the cached ones, optional \*(L"username\*(R" & \*(L"password\*(R" arguments can be provided.
Attributes 'cpu_slot' and 'is_master_cpu' are automatically updated once the connection to the peer \s-1CPU\s0 succeeds. See \fBattribute()\fR.
.Sp
In non-blocking mode (blocking disabled), the \fBdevice_peer_cpu()\fR method will most likely immediately return with a false, but defined, value of 0. You will then need to call the \fBdevice_peer_cpu_poll()\fR method at regular intervals until it returns a true (1) value indicating that the change is complete. The following example illustrates:
.Sp
.Vb 2
\&        $ok = $obj\->device_peer_cpu(Blocking => 0);
\&        until ($ok) {
\&                
\&                <do other stuff here..>
\&        
\&                $ok = $obj\->device_peer_cpu_poll;
\&        }
.Ve
.SS "Methods to set/read Object variables"
.IX Subsection "Methods to set/read Object variables"
.IP "\fBflush_credentials\fR \- flush the stored username, password, passphrase and enable password credentials" 4
.IX Item "flush_credentials - flush the stored username, password, passphrase and enable password credentials"
.Vb 1
\&  $obj\->flush_credentials;
.Ve
.Sp
The \fBconnect()\fR, \fBlogin()\fR and \fBenable()\fR methods, if successful in authenticating, will automatically store the username/password/enable\-password or \s-1SSH\s0 passphrase supplied to them.
These can be retrieved via the username, password, passphrase and enable_password methods. If you do not want these to persist in memory once the authentication has completed, use this method to flush them. This method always returns 1.
.IP "\fB\fBprompt()\fB\fR \- set the \s-1CLI\s0 prompt match pattern for this object" 4
.IX Item "prompt() - set the CLI prompt match pattern for this object"
.Vb 1
\&  $string = $obj\->prompt;
\&
\&  $prev = $obj\->prompt($string);
.Ve
.Sp
This method sets the \s-1CLI\s0 prompt match patterns for this object. In the first form the current pattern match string is returned. In the second form a new pattern match string is set and the previous setting returned.
If no prompt has yet been set (connection not yet established) undef is returned.
The object \s-1CLI\s0 prompt pattern is automatically set by the \fBconnect()\fR, \fBlogin()\fR and cmd(reset_prompt => 1) methods and normally does not need to be set manually unless the \s-1CLI\s0 prompt is expected to change.
Once set, the object \s-1CLI\s0 prompt match pattern is only used by the \fBcmd()\fR and \fBcmd_prompted()\fR methods.
.IP "\fB\fBmore_prompt()\fB\fR \- set the \s-1CLI\s0 \-\-More\*(-- prompt match pattern for this object" 4
.IX Item "more_prompt() - set the CLI --More prompt match pattern for this object"
.Vb 1
\&  $string = $obj\->more_prompt;
\&
\&  $prev = $obj\->more_prompt($string [, $delayPrompt]);
.Ve
.Sp
This method sets the \s-1CLI\s0 \-\-More\*(-- prompt match patterns for this object. In the first form the current pattern match string is returned. In the second form a new pattern match string is set and the previous setting returned (the \f(CW$delayPrompt\fR can be set as a subset of \f(CW$string\fR if \f(CW$string\fR accepts multiple patterns some of which are subsets of others).
If no prompt has yet been set (connection not yet established) undef is returned.
The object's \s-1CLI\s0 \-\-More\*(-- prompt pattern is automatically set by the \fBconnect()\fR and \fBlogin()\fR methods based upon the device type detected during login. Normally there should be no need to set this manually.
Once set, the object \s-1CLI\s0 \-\-More\*(-- prompt match patterns is only used by the \fBcmd()\fR and \fBcmd_prompted()\fR methods.
.IP "\fB\fBmore_paging()\fB\fR \- sets the number of pages to read when device output is paged by \-\-more\*(-- prompts" 4
.IX Item "more_paging() - sets the number of pages to read when device output is paged by --more prompts"
.Vb 1
\&  $numberOfPages = $obj\->more_paging;
\&
\&  $prev = $obj\->more_paging($numberOfPages);
.Ve
.Sp
When issuing \s-1CLI\s0 commands, using \fBcmd()\fR or \fBcmd_prompted()\fR, which generate large amount of output, the host device will automatically page the output with \-\-more\*(-- prompts where the user can either view the next page, by sending a Space character, or terminate the \s-1CLI\s0 command, by sending a q character.
This method sets the number of pages of output that both \fBcmd()\fR and \fBcmd_prompted()\fR will retrieve before sending a q character and thus terminating the \s-1CLI\s0 command. Hence if more_paging is set to 1, only one page of output will be collected and a q character will be sent to the first \-\-more\*(-- prompt received. if more_paging is set to 2, two pages of output will be collected and a q character will be sent to the second \-\-more\*(-- prompt received.
By default more_paging is set to 0, which means that the entire output of any issued command will be retrieved, by always feeding Space characters to every \-\-more\*(-- prompt encountered.
Note however that for best performance, if the entire output of a command is required, it is best to disable \-\-more\*(-- paging direcly on the host device rather than letting \fBcmd()\fR or \fBcmd_prompted()\fR feed a Space to every \-\-more\*(-- prompt encountered; see \fBdevice_more_paging()\fR.
This setting can also be overridden directly in \fBcmd()\fR or \fBcmd_prompted()\fR using the 'more_pages' argument.
In the first form the current setting of more_paging is returned; in the second form a more_paging setting is configured and the previous setting returned.
.IP "\fB\fBprogress_dots()\fB\fR \- configure activity dots for \fBcmd()\fR and \fBcmd_prompted()\fR methods" 4
.IX Item "progress_dots() - configure activity dots for cmd() and cmd_prompted() methods"
.Vb 1
\&  $prevBytesPerDot = $obj\->progress_dots($bytesPerDot);
.Ve
.Sp
With this method it is possible to enable \fBcmd()\fR \- and \fBcmd_prompted()\fR \- to print activity dots (....) as input data is read from the host device. This is useful if the command sent to the host device returns large amount of data (e.g. \*(L"show tech\*(R") and/or it takes a long time for the host device to complete the command and return a \s-1CLI\s0 prompt.
To enable the functionality set \f(CW$bytesPerDot\fR to a non zero value; this value will represent every how many bytes of input data read an activity dot will be printed. For example set a value of 1000.
To disable the functionality simply configure it with a zero value.
By default this functionality is disabled.
.IP "\fB\fBreturn_result()\fB\fR \- set whether cmd methods should return output or the success/failure of the command" 4
.IX Item "return_result() - set whether cmd methods should return output or the success/failure of the command"
.Vb 1
\&  $flag = $obj\->return_result;
\&
\&  $prev = $obj\->return_result($flag);
.Ve
.Sp
This method gets or sets the setting for return_result for the object.
This applies to the \fBcmd()\fR and \fBcmd_prompted()\fR methods and determines whether these methods should return the success or failure of the issued command (i.e. a true/false value) or instead the output generated by the command. By default return_result is false (0) and the output of the command is returned.
.IP "\fB\fBlast_cmd_success()\fB\fR \- Returns the result of the last command sent via a cmd method" 4
.IX Item "last_cmd_success() - Returns the result of the last command sent via a cmd method"
.Vb 1
\&  $result = $obj\->last_cmd_success;
\&
\&  $prev = $obj\->last_cmd_success($result);
.Ve
.Sp
This method returns the outcome (true or false) of the last command sent to the host via any of the \fBcmd()\fR or \fBcmd_prompted()\fR methods. If the command generated no error messages on the host, then the command was successful and the result is true (1). If instead an error message was generated by the host, then the command is deemed unsuccesful and the result is false (0). The second form allows the outcome to be manually set.
Note that the same information can be directly obtained from the above mentioned cmd methods by simply enabling the 'return_result' object parameter, or method argument.
Note also that this functionality is only available if the host is detected as an Extreme Networking product, i.e. the \fIfamily_type\fR attribute is set to a value other than \fBgeneric\fR \- see \fBattribute()\fR. If the \fIfamily_type\fR attribute is set to \fBgeneric\fR then this method will always return undef.
.IP "\fB\fBlast_cmd_errmsg()\fB\fR \- returns the last command error message received from connected host" 4
.IX Item "last_cmd_errmsg() - returns the last command error message received from connected host"
.Vb 1
\&  $msg = $obj\->last_cmd_errmsg;
\&
\&  $prev = $obj\->last_cmd_errmsg($msg);
.Ve
.Sp
The first calling sequence returns the cmd error message associated with the object. Undef is returned if no error has been encountered yet. The second calling sequence sets the cmd error message for the object.
If the attached device is detected as an Extreme Networking product, i.e. the \fIfamily_type\fR attribute is set to a value other than \fBgeneric\fR, and a command is issued to the host via \fBcmd()\fR or \fBcmd_prompted()\fR, and this command generates an error on the host, then the last_cmd_success will be set to false and the actual error message will be available via this method. The string returned will include the device prompt + command echoed back by the device (on the first line) and the error message and pointer on subsequent lines. The error message will be held until a new command generates a new error message. In general, only call this method after checking that the \fBlast_cmd_success()\fR method returns a false value.
.IP "\fB\fBcmd_confirm_prompt()\fB\fR \- set the Y/N confirm prompt expected from certain device \s-1CLI\s0 commands" 4
.IX Item "cmd_confirm_prompt() - set the Y/N confirm prompt expected from certain device CLI commands"
.Vb 1
\&  $string = $obj\->cmd_confirm_prompt;
\&
\&  $prev = $obj\->cmd_confirm_prompt($string);
.Ve
.Sp
This method sets the Y/N confirm prompt used by the object instance to match confirmation prompts that Extreme Networking devices will generate on certain \s-1CLI\s0 commands.
The \fBcmd()\fR method will use this patterm match to detect these Y/N confirmation prompts and automatically feed a 'Y' to them so that the command is executed as you would expect when scripting the device \- see \fBcmd()\fR. In the event you want to feed a 'N' instead, refer to \fBcmd_prompted()\fR.
The default prompt match pattern used is:
.Sp
.Vb 1
\&  \*(Aq[\e(\e[] *(?:[yY](?:es)? *(?:[\e\e\e/]|or) *[nN]o?|[nN]o? *(?:[\e\e\e/]|or) *[yY](?:es)?|y \- .+?, n \- .+?, <cr> \- .+?) *[\e)\e]](?: *[?:] *| )$\*(Aq
.Ve
.Sp
The first form of this method allows reading the current setting; the latter will set the new Y/N prompt and return the previous setting.
.IP "\fB\fBcmd_initiated_prompt()\fB\fR \- Set the prompt that certain device \s-1CLI\s0 commands will generate to request additional info" 4
.IX Item "cmd_initiated_prompt() - Set the prompt that certain device CLI commands will generate to request additional info"
.Vb 1
\&  $string = $obj\->cmd_initiated_prompt;
\&
\&  $prev = $obj\->cmd_initiated_prompt($string);
.Ve
.Sp
This method sets the prompt used by the object instance to match the prompt that certain Extreme Networking device \s-1CLI\s0 commands will generate to request additional info.
This is used exclusively by the \fBcmd_prompted()\fR method which is capable to detect these prompts and feed the required information to them. See \fBcmd_prompted()\fR.
The default prompt match pattern used is:
.Sp
.Vb 1
\&  \*(Aq[?:=]\eh*(?:\e(.+?\e)\eh*)?$\*(Aq
.Ve
.Sp
This method can also be used if you wish to feed a 'N' to Y/N prompts, unlike what is automaticaly done by the \fBcmd()\fR method.
The first form of this method allows reading the current setting; the latter will set the new prompt and return the previous setting.
.IP "\fB\fBcmd_feed_timeout()\fB\fR \- Set the number of times we skip command prompts before giving up" 4
.IX Item "cmd_feed_timeout() - Set the number of times we skip command prompts before giving up"
.Vb 1
\&  $value = $obj\->cmd_feed_timeout;
\&
\&  $prev = $obj\->cmd_feed_timeout($value);
.Ve
.Sp
If a \s-1CLI\s0 command is found to generate a prompt for additional data \- i.e. a match was found for string defined by \fBcmd_initiated_prompt()\fR \- and no data was provided to feed to the command (either because of insufficient feed data in \fBcmp_promted()\fR or if using \fBcmd()\fR which cannot supply any feed data) the cmd methods will automatically feed a carriage return to such prompts in the hope of getting to the next \s-1CLI\s0 prompt and return.
If however these command prompts for additional data were indefinite, the cmd methods would never return.
This method sets a limit to the number of times that an empty carriage return is fed to these prompts for more data for which we have no data to feed. When that happens the cmd method will timeout and the error mode action is performed.
The same value will also set an upper limit to how many times a 'y' is fed to Y/N confirm prompts for the same command in the \fBcmd()\fR method. 
The default value is set to 10.
.IP "\fB\fBconsole()\fB\fR \- Enable or Disable object console mode, wich triggers sending the wake_console string on connection/login" 4
.IX Item "console() - Enable or Disable object console mode, wich triggers sending the wake_console string on connection/login"
.Vb 1
\&  $value = $obj\->console;
\&
\&  $prev = $obj\->console($flag);
.Ve
.Sp
When connecting to the serial console port of a device it is necessary to send some characters to trigger the device at the other end to respond. These characters are defined in \fBwake_console()\fR and are automatically sent when the object console mode is true. By default the object console is undefined, and automatically updates itself to true when connecting via Serial, or Telnet (with port other than 23) or \s-1SSH\s0 (with port other than 22). The latter two generally represent connection to some terminal server deivce.
To prevent the object console mode from auto updating following connection, you may set it with this method to a defined false value (0); this will result in wake_console being permanently disabled.
Alternatively, to force wake_console to be sent even on regular Telnet/SSH connections, you may set it with this method to a true value. This approach is needed when connecting via Telnet to an \s-1XOS\s0 switch which is configured with a 'before\-login' banner which has to be acknowledged. In this case the \s-1XOS\s0 switch will not request a login until the user has hit a key; setting this method to 1 (or setting the Console argument to 1 in the object constructor) will ensure that the \s-1XOS\s0 banner is acknowledged and the login will not time-out.
.IP "\fB\fBwake_console()\fB\fR \- Set the character sequence to send to wake up device when connecting to console port" 4
.IX Item "wake_console() - Set the character sequence to send to wake up device when connecting to console port"
.Vb 1
\&  $string = $obj\->wake_console;
\&
\&  $prev = $obj\->wake_console($string);
.Ve
.Sp
When connecting to the serial console port of a device it is necessary to send some characters to trigger the device at the other end to respond. These characters can be defined using this method. By default the wake string is \*(L"\en\*(R". The wake string is sent when the console mode of the connection is true \- see \fBconsole()\fR. By default this happens when connecting via Serial port as well as via Telnet (with port other than 23) or via \s-1SSH\s0 (with port other than 22), i.e. via a Terminal Server device. See  Setting the wake sequence to the empty string, will disable it.
.IP "\fB\fBno_refresh_cmd()\fB\fR \- set pattern and send character to automatically come out of refreshed commands" 4
.IX Item "no_refresh_cmd() - set pattern and send character to automatically come out of refreshed commands"
.Vb 1
\&  $pattern = $obj\->no_refresh_cmd;
\&
\&  $prev = $obj\->no_refresh_cmd($pattern, $sendCharacter);
.Ve
.Sp
Some commands on some devices endlessly refresh the output requested (e.g. commands showing statistics on ExtremeXOS). This is not desireable when scripting the \s-1CLI\s0 using the \fBcmd()\fR methods as these commands would result in \fBcmd()\fR the methods never returning, as output keeps being read indefinitely and no final \s-1CLI\s0 prompt is ever seen.
This method is used to set a pattern to detect the such refreshing commands from their output, as well as a send character to send to the host in order to break out immediately from the refresh cycle. Suitable patterns for ExtremeXOS and PassportERS family types are automatically setup by the \fBconnect()\fR and \fBlogin()\fR methods based upon the device type detected during login.
Normally there should be no need to set this manually. This method can also be used to disable the automatically set pattern, by simply calling the method with \f(CW$pattern\fR set to the empty string.
Once set, these patterns are only used by the \fBcmd()\fR and \fBcmd_prompted()\fR methods.
.IP "\fB\fBdebug()\fB\fR \- set debugging" 4
.IX Item "debug() - set debugging"
.Vb 1
\&  $debugLevel = $obj\->debug;
\&
\&  $prev = $obj\->debug($debugLevel);
.Ve
.Sp
Enables debugging for the object methods and on underlying modules.
In the first form the current debug level is returned; in the second form a debug level is configured and the previous setting returned.
By default debugging is disabled. To disable debugging set the debug level to 0.
The following debug levels are defined:
.RS 4
.IP "\(bu" 4
0 : No debugging
.IP "\(bu" 4
bit 1 : Control::CLI \- Debugging activated for for polling methods + \fBreadwait()\fR and enables carping on Win32/Device::SerialPort. This level also resets Win32/Device::SerialPort constructor \f(CW$quiet\fR flag only when supplied in \fBControl::CLI::new()\fR
.IP "\(bu" 4
bit 2 : Control::CLI \- Debugging is activated on underlying Net::SSH2 and Win32::SerialPort / Device::SerialPort; there is no actual debugging for Net::Telnet
.IP "\(bu" 4
bit 4 : Control::CLI::Extreme \- Basic debugging
.IP "\(bu" 4
bit 8 : Control::CLI::Extreme \- Extended debugging of \fBlogin()\fR & \fBcmd()\fR methods
.RE
.RS 4
.RE
.IP "\fB\fBdebug_file()\fB\fR \- set debug output file" 4
.IX Item "debug_file() - set debug output file"
.Vb 1
\&  $fh = $obj\->debug_file;
\&
\&  $fh = $obj\->debug_file($fh);
\&
\&  $fh = $obj\->debug_file($fileName);
.Ve
.Sp
This method starts or stops logging debug messages to a file.
If no argument is given, the log filehandle is returned. An empty string indicates logging is off. If an open filehandle is given, it is used for logging and returned. Otherwise, the argument is assumed to be the name of a file, the file is opened for logging and a filehandle to it is returned. If the file can't be opened for writing, the error mode action is performed.
To stop logging debug messages to a file, call this method with an empty string as the argument.
Note that if no debug_file is defined all debug messages will be printed to \s-1STDOUT.\s0 To set or stop debugging use the \fBdebug()\fR method.
.SS "Methods to access Object read-only variables"
.IX Subsection "Methods to access Object read-only variables"
.IP "\fBconfig_context\fR \- read configuration context of last prompt" 4
.IX Item "config_context - read configuration context of last prompt"
.Vb 1
\&  $configContext = $obj\->config_context;
.Ve
.Sp
Returns the configuration context included in the last prompt received from the host device.
For example if the last prompt received from the device was 'switch(config\-if)#' this method will return 'config\-if'.
While if the last prompt was in the form 'switch/config/ip#' this method will return '/config/ip'.
If the device was not in config mode at the last prompt, this method returns an empty string ''.
.IP "\fBenable_password\fR \- read enable password provided" 4
.IX Item "enable_password - read enable password provided"
.Vb 1
\&  $enablePassword = $obj\->enable_password;
.Ve
.Sp
Returns the last enable password which was successfully used in the \fBenable()\fR method, or undef otherwise.
Of the supported family types only the \s-1WLAN2300\s0 requires a password to access privExec mode.
.SS "Methods overridden from Control::CLI"
.IX Subsection "Methods overridden from Control::CLI"
.IP "\fB\fBconnect()\fB & \fBconnect_poll()\fB\fR \- connect to host" 4
.IX Item "connect() & connect_poll() - connect to host"
.PD 0
.IP "\fB\fBlogin()\fB & \fBlogin_poll()\fB\fR \- handle login for Telnet / Serial port" 4
.IX Item "login() & login_poll() - handle login for Telnet / Serial port"
.IP "\fB\fBcmd()\fB & \fBcmd_poll()\fB\fR \- Sends a \s-1CLI\s0 command to host and returns output data" 4
.IX Item "cmd() & cmd_poll() - Sends a CLI command to host and returns output data"
.IP "\fB\fBchange_baudrate()\fB\fR \- Change baud rate on current serial connection" 4
.IX Item "change_baudrate() - Change baud rate on current serial connection"
.IP "\fB\fBprompt()\fB\fR \- set the \s-1CLI\s0 prompt match pattern for this object" 4
.IX Item "prompt() - set the CLI prompt match pattern for this object"
.IP "\fB\fBdisconnect()\fB\fR \- disconnect from host" 4
.IX Item "disconnect() - disconnect from host"
.PD
.SS "Methods inherited from Control::CLI"
.IX Subsection "Methods inherited from Control::CLI"
.IP "\fB\fBread()\fB\fR \- read block of data from object" 4
.IX Item "read() - read block of data from object"
.PD 0
.IP "\fB\fBreadwait()\fB\fR \- read in data initially in blocking mode, then perform subsequent non-blocking reads for more" 4
.IX Item "readwait() - read in data initially in blocking mode, then perform subsequent non-blocking reads for more"
.IP "\fB\fBwaitfor()\fB & \fBwaitfor_poll()\fB\fR \- wait for pattern in the input stream" 4
.IX Item "waitfor() & waitfor_poll() - wait for pattern in the input stream"
.IP "\fB\fBput()\fB\fR \- write data to object" 4
.IX Item "put() - write data to object"
.IP "\fB\fBprint()\fB\fR \- write data to object with trailing output_record_separator" 4
.IX Item "print() - write data to object with trailing output_record_separator"
.IP "\fB\fBprintlist()\fB\fR \- write multiple lines to object each with trailing output_record_separator" 4
.IX Item "printlist() - write multiple lines to object each with trailing output_record_separator"
.IP "\fB\fBinput_log()\fB\fR \- log all input sent to host" 4
.IX Item "input_log() - log all input sent to host"
.IP "\fB\fBoutput_log()\fB\fR \- log all output received from host" 4
.IX Item "output_log() - log all output received from host"
.IP "\fB\fBdump_log()\fB\fR \- log hex and ascii for both input and output stream" 4
.IX Item "dump_log() - log hex and ascii for both input and output stream"
.IP "\fBeof\fR \- end-of-file indicator" 4
.IX Item "eof - end-of-file indicator"
.IP "\fBbreak\fR \- send the break signal" 4
.IX Item "break - send the break signal"
.IP "\fBclose\fR \- disconnect from host" 4
.IX Item "close - disconnect from host"
.IP "\fBpoll\fR \- poll object(s) for completion" 4
.IX Item "poll - poll object(s) for completion"
.IP "\fB\fBdebug()\fB\fR \- set debugging" 4
.IX Item "debug() - set debugging"
.PD
.SS "Error Handling Methods inherited from Control::CLI"
.IX Subsection "Error Handling Methods inherited from Control::CLI"
.IP "\fB\fBerrmode()\fB\fR \- define action to be performed on error/timeout" 4
.IX Item "errmode() - define action to be performed on error/timeout"
.PD 0
.IP "\fB\fBerrmsg()\fB\fR \- last generated error message for the object" 4
.IX Item "errmsg() - last generated error message for the object"
.IP "\fB\fBerrmsg_format()\fB\fR \- set the format to be used for object error messages" 4
.IX Item "errmsg_format() - set the format to be used for object error messages"
.IP "\fB\fBerror()\fB\fR \- perform the error mode action" 4
.IX Item "error() - perform the error mode action"
.PD
.SS "Methods to set/read Object variables inherited from Control::CLI"
.IX Subsection "Methods to set/read Object variables inherited from Control::CLI"
.IP "\fB\fBtimeout()\fB\fR \- set I/O time-out interval" 4
.IX Item "timeout() - set I/O time-out interval"
.PD 0
.IP "\fB\fBconnection_timeout()\fB\fR \- set Telnet and \s-1SSH\s0 connection time-out interval" 4
.IX Item "connection_timeout() - set Telnet and SSH connection time-out interval"
.IP "\fB\fBread_block_size()\fB\fR \- set read_block_size for either \s-1SSH\s0 or Serial port" 4
.IX Item "read_block_size() - set read_block_size for either SSH or Serial port"
.IP "\fB\fBblocking()\fB\fR \- set blocking mode for read methods and polling capable methods" 4
.IX Item "blocking() - set blocking mode for read methods and polling capable methods"
.IP "\fB\fBread_attempts()\fB\fR \- set number of read attempts used in \fBreadwait()\fR method" 4
.IX Item "read_attempts() - set number of read attempts used in readwait() method"
.IP "\fB\fBreadwait_timer()\fB\fR \- set the polling timer used in \fBreadwait()\fR method" 4
.IX Item "readwait_timer() - set the polling timer used in readwait() method"
.IP "\fB\fBdata_with_error()\fB\fR \- set the \fBreadwait()\fR method behaviour in case a read error occurs after some data was read" 4
.IX Item "data_with_error() - set the readwait() method behaviour in case a read error occurs after some data was read"
.IP "\fB\fBreturn_reference()\fB\fR \- set whether read methods should return a hard reference or not" 4
.IX Item "return_reference() - set whether read methods should return a hard reference or not"
.ie n .IP "\fB\fBoutput_record_separator()\fB\fR \- set the Output Record Separator automatically appended by print & cmd methods (Note that unlike Control::CLI this class will default to ""\er"")" 4
.el .IP "\fB\fBoutput_record_separator()\fB\fR \- set the Output Record Separator automatically appended by print & cmd methods (Note that unlike Control::CLI this class will default to ``\er'')" 4
.IX Item "output_record_separator() - set the Output Record Separator automatically appended by print & cmd methods (Note that unlike Control::CLI this class will default to r)"
.IP "\fB\fBprompt_credentials()\fB\fR \- set whether \fBconnect()\fR and \fBlogin()\fR methods should be able to prompt for credentials" 4
.IX Item "prompt_credentials() - set whether connect() and login() methods should be able to prompt for credentials"
.IP "\fB\fBusername_prompt()\fB\fR \- set the \fBlogin()\fR username prompt match pattern for this object" 4
.IX Item "username_prompt() - set the login() username prompt match pattern for this object"
.IP "\fB\fBpassword_prompt()\fB\fR \- set the \fBlogin()\fR password prompt match pattern for this object" 4
.IX Item "password_prompt() - set the login() password prompt match pattern for this object"
.IP "\fB\fBterminal_type()\fB\fR \- set the terminal type for the connection" 4
.IX Item "terminal_type() - set the terminal type for the connection"
.IP "\fB\fBwindow_size()\fB\fR \- set the terminal window size for the connection" 4
.IX Item "window_size() - set the terminal window size for the connection"
.IP "\fB\fBreport_query_status()\fB\fR \- set if read methods should automatically respond to Query Device Status escape sequences" 4
.IX Item "report_query_status() - set if read methods should automatically respond to Query Device Status escape sequences"
.PD
.SS "Methods to access Object read-only variables inherited from Control::CLI"
.IX Subsection "Methods to access Object read-only variables inherited from Control::CLI"
.IP "\fBparent\fR \- return parent object" 4
.IX Item "parent - return parent object"
.PD 0
.IP "\fBssh_channel\fR \- return ssh channel object" 4
.IX Item "ssh_channel - return ssh channel object"
.IP "\fBssh_authentication\fR \- return ssh authentication type performed" 4
.IX Item "ssh_authentication - return ssh authentication type performed"
.IP "\fBconnection_type\fR \- return connection type for object" 4
.IX Item "connection_type - return connection type for object"
.IP "\fBhost\fR \- return the host for the connection" 4
.IX Item "host - return the host for the connection"
.IP "\fBport\fR \- return the \s-1TCP\s0 port / \s-1COM\s0 port for the connection" 4
.IX Item "port - return the TCP port / COM port for the connection"
.IP "\fBlast_prompt\fR \- returns the last \s-1CLI\s0 prompt received from host" 4
.IX Item "last_prompt - returns the last CLI prompt received from host"
.IP "\fBusername\fR \- read username provided" 4
.IX Item "username - read username provided"
.IP "\fBpassword\fR \- read password provided" 4
.IX Item "password - read password provided"
.IP "\fBpassphrase\fR \- read passphrase provided" 4
.IX Item "passphrase - read passphrase provided"
.IP "\fBhandshake\fR \- read handshake used by current serial connection" 4
.IX Item "handshake - read handshake used by current serial connection"
.IP "\fBbaudrate\fR \- read baudrate used by current serial connection" 4
.IX Item "baudrate - read baudrate used by current serial connection"
.IP "\fBparity\fR \- read parity used by current serial connection" 4
.IX Item "parity - read parity used by current serial connection"
.IP "\fBdatabits\fR \- read databits used by current serial connection" 4
.IX Item "databits - read databits used by current serial connection"
.IP "\fBstopbits\fR \- read stopbits used by current serial connection" 4
.IX Item "stopbits - read stopbits used by current serial connection"
.PD
.SS "Methods for modules sub-classing Control::CLI::Extreme inherited from Control::CLI"
.IX Subsection "Methods for modules sub-classing Control::CLI::Extreme inherited from Control::CLI"
.IP "\fB\fBpoll_struct()\fB\fR \- sets up the polling data structure for non-blocking capable methods" 4
.IX Item "poll_struct() - sets up the polling data structure for non-blocking capable methods"
.PD 0
.IP "\fB\fBpoll_struct_cache()\fB\fR \- caches selected poll structure keys, if a nested polled method is called" 4
.IX Item "poll_struct_cache() - caches selected poll structure keys, if a nested polled method is called"
.IP "\fB\fBpoll_struct_restore()\fB\fR \- restores previously cached poll structure keys, if a nested polled method was called" 4
.IX Item "poll_struct_restore() - restores previously cached poll structure keys, if a nested polled method was called"
.IP "\fB\fBpoll_reset()\fB\fR \- resets poll structure" 4
.IX Item "poll_reset() - resets poll structure"
.IP "\fB\fBpoll_return()\fB\fR \- return status and optional output while updating poll structure" 4
.IX Item "poll_return() - return status and optional output while updating poll structure"
.IP "\fB\fBpoll_sleep()\fB\fR \- performs a sleep in blocking or non-blocking mode" 4
.IX Item "poll_sleep() - performs a sleep in blocking or non-blocking mode"
.IP "\fB\fBpoll_open_socket()\fB\fR \- opens \s-1TCP\s0 socket in blocking or non-blocking mode" 4
.IX Item "poll_open_socket() - opens TCP socket in blocking or non-blocking mode"
.IP "\fB\fBpoll_read()\fB\fR \- performs a non-blocking poll read and handles timeout in non-blocking polling mode" 4
.IX Item "poll_read() - performs a non-blocking poll read and handles timeout in non-blocking polling mode"
.IP "\fB\fBpoll_readwait()\fB\fR \- performs a non-blocking poll readwait and handles timeout in non-blocking polling mode" 4
.IX Item "poll_readwait() - performs a non-blocking poll readwait and handles timeout in non-blocking polling mode"
.IP "\fB\fBpoll_waitfor()\fB\fR \- performs a non-blocking poll for \fBwaitfor()\fR" 4
.IX Item "poll_waitfor() - performs a non-blocking poll for waitfor()"
.PD
.SS "Methods for modules sub-classing overridden from Control::CLI"
.IX Subsection "Methods for modules sub-classing overridden from Control::CLI"
.IP "\fB\fBpoll_connect()\fB\fR \- performs a non-blocking poll for \fBconnect()\fR" 4
.IX Item "poll_connect() - performs a non-blocking poll for connect()"
.PD 0
.IP "\fB\fBpoll_login()\fB\fR \- performs a non-blocking poll for \fBlogin()\fR" 4
.IX Item "poll_login() - performs a non-blocking poll for login()"
.IP "\fB\fBpoll_cmd()\fB\fR \- performs a non-blocking poll for \fBcmd()\fR" 4
.IX Item "poll_cmd() - performs a non-blocking poll for cmd()"
.IP "\fB\fBpoll_change_baudrate()\fB\fR \- performs a non-blocking poll for \fBchange_baudrate()\fR" 4
.IX Item "poll_change_baudrate() - performs a non-blocking poll for change_baudrate()"
.IP "\fB\fBdebugMsg()\fB\fR \- prints out a debug message" 4
.IX Item "debugMsg() - prints out a debug message"
.PD
.SS "Methods for modules sub-classing Control::CLI::Extreme"
.IX Subsection "Methods for modules sub-classing Control::CLI::Extreme"
.IP "\fB\fBpoll_connect()\fB\fR \- performs a non-blocking poll for \fBconnect()\fR" 4
.IX Item "poll_connect() - performs a non-blocking poll for connect()"
.Vb 10
\&  $ok = $obj\->poll_connect($pkgsub,
\&        [Host                   => $host,]
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [PublicKey              => $publicKey,]
\&        [PrivateKey             => $privateKey,]
\&        [Passphrase             => $passphrase,]
\&        [Prompt_credentials     => $flag,]
\&        [BaudRate               => $baudRate,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Login_Timeout          => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
\&
\&  ($ok, $outputref) = $obj\->poll_connect($pkgsub,
\&        [Host                   => $host,]
\&        [Port                   => $port,]
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [PublicKey              => $publicKey,]
\&        [PrivateKey             => $privateKey,]
\&        [Passphrase             => $passphrase,]
\&        [Prompt_credentials     => $flag,]
\&        [BaudRate               => $baudRate,]
\&        [Parity                 => $parity,]
\&        [DataBits               => $dataBits,]
\&        [StopBits               => $stopBits,]
\&        [Handshake              => $handshake,]
\&        [Login_Timeout          => $secs,]
\&        [Connection_timeout     => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Errmode                => $errmode,]
\&        [Terminal_type          => $string,]
\&        [Window_size            => [$width, $height],]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBconnect()\fR and \fBconnect_poll()\fR methods.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBpoll_login()\fB\fR \- performs a non-blocking poll for \fBlogin()\fR" 4
.IX Item "poll_login() - performs a non-blocking poll for login()"
.Vb 12
\&  $ok = $obj\->poll_login($pkgsub,
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Errmode                => $errmode,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
\&
\&  ($ok, $outputref) = $obj\->poll_login($pkgsub,
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Read_attempts          => $numberOfLoginReadAttemps,]
\&        [Data_with_error        => $flag,]
\&        [Wake_console           => $string,]
\&        [Errmode                => $errmode,]
\&        [Non_recognized_login   => $flag,]
\&        [Generic_login          => $flag,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBlogin()\fR and \fBlogin_poll()\fR methods.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBpoll_cmd()\fB\fR \- performs a non-blocking poll for \fBcmd()\fR" 4
.IX Item "poll_cmd() - performs a non-blocking poll for cmd()"
.Vb 1
\&  $ok = $obj\->poll_cmd($pkgsub, $cliCommand);
\&
\&  $ok = $obj\->poll_cmd($pkgsub,
\&        [Command                => $cliCommand,]
\&        [Feed_list              => \e@arrayRef,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_confirm_prompt     => $ynPrompt,]
\&        [Cmd_initiated_prompt   => $cmdPrompt,]
\&        [Timeout                => $secs,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $outputref[, $resultref]) = $obj\->poll_cmd($pkgsub, $cliCommand);
\&
\&  ($ok, $outputref[, $resultref]) = $obj\->poll_cmd($pkgsub,
\&        [Command                => $cliCommand,]
\&        [Feed_list              => \e@arrayRef,]
\&        [Prompt                 => $prompt,]
\&        [Reset_prompt           => $flag,]
\&        [More_prompt            => $morePrompt,]
\&        [More_pages             => $numberOfPages,]
\&        [Cmd_confirm_prompt     => $ynPrompt,]
\&        [Cmd_initiated_prompt   => $cmdPrompt,]
\&        [Timeout                => $secs,]
\&        [Progress_dots          => $bytesPerDot,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBcmd()\fR, \fBcmd_prompted()\fR and \fBcmd_poll()\fR methods.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBpoll_attribute()\fB\fR \- performs a non-blocking poll for \fBattribute()\fR" 4
.IX Item "poll_attribute() - performs a non-blocking poll for attribute()"
.Vb 1
\&  $ok = $obj\->poll_attribute($pkgsub, $attribute);
\&
\&  $ok = $obj\->poll_attribute($pkgsub,
\&        [Attribute               => $attribute,]
\&        [Reload                 => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $valueref) = $obj\->poll_attribute($pkgsub, $attribute);
\&
\&  ($ok, $valueref) = $obj\->poll_attribute($pkgsub,
\&        [Attribute               => $attribute,]
\&        [Reload                 => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBattribute()\fR and \fBattribute_poll()\fR methods.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBpoll_change_baudrate()\fB\fR \- performs a non-blocking poll for \fBchange_baudrate()\fR" 4
.IX Item "poll_change_baudrate() - performs a non-blocking poll for change_baudrate()"
.Vb 1
\&  $ok = $obj\->poll_change_baudrate($pkgsub, $baudrate);
\&
\&  $ok = $obj\->poll_change_baudrate($pkgsub,
\&        [BaudRate               => $baudRate,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
\&
\&  ($ok, $baudrateref) = $obj\->poll_change_baudrate($pkgsub, $baudrate);
\&
\&  ($ok, $baudrateref) = $obj\->poll_change_baudrate($pkgsub,
\&        [BaudRate               => $baudRate,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBchange_baudrate()\fR and \fBchange_baudrate_poll()\fR methods.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBpoll_enable()\fB\fR \- performs a non-blocking poll for \fBenable()\fR" 4
.IX Item "poll_enable() - performs a non-blocking poll for enable()"
.Vb 1
\&  $ok = $obj\->poll_enable($pkgsub, $password);
\&
\&  $ok = $obj\->poll_enable($pkgsub,
\&        [Password               => $enablePassword,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBenable()\fR and \fBenable_poll()\fR methods.
.IP "\fB\fBpoll_device_more_paging()\fB\fR \- performs a non-blocking poll for \fBdevice_more_paging()\fR" 4
.IX Item "poll_device_more_paging() - performs a non-blocking poll for device_more_paging()"
.Vb 1
\&  $ok = $obj\->poll_device_more_paging($pkgsub, $flag);
\&
\&  $ok = $obj\->poll_device_more_paging($pkgsub,
\&        [Enable                 => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBdevice_more_paging()\fR and \fBdevice_more_paging_poll()\fR methods.
.IP "\fB\fBpoll_device_peer_cpu()\fB\fR \- performs a non-blocking poll for \fBdevice_peer_cpu()\fR" 4
.IX Item "poll_device_peer_cpu() - performs a non-blocking poll for device_peer_cpu()"
.Vb 7
\&  $ok = $obj\->poll_device_peer_cpu($pkgsub,
\&        [Username               => $username,]
\&        [Password               => $password,]
\&        [Prompt_credentials     => $flag,]
\&        [Timeout                => $secs,]
\&        [Errmode                => $errmode,]
\&  );
.Ve
.Sp
Normally this is the internal method used by \fBdevice_peer_cpu()\fR and \fBdevice_peer_cpu_poll()\fR methods.
.IP "\fB\fBcmdPrivExec()\fB\fR \- send a command requiring PrivExec mode" 4
.IX Item "cmdPrivExec() - send a command requiring PrivExec mode"
.Vb 1
\&  ($ok, $outputref, $resultref) = $obj\->cmdPrivExec($pkgsub, $cmdcli, $cmdnncli, $morePages);
.Ve
.Sp
If the connected device is in \s-1ACLI\s0 mode this method will enter PrivExec mode, if not already in that mode, and then send \f(CW$cmdnncli\fR; after sending the command, if PrivExec mode was enabled, then this method will disable it to leave the device in exactly the same mode it was found in.
If instead the connected device is not in \s-1ACLI\s0 mode then it will simply send \f(CW$cmdcli\fR.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBcmdConfig()\fB\fR \- send a command requiring Config mode" 4
.IX Item "cmdConfig() - send a command requiring Config mode"
.Vb 1
\&  ($ok, $outputref, $resultref) = $obj\->cmdConfig($pkgsub, $cmdcli, $cmdnncli);
.Ve
.Sp
If the connected device is in \s-1ACLI\s0 mode this method will enter PrivExec mode and then Config mode, if not already in that mode, and then send \f(CW$cmdnncli\fR; after sending the command, if PrivExec mode and/or Config mode were enabled, then this method will come out of them to leave the device in exactly the same mode it was found in.
If instead the connected device is not in \s-1ACLI\s0 mode then 'config ' is prepended to \f(CW$cmdcli\fR (if it is not already beginning with 'config ' string) and the resulting command is sent.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBdiscoverDevice()\fB\fR \- discover the family type of connected device" 4
.IX Item "discoverDevice() - discover the family type of connected device"
.Vb 1
\&  ($ok, $familyType) = $obj\->discoverDevice($pkgsub);
.Ve
.Sp
This method will issue \s-1CLI\s0 commands to the attached device and based on the output received will determine what family type it belongs to.
Arguments after \f(CW$ok\fR will only be defined if \f(CW$ok\fR is \fBtrue\fR\|(1).
.IP "\fB\fBdebugMsg()\fB\fR \- prints out a debug message" 4
.IX Item "debugMsg() - prints out a debug message"
.Vb 1
\&  $obj\->debugMsg($msgLevel, $string1 [, $stringRef [,$string2]]);
.Ve
.Sp
A logical \s-1AND\s0 is performed between \f(CW$msgLevel\fR and the object debug level \- see \fBdebug()\fR; if the result is true, then the message is printed.
The message can be provided in 3 chunks: \f(CW$string1\fR is always present, followed by an optional string reference (to dump large amout of data) and \f(CW$string2\fR.
If a debug file was set \- see \fBdebug_file()\fR \- then the messages are printed to that file instead of \s-1STDOUT.\s0
.PP
The above methods are exposed so that sub classing modules can leverage the functionality within new methods themselves implementing polling.
These newer methods would have already set up a polling structure of their own.
When calling \fBpoll_login()\fR directly for the 1st time, it will detect an already existing poll structure and add itself to it (as well as caching some of it's keys; see poll_struct_cache). It will also read in the arguments provided at this point.
On subsequent calls, the arguments provided are ignored and the method simply polls the progress of the current task.
.SH "CLASS METHODS inherited from Control::CLI"
.IX Header "CLASS METHODS inherited from Control::CLI"
Class Methods which are not tied to an object instance.
The Control::CLI::Extreme class expressly imports all of Control::CLI's class methods into itself.
However by default Control::CLI::Extreme class does not import anything when it is use-ed.
The following list is a sub-set of those Control::CLI class methods.
These should be called using their fully qualified package name or else they can be expressly imported when loading this module:
.PP
.Vb 2
\&        # Import useTelnet, useSsh, useSerial & useIPv6
\&        use Control::CLI::Extreme qw(:use);
\&
\&        # Import promptClear, promptHide & promptCredential
\&        use Control::CLI::Extreme qw(:prompt);
\&
\&        # Import parseMethodArgs suppressMethodArgs
\&        use Control::CLI qw(:args);
\&
\&        # Import validCodeRef callCodeRef
\&        use Control::CLI qw(:coderef);
\&
\&        # Import all of Control::CLI class methods
\&        use Control::CLI::Extreme qw(:all);
\&
\&        # Import just poll()
\&        use Control::CLI::Extreme qw(poll);
.Ve
.IP "\fBuseTelnet\fR \- can Telnet be used ?" 4
.IX Item "useTelnet - can Telnet be used ?"
.PD 0
.IP "\fBuseSsh\fR \- can \s-1SSH\s0 be used ?" 4
.IX Item "useSsh - can SSH be used ?"
.IP "\fBuseSerial\fR \- can Serial port be used ?" 4
.IX Item "useSerial - can Serial port be used ?"
.IP "\fBuseIPv6\fR \- can IPv6 be used with Telnet or \s-1SSH\s0 ?" 4
.IX Item "useIPv6 - can IPv6 be used with Telnet or SSH ?"
.IP "\fB\fBpoll()\fB\fR \- poll objects for completion" 4
.IX Item "poll() - poll objects for completion"
.IP "\fB\fBpromptClear()\fB\fR \- prompt for username in clear text" 4
.IX Item "promptClear() - prompt for username in clear text"
.IP "\fB\fBpromptHide()\fB\fR \- prompt for password in hidden text" 4
.IX Item "promptHide() - prompt for password in hidden text"
.IP "\fB\fBpromptCredential()\fB\fR \- prompt for credential using either prompt class methods or code reference" 4
.IX Item "promptCredential() - prompt for credential using either prompt class methods or code reference"
.IP "\fB\fBpassphraseRequired()\fB\fR \- check if private key requires passphrase" 4
.IX Item "passphraseRequired() - check if private key requires passphrase"
.IP "\fB\fBparseMethodArgs()\fB\fR \- parse arguments passed to a method against list of valid arguments" 4
.IX Item "parseMethodArgs() - parse arguments passed to a method against list of valid arguments"
.IP "\fB\fBsuppressMethodArgs()\fB\fR \- parse arguments passed to a method and suppress selected arguments" 4
.IX Item "suppressMethodArgs() - parse arguments passed to a method and suppress selected arguments"
.IP "\fB\fBparse_errmode()\fB\fR \- parse a new value for the error mode and return it if valid or undef otherwise" 4
.IX Item "parse_errmode() - parse a new value for the error mode and return it if valid or undef otherwise"
.IP "\fB\fBstripLastLine()\fB\fR \- strip and return last incomplete line from string reference provided" 4
.IX Item "stripLastLine() - strip and return last incomplete line from string reference provided"
.IP "\fB\fBvalidCodeRef()\fB\fR \- validates reference as either a code ref or an array ref where first element is a code ref" 4
.IX Item "validCodeRef() - validates reference as either a code ref or an array ref where first element is a code ref"
.IP "\fB\fBcallCodeRef()\fB\fR \- calls the code ref provided (which should be a code ref or an array ref where first element is a code ref)" 4
.IX Item "callCodeRef() - calls the code ref provided (which should be a code ref or an array ref where first element is a code ref)"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Ludovico Stevens <lstevens@cpan.org>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-control\-cli\-extreme at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Control\-CLI\-Extreme>.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
Note that this module is in no way supported or endorsed by Extreme Inc.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Control::CLI::Extreme
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Control\-CLI\-Extreme>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Control\-CLI\-Extreme>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Control\-CLI\-Extreme>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Control\-CLI\-Extreme/>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2020 Ludovico Stevens.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
