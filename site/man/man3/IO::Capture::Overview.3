.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Capture::Overview 3"
.TH IO::Capture::Overview 3 "2005-04-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Overview of "IO::Capture" Module, and classes derived from it.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The modules in this distribution are designed to allow you to
capture and process output sent to \s-1STDOUT\s0 and/or \s-1STDERR.\s0
.PP
I initial created the modules to use in building module tests.  I 
wanted to be able to intentionally cause errors, and insure the 
module responded correctly.  E.g., Call a class method without a 
required argument.  Using IO::Capture keeps the user from seeing 
these intentional errors when running 'make test'.
.PP
I have also found this useful on occasion in Perl Tk apps, where 
I wanted to capture output from a Perl module I was using.  I could 
then capture, then put the text into a log or message window.
.PP
Note:  None of the modules currently distributed will capture from
the 'system' Perl function, or the like.  It could be done, but 
generally, if you would like to capture from a system command,
you don't need this module, just use the backticks operators.
.PP
.Vb 1
\&        my $output = \*(Aq/usr/bin/ls\*(Aq;
.Ve
.PP
They are small, lightweight modules.  Instead of designing in a lot of
features, we designed it to be easily reusable and adaptable.
A module can be quickly built, that incorporates custom methods, but
reuses all existing features of one of the derived classes. See the 
section on \*(L"\s-1ADDING FEATURES\*(R"\s0  Or, if you need to change the actual 
capture mechanism, \*(L"\s-1WRITING YOUR OWN DERIVED CLASS\*(R"\s0.  (Don't worry, 
it's a piece of cake)
.SH "DERIVED CLASSES"
.IX Header "DERIVED CLASSES"
There are several classes derived from \f(CW\*(C`IO::Capture\*(C'\fR.
.SS "IO::Capture::Stdout"
.IX Subsection "IO::Capture::Stdout"
Module to capture \f(CW\*(C`STDOUT\*(C'\fR from program.  See IO::Capture::Stdout.
.SS "IO::Capture::Stderr"
.IX Subsection "IO::Capture::Stderr"
Module to capture \f(CW\*(C`STDERR\*(C'\fR from program.  See IO::Capture::Stderr.
.SS "IO::Capture::ErrorMessages"
.IX Subsection "IO::Capture::ErrorMessages"
This method has been depreciated.  The only difference between this one and Stderr.pm
was the trap for \s-1WARN.\s0  I found it was fixed in 5.8 so just check in Stderr
now.  I.e., Just use Stderr now. It (Stderr) will detect what version of
perl you are using, and act accordingly.  The two (\f(CW\*(C`IO::Capture::ErrorMessages\*(C'\fR and 
\&\f(CW\*(C`IO::Capture::Stderr\*(C'\fR) are currently identical, and \f(CW\*(C`IO::Capture::ErrorMessages\*(C'\fR will
be removed in a future release.
.PP
If you would like to add features to any of these, or build your 
own module using \f(CW\*(C`IO::Capture\*(C'\fR as a base, read on.
.SH "ADDING FEATURES"
.IX Header "ADDING FEATURES"
If one of these modules takes care of your problem, install it and
have fun!
.PP
But let's say you would like to add a feature to one of the derived classes, 
say IO::Capture::Stdout.  No need to re-write the whole module, just use it
as the base, and write your one feature. Here is a somewhat simplified 
example.
.PP
.Vb 5
\&    #
\&    # Example module to add a grep_it method
\&    #
\&    # Give your package a name
\&    package MyPackage;
\&
\&    #use IO:Capture:Stdout as the base
\&    use base \*(AqIO::Capture::Stdout\*(Aq;
\&
\&    #define your method
\&    sub grep_it {
\&        my $self = shift;
\&        my $string = shift;
\&        my @found_lines;
\&
\&        # Making a ref to the array makes it easier to read  :\-)
\&        my $arrayref = \e@{$self\->{\*(AqIO::Capture::messages\*(Aq}};
\&        
\&        for my $line (@$arrayref) {
\&            push @found_lines, $line if $line =~ /$string/;
\&        }
\&        return wantarray ? @found_lines : scalar(@found_lines);
\&    }
\&    1;
.Ve
.PP
Using it in this script
.PP
.Vb 4
\&    #!/usr/sbin/perl
\&    use strict;
\&    use warnings;
\&    use MyPackage;
\&
\&    my $capture = MyPackage\->new();
\&    $capture\->start;
\&    print "The quick brown fox jumped over ...";
\&    print "garden wall";
\&    print "The quick red fox jumped over ...";
\&    print "garden wall";
\&    $capture\->stop;
\&    for my $line ($capture\->grep_it("fox")) {
\&        print "$line\en";
\&    }
.Ve
.PP
Results in
.PP
.Vb 3
\&    $ grep_it   
\&    The quick brown fox jumped over ...
\&    The quick red fox jumped over ...
.Ve
.SH "WRITING YOUR OWN DERIVED CLASS"
.IX Header "WRITING YOUR OWN DERIVED CLASS"
Before starting your own sub-class, be sure to read through IO::Capture.  Pay 
special attention to the internal methods that are only defined as \fIabstract\fR 
methods in \f(CW\*(C`IO::Capture\*(C'\fR.  For examples, look at the sub-classes included with 
this distribution. (\f(CW\*(C`IO::Capture::Stdout\*(C'\fR, \f(CW\*(C`IO:Capture::Stderr\*(C'\fR.
You can start by copying one of these and using 
it as a template.  They have the required private methods defined already, and you 
may very well be able to use them as is.  Change any methods, and add any new 
ones, as needed.
.PP
For example, here is a commented copy of \f(CW\*(C`IO::Capture::Stderr\*(C'\fR.
.PP
.Vb 5
\&    #
\&    # Example module using abstract class IO::Capture
\&    #
\&    # Change this to give your class it\*(Aqs own name
\&    package IO::Capture::Stderr;
\&
\&    # Make IO::Capture the base class
\&    use base qw/IO::Capture/;
\&
\&    # If using included utility module in \*(Aq_start()\*(Aq
\&    use IO::Capture::Tie_STDx;
\&
\&    # Override the three abstract methods needed to make a valid
\&    # module. See IO::Capture manpage
\&    #  1) _start \- Starts the data capture. Is run from public method
\&    #     start();
\&    #
\&    #  2) _retrieve_captured_text() \- Move the captured text into the
\&    #  object hash key, "IO::Capture::messages". Called by public method 
\&    #
\&    #  3) _stop \- Stop the data capture. Called by public method \*(Aqstop()\*(Aq
\&    #    after private method \*(Aq_retrieve_captured_text()\*(Aq returns. 
\&    #
\&    sub _start {
\&        tie *STDERR, "IO::Capture::Tie_STDx";
\&    }
\&
\&    sub _retrieve_captured_text {
\&        my $self = shift;
\&        # making a reference to it makes it more readable ;\-)
\&        my $messages = \e@{$self\->{\*(AqIO::Capture::messages\*(Aq}};
\&
\&        @$messages = <STDERR>;
\&    }
\&
\&    sub _stop {
\&        untie *STDERR;
\&                return 1;
\&    }
\&    1;
.Ve
.PP
Lets say you don't want to capture \fBall\fR the text.  You just want to 
grab the lines that have the word \*(L"Error\*(R" in them.  The only thing you 
need to change is _retrieve_captured_text. (Besides the package name)
.PP
Something like:
.PP
.Vb 4
\&    sub _retrieve_captured_text {
\&        my $self = shift;
\&        # making a reference to it makes it more readable ;\-)
\&        my $messages = \e@{$self\->{\*(AqIO::Capture::messages\*(Aq}};
\&
\&        while (<STDERR>) {
\&            push @$messages, $_ if /error/i;
\&        }
\&    }
.Ve
.PP
Yes. You could do this easier by just using \f(CW\*(C`IO::Capture::Stderr\*(C'\fR as the base and 
overriding \f(CW\*(C`_retrieve_captured_text\*(C'\fR like in \*(L"\s-1ADDING FEATURES\*(R"\s0, but hey, we 
needed an easy example.  :\-)
.PP
If you want your class to have arguments that users can pass in, just use the default
\&\f(CW\*(C`new()\*(C'\fR method and have the arguments passed in as an anonymous array.  See the 
\&\f(CW\*(C`IO::Capture::Stderr\*(C'\fR module for an example.
.SH "BUGS"
.IX Header "BUGS"
Please report bugs on http://rt.cpan.org/
.SH "CREDITS"
.IX Header "CREDITS"
Special thanks to  James E Keenan for many bug fixes and tests he provided.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Reynolds
reynolds<at>sgi.com
.PP
Note: \f(CW\*(C`Change <at\*(C'\fR to 'at' sign.>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2005, Mark Reynolds. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as Perl itself.
