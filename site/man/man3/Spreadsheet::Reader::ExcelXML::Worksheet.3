.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::Reader::ExcelXML::Worksheet 3"
.TH Spreadsheet::Reader::ExcelXML::Worksheet 3 "2017-04-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::Reader::ExcelXML::Worksheet \- Top level Worksheet interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        use strict;
\&        use warnings;
\&        use Data::Dumper;
\&
\&        use Spreadsheet::Reader::ExcelXML;
\&        my $workbook =  Spreadsheet::Reader::ExcelXML\->new( #similar style to Spreadsheet::XLSX
\&                                                file => \*(Aqt/test_files/TestBook.xlsx\*(Aq,# in the test folder of this package
\&                                                group_return_type => \*(Aqvalue\*(Aq,
\&                                        );
\&
\&        if ( !$workbook\->file_opened ) {
\&                die $workbook\->error(), ".\en";
\&        }
\&
\&        my      $worksheet = $workbook\->worksheet( \*(AqSheet5\*(Aq );
\&                $worksheet\->set_custom_formats( {
\&                        2 =>\*(Aqyyyy\-mm\-dd\*(Aq,
\&                } );
\&        my $value;
\&        while( !$value or $value ne \*(AqEOF\*(Aq ){
\&                $value = $worksheet\->fetchrow_arrayref;
\&                print Dumper( $value );
\&        }
\&
\&        ###########################
\&        # SYNOPSIS Output
\&        # $VAR1 = [ \*(AqSuperbowl Audibles\*(Aq, \*(AqColumn Labels\*(Aq ];
\&        # $VAR1 = [         \*(AqRow Labels\*(Aq,     2016\-02\-06\*(Aq, \*(Aq2017\-02\-14\*(Aq, \*(Aq2018\-02\-03\*(Aq, \*(AqGrand Total\*(Aq ];
\&        # $VAR1 = [               \*(AqBlue\*(Aq,            \*(Aq10\*(Aq,          \*(Aq7\*(Aq,           \*(Aq\*(Aq,          \*(Aq17\*(Aq ];
\&        # $VAR1 = [              \*(AqOmaha\*(Aq,              \*(Aq\*(Aq,           \*(Aq\*(Aq,          \*(Aq2\*(Aq,           \*(Aq2\*(Aq ];
\&        # $VAR1 = [                \*(AqRed\*(Aq,            \*(Aq30\*(Aq,          \*(Aq5\*(Aq,          \*(Aq3\*(Aq,          \*(Aq38\*(Aq ];
\&        # $VAR1 = [        \*(AqGrand Total\*(Aq,            \*(Aq40\*(Aq,         \*(Aq12\*(Aq,          \*(Aq5\*(Aq,          \*(Aq57\*(Aq ];
\&        # $VAR1 = \*(AqEOF\*(Aq;
\&        ###########################
.Ve
.PP
The best example for use of this module alone is the test file in this package
t/Spreadsheet/Reader/ExcelXML/10\-worksheet.t
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is the worksheet interface.  Even thought it will not provide all worksheet
access itself it's role is to manage a consistent way of parsing Excel worksheets.  If
the sheet/tab is a 'chartsheet' then please review the documentation for Chartsheets
\&. The documentation in this file will include
all publicly accesable elements.  This include elements provided through other roles and
the base class.  The purpose of this instance is to extract worksheet level formats and
cell level content for parsing. The workbook also has several Settings
 that affect the outcome of methods from this
interface.  For example the workbook level attribute setting
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML will directly affect how this data is
returned when retreiving cell data.  Please review all workbook level attribute
documentation for information covering those possibilities.  It is best to generate a
worksheet instance from the workbook class using one of the various worksheet
 methods.
.SS "Modification of this Interface"
.IX Subsection "Modification of this Interface"
The final worksheet instance provided by this package is an amalgam of a base class and a
few roles aggregated at run time based on attribute settings from the workbook level
class.  The easiest way to modify behaviour in this instance is to build an additional
or replacement element and have it built into the interface by the workbook.   The
settings for this type of injection/adjustement are stored in the raw code of
Spreadsheet::Reader::ExcelXML::Workbook within the 'worksheet_interface' key of the
\&\f(CW$parser_modules\fR variable.  The file t/Spreadsheet/Reader/ExcelXML/10\-worksheet.t
in the distribution represents a good 'under the hood' example of the way all the elements
are integrated into the larger worksheet class as a whole.
.SS "Methods"
.IX Subsection "Methods"
These are the various functions that are available to extract cell (values) to read or
to extract worksheet level formats. There are several different methods provided to
extract the same content in different ways.  All the methods are object methods performed
on the worksheet.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        my $cell_data = $worksheet\->get_cell( $row, $column );
.Ve
.PP
\fImin_row\fR
.IX Subsection "min_row"
.Sp
.RS 4
\&\fBDefinition:\fR This is the minimum row determined when the sheet is opened.  This
value is affected by the workbook attributes
from_the_edge, and
count_from_zero
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer \f(CW$row\fR
.RE
.PP
\fIhas_min_row\fR
.IX Subsection "has_min_row"
.Sp
.RS 4
\&\fBDefinition:\fR The predicate
of min_row
.RE
.PP
\fImax_row\fR
.IX Subsection "max_row"
.Sp
.RS 4
\&\fBDefinition:\fR This is the maximum row with data listed in the sheet.  This value
is affected by the workbook attribute
count_from_zero. \fBWarning:
This value is extracted from the sheet metadata, however if your sheet has been
damaged or 'adjusted' by non-microsoft code (This is more common than you would think
in the data processing world) then this value may be wrong or missing when the sheet
is first opened.  The goal of this package is to minimize memory consumption so it
will learn what the correct value is over the first pass through the sheet as you
collect data but it does not attempt to validate this value in detail initially. If
you have an idea of the range for a damaged sheet before you open it you can use
\&\s-1EOF\s0 flags.  Otherwise the methods
get_next_value or fetchrow_arrayref are
recomended.\fR
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer
.RE
.PP
\fIhas_max_row\fR
.IX Subsection "has_max_row"
.Sp
.RS 4
\&\fBDefinition:\fR The predicate
of max_row
.RE
.PP
\fIrow_range\fR
.IX Subsection "row_range"
.Sp
.RS 4
\&\fBDefinition:\fR This returns a list containing the minimum row number followed
by the maximum row number.  This list is affected by the workbook attributes
from_the_edge, and
count_from_zero \fBWarning:
This result is extracted from the sheet metadata, however if your sheet has been
damaged or 'adjusted' by non-microsoft code (This is more common than you would think
in the data processing world) then the return list may be wrong or missing when the
sheet is first opened.  The goal of this package is to minimize memory consumption so it
will learn what the correct list is over the first pass through the sheet as you
collect data but it does not attempt to validate this list in detail initially. If
you have an idea of the range for a damaged sheet before you open it you can use
EOR-EOF flags.  Otherwise the methods
get_next_value or fetchrow_arrayref are
recomended.\fR  For missing values the minimum is set to the first row and the maximum
is set to undef.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR ( \f(CW$minimum_row\fR, \f(CW$maximum_row\fR )
.RE
.PP
\fImin_col\fR
.IX Subsection "min_col"
.Sp
.RS 4
\&\fBDefinition:\fR This is the minimum column with data listed in the sheet.  This value
is affected by the workbook attributes
from_the_edge, and
count_from_zero
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer
.RE
.PP
\fIhas_min_col\fR
.IX Subsection "has_min_col"
.Sp
.RS 4
\&\fBDefinition:\fR The predicate
of min_col
.RE
.PP
\fImax_col\fR
.IX Subsection "max_col"
.Sp
.RS 4
\&\fBDefinition:\fR This is the maximum row with data listed in the sheet.  This value
is affected by the workbook attribute
count_from_zero \fBWarning:
This value is extracted from the sheet metadata, however if your sheet has been
damaged or 'adjusted' by non-microsoft code (This is more common than you would think
in the data processing world) then this value may be wrong or missing when the sheet
is first opened.  The goal of this package is to minimize memory consumption so it
will learn what the correct value is over the first pass through the sheet as you
collect data but it does not attempt to validate this value in detail initially. If
you have an idea of the range for a damaged sheet before you open it you can use
\&\s-1EOR\s0 flags.  Otherwise the methods
get_next_value or fetchrow_arrayref are
recomended.\fR
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer
.RE
.PP
\fIhas_max_col\fR
.IX Subsection "has_max_col"
.Sp
.RS 4
\&\fBDefinition:\fR The predicate
of max_col
.RE
.PP
\fIcol_range\fR
.IX Subsection "col_range"
.Sp
.RS 4
\&\fBDefinition:\fR This returns a list containing the minimum column number followed
by the maximum column number.  This list is affected by the workbook attributes
from_the_edge, and
count_from_zero
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR ( \f(CW$minimum_column\fR, \f(CW$maximum_column\fR )
.RE
.PP
\fIget_merged_areas\fR
.IX Subsection "get_merged_areas"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns an array ref of cells that are merged.  This method does
respond to the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML \fBWarning:
This result is extracted from the sheet metadata for 2007+ Excel files, however if you
are parsing an Excel 2003 xml file this data is stored at the cell level.  Since this
parser reads the data 'Just In Time' it will not know about a set of merged cells until the
upper left cell of the group has been read.\fR
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR An arrayref of arrayrefs of merged areas or undef if no merged areas
.Sp
.Vb 1
\&        [ [ $start_row_1, $start_col_1, $end_row_1, $end_col_1], etc.. ]
.Ve
.RE
.PP
\fIis_column_hidden\fR
.IX Subsection "is_column_hidden"
.Sp
.RS 4
\&\fBDefinition:\fR Method indicates if the excel program would hide the identified column(s) or show
it|them if the file were opened in the Microsoft Excel application.  If more than one column is
passed then it returns true if any of the columns are hidden in scalar context and a list of
1 and 0 values for each of the requested positions in array (list) context.  This method (input)
does respond to the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML.  For 2003
xml files this data is stored at the cell level so the parser will not 'know' until you have
read (past) the cell.
.Sp
\&\fBAccepts:\fR integer values or column letter values selecting the columns in question
.Sp
\&\fBReturns:\fR in scalar context it returns a boolean value indicating if any of the requested
columns would be hidden by Excel.  In array/list context it returns a list of boolean values
for each requested column indicating it's hidden state for Excel. (1 = hidden)
.Sp
\&\fBExamples:\fR (Indicating the 3rd and 4th of 6 columns are hidden)
.Sp
.Vb 5
\&        $worksheet_instance\->is_column_hidden( 0 .. 5 ),
\&        ###########################
\&        # Example Output
\&        # [ 0, 0, 1, 1, 0, 0 ]
\&        ###########################
\&
\&        $worksheet_instance\->is_column_hidden( \*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq, \*(AqD\*(Aq, \*(AqE\*(Aq, \*(AqF\*(Aq )
\&        ###########################
\&        # Example Output
\&        # [ 0, 0, 1, 1, 0, 0 ]
\&        ###########################
.Ve
.RE
.PP
\fIis_row_hidden\fR
.IX Subsection "is_row_hidden"
.Sp
.RS 4
\&\fBDefinition:\fR Method indicates if the excel program would hide the identified row(s) or show
it|them if the file were opened in the Microsoft Excel application.  If more than one row is
passed then it returns true if any of the rows are hidden in scalar context and a list of
1 and 0 values for each of the requested positions in array (list) context.  This method (input)
does respond to the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML.  \fBWarning:
This method will only be accurate after the user has read at least one cell from or past the row
inspected for it's hidden state.  This allows the sheet to avoid reading all the way through once
before starting the cell parsing.\fR
.Sp
\&\fBAccepts:\fR integer values selecting the rows in question
.Sp
\&\fBReturns:\fR in scalar context it returns a boolean value indicating if any of the requested
rows would be hidden by Excel.  In array/list context it returns a list of boolean values
for each requested row indicating it's hidden state for Excel. (1 = hidden)
.RE
.PP
\fIget_cell( \f(CI$row\fI, \f(CI$column\fI )\fR
.IX Subsection "get_cell( $row, $column )"
.Sp
.RS 4
\&\fBDefinition:\fR Indicate both the requested row and requested column and the information for
that position will be returned.  Both \f(CW$row\fR and \f(CW$column\fR are required
.Sp
\&\fBAccepts:\fR the list ( \f(CW$row\fR, \f(CW$column\fR ) both required  See the attribute
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML to understand which row and column
are returned for \f(CW$row\fR and \f(CW$colum\fR.
.Sp
\&\fBReturns:\fR see the attribute \*(L"group_return_type\*(R" in Spreadsheet::Reader::ExcelXML for
details on what is returned
.RE
.PP
\fIget_next_value\fR
.IX Subsection "get_next_value"
.Sp
.RS 4
\&\fBDefinition:\fR Reading left to right and top to bottom this will return the next cell with
a value.  This can includes cells with no value but some unique formatting such as
cells that have been merged with other cells.  See the attributes
\&\*(L"values_only\*(R" in Spreadsheet::Reader::ExcelXML and
\&\*(L"spaces_are_empty\*(R" in Spreadsheet::Reader::ExcelXML for more information.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR see the attribute \*(L"group_return_type\*(R" in Spreadsheet::Reader::ExcelXML for
details on what is returned
.RE
.PP
\fIfetchrow_arrayref( \f(CI$row\fI )\fR
.IX Subsection "fetchrow_arrayref( $row )"
.Sp
.RS 4
\&\fBDefinition:\fR In an homage to \s-1DBI\s0 I included this function to return an array ref of
the cells or values in the requested \f(CW$row\fR.  If no row is requested this returns the 'next'
row.  In the array ref any empty cell will show as 'undef'.
.Sp
\&\fBAccepts:\fR undef = next|$row = a row integer indicating the desired row  See the attribute
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML to understand which row is returned for \f(CW$row\fR.
.Sp
\&\fBReturns:\fR an array ref of all possible column positions in that row with data filled in
per the attribute \*(L"group_return_type\*(R" in Spreadsheet::Reader::ExcelXML.
.RE
.PP
\fIfetchrow_array( \f(CI$row\fI )\fR
.IX Subsection "fetchrow_array( $row )"
.Sp
.RS 4
\&\fBDefinition:\fR This function is just like fetchrow_arrayref
except it returns an array instead of an array ref
.Sp
\&\fBAccepts:\fR undef = next|$row = a row integer indicating the desired row.  See the attribute
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML to understand which row is returned for \f(CW$row\fR.
.Sp
\&\fBReturns:\fR an array ref of all possible column positions in that row with data filled in
per the attribute \*(L"group_return_type\*(R" in Spreadsheet::Reader::ExcelXML.
.RE
.PP
\fIset_headers( \f(CI@header_row_list\fI, [ \e&header_scrubber ] )\fR
.IX Subsection "set_headers( @header_row_list, [ &header_scrubber ] )"
.Sp
.RS 4
\&\fBDefinition:\fR This function is used to set headers used in the function
fetchrow_hashref.  It accepts a list of row numbers that
will be collated into a set of headers used to build the hashref for each row.
The header rows are coallated in sequence with the first position taking precedence.
The list is also used to set the lowest row of the headers in the table.  All rows
at that level and higher will be considered out of the table and will return undef
while setting the error instance.  If some of the header columns do not have values
then the instance will auto generate unique headers for each empty header column to
fill out the header ref. [ optionally: it is possible to pass a coderef at the end of
the list to scrub the headers so they make some sense.] When the headers are loaded
the top level information row of any pull for 'fetchrow_hashref' will be considered
the first row after the header row.  Any header build will not be tested again during
fetchrow_hashref the content columns will be matched to the header columns by position.
for example;
.Sp
.Vb 9
\&        my $scrubber = sub{
\&                my $input = $_[0];
\&                $input =~ s/\en//g if $input;
\&                $input =~ s/\es/_/g if $input;
\&                return $input;
\&        };
\&        $self\->set_headers( 2, 1, $scrubber ); # Called internally as $new_value = $scrubber\->( $old_value );
\&        # Returns/stores the headers set at row 2 and 1 with values from row 2 taking precedence
\&        #  Then it scrubs the values by removing newlines and replacing spaces with underscores.
.Ve
.Sp
\&\fBAccepts:\fR a list of row numbers (modified as needed by the attribute state of
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML) and an optional closure
 <http://www.perl.com/pub/2002/05/29/closure.html>.  See the attribute
\&\*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML to understand which rows are
used when the \f(CW@header_row_list\fR is called.
.Sp
\&\fBReturns:\fR an array ref of the built headers for review.
.RE
.PP
\fIget_last_header_row\fR
.IX Subsection "get_last_header_row"
.Sp
.RS 4
\&\fBDefinition:\fR This returns the final row of headers in the sheet.  The return value is
in the context of the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML.  It is
determined by the function 'set_headers'.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR the last (largest) row number used in the coallated header.
.RE
.PP
\fIheader_row_set\fR
.IX Subsection "header_row_set"
.Sp
.RS 4
\&\fBDefinition:\fR This predicate will indicate if any header build has occured from the
method 'set_headers'.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR Boolean on off for set headers (1 = headers are set)
.RE
.PP
\fIfetchrow_hashref( \f(CI$row\fI )\fR
.IX Subsection "fetchrow_hashref( $row )"
.Sp
.RS 4
\&\fBDefinition:\fR This function is used to return a hashref representing the data in the
specified row.  If no \f(CW$row\fR value is passed it will return the 'next' row of data.  A call
to this function without setting the headers first
will return 'undef' and set the error instance.
.Sp
\&\fBAccepts:\fR a target \f(CW$row\fR number for return values or undef meaning 'next'  See the
attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML to understand which rows
are targeted by \f(CW$row\fR.
.Sp
\&\fBReturns:\fR a hash ref of the values for that row.  This function ignores the attribute
group_return_type when it is
set to 'instance' and returns 'value's instead.  See also the attributes
min_header_col and max_header_col to pare the
start and end columns of the returned hash ref.
.RE
.PP
\fIset_custom_formats( \f(CI$format_ref\fI )\fR
.IX Subsection "set_custom_formats( $format_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This package will generate value conversions that generally match the
numerical conversions set in the Excel spreadsheet.  However, it may be that you want
to convert the unformatted values for certain cells, rows, or columns in some user
defined way.  The simplest way to do this is by storing an
Excel custom number format string
 <https://support.office.com/en-au/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4>
in this instance using 'set_custom_formats' against either a CellID, a Row Number, or a
Column letter. As an example you could say;
.Sp
.Vb 3
\&        $worksheet\->set_custom_formats( {
\&            A => \*(Aq# ?/?\*(Aq,
\&        } );
.Ve
.Sp
And any subsequent call for a \f(CW$cell\fR\->value from column 'A' will attempt to convert the
raw xml contents of that cell to an integer and fraction combination with one position
in the denominator or less (an integer only).  If the cell is text then it will act as
a pass-through.  Where there is overlap between the formats the instance will select
one based on the following priority; cellID, column letter, row number.
.Sp
For the truly adventurous you can build an object instance that has the two following
methods; 'assert_coerce' and 'display_name'.  Then add it to the attribute as above.
.Sp
.RS 4
\&\fBA Complicated Example:\fR Building a converter on the fly from Type::Tiny
 (or use MooseX::Types)
.Sp
.Vb 6
\&        use DateTimeX::Format::Excel;
\&        use DateTime::Format::Flexible;
\&        use Type::Coercion;
\&        use Type::Tiny;
\&        my @args_list  = ( system_type => \*(Aqapple_excel\*(Aq );
\&        my $num_converter  = DateTimeX::Format::Excel\->new( @args_list );
\&
\&        # build conversion subroutines (number and strings to DateTime objects)
\&        my $string_via = sub{
\&              my $str = $_[0];
\&              return DateTime::Format::Flexible\->parse_datetime( $str );
\&        };
\&        my $num_via     = sub{
\&              my $num = $_[0];
\&              return $num_converter\->parse_datetime( $num );
\&        };
\&
\&        # Combine conversion subroutines into a coercion object!
\&        #  (Note numbers are attempted first)
\&        my $date_time_from_value = Type::Coercion\->new(
\&                type_coercion_map => [ Num, $num_via, Str, $string_via, ],
\&        );
\&
\&        # Install the coercion in a type that ensures it passes through a DateTime check
\&        $date_time_type = Type::Tiny\->new(
\&           name       => \*(AqCustom_date_type\*(Aq,
\&           constraint => sub{ ref($_) eq \*(AqDateTime\*(Aq },
\&           coercion   => $date_time_from_value,
\&        );
\&
\&        # Chained coercions! to handle first the $date_time_from_value coercion
\&        #    and then build a specific date string output
\&        $string_type = Type::Tiny\->new(
\&           name       => \*(AqYYYYMMDD\*(Aq,
\&           constraint => sub{
\&              !$_ or (
\&                 $_ =~ /^\ed{4}\e\-(\ed{2})\-(\ed{2})$/ and
\&                 $1 > 0 and $1 < 13 and $2 > 0 and $2 < 32
\&              )
\&           },
\&           coercion => Type::Coercion\->new(
\&           type_coercion_map =>[
\&              $date_time_type\->coercibles, sub{
\&                 my $tmp = $date_time_type\->coerce( $_ );
\&                 $tmp\->format_cldr( \*(Aqyyyy\-MM\-dd\*(Aq )
\&              },
\&           ],
\&        ), );
\&
\&        # Then set the coercions in the worksheet for targeted positions
\&        $worksheet\->set_custom_formats( {
\&            E10 => $date_time_type,
\&            10  => $string_type,
\&            D14 => $string_type,
\&        } );
.Ve
.RE
.RE
.RS 4
.Sp
\&\fBAccepts:\fR a set of \f(CW$key\fR => \f(CW$value\fR pairs where the \f(CW$key\fR can either be a
row number, a column letter, or a cell \s-1ID.\s0  The \f(CW$value\fR must either be a
string that complies with excel custom number formatting conventions or
an object instance with two methods 'display_name' and 'assert_coerce'.
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIhas_custom_format( \f(CI$key\fI )\fR
.IX Subsection "has_custom_format( $key )"
.Sp
.RS 4
\&\fBDefinition:\fR This is a test to see if a custom format is stored for \f(CW$key\fR.
.Sp
\&\fBAccepts:\fR \f(CW$key\fR
.Sp
\&\fBReturns:\fR a boolean where 1 = formats exist
.RE
.PP
\fIget_custom_format( \f(CI$key\fI )\fR
.IX Subsection "get_custom_format( $key )"
.Sp
.RS 4
\&\fBDefinition:\fR This will retrieve the \f(CW$value_ref\fR of the custom format stored
against the given \f(CW$key\fR.  For formats saved as Excel custom format strings this
will return a package built object instance that performs the conversion
indicated by the custom format string.
.Sp
\&\fBAccepts:\fR \f(CW$key\fR
.Sp
\&\fBReturns:\fR a \f(CW$value_ref\fR for the stored format object
.RE
.PP
\fIget_custom_formats\fR
.IX Subsection "get_custom_formats"
.Sp
.RS 4
\&\fBDefinition:\fR This returns a hashref of all stored custom formats
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a hashref of all custom formats
.RE
.SS "Attributes"
.IX Subsection "Attributes"
These are attributes of the built instance.  Most of these are provided as metadata for
the specific parsed sheet and should be provided by the object that builds the worksheet
instance.  (The workbook)  However, a few can be set after worksheet creation to affect the
data retreival results.  These attributes are presented first. The end of the list is the
attribute that stores a reference to the workbook.  Follow the link in thats attribute
documentation to learn a tricksy way to adjust several workbook level settings with the
worksheet instance.
.PP
\fImin_header_col\fR
.IX Subsection "min_header_col"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute affects the hashref that is returned in the method
fetchrow_hashref.    This attribute tells fetchrow_hashref
what column to use to start the hash ref build.  This attribute (input)
does respond to the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML.
.Sp
\&\fBDefault:\fR undef (which is equivalent to the minimum column of the sheet)
.Sp
\&\fBRange:\fR The minimum column of the sheet to or less than the
max_header_col
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_min_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.Sp
\&\fBset_min_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR Sets a new value for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBhas_min_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has a stored value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fImax_header_col\fR
.IX Subsection "max_header_col"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute affects the hashref that is returned in the method
fetchrow_hashref.  This attribute tells fetchrow_hashref
what column to use to end the hash ref build.  This attribute (input) does respond to
the attribute \*(L"count_from_zero\*(R" in Spreadsheet::Reader::ExcelXML.
.Sp
\&\fBDefault:\fR undef (equal to the maximum column of the sheet)
.Sp
\&\fBRange:\fR The maximum column of the sheet to or less than the
min_header_col
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_max_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.Sp
\&\fBset_max_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR Sets a new value for the attribute
.RE
.RE
.RS 4
.Sp
\&\fBhas_max_header_col\fR
.Sp
.RS 4
\&\fBDefinition:\fR Indicates if the attribute has a stored value
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIfile\fR
.IX Subsection "file"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds the file handle for the file being read.  If
the full file name and path is passed to the attribute the class will coerce that
into an IO::File file handle.
.Sp
\&\fBDefault:\fR no default \- this must be provided to read a file
.Sp
\&\fBRequired:\fR yes
.Sp
\&\fBRange:\fR any unencrypted xml file name and path or IO::File file handle set to
read.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBset_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR change the file value in the attribute (this will reboot
the file instance and should lock the file)
.RE
.RE
.RS 4
.Sp
\&\fBget_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR Returns the file handle of the file even if a file name
was passed
.RE
.RE
.RS 4
.Sp
\&\fBhas_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR this is used to see if the file loaded correctly.
.RE
.RE
.RS 4
.Sp
\&\fBclear_file\fR
.Sp
.RS 4
\&\fBDefinition:\fR this clears (and unlocks) the file handle
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBDelegated Methods\fR
.Sp
.RS 4
close
.Sp
.RS 4
closes the file handle
.RE
.RE
.RS 4
.Sp
seek
.Sp
.RS 4
allows seek commands to be passed to the file handle
.RE
.RE
.RS 4
.Sp
getline
.Sp
.RS 4
returns the next line of the file handle with '<' set as the
input_record_separator ($/) <http://perldoc.perl.org/perlvar.html>
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIsheet_type\fR
.IX Subsection "sheet_type"
.Sp
.RS 4
\&\fBDefinition:\fR This is the sheet 'type' which will always be 'worksheet'
(as opposed to chartsheet)
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_sheet_type\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute (worsheet)
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIsheet_rel_id\fR
.IX Subsection "sheet_rel_id"
.Sp
.RS 4
\&\fBDefinition:\fR This is the relId of the sheet listed in the \s-1XML\s0 of the .xlsx file.
You probably don't care and you should never set this value.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBrel_id\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIsheet_id\fR
.IX Subsection "sheet_id"
.Sp
.RS 4
\&\fBDefinition:\fR This is the Id of the sheet listed in the \s-1XML\s0 of the .xlsx file.
I beleive this to be the number used in vbscript to reference the sheet.  You
should never set this value.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBsheet_id\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIsheet_position\fR
.IX Subsection "sheet_position"
.Sp
.RS 4
\&\fBDefinition:\fR This is the visual sheet position in the .xlsx file.
You should never set this value.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBposition\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIsheet_name\fR
.IX Subsection "sheet_name"
.Sp
.RS 4
\&\fBDefinition:\fR This is the visual sheet name in the .xlsx file
on the tab.  You should never set this value.
.Sp
\&\fBattribute methods\fR Methods provided to adjust this attribute
.Sp
.RS 4
\&\fBget_name\fR
.Sp
.RS 4
\&\fBDefinition:\fR returns the value stored in the attribute
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fIworkbook_instance\fR
.IX Subsection "workbook_instance"
.Sp
.RS 4
\&\fBDefinition:\fR This attribute holds a reference back to the workbook instance so that
the worksheet has access to the global settings managed there.  As a consequence many
of the workbook methods are be exposed here.  This includes some setter methods for
workbook attributes. \fIBeware that setting or adjusting the workbook level attributes
with methods here will be universal and affect other worksheets.  So don't forget to
return the old value if you want the old behavour after you are done.\fR  If that
doesn't make sense then don't use these methods.  (Nothing to see here! Move along.)
.Sp
\&\fBDefault:\fR a Spreadsheet::Reader::ExcelXML::Workbook instance
.Sp
\&\fBattribute methods\fR Methods used to change the workbook instance
.Sp
.RS 4
\&\fBset_workbook_inst\fR
.Sp
.RS 4
\&\fBDefinition:\fR Sets the attribute with a new workbook instance
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
\&\fBDelegated attribute methods\fR Since this list can float please follow the link

to the documented delegations in that file.
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Spreadsheet::Reader::ExcelXML/issues
 <https://github.com/jandrew/p5-spreadsheet-reader-excelxml/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Nothing Yet <https://github.com/jandrew/p5-spreadsheet-reader-excelxml/issues>!
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2016 by Jed Lund
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.RS 4
Spreadsheet::Reader::ExcelXML \- the package
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Spreadsheet::Read \- generic Spreadsheet reader
.Sp
Spreadsheet::ParseExcel \- Excel binary version 2003 and earlier (.xls files)
.Sp
Spreadsheet::XLSX \- Excel version 2007 and later
.Sp
Spreadsheet::ParseXLSX \- Excel version 2007 and later
.Sp
Log::Shiras <https://github.com/jandrew/Log-Shiras>
.Sp
.RS 4
All lines in this package that use Log::Shiras are commented out
.RE
.RE
.RS 4
.RE
