.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "POE::Driver 3"
.TH POE::Driver 3 "2020-02-01" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
POE::Driver \- an abstract interface for buffered, non\-blocking I/O
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is a contrived example of how POE::Filter and POE::Driver objects
may be used in a stand-alone application.
.PP
.Vb 2
\&  my $driver = POE::Driver::SysRW\->new();
\&  my $filter = POE::Filter::Line\->new();
\&
\&  my $list_of_octet_chunks = $filter\->put("A line of text.");
\&
\&  $driver\->put( $list_of_octet_chunks );
\&
\&  my $octets_remaining_in_buffer = $driver\->flush($filehandle);
\&  die "couldn\*(Aqt flush everything" if $octets_remaining_in_buffer;
\&
\&  while (1) {
\&    my $octets_list = $driver\->get($filehandle);
\&    die $! unless defined $octets_list;
\&
\&    $filter\->get_one_start($octets_list);
\&    while (my $line = $filter\->get_one()) {
\&      print "Input: $line\en";
\&    }
\&  }
.Ve
.PP
Most programs will use POE::Filter and POE::Driver objects as
parameters to POE::Wheel constructors.  See the synopses for
particular classes for details.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Driver is a common \s-1API\s0 for I/O drivers that can read from and
write to various files, sockets, pipes, and other devices.
.PP
\&\s-1POE\s0 \*(L"drivers\*(R" implement the specifics of reading and writing to
devices.  Drivers plug into POE::Wheel objects so that wheels may
support a large number of device types without implementing a separate
subclass for each.
.PP
As mentioned in the \s-1SYNOPSIS,\s0 POE::Driver objects may be used in
stand-alone applications.
.SS "Public Driver Methods"
.IX Subsection "Public Driver Methods"
These methods are the generic Driver interface, and every driver must
implement them.  Specific drivers may have additional methods related
to their particular tasks.
.PP
\fInew\fR
.IX Subsection "new"
.PP
\&\fBnew()\fR creates, initializes, and returns a new driver.  Specific
drivers may have different constructor parameters.  The default
constructor parameters should configure the driver for the most common
use case.
.PP
\fIget \s-1FILEHANDLE\s0\fR
.IX Subsection "get FILEHANDLE"
.PP
\&\fBget()\fR immediately tries to read information from a \s-1FILEHANDLE.\s0  It
returns an array reference on success\-\-\-even if nothing was read from
the \s-1FILEHANDLE.\s0  \fBget()\fR returns undef on error, and $! will be set to
the reason why \fBget()\fR failed.
.PP
The returned arrayref will be empty if nothing was read from the
\&\s-1FILEHANDLE.\s0
.PP
In an \s-1EOF\s0 condition, \fBget()\fR returns undef with the numeric value of $!
set to zero.
.PP
The arrayref returned by \fBget()\fR is suitable for passing to any
POE::Filter's \fBget()\fR or \fBget_one_start()\fR method.  Wheels do exactly this
internally.
.IP "put \s-1ARRAYREF\s0" 4
.IX Item "put ARRAYREF"
\&\fBput()\fR accepts an \s-1ARRAYREF\s0 of raw octet chunks.  These octets are added
to the driver's internal output queue or buffer.  \fBput()\fR returns the
number of octets pending output after the new octets are buffered.
.Sp
Some drivers may flush data immediately from their \fBput()\fR methods.
.IP "flush \s-1FILEHANDLE\s0" 4
.IX Item "flush FILEHANDLE"
\&\fBflush()\fR attempts to write a driver's buffered data to a given
\&\s-1FILEHANDLE.\s0  The driver should flush as much data as possible in a
single \fBflush()\fR call.
.Sp
\&\fBflush()\fR returns the number of octets remaining in the driver's output
queue or buffer after the maximum amount of data has been written.
.Sp
\&\fBflush()\fR denotes success or failure by the value of $! after it
returns.  $! will always numerically equal zero on success.  On
failure, $! will contain the usual Errno value.  In either case,
\&\fBflush()\fR will return the number of octets in the driver's output queue.
.IP "get_out_messages_buffered" 4
.IX Item "get_out_messages_buffered"
\&\fBget_out_messages_buffered()\fR returns the number of messages enqueued in
the driver's output queue, rounded up to the nearest whole message.
Some applications require the message count rather than the octet
count.
.Sp
Messages are raw octet chunks enqueued by \fBput()\fR.  The following \fBput()\fR
call enqueues two messages for a total of six octets:
.Sp
.Vb 1
\&  $filter\->put( [ "one", "two" ] );
.Ve
.Sp
It is possible for a \fBflush()\fR call to write part of a message.  A
partial message still counts as one message.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1SEE ALSO\s0 section in \s-1POE\s0 contains a table of contents covering
the entire \s-1POE\s0 distribution.
.PP
POE::Wheel \- A base class for POE::Session mix-ins.
.PP
POE::Filter \- A base class for data parsers and serializers.
.PP
POE::Driver::SysRW \- A driver that encapsulates \fBsysread()\fR and
buffered \fBsyswrite()\fR.
.SH "BUGS"
.IX Header "BUGS"
There is no POE::Driver::SendRecv, but nobody has needed one so far.
\&\fBsysread()\fR and \fBsyswrite()\fR manage to do almost everything people need.
.PP
In theory, drivers should be pretty much interchangeable.  In
practice, there seems to be an impermeable barrier between the
different SOCK_* types.
.SH "AUTHORS & COPYRIGHTS"
.IX Header "AUTHORS & COPYRIGHTS"
Please see \s-1POE\s0 for more information about authors and contributors.
