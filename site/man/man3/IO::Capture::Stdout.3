.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Capture::Stdout 3"
.TH IO::Capture::Stdout 3 "2005-04-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Capture::Stdout \- Capture any output sent to STDOUT
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Generic example (Just to give the overall view)
\&    use IO::Capture::Stdout;
\&
\&    $capture = IO::Capture::Stdout\->new();
\&
\&    $capture\->start();          # STDOUT Output captured
\&    print STDOUT "Test Line One\en";
\&    print STDOUT "Test Line Two\en";
\&    print STDOUT "Test Line Three\en";
\&    $capture\->stop();           # STDOUT output sent to wherever it was before \*(Aqstart\*(Aq
\&
\&    # In \*(Aqscalar context\*(Aq returns next line
\&    $line = $capture\->read;
\&    print "$line";         # prints "Test Line One"
\&
\&    $line = $capture\->read;
\&    print "$line";         # prints "Test Line Two"
\&
\&    # move line pointer to line 1
\&    $capture\->line_pointer(1);
\&
\&    $line = $capture\->read;
\&    print "$line";         # prints "Test Line One"
\&
\&    # Find out current line number
\&    $current_line_position = $capture\->line_pointer;
\&
\&    # In \*(AqList Context\*(Aq return an array(list)
\&    @all_lines = $capture\->read;
\&
\&    # More useful example 1 \- "Using in module tests"
\&    #  Note: If you don\*(Aqt want to make users install 
\&    #        the IO::Capture module just for your tests,
\&    #        you can just install in the t/lib directory
\&    #        of your module and use the lib pragma in  
\&    #        your tests. 
\&
\&    use lib "t/lib";
\&    use IO::Capture::Stdout;
\&
\&    use Test::More;
\&
\&    my $capture =  IO::Capture::Stdout\->new;
\&    $capture\->start
\&
\&    # execute with a bad parameter to make sure get
\&    # an error.
\&
\&    ok( ! $test("Bad Parameter") );
\&
\&    $capture\->stop();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module \f(CW\*(C`IO::Capture::Stdout\*(C'\fR, is derived from the abstract class \f(CW\*(C`IO::Capture\*(C'\fR.
See IO::Capture. The purpose of the module (as the name suggests) is to capture 
any output sent to \f(CW\*(C`STDOUT\*(C'\fR.  After the capture is stopped, the \s-1STDOUT\s0 filehandle 
will be reset to the previous location. E.g., If previously redirected to a file, when 
\&\f(CW\*(C`IO::Capture\->stop\*(C'\fR is called, output will start going into that file again.
.PP
Note:  This module won't work with the perl function, \fBsystem()\fR, or any other operation 
       involving a \fBfork()\fR.  If you want to capture the output from a system command,
       it is faster to use \fBopen()\fR or back-ticks.
.PP
.Vb 1
\&       my $output = \`/usr/sbin/ls \-l 2>&1\`;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.IP "\(bu" 4
Creates a new capture object.
.IP "\(bu" 4
An object can be reused as needed, so will only need to do one of these.
.RS 4
.IP "\(bu" 4
Be aware, any data previously captured will be discarded if a new 
capture session is started.
.RE
.RS 4
.RE
.SS "start"
.IX Subsection "start"
.IP "\(bu" 4
Start capturing data into the \f(CW\*(C`IO::Capture\*(C'\fR Object.
.IP "\(bu" 4
Can \fBnot\fR be called on an object that is already capturing.
.IP "\(bu" 4
Can \fBnot\fR be called while \s-1STDOUT\s0 tied to an object.
.IP "\(bu" 4
\&\f(CW\*(C`undef\*(C'\fR will be returned on an error.
.SS "stop"
.IX Subsection "stop"
.IP "\(bu" 4
Stop capturing data and point \s-1STDOUT\s0 back to it's previous output location
I.e., untie \s-1STDOUT\s0
.SS "read"
.IX Subsection "read"
.IP "\(bu" 4
In \fIScalar Context\fR
.RS 4
.IP "\(bu" 4
Lines are read from the buffer at the position of the \f(CW\*(C`line_pointer\*(C'\fR, 
and the pointer is incremented by one.
.Sp
.Vb 1
\&    $next_line = $capture\->read;
.Ve
.RE
.RS 4
.RE
.IP "\(bu" 4
In \fIList Context\fR
.RS 4
.IP "\(bu" 4
The array is returned.  The \f(CW\*(C`line_pointer\*(C'\fR is not affected.
.Sp
.Vb 1
\&    @buffer = $capture\->read;
.Ve
.RE
.RS 4
.RE
.IP "\(bu" 4
Data lines are returned exactly as they were captured.  You may want 
to use \f(CW\*(C`chomp\*(C'\fR on them if you don't want the end of line character(s)
.Sp
.Vb 4
\&    while (my $line = $capture\->read) {
\&        chomp $line;
\&        $cat_line = join \*(Aq\*(Aq, $cat_line, $line;
\&    }
.Ve
.SS "line_pointer"
.IX Subsection "line_pointer"
.IP "\(bu" 4
Reads or sets the \f(CW\*(C`line_pointer\*(C'\fR.
.Sp
.Vb 2
\&    my $current_line = $capture\->line_pointer;
\&    $capture\->line_pointer(1);
.Ve
.SH "SUB-CLASSING"
.IX Header "SUB-CLASSING"
.SS "Adding Features"
.IX Subsection "Adding Features"
If you would like to sub-class this module to add a feature (method) or two,
here is a couple of easy steps. Also see IO::Capture::Overview.
.IP "1." 4
Give your package a name
.Sp
.Vb 1
\&    package MyPackage;
.Ve
.IP "2." 4
Use this \f(CW\*(C`IO::Capture::Stdout\*(C'\fR as your base class like this:
.Sp
.Vb 1
\&    package MyPackage;
\&
\&    use base qw/IO::Capture::Stdout/;
.Ve
.IP "3." 4
Add your new method like this
.Sp
.Vb 1
\&    package MyPackage;
\&
\&    use base qw/IO::Capture::Stdout/;
\&
\&    sub grep {
\&        my $self = shift;
\&
\&        for $line (
\&    }
.Ve
.SH "See Also"
.IX Header "See Also"
IO::Capture::Overview
.PP
IO::Capture
.PP
IO::Capture::Stderr
.SH "AUTHORS"
.IX Header "AUTHORS"
Mark Reynolds
reynolds@sgi.com
.PP
Jon Morgan
jmorgan@sgi.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003, Mark Reynolds. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as Perl itself.
