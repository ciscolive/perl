.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::JavaScript::Anon 3"
.TH Data::JavaScript::Anon 3 "2009-04-20" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::JavaScript::Anon \- Dump big dumb Perl structs to anonymous JavaScript structs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Dump an arbitrary structure to javascript
\&  Data::JavaScript::Anon\->anon_dump( [ \*(Aqa\*(Aq, \*(Aqb\*(Aq, { a => 1, b => 2 } ] );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::JavaScript::Anon provides the ability to dump large simple data
structures to JavaScript. That is, things that don't need to be a class,
or have special methods or whatever.
.PP
The method it uses is to write anonymous variables, in the same way you
would in Perl. The following shows some examples.
.PP
.Vb 2
\&  # Perl anonymous array
\&  [ 1, \*(Aqa\*(Aq, \*(AqFoo Bar\*(Aq ]
\&  
\&  # JavaScript equivalent ( yes, it\*(Aqs exactly the same )
\&  [ 1, \*(Aqa\*(Aq, \*(AqFoo Bar\*(Aq ]
\&  
\&  # Perl anonymous hash
\&  { foo => 1, bar => \*(Aqbar\*(Aq }
\&  
\&  # JavaScript equivalent
\&  { foo: 1, bar: \*(Aqbar\*(Aq }
.Ve
.PP
One advantage of doing it in this method is that you do not have to
co-ordinate variable names between your \s-1HTML\s0 templates and Perl. You
could use a simple Template Toolkit phrase like the following to get
data into your \s-1HTML\s0 templates.
.PP
.Vb 1
\&  var javascript_data = [% data %];
.Ve
.PP
In this way, it doesn't matter \s-1WHAT\s0 the \s-1HTML\s0 template calls a
particular variables, the data dumps just the same. This could help
you keep the work of JavaScript and Perl programmers ( assuming you
were using different people ) seperate, without creating 
cross-dependencies between their code, such as variable names.
.PP
The variables you dump can also be of arbitrary depth and complexity,
with a few limitations.
.IP "\s-1ARRAY\s0 and \s-1HASH\s0 only" 4
.IX Item "ARRAY and HASH only"
Since arrays and hashs are all that is supported by JavaScript, they
are the only things you can use in your structs. Any references or a
different underlying type will be detected and an error returned.
.Sp
Note that Data::JavaScript::Anon will use the \s-1UNDERLYING\s0 type of the
data. This means that the blessed classes or objects will be ignored
and their data based on the object's underlying implementation type.
.Sp
This can be a positive thing, as you can put objects for which you expect
a certain dump structure into the data to dump, and it will convert to 
unblessed, more stupid, JavaScript objects cleanly.
.IP "No Circular References" 4
.IX Item "No Circular References"
Since circular references can't be defined in a single anonymous struct,
they are not allowed. Try something like Data::JavaScript instead.
Although not supported, they will be detected, and an error returned.
.SH "MAIN METHODS"
.IX Header "MAIN METHODS"
All methods are called as methods directly, in the form
\&\f(CW\*(C`Data::JavaScript::Anon\->anon_dump( [ \*(Aqetc\*(Aq ] )\*(C'\fR.
.SS "anon_dump \s-1STRUCT\s0"
.IX Subsection "anon_dump STRUCT"
The main method of the class, anon_dump takes a single arbitrary data
struct, and converts it into an anonymous JavaScript struct.
.PP
If needed, the argument can even be a normal text string, although it
wouldn't do a lot to it. :)
.PP
Returns a string containing the JavaScript struct on success, or \f(CW\*(C`undef\*(C'\fR
if an error is found.
.ie n .SS "var_dump $name, \s-1STRUCT\s0"
.el .SS "var_dump \f(CW$name\fP, \s-1STRUCT\s0"
.IX Subsection "var_dump $name, STRUCT"
As above, but the \f(CW\*(C`var_dump\*(C'\fR method allows you to specify a variable name,
with the resulting JavaScript being \f(CW\*(C`var name = struct;\*(C'\fR. Note that the
method \s-1WILL\s0 put the trailing semi-colon on the string.
.ie n .SS "script_wrap $javascript"
.el .SS "script_wrap \f(CW$javascript\fP"
.IX Subsection "script_wrap $javascript"
The \f(CW\*(C`script_wrap\*(C'\fR method is a quick way of wrapping a normal JavaScript html
tag around your JavaScript.
.ie n .SS "is_a_number $scalar"
.el .SS "is_a_number \f(CW$scalar\fP"
.IX Subsection "is_a_number $scalar"
When generating the javascript, numbers will be printed directly and not
quoted. The \f(CW\*(C`is_a_number\*(C'\fR method provides convenient access to the test
that is used to see if something is a number. The test handles just about
everything legal in JavaScript, with the one exception of the exotics, such
as Infinite, \-Infinit and NaN.
.PP
Returns true is a scalar is numeric, or false otherwise.
.PP
You may also access method in using an instantiated object.
.SS "new \s-1HASH\s0"
.IX Subsection "new HASH"
This will create a Data::JavaScript::Anon object that will allow you to change
some of the default behaviors of some methods.
.PP
.Vb 2
\&    Options:
\&        quote_char  : Set the quote_char for stirng scalars. Default is \*(Aq"\*(Aq.
.Ve
.SH "SECONDARY METHODS"
.IX Header "SECONDARY METHODS"
The following are a little less general, but may be of some use.
.ie n .SS "var_scalar $name, \e$scalar"
.el .SS "var_scalar \f(CW$name\fP, \e$scalar"
.IX Subsection "var_scalar $name, $scalar"
Creates a named variable from a scalar reference.
.ie n .SS "var_array $name, \e@array"
.el .SS "var_array \f(CW$name\fP, \e@array"
.IX Subsection "var_array $name, @array"
Creates a named variable from an array reference.
.ie n .SS "var_hash $name, \e%hash"
.el .SS "var_hash \f(CW$name\fP, \e%hash"
.IX Subsection "var_hash $name, %hash"
Creates a named variable from a hash reference.
.SS "anon_scalar \e$scalar"
.IX Subsection "anon_scalar $scalar"
Creates an anonymous JavaScript value from a scalar reference.
.SS "anon_array \e@array"
.IX Subsection "anon_array @array"
Creates an anonymous JavaScript array from an array reference.
.SS "anon_hash \e%hash"
.IX Subsection "anon_hash %hash"
Creates an anonymous JavaScript object from a hash reference.
.ie n .SS "anon_hash_key $value"
.el .SS "anon_hash_key \f(CW$value\fP"
.IX Subsection "anon_hash_key $value"
Applys the formatting for a key in a JavaScript object
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be reported via the \s-1CPAN\s0 bug tracker at:
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data\-JavaScript\-Anon>
.PP
For other comments or queries, contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1JSON\s0, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2009 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
