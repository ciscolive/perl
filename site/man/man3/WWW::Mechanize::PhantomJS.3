.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "WWW::Mechanize::PhantomJS 3"
.TH WWW::Mechanize::PhantomJS 3 "2020-09-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::Mechanize::PhantomJS \- automate the PhantomJS browser
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use WWW::Mechanize::PhantomJS;
\&  my $mech = WWW::Mechanize::PhantomJS\->new();
\&  $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&
\&  $mech\->eval_in_page(\*(Aqalert("Hello PhantomJS")\*(Aq);
\&  my $png= $mech\->content_as_png();
.Ve
.ie n .SS """WWW::Mechanize::PhantomJS\->new %options"""
.el .SS "\f(CWWWW::Mechanize::PhantomJS\->new %options\fP"
.IX Subsection "WWW::Mechanize::PhantomJS->new %options"
.Vb 1
\&  my $mech = WWW::Mechanize::PhantomJS\->new();
.Ve
.IP "\fBautodie\fR" 4
.IX Item "autodie"
Control whether \s-1HTTP\s0 errors are fatal.
.Sp
.Vb 1
\&  autodie => 0, # make HTTP errors non\-fatal
.Ve
.Sp
The default is to have \s-1HTTP\s0 errors fatal,
as that makes debugging much easier than expecting
you to actually check the results of every action.
.IP "\fBport\fR" 4
.IX Item "port"
Specify the port where PhantomJS should listen
.Sp
.Vb 1
\&  port => 8910
.Ve
.IP "\fBlog\fR" 4
.IX Item "log"
Specify the log level of PhantomJS
.Sp
.Vb 1
\&  log => \*(AqOFF\*(Aq   # Also INFO, WARN, DEBUG
.Ve
.IP "\fBlaunch_exe\fR" 4
.IX Item "launch_exe"
Specify the path to the PhantomJS executable.
.Sp
The default is \f(CW\*(C`phantomjs\*(C'\fR as found via \f(CW$ENV{PATH}\fR.
You can also provide this information from the outside
by setting \f(CW$ENV{PHANTOMJS_EXE}\fR.
.IP "\fBphantomjs_arg\fR" 4
.IX Item "phantomjs_arg"
Additional command line arguments to \f(CW\*(C`phantomjs\*(C'\fR.  (phantomjs \-h)
.Sp
.Vb 1
\&  phantomjs_arg => ["\-\-proxy=$ENV{HTTP_PROXY}"]
.Ve
.IP "\fBlaunch_ghostdriver\fR" 4
.IX Item "launch_ghostdriver"
Filename of the \f(CW\*(C`ghostdriver\*(C'\fR Javascript code
to launch. The default is the file distributed with this module.
.Sp
.Vb 1
\&  launch_ghostdriver => "devel/my/ghostdriver/main.js",
.Ve
.IP "\fBlaunch_arg\fR" 4
.IX Item "launch_arg"
Specify additional parameters to the Ghostdriver script.
.Sp
.Vb 1
\&  launch_arg => [ "\-\-some\-new\-parameter=foo" ],
.Ve
.Sp
Some interesting parameters are:
.Sp
.Vb 4
\&  "\-\-webdriver=$port",
\&  \*(Aq\-\-webdriver\-logfile=/tmp/webdriver\*(Aq,
\&  \*(Aq\-\-webdriver\-loglevel=DEBUG\*(Aq,
\&  \*(Aq\-\-debug=true\*(Aq,
\&
\&  note: these set config.xxx values in ghostrdriver/config.js
.Ve
.IP "\fBcookie_file\fR" 4
.IX Item "cookie_file"
Cookies are not directly persisted. If you pass in a path here,
that file will be used to store or retrieve cookies.
.IP "\fBignore_ssl_errors\fR" 4
.IX Item "ignore_ssl_errors"
If you want \f(CW\*(C`phantomjs\*(C'\fR to ignore \s-1SSL\s0 errors, pass a true value here.
.IP "\fBdriver\fR" 4
.IX Item "driver"
A premade Selenium::Remote::Driver object.
.IP "\fBreport_js_errors\fR" 4
.IX Item "report_js_errors"
If set to 1, after each request tests for Javascript errors and warns. Useful
for testing with \f(CW\*(C`use warnings qw(fatal)\*(C'\fR.
.ie n .SS """$mech\->phantomjs_version"""
.el .SS "\f(CW$mech\->phantomjs_version\fP"
.IX Subsection "$mech->phantomjs_version"
.Vb 1
\&  print $mech\->phantomjs_version;
.Ve
.PP
Returns the version of the PhantomJS executable that is used.
.ie n .SS """$mech\->ghostdriver_version"""
.el .SS "\f(CW$mech\->ghostdriver_version\fP"
.IX Subsection "$mech->ghostdriver_version"
.Vb 1
\&  print $mech\->ghostdriver_version;
.Ve
.PP
Returns the version of the ghostdriver script that is used.
.ie n .SS """$mech\->driver"""
.el .SS "\f(CW$mech\->driver\fP"
.IX Subsection "$mech->driver"
.Vb 1
\&    my $selenium= $mech\->driver
.Ve
.PP
Access the Selenium::Driver::Remote instance connecting to PhantomJS.
.ie n .SS """$mech\->js_alerts()"""
.el .SS "\f(CW$mech\->js_alerts()\fP"
.IX Subsection "$mech->js_alerts()"
.Vb 1
\&  print for $mech\->js_alerts();
.Ve
.PP
An interface to the Javascript Alerts
.PP
Returns the list of alerts
.ie n .SS """$mech\->clear_js_alerts()"""
.el .SS "\f(CW$mech\->clear_js_alerts()\fP"
.IX Subsection "$mech->clear_js_alerts()"
.Vb 1
\&    $mech\->clear_js_alerts();
.Ve
.PP
Clears all saved alerts
.ie n .SS """$mech\->js_errors()"""
.el .SS "\f(CW$mech\->js_errors()\fP"
.IX Subsection "$mech->js_errors()"
.Vb 2
\&  print $_\->{message}
\&      for $mech\->js_errors();
.Ve
.PP
An interface to the Javascript Error Console
.PP
Returns the list of errors in the \s-1JEC\s0
.PP
Maybe this should be called \f(CW\*(C`js_messages\*(C'\fR or
\&\f(CW\*(C`js_console_messages\*(C'\fR instead.
.ie n .SS """$mech\->clear_js_errors()"""
.el .SS "\f(CW$mech\->clear_js_errors()\fP"
.IX Subsection "$mech->clear_js_errors()"
.Vb 1
\&    $mech\->clear_js_errors();
.Ve
.PP
Clears all Javascript messages from the console
.ie n .SS """$mech\->confirm( \*(AqReally do this?\*(Aq [ => 1 ])"""
.el .SS "\f(CW$mech\->confirm( \*(AqReally do this?\*(Aq [ => 1 ])\fP"
.IX Subsection "$mech->confirm( Really do this? [ => 1 ])"
Records a confirmation (which is \*(L"1\*(R" or \*(L"ok\*(R" by default), to be used
whenever javascript fires a confirm dialog. If the message is not found,
the answer is \*(L"cancel\*(R".
.ie n .SS """$mech\->eval_in_page( $str, @args )"""
.el .SS "\f(CW$mech\->eval_in_page( $str, @args )\fP"
.IX Subsection "$mech->eval_in_page( $str, @args )"
.ie n .SS """$mech\->eval( $str, @args )"""
.el .SS "\f(CW$mech\->eval( $str, @args )\fP"
.IX Subsection "$mech->eval( $str, @args )"
.Vb 1
\&  my ($value, $type) = $mech\->eval( \*(Aq2+2\*(Aq );
.Ve
.PP
Evaluates the given Javascript fragment in the
context of the web page.
Returns a pair of value and Javascript type.
.PP
This allows access to variables and functions declared
\&\*(L"globally\*(R" on the web page.
.PP
This method is special to WWW::Mechanize::PhantomJS.
.ie n .SS """$mech\->eval_in_phantomjs $code, @args"""
.el .SS "\f(CW$mech\->eval_in_phantomjs $code, @args\fP"
.IX Subsection "$mech->eval_in_phantomjs $code, @args"
.Vb 3
\&  $mech\->eval_in_phantomjs(<<\*(AqJS\*(Aq, "Foobar/1.0");
\&      this.settings.userAgent= arguments[0]
\&  JS
.Ve
.PP
Evaluates Javascript code in the context of PhantomJS.
.PP
This allows you to modify properties of PhantomJS.
.ie n .SS """$mech\->highlight_node( @nodes )"""
.el .SS "\f(CW$mech\->highlight_node( @nodes )\fP"
.IX Subsection "$mech->highlight_node( @nodes )"
.Vb 3
\&    my @links = $mech\->selector(\*(Aqa\*(Aq);
\&    $mech\->highlight_node(@links);
\&    print $mech\->content_as_png();
.Ve
.PP
Convenience method that marks all nodes in the arguments
with
.PP
.Vb 3
\&  background: red;
\&  border: solid black 1px;
\&  display: block; /* if the element was display: none before */
.Ve
.PP
This is convenient if you need visual verification that you've
got the right nodes.
.PP
There currently is no way to restore the nodes to their original
visual state except reloading the page.
.SH "NAVIGATION METHODS"
.IX Header "NAVIGATION METHODS"
.ie n .SS """$mech\->get( $url, %options )"""
.el .SS "\f(CW$mech\->get( $url, %options )\fP"
.IX Subsection "$mech->get( $url, %options )"
.Vb 1
\&  $mech\->get( $url  );
.Ve
.PP
Retrieves the \s-1URL\s0 \f(CW\*(C`URL\*(C'\fR.
.PP
It returns a faked HTTP::Response object for interface compatibility
with WWW::Mechanize. It seems that Selenium and thus Selenium::Remote::Driver
have no concept of \s-1HTTP\s0 status code and thus no way of returning the
\&\s-1HTTP\s0 status code.
.PP
Note that PhantomJs does not support download of files.
.ie n .SS """$mech\->get_local( $filename , %options )"""
.el .SS "\f(CW$mech\->get_local( $filename , %options )\fP"
.IX Subsection "$mech->get_local( $filename , %options )"
.Vb 1
\&  $mech\->get_local(\*(Aqtest.html\*(Aq);
.Ve
.PP
Shorthand method to construct the appropriate
\&\f(CW\*(C`file://\*(C'\fR \s-1URI\s0 and load it into PhantomJS. Relative
paths will be interpreted as relative to \f(CW$0\fR.
.PP
This method accepts the same options as \f(CW\*(C`\->get()\*(C'\fR.
.PP
This method is special to WWW::Mechanize::PhantomJS but could
also exist in WWW::Mechanize through a plugin.
.PP
\&\fBWarning\fR: PhantomJs does not handle local files well. Especially
subframes do not get loaded properly.
.ie n .SS """$mech\->post( $url, %options )"""
.el .SS "\f(CW$mech\->post( $url, %options )\fP"
.IX Subsection "$mech->post( $url, %options )"
\&\fBnot implemented\fR
.PP
Selenium currently does not allow a raw \s-1POST\s0 message
and the code for constructing a form on the fly is not working
so this method is not implemented.
.PP
.Vb 7
\&  $mech\->post( \*(Aqhttp://example.com\*(Aq,
\&      params => { param => "Hello World" },
\&      headers => {
\&        "Content\-Type" => \*(Aqapplication/x\-www\-form\-urlencoded\*(Aq,
\&      },
\&      charset => \*(Aqutf\-8\*(Aq,
\&  );
.Ve
.PP
Sends a \s-1POST\s0 request to \f(CW$url\fR.
.PP
A \f(CW\*(C`Content\-Length\*(C'\fR header will be automatically calculated if
it is not given.
.PP
The following options are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR \- a hash of \s-1HTTP\s0 headers to send. If not given,
the content type will be generated automatically.
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR \- the raw data to send, if you've encoded it already.
.ie n .SS """$mech\->add_header( $name => $value, ... )"""
.el .SS "\f(CW$mech\->add_header( $name => $value, ... )\fP"
.IX Subsection "$mech->add_header( $name => $value, ... )"
.Vb 4
\&    $mech\->add_header(
\&        \*(AqX\-WWW\-Mechanize\-PhantomJS\*(Aq => "I\*(Aqm using it",
\&        Encoding => \*(Aqtext/klingon\*(Aq,
\&    );
.Ve
.PP
This method sets up custom headers that will be sent with \fBevery\fR \s-1HTTP\s0(S)
request that PhantomJS makes.
.PP
Note that currently, we only support one value per header.
.ie n .SS """$mech\->delete_header( $name , $name2... )"""
.el .SS "\f(CW$mech\->delete_header( $name , $name2... )\fP"
.IX Subsection "$mech->delete_header( $name , $name2... )"
.Vb 1
\&    $mech\->delete_header( \*(AqUser\-Agent\*(Aq );
.Ve
.PP
Removes \s-1HTTP\s0 headers from the agent's list of special headers. Note
that PhantomJS may still send a header with its default value.
.ie n .SS """$mech\->reset_headers"""
.el .SS "\f(CW$mech\->reset_headers\fP"
.IX Subsection "$mech->reset_headers"
.Vb 1
\&    $mech\->reset_headers();
.Ve
.PP
Removes all custom headers and makes PhantomJS send its defaults again.
.ie n .SS """$mech\->res()"" / ""$mech\->response(%options)"""
.el .SS "\f(CW$mech\->res()\fP / \f(CW$mech\->response(%options)\fP"
.IX Subsection "$mech->res() / $mech->response(%options)"
.Vb 1
\&    my $response = $mech\->response(headers => 0);
.Ve
.PP
Returns the current response as a HTTP::Response object.
.ie n .SS """$mech\->success()"""
.el .SS "\f(CW$mech\->success()\fP"
.IX Subsection "$mech->success()"
.Vb 3
\&    $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&    print "Yay"
\&        if $mech\->success();
.Ve
.PP
Returns a boolean telling whether the last request was successful.
If there hasn't been an operation yet, returns false.
.PP
This is a convenience function that wraps \f(CW\*(C`$mech\->res\->is_success\*(C'\fR.
.ie n .SS """$mech\->status()"""
.el .SS "\f(CW$mech\->status()\fP"
.IX Subsection "$mech->status()"
.Vb 3
\&    $mech\->get(\*(Aqhttp://google.com\*(Aq);
\&    print $mech\->status();
\&    # 200
.Ve
.PP
Returns the \s-1HTTP\s0 status code of the response.
This is a 3\-digit number like 200 for \s-1OK, 404\s0 for not found, and so on.
.ie n .SS """$mech\->back()"""
.el .SS "\f(CW$mech\->back()\fP"
.IX Subsection "$mech->back()"
.Vb 1
\&    $mech\->back();
.Ve
.PP
Goes one page back in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->forward()"""
.el .SS "\f(CW$mech\->forward()\fP"
.IX Subsection "$mech->forward()"
.Vb 1
\&    $mech\->forward();
.Ve
.PP
Goes one page forward in the page history.
.PP
Returns the (new) response.
.ie n .SS """$mech\->uri()"""
.el .SS "\f(CW$mech\->uri()\fP"
.IX Subsection "$mech->uri()"
.Vb 1
\&    print "We are at " . $mech\->uri;
.Ve
.PP
Returns the current document \s-1URI.\s0
.SH "CONTENT METHODS"
.IX Header "CONTENT METHODS"
.ie n .SS """$mech\->document()"""
.el .SS "\f(CW$mech\->document()\fP"
.IX Subsection "$mech->document()"
Returns the document object as a WebElement.
.PP
This is WWW::Mechanize::PhantomJS specific.
.ie n .SS """$mech\->content( %options )"""
.el .SS "\f(CW$mech\->content( %options )\fP"
.IX Subsection "$mech->content( %options )"
.Vb 3
\&  print $mech\->content;
\&  print $mech\->content( format => \*(Aqhtml\*(Aq ); # default
\&  print $mech\->content( format => \*(Aqtext\*(Aq ); # identical to \->text
.Ve
.PP
This always returns the content as a Unicode string. It tries
to decode the raw content according to its input encoding.
This currently only works for \s-1HTML\s0 pages, not for images etc.
.PP
Recognized options:
.IP "\(bu" 4
\&\f(CW\*(C`format\*(C'\fR \- the stuff to return
.Sp
The allowed values are \f(CW\*(C`html\*(C'\fR and \f(CW\*(C`text\*(C'\fR. The default is \f(CW\*(C`html\*(C'\fR.
.ie n .SS """$mech\->text()"""
.el .SS "\f(CW$mech\->text()\fP"
.IX Subsection "$mech->text()"
.Vb 1
\&    print $mech\->text();
.Ve
.PP
Returns the text of the current \s-1HTML\s0 content.  If the content isn't
\&\s-1HTML,\s0 \f(CW$mech\fR will die.
.ie n .SS """$mech\->content_encoding()"""
.el .SS "\f(CW$mech\->content_encoding()\fP"
.IX Subsection "$mech->content_encoding()"
.Vb 1
\&    print "The content is encoded as ", $mech\->content_encoding;
.Ve
.PP
Returns the encoding that the content is in. This can be used
to convert the content from \s-1UTF\-8\s0 back to its native encoding.
.ie n .SS """$mech\->update_html( $html )"""
.el .SS "\f(CW$mech\->update_html( $html )\fP"
.IX Subsection "$mech->update_html( $html )"
.Vb 1
\&  $mech\->update_html($html);
.Ve
.PP
Writes \f(CW$html\fR into the current document. This is mostly
implemented as a convenience method for HTML::Display::MozRepl.
.ie n .SS """$mech\->base()"""
.el .SS "\f(CW$mech\->base()\fP"
.IX Subsection "$mech->base()"
.Vb 1
\&  print $mech\->base;
.Ve
.PP
Returns the \s-1URL\s0 base for the current page.
.PP
The base is either specified through a \f(CW\*(C`base\*(C'\fR
tag or is the current \s-1URL.\s0
.PP
This method is specific to WWW::Mechanize::PhantomJS.
.ie n .SS """$mech\->content_type()"""
.el .SS "\f(CW$mech\->content_type()\fP"
.IX Subsection "$mech->content_type()"
.ie n .SS """$mech\->ct()"""
.el .SS "\f(CW$mech\->ct()\fP"
.IX Subsection "$mech->ct()"
.Vb 1
\&  print $mech\->content_type;
.Ve
.PP
Returns the content type of the currently loaded document
.ie n .SS """$mech\->is_html()"""
.el .SS "\f(CW$mech\->is_html()\fP"
.IX Subsection "$mech->is_html()"
.Vb 1
\&  print $mech\->is_html();
.Ve
.PP
Returns true/false on whether our content is \s-1HTML,\s0 according to the
\&\s-1HTTP\s0 headers.
.ie n .SS """$mech\->title()"""
.el .SS "\f(CW$mech\->title()\fP"
.IX Subsection "$mech->title()"
.Vb 1
\&  print "We are on page " . $mech\->title;
.Ve
.PP
Returns the current document title.
.SH "EXTRACTION METHODS"
.IX Header "EXTRACTION METHODS"
.ie n .SS """$mech\->links()"""
.el .SS "\f(CW$mech\->links()\fP"
.IX Subsection "$mech->links()"
.Vb 2
\&  print $_\->text . " \-> " . $_\->url . "\en"
\&      for $mech\->links;
.Ve
.PP
Returns all links in the document as WWW::Mechanize::Link objects.
.PP
Currently accepts no parameters. See \f(CW\*(C`\->xpath\*(C'\fR
or \f(CW\*(C`\->selector\*(C'\fR when you want more control.
.ie n .SS """$mech\->selector( $css_selector, %options )"""
.el .SS "\f(CW$mech\->selector( $css_selector, %options )\fP"
.IX Subsection "$mech->selector( $css_selector, %options )"
.Vb 1
\&  my @text = $mech\->selector(\*(Aqp.content\*(Aq);
.Ve
.PP
Returns all nodes matching the given \s-1CSS\s0 selector. If
\&\f(CW$css_selector\fR is an array reference, it returns
all nodes matched by any of the \s-1CSS\s0 selectors in the array.
.PP
This takes the same options that \f(CW\*(C`\->xpath\*(C'\fR does.
.PP
This method is implemented via WWW::Mechanize::Plugin::Selector.
.ie n .SS """$mech\->find_link_dom( %options )"""
.el .SS "\f(CW$mech\->find_link_dom( %options )\fP"
.IX Subsection "$mech->find_link_dom( %options )"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_link_dom( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method to find links, like WWW::Mechanize's
\&\f(CW\*(C`\->find_links\*(C'\fR method. This method returns \s-1DOM\s0 objects from
PhantomJS instead of WWW::Mechanize::Link objects.
.PP
Note that PhantomJS
might have reordered the links or frame links in the document
so the absolute numbers passed via \f(CW\*(C`n\*(C'\fR
might not be the same between
WWW::Mechanize and WWW::Mechanize::PhantomJS.
.PP
The supported options are:
.IP "\(bu" 4
\&\f(CW\*(C`text\*(C'\fR and \f(CW\*(C`text_contains\*(C'\fR and \f(CW\*(C`text_regex\*(C'\fR
.Sp
Match the text of the link as a complete string, substring or regular expression.
.Sp
Matching as a complete string or substring is a bit faster, as it is
done in the XPath engine of PhantomJS.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR and \f(CW\*(C`id_contains\*(C'\fR and \f(CW\*(C`id_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`id\*(C'\fR attribute of the link completely or as part
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR and \f(CW\*(C`name_contains\*(C'\fR and \f(CW\*(C`name_regex\*(C'\fR
.Sp
Matches the \f(CW\*(C`name\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR and \f(CW\*(C`url_regex\*(C'\fR
.Sp
Matches the \s-1URL\s0 attribute of the link (\f(CW\*(C`href\*(C'\fR, \f(CW\*(C`src\*(C'\fR or \f(CW\*(C`content\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`class\*(C'\fR \- the \f(CW\*(C`class\*(C'\fR attribute of the link
.IP "\(bu" 4
\&\f(CW\*(C`n\*(C'\fR \- the (1\-based) index. Defaults to returning the first link.
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.Sp
The method \f(CW\*(C`croak\*(C'\fRs if no link is found. If the \f(CW\*(C`single\*(C'\fR option is true,
it also \f(CW\*(C`croak\*(C'\fRs when more than one link is found.
.ie n .SS """$mech\->find_link( %options )"""
.el .SS "\f(CW$mech\->find_link( %options )\fP"
.IX Subsection "$mech->find_link( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_link( text_contains => \*(AqCPAN\*(Aq );
.Ve
.PP
A method quite similar to WWW::Mechanize's method.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns a WWW::Mechanize::Link object.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links( %options )"""
.el .SS "\f(CW$mech\->find_all_links( %options )\fP"
.IX Subsection "$mech->find_all_links( %options )"
.Vb 2
\&  print $_\->text . "\en"
\&      for $mech\->find_all_links( text_regex => qr/google/i );
.Ve
.PP
Finds all links in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->find_all_links_dom %options"""
.el .SS "\f(CW$mech\->find_all_links_dom %options\fP"
.IX Subsection "$mech->find_all_links_dom %options"
.Vb 2
\&  print $_\->{innerHTML} . "\en"
\&      for $mech\->find_all_links_dom( text_regex => qr/google/i );
.Ve
.PP
Finds all matching linky \s-1DOM\s0 nodes in the document.
The options are documented in \f(CW\*(C`\->find_link_dom\*(C'\fR.
.PP
Returns them as list or an array reference, depending
on context.
.PP
This defaults to not look through child frames.
.ie n .SS """$mech\->follow_link( $link )"""
.el .SS "\f(CW$mech\->follow_link( $link )\fP"
.IX Subsection "$mech->follow_link( $link )"
.ie n .SS """$mech\->follow_link( %options )"""
.el .SS "\f(CW$mech\->follow_link( %options )\fP"
.IX Subsection "$mech->follow_link( %options )"
.Vb 1
\&  $mech\->follow_link( xpath => \*(Aq//a[text() = "Click here!"]\*(Aq );
.Ve
.PP
Follows the given link. Takes the same parameters that \f(CW\*(C`find_link_dom\*(C'\fR
uses.
.PP
Note that \f(CW\*(C`\->follow_link\*(C'\fR will only try to follow link-like
things like \f(CW\*(C`A\*(C'\fR tags.
.ie n .SS """$mech\->xpath( $query, %options )"""
.el .SS "\f(CW$mech\->xpath( $query, %options )\fP"
.IX Subsection "$mech->xpath( $query, %options )"
.Vb 2
\&    my $link = $mech\->xpath(\*(Aq//a[id="clickme"]\*(Aq, one => 1);
\&    # croaks if there is no link or more than one link found
\&
\&    my @para = $mech\->xpath(\*(Aq//p\*(Aq);
\&    # Collects all paragraphs
\&
\&    my @para_text = $mech\->xpath(\*(Aq//p/text()\*(Aq, type => $mech\->xpathResult(\*(AqSTRING_TYPE\*(Aq));
\&    # Collects all paragraphs as text
.Ve
.PP
Runs an XPath query in PhantomJS against the current document.
.PP
If you need more information about the returned results,
use the \f(CW\*(C`\->xpathEx()\*(C'\fR function.
.PP
The options allow the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`document\*(C'\fR \- document in which the query is to be executed. Use this to
search a node within a specific subframe of \f(CW\*(C`$mech\->document\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`frames\*(C'\fR \- if true, search all documents in all frames and iframes.
This may or may not conflict with \f(CW\*(C`node\*(C'\fR. This will default to the
\&\f(CW\*(C`frames\*(C'\fR setting of the WWW::Mechanize::PhantomJS object.
.IP "\(bu" 4
\&\f(CW\*(C`node\*(C'\fR \- node relative to which the query is to be executed. Note
that you will have to use a relative XPath expression as well. Use
.Sp
.Vb 1
\&  .//foo
.Ve
.Sp
instead of
.Sp
.Vb 1
\&  //foo
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`single\*(C'\fR \- If true, ensure that only one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`one\*(C'\fR \- If true, ensure that at least one element is found. Otherwise croak
or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`maybe\*(C'\fR \- If true, ensure that at most one element is found. Otherwise
croak or carp, depending on the \f(CW\*(C`autodie\*(C'\fR parameter.
.IP "\(bu" 4
\&\f(CW\*(C`all\*(C'\fR \- If true, return all elements found. This is the default.
You can use this option if you want to use \f(CW\*(C`\->xpath\*(C'\fR in scalar context
to count the number of matched elements, as it will otherwise emit a warning
for each usage in scalar context without any of the above restricting options.
.IP "\(bu" 4
\&\f(CW\*(C`any\*(C'\fR \- no error is raised, no matter if an item is found or not.
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR \- force the return type of the query.
.Sp
.Vb 1
\&  type => $mech\->xpathResult(\*(AqORDERED_NODE_SNAPSHOT_TYPE\*(Aq),
.Ve
.Sp
WWW::Mechanize::PhantomJS tries a best effort in giving you the appropriate
result of your query, be it a \s-1DOM\s0 node or a string or a number. In the case
you need to restrict the return type, you can pass this in.
.Sp
The allowed strings are documented in the \s-1MDN.\s0 Interesting types are
.Sp
.Vb 4
\&  ANY_TYPE     (default, uses whatever things the query returns)
\&  STRING_TYPE
\&  NUMBER_TYPE
\&  ORDERED_NODE_SNAPSHOT_TYPE
.Ve
.PP
Returns the matched results.
.PP
You can pass in a list of queries as an array reference for the first parameter.
The result will then be the list of all elements matching any of the queries.
.PP
This is a method that is not implemented in WWW::Mechanize.
.PP
In the long run, this should go into a general plugin for
WWW::Mechanize.
.ie n .SS """$mech\->by_id( $id, %options )"""
.el .SS "\f(CW$mech\->by_id( $id, %options )\fP"
.IX Subsection "$mech->by_id( $id, %options )"
.Vb 1
\&  my @text = $mech\->by_id(\*(Aq_foo:bar\*(Aq);
.Ve
.PP
Returns all nodes matching the given ids. If
\&\f(CW$id\fR is an array reference, it returns
all nodes matched by any of the ids in the array.
.PP
This method is equivalent to calling \f(CW\*(C`\->xpath\*(C'\fR :
.PP
.Vb 1
\&    $self\->xpath(qq{//*[\e@id="$_"], %options)
.Ve
.PP
It is convenient when your element ids get mistaken for
\&\s-1CSS\s0 selectors.
.ie n .SS """$mech\->click( $name [,$x ,$y] )"""
.el .SS "\f(CW$mech\->click( $name [,$x ,$y] )\fP"
.IX Subsection "$mech->click( $name [,$x ,$y] )"
.Vb 2
\&  $mech\->click( \*(Aqgo\*(Aq );
\&  $mech\->click({ xpath => \*(Aq//button[@name="go"]\*(Aq });
.Ve
.PP
Has the effect of clicking a button (or other element) on the current form. The
first argument is the \f(CW\*(C`name\*(C'\fR of the button to be clicked. The second and third
arguments (optional) allow you to specify the (x,y) coordinates of the click.
.PP
If there is only one button on the form, \f(CW\*(C`$mech\->click()\*(C'\fR with
no arguments simply clicks that one button.
.PP
If you pass in a hash reference instead of a name,
the following keys are recognized:
.IP "\(bu" 4
\&\f(CW\*(C`selector\*(C'\fR \- Find the element to click by the \s-1CSS\s0 selector
.IP "\(bu" 4
\&\f(CW\*(C`xpath\*(C'\fR \- Find the element to click by the XPath query
.IP "\(bu" 4
\&\f(CW\*(C`dom\*(C'\fR \- Click on the passed \s-1DOM\s0 element
.Sp
You can use this to click on arbitrary page elements. There is no convenient
way to pass x/y co-ordinates with this method.
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- Click on the element with the given id
.Sp
This is useful if your document ids contain characters that
do look like \s-1CSS\s0 selectors. It is equivalent to
.Sp
.Vb 1
\&    xpath => qq{//*[\e@id="$id"]}
.Ve
.PP
Returns a HTTP::Response object.
.PP
As a deviation from the WWW::Mechanize \s-1API,\s0 you can also pass a
hash reference as the first parameter. In it, you can specify
the parameters to search much like for the \f(CW\*(C`find_link\*(C'\fR calls.
.ie n .SS """$mech\->click_button( ... )"""
.el .SS "\f(CW$mech\->click_button( ... )\fP"
.IX Subsection "$mech->click_button( ... )"
.Vb 2
\&  $mech\->click_button( name => \*(Aqgo\*(Aq );
\&  $mech\->click_button( input => $mybutton );
.Ve
.PP
Has the effect of clicking a button on the current form by specifying its
name, value, or index. Its arguments are a list of key/value pairs. Only
one of name, number, input or value must be specified in the keys.
.IP "\(bu" 4
\&\f(CW\*(C`name\*(C'\fR \- name of the button
.IP "\(bu" 4
\&\f(CW\*(C`value\*(C'\fR \- value of the button
.IP "\(bu" 4
\&\f(CW\*(C`input\*(C'\fR \- \s-1DOM\s0 node
.IP "\(bu" 4
\&\f(CW\*(C`id\*(C'\fR \- id of the button
.IP "\(bu" 4
\&\f(CW\*(C`number\*(C'\fR \- number of the button
.PP
If you find yourself wanting to specify a button through its
\&\f(CW\*(C`selector\*(C'\fR or \f(CW\*(C`xpath\*(C'\fR, consider using \f(CW\*(C`\->click\*(C'\fR instead.
.SH "FORM METHODS"
.IX Header "FORM METHODS"
.ie n .SS """$mech\->current_form()"""
.el .SS "\f(CW$mech\->current_form()\fP"
.IX Subsection "$mech->current_form()"
.Vb 1
\&  print $mech\->current_form\->{name};
.Ve
.PP
Returns the current form.
.PP
This method is incompatible with WWW::Mechanize.
It returns the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR object and not
a HTML::Form instance.
.PP
The current form will be reset by WWW::Mechanize::PhantomJS
on calls to \f(CW\*(C`\->get()\*(C'\fR and \f(CW\*(C`\->get_local()\*(C'\fR,
and on calls to \f(CW\*(C`\->submit()\*(C'\fR and \f(CW\*(C`\->submit_with_fields\*(C'\fR.
.ie n .SS """$mech\->dump_forms( [$fh] )"""
.el .SS "\f(CW$mech\->dump_forms( [$fh] )\fP"
.IX Subsection "$mech->dump_forms( [$fh] )"
.Vb 3
\&  open my $fh, \*(Aq>\*(Aq, \*(Aqform\-log.txt\*(Aq
\&      or die "Couldn\*(Aqt open logfile \*(Aqform\-log.txt\*(Aq: $!";
\&  $mech\->dump_forms( $fh );
.Ve
.PP
Prints a dump of the forms on the current page to
the filehandle \f(CW$fh\fR. If \f(CW$fh\fR is not specified or is undef, it dumps
to \f(CW\*(C`STDOUT\*(C'\fR.
.ie n .SS """$mech\->form_name( $name [, %options] )"""
.el .SS "\f(CW$mech\->form_name( $name [, %options] )\fP"
.IX Subsection "$mech->form_name( $name [, %options] )"
.Vb 1
\&  $mech\->form_name( \*(Aqsearch\*(Aq );
.Ve
.PP
Selects the current form by its name. The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_id( $id [, %options] )"""
.el .SS "\f(CW$mech\->form_id( $id [, %options] )\fP"
.IX Subsection "$mech->form_id( $id [, %options] )"
.Vb 1
\&  $mech\->form_id( \*(Aqlogin\*(Aq );
.Ve
.PP
Selects the current form by its \f(CW\*(C`id\*(C'\fR attribute.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.PP
This is equivalent to calling
.PP
.Vb 1
\&    $mech\->by_id($id,single => 1,%options)
.Ve
.ie n .SS """$mech\->form_number( $number [, %options] )"""
.el .SS "\f(CW$mech\->form_number( $number [, %options] )\fP"
.IX Subsection "$mech->form_number( $number [, %options] )"
.Vb 1
\&  $mech\->form_number( 2 );
.Ve
.PP
Selects the \fInumber\fRth form.
The options
are identical to those accepted by the \*(L"$mech\->xpath\*(R" method.
.ie n .SS """$mech\->form_with_fields( [$options], @fields )"""
.el .SS "\f(CW$mech\->form_with_fields( [$options], @fields )\fP"
.IX Subsection "$mech->form_with_fields( [$options], @fields )"
.Vb 3
\&  $mech\->form_with_fields(
\&      \*(Aquser\*(Aq, \*(Aqpassword\*(Aq
\&  );
.Ve
.PP
Find the form which has the listed fields.
.PP
If the first argument is a hash reference, it's taken
as options to \f(CW\*(C`\->xpath\*(C'\fR.
.PP
See also \*(L"$mech\->submit_form\*(R".
.ie n .SS """$mech\->forms( %options )"""
.el .SS "\f(CW$mech\->forms( %options )\fP"
.IX Subsection "$mech->forms( %options )"
.Vb 1
\&  my @forms = $mech\->forms();
.Ve
.PP
When called in a list context, returns a list
of the forms found in the last fetched page.
In a scalar context, returns a reference to
an array with those forms.
.PP
The options
are identical to those accepted by the \*(L"$mech\->selector\*(R" method.
.PP
The returned elements are the \s-1DOM\s0 \f(CW\*(C`<form>\*(C'\fR elements.
.ie n .SS """$mech\->field( $selector, $value, [,\e@pre_events [,\e@post_events]] )"""
.el .SS "\f(CW$mech\->field( $selector, $value, [,\e@pre_events [,\e@post_events]] )\fP"
.IX Subsection "$mech->field( $selector, $value, [,@pre_events [,@post_events]] )"
.Vb 2
\&  $mech\->field( user => \*(Aqjoe\*(Aq );
\&  $mech\->field( not_empty => \*(Aq\*(Aq, [], [] ); # bypass JS validation
.Ve
.PP
Sets the field with the name given in \f(CW$selector\fR to the given value.
Returns the value.
.PP
The method understands very basic \s-1CSS\s0 selectors in the value for \f(CW$selector\fR,
like the HTML::Form \fBfind_input()\fR method.
.PP
A selector prefixed with '#' must match the id attribute of the input.
A selector prefixed with '.' matches the class attribute. A selector
prefixed with '^' or with no prefix matches the name attribute.
.PP
By passing the array reference \f(CW@pre_events\fR, you can indicate which
Javascript events you want to be triggered before setting the value.
\&\f(CW@post_events\fR contains the events you want to be triggered
after setting the value.
.PP
By default, the events set in the
constructor for \f(CW\*(C`pre_events\*(C'\fR and \f(CW\*(C`post_events\*(C'\fR
are triggered.
.ie n .SS """$mech\->value( $selector_or_element, [%options] )"""
.el .SS "\f(CW$mech\->value( $selector_or_element, [%options] )\fP"
.IX Subsection "$mech->value( $selector_or_element, [%options] )"
.Vb 1
\&    print $mech\->value( \*(Aquser\*(Aq );
.Ve
.PP
Returns the value of the field given by \f(CW$selector_or_name\fR or of the
\&\s-1DOM\s0 element passed in.
.PP
The legacy form of
.PP
.Vb 1
\&    $mech\->value( name => value );
.Ve
.PP
is also still supported but will likely be deprecated
in favour of the \f(CW\*(C`\->field\*(C'\fR method.
.PP
For fields that can have multiple values, like a \f(CW\*(C`select\*(C'\fR field,
the method is context sensitive and returns the first selected
value in scalar context and all values in list context.
.ie n .SS """$mech\->get_set_value( %options )"""
.el .SS "\f(CW$mech\->get_set_value( %options )\fP"
.IX Subsection "$mech->get_set_value( %options )"
Allows fine-grained access to getting/setting a value
with a different \s-1API.\s0 Supported keys are:
.PP
.Vb 4
\&  pre
\&  post
\&  name
\&  value
.Ve
.PP
in addition to all keys that \f(CW\*(C`$mech\->xpath\*(C'\fR supports.
.ie n .SS """$mech\->submit( $form )"""
.el .SS "\f(CW$mech\->submit( $form )\fP"
.IX Subsection "$mech->submit( $form )"
.Vb 1
\&  $mech\->submit;
.Ve
.PP
Submits the form. Note that this does \fBnot\fR fire the \f(CW\*(C`onClick\*(C'\fR
event and thus also does not fire eventual Javascript handlers.
Maybe you want to use \f(CW\*(C`$mech\->click\*(C'\fR instead.
.PP
The default is to submit the current form as returned
by \f(CW\*(C`$mech\->current_form\*(C'\fR.
.ie n .SS """$mech\->submit_form( %options )"""
.el .SS "\f(CW$mech\->submit_form( %options )\fP"
.IX Subsection "$mech->submit_form( %options )"
.Vb 6
\&  $mech\->submit_form(
\&      with_fields => {
\&          user => \*(Aqme\*(Aq,
\&          pass => \*(Aqsecret\*(Aq,
\&      }
\&  );
.Ve
.PP
This method lets you select a form from the previously fetched page,
fill in its fields, and submit it. It combines the form_number/form_name,
set_fields and click methods into one higher level call. Its arguments are
a list of key/value pairs, all of which are optional.
.IP "\(bu" 4
\&\f(CW\*(C`form => $mech\->current_form()\*(C'\fR
.Sp
Specifies the form to be filled and submitted. Defaults to the current form.
.IP "\(bu" 4
\&\f(CW\*(C`fields => \e%fields\*(C'\fR
.Sp
Specifies the fields to be filled in the current form
.IP "\(bu" 4
\&\f(CW\*(C`with_fields => \e%fields\*(C'\fR
.Sp
Probably all you need for the common case. It combines a smart form selector
and data setting in one operation. It selects the first form that contains
all fields mentioned in \e%fields. This is nice because you don't need to
know the name or number of the form to do this.
.Sp
(calls \*(L"$mech\->\fBform_with_fields()\fR\*(R" and \*(L"$mech\->\fBset_fields()\fR\*(R").
.Sp
If you choose this, the form_number, form_name, form_id and fields options
will be ignored.
.ie n .SS """$mech\->set_fields( $name => $value, ... )"""
.el .SS "\f(CW$mech\->set_fields( $name => $value, ... )\fP"
.IX Subsection "$mech->set_fields( $name => $value, ... )"
.Vb 4
\&  $mech\->set_fields(
\&      user => \*(Aqme\*(Aq,
\&      pass => \*(Aqsecret\*(Aq,
\&  );
.Ve
.PP
This method sets multiple fields of the current form. It takes a list of
field name and value pairs. If there is more than one field with the same
name, the first one found is set. If you want to select which of the
duplicate field to set, use a value which is an anonymous array which
has the field value and its number as the 2 elements.
.ie n .SS """$mech\->expand_frames( $spec )"""
.el .SS "\f(CW$mech\->expand_frames( $spec )\fP"
.IX Subsection "$mech->expand_frames( $spec )"
.Vb 1
\&  my @frames = $mech\->expand_frames();
.Ve
.PP
Expands the frame selectors (or \f(CW1\fR to match all frames)
into their respective PhantomJS nodes according to the current
document. All frames will be visited in breadth first order.
.PP
This is mostly an internal method.
.ie n .SS """$mech\->current_frame"""
.el .SS "\f(CW$mech\->current_frame\fP"
.IX Subsection "$mech->current_frame"
.Vb 2
\&    my $last_frame= $mech\->current_frame;
\&    # Switch frame somewhere else
\&
\&    # Switch back
\&    $mech\->activate_container( $last_frame );
.Ve
.PP
Returns the currently active frame as a WebElement.
.PP
This is mostly an internal method.
.PP
See also
.PP
<http://code.google.com/p/selenium/issues/detail?id=4305>
.PP
Frames are currently not really supported.
.SH "CONTENT RENDERING METHODS"
.IX Header "CONTENT RENDERING METHODS"
.ie n .SS """$mech\->content_as_png( [\e%coordinates ] )"""
.el .SS "\f(CW$mech\->content_as_png( [\e%coordinates ] )\fP"
.IX Subsection "$mech->content_as_png( [%coordinates ] )"
.Vb 1
\&    my $png_data = $mech\->content_as_png();
\&
\&    # Create scaled\-down 480px wide preview
\&    my $png_data = $mech\->content_as_png(undef, { width => 480 });
.Ve
.PP
Returns the given tab or the current page rendered as \s-1PNG\s0 image.
.PP
All parameters are optional.
.ie n .IP """ \e%coordinates """ 4
.el .IP "\f(CW \e%coordinates \fR" 4
.IX Item " %coordinates "
If the coordinates are given, that rectangle will be cut out.
The coordinates should be a hash with the four usual entries,
\&\f(CW\*(C`left\*(C'\fR,\f(CW\*(C`top\*(C'\fR,\f(CW\*(C`width\*(C'\fR,\f(CW\*(C`height\*(C'\fR.
.PP
This method is specific to WWW::Mechanize::PhantomJS.
.PP
Currently, the data transfer between PhantomJS and Perl
is done Base64\-encoded.
.ie n .SS """$mech\->viewport_size"""
.el .SS "\f(CW$mech\->viewport_size\fP"
.IX Subsection "$mech->viewport_size"
.Vb 2
\&  print Dumper $mech\->viewport_size;
\&  $mech\->viewport_size({ width => 1388, height => 792 });
.Ve
.PP
Returns (or sets) the new size of the viewport (the \*(L"window\*(R").
.ie n .SS """$mech\->element_as_png( $element )"""
.el .SS "\f(CW$mech\->element_as_png( $element )\fP"
.IX Subsection "$mech->element_as_png( $element )"
.Vb 2
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my $i_want_this = $mech\->element_as_png($shiny);
.Ve
.PP
Returns \s-1PNG\s0 image data for a single element
.ie n .SS """$mech\->render_element( %options )"""
.el .SS "\f(CW$mech\->render_element( %options )\fP"
.IX Subsection "$mech->render_element( %options )"
.Vb 5
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my $i_want_this= $mech\->render_element(
\&        element => $shiny,
\&        format => \*(Aqpdf\*(Aq,
\&    );
.Ve
.PP
Returns the data for a single element
or writes it to a file. It accepts
all options of \f(CW\*(C`\->render_content\*(C'\fR.
.ie n .SS """$mech\->element_coordinates( $element )"""
.el .SS "\f(CW$mech\->element_coordinates( $element )\fP"
.IX Subsection "$mech->element_coordinates( $element )"
.Vb 3
\&    my $shiny = $mech\->selector(\*(Aq#shiny\*(Aq, single => 1);
\&    my ($pos) = $mech\->element_coordinates($shiny);
\&    print $pos\->{left},\*(Aq,\*(Aq, $pos\->{top};
.Ve
.PP
Returns the page-coordinates of the \f(CW$element\fR
in pixels as a hash with four entries, \f(CW\*(C`left\*(C'\fR, \f(CW\*(C`top\*(C'\fR, \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR.
.PP
This function might get moved into another module more geared
towards rendering \s-1HTML.\s0
.ie n .SS """$mech\->render_content(%options)"""
.el .SS "\f(CW$mech\->render_content(%options)\fP"
.IX Subsection "$mech->render_content(%options)"
.Vb 1
\&    my $pdf_data = $mech\->render( format => \*(Aqpdf\*(Aq );
\&
\&    $mech\->render_content(
\&        format => \*(Aqjpg\*(Aq,
\&        filename => \*(Aq/path/to/my.jpg\*(Aq,
\&    );
.Ve
.PP
Returns the current page rendered in the specified format
as a bytestring or stores the current page in the specified
filename.
.PP
The filename must be absolute. We are dealing with external processes here!
.PP
This method is specific to WWW::Mechanize::PhantomJS.
.PP
Currently, the data transfer between PhantomJS and Perl
is done through a temporary file, so directly using
the \f(CW\*(C`filename\*(C'\fR option may be faster.
.ie n .SS """$mech\->content_as_pdf(%options)"""
.el .SS "\f(CW$mech\->content_as_pdf(%options)\fP"
.IX Subsection "$mech->content_as_pdf(%options)"
.Vb 1
\&    my $pdf_data = $mech\->content_as_pdf();
\&
\&    $mech\->content_as_pdf(
\&        filename => \*(Aq/path/to/my.pdf\*(Aq,
\&    );
.Ve
.PP
Returns the current page rendered in \s-1PDF\s0 format as a bytestring.
.PP
This method is specific to WWW::Mechanize::PhantomJS.
.PP
Currently, the data transfer between PhantomJS and Perl
is done through a temporary file, so directly using
the \f(CW\*(C`filename\*(C'\fR option may be faster.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
These are methods that are available but exist mostly as internal
helper methods. Use of these is discouraged.
.ie n .SS """$mech\->element_query( \e@elements, \e%attributes )"""
.el .SS "\f(CW$mech\->element_query( \e@elements, \e%attributes )\fP"
.IX Subsection "$mech->element_query( @elements, %attributes )"
.Vb 2
\&    my $query = $mech\->element_query([\*(Aqinput\*(Aq, \*(Aqselect\*(Aq, \*(Aqtextarea\*(Aq],
\&                               { name => \*(Aqfoo\*(Aq });
.Ve
.PP
Returns the XPath query that searches for all elements with \f(CW\*(C`tagName\*(C'\fRs
in \f(CW@elements\fR having the attributes \f(CW%attributes\fR. The \f(CW@elements\fR
will form an \f(CW\*(C`or\*(C'\fR condition, while the attributes will form an \f(CW\*(C`and\*(C'\fR
condition.
.ie n .SS """$mech\->PhantomJS_elementToJS"""
.el .SS "\f(CW$mech\->PhantomJS_elementToJS\fP"
.IX Subsection "$mech->PhantomJS_elementToJS"
Returns the Javascript fragment to turn a Selenium::Remote::PhantomJS
id back to a Javascript object.
.SH "INCOMPATIBILITIES WITH WWW::Mechanize"
.IX Header "INCOMPATIBILITIES WITH WWW::Mechanize"
As this module is in a very early stage of development,
there are many incompatibilities. The main thing is
that only the most needed WWW::Mechanize methods
have been implemented by me so far.
.SS "Unsupported Methods"
.IX Subsection "Unsupported Methods"
At least the following methods are unsupported:
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_inputs\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_submits\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_image\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`\->find_all_images\*(C'\fR
.Sp
This function is likely best implemented through \f(CW\*(C`$mech\->selector\*(C'\fR.
.SS "Functions that will likely never be implemented"
.IX Subsection "Functions that will likely never be implemented"
These functions are unlikely to be implemented because
they make little sense in the context of PhantomJS.
.IP "\(bu" 4
\&\f(CW\*(C`\->clone\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->credentials( $username, $password )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->get_basic_credentials( $realm, $uri, $isproxy )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->clear_credentials()\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\->put\*(C'\fR
.Sp
I have no use for it
.IP "\(bu" 4
\&\f(CW\*(C`\->post\*(C'\fR
.Sp
Selenium does not support \s-1POST\s0 requests
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Add \f(CW\*(C`limit\*(C'\fR parameter to \f(CW\*(C`\->xpath()\*(C'\fR to allow an early exit-case
when searching through frames.
.IP "\(bu" 4
Implement downloads via
.Sp
<https://perlmonks.org/?node_id=1151151>
.IP "\(bu" 4
Implement download progress
.SH "INSTALLING"
.IX Header "INSTALLING"
.ie n .SS "Install the ""PhantomJS"" executable"
.el .SS "Install the \f(CWPhantomJS\fP executable"
.IX Subsection "Install the PhantomJS executable"
.IP "\(bu" 4
Installing on Ubuntu
.Sp
Version: 1.9.8
Platform: x86_64
.Sp
Install or update latest system software:
.Sp
\&\f(CW\*(C`sudo apt\-get update\*(C'\fR
.Sp
\&\f(CW\*(C`sudo apt\-get install build\-essential chrpath libssl\-dev libxft\-dev\*(C'\fR
.Sp
Install the following packages needed by PhantomJS:
.Sp
\&\f(CW\*(C`sudo apt\-get install libfreetype6 libfreetype6\-dev\*(C'\fR
.Sp
\&\f(CW\*(C`sudo apt\-get install libfontconfig1 libfontconfig1\-dev\*(C'\fR
.Sp
Get PhantomJS from the website <http://phantomjs.org/>
.Sp
\&\f(CW\*(C`cd ~\*(C'\fR
.Sp
\&\f(CW\*(C`export PHANTOM_JS="phantomjs\-1.9.8\-linux\-x86_64"\*(C'\fR
.Sp
\&\f(CW\*(C`wget https://bitbucket.org/ariya/phantomjs/downloads/$PHANTOM_JS.tar.bz2\*(C'\fR
.Sp
\&\f(CW\*(C`sudo tar xvjf $PHANTOM_JS.tar.bz2\*(C'\fR
.Sp
Once downloaded move Phantomjs folder:
.Sp
\&\f(CW\*(C`sudo mv $PHANTOM_JS /usr/local/share\*(C'\fR
.Sp
\&\f(CW\*(C`sudo ln \-sf /usr/local/share/$PHANTOM_JS/bin/phantomjs /usr/local/bin\*(C'\fR
.Sp
\&\f(CW\*(C`sudo ln \-sf /usr/local/share/$PHANTOM_JS/bin/phantomjs /usr/bin/phantomjs\*(C'\fR
.Sp
Test it has been installed on your system:
.Sp
\&\f(CW\*(C`phantomjs \-\-version\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
<http://phantomjs.org> \- the PhantomJS homepage
.IP "\(bu" 4
<https://github.com/detro/ghostdriver> \- the ghostdriver homepage
.IP "\(bu" 4
WWW::Mechanize \- the module whose \s-1API\s0 grandfathered this module
.IP "\(bu" 4
WWW::Scripter \- another WWW::Mechanize\-workalike with Javascript support
.IP "\(bu" 4
WWW::Mechanize::Firefox \- a similar module with a visible application
.SH "REPOSITORY"
.IX Header "REPOSITORY"
The public repository of this module is
<https://github.com/Corion/www\-mechanize\-phantomjs>.
.SH "SUPPORT"
.IX Header "SUPPORT"
The public support forum of this module is
<https://perlmonks.org/>.
.SH "TALKS"
.IX Header "TALKS"
I've given a talk about this module at Perl conferences:
.PP
German Perl Workshop 2014, German <http://corion.net/talks/WWW-Mechanize-PhantomJS/www-mechanize-phantomjs.de.html>
.PP
YAPC::Europe 2014, English <http://corion.net/talks/WWW-Mechanize-PhantomJS/www-mechanize-phantomjs.en.html>
.PP
Talk on Youtube <https://www.youtube.com/watch?v=lH3Fhw6b5BI>
.SH "BUG TRACKER"
.IX Header "BUG TRACKER"
Please report bugs in this module via the \s-1RT CPAN\s0 bug queue at
<https://rt.cpan.org/Public/Dist/Display.html?Name=WWW\-Mechanize\-PhantomJS>
or via mail to www\-mechanize\-phantomjs\-Bugs@rt.cpan.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR
.SH "COPYRIGHT (c)"
.IX Header "COPYRIGHT (c)"
Copyright 2014\-2020 by Max Maischein \f(CW\*(C`corion@cpan.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
This module is released under the same terms as Perl itself.
.PP
This distribution includes a modified copy of the ghostdriver code,
which is released under the same terms as the ghostdriver code itself.
The terms of the ghostdriver code are the \s-1BSD\s0 license, as found at
<https://github.com/detro/ghostdriver/blob/master/LICENSE.BSD>:
.PP
.Vb 2
\&    Copyright (c) 2014, Ivan De Marino <http://ivandemarino.me>
\&    All rights reserved.
\&
\&    Redistribution and use in source and binary forms, with or without modification,
\&    are permitted provided that the following conditions are met:
\&
\&    * Redistributions of source code must retain the above copyright notice,
\&    this list of conditions and the following disclaimer.
\&    * Redistributions in binary form must reproduce the above copyright notice,
\&    this list of conditions and the following disclaimer in the documentation
\&    and/or other materials provided with the distribution.
\&
\&    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
\&    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
\&    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
\&    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
\&    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
\&    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
\&    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
\&    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\&    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
\&    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
.PP
The ghostdriver code includes the Selenium WebDriver fragments.
