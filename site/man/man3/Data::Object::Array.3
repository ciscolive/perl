.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Object::Array 3"
.TH Data::Object::Array 3 "2020-04-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Object::Array
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Array Class for Perl 5
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package main;
\&
\&  use Data::Object::Array;
\&
\&  my $array = Data::Object::Array\->new([1..9]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides methods for manipulating array data.
.SH "INHERITS"
.IX Header "INHERITS"
This package inherits behaviors from:
.PP
Data::Object::Kind
.SH "INTEGRATES"
.IX Header "INTEGRATES"
This package integrates behaviors from:
.PP
Data::Object::Role::Dumpable
.PP
Data::Object::Role::Pluggable
.PP
Data::Object::Role::Throwable
.SH "LIBRARIES"
.IX Header "LIBRARIES"
This package uses type constraints from:
.PP
Data::Object::Types
.SH "METHODS"
.IX Header "METHODS"
This package implements the following methods:
.SS "all"
.IX Subsection "all"
.Vb 1
\&  all(CodeRef $arg1, Any @args) : Num
.Ve
.PP
The all method returns true if the callback returns true for all of the
elements.
.IP "all example #1" 4
.IX Item "all example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->all(sub {
\&    my ($value, @args) = @_;
\&
\&    $value > 1;
\&  });
.Ve
.SS "any"
.IX Subsection "any"
.Vb 1
\&  any(CodeRef $arg1, Any @args) : Num
.Ve
.PP
The any method returns true if the callback returns true for any of the
elements.
.IP "any example #1" 4
.IX Item "any example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->any(sub {
\&    my ($value) = @_;
\&
\&    $value > 5;
\&  });
.Ve
.SS "clear"
.IX Subsection "clear"
.Vb 1
\&  clear() : ArrayLike
.Ve
.PP
The clear method is an alias to the empty method.
.IP "clear example #1" 4
.IX Item "clear example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->clear;
.Ve
.SS "count"
.IX Subsection "count"
.Vb 1
\&  count() : Num
.Ve
.PP
The count method returns the number of elements within the array.
.IP "count example #1" 4
.IX Item "count example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->count;
.Ve
.SS "defined"
.IX Subsection "defined"
.Vb 1
\&  defined() : Num
.Ve
.PP
The defined method returns true if the element at the array index is defined.
.IP "defined example #1" 4
.IX Item "defined example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->defined;
.Ve
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  delete(Int $arg1) : Any
.Ve
.PP
The delete method returns the value of the element at the index specified after
removing it from the array.
.IP "delete example #1" 4
.IX Item "delete example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->delete(2);
.Ve
.SS "each"
.IX Subsection "each"
.Vb 1
\&  each(CodeRef $arg1, Any @args) : ArrayLike
.Ve
.PP
The each method executes a callback for each element in the array passing the
index and value as arguments.
.IP "each example #1" 4
.IX Item "each example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->each(sub {
\&    my ($index, $value) = @_;
\&
\&    [$index, $value]
\&  });
.Ve
.SS "each_key"
.IX Subsection "each_key"
.Vb 1
\&  each_key(CodeRef $arg1, Any @args) : ArrayRef
.Ve
.PP
The each_key method executes a callback for each element in the array passing
the index as an argument.
.IP "each_key example #1" 4
.IX Item "each_key example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->each_key(sub {
\&    my ($index)  = @_;
\&
\&    [$index]
\&  });
.Ve
.SS "each_n_values"
.IX Subsection "each_n_values"
.Vb 1
\&  each_n_values(Num $arg1, CodeRef $arg2, Any @args) : ArrayRef
.Ve
.PP
The each_n_values method executes a callback for each element in the array
passing the routine the next \fBn\fR values until all values have been handled.
.IP "each_n_values example #1" 4
.IX Item "each_n_values example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->each_n_values(4, sub {
\&    my (@values) = @_;
\&
\&    # $values[1] # a
\&    # $values[2] # b
\&    # $values[3] # c
\&    # $values[4] # d
\&
\&    [@values]
\&  });
.Ve
.SS "each_value"
.IX Subsection "each_value"
.Vb 1
\&  each_value(CodeRef $arg1, Any @args) : ArrayRef
.Ve
.PP
The each_value method executes a callback for each element in the array passing
the routine the value as an argument.
.IP "each_value example #1" 4
.IX Item "each_value example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->each_value(sub {
\&    my ($value, @args) = @_;
\&
\&    [$value, @args]
\&  });
.Ve
.SS "empty"
.IX Subsection "empty"
.Vb 1
\&  empty() : ArrayLike
.Ve
.PP
The empty method drops all elements from the array.
.IP "empty example #1" 4
.IX Item "empty example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqg\*(Aq]);
\&
\&  $array\->empty;
.Ve
.SS "eq"
.IX Subsection "eq"
.Vb 1
\&  eq(Any $arg1) : Num
.Ve
.PP
The eq method will throw an exception if called.
.IP "eq example #1" 4
.IX Item "eq example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->eq([]);
.Ve
.SS "exists"
.IX Subsection "exists"
.Vb 1
\&  exists(Int $arg1) : Num
.Ve
.PP
The exists method returns true if the element at the index specified exists,
otherwise it returns false.
.IP "exists example #1" 4
.IX Item "exists example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1,2,3,4,5]);
\&
\&  $array\->exists(0);
.Ve
.SS "first"
.IX Subsection "first"
.Vb 1
\&  first() : Any
.Ve
.PP
The first method returns the value of the first element.
.IP "first example #1" 4
.IX Item "first example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->first;
.Ve
.SS "ge"
.IX Subsection "ge"
.Vb 1
\&  ge(Any $arg1) : Num
.Ve
.PP
The ge method will throw an exception if called.
.IP "ge example #1" 4
.IX Item "ge example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->ge([]);
.Ve
.SS "get"
.IX Subsection "get"
.Vb 1
\&  get(Int $arg1) : Any
.Ve
.PP
The get method returns the value of the element at the index specified.
.IP "get example #1" 4
.IX Item "get example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->get(0);
.Ve
.SS "grep"
.IX Subsection "grep"
.Vb 1
\&  grep(CodeRef $arg1, Any @args) : ArrayRef
.Ve
.PP
The grep method executes a callback for each element in the array passing the
value as an argument, returning a new array reference containing the elements
for which the returned true.
.IP "grep example #1" 4
.IX Item "grep example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->grep(sub {
\&    my ($value) = @_;
\&
\&    $value >= 3
\&  });
.Ve
.SS "gt"
.IX Subsection "gt"
.Vb 1
\&  gt(Any $arg1) : Num
.Ve
.PP
The gt method will throw an exception if called.
.IP "gt example #1" 4
.IX Item "gt example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->gt([]);
.Ve
.SS "hash"
.IX Subsection "hash"
.Vb 1
\&  hash() : HashRef
.Ve
.PP
The hash method returns a hash reference where each key and value pairs
corresponds to the index and value of each element in the array.
.IP "hash example #1" 4
.IX Item "hash example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->hash; # {0=>1,1=>2,2=>3,3=>4,4=>5}
.Ve
.SS "hashify"
.IX Subsection "hashify"
.Vb 1
\&  hashify(CodeRef $arg1, Any $arg2) : HashRef
.Ve
.PP
The hashify method returns a hash reference where the elements of array become
the hash keys and the corresponding values are assigned a value of 1.
.IP "hashify example #1" 4
.IX Item "hashify example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->hashify;
.Ve
.IP "hashify example #2" 4
.IX Item "hashify example #2"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->hashify(sub { my ($value) = @_; $value % 2 });
.Ve
.SS "head"
.IX Subsection "head"
.Vb 1
\&  head() : Any
.Ve
.PP
The head method returns the value of the first element in the array.
.IP "head example #1" 4
.IX Item "head example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([9,8,7,6,5]);
\&
\&  $array\->head; # 9
.Ve
.SS "invert"
.IX Subsection "invert"
.Vb 1
\&  invert() : Any
.Ve
.PP
The invert method returns an array reference containing the elements in the
array in reverse order.
.IP "invert example #1" 4
.IX Item "invert example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->invert; # [5,4,3,2,1]
.Ve
.SS "iterator"
.IX Subsection "iterator"
.Vb 1
\&  iterator() : CodeRef
.Ve
.PP
The iterator method returns a code reference which can be used to iterate over
the array. Each time the iterator is executed it will return the next element
in the array until all elements have been seen, at which point the iterator
will return an undefined value.
.IP "iterator example #1" 4
.IX Item "iterator example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  my $iterator = $array\->iterator;
\&
\&  # while (my $value = $iterator\->next) {
\&  #   say $value; # 1
\&  # }
.Ve
.SS "join"
.IX Subsection "join"
.Vb 1
\&  join(Str $arg1) : Str
.Ve
.PP
The join method returns a string consisting of all the elements in the array
joined by the join-string specified by the argument. Note: If the argument is
omitted, an empty string will be used as the join-string.
.IP "join example #1" 4
.IX Item "join example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->join; # 12345
.Ve
.IP "join example #2" 4
.IX Item "join example #2"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->join(\*(Aq, \*(Aq); # 1, 2, 3, 4, 5
.Ve
.SS "keyed"
.IX Subsection "keyed"
.Vb 1
\&  keyed(Str $arg1) : HashRef
.Ve
.PP
The keyed method returns a hash reference where the arguments become the keys,
and the elements of the array become the values.
.IP "keyed example #1" 4
.IX Item "keyed example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->keyed(\*(Aqa\*(Aq..\*(Aqd\*(Aq); # {a=>1,b=>2,c=>3,d=>4}
.Ve
.SS "keys"
.IX Subsection "keys"
.Vb 1
\&  keys() : ArrayRef
.Ve
.PP
The keys method returns an array reference consisting of the indicies of the
array.
.IP "keys example #1" 4
.IX Item "keys example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqd\*(Aq]);
\&
\&  $array\->keys; # [0,1,2,3]
.Ve
.SS "last"
.IX Subsection "last"
.Vb 1
\&  last() : Any
.Ve
.PP
The last method returns the value of the last element in the array.
.IP "last example #1" 4
.IX Item "last example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->last; # 5
.Ve
.SS "le"
.IX Subsection "le"
.Vb 1
\&  le(Any $arg1) : Num
.Ve
.PP
The le method will throw an exception if called.
.IP "le example #1" 4
.IX Item "le example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->le([]);
.Ve
.SS "length"
.IX Subsection "length"
.Vb 1
\&  length() : Num
.Ve
.PP
The length method returns the number of elements in the array.
.IP "length example #1" 4
.IX Item "length example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->length; # 5
.Ve
.SS "list"
.IX Subsection "list"
.Vb 1
\&  list() : (Any)
.Ve
.PP
The list method returns a shallow copy of the underlying array reference as an
array reference.
.IP "list example #1" 4
.IX Item "list example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  my @list = $array\->list;
\&
\&  [@list]
.Ve
.SS "lt"
.IX Subsection "lt"
.Vb 1
\&  lt(Any $arg1) : Num
.Ve
.PP
The lt method will throw an exception if called.
.IP "lt example #1" 4
.IX Item "lt example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->lt([]);
.Ve
.SS "map"
.IX Subsection "map"
.Vb 1
\&  map(CodeRef $arg1, Any $arg2) : ArrayRef
.Ve
.PP
The map method iterates over each element in the array, executing the code
reference supplied in the argument, passing the routine the value at the
current position in the loop and returning a new array reference containing the
elements for which the argument returns a value or non-empty list.
.IP "map example #1" 4
.IX Item "map example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->map(sub {
\&    $_[0] + 1
\&  });
\&
\&  # [2,3,4,5,6]
.Ve
.SS "max"
.IX Subsection "max"
.Vb 1
\&  max() : Any
.Ve
.PP
The max method returns the element in the array with the highest numerical
value. All non-numerical element are skipped during the evaluation process.
.IP "max example #1" 4
.IX Item "max example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([8,9,1,2,3,4,5]);
\&
\&  $array\->max; # 9
.Ve
.SS "min"
.IX Subsection "min"
.Vb 1
\&  min() : Any
.Ve
.PP
The min method returns the element in the array with the lowest numerical
value. All non-numerical element are skipped during the evaluation process.
.IP "min example #1" 4
.IX Item "min example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([8,9,1,2,3,4,5]);
\&
\&  $array\->min; # 1
.Ve
.SS "ne"
.IX Subsection "ne"
.Vb 1
\&  ne(Any $arg1) : Num
.Ve
.PP
The ne method will throw an exception if called.
.IP "ne example #1" 4
.IX Item "ne example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new;
\&
\&  $array\->ne([]);
.Ve
.SS "none"
.IX Subsection "none"
.Vb 1
\&  none(CodeRef $arg1, Any $arg2) : Num
.Ve
.PP
The none method returns true if none of the elements in the array meet the
criteria set by the operand and rvalue.
.IP "none example #1" 4
.IX Item "none example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->none(sub {
\&    my ($value) = @_;
\&
\&    $value <= 1; # 1; true
\&  });
.Ve
.IP "none example #2" 4
.IX Item "none example #2"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->none(sub {
\&    my ($value) = @_;
\&
\&    $value <= 1; # 1; true
\&  });
.Ve
.SS "nsort"
.IX Subsection "nsort"
.Vb 1
\&  nsort() : ArrayRef
.Ve
.PP
The nsort method returns an array reference containing the values in the array
sorted numerically.
.IP "nsort example #1" 4
.IX Item "nsort example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([5,4,3,2,1]);
\&
\&  $array\->nsort; # [1,2,3,4,5]
.Ve
.SS "one"
.IX Subsection "one"
.Vb 1
\&  one(CodeRef $arg1, Any $arg2) : Num
.Ve
.PP
The one method returns true if only one of the elements in the array meet the
criteria set by the operand and rvalue.
.IP "one example #1" 4
.IX Item "one example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->one(sub {
\&    my ($value) = @_;
\&
\&    $value == 5; # 1; true
\&  });
.Ve
.IP "one example #2" 4
.IX Item "one example #2"
.Vb 1
\&  my $array = Data::Object::Array\->new([2..5]);
\&
\&  $array\->one(sub {
\&    my ($value) = @_;
\&
\&    $value == 6; # 0; false
\&  });
.Ve
.SS "pairs"
.IX Subsection "pairs"
.Vb 1
\&  pairs() : ArrayRef
.Ve
.PP
The pairs method is an alias to the pairs_array method.
.IP "pairs example #1" 4
.IX Item "pairs example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->pairs; # [[0,1],[1,2],[2,3],[3,4],[4,5]]
.Ve
.SS "pairs_array"
.IX Subsection "pairs_array"
.Vb 1
\&  pairs_array() : ArrayRef
.Ve
.PP
The pairs_array method returns an array reference consisting of array
references where each sub-array reference has two elements corresponding to the
index and value of each element in the array.
.IP "pairs_array example #1" 4
.IX Item "pairs_array example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->pairs_array; # [[0,1],[1,2],[2,3],[3,4],[4,5]]
.Ve
.SS "pairs_hash"
.IX Subsection "pairs_hash"
.Vb 1
\&  pairs_hash() : HashRef
.Ve
.PP
The pairs_hash method returns a hash reference where each key and value pairs
corresponds to the index and value of each element in the array.
.IP "pairs_hash example #1" 4
.IX Item "pairs_hash example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->pairs_hash; # {0=>1,1=>2,2=>3,3=>4,4=>5}
.Ve
.SS "part"
.IX Subsection "part"
.Vb 1
\&  part(CodeRef $arg1, Any $arg2) : Tuple[ArrayRef, ArrayRef]
.Ve
.PP
The part method iterates over each element in the array, executing the code
reference supplied in the argument, using the result of the code reference to
partition to array into two distinct array references.
.IP "part example #1" 4
.IX Item "part example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..10]);
\&
\&  $array\->part(sub { my ($value) = @_; $value > 5 });
\&
\&  # [[6, 7, 8, 9, 10], [1, 2, 3, 4, 5]]
.Ve
.SS "pop"
.IX Subsection "pop"
.Vb 1
\&  pop() : Any
.Ve
.PP
The pop method returns the last element of the array shortening it by one.
Note, this method modifies the array.
.IP "pop example #1" 4
.IX Item "pop example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->pop; # 5
.Ve
.SS "push"
.IX Subsection "push"
.Vb 1
\&  push(Any $arg1) : Any
.Ve
.PP
The push method appends the array by pushing the agruments onto it and returns
itself.
.IP "push example #1" 4
.IX Item "push example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->push(6,7,8); # [1,2,3,4,5,6,7,8]
.Ve
.SS "random"
.IX Subsection "random"
.Vb 1
\&  random() : Any
.Ve
.PP
The random method returns a random element from the array.
.IP "random example #1" 4
.IX Item "random example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->random; # 4
.Ve
.SS "reverse"
.IX Subsection "reverse"
.Vb 1
\&  reverse() : ArrayRef
.Ve
.PP
The reverse method returns an array reference containing the elements in the
array in reverse order.
.IP "reverse example #1" 4
.IX Item "reverse example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->reverse; # [5,4,3,2,1]
.Ve
.SS "rnsort"
.IX Subsection "rnsort"
.Vb 1
\&  rnsort() : ArrayRef
.Ve
.PP
The rnsort method returns an array reference containing the values in the array
sorted numerically in reverse.
.IP "rnsort example #1" 4
.IX Item "rnsort example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([5,4,3,2,1]);
\&
\&  $array\->rnsort; # [5,4,3,2,1]
.Ve
.SS "rotate"
.IX Subsection "rotate"
.Vb 1
\&  rotate() : ArrayLike
.Ve
.PP
The rotate method rotates the elements in the array such that first elements
becomes the last element and the second element becomes the first element each
time this method is called.
.IP "rotate example #1" 4
.IX Item "rotate example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->rotate; # [2,3,4,5,1]
.Ve
.IP "rotate example #2" 4
.IX Item "rotate example #2"
.Vb 1
\&  my $array = Data::Object::Array\->new([2,3,4,5,1]);
\&
\&  $array\->rotate; # [3,4,5,1,2]
.Ve
.SS "rsort"
.IX Subsection "rsort"
.Vb 1
\&  rsort() : ArrayRef
.Ve
.PP
The rsort method returns an array reference containing the values in the array
sorted alphanumerically in reverse.
.IP "rsort example #1" 4
.IX Item "rsort example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqa\*(Aq..\*(Aqd\*(Aq]);
\&
\&  $array\->rsort; # [\*(Aqd\*(Aq,\*(Aqc\*(Aq,\*(Aqb\*(Aq,\*(Aqa\*(Aq]
.Ve
.SS "set"
.IX Subsection "set"
.Vb 1
\&  set(Str $arg1, Any $arg2) : Any
.Ve
.PP
The set method returns the value of the element in the array at the index
specified by the argument after updating it to the value of the second
argument.
.IP "set example #1" 4
.IX Item "set example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->set(4,6); # 6
.Ve
.SS "shift"
.IX Subsection "shift"
.Vb 1
\&  shift() : Any
.Ve
.PP
The shift method returns the first element of the array shortening it by one.
.IP "shift example #1" 4
.IX Item "shift example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->shift; # 1
.Ve
.SS "size"
.IX Subsection "size"
.Vb 1
\&  size() : Num
.Ve
.PP
The size method is an alias to the length method.
.IP "size example #1" 4
.IX Item "size example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->size; # 5
.Ve
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  slice(Any @args) : HashRef
.Ve
.PP
The slice method returns a hash reference containing the elements in the array
at the index(es) specified in the arguments.
.IP "slice example #1" 4
.IX Item "slice example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->kvslice(2,4); # {2=>3, 4=>5}
.Ve
.SS "sort"
.IX Subsection "sort"
.Vb 1
\&  sort() : ArrayRef
.Ve
.PP
The sort method returns an array reference containing the values in the array
sorted alphanumerically.
.IP "sort example #1" 4
.IX Item "sort example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([\*(Aqd\*(Aq,\*(Aqc\*(Aq,\*(Aqb\*(Aq,\*(Aqa\*(Aq]);
\&
\&  $array\->sort; # [\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq,\*(Aqd\*(Aq]
.Ve
.SS "sum"
.IX Subsection "sum"
.Vb 1
\&  sum() : Num
.Ve
.PP
The sum method returns the sum of all values for all numerical elements in the
array. All non-numerical element are skipped during the evaluation process.
.IP "sum example #1" 4
.IX Item "sum example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->sum; # 15
.Ve
.SS "tail"
.IX Subsection "tail"
.Vb 1
\&  tail() : Any
.Ve
.PP
The tail method returns an array reference containing the second through the
last elements in the array omitting the first.
.IP "tail example #1" 4
.IX Item "tail example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->tail; # [2,3,4,5]
.Ve
.SS "unique"
.IX Subsection "unique"
.Vb 1
\&  unique() : ArrayRef
.Ve
.PP
The unique method returns an array reference consisting of the unique elements
in the array.
.IP "unique example #1" 4
.IX Item "unique example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1,1,1,1,2,3,1]);
\&
\&  $array\->unique; # [1,2,3]
.Ve
.SS "unshift"
.IX Subsection "unshift"
.Vb 1
\&  unshift() : Any
.Ve
.PP
The unshift method prepends the array by pushing the agruments onto it and
returns itself.
.IP "unshift example #1" 4
.IX Item "unshift example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->unshift(\-2,\-1,0); # [\-2,\-1,0,1,2,3,4,5]
.Ve
.SS "values"
.IX Subsection "values"
.Vb 1
\&  values() : ArrayRef
.Ve
.PP
The values method returns an array reference consisting of the elements in the
array. This method essentially copies the content of the array into a new
container.
.IP "values example #1" 4
.IX Item "values example #1"
.Vb 1
\&  my $array = Data::Object::Array\->new([1..5]);
\&
\&  $array\->values; # [1,2,3,4,5]
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk, \f(CW\*(C`awncorp@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2011\-2019, Al Newkirk, et al.
.PP
This is free software; you can redistribute it and/or modify it under the terms
of the The Apache License, Version 2.0, as elucidated in the \*(L"license
file\*(R" <https://github.com/iamalnewkirk/data-object/blob/master/LICENSE>.
.SH "PROJECT"
.IX Header "PROJECT"
Wiki <https://github.com/iamalnewkirk/data-object/wiki>
.PP
Project <https://github.com/iamalnewkirk/data-object>
.PP
Initiatives <https://github.com/iamalnewkirk/data-object/projects>
.PP
Milestones <https://github.com/iamalnewkirk/data-object/milestones>
.PP
Contributing <https://github.com/iamalnewkirk/data-object/blob/master/CONTRIBUTE.md>
.PP
Issues <https://github.com/iamalnewkirk/data-object/issues>
