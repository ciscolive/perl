.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Imager::Expr 3"
.TH Imager::Expr 3 "2020-06-13" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Imager::Expr \- implements expression parsing and compilation for the 
expression evaluation engine used by Imager::transform2()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
my \f(CW$code\fR = Imager::Expr\->new({rpnexpr=>$someexpr})
  or die \*(L"Cannot compile \f(CW$someexpr:\fR \*(R",\fBImager::Expr::error()\fR;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is used internally by the \fBImager::transform2()\fR function.
You shouldn't have much need to use it directly, but you may want to
extend it.
.PP
To create a new Imager::Expr object, call:
.PP
.Vb 3
\& my %options;
\& my $expr = Imager::Expr\->new(\e%options)
\&   or die Imager::Expr::error();
.Ve
.PP
You will need to set an expression value and you may set any of the
following:
.IP "\(bu" 4
constants
.Sp
A hashref defining extra constants for expression parsing.  The names
of the constants must be valid identifiers (/[^\eW\ed]\ew*/) and the
values must be valid numeric constants (that Perl recognizes in
scalars).
.Sp
Imager::Expr may define it's own constants (currently just pi.)
.IP "\(bu" 4
variables
.Sp
A reference to an array of variable names.  These are allocated
numeric registers starting from register zero.
.PP
By default you can define a \f(CW\*(C`rpnexpr\*(C'\fR key (which emulates \s-1RPN\s0) or
\&\f(CW\*(C`expr\*(C'\fR (an infix expression).  It's also possible to write other
expression parsers that will use other keys.  Only one expression key
should be defined.
.SS "Instance methods"
.IX Subsection "Instance methods"
The \fBImager::Expr::error()\fR method is used to retrieve the error if the
expression object cannot be created.
.SS "Methods"
.IX Subsection "Methods"
Imager::Expr provides only a few simple methods meant for external use:
.IP "Imager::Expr\->type_registered($keyword)" 4
.IX Item "Imager::Expr->type_registered($keyword)"
Returns true if the given expression type is available.  The parameter
is the key supplied to the \fBnew()\fR method.
.Sp
.Vb 3
\&  if (Imager::Expr\->type_registered(\*(Aqexpr\*(Aq)) {
\&    # use infix expressions
\&  }
.Ve
.ie n .IP "$expr\->\fBcode()\fR" 4
.el .IP "\f(CW$expr\fR\->\fBcode()\fR" 4
.IX Item "$expr->code()"
Returns the compiled code.
.ie n .IP "$expr\->\fBnregs()\fR" 4
.el .IP "\f(CW$expr\fR\->\fBnregs()\fR" 4
.IX Item "$expr->nregs()"
Returns a reference to the array of numeric registers.
.ie n .IP "$expr\->\fBcregs()\fR" 4
.el .IP "\f(CW$expr\fR\->\fBcregs()\fR" 4
.IX Item "$expr->cregs()"
Returns a reference to the array of color registers.
.ie n .IP "$expr\->\fBdumpops()\fR" 4
.el .IP "\f(CW$expr\fR\->\fBdumpops()\fR" 4
.IX Item "$expr->dumpops()"
Returns a string with the generated \s-1VM\s0 \*(L"machine code\*(R".
.ie n .IP "$expr\->\fBdumpcode()\fR" 4
.el .IP "\f(CW$expr\fR\->\fBdumpcode()\fR" 4
.IX Item "$expr->dumpcode()"
Returns a string with the disassembled \s-1VM\s0 \*(L"machine code\*(R".
.SS "Creating a new parser"
.IX Subsection "Creating a new parser"
I'll write this one day.
.PP
Methods used by parsers:
.IP "compile" 4
.IX Item "compile"
This is the main method you'll need to implement in a parser.  See the
existing parsers for a guide.
.Sp
It's supplied the following parameters:
.RS 4
.IP "\(bu" 4
\&\f(CW$expr\fR \- the expression to be parsed
.IP "\(bu" 4
\&\f(CW$options\fR \- the options hash supplied to transform2.
.RE
.RS 4
.Sp
Return an array ref of array refs containing opcodes and operands.
.RE
.ie n .IP "@vars = $self\->\fB_variables()\fR" 4
.el .IP "\f(CW@vars\fR = \f(CW$self\fR\->\fB_variables()\fR" 4
.IX Item "@vars = $self->_variables()"
A list (not a reference) of the input variables.  This should be used
to allocate as many registers as there are variable as input
registers.
.ie n .IP "$self\->error($message)" 4
.el .IP "\f(CW$self\fR\->error($message)" 4
.IX Item "$self->error($message)"
Set the return value of \fBImager::Expr::error()\fR
.ie n .IP "@ops = $self\->stack_to_reg(@stack_ops)" 4
.el .IP "\f(CW@ops\fR = \f(CW$self\fR\->stack_to_reg(@stack_ops)" 4
.IX Item "@ops = $self->stack_to_reg(@stack_ops)"
Converts marginally parsed \s-1RPN\s0 to register code.
.IP "\fBassemble()\fR" 4
.IX Item "assemble()"
Called to convert op codes into byte code.
.IP "\fBnumre()\fR" 4
.IX Item "numre()"
Returns a regular expression that matches floating point numbers.
.IP "\fBoptimize()\fR" 4
.IX Item "optimize()"
Optimizes the assembly code, including attempting common subexpression
elimination and strength reducing division by a constant into
multiplication by a constant.
.IP "\fBregister_type()\fR" 4
.IX Item "register_type()"
Called by a new expression parser implementation to register itself,
call as:
.Sp
.Vb 1
\&  YourClassName\->register_type(\*(Aqtype code\*(Aq);
.Ve
.Sp
where type code is the parameter that will accept the expression.
.SS "Future compatibility"
.IX Subsection "Future compatibility"
Try to avoid doing your own optimization beyond literal folding \- if
we add some sort of jump, the existing optimizer will need to be
rewritten, and any optimization you perform may well be broken too
(well, your code generation will probably be broken anyway <sigh>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Tony Cook <tonyc@cpan.org>, Arnar M. Hrafnkelsson
