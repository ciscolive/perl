.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Search::Elasticsearch::Client::7_0::Direct::Indices 3"
.TH Search::Elasticsearch::Client::7_0::Direct::Indices 3 "2020-09-15" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Search::Elasticsearch::Client::7_0::Direct::Indices \- A client for running index\-level requests
.SH "VERSION"
.IX Header "VERSION"
version 7.30
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods to make index-level requests, such as
creating and deleting indices, managing type mappings, index settings,
index templates and aliases.
.PP
It does Search::Elasticsearch::Role::Client::Direct.
.SH "INDEX METHODS"
.IX Header "INDEX METHODS"
.ie n .SS """create()"""
.el .SS "\f(CWcreate()\fP"
.IX Subsection "create()"
.Vb 2
\&    $result = $e\->indices\->create(
\&        index => \*(Aqmy_index\*(Aq             # required
\&
\&        body  => {                      # optional
\&            index settings
\&            mappings
\&            aliases
\&        }
\&    );
.Ve
.PP
The \f(CW\*(C`create()\*(C'\fR method is used to create an index. Optionally, index
settings, type mappings, and aliases can be added at the same time.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`update_all_types\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the create index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html>
for more information.
.ie n .SS """get()"""
.el .SS "\f(CWget()\fP"
.IX Subsection "get()"
.Vb 3
\&    $response = $e\->indices\->get(
\&        index   => \*(Aqindex\*(Aq   | \e@indices    # required
\&    );
.Ve
.PP
Returns the aliases, settings, and mappings for the specified indices.
.PP
See the get index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-index.html>.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_defaults\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.ie n .SS """exists()"""
.el .SS "\f(CWexists()\fP"
.IX Subsection "exists()"
.Vb 3
\&    $bool = $e\->indices\->exists(
\&        index => \*(Aqindex\*(Aq | \e@indices    # required
\&    );
.Ve
.PP
The \f(CW\*(C`exists()\*(C'\fR method returns \f(CW1\fR or the empty string to indicate
whether the specified index or indices exist.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_defaults\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR
.PP
See the index exists docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-indices-exists.html>
for more information.
.ie n .SS """delete()"""
.el .SS "\f(CWdelete()\fP"
.IX Subsection "delete()"
.Vb 3
\&    $response = $e\->indices\->delete(
\&        index => \*(Aqindex\*(Aq | \e@indices    # required
\&    );
.Ve
.PP
The \f(CW\*(C`delete()\*(C'\fR method deletes the specified indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the delete index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-delete-index.html>
for more information.
.ie n .SS """close()"""
.el .SS "\f(CWclose()\fP"
.IX Subsection "close()"
.Vb 3
\&    $response = $e\->indices\->close(
\&        index => \*(Aqindex\*(Aq | \e@indices    # required
\&    );
.Ve
.PP
The \f(CW\*(C`close()\*(C'\fR method closes the specified indices, reducing resource usage
but allowing them to be reopened later.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the close index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-open-close.html>
for more information.
.ie n .SS """open()"""
.el .SS "\f(CWopen()\fP"
.IX Subsection "open()"
.Vb 3
\&    $response = $e\->indices\->open(
\&        index => \*(Aqindex\*(Aq | \e@indices    # required
\&    );
.Ve
.PP
The \f(CW\*(C`open()\*(C'\fR method opens closed indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the open index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-open-close.html>
for more information.
.ie n .SS """rollover()"""
.el .SS "\f(CWrollover()\fP"
.IX Subsection "rollover()"
.Vb 5
\&    $response = $e\->indices\->rollover(
\&        alias     => $alias,                    # required
\&        new_index => $index,                    # optional
\&        body      => { rollover conditions }    # optional
\&    );
.Ve
.PP
Rollover an index pointed to by \f(CW\*(C`alias\*(C'\fR if it meets rollover conditions
(eg max age, max docs) to a new index name.
.PP
Query string parameters:
    \f(CW\*(C`dry_run\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the rollover index docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-rollover-index.html>
for more information.
.ie n .SS """shrink()"""
.el .SS "\f(CWshrink()\fP"
.IX Subsection "shrink()"
.Vb 5
\&    $response = $e\->shrink(
\&        index  => $index,                           # required
\&        target => $target,                          # required
\&        body   => { mappings, settings aliases }    # optional
\&    );
.Ve
.PP
The shrink \s-1API\s0 shrinks the shards of an index down to a single shard (or to a factor
of the original shards).
.PP
Query string parameters:
    \f(CW\*(C`copy_settings\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the shrink index docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-shrink-index.html>
for more information.
.ie n .SS """split()"""
.el .SS "\f(CWsplit()\fP"
.IX Subsection "split()"
.Vb 4
\&    $response = $e\->split(
\&        index  => $index,                           # required
\&        target => $target,                          # required
\&    );
.Ve
.PP
The split \s-1API\s0 splits a shard into multiple shards.
.PP
Query string parameters:
    \f(CW\*(C`copy_settings\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the split index docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-split-index.html>
for more information.
.ie n .SS """freeze()"""
.el .SS "\f(CWfreeze()\fP"
.IX Subsection "freeze()"
.Vb 3
\&    $response = $e\->indices\->freeze(
\&        $index => $index    # required
\&    );
.Ve
.PP
The \f(CW\*(C`freeze()\*(C'\fR \s-1API\s0 is used to freeze an index, which puts it in a state which has almost no
overhead on the cluster.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the freeze index docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/freeze-index-api.html>
for more information.
.ie n .SS """unfreeze()"""
.el .SS "\f(CWunfreeze()\fP"
.IX Subsection "unfreeze()"
.Vb 3
\&    $response = $e\->indices\->unfreeze(
\&        $index => $index    # required
\&    );
.Ve
.PP
The \f(CW\*(C`unfreeze()\*(C'\fR \s-1API\s0 is used to return a frozen index to its normal state.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`filter_path\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`wait_for_active_shards\*(C'\fR
.PP
See the unfreeze index docs <https://www.elastic.co/guide/en/elasticsearch/reference/current/freeze-index-api.html>
for more information.
.ie n .SS """clear_cache()"""
.el .SS "\f(CWclear_cache()\fP"
.IX Subsection "clear_cache()"
.Vb 3
\&    $response = $e\->indices\->clear_cache(
\&        index => \*(Aqindex\*(Aq | \e@indices        # optional
\&    );
.Ve
.PP
The \f(CW\*(C`clear_cache()\*(C'\fR method is used to clear the in-memory filter, fielddata,
or id cache for the specified indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`fielddata\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`query\*(C'\fR,
    \f(CW\*(C`request\*(C'\fR
.PP
See the clear_cache docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-clearcache.html>
for more information.
.ie n .SS """refresh()"""
.el .SS "\f(CWrefresh()\fP"
.IX Subsection "refresh()"
.Vb 3
\&    $response = $e\->indices\->refresh(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`refresh()\*(C'\fR method refreshes the specified indices (or all indices),
allowing recent changes to become visible to search. This process normally
happens automatically once every second by default.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
.PP
See the refresh index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-refresh.html>
for more information.
.ie n .SS """flush()"""
.el .SS "\f(CWflush()\fP"
.IX Subsection "flush()"
.Vb 3
\&    $response = $e\->indices\->flush(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`flush()\*(C'\fR method causes the specified indices (or all indices) to be
written to disk with an \f(CW\*(C`fsync\*(C'\fR, and clears out the transaction log.
This process normally happens automatically.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`force\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`wait_if_ongoing\*(C'\fR
.PP
See the flush index docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-flush.html>
for more information.
.ie n .SS """flush_synced()"""
.el .SS "\f(CWflush_synced()\fP"
.IX Subsection "flush_synced()"
.Vb 3
\&    $respnse = $e\->indices\->flush_synced(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`flush_synced()\*(C'\fR method does a synchronised \fBflush()\fR on the primaries and replicas of
all the specified indices.  In other words, after flushing it tries to write a \f(CW\*(C`sync_id\*(C'\fR
on the primaries and replicas to mark them as containing the same documents.  During
recovery, if a replica has the same \f(CW\*(C`sync_id\*(C'\fR as the primary, then it doesn't need to check
whether the segment files on primary and replica are the same, and it can move on
directly to just replaying the translog.  This can greatly speed up recovery.
.PP
Synced flushes happens automatically in the background on indices that have not received any
writes for a while, but the \fBflush_synced()\fR method can be used to trigger this process
manually, eg before shutting down.  Any new commits immediately break the sync.
.PP
See the flush synced docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-synced-flush.html>
for more information.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
.ie n .SS """forcemerge()"""
.el .SS "\f(CWforcemerge()\fP"
.IX Subsection "forcemerge()"
.Vb 3
\&    $response = $e\->indices\->forcemerge(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`forcemerge()\*(C'\fR method rewrites all the data in an index into at most
\&\f(CW\*(C`max_num_segments\*(C'\fR.  This is a very heavy operation and should only be run
with care, and only on indices that are no longer being updated.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`flush\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`max_num_segments\*(C'\fR,
    \f(CW\*(C`only_expunge_deletes\*(C'\fR
.PP
See the forcemerge docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-forcemerge.html>
for more information.
.ie n .SS """get_upgrade()"""
.el .SS "\f(CWget_upgrade()\fP"
.IX Subsection "get_upgrade()"
.Vb 3
\&    $response = $e\->indices\->get_upgrade(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`get_upgrade()\*(C'\fR method returns information about which indices need to be
upgraded, which can be done with the \f(CW\*(C`upgrade()\*(C'\fR method.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR
.PP
See the upgrade docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html>
for more information.
.ie n .SS """upgrade()"""
.el .SS "\f(CWupgrade()\fP"
.IX Subsection "upgrade()"
.Vb 3
\&    $response = $e\->indices\->upgrade(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional
\&    );
.Ve
.PP
The \f(CW\*(C`upgrade()\*(C'\fR method upgrades all segments in the specified indices to the latest format.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`only_ancient_segments\*(C'\fR,
    \f(CW\*(C`wait_for_completion\*(C'\fR
.PP
See the upgrade docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html>
for more information.
.SH "MAPPING METHODS"
.IX Header "MAPPING METHODS"
.ie n .SS """put_mapping()"""
.el .SS "\f(CWput_mapping()\fP"
.IX Subsection "put_mapping()"
.Vb 3
\&    $response = $e\->indices\->put_mapping(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional,
\&        type  => \*(Aqtype\*(Aq,                # optional
\&
\&        body  => { mapping }            # required
\&    )
.Ve
.PP
The \f(CW\*(C`put_mapping()\*(C'\fR method is used to create or update a type
mapping on an existing index.  Mapping updates are allowed to add new
fields, but not to overwrite or change existing fields.
.PP
For instance:
.PP
.Vb 12
\&    $response = $e\->indices\->put_mapping(
\&        index   => \*(Aqusers\*(Aq,
\&        type    => \*(Aquser\*(Aq,
\&        body    => {
\&            user => {
\&                properties => {
\&                    name => { type => \*(Aqstring\*(Aq  },
\&                    age  => { type => \*(Aqinteger\*(Aq }
\&                }
\&            }
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`update_all_types\*(C'\fR
.PP
See the put_mapping docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html>
for more information.
.ie n .SS """get_mapping()"""
.el .SS "\f(CWget_mapping()\fP"
.IX Subsection "get_mapping()"
.Vb 4
\&    $result = $e\->indices\->get_mapping(
\&        index => \*(Aqindex\*(Aq | \e@indices    # optional,
\&        type  => \*(Aqtype\*(Aq  | \e@types      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`get_mapping()\*(C'\fR method returns the type definitions for one, more or
all types in one, more or all indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.PP
See the get_mapping docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html>
for more information.
.ie n .SS """get_field_mapping()"""
.el .SS "\f(CWget_field_mapping()\fP"
.IX Subsection "get_field_mapping()"
.Vb 4
\&    $result = $e\->indices\->get_field_mapping(
\&        index => \*(Aqindex\*(Aq  | \e@indices    # optional,
\&        type  => \*(Aqtype\*(Aq   | \e@types      # optional,
\&        fields => \*(Aqfield\*(Aq | \e@fields     # required
\&
\&        include_defaults => 0 | 1
\&    );
.Ve
.PP
The \f(CW\*(C`get_field_mapping()\*(C'\fR method returns the field definitions for one, more or
all fields in one, more or all types and indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_defaults\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR
.PP
See the get_mapping docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-field-mapping.html>
for more information.
.ie n .SS """exists_type()"""
.el .SS "\f(CWexists_type()\fP"
.IX Subsection "exists_type()"
.Vb 4
\&    $bool = $e\->indices\->exists_type(
\&        index => \*(Aqindex\*(Aq | \e@indices    # required,
\&        type  => \*(Aqtype\*(Aq  | \e@types      # required
\&    );
.Ve
.PP
The \f(CW\*(C`exists_type()\*(C'\fR method checks for the existence of all specified types
in all specified indices, and returns \f(CW1\fR or the empty string.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR
.PP
See the exists_type docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-types-exists.html>
for more information.
.SH "ALIAS METHODS"
.IX Header "ALIAS METHODS"
.ie n .SS """update_aliases()"""
.el .SS "\f(CWupdate_aliases()\fP"
.IX Subsection "update_aliases()"
.Vb 3
\&    $response = $e\->indices\->update_aliases(
\&        body => { actions }             # required
\&    );
.Ve
.PP
The \f(CW\*(C`update_aliases()\*(C'\fR method changes (by adding or removing) multiple
index aliases atomically. For instance:
.PP
.Vb 8
\&    $response = $e\->indices\->update_aliases(
\&        body => {
\&            actions => [
\&                { add    => { alias => \*(Aqcurrent\*(Aq, index => \*(Aqlogs_2013_09\*(Aq }},
\&                { remove => { alias => \*(Aqcurrent\*(Aq, index => \*(Aqlogs_2013_08\*(Aq }}
\&            ]
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the update_aliases docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html>
for more information.
.ie n .SS """put_alias()"""
.el .SS "\f(CWput_alias()\fP"
.IX Subsection "put_alias()"
.Vb 3
\&    $response = $e\->indices\->put_alias(
\&        index => \*(Aqindex\*(Aq | \e@indices,       # required
\&        name  => \*(Aqalias\*(Aq,                   # required
\&
\&        body  => { alias defn }             # optional
\&    );
.Ve
.PP
The \f(CW\*(C`put_alias()\*(C'\fR method creates an index alias. For instance:
.PP
.Vb 7
\&    $response = $e\->indices\->put_alias(
\&        index => \*(Aqmy_index\*(Aq,
\&        name  => \*(Aqtwitter\*(Aq,
\&        body => {
\&            filter => { term => { user_id => \*(Aqtwitter\*(Aq }}
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the put_alias docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html>
for more information.
.ie n .SS """get_alias()"""
.el .SS "\f(CWget_alias()\fP"
.IX Subsection "get_alias()"
.Vb 4
\&    $result = $e\->indices\->get_alias(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        name    => \*(Aqalias\*(Aq | \e@aliases      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`get_alias()\*(C'\fR method returns the alias definitions for the specified
aliases in the specified indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR
.PP
See the get_alias docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html>
for more information.
.ie n .SS """exists_alias()"""
.el .SS "\f(CWexists_alias()\fP"
.IX Subsection "exists_alias()"
.Vb 4
\&    $bool = $e\->indices\->exists_alias(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        name    => \*(Aqalias\*(Aq | \e@aliases      # required
\&    );
.Ve
.PP
The \f(CW\*(C`exists_alias()\*(C'\fR method returns \f(CW1\fR or the empty string depending on
whether the specified aliases exist in the specified indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR
.PP
See the exists_alias docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html>
for more information.
.ie n .SS """delete_alias()"""
.el .SS "\f(CWdelete_alias()\fP"
.IX Subsection "delete_alias()"
.Vb 4
\&    $response = $e\->indices\->delete_alias(
\&        index   => \*(Aqindex\*(Aq | \e@indices        # required,
\&        name    => \*(Aqalias\*(Aq | \e@aliases        # required
\&    );
.Ve
.PP
The \f(CW\*(C`delete_alias()\*(C'\fR method deletes one or more aliases from one or more
indices.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the delete_alias docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html>
for more information.
.SH "SETTINGS METHODS"
.IX Header "SETTINGS METHODS"
.ie n .SS """put_settings()"""
.el .SS "\f(CWput_settings()\fP"
.IX Subsection "put_settings()"
.Vb 2
\&    $response = $e\->indices\->put_settings(
\&        index   => \*(Aqindex\*(Aq | \e@indices      # optional
\&
\&        body    => { settings }
\&    );
.Ve
.PP
The \f(CW\*(C`put_settings()\*(C'\fR method sets the index settings for the specified
indices or all indices. For instance:
.PP
.Vb 5
\&    $response = $e\->indices\->put_settings(
\&        body => {
\&            "index.refresh_interval" => \-1
\&        }
\&    );
.Ve
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`preserve_existing\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the put_settings docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html>
for more information.
.ie n .SS """get_settings()"""
.el .SS "\f(CWget_settings()\fP"
.IX Subsection "get_settings()"
.Vb 4
\&    $result = $e\->indices\->get_settings(
\&        index   => \*(Aqindex\*(Aq | \e@indices      # optional
\&        name    => \*(Aqname\*(Aq  | \e@names        # optional
\&    );
.Ve
.PP
The \f(CW\*(C`get_settings()\*(C'\fR method retrieves the index settings for the specified
indices or all indices.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`include_defaults\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.PP
See the get_settings docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-settings.html>
for more information.
.SH "TEMPLATE METHODS"
.IX Header "TEMPLATE METHODS"
.ie n .SS """put_template()"""
.el .SS "\f(CWput_template()\fP"
.IX Subsection "put_template()"
.Vb 4
\&    $response = $e\->indices\->put_template(
\&        name => \*(Aqtemplate\*(Aq                  # required
\&        body => { template defn }           # required
\&    );
.Ve
.PP
The \f(CW\*(C`put_template()\*(C'\fR method is used to create or update index templates.
.PP
Query string parameters:
    \f(CW\*(C`create\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`order\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR
.PP
See the put_template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html>
for more information.
.ie n .SS """get_template()"""
.el .SS "\f(CWget_template()\fP"
.IX Subsection "get_template()"
.Vb 3
\&    $result = $e\->indices\->get_template(
\&        name  => \*(Aqtemplate\*(Aq | \e@templates # optional
\&    );
.Ve
.PP
The \f(CW\*(C`get_template()\*(C'\fR method is used to retrieve a named template.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`include_type_name\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.PP
See the get_template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html>
for more information.
.ie n .SS """exists_template()"""
.el .SS "\f(CWexists_template()\fP"
.IX Subsection "exists_template()"
.Vb 3
\&    $result = $e\->indices\->exists_template(
\&        name  => \*(Aqtemplate\*(Aq                 # optional
\&    );
.Ve
.PP
The \f(CW\*(C`exists_template()\*(C'\fR method is used to check whether the named template exists.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`flat_settings\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`local\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR
.PP
See the get_template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html>
for more information.
.ie n .SS """delete_template()"""
.el .SS "\f(CWdelete_template()\fP"
.IX Subsection "delete_template()"
.Vb 3
\&    $response = $e\->indices\->delete_template(
\&        name  => \*(Aqtemplate\*(Aq                 # required
\&    );
.Ve
.PP
The \f(CW\*(C`delete_template()\*(C'\fR method is used to delete a named template.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`master_timeout\*(C'\fR,
    \f(CW\*(C`timeout\*(C'\fR,
    \f(CW\*(C`version\*(C'\fR,
    \f(CW\*(C`version_type\*(C'\fR
.PP
See the delete_template docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html>
for more information.
.SH "STATS METHODS"
.IX Header "STATS METHODS"
.ie n .SS """stats()"""
.el .SS "\f(CWstats()\fP"
.IX Subsection "stats()"
.Vb 4
\&    $result = $e\->indices\->stats(
\&        index   => \*(Aqindex\*(Aq  | \e@indices      # optional
\&        metric  => \*(Aqmetric\*(Aq | \e@metrics      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`stats()\*(C'\fR method returns statistical information about one, more or all
indices. By default it returns all metrics, but you can limit which metrics
are returned by specifying the \f(CW\*(C`metric\*(C'\fR.
.PP
Allowed metrics are:
    \f(CW\*(C`_all\*(C'\fR,
    \f(CW\*(C`completion\*(C'\fR
    \f(CW\*(C`docs\*(C'\fR,
    \f(CW\*(C`fielddata\*(C'\fR,
    \f(CW\*(C`filter_cache\*(C'\fR,
    \f(CW\*(C`flush\*(C'\fR,
    \f(CW\*(C`get\*(C'\fR,
    \f(CW\*(C`id_cache\*(C'\fR,
    \f(CW\*(C`indexing\*(C'\fR,
    \f(CW\*(C`merge\*(C'\fR,
    \f(CW\*(C`percolate\*(C'\fR,
    \f(CW\*(C`query_cache\*(C'\fR,
    \f(CW\*(C`refresh\*(C'\fR,
    \f(CW\*(C`request_cache\*(C'\fR,
    \f(CW\*(C`search\*(C'\fR,
    \f(CW\*(C`segments\*(C'\fR,
    \f(CW\*(C`store\*(C'\fR
.PP
Query string parameters:
    \f(CW\*(C`completion_fields\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`fielddata_fields\*(C'\fR,
    \f(CW\*(C`fields\*(C'\fR,
    \f(CW\*(C`groups\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`include_segment_file_sizes\*(C'\fR,
    \f(CW\*(C`level\*(C'\fR,
    \f(CW\*(C`types\*(C'\fR
.PP
See the stats docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-stats.html>
for more information.
.ie n .SS """recovery()"""
.el .SS "\f(CWrecovery()\fP"
.IX Subsection "recovery()"
.Vb 3
\&    $result = $e\->indices\->recovery(
\&        index   => \*(Aqindex\*(Aq | \e@indices      # optional
\&    );
.Ve
.PP
Provides insight into on-going shard recoveries.
.PP
Query string parameters:
    \f(CW\*(C`active_only\*(C'\fR,
    \f(CW\*(C`detailed\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR
.PP
See the recovery docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-recovery.html>
for more information.
.ie n .SS """segments()"""
.el .SS "\f(CWsegments()\fP"
.IX Subsection "segments()"
.Vb 3
\&    $result = $e\->indices\->segments(
\&        index   => \*(Aqindex\*(Aq | \e@indices      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`segments()\*(C'\fR method is used to return information about the segments
that an index contains.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`verbose\*(C'\fR
.PP
See the segments docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-segments.html>
for more information.
.ie n .SS """shard_stores()"""
.el .SS "\f(CWshard_stores()\fP"
.IX Subsection "shard_stores()"
.Vb 3
\&    $result = $e\->indices\->shard_stores(
\&        index   => \*(Aqindex\*(Aq | \e@indices      # optional
\&    );
.Ve
.PP
The \f(CW\*(C`shard_stores()\*(C'\fR method is used to find out which nodes contain
copies of which shards, whether the shards are allocated or not.
.PP
Query string parameters:
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`status\*(C'\fR
.PP
See the shard_stores docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-shards-stores.html>
for more information.
.SH "QUERY AND ANALYSIS METHODS"
.IX Header "QUERY AND ANALYSIS METHODS"
.ie n .SS """analyze()"""
.el .SS "\f(CWanalyze()\fP"
.IX Subsection "analyze()"
.Vb 4
\&    $result = $e\->indices\->analyze(
\&        index   => \*(Aqindex\*(Aq                  # optional,
\&        body    => \*(Aqtext to analyze\*(Aq
\&    );
.Ve
.PP
The \f(CW\*(C`analyze()\*(C'\fR method passes the text in the \f(CW\*(C`body\*(C'\fR through the specified
\&\f(CW\*(C`analyzer\*(C'\fR, \f(CW\*(C`tokenizer\*(C'\fR or token \f(CW\*(C`filter\*(C'\fR \- which may be global, or associated
with a particular index or field \- and returns the tokens.  Very useful
for debugging analyzer configurations.
.PP
Query string parameters:
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`human\*(C'\fR
.PP
See the analyze docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html>
for more information.
.ie n .SS """validate_query()"""
.el .SS "\f(CWvalidate_query()\fP"
.IX Subsection "validate_query()"
.Vb 3
\&    $result = $e\->indices\->validate_query(
\&        index   => \*(Aqindex\*(Aq | \e@indices,     # optional
\&        type    => \*(Aqtype\*(Aq  | \e@types,       # optional
\&
\&        body    => { query }
\&    );
.Ve
.PP
The \f(CW\*(C`validate_query()\*(C'\fR method accepts a query in the \f(CW\*(C`body\*(C'\fR and checks
whether the query is valid or not.  Most useful when \f(CW\*(C`explain\*(C'\fR is set
to \f(CW\*(C`true\*(C'\fR, in which case it includes an execution plan in the output.
.PP
Query string parameters:
    \f(CW\*(C`all_shards\*(C'\fR,
    \f(CW\*(C`allow_no_indices\*(C'\fR,
    \f(CW\*(C`analyze_wildcard\*(C'\fR,
    \f(CW\*(C`analyzer\*(C'\fR,
    \f(CW\*(C`default_operator\*(C'\fR,
    \f(CW\*(C`df\*(C'\fR,
    \f(CW\*(C`error_trace\*(C'\fR,
    \f(CW\*(C`explain\*(C'\fR,
    \f(CW\*(C`expand_wildcards\*(C'\fR,
    \f(CW\*(C`ignore_unavailable\*(C'\fR,
    \f(CW\*(C`lenient\*(C'\fR,
    \f(CW\*(C`q\*(C'\fR,
    \f(CW\*(C`rewrite\*(C'\fR
.PP
See the validate_query docs <http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-validate.html>
for more information.
.SH "AUTHOR"
.IX Header "AUTHOR"
Enrico Zimuel <enrico.zimuel@elastic.co>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Elasticsearch \s-1BV.\s0
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
