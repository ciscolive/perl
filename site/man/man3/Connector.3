.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector 3"
.TH Connector 3 "2020-06-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Connector \- a generic connection to a hierarchical\-structured data set
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Connector is generic connection to a data set, typically configuration
data in a hierarchical structure. Each connector object accepts the get(\s-1KEY\s0)
method, which, when given a key, returns the associated value from the
connector's data source.
.PP
Typically, a connector acts as a proxy to a simple data source like
\&\s-1YAML,\s0 Config::Std, Config::Versioned, or to a more complex data source
like an \s-1LDAP\s0 server or Proc::SafeExec. The standard calling convention
via get(\s-1KEY\s0) makes the connectors interchangeable.
.PP
In addition, a set of meta-connectors may be used to combine multiple
connectors into more complex chains. The Connector::Multi, for example,
allows for redirection to delegate connectors via symbolic links. If
you have a list of connectors and want to use them in a load-balancing,
round-robin fashion or have the list iterated until a value is found,
use Connector::List and choose the algorithm to perform.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Connector::MODULENAME;
\&
\&    my $conn = Connector::MODULENAME\->new( {
\&        LOCATION => $path_to_config_for_module,
\&    });
\&
\&    my $val = $conn\->get(\*(Aqfull.name.of.key\*(Aq);
.Ve
.SS "Connector Class"
.IX Subsection "Connector Class"
This is the base class for all Connector implementations. It provides
common helper methods and performs common sanity checking.
.PP
Usually this class should not be instantiated directly.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.SS "die_on_undef"
.IX Subsection "die_on_undef"
Set to true if you want the connector to die when a query reaches a non-exisiting
node. This will affect calls to get/get_list/get_hash and will not affect
values that are explicitly set to undef (if supported by the connector!).
.PP
Each accessor method is valid only on special types of nodes. If you call them
on a wrong type of node, the connector may retunr unexpected result or simply die.
.SS "exists"
.IX Subsection "exists"
.SS "get"
.IX Subsection "get"
Basic method to obtain a scalar value at the leaf of the config tree.
.PP
.Vb 1
\&  my $value = $connector\->get(\*(Aqsmartcard.owners.tokenid.bob\*(Aq);
.Ve
.PP
Each implementation must also accept an arrayref as path. The path is
contructed from the elements. The default behaviour allows strings using
the delimiter character inside an array element. If you want each array
element to be parsed, you need to pass \*(L"\s-1RECURSEPATH\s0 => 1\*(R" to the constructor.
.PP
.Vb 1
\&  my $value = $connector\->get( [ \*(Aqsmartcard\*(Aq,\*(Aqowners\*(Aq,\*(Aqtokenid\*(Aq,\*(Aqbob.builder\*(Aq ] );
.Ve
.PP
Some implementations accept control parameters, which can be passed by
\&\fIparams\fR, which is a hash ref of key => value pairs.
.PP
.Vb 1
\&  my $value = $connector\->get( \*(Aqsmartcard.owners.tokenid.bob\*(Aq , { version => 1 } );
.Ve
.SS "get_list"
.IX Subsection "get_list"
This method is only valid if it is called on a \*(L"n\-1\*(R" depth node representing
an ordered list of items (array). The return value is an array with all
values present below the node.
.PP
.Vb 1
\&  my @items = $connector\->get_list( \*(Aqsmartcard.owners.tokenid\*(Aq  );
.Ve
.SS "get_size"
.IX Subsection "get_size"
This method is only valid if it is called on a \*(L"n\-1\*(R" depth node representing
an ordered list of items (array). The return value is the number of elements
in this array (including undef elements if they are explicitly given).
.PP
.Vb 1
\&  my $count = $connector\->get_size( \*(Aqsmartcard.owners.tokens.bob\*(Aq );
.Ve
.PP
If the node does not exist, 0 is returned.
.SS "get_hash"
.IX Subsection "get_hash"
This method is only valid if it is called on a \*(L"n\-1\*(R" depth node representing
a key => value list (hash). The return value is a hash ref.
.PP
.Vb 1
\&  my %data = %{$connector\->get_hash( \*(Aqsmartcard.owners.tokens.bob\*(Aq )};
.Ve
.SS "get_keys"
.IX Subsection "get_keys"
This method is only valid if it is called on a \*(L"n\-1\*(R" depth node representing
a key => value list (hash). The return value is an array holding the
values of all keys (including undef elements if they are explicitly given).
.PP
.Vb 1
\&  my @keys = $connector\->get_keys( \*(Aqsmartcard.owners.tokens.bob\*(Aq );
.Ve
.PP
If the node does not exist, an empty list is returned.
.SS "get_reference"
.IX Subsection "get_reference"
Rarely used, returns the value of a reference node. Currently used by
Connector::Multi in combination with Connector::Proxy::Config::Versioned
to create internal links and cascaded connectors. See Connector::Multi
for details.
.SS "set"
.IX Subsection "set"
The set method is a \*(L"all in one\*(R" implementation, that is used for either type
of value. If the value is not a scalar, it must be passed by reference.
.PP
.Vb 1
\&  $connector\->set(\*(Aqsmartcard.owners.tokenid.bob\*(Aq, $value, $params);
.Ve
.PP
The \fIvalue\fR parameter holds a scalar or ref to an array/hash with the data to
be written. \fIparams\fR is a hash ref which holds additional parameters for the
operation and can be undef if not needed.
.SH "STRUCTURAL METHODS"
.IX Header "STRUCTURAL METHODS"
.SS "get_meta"
.IX Subsection "get_meta"
This method returns some structural information about the current node as
hash ref. At minimum it must return the type of node at the current path.
.PP
Valid values are \fIscalar, list, hash, reference\fR. The types match the
accessor methods given above (use \f(CW\*(C`get\*(C'\fR for \fIscalar\fR).
.PP
.Vb 2
\&    my $meta = $connector\->get_meta( \*(Aqsmartcard.owners\*(Aq );
\&    my $type = $meta\->{TYPE};
.Ve
.PP
When you call a proxy connector without sufficient arguments to perform the
query, you will receive a value of \fIconnector\fR for type. Running a get_*
method against such a node will cause the connector to die!
.SH "IMPLEMENTATION GUIDELINES"
.IX Header "IMPLEMENTATION GUIDELINES"
You \s-1SHOULD\s0 use the _node_not_exists method if the requested path does not exist
or has an undefined value. This will internally take care of the \fIdie_on_undef\fR
setting and throw an exception or return undef. So you can just write:
.PP
.Vb 3
\&    if (path not exists || not defined val) {
\&        return $self\->_node_not_exists( pathspec );
\&    }
.Ve
.PP
As connectors are often used in eval constructs where the error messages
are swallowed you \s-1SHOULD\s0 log a verbose error before aborting with
die/confess. You can use the _log_and_die method for this purpose. It will
send a message to the logger on error level before calling \*(L"die \f(CW$message\fR\*(R".
.SS "path building"
.IX Subsection "path building"
You should always pass the first parameter to the private \f(CW\*(C`_build_path\*(C'\fR
method. This method converts any valid path spec representation to a valid
path. It takes care of the \s-1RECURSEPATH\s0 setting and returns the path
elements as list.
.SS "Supported methods"
.IX Subsection "Supported methods"
The methods get, get_list, get_size, get_hash, get_keys, set, get_meta are
routed to the appropriate connector.
.PP
You \s-1MUST\s0 implement at minimum one of the three data getters, if get_list/get_keys
is omited, the base class will do a get_list/get_keys call and return the info
which will be a correct result but might be expensive, so you can provide your
own implementiation if required.
.PP
You \s-1MUST\s0 also implement the get_meta method. If you have a connector with a
fixed type, you \s-1MAY\s0 check if the particular path exists and return
the result of \fI_node_not_exists\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Scott Hardin <mrscotty@cpan.org>
.PP
Martin Bartosch
.PP
Oliver Welter
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2013 OpenXPKI Foundation
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 376:" 4
.IX Item "Around line 376:"
Unknown directive: =head
