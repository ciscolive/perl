.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Shiras::Test2 3"
.TH Log::Shiras::Test2 3 "2016-10-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Shiras::Test2 \- Test2 for traffic in the ::Switchboard
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        use Test2::Bundle::Extended qw( !meta );
\&        use Test2::Plugin::UTF8;
\&        use Test::Log::Shiras;
\&        plan( 3 );
\&        
\&        ~~ Set up the Log::Shiras::Switchboard operator here ($ella_peterson) ~~
\&        
\&        my $test_class;
\&        ok( lives{      $test_class = Log::Shiras::Test2\->new },
\&                                                                                        "Build a test class for reading messages from the bat phone" ) or note($@);;
\&        ok( lives{
\&                                $ella_peterson\->master_talk({ # Use Ella Petersons bat phone
\&                                        name_space => \*(Aqmain\*(Aq, report => \*(Aqreport1\*(Aq, level => \*(Aqeleven\*(Aq, 
\&                                        message =>[ \*(AqHello World\*(Aq ], });
\&        },                                                                              "Test making a call (with Ella Petersons bat phone)" ) or note($@);
\&        $test_class\->match_message( \*(Aqreport1\*(Aq, "Hello World",
\&                                                                                        "... and check the output" );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a class used for testing.  It inherits directly from Test2::API without going through 
Test::Builder.  This will feed back to any Test2 rooted test with the understanding that even 
Test::More now uses Test2 Under the hood.  The tests are object oriented methods rather than 
functions.  That was a conscious choice in order to auto link to the singleton once without 
re-connecting over and over.  The goal is to be able to set up messages to the switchboard with 
minimum wiring to the reports and still be able to see if the messages are working as expected.  
Log::Shiras::Switchboard will actually check if this module is active and store messages to a test 
buffer right before sending them to the reports.  This allows the reports to exist in name only 
and to still test permissions levels and caller actions without using Capture::Tiny or reading 
output files for test results.
.SS "Attributes"
.IX Subsection "Attributes"
These are things that can be passed to the \->new argument in order to change the general behavior 
of the test instance.
.PP
\fIkeep_matches\fR
.IX Subsection "keep_matches"
.Sp
.RS 4
\&\fBDescription:\fR This determines whether a match is deleted from the test buffer when it is matched 
by the test match_message.
.Sp
\&\fBRange:\fR accepts a boolean value
.Sp
\&\fBDefault:\fR 1 = yes, matches are deleted when found
.Sp
\&\fBattribute methods:\fR
.Sp
.RS 4
\&\fBset_match_retention( \f(CB$bool\fB )\fR
.Sp
.RS 4
\&\fBDescription:\fR Changes the keep_matches attribute setting to the passed \f(CW$bool\fR
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
\fItest_buffer_size\fR
.IX Subsection "test_buffer_size"
.Sp
.RS 4
\&\fBDescription:\fR This attribute attempts to mirror \f(CW$Test::Log::Shiras::last_buffer_position\fR
\&.  If you set it upon instantiation of an instance of this 
class then it will change the global variable too.
.Sp
\&\fBRange:\fR accepts a positive integer
.Sp
\&\fBDefault:\fR 11 this starts at eleven
.Sp
\&\fBattribute methods:\fR
.Sp
.RS 4
\&\fBchange_test_buffer_size( \f(CB$int\fB )\fR
.Sp
.RS 4
\&\fBDefinition:\fR This will change the maximum test buffer size.  If the target buffer size is 
reduced greater than the current buffer contents the size will not be resolved until the next 
message is sent to the buffer.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.SS "Methods"
.IX Subsection "Methods"
These are not tests!
.PP
\fIget_buffer( \f(CI$report\fI )\fR
.IX Subsection "get_buffer( $report )"
.Sp
.RS 4
\&\fBDefinition:\fR This will return the full test buffer for a given report.  It should be noted 
that messages are stored with metadata.  Active buffers are not an ArrayRef of strings.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name
.Sp
\&\fBReturns:\fR An ArrayRef of HashRefs
.RE
.SS "Tests"
.IX Subsection "Tests"
All tests here are written as methods on an object not exportable functions.  As such they 
are implemented in the following fashion.
.PP
.Vb 2
\&        my $tester = Test::Log::Shiras\->new;
\&        $tester\->match_message( $report, $wanted, $message );
.Ve
.PP
\fIclear_buffer( \f(CI$report\fI, \f(CI$message\fI )\fR
.IX Subsection "clear_buffer( $report, $message )"
.Sp
.RS 4
\&\fBDefinition:\fR This test will clear the buffer.  It always passes.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name string to clear and the \f(CW$message\fR to append to the test report.
.Sp
\&\fBReturns:\fR The cleared test name_space
.RE
.PP
\fIhas_buffer( \f(CI$report\fI, \f(CI$expected\fI, \f(CI$message\fI )\fR
.IX Subsection "has_buffer( $report, $expected, $message )"
.Sp
.RS 4
\&\fBDefinition:\fR This test checks to see if there is a test buffer for the \f(CW$report\fR name.  It allows 
for testing a buffer existence whether the buffer is \f(CW$expected\fR to exist or not.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name string to check and whether you \f(CW$expected\fR to find the buffer or not.  
It also accepts the \f(CW$message\fR used for test result reporting.
.Sp
\&\fBReturns:\fR The tested report buffer name
.RE
.PP
\fIbuffer_count( \f(CI$report\fI, \f(CI$expected\fI, \f(CI$message\fI )\fR
.IX Subsection "buffer_count( $report, $expected, $message )"
.Sp
.RS 4
\&\fBDefinition:\fR This test checks a known buffer to see how many records it contains.  It will compare that 
to how many records are \f(CW$expected\fR.  The buffer count will mostly never exceed the mandated max
 buffer size.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name string to check and how many records were \f(CW$expected\fR in the buffer.  
It also accepts the \f(CW$message\fR used for test result reporting.
.Sp
\&\fBReturns:\fR The tested report buffer name
.RE
.PP
\fImatch_message( \f(CI$report\fI, \f(CI$test_line\fI, \f(CI$message\fI )\fR
.IX Subsection "match_message( $report, $test_line, $message )"
.Sp
.RS 4
\&\fBDefinition:\fR This test checks if a \f(CW$test_line\fR exists in any of the message elements in the test buffer.  
The message elements take the following relevant format.
.Sp
.Vb 1
\&        $message\->{message} =>[ $compare_line1, $compare_line2, etc. ]
.Ve
.Sp
\&\f(CW$compare_line1\fR and \f(CW$compare_line2\fR are the elements tested.  If \f(CW$test_line\fR is a RegexpRef then it will 
do a regex compare otherwise it does an exact string 'eq' compare.  If there is a match the test will 
splice out the message from the buffer so It won't show up again unless you re-send it to the buffer.  
This behavior can be changed with the attribute keep_matches.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name string a \f(CW$test_line\fR [or regex] to check with.  It also accepts the 
\&\f(CW$message\fR used for test result reporting.
.Sp
\&\fBReturns:\fR The tested report buffer name
.RE
.PP
\fIcant_match_message( \f(CI$report\fI, \f(CI$test_line\fI, \f(CI$message\fI )\fR
.IX Subsection "cant_match_message( $report, $test_line, $message )"
.Sp
.RS 4
\&\fBDefinition:\fR This test checks all messages in a buffer to see if a \f(CW$test_line\fR exists in any of the 
message elements.  The message elements take the following relevant format.
.Sp
.Vb 1
\&        $message\->{message} =>[ $compare_line1, $compare_line2, etc. ]
.Ve
.Sp
\&\f(CW$compare_line1\fR and \f(CW$compare_line2\fR are the elements tested.  If \f(CW$test_line\fR is a RegexpRef then it will 
do a regex compare otherwise it does an exact string 'eq' compare.  Even if there is a match the buffer 
remains un-edited but the test fails.
.Sp
\&\fBAccepts:\fR The target \f(CW$report\fR name string a \f(CW$test_line\fR [or regex] to check with.  It also accepts the 
\&\f(CW$message\fR used for test result reporting.
.Sp
\&\fBReturns:\fR The tested report buffer name
.RE
.SS "\s-1GLOBAL VARIABLES\s0"
.IX Subsection "GLOBAL VARIABLES"
.RS 4
\&\fB\f(CB$Test::Log::Shiras::last_buffer_position\fB\fR
.Sp
.RS 4
In order to not have memory issues with long running tests that accumulate buffers without 
flushing there is a global variable for the max items in the test buffer.  The actual test 
buffer is not stored here but rather in the Switchboard in 
order to leverage the Singleton there.  The default value is 11 (Store to 11).  So if you 
want to do a lot of work and then check if a message was processed early on then you need 
to increase this value (equivalent to max buffer size).  Internal to the instance it is 
best to change the max buffer using the attribute test_buffer_size 
and it's method.
.RE
.RE
.RS 4
.RE
.SH "SUPPORT"
.IX Header "SUPPORT"
.IP "github Log\-Shiras/issues <https://github.com/jandrew/Log-Shiras/issues>" 4
.IX Item "github Log-Shiras/issues <https://github.com/jandrew/Log-Shiras/issues>"
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR Nothing yet
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund.
.SH "DEPENDANCIES"
.IX Header "DEPENDANCIES"
.RS 4
version \- 0.77
.Sp
5.010 <http://perldoc.perl.org/perl5100delta.html> (for use of
defined or <http://perldoc.perl.org/perlop.html#Logical-Defined-Or> //)
.Sp
utf8
.Sp
Moose
.Sp
MooseX::StrictConstructor
.Sp
MooseX::HasDefaults::RO
.Sp
Test2::API \- context
.Sp
MooseX::Types::Moose \- RegexpRef Bool ArrayRef
.Sp
Log::Shiras::Switchboard \- 0.029
.Sp
Log::Shiras::Types
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Log::Log4perl::Appender::TestBuffer
.Sp
Log::Log4perl::Appender::TestArrayBuffer
.RE
