.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Spreadsheet::ReadSXC 3"
.TH Spreadsheet::ReadSXC 3 "2020-10-06" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::ReadSXC \- Extract OpenOffice 1.x spreadsheet data
.SH "NOTICE"
.IX Header "NOTICE"
This is a legacy \s-1API\s0 wrapper. Most likely you want to look at
Spreadsheet::ParseODS, which implements an \s-1API\s0 more compatible with
Spreadsheet::ParseXLSX. That module is also the backend for this \s-1API.\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Spreadsheet::ReadSXC qw(read_sxc);
\&  my $workbook_ref = read_sxc("/path/to/file.sxc");
\&
\&  # Alternatively, unpack the .sxc file yourself and pass content.xml
\&
\&  use Spreadsheet::ReadSXC qw(read_xml_file);
\&  my $workbook_ref = read_xml_file("/path/to/content.xml");
\&
\&
\&  # Alternatively, pass the XML string directly
\&
\&  use Spreadsheet::ReadSXC qw(read_xml_string);
\&  use Archive::Zip;
\&  my $zip = Archive::Zip\->new("/path/to/file.sxc");
\&  my $content = $zip\->contents(\*(Aqcontent.xml\*(Aq);
\&  my $workbook_ref = read_xml_string($content);
\&
\&
\&  # Control the output through a hash of options (below are the defaults):
\&
\&  my %options = (
\&    ReplaceNewlineWith  => "",
\&    IncludeCoveredCells => 0,
\&    DropHiddenRows      => 0,
\&    DropHiddenColumns   => 0,
\&    NoTruncate          => 0,
\&    StandardCurrency    => 0,
\&    StandardDate        => 0,
\&    StandardTime        => 0,
\&    OrderBySheet        => 0,
\&    StrictErrors        => 0,
\&  );
\&  my $workbook_ref = read_sxc("/path/to/file.sxc", \e%options );
\&
\&
\&  # Iterate over every worksheet, row, and cell:
\&
\&  use Encode \*(Aqdecode\*(Aq;
\&
\&  foreach ( sort keys %$workbook_ref ) {
\&     print "Worksheet ", $_, " contains ", $#{$$workbook_ref{$_}} + 1, " row(s):\en";
\&     foreach ( @{$$workbook_ref{$_}} ) {
\&        foreach ( map { defined $_ ? $_ : \*(Aq\*(Aq } @{$_} ) {
\&          my $str = decode(\*(AqUTF\-8\*(Aq, $_);
\&          print " \*(Aq$str\*(Aq";
\&        }
\&        print "\en";
\&     }
\&  }
\&
\&
\&  # Cell D2 of worksheet "Sheet1"
\&
\&  $cell = $$workbook_ref{"Sheet1"}[1][3];
\&
\&
\&  # Row 1 of worksheet "Sheet1":
\&
\&  @row = @{$$workbook_ref{"Sheet1"}[0]};
\&
\&
\&  # Worksheet "Sheet1":
\&
\&  @sheet = @{$$workbook_ref{"Sheet1"}};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Spreadsheet::ReadSXC extracts data from OpenOffice 1.x spreadsheet
files (.sxc). It exports the function \fBread_sxc()\fR which takes a
filename and an optional reference to a hash of options as
arguments and returns a reference to a hash of references to
two-dimensional arrays. The hash keys correspond to the names of
worksheets in the OpenOffice workbook. The two-dimensional arrays
correspond to rows and cells in the respective spreadsheets. If
you don't like this because the order of sheets is not preserved
in a hash, read on. The 'OrderBySheet' option provides an array
of hashes instead.
.PP
If you prefer to unpack the .sxc file yourself, you can use the
function \fBread_xml_file()\fR instead and pass the path to content.xml
as an argument. Or you can extract the \s-1XML\s0 string from content.xml
and pass the string to the function \fBread_xml_string()\fR. Both
functions also take a reference to a hash of options as an
optional second argument.
.PP
Spreadsheet::ReadSXC uses XML::Twig to parse the \s-1XML\s0
contained in .sxc files. Only the contents of text:p elements are
returned, not the actual values of table:value attributes. For
example, a cell might have a table:value\-type attribute of
\&\*(L"currency\*(R", a table:value attribute of \*(L"\-1500.99\*(R" and a
table:currency attribute of \*(L"\s-1USD\*(R".\s0 The text:p element would
contain \*(L"\-$1,500.99\*(R". This is the string which is returned by the
\&\fBread_sxc()\fR function, not the value of \-1500.99.
.PP
Spreadsheet::ReadSXC was written with data import into an \s-1SQL\s0
database in mind. Therefore empty spreadsheet cells correspond to
undef values in array rows. The example code above shows how to
replace undef values with empty strings.
.PP
If the .sxc file contains an empty spreadsheet its hash element will
point to an empty array (unless you use the 'NoTruncate' option in
which case it will point to an array of an array containing one
undefined element).
.PP
OpenOffice uses \s-1UTF\-8\s0 encoding. It depends on your environment how
the data returned by the \s-1XML\s0 Parser is best handled:
.PP
.Vb 2
\&  use Unicode::String qw(latin1 utf8);
\&  $unicode_string = utf8($$workbook_ref{"Sheet1"}[0][0])\->as_string;
\&
\&  # this will not work for characters outside ISO\-8859\-1:
\&
\&  $latin1_string = utf8($$workbook_ref{"Sheet1"}[0][0])\->latin1;
.Ve
.PP
Of course there are other modules than Unicode::String on \s-1CPAN\s0 that
handle conversion between encodings. It's your choice.
.PP
Table rows in .sxc files may have a \*(L"table:number\-rows\-repeated\*(R"
attribute, which is often used for consecutive empty rows. When you
format whole rows and/or columns in OpenOffice, it sets the numbers
of rows in a worksheet to 32,000 and the number of columns to 256, even
if only a few lower-numbered rows and cells actually contain data.
Spreadsheet::ReadSXC truncates such sheets so that there are no empty
rows after the last row containing data and no empty columns after the
last column containing data (unless you use the 'NoTruncate' option).
.PP
Still it is perfectly legal for an .sxc file to apply the
\&\*(L"table:number\-rows\-repeated\*(R" attribute to rows that actually contain
data (although I have only been able to produce such files manually,
not through OpenOffice itself). To save on memory usage in these cases,
Spreadsheet::ReadSXC does not copy rows by value, but by reference
(remember that multi-dimensional arrays in Perl are really arrays of
references to arrays). Therefore, if you change a value in one row, it
is possible that you find the corresponding value in the next row
changed, too:
.PP
.Vb 2
\&  $$workbook_ref{"Sheet1"}[0][0] = \*(Aqnew string\*(Aq;
\&  print $$workbook_ref{"Sheet1"}[1][0];
.Ve
.PP
As of version 0.20 the references returned by \fBread_sxc()\fR et al. remain
valid after subsequent calls to the same function. In earlier versions,
calling \fBread_sxc()\fR with a different file as the argument would change
the data referenced by the original return value, so you had to
derefence it before making another call. Thanks to H. Merijn Brand for
fixing this.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "StrictErrors" 4
.IX Item "StrictErrors"
Turn on error reporting by using \f(CW\*(C`croak\*(C'\fR. Otherwise, functions silently
return \f(CW\*(C`undef\*(C'\fR when errors are encountered.
.IP "ReplaceNewlineWith" 4
.IX Item "ReplaceNewlineWith"
By default, newlines within cells are ignored and all lines in a cell
are concatenated to a single string which does not contain a newline. To
keep the newline characters, use the following key/value pair in your
hash of options:
.Sp
.Vb 1
\&  ReplaceNewlineWith => "\en"
.Ve
.Sp
However, you may replace newlines with any string you like.
.IP "IncludeCoveredCells" 4
.IX Item "IncludeCoveredCells"
By default, the content of cells that are covered by other cells is
ignored because you wouldn't see it in OpenOffice unless you unmerge
the merged cells. To include covered cells in the data structure which
is returned by \fBparse_sxc()\fR, use the following key/value pair in your
hash of options:
.Sp
.Vb 1
\&  IncludeCoveredCells => 1
.Ve
.IP "DropHiddenRows" 4
.IX Item "DropHiddenRows"
By default, hidden rows are included in the data structure returned by
\&\fBparse_sxc()\fR. To drop those rows, use the following key/value pair in
your hash of options:
.Sp
.Vb 1
\&  DropHiddenRows => 1
.Ve
.IP "DropHiddenColumns" 4
.IX Item "DropHiddenColumns"
By default, hidden columns are included in the data structure returned
by \fBparse_sxc()\fR. To drop those rows, use the following key/value pair
in your hash of options:
.Sp
.Vb 1
\&  DropHiddenColumns => 1
.Ve
.IP "NoTruncate" 4
.IX Item "NoTruncate"
By default, the two-dimensional arrays that contain the data within
each worksheet are truncated to get rid of empty rows below the last
row containing data and empty columns beyond the last column
containing data. If you prefer to keep those rows and columns, use the
following key/value pair in your hash of options:
.Sp
.Vb 1
\&  NoTruncate => 1
.Ve
.IP "StandardCurrency" 4
.IX Item "StandardCurrency"
By default, cells are returned as formatted. If you prefer to
obtain the value as contained in the table:value attribute,
use the following key/value pair in your hash of options:
.Sp
.Vb 1
\&  StandardCurrency => 1
.Ve
.IP "StandardDate" 4
.IX Item "StandardDate"
By default, date cells are returned as formatted. If you prefer to
obtain the date value as contained in the table:date\-value attribute,
use the following key/value pair in your hash of options:
.Sp
.Vb 1
\&  StandardDate => 1
.Ve
.IP "StandardTime" 4
.IX Item "StandardTime"
By default, time cells are returned as formatted. If you prefer to
obtain the time value as contained in the table:time\-value attribute,
use the following key/value pair in your hash of options:
.Sp
.Vb 1
\&  StandardTime => 1
.Ve
.Sp
These options are a first step on the way to a different approach at
reading data from .sxc files. There should be more options to read in
values instead of the strings OpenOffice displays. It should give
more flexibility in working with the data obtained from OpenOffice
spreadsheets. 'float' and 'percentage' values could be next.
\&'currency' is less obvious, though, as we need to consider both its
value and the 'table:currency' attribute. Formulas and array formulas
are yet another issue. I probably won't deal with this until I've
given this module an object-oriented interface.
.IP "OrderBySheet" 4
.IX Item "OrderBySheet"
The disadvantage of storing worksheets by name in a hash is that the
order of sheets is lost. If you prefer not to obtain such a hash, but
an array of worksheets insted, use the following key/value pair in
your hash of options:
.Sp
.Vb 1
\&  OrderBySheet => 1
.Ve
.Sp
Thus the read_sxc function will return an array of hashes, each of
which will have two keys, \*(L"label\*(R" and \*(L"data\*(R". The value of \*(L"label\*(R"
is the name of the sheet. The value of data is a reference to a
two-dimensional array containing rows and columns of the worksheet:
.Sp
.Vb 3
\&  my $worksheets_ref = read_sxc("/path/to/file.sxc");
\&  my $name_of_first_sheet = $$worksheets_ref[0]{label};
\&  my $first_cell_of_first_sheet = $$worksheets_ref[0]{data}[0][0];
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "read_sxc"
.IX Subsection "read_sxc"
.Vb 1
\&  my $workbook_ref = read_sxc("/path/to/file.sxc");
.Ve
.PP
Reads an \s-1SXC\s0 or \s-1ODS\s0 file given a filename and returns the worksheets as a
data structure.
.SS "read_sxc_fh"
.IX Subsection "read_sxc_fh"
.Vb 2
\&    open my $fh = \*(Aqexample.ods\*(Aq;
\&    my $sheet = read_sxc_fh( $fh );
.Ve
.PP
Reads an \s-1SXC\s0 or \s-1ODS\s0 file given a filehandle and returns the worksheets as a
data structure.
.SS "read_xml_file"
.IX Subsection "read_xml_file"
.Vb 1
\&  my $workbook_ref = read_xml_file("/path/to/content.xml");
.Ve
.PP
Reads an \s-1XML\s0 file from a \s-1SXC\s0 or \s-1ODS\s0 file returns the worksheets as a
data structure.
.SS "read_xml_string"
.IX Subsection "read_xml_string"
Parses an \s-1XML\s0 string and eturns the worksheets as a data structure.
.SH "Reading an SXC file from an URL"
.IX Header "Reading an SXC file from an URL"
.Vb 2
\&    use HTTP::Tiny;
\&    use Spreadsheet::Read;
\&
\&    # Fetch data and return a filehandle to that data
\&    sub fetch_url {
\&        my( $url ) = @_;
\&        my $ua = HTTP::Tiny\->new;
\&        my $res = $ua\->get( $url );
\&        open my $fh, \*(Aq<\*(Aq, \e$res\->{content};
\&        return $fh
\&    }
\&    my $fh = fetch_url(\*(Aqhttp://example.com/example.ods\*(Aq);
\&    my $sheet = read_sxc_fh( $fh );
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<https://www.openoffice.org/xml/general.html> has extensive documentation
of the OpenOffice 1.x \s-1XML\s0 file format (soon to be replaced by the
\&\s-1OASIS\s0 file format (\s-1ODS\s0), see <http://docs.oasis\-open.org/office/v1.2/OpenDocument\-v1.2.pdf>).
.SH "AUTHOR"
.IX Header "AUTHOR"
Christoph Terhechte, <terhechte@cpan.org>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Max Maischein, <mailto:corion@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2005\-2019 by Christoph Terhechte
Copyright 2019\- by Max Maischein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
