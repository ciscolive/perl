.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser::MGC::Examples::EvaluateExpression 3"
.TH Parser::MGC::Examples::EvaluateExpression 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Parser::MGC::Examples::EvaluateExpression" \- an example parser to evaluate simple numerical expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This evaluator-parser takes simple mathematical expressions involving the four
basic arithmetic operators (+, \-, *, /) applied to integers, and returns the
numerical result. It handles operator precedence, with * and / having a higher
level than + and \-, and copes with parentheses.
.PP
Operator precedence is implemented by using two different parsing functions to
handle the two different precedence levels.
.SS "Boilerplate"
.IX Subsection "Boilerplate"
We start off by declaring a package and subclassing Parser::MGC.
.PP
.Vb 2
\&   package ExprParser;
\&   use base qw( Parser::MGC );
\&
\&   use strict;
\&   use warnings;
.Ve
.SS "parse"
.IX Subsection "parse"
The topmost parsing function, \f(CW\*(C`parse\*(C'\fR, handles the outermost level of
operator precedence, the + and \- operators. It first parses a single term from
the input by callling \f(CW\*(C`parse_term\*(C'\fR to obtain its value.
.PP
It then uses the \f(CW\*(C`any_of\*(C'\fR structure-forming method to look for either a + or \-
operator which would indicate another term will follow it. If it finds either
of these, it parses the next term from after the operator by another call to
\&\f(CW\*(C`parse_term\*(C'\fR and then adds or subtracts the value of it from the running
total.
.PP
The \f(CW\*(C`any_of\*(C'\fR call itself is used as the conditional expression of a \f(CW\*(C`while\*(C'\fR
loop, to ensure it gets called multiple times. Whenever another term has been
parsed, the body function returns a true value, to indicate that the while
loop should be invoked again. Only when there are no more + or \- operators,
indicating no more terms, does the body return false, causing the while loop
to stop.
.PP
This continues until there are no more + or \- operators, when the overall
total value is returned to the caller.
.PP
.Vb 3
\&   sub parse
\&   {
\&      my $self = shift;
\&
\&      my $val = $self\->parse_term
\&
\&      1 while $self\->any_of(
\&         sub { $self\->expect( "+" ); $val += $self\->parse_term; 1 },
\&         sub { $self\->expect( "\-" ); $val \-= $self\->parse_term; 1 },
\&         sub { 0 },
\&      );
\&
\&      return $val;
\&   }
.Ve
.PP
This function recognises input matching the following \s-1EBNF\s0 grammar:
.PP
.Vb 1
\&   EXPR = TERM { ( \*(Aq+\*(Aq | \*(Aq\-\*(Aq ) TERM };
.Ve
.SS "parse_term"
.IX Subsection "parse_term"
Called by \f(CW\*(C`parse\*(C'\fR, the next function is \f(CW\*(C`parse_term\*(C'\fR which has a similar
structure. This function implements the next level of operator precedence, of
the * and / operators. In a similar fashion to the previous function, this one
parses a single factor from the input by calling \f(CW\*(C`parse_factor\*(C'\fR, and then
looks for * or / operators, multiplying or dividing the value by the next
factor it expects to find after those. This continues until there are no more
* or / operators, when the overall product is returned.
.PP
.Vb 3
\&   sub parse_term
\&   {
\&      my $self = shift;
\&
\&      my $val = $self\->parse_factor;
\&
\&      1 while $self\->any_of(
\&         sub { $self\->expect( "*" ); $val *= $self\->parse_factor; 1 },
\&         sub { $self\->expect( "/" ); $val /= $self\->parse_factor; 1 },
\&         sub { 0 },
\&      );
\&
\&      return $val;
\&   }
.Ve
.PP
This function recognises input matching the following \s-1EBNF\s0 grammar:
.PP
.Vb 1
\&   TERM = FACTOR { ( \*(Aq*\*(Aq | \*(Aq/\*(Aq ) FACTOR };
.Ve
.SS "parse_factor"
.IX Subsection "parse_factor"
Finally, the innermost \f(CW\*(C`parse_factor\*(C'\fR function is called by \f(CW\*(C`parse_term\*(C'\fR to
parse out the actual numerical values. This is also the point at which the
grammar can recurse, recognising a parenthesized expression. It uses an
\&\f(CW\*(C`any_of\*(C'\fR with two alternative function bodies, to cover these two cases.
.PP
The first case, to handle a parenthesized sub-expression, consists of a call
to \f(CW\*(C`scope_of\*(C'\fR. This call would expect to find a \f(CW\*(C`(\*(C'\fR symbol to indicate the
parenthesized expression. If it finds one, it will recurse back to the
toplevel \f(CW\*(C`parse\*(C'\fR method to obtain its value, then expects the final \f(CW\*(C`)\*(C'\fR
symbol. The value of this factor is then the value of the sub-expression
contained within the parentheses.
.PP
If the first case fails, because it does not find that leading \f(CW\*(C`(\*(C'\fR symbol,
the second case is attempted instead. This handles an actual integer constant.
This case is simply a call to the \f(CW\*(C`token_int\*(C'\fR method of the underlying class,
which recognises various string forms of integer constants, returning their
numerical value.
.PP
.Vb 3
\&   sub parse_factor
\&   {
\&      my $self = shift;
\&
\&      $self\->any_of(
\&         sub { $self\->scope_of( "(", sub { $self\->parse }, ")" ) },
\&         sub { $self\->token_int },
\&      );
\&   }
.Ve
.PP
This function recognises input matching the following \s-1EBNF\s0 grammar:
.PP
.Vb 2
\&   FACTOR = \*(Aq(\*(Aq EXPR \*(Aq)\*(Aq
\&          | integer
.Ve
.SH "EXAMPLES OF OPERATION"
.IX Header "EXAMPLES OF OPERATION"
.SS "A single integer"
.IX Subsection "A single integer"
The simplest form of operation of this parser is when it is given a single
integer value as its input; for example \f(CW"15"\fR.
.PP
.Vb 2
\& INPUT:    15
\& POSITION: ^
.Ve
.PP
The outermost call to \f(CW\*(C`parse\*(C'\fR will call \f(CW\*(C`parse_term\*(C'\fR, which in turn calls
\&\f(CW\*(C`parse_factor\*(C'\fR.
.PP
.Vb 5
\& INPUT:    15
\& POSITION  ^
\& CALLS:    parse
\&            => parse_term
\&             => parse_factor
.Ve
.PP
The \f(CW\*(C`any_of\*(C'\fR inside \f(CW\*(C`parse_factor\*(C'\fR will first attempt to find a
parenthesized sub-expression by using \f(CW\*(C`scope_of\*(C'\fR, but this will fail because
it does not start with an open parenthesis symbol. The \f(CW\*(C`any_of\*(C'\fR will then
attempt the second case, calling \f(CW\*(C`token_int\*(C'\fR which will succeed at obtaining
an integer value from the input stream, consuming it by advancing the stream
position. The value of 15 is then returned by \f(CW\*(C`parse_factor\*(C'\fR back to
\&\f(CW\*(C`parse_term\*(C'\fR where it is stored in the \f(CW$val\fR lexical.
.PP
.Vb 4
\& INPUT:    15
\& POSITION:   ^
\& CALLS:    parse
\&            => parse_term \-\- $val = 15
.Ve
.PP
At this point, the \f(CW\*(C`any_of\*(C'\fR inside \f(CW\*(C`parse_term\*(C'\fR will attempt to find a * or
/ operator, but both will fail because there is none, causing the final
alternative function to be invoked, which stops the \f(CW\*(C`while\*(C'\fR loop executing.
The value of 15 is then returned to the outer caller, \f(CW\*(C`parse\*(C'\fR. A similar
process happens there, where it fails to find a + or \- operator, and thus the
final value of 15 is returned as the result of the entire parsing operation.
.PP
.Vb 2
\& INPUT:    15
\& OUTPUT:   15
.Ve
.SS "A simple sum of two integers"
.IX Subsection "A simple sum of two integers"
Next lets consider a case that actually requires some real parsing, such as an
expression requesting the sum of two values; \f(CW"6 + 9"\fR.
.PP
.Vb 2
\& INPUT:    6 + 9
\& POSITION: ^
.Ve
.PP
This parsing operation starts the same as the previous; with \f(CW\*(C`parse\*(C'\fR calling
\&\f(CW\*(C`parse_term\*(C'\fR which in turn calls \f(CW\*(C`parse_factor\*(C'\fR.
.PP
.Vb 5
\& INPUT:    6 + 9
\& POSITION: ^
\& CALLS:    parse
\&            => parse_term
\&             => parse_factor
.Ve
.PP
As before, the \f(CW\*(C`any_of\*(C'\fR inside \f(CW\*(C`parse_factor\*(C'\fR first attempts and fails to
find a parenthesized sub-expression and so tries \f(CW\*(C`token_int\*(C'\fR instead. As
before this obtains an integer value from the stream and advances the
position. This value is again returned to \f(CW\*(C`parse_term\*(C'\fR. As before, the
\&\f(CW\*(C`any_of\*(C'\fR attempts but fails to find a * or / operator so the value gets
returned to \f(CW\*(C`parse\*(C'\fR to be stored in \f(CW$val\fR.
.PP
.Vb 3
\& INPUT:    6 + 9
\& POSITION:  ^
\& CALLS:    parse \-\- $val = 6
.Ve
.PP
This time, the \f(CW\*(C`any_of\*(C'\fR in the outer \f(CW\*(C`parse\*(C'\fR method attempts to find a +
operator and succeeds, because there is one at the next position in the
stream. This causes the first case to continue, making another call to
\&\f(CW\*(C`parse_term\*(C'\fR.
.PP
.Vb 4
\& INPUT:    6 + 9
\& POSITION:    ^
\& CALLS:    parse \-\- $val = 6
\&            => parse_term
.Ve
.PP
This call to \f(CW\*(C`parse_term\*(C'\fR proceeds much like the first, eventually returning
the value 9 by consuming it from the input stream. This value is added to
\&\f(CW$val\fR by the code inside the \f(CW\*(C`any_of\*(C'\fR call.
.PP
.Vb 3
\& INPUT:    6 + 9
\& POSITION:      ^
\& CALLS:    parse \-\- $val = 15
.Ve
.PP
\&\f(CW\*(C`parse\*(C'\fR then calls \f(CW\*(C`any_of\*(C'\fR a second time, which attempts to find another
operator. This time there is none, so it returns false, which stops the
\&\f(CW\*(C`while\*(C'\fR loop and the value is returned as the final result of the operation.
.PP
.Vb 2
\& INPUT:    6 + 9
\& OUTPUT:   15
.Ve
.SS "Operator precedence"
.IX Subsection "Operator precedence"
The two kinds of operators (+ and \- vs * and /) are split across two different
method calls to allow them to implement precedence; to say that some of the
operators bind more tightly than others. Those operators that are implemented
in more inwardly-nested functions bind tighter than the ones implemented
further out.
.PP
To see this in operation consider an expression that mixes the two kinds of
operators, such as \f(CW"15 \- 2 * 3"\fR
.PP
.Vb 2
\& INPUT:    15 \- 2 * 3
\& POSITION: ^
.Ve
.PP
The parsing operation starts by calling down from \f(CW\*(C`parse\*(C'\fR all the way to
\&\f(CW\*(C`token_int\*(C'\fR which extracts the first integer, 15, from the stream and returns
it all the way up to \f(CW\*(C`parse\*(C'\fR as before:
.PP
.Vb 3
\& INPUT:    15 \- 2 * 3
\& POSITION:   ^
\& CALLS:    parse \-\- $val = 15
.Ve
.PP
As before, the \f(CW\*(C`parse\*(C'\fR function looks for a * or \- operator by its \f(CW\*(C`any_of\*(C'\fR
test, and finds this time the \- operator, which then causes it to call
\&\f(CW\*(C`parse_term\*(C'\fR to parse its value:
.PP
.Vb 4
\& INPUT:    15 \- 2 * 3
\& POSITION:     ^
\& CALLS:    parse \-\- $val = 15
\&            => parse_term
.Ve
.PP
Again, \f(CW\*(C`parse_term\*(C'\fR starts by calling \f(CW\*(C`parse_factor\*(C'\fR which extracts the next
integer from the stream and returns it. \f(CW\*(C`parse_factor\*(C'\fR temporarily stores
that in its own \f(CW$val\fR lexical (which remember, is a lexical variable local
to that call, so is distinct from the one in \f(CW\*(C`parse\*(C'\fR).
.PP
.Vb 4
\& INPUT:    15 \- 2 * 3
\& POSITION:       ^
\& CALLS:    parse \-\- $val = 15
\&            => parse_term \-\- $val = 2
.Ve
.PP
This time, when \f(CW\*(C`parse_term\*(C'\fR attempts its own \f(CW\*(C`any_of\*(C'\fR test to look for a *
or / operator, it manages to find one. By a process similar to the way that
the outer \f(CW\*(C`parse\*(C'\fR method forms a sum of terms, \f(CW\*(C`parse_term\*(C'\fR forms a product
of factors by calling down to \f(CW\*(C`parse_factor\*(C'\fR and accumulating the result.
Here it will call \f(CW\*(C`parse_factor\*(C'\fR again, which returns the value 3. This gets
multiplied into \f(CW$var\fR.
.PP
.Vb 4
\& INPUT:    15 \- 2 * 3
\& POSITION:           ^
\& CALLS:    parse \-\- $val = 15
\&            => parse_term \-\- $val = 6
.Ve
.PP
\&\f(CW\*(C`parse_term\*(C'\fR will try again to look for a * or / operator, but this time
fails to find one, and so returns its final result, 6, back to \f(CW\*(C`parse\*(C'\fR, which
then subtracts it from its own \f(CW$val\fR.
.PP
.Vb 3
\& INPUT:    15 \- 2 * 3
\& POSITION:           ^
\& CALLS:    parse \-\- $val = 9
.Ve
.PP
The outer \f(CW\*(C`parse\*(C'\fR call similarly fails to find any more + or \- operators and
so returns the final result of the parsing operation.
.PP
.Vb 2
\& INPUT:    15 \- 2 * 3
\& OUTPUT:   9
.Ve
.PP
By implementing the * and / operators separately in a different piece of logic
inside the one that implements the + and \- operators, we have ensured that
they operate more greedily. That is, that they bind tighter, consuming their
values first, before the outer + and \- operators. This is the way that
operator precedence is implemented.
.SS "Parentheses"
.IX Subsection "Parentheses"
This grammar, like many others, provides a way for expressions to override the
usual operator precedence by supplying a sub-expression in parentheses. The
expression inside those parentheses is parsed in the usual way, and then its
result stands in place of the entire parenthesized part, overriding whatever
rules might have governed the order between those operators inside it and
those outside.
.PP
In this parser we implement this as a recursive call, where one possibility
of the innermost part (the \f(CW\*(C`parse_factor\*(C'\fR function or the \f(CW\*(C`FACTOR\*(C'\fR \s-1EBNF\s0
rule) is to recurse back to the outermost thing, inside parentheses. This
example examines what happens to the input string \f(CW"(15 \- 2) * 3"\fR.
.PP
.Vb 2
\& INPUT:    (15 \- 2) * 3
\& POSITION: ^
.Ve
.PP
As with all the other examples the parsing operation starts by \f(CW\*(C`parse\*(C'\fR
calling \f(CW\*(C`parse_term\*(C'\fR which calls \f(CW\*(C`parse_factor\*(C'\fR. This time, the first case
within the \f(CW\*(C`any_of\*(C'\fR in \f(CW\*(C`parse_factor\*(C'\fR does successfully manage to find an
open parenthesis, so consumes it. It then stores the close parenthesis pattern
as the end-of-scope marker, and makes a recursive call back to the parse
method again.
.PP
.Vb 6
\& INPUT:    (15 \- 2) * 3
\& POSITION:  ^
\& CALLS:    parse
\&            => parse_term
\&             => parse_factor
\&              => parse                 EOS = ")"
.Ve
.PP
The operation of the inner call to \f(CW\*(C`parse\*(C'\fR proceeds much like the first few
examples, calling down through \f(CW\*(C`parse_term\*(C'\fR to \f(CW\*(C`parse_factor\*(C'\fR to obtain
the 15.
.PP
.Vb 6
\& INPUT:    (15 \- 2) * 3
\& POSITION:    ^
\& CALLS:    parse
\&            => parse_term
\&             => parse_factor
\&              => parse \-\- $val = 15    EOS = ")"
.Ve
.PP
Similar to previous examples, this then finds the \- operator, and parses
another term to subtract from it.
.PP
.Vb 6
\& INPUT:    (15 \- 2) * 3
\& POSITION:        ^
\& CALLS:    parse
\&            => parse_term
\&             => parse_factor
\&              => parse \-\- $val = 13    EOS = ")"
.Ve
.PP
At this point, the \f(CW\*(C`any_of\*(C'\fR test in the inner call to \f(CW\*(C`parse\*(C'\fR tries again to
look for a + or \- operator, and this time fails because it believes it is at
the end of the input. It isn't really at the end of the string, of course, but
it believes it to be at the end because of the \*(L"end-of-scope\*(R" pattern that the
call to \f(CW\*(C`scope_of\*(C'\fR established. This pretends that the input has finished
whenever the next part of the input matches the end-of-scope pattern.
.PP
Because this inner call to \f(CW\*(C`parse\*(C'\fR now believes it has got to the end of its
input, it returns its final answer back to the caller, which in this case was
the \f(CW\*(C`scope_of\*(C'\fR call that \f(CW\*(C`parse_factor\*(C'\fR made. As the \f(CW\*(C`scope_of\*(C'\fR call
returns, it consumes the input matching the end-of-scope pattern. This return
value is then stored by \f(CW\*(C`parse_term\*(C'\fR.
.PP
.Vb 4
\& INPUT:    (15 \- 2) * 3
\& POSITION:         ^
\& CALLS:    parse
\&            => parse_term \-\- $val = 13
.Ve
.PP
At this point, \f(CW\*(C`parse_term\*(C'\fR proceeds as before, finding and extracting the *
operator and calling \f(CW\*(C`parse_factor\*(C'\fR a second time, multiplying them together
and returning that to the outer \f(CW\*(C`parse\*(C'\fR call.
.PP
.Vb 3
\& INPUT:    (15 \- 2) * 3
\& POSITION:             ^
\& CALLS:    parse \-\- $val = 39
.Ve
.PP
At this point \f(CW\*(C`parse\*(C'\fR fails to extract any more operators because it is at
the (real) end of input, so returns the final answer.
.PP
.Vb 2
\& INPUT:    (15 \- 2) * 3
\& OUTPUT:   39
.Ve
