.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Compile::Internal 3"
.TH Test::Compile::Internal 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Compile::Internal \- Test whether your perl files compile.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Test::Compile::Internal;
\&    my $test = Test::Compile::Internal\->new();
\&    $test\->all_files_ok();
\&    $test\->done_testing();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Test::Compile::Internal\*(C'\fR is an object oriented tool for testing whether your
perl files compile.
.PP
It is primarily to provide the inner workings of \f(CW\*(C`Test::Compile\*(C'\fR, but it can
also be used directly to test a \s-1CPAN\s0 distribution.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new()""" 4
.el .IP "\f(CWnew()\fR" 4
.IX Item "new()"
A basic constructor, nothing special.
.ie n .IP """all_files_ok(@dirs)""" 4
.el .IP "\f(CWall_files_ok(@dirs)\fR" 4
.IX Item "all_files_ok(@dirs)"
Looks for perl files and tests them all for compilation errors.
.Sp
If \f(CW@dirs\fR is defined then it is taken as an array of files or directories to be 
searched for perl files, otherwise it searches the default locations you'd expect to find
perl files in a perl module \- see \*(L"all_pm_files(@dirs)\*(R" and \*(L"all_pl_files(@dirs)\*(R" 
for details.
.ie n .IP """all_pm_files_ok(@dirs)""" 4
.el .IP "\f(CWall_pm_files_ok(@dirs)\fR" 4
.IX Item "all_pm_files_ok(@dirs)"
Checks all the perl module files it can find for compilation errors.
.Sp
If \f(CW@dirs\fR is defined then it is taken as an array of directories to
be searched for perl files, otherwise it searches some default locations
\&\- see \*(L"all_pm_files(@dirs)\*(R".
.ie n .IP """all_pl_files_ok(@dirs)""" 4
.el .IP "\f(CWall_pl_files_ok(@dirs)\fR" 4
.IX Item "all_pl_files_ok(@dirs)"
Checks all the perl program files it can find for compilation errors.
.Sp
If \f(CW@dirs\fR is defined then it is taken as an array of directories to
be searched for perl files, otherwise it searches some default locations
\&\- see \*(L"all_pl_files(@dirs)\*(R".
.ie n .IP """verbose($verbose)""" 4
.el .IP "\f(CWverbose($verbose)\fR" 4
.IX Item "verbose($verbose)"
An accessor to get/set the verbosity.  The default value (undef) will suppress output
unless the compilation fails.  This is probably what you want.
.Sp
If \f(CW\*(C`verbose\*(C'\fR is set to true, you'll get the output from 'perl \-c'. If it's set to
false, all diagnostic output is suppressed.
.ie n .IP """all_pm_files(@dirs)""" 4
.el .IP "\f(CWall_pm_files(@dirs)\fR" 4
.IX Item "all_pm_files(@dirs)"
Searches for and returns a list of perl module files \- that is, files with a \fI.pm\fR
extension.
.Sp
If you provide a list of \f(CW@dirs\fR, it'll use that as a list of files to process, or
directories to search for perl modules.
.Sp
If you don't provide \f(CW\*(C`dirs\*(C'\fR, it'll search for perl modules in the \fIblib\fR directory,
unless that directory doesn't exist, in which case it'll search the \fIlib\fR directory.
.Sp
Skips any files in \fI\s-1CVS\s0\fR, \fI.svn\fR, or \fI.git\fR directories.
.Sp
The order of the files returned is machine-dependent. If you want them
sorted, you'll have to sort them yourself.
.ie n .IP """all_pl_files(@dirs)""" 4
.el .IP "\f(CWall_pl_files(@dirs)\fR" 4
.IX Item "all_pl_files(@dirs)"
Searches for and returns a list of perl script files \- that is, any files that either
have a \fI.pl\fR extension, or have no extension but have a perl shebang line.
.Sp
If you provide a list of \f(CW@dirs\fR, it'll use that as a list of files to process, or
directories to search for perl scripts.
.Sp
If you don't provide \f(CW\*(C`dirs\*(C'\fR, it'll search for perl scripts in the \fIblib/script/\fR 
directory, or if that doesn't exist, the \fIscript/\fR directory, or if that doesn't exist,
the \fIbin/\fR directory.
.Sp
Skips any files in \fI\s-1CVS\s0\fR, \fI.svn\fR, or \fI.git\fR directories.
.Sp
The order of the files returned is machine-dependent. If you want them
sorted, you'll have to sort them yourself.
.ie n .IP """pl_file_compiles($file)""" 4
.el .IP "\f(CWpl_file_compiles($file)\fR" 4
.IX Item "pl_file_compiles($file)"
Returns true if \f(CW$file\fR compiles as a perl script.
.ie n .IP """pm_file_compiles($file)""" 4
.el .IP "\f(CWpm_file_compiles($file)\fR" 4
.IX Item "pm_file_compiles($file)"
Returns true if \f(CW$file\fR compiles as a perl module.
.SH "TEST METHODS"
.IX Header "TEST METHODS"
\&\f(CW\*(C`Test::Compile::Internal\*(C'\fR encapsulates a \f(CW\*(C`Test::Builder\*(C'\fR object, and provides
access to some of its methods.
.ie n .IP """done_testing()""" 4
.el .IP "\f(CWdone_testing()\fR" 4
.IX Item "done_testing()"
Declares that you are done testing, no more tests will be run after this point.
.ie n .IP """ok($test, $name)""" 4
.el .IP "\f(CWok($test, $name)\fR" 4
.IX Item "ok($test, $name)"
Your basic test. Pass if \f(CW$test\fR is true, fail if \f(CW$test\fR is false. Just
like \f(CW\*(C`Test::Simple\*(C'\fR's \f(CW\*(C`ok()\*(C'\fR.
.ie n .IP """plan(tests => $count)""" 4
.el .IP "\f(CWplan(tests => $count)\fR" 4
.IX Item "plan(tests => $count)"
Defines how many tests you plan to run.
.ie n .IP """diag(@msgs)""" 4
.el .IP "\f(CWdiag(@msgs)\fR" 4
.IX Item "diag(@msgs)"
Prints out the given \f(CW@msgs\fR. Like print, arguments are simply appended
together.
.Sp
Output will be indented and marked with a # so as not to interfere with
test output. A newline will be put on the end if there isn't one already.
.Sp
We encourage using this rather than calling print directly.
.ie n .IP """skip($reason)""" 4
.el .IP "\f(CWskip($reason)\fR" 4
.IX Item "skip($reason)"
Skips the current test, reporting the \f(CW$reason\fR.
.ie n .IP """skip_all($reason)""" 4
.el .IP "\f(CWskip_all($reason)\fR" 4
.IX Item "skip_all($reason)"
Skips all the tests, using the given \f(CW$reason\fR. Exits immediately with 0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Sagar R. Shah \f(CW\*(C`<srshah@cpan.org>\*(C'\fR,
Marcel Gru\*:nauer, \f(CW\*(C`<marcel@cpan.org>\*(C'\fR,
Evan Giles, \f(CW\*(C`<egiles@cpan.org>\*(C'\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2020 by the authors.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Strict provides functions to ensure your perl files compile, with
the added bonus that it will check you have used strict in all your files.
