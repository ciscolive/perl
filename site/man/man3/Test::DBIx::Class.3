.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::DBIx::Class 3"
.TH Test::DBIx::Class 3 "2016-12-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::DBIx::Class \- Easier test cases for your DBIx::Class applications
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following is example usage for this module.  Assume you create a standard
Perl testing script, such as \*(L"MyApp/t/schema/01\-basic.t\*(R" which is run from the
shell like \*(L"prove \-l t/schema/01\-basic.t\*(R" or during \*(L"make test\*(R".  That test 
script could contain:
.PP
.Vb 1
\&    use Test::More;
\&
\&    use strict;
\&    use warnings;
\&
\&    use Test::DBIx::Class {
\&        schema_class => \*(AqMyApp::Schema\*(Aq,
\&        connect_info => [\*(Aqdbi:SQLite:dbname=:memory:\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq],
\&        connect_opts => { name_sep => \*(Aq.\*(Aq, quote_char => \*(Aq\`\*(Aq, },
\&        fixture_class => \*(Aq::Populate\*(Aq,
\&    }, \*(AqPerson\*(Aq, \*(AqPerson::Employee\*(Aq => {\-as => \*(AqEmployee\*(Aq}, \*(AqJob\*(Aq, \*(AqPhone\*(Aq;
\&
\&    ## Your testing code below ##
\&
\&    ## Your testing code above ##
\&
\&    done_testing;
.Ve
.PP
Yes, it looks like a lot of boilerplate, but sensible defaults are in place
(the above code example shows most of the existing defaults) and configuration
data can be loaded from a central file.  So,
assuming you put all of your test configuration in the standard place, your
\&'real life' example is going to look closer to:
.PP
.Vb 1
\&    use Test::More;
\&        
\&    use strict;
\&    use warnings;
\&    use Test::DBIx::Class qw(:resultsets);
\&
\&    ## Your testing code below ##
\&    ## Your testing code above ##
\&
\&    done_testing;
.Ve
.PP
Then, assuming the existence of a DBIx::Class::Schema subclass called,
\&\*(L"MyApp::Schema\*(R" and some DBIx::Class::ResultSources named like \*(L"Person\*(R",
\&\*(L"Person::Employee\*(R", \*(L"Job\*(R" and \*(L"Phone\*(R", will automatically deploy a testing 
schema in the given database / storage (or auto deploy to an in-memory based
DBD::SQLite database), install fixtures and let you run some test cases, 
such as:
.PP
.Vb 1
\&    ## Your testing code below ##
\&
\&    fixtures_ok \*(Aqbasic\*(Aq
\&      => \*(Aqinstalled the basic fixtures from configuration files\*(Aq;
\&
\&    fixtures_ok [ 
\&        Job => [
\&            [qw/name description/],
\&            [Programmer => \*(AqShe who writes the code\*(Aq],
\&            [\*(AqMovie Star\*(Aq => \*(AqKnows nothing about the code\*(Aq],
\&        ],
\&    ], \*(AqInstalled some custom fixtures via the Populate fixture class\*(Aq,
\&
\&    
\&    ok my $john = Person\->find({email=>\*(Aqjjnapiork@cpan.org\*(Aq})
\&      => \*(AqJohn has entered the building!\*(Aq;
\&
\&    is_fields $john, {
\&        name => \*(AqJohn Napiorkowski\*(Aq, 
\&        email => \*(Aqjjnapiork@cpan.org\*(Aq, 
\&        age => 40,
\&    }, \*(AqJohn has the expected fields\*(Aq;
\&
\&    is_fields [\*(Aqjob_title\*(Aq], $john\->jobs, [
\&        {job_title => \*(Aqprogrammer\*(Aq},
\&        {job_title => \*(Aqadministrator\*(Aq},
\&    ], 
\&    is_fields \*(Aqjob_title\*(Aq, $john\->jobs, 
\&        [qw/programmer administrator/],
\&        \*(AqSame test as above, just different compare format;
\&
\&
\&    is_fields [qw/job_title salary/], $john\->jobs, [
\&        [\*(Aqprogrammer\*(Aq, 100000],
\&        [\*(Aqadministrator, 120000],
\&    ], \*(AqGot expected fields from $john\->jobs\*(Aq;
\&
\&    is_fields [qw/name age/], $john, [\*(AqJohn Napiorkowski\*(Aq, 40],
\&      => \*(AqJohn has expected name and age\*(Aq;
\&
\&    is_fields_multi \*(Aqname\*(Aq, [
\&        $john, [\*(AqJohn Napiorkowski\*(Aq],
\&        $vanessa, [\*(AqVanessa Li\*(Aq],
\&        $vincent, [\*(AqVincent Zhou\*(Aq],
\&    ] => \*(AqAll names as expected\*(Aq;
\&
\&    is_fields \*(Aqfullname\*(Aq, 
\&        ResultSet(\*(AqCountry\*(Aq)\->find(\*(AqUSA\*(Aq), 
\&        \*(AqUnited States of America\*(Aq,
\&        \*(AqFound the USA\*(Aq;
\&
\&    is_deeply [sort Schema\->sources], [qw/
\&        Person Person::Employee Job Country Phone
\&    /], \*(AqFound all expected sources in the schema\*(Aq;
\&
\&    fixtures_ok my $first_album = sub {
\&        my $schema = shift @_;
\&        my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq);
\&        return $cd_rs\->create({
\&            name => \*(AqMy First Album\*(Aq,
\&            track_rs => [
\&                {position=>1, title=>\*(Aqthe first song\*(Aq},
\&                {position=>2, title=>\*(Aqyet another song\*(Aq},
\&            ],
\&            cd_artist_rs=> [
\&                {person_artist=>{person => $vanessa}},
\&                {person_artist=>{person => $john}},
\&            ],
\&        });
\&    }, \*(AqYou can even use a code reference for custom fixtures\*(Aq;
\&
\&    ## Your testing code above ##
.Ve
.PP
Please see the test cases for more examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The goal of this distribution is to make it easier to write test cases for your
DBIx::Class based applications.  It does this in three ways.  First, it trys
to make it easy to deploy your Schema.  This can be to your dedicated testing
database, or a simple SQLite database.  This allows you to run tests without 
interfering with your development work and having to stop and set up a testing 
database instance.
.PP
Second, we allow you to load test fixtures via several different tools.  Last
we create some helper functions in your test script so that you can reduce
repeated or boilerplate code.
.PP
Overall, we attempt to reduce the amount of code you have to write before you
can begin writing tests.
.SH "IMPORTED METHODS"
.IX Header "IMPORTED METHODS"
The following methods are automatically imported when you use this module.
.SS "Schema"
.IX Subsection "Schema"
You probably won't need this directly in your tests unless you have some
application logic methods in it.
.SS "ResultSet ($source, ?{%search}, ?{%conditions})"
.IX Subsection "ResultSet ($source, ?{%search}, ?{%conditions})"
Although you can import your sources as local keywords, sometimes you might
need to get a particular resultset when you don't wish to import it globally.
Use like
.PP
.Vb 2
\&    ok ResultSet(\*(AqJob\*(Aq), "Yeah, some jobs in the database";
\&    ok ResultSet( Job => {hourly_pay=>{\*(Aq>\*(Aq=>100}}), "Good paying jobs available!";
.Ve
.PP
Since this returns a normal DBIx::Class::ResultSet, you can just call the
normal methods against it.
.PP
.Vb 1
\&    ok ResultSet(\*(AqJob\*(Aq)\->search({hourly_pay=>{\*(Aq>\*(Aq=>100}}), "Good paying jobs available!";
.Ve
.PP
This is the same as the test above.
.PP
ResultSet can also be called with a \f(CW\*(C`$source, [\e%search,
\&\e%condition]\*(C'\fR signature.
.SS "fixtures_ok"
.IX Subsection "fixtures_ok"
This is used to install and verify installation of fixtures, either inlined,
from a fixture set in a file, or through a custom sub reference.  Accept three
argument styles:
.IP "coderef" 4
.IX Item "coderef"
Given a code reference, execute it against the currently defined schema.  This
is used when you need a lot of control over installing your fixtures.  Example:
.Sp
.Vb 10
\&    fixtures_ok sub {
\&        my $schema = shift @_;
\&        my $cd_rs = $schema\->resultset(\*(AqCD\*(Aq);
\&        return $cd_rs\->create({
\&            name => \*(AqMy First Album\*(Aq,
\&            track_rs => [
\&                {position=>1, title=>\*(Aqthe first song\*(Aq},
\&                {position=>2, title=>\*(Aqyet another song\*(Aq},
\&            ],
\&            cd_artist_rs=> [
\&                {person_artist=>{person => $vanessa}},
\&                {person_artist=>{person => $john}},
\&            ],
\&        });
\&
\&    }, \*(AqInstalled fixtures\*(Aq;
.Ve
.Sp
The above gets executed at runtime and if there is an error it is trapped,
reported and we move on to the next test.
.IP "arrayref" 4
.IX Item "arrayref"
Given an array reference, attempt to process it via the default fixtures loader
or through the specified loader.
.Sp
.Vb 8
\&    fixtures_ok [
\&        Person => [
\&            [\*(Aqname\*(Aq, \*(Aqage\*(Aq, \*(Aqemail\*(Aq],
\&            [\*(AqJohn\*(Aq, 40, \*(Aqjohn@nowehere.com\*(Aq],
\&            [\*(AqVincent\*(Aq, 15, \*(Aqvincent@home.com\*(Aq],
\&            [\*(AqVanessa\*(Aq, 35, \*(Aqvanessa@school.com\*(Aq],
\&        ],
\&    ], \*(AqInstalled fixtures\*(Aq;
.Ve
.Sp
This is a good option to use while you are building up your fixture sets or
when your sets are going to be small and not reused across lots of tests.  This
will get you rolling without messing around with configuration files.
.IP "fixture set name" 4
.IX Item "fixture set name"
Given a fixture name, or array reference of names, install the fixtures.
.Sp
.Vb 2
\&    fixtures_ok \*(Aqcore\*(Aq;
\&    fixtures_ok [qw/core extra/];
.Ve
.Sp
Fixtures are installed in the order specified.
.PP
All different types can be mixed and matched in a given test file.
.SS "is_result ($result, ?$result)"
.IX Subsection "is_result ($result, ?$result)"
Quick test to make sure \f(CW$result\fR does inherit from DBIx::Class or that it
inherits from a subclass of DBIx::Class.
.SS "is_resultset ($resultset, ?$resultset)"
.IX Subsection "is_resultset ($resultset, ?$resultset)"
Quick test to make sure \f(CW$resultset\fR does inherit from DBIx::Class::ResultSet
or from a subclass of DBIx::Class::ResultSet.
.ie n .SS "eq_resultset ($resultset, $resultset, ?$message)"
.el .SS "eq_resultset ($resultset, \f(CW$resultset\fP, ?$message)"
.IX Subsection "eq_resultset ($resultset, $resultset, ?$message)"
Given two ResultSets, determine if the are equal based on class type and data.
This is a true set equality that ignores sorting order of items inside the
set.
.ie n .SS "eq_result ($resultset, $resultset, ?$message)"
.el .SS "eq_result ($resultset, \f(CW$resultset\fP, ?$message)"
.IX Subsection "eq_result ($resultset, $resultset, ?$message)"
Given two row objects, make sure they are the same.
.SS "hri_dump ($resultset)"
.IX Subsection "hri_dump ($resultset)"
Not a test, just returns a version of the ResultSet that has its inflator set
to DBIx::Class::ResultClass::HashRefInflator, which returns a set of hashes
and makes it easier to stop issues.  This return value is suitable for dumping
via Data::Dump, for example.
.SS "reset_schema"
.IX Subsection "reset_schema"
Wipes and reloads the schema.
.SS "cleanup_schema"
.IX Subsection "cleanup_schema"
Wipes schema and disconnects.
.SS "dump_settings"
.IX Subsection "dump_settings"
Returns the configuration and related settings used to initialize this testing
module.  This is mostly to help you debug trouble with configuration and to help
the authors find and fix bugs.  At some point this won't be exported by default
so don't use it for your real tests, just to help you understand what is going
on.  You've been warned!
.SS "is_fields"
.IX Subsection "is_fields"
A 'Swiss Army Knife' method to check your results or resultsets.  Tests the 
values of a Result or ResultSet against expected via a pattern.  A pattern
is automatically created by instrospecting the fields of your ResultSet or
Result.
.PP
Example usage for testing a result follows.
.PP
.Vb 1
\&    ok my $john = Person\->find(\*(Aqjohn\*(Aq);
\&
\&    is_fields \*(Aqname\*(Aq, $john, [\*(AqJohn Napiorkowski\*(Aq],
\&      \*(AqFound name of $john\*(Aq;
\&
\&    is_fields [qw/name age/], $john, [\*(AqJohn Napiorkowski\*(Aq, 40],
\&      \*(AqFound $johns name and age\*(Aq;
\&
\&    is_fields $john, {
\&        name => \*(AqJohn Napiorkowski\*(Aq,
\&        age => 40,
\&        email => \*(Aqjohn@home.com\*(Aq};  # Assuming $john has only the three columns listed
.Ve
.PP
In the case where we need to infer the match pattern, we get the columns of the
given result but remove the primary key.  Please note the following would also
work:
.PP
.Vb 3
\&    is_fields [qw/name age/] $john, {
\&        name => \*(AqJohn Napiorkowski\*(Aq,
\&        age => 40}, \*(AqStill got the name and age correct\*(Aq;
.Ve
.PP
You should choose the method that makes most sense in your tests.
.PP
Example usage for testing a resultset follows.
.PP
.Vb 5
\&    is_fields \*(Aqname\*(Aq, Person, [
\&        \*(AqJohn\*(Aq,
\&        \*(AqVanessa\*(Aq,
\&        \*(AqVincent\*(Aq,
\&    ];
\&
\&    is_fields [\*(Aqname\*(Aq], Person, [
\&        \*(AqJohn\*(Aq,
\&        \*(AqVanessa\*(Aq,
\&        \*(AqVincent\*(Aq,
\&    ];
\&
\&    is_fields [\*(Aqname\*(Aq,\*(Aqage\*(Aq], Person, [
\&        [\*(AqJohn\*(Aq,40],
\&        [\*(AqVincent\*(Aq,15],
\&        [\*(AqVanessa\*(Aq,35],
\&    ];
\&
\&    is_fields [\*(Aqname\*(Aq,\*(Aqage\*(Aq], Person, [
\&        {name=>\*(AqJohn\*(Aq, age=>40},
\&        {name=>\*(AqVanessa\*(Aq,age=>35},
\&        {name=>\*(AqVincent\*(Aq, age=>15},
\&    ];
.Ve
.PP
I find the array version is most consise.  Please note that the match is not
ordered.  If you need to test that a given Resultset is in a particular order,
you will currently need to write a custom test.  If you have a big need for 
this I'd be willing to write a test for it, or gladly accept a patch to add it.
.PP
You should examine the test cases for more examples.
.SS "is_fields_multi"
.IX Subsection "is_fields_multi"
.Vb 1
\&    TBD: Not yet written.
.Ve
.SH "SETUP AND INITIALIZATION"
.IX Header "SETUP AND INITIALIZATION"
The generic usage for this would look like one of the following:
.PP
.Vb 2
\&    use Test::DBIx::Class \e%options, @sources
\&    use Test::DBIx::Class %options, @sources
.Ve
.PP
Where \f(CW%options\fR are key value pairs and \f(CW@sources\fR an array as specified below.
.SS "Initialization Options"
.IX Subsection "Initialization Options"
The only difference between the hash and hash reference version of \f(CW%options\fR
is that the hash version requires its keys to be prepended with \*(L"\-\*(R".  If
you are inlining a lot of configuration the hash reference version may look
neater, while if you are only setting one or two options the hash version
might be more readable.  For example, the following are the same:
.PP
.Vb 2
\&    use Test::DBIx::Class \-config_path=>[qw(t etc config)], \*(AqPerson\*(Aq, \*(AqJob\*(Aq;
\&    use Test::DBIx::Class {config_path=>[qw(t etc config)]}, \*(AqPerson\*(Aq, \*(AqJob\*(Aq;
.Ve
.PP
The following options are currently standard and always available.  Depending
on your storage engine (such as SQLite or MySQL) you will have other options.
.IP "config_path" 4
.IX Item "config_path"
These are the relative paths searched for configuration file information. See
\&\*(L"Initialization Sources\*(R" for more.
.Sp
In the case were we have both inlined and file based configurations, the 
inlined is merged last (that is, has highest authority to override configuration
files).
.Sp
When the final merging of all configurations (both anything inlined at 'use'
time, and anything found in any of the specified config_paths, we do a single
\&'post' config_path check.  This allows you to add in a configuration file from
inside a configuration file.  For safety and sanity you can only do this once.
This feature makes it easier to globalize any additional configuration files.
For example, I often store user specific settings in \*(L"~/etc/conf.*\*(R".  This
feature allows me to add that into my standard \*(L"t/etc/schema.*\*(R" so it's 
available to all my test cases.
.IP "schema_class" 4
.IX Item "schema_class"
Required. This must be your subclass of DBIx::Class::Schema that defines
your database schema.
.IP "connect_info" 4
.IX Item "connect_info"
Required. This will accept anything you can send to \*(L"connect\*(R" in DBIx::Class.
Defaults to: ['dbi:SQLite:dbname=:memory:','',''] if left blank (but see
\&'traits' below for more)
.IP "connect_opts" 4
.IX Item "connect_opts"
Use this to customise connect_info if you have left that blank in order to
have the dsn auto-generated, but require extra attributes such as name_sep
and quote_char.
.IP "deploy_opts" 4
.IX Item "deploy_opts"
Use this to customise any arguments that are to be passed to
\&\*(L"deploy\*(R" in DBIx::Class::Schema, such as add_drop_table or quote_identifiers.
.IP "default_resultset_attributes" 4
.IX Item "default_resultset_attributes"
Allows you to specify default_resultset_attributes to be set on the schema.
These will be used when creating all new resultsets.
.Sp
This is typically done to enable caching or turn on the software_limit flag.
.IP "fixture_path" 4
.IX Item "fixture_path"
These are a list of relative paths search for fixtures.  Each item should be
a directory that contains files loadable by Config::Any and suitable to
be installed via one of the fixture classes.
.IP "fixture_class" 4
.IX Item "fixture_class"
Command class that installs data into the database.  Must provide a method
called 'install_fixtures' that accepts a perl data structure and installs
it into the database.  Must capture and report errors.  Default value is
\&\*(L"::Populate\*(R", which loads Test::DBIx::Class::FixtureCommand::Populate, which
is a command class based on \*(L"populate\*(R" in DBIx::Class::Schema.
.IP "resultsets" 4
.IX Item "resultsets"
Lets you add in some result source definitions to be imported at test script
runtime.  See \*(L"Initialization Sources\*(R" for more.
.IP "force_drop_table" 4
.IX Item "force_drop_table"
When deploying the database this option allows you add a 'drop table' statement
before the create ddl.  Since this will return an error if you attempt to drop
a table that doesn't exist, this is off by default for SQLite storage engines.
You may need to enble it you you are using the following 'keep_db' option.
.IP "keep_db" 4
.IX Item "keep_db"
By default your testing database is 'cleaned up' after you are finished.  This
drops all the created tables (but currently doesn't delete any related files
or database users, if any).  If you want to keep your testing database after
all the tests are run, you can set this to true.  If so, you may also need to
set the previously mentioned option 'force_drop_table' to true as well, or we
will attempt to create tables and populate them when they are already populated
and created.
.IP "deploy_db" 4
.IX Item "deploy_db"
By default a fresh version of the schema is deployed when 'Test::DBIx::Class'
is invoked.  If you want to skip the schema deployment and instead connect
to an already existing and populated database, set this option to false.
.IP "traits" 4
.IX Item "traits"
Traits are Moose::Roles that are applied to the class managing the connection
to your database.  If you leave this option blank and you don't specify anything
for 'connect_info' (above), we automatically load the SQLite trait (which can
be reviewed at Test::DBIx::Class::SchemaManager::Trait::SQLite).  This trait
installs the ability to automatically discover and deploy to an in memory or a
filesystem SQLite database.  If you are just getting started with testing, this
is probably your easiest option.
.Sp
Currently there are only three traits, the SQLite trait just described (and since
it get's automatically loaded you never need to load it yourself). The
Test::DBIx::Class::SchemaManager::Trait::Testmysqld trait, which is built on
top of Test::mysqld and allows you the ability to deploy to and run tests
against a temporary instance of MySQL. For this trait MySQL and DBD::mysql
needs to be installed, but MySQL does not need to be running, nor do you need
to create a test database or user.   The third one is the 
Test::DBIx::Class::SchemaManager::Trait::Testpostgresql trait, which is
built on top of Test::Postgresql58 and allows you to deploy to and run tests
against a temporary instance of Postgresql.  For this trait Postgresql
and DBD::Pg needs to be installed, but Postgresql does not need to be
running, nor do you need to create a test database or user.  
See \*(L"\s-1TRAITS\*(R"\s0 for more.
.IP "fail_on_schema_break" 4
.IX Item "fail_on_schema_break"
Makes the test run fail when the schema can not be created.  Normally the
test run is skipped when the schema fails to create.  A failure can be more
convenient when you want to spot compilation failures.
.PP
Please note that although all initialization options can be set inlined or in
a configuration file, some options can also be set via \f(CW%ENV\fR variables. \f(CW%ENV\fR
settings will only apply \s-1IF\s0 there are no existing values for the option in any
configuration file.  As of this time we don't merge \f(CW%ENV\fR settings, they only
provider overrides to the default settings. Example use (assumes you are
using the default SQLite database)
.PP
.Vb 1
\&    DBNAME=test.db KEEP_DB=1 prove \-lv t/schema/check\-person.t
.Ve
.PP
After running the test there will be a new file called 'test.db' in the home
directory of your distribution.  You can use:
.PP
.Vb 1
\&    sqlite3 test.db
.Ve
.PP
to open and view the tables and their data as loaded by any fixtures or create
statements. See Test::DBIx::Class::SchemaManager::Trait::SQLite for more.
Note that you can specify both 'dbpath' and 'keep_db' in your configuration
files if you prefer.  I tried to expose a subset of configuration to \f(CW%ENV\fR that
I thought the most useful.  Patches and suggestions welcomed.
.SS "Initialization Sources"
.IX Subsection "Initialization Sources"
The \f(CW@sources\fR are a list of result sources that you want helper methods injected
into your test script namespace.  This is the 'Source' part of:
.PP
.Vb 1
\&    $schema\->resultset(\*(AqSource\*(Aq);
.Ve
.PP
Injecting methods are optional since you can also use the 'ResultSet' keyword
.PP
Imported Source keywords use Sub::Exporter so you have quite a few options
for controling how the keywords are imported.  For example:
.PP
.Vb 4
\&    use Test::DBIx::Class 
\&      \*(AqPerson\*(Aq,
\&      \*(AqPerson::Employee\*(Aq => {\-as => \*(AqEmployee\*(Aq},
\&      \*(AqPerson\*(Aq => {search => {age=>{\*(Aq>\*(Aq=>55}}, \-as => \*(AqOlderPerson\*(Aq};
.Ve
.PP
This would import three local keywork methods, \*(L"Person\*(R", \*(L"Employee\*(R" and 
\&\*(L"OlderPerson\*(R".  For \*(L"OlderPerson\*(R", the search parameter would automatically be
resolved via \f(CW$resultset\fR\->search and the correct resultset returned.  You may
wish to preconfigure all your test result set cases in one go at the top of
your test script as a way to promote reusability.
.PP
In addition to the 'search' parameter, there is also an 'exec' parameter
which let's you process your resultset programatically.  For example:
.PP
.Vb 1
\&    \*(AqPerson\*(Aq => {exec => sub { shift\->older_than(55) }, \-as => \*(AqOlderPerson\*(Aq};
.Ve
.PP
This code reference gets passed the resultset object.  So you can use any 
method on \f(CW$resultset\fR.  For example:
.PP
.Vb 1
\&    \*(AqPerson\*(Aq => {exec => sub { shift\->find(\*(Aqjohn\*(Aq) }, \-as => \*(AqJohn\*(Aq}; 
\&
\&    is_result John;
\&    is John\->name, \*(AqJohn Napiorkowski\*(Aq, "Got Correct Name";
.Ve
.PP
Although since fixtures will not yet be installed, the above is probably not
going to be a normally working example :)
.PP
Additionally, since you can also initialize sources via the 'resultsets'
configuration option, which can be placed into your global configuration files
this means you can predefine and result resultsets across all your tests.  Here
is an example 't/etc/schema.pl' file where I initialize pretty much everything
in one file:
.PP
.Vb 10
\&     {
\&      \*(Aqschema_class\*(Aq => \*(AqTest::DBIx::Class::Example::Schema\*(Aq,
\&      \*(Aqresultsets\*(Aq => [
\&        \*(AqPerson\*(Aq,
\&        \*(AqJob\*(Aq,
\&        \*(AqPerson\*(Aq => { \*(Aq\-as\*(Aq => \*(AqNotTeenager\*(Aq, search => {age=>{\*(Aq>\*(Aq=>18}}},
\&      ],
\&      \*(Aqfixture_sets\*(Aq => {
\&        \*(Aqbasic\*(Aq => [
\&          \*(AqPerson\*(Aq => [
\&            [
\&              \*(Aqname\*(Aq,
\&              \*(Aqage\*(Aq,
\&              \*(Aqemail\*(Aq
\&            ],
\&            [
\&              \*(AqJohn\*(Aq,
\&              \*(Aq40\*(Aq,
\&              \*(Aqjohn@nowehere.com\*(Aq
\&            ],
\&            [
\&              \*(AqVincent\*(Aq,
\&              \*(Aq15\*(Aq,
\&              \*(Aqvincent@home.com\*(Aq
\&            ],
\&            [
\&              \*(AqVanessa\*(Aq,
\&              \*(Aq35\*(Aq,
\&              \*(Aqvanessa@school.com\*(Aq
\&            ]
\&          ]
\&        ]
\&      },
\&    };
.Ve
.PP
In this case you can simple do \*(L"use Test::DBIx::Class\*(R" and everything will
happen automatically.
.PP
In the example 't/etc/schema.pl' file, instead of (or as well as) fixture_sets
you could instead define fixture_path to allow resultset data outside of the
main 't/etc/schema.pl' file.
.PP
.Vb 1
\&     \*(Aqfixture_path\*(Aq => [qw{t etc fixtures}],
.Ve
.PP
Create the file './t/etc/fixtures/basic.pl' and insert
.PP
.Vb 10
\&    [
\&      \*(AqPerson\*(Aq => [
\&        [
\&          \*(Aqname\*(Aq,
\&          \*(Aqage\*(Aq,
\&          \*(Aqemail\*(Aq
\&        ],
\&        [
\&          \*(AqJohn\*(Aq,
\&          \*(Aq40\*(Aq,
\&          \*(Aqjohn@nowehere.com\*(Aq
\&        ],
\&        [
\&          \*(AqVincent\*(Aq,
\&          \*(Aq15\*(Aq,
\&          \*(Aqvincent@home.com\*(Aq
\&        ],
\&        [
\&          \*(AqVanessa\*(Aq,
\&          \*(Aq35\*(Aq,
\&          \*(Aqvanessa@school.com\*(Aq
\&        ]
\&      ]
\&    ]
.Ve
.PP
Additional rulesets should be included within the outermost [ ] like
this.
.PP
.Vb 8
\&    [
\&      \*(AqPerson\*(Aq => [
\&        ...
\&      ],
\&      \*(AqJob\*(Aq => [
\&        ...
\&      ]
\&    ]
.Ve
.PP
The 'basic' fixture would be used with fixtures_ok in exactly the same way
as when it was embedded within schema.pl using fixture_sets.
.SH "CONFIGURATION BY FILE"
.IX Header "CONFIGURATION BY FILE"
By default, we try to load configuration files from the following locations:
.PP
.Vb 2
\&     ./t/etc/schema.*
\&     ./t/etc/[test file path].*
.Ve
.PP
Where \*(L".\*(R" is the root of the distribution and \*(L"*\*(R" is any of the configuration
file types supported by Config::Any configuration loader.  This allows you
to store configuration in the format of your choice.
.PP
\&\*(L"[test file path]\*(R" is the relative path part under the \*(L"t\*(R" directory of the
calling test script.  For example, if your test script is \*(L"t/mytest.t\*(R" we add
the path \*(L"./t/etc/mytest.*\*(R" to the path.
.PP
Additionally, we do a merge using Hash::Merge of all the matching found
configurations.  This allows you to do 'cascading' configuration from the most
global to the most local settings.
.PP
You can override this search path with the \*(L"\-config_path\*(R" key in options. For
example, the following searches for \*(L"t/etc/myconfig.*\*(R" (or whatever is the
correct directory separator for your operating system):
.PP
.Vb 1
\&    use Test::DBIx::Class \-config_path => [qw/t etc myconfig/];
.Ve
.PP
Relative paths are rooted to the distribution home directory (ie, the one that
contains your 'lib' and 't' directories).  Full paths are searched without
modification.
.PP
You can specify multiple paths.  The following would search for both \*(L"schema.*\*(R"
and \*(L"share/schema\*(R".
.PP
.Vb 1
\&    use Test::DBIx::Class \-config_path => [[qw/share schema/], [qw/schema/]];
.Ve
.PP
Lastly, you can use the special symbol \*(L"+\*(R" to indicate that your custom path
adds to or prepends to the default search path.  Since as indicated we merge
all the configurations found, this means it's easy to create user level 
configuration settings mixed with global settings, as in:
.PP
.Vb 6
\&    use Test::DBIx::Class
\&        \-config_path => [ 
\&            [qw(/ etc myapp test\-schema)],
\&            \*(Aq+\*(Aq,
\&            [qw(~ etc test\-schema)],
\&        ];
.Ve
.PP
Which would search and combine \*(L"/etc/myapp/test\-schema.*\*(R", \*(L"./t/etc/schema.*\*(R",
\&\*(L"./etc/[test script name].*\*(R" and \*(L"~/etc/test\-schema.*\*(R".  This would let you set
up server level global settings, distribution level settings and finally user
level settings.
.PP
Please note that in all the examples given, paths are written as an array
reference of path parts, rather than as a string with delimiters (i.e. we do
[qw(t etc)] rather than \*(L"t/etc\*(R").  This is not required but recommended.  All
arguments, either string or array references, are passed to Path::Class so
that we can maintain better compatibility with non unix filesystems.  If you
are writing for \s-1CPAN,\s0 please consider our non Unix filesystem friends :)
.PP
Lastly, there is an \f(CW%ENV\fR variable named '\s-1TEST_DBIC_CONFIG_SUFFIX\s0' which, if it
exists, can be used to further customize your configuration path.  If we find
that \f(CW$ENV\fR{\s-1TEST_DBIC_CONFIG_SUFFIX\s0} is set, we attempt to find configuration files
with the suffix appended to each of the items in the config_path option.  So, if
you have:
.PP
.Vb 6
\&    use Test::DBIx::Class
\&        \-config_path => [ 
\&            [qw(/ etc myapp test\-schema)],
\&            \*(Aq+\*(Aq,
\&            [qw(~ etc test\-schema)],
\&        ];
.Ve
.PP
and \f(CW$ENV\fR{\s-1TEST_DBIC_CONFIG_SUFFIX\s0} = '\-mysql' we will check the following paths
for valid and loading configuration files (assuming unix filesystem conventions)
.PP
.Vb 8
\&    /etc/myapp/test\-schema.*
\&    /etc/myapp/test\-schema\-mysql.*
\&    ./t/etc/schema.*    
\&    ./t/etc/schema\-mysql.*
\&    ./etc/[test script name].*
\&    ./etc/[test script name]\-mysql.*
\&    ~/etc/test\-schema.*
\&    ~/etc/test\-schema\-mysql.*
.Ve
.PP
Each path is tested in turn and all found configurations are merged from top to
bottom.  This feature is intended to make it easier to switch between sets of
configuration files when developing.  For example, you can create a test suite
intended for a MySQL database, but allow a failback to the default Sqlite should
certain enviroment variables not exist.
.SH "CONFIGURATION SUBSTITUTIONS"
.IX Header "CONFIGURATION SUBSTITUTIONS"
Similarly to Catalyst::Plugin::ConfigLoader, there are some macro style 
keyword inflators available for use within your configuration files.  This
allows you to set the value of a configuration setting from an external source,
such as from \f(CW%ENV\fR.  There are currently two macro substitutions:
.IP "\s-1ENV\s0" 4
.IX Item "ENV"
Given a value in \f(CW%ENV\fR, substitute the keyword for the value of the named
substitution.  For example, if you had:
.Sp
.Vb 1
\&    email = \*(Aqvanessa_\|_ENV(TEST_DBIC_LAST_NAME)_\|_@school.com\*(Aq
.Ve
.Sp
in your configuration filem your could:
.Sp
.Vb 1
\&    TEST_DBIC_LAST_NAME=_lee prove \-lv t/schema\-your\-test.t
.Ve
.Sp
and then:
.Sp
.Vb 1
\&    is $vanessa\->email, \*(Aqvanessa_lee@school.com\*(Aq, \*(AqGot expected email\*(Aq;
.Ve
.Sp
You might find this useful for configuring localized username and passwords
although personally I'd rather set that via configuration in the user home
directory.
.SH "TRAITS"
.IX Header "TRAITS"
As described, a trait is a Moose::Role that is applied to the class
managing your database and test instance.  Traits are installed by the
\&'traits' configuration option, which expects an ArrayRef as its input
(however will also normalize a scalar to an ArrayRef).
.PP
Available traits are as follows.
.SS "SQLite"
.IX Subsection "SQLite"
This is the default trait which will be loaded if no other traits are installed
and there is not 'connect_info' in the configuration.  In this case we assume
you want us to go and create a tempory SQLite database for testing.  Please see
Test::DBIx::Class::SchemaManager::Trait::SQLite for more.
.SS "Testmysqld"
.IX Subsection "Testmysqld"
If MySQL is installed on the testing machine, and DBD::mysql, we try to auto
create an instance of MySQL and deploy our tests to that.  Similarly to the way
the SQLite trait works, we attempt to create the database without requiring any
other using effort or setup.
.PP
See Test::DBIx::Class::SchemaManager::Trait::Testmysqld for more.
.SS "Testpostgresql"
.IX Subsection "Testpostgresql"
If Postgresql is installed on the testing machine, along with DBD::Pg, we try
to auto create an instance of Postgresql in a testing area and deploy our tests
and fixtures to it.
.PP
See Test::DBIx::Class::SchemaManager::Trait::Testpostgresql for more.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The following modules or resources may be of interest.
.PP
DBIx::Class, DBIx::Class::Schema::PopulateMore, DBIx::Class::Fixtures
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    John Napiorkowski C<< <jjnapiork@cpan.org> >>
.Ve
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.Vb 10
\&    Tristan Pratt
\&    Tomas Doran C<< <bobtfish@bobtfish.net> >>
\&    Kyle Hasselbacher C<< kyleha@gmail.com >>
\&    cvince
\&    colinnewell
\&    rbuels
\&    wlk
\&    yanick
\&    hippich
\&    lecstor
\&    bphillips
\&    abraxxa
\&    oalders
\&    felliott
\&    Vadim Pushtaev C<< <pushtaev@cpan.org> >>
\&    simonamor
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2012, John Napiorkowski \f(CW\*(C`<jjnapiork@cpan.org>\*(C'\fR
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
