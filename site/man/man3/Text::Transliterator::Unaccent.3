.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Transliterator::Unaccent 3"
.TH Text::Transliterator::Unaccent 3 "2020-08-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Transliterator::Unaccent \- Compile a transliterator from Unicode tables, to remove accents from text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  my $unaccenter = Text::Transliterator::Unaccent\->new(script => \*(AqLatin\*(Aq,
\&                                                       wide   => 0,
\&                                                       upper  => 0);
\&  $unaccenter\->($string);
\&
\&  my $map   = Text::Transliterator::Unaccent\->char_map(script => \*(AqLatin\*(Aq);
\&
\&  my $descr = Text::Transliterator::Unaccent\->char_map_descr();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package compiles a transliteration function that will replace
accented characters by unaccented characters. That function
is fast, because it uses the builtin \f(CW\*(C`tr/.../.../\*(C'\fR Perl operator; it
is compact, because it only treats the Unicode subset that you need
for your language; and it is complete, because it relies on
the builtin Unicode character tables shipped with your Perl installation.
.PP
The algorithm for detecting accented characters is derived from the notion
of \fIcompositions\fR in Unicode; that notion is explained in perluniintro.
Characters considered \*(L"accented\*(R" are the precomposed characters for
which the Unicode canonical decomposition contains more than one
codepoint; for such decompositions, the first codepoint is the
unaccented character that will be mapped to the accented one.  This
definition seems to work well for the Latin script; I presume that it
also makes sense for other scripts as well, but I'm not able to test.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 3
\&  my $unaccenter = Text::Transliterator::Unaccent\->new(@range_description);
\&  # or
\&  my $unaccenter = Text::Transliterator::Unaccent\->new(); # script => \*(AqLatin\*(Aq
.Ve
.PP
Compiles a new 'unaccenter' function. The \f(CW@range_description\fR
argument specifies which ranges of characters will be handled, and is
comprised of pairs of shape :
.ie n .IP """script => $unicode_script""" 4
.el .IP "\f(CWscript => $unicode_script\fR" 4
.IX Item "script => $unicode_script"
\&\f(CW$unicode_script\fR is the name of a Unicode script, such as 'Latin', 
\&'Greek' or 'Cyrillic'.
For a complete list of unicode scripts, see
.Sp
.Vb 1
\&  perl \-MUnicode::UCD=charscripts \-e "print join \*(Aq, \*(Aq, keys %{charscripts()}"
.Ve
.ie n .IP """block => $unicode_block""" 4
.el .IP "\f(CWblock => $unicode_block\fR" 4
.IX Item "block => $unicode_block"
\&\f(CW$unicode_block\fR is the name of a Unicode block. For a complete list of 
Unicode blocks, see
.Sp
.Vb 1
\&  perl \-MUnicode::UCD=charblocks \-e "print join \*(Aq, \*(Aq, keys %{charblocks()}"
.Ve
.ie n .IP """range => \e@codepoint_ranges""" 4
.el .IP "\f(CWrange => \e@codepoint_ranges\fR" 4
.IX Item "range => @codepoint_ranges"
\&\f(CW@codepoint_ranges\fR is a list of arrayrefs that contain
\&\fIstart-of-range, end-of-range\fR
code point pairs.
.ie n .IP """wide => $bool""" 4
.el .IP "\f(CWwide => $bool\fR" 4
.IX Item "wide => $bool"
Decides if wide characters (i.e. characters with code points above 255)
are kept or not within the map. The default is \fItrue\fR.
.ie n .IP """upper => $bool""" 4
.el .IP "\f(CWupper => $bool\fR" 4
.IX Item "upper => $bool"
Decides if uppercase characters are kept or not within the map. The
default is \fItrue\fR.
.ie n .IP """lower => $bool""" 4
.el .IP "\f(CWlower => $bool\fR" 4
.IX Item "lower => $bool"
Decides if lowercase characters are kept or not within the map. The
default is \fItrue\fR.
.PP
The \f(CW@range_description\fR may contain a list of several scripts,
blocks and/or ranges; all will get concatenated into a single
correspondance map.  If the list is empty, the default range is
\&\f(CW\*(C`script => \*(AqLatin\*(Aq\*(C'\fR.
.PP
The return value from that \f(CW\*(C`new\*(C'\fR method is actually
a reference to a function, not an object. That function is called as
.PP
.Vb 1
\&  $unaccenter\->(@strings);
.Ve
.PP
and modifies every member of \f(CW@strings\fR \fIin place\fR, 
like the \f(CW\*(C`tr/.../.../\*(C'\fR operator.
The return value is the number of transliterated characters
in the last member of \f(CW@strings\fR.
.SS "char_map"
.IX Subsection "char_map"
.Vb 1
\&  my $map = Text::Transliterator::Unaccent\->char_map(@range_description);
.Ve
.PP
Utility class method that 
returns a hashref of the accented characters in \f(CW@range_description\fR,
mapped to their unaccented corresponding characters, according to
the algorithm described in the introduction. The \f(CW@range_description\fR
format is exactly like for the \f(CW\*(C`new()\*(C'\fR method.
.SS "char_map_descr"
.IX Subsection "char_map_descr"
.Vb 1
\&  my $descr = Text::Transliterator::Unaccent\->char_map_descr(@range_descr);
.Ve
.PP
Utility class method that 
returns a textual description of the map 
generated by \f(CW@range_descr\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Text::Unaccent is another unaccenter module, with a C and a Pure
Perl version. It is based on \f(CW\*(C`iconv\*(C'\fR instead of Perl's internal
Unicode tables, and therefore may produce slighthly different
results. According to some experimental benchmarks, the C version of
\&\f(CW\*(C`Text::Unaccent\*(C'\fR is faster than \f(CW\*(C`Text::Transliterator::Unaccent\*(C'\fR on
short strings and on small number of calls, and slower on long strings
or high number of calls (but this may be a side-effect of the fact
that it returns a copy of the string instead of replacing characters
in-place); however I am not able to give a predictable rule about
which module is faster in which circumstances.
.PP
Text::StripAccents is a Pure Perl module. In only handles Latin1, and
is several orders of magnitude slower because it does an
internal split and join of the whole string.
.PP
Search::Tokenizer uses the present module for building
an \f(CW\*(C`unaccent\*(C'\fR tokenizer.
.SH "AUTHOR"
.IX Header "AUTHOR"
Laurent Dami, \f(CW\*(C`<dami@cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-text\-transliterator at rt.cpan.org\*(C'\fR, or through the web
interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Text\-Transliterator>.
I will be notified, and then you'll automatically be notified of
progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Text::Transliterator::Unaccent
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Text\-Transliterator>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Text\-Transliterator>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Text\-Transliterator>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Text\-Transliterator/>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2010, 2017 Laurent Dami.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
