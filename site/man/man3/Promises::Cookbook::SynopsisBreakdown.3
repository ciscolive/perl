.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises::Cookbook::SynopsisBreakdown 3"
.TH Promises::Cookbook::SynopsisBreakdown 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises::Cookbook::SynopsisBreakdown \- A breakdown of the SYNOPSIS section of Promises
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use AnyEvent::HTTP;
\&  use JSON::XS qw[ decode_json ];
\&  use Promises qw[ collect deferred ];
\&
\&  sub fetch_it {
\&      my ($uri) = @_;
\&      my $d = deferred;
\&      http_get $uri => sub {
\&          my ($body, $headers) = @_;
\&          $headers\->{Status} == 200
\&              ? $d\->resolve( decode_json( $body ) )
\&              : $d\->reject( $body )
\&      };
\&      $d\->promise;
\&  }
\&
\&  my $cv = AnyEvent\->condvar;
\&
\&  collect(
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq),
\&  )\->then(
\&      sub {
\&          my ($product, $suggestions, $reviews) = @_;
\&          $cv\->send({
\&              product     => $product,
\&              suggestions => $suggestions,
\&              reviews     => $reviews,
\&          })
\&      },
\&      sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&  );
\&
\&  my $all_product_info = $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The example in the synopsis actually demonstrates a number of the
features of this module, this section will break down each part
and explain them in order.
.PP
.Vb 11
\&  sub fetch_it {
\&      my ($uri) = @_;
\&      my $d = deferred;
\&      http_get $uri => sub {
\&          my ($body, $headers) = @_;
\&          $headers\->{Status} == 200
\&              ? $d\->resolve( decode_json( $body ) )
\&              : $d\->reject( $body )
\&      };
\&      $d\->promise;
\&  }
.Ve
.PP
First is the \f(CW\*(C`fetch_it\*(C'\fR function, the pattern within this function
is the typical way in which you might wrap an async function call
of some kind. The first thing we do it to create an instance of
Promises::Deferred using the \f(CW\*(C`deferred\*(C'\fR function, this is the
class which does the majority of the work or managing callbacks
and the like. Then within the callback for our async function,
we will call methods on the Promises::Deferred instance. In the
case we first check the response headers to see if the request was
a success, if so, then we call the \f(CW\*(C`resolve\*(C'\fR method and pass the
decoded \s-1JSON\s0 to it. If the request failed, we then call the \f(CW\*(C`reject\*(C'\fR
method and send back the data from the body. Finally we call the
\&\f(CW\*(C`promise\*(C'\fR method and return the promise 'handle' for this deferred
instance.
.PP
At this point out asynchronous operation will typically be in
progress, but control has been returned to the rest of our
program. Now, before we dive into the rest of the example, lets
take a quick detour to look at what promises do. Take the following
code for example:
.PP
.Vb 1
\&  my $p = fetch_it(\*(Aqhttp://rest.api.example.com/\-/user/bob@example.com\*(Aq);
.Ve
.PP
At this point, our async operation is running, but we have not yet
given it anything to do when the callback is fired. We will get to
that shortly, but first lets look at what information we can get
from the promise.
.PP
.Vb 1
\&  $p\->status;
.Ve
.PP
Calling the \f(CW\*(C`status\*(C'\fR method will return a string representing the
status of the promise. This will be either \fIin progress\fR, \fIresolved\fR,
\&\fIresolving\fR (meaning it is in the process of resolving), \fIrejected\fR
or \fIrejecting\fR (meaning it is in the process of rejecting).
(\s-1NOTE:\s0 these are also constants on the Promises::Deferred class,
\&\f(CW\*(C`IN_PROGRESS\*(C'\fR, \f(CW\*(C`RESOLVED\*(C'\fR, \f(CW\*(C`REJECTED\*(C'\fR, etc., but they are also
available as predicate methods in both the Promises::Deferred class
and proxied in the Promises::Promise class). At this point, this
method call is likely to return \fIin progress\fR. Next is the \f(CW\*(C`result\*(C'\fR
method:
.PP
.Vb 1
\&  $p\->result;
.Ve
.PP
which will give us back the values that are passed to either \f(CW\*(C`resolve\*(C'\fR
or \f(CW\*(C`reject\*(C'\fR on the associated Promises::Deferred instance.
.PP
Now, one thing to keep in mind before we go any further is that our
promise is really just a thin proxy over the associated Promises::Deferred
instance, it stores no state itself, and when these methods are called on
it, it simply forwards the call to the associated Promises::Deferred
instance (which, as I said before, is where all the work is done).
.PP
So, now, lets actually do something with this promise. So as I said above
the goal of the Promise pattern is to reduce the callback spaghetti that
is often created with writing async code. This does not mean that we have
no callbacks at all, we still need to have some kind of callback, the
difference is all in how those callbacks are managed and how we can more
easily go about providing some level of sequencing and control.
.PP
That all said, lets register a callback with our promise.
.PP
.Vb 10
\&  $p\->then(
\&      sub {
\&          my ($user) = @_;
\&          do_something_with_a_user( $user );
\&      },
\&      sub {
\&          my ($err) = @_;
\&          warn "An error was received : $err";
\&      }
\&  );
.Ve
.PP
As you can see, we use the \f(CW\*(C`then\*(C'\fR method (again, keep in mind this is
just proxying to the associated Promises::Deferred instance) and
passed it two callbacks, the first is for the success case (if \f(CW\*(C`resolve\*(C'\fR
has been called on our associated Promises::Deferred instance) and
the second is the error case (if \f(CW\*(C`reject\*(C'\fR has been called on our
associated Promises::Deferred instance). Both of these callbacks will
receive the arguments that were passed to \f(CW\*(C`resolve\*(C'\fR or \f(CW\*(C`reject\*(C'\fR as
their only arguments, as you might have guessed, these values are the
same values you would get if you called \f(CW\*(C`result\*(C'\fR on the promise
(assuming the async operation was completed).
.PP
It should be noted that the error callback is optional. If it is not
specified then errors will be silently eaten (similar to a \f(CW\*(C`try\*(C'\fR block
that has not \f(CW\*(C`catch\*(C'\fR). If there is a chain of promises however, the
error will continue to bubble to the last promise in the chain and
if there is an error callback there, it will be called. This allows
you to concentrate error handling in the places where it makes the most
sense, and ignore it where it doesn't make sense. As I alluded to above,
this is very similar to nested \f(CW\*(C`try/catch\*(C'\fR blocks.
.PP
And really, that's all there is to it. You can continue to call \f(CW\*(C`then\*(C'\fR
on a promise and it will continue to accumulate callbacks, which will
be executed in \s-1FIFO\s0 order once a call is made to either \f(CW\*(C`resolve\*(C'\fR
or \f(CW\*(C`reject\*(C'\fR on the associated Promises::Deferred instance. And in
fact, it will even work after the async operation is complete. Meaning
that if you call \f(CW\*(C`then\*(C'\fR and the async operation is already completed,
your callback will be executed immediately.
.PP
So, now lets get back to our original example. I will briefly explain
my usage of the AnyEvent \f(CW\*(C`condvar\*(C'\fR, but I encourage you to review
the docs for AnyEvent yourself if my explanation is not enough.
.PP
So, the idea behind my usage of the \f(CW\*(C`condvar\*(C'\fR is to provide a
merge-point in my code at which point I want all the asynchronous
operations to converge, after which I can resume normal synchronous
programming (if I so choose). It provides a kind of a transaction
wrapper if you will, around my async operations. So, first step is
to actually create that \f(CW\*(C`condvar\*(C'\fR.
.PP
.Vb 1
\&  my $cv = AnyEvent\->condvar;
.Ve
.PP
Next, we jump back into the land of Promises. Now I am breaking apart
the calling of \f(CW\*(C`collect\*(C'\fR and the subsequent chained \f(CW\*(C`then\*(C'\fR call here
to help keep things in digestible chunks, but also to illustrate that
\&\f(CW\*(C`collect\*(C'\fR just returns a promise (as you might have guessed anyway).
.PP
.Vb 5
\&  my $p = collect(
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq),
\&      fetch_it(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq),
\&  );
.Ve
.PP
So, what is going on here is that we want to be able to run multiple
async operations in parallel, but we need to wait for all of them to
complete before we can move on, and \f(CW\*(C`collect\*(C'\fR gives us that ability.
As we know from above, \f(CW\*(C`fetch_it\*(C'\fR is returning a promise, so obviously
\&\f(CW\*(C`collect\*(C'\fR takes an array of promises as its parameters. As we said before
\&\f(CW\*(C`collect\*(C'\fR also returns a promise, which is just a handle on a
\&\f(CW\*(C`Promises::Deferred\*(C'\fR instance it created to watch and handle the
multiple promises you passed it. Okay, so now lets move onto adding
callbacks to our promise that \f(CW\*(C`collect\*(C'\fR returned to us.
.PP
.Vb 11
\&  $p\->then(
\&      sub {
\&          my ($product, $suggestions, $reviews) = @_;
\&          $cv\->send({
\&              product     => $product,
\&              suggestions => $suggestions,
\&              reviews     => $reviews,
\&          })
\&      },
\&      sub { $cv\->croak( \*(AqERROR\*(Aq ) }
\&  );
.Ve
.PP
So, you will notice that, as before, we provide a success and an error
callback, but you might notice one slight difference in the success
callback. It is actually being passed multiple arguments, these are
the results of the three \f(CW\*(C`fetch_it\*(C'\fR calls passed into \f(CW\*(C`collect\*(C'\fR, and yes,
they are passed to the callback in the same order you passed them into
\&\f(CW\*(C`collect\*(C'\fR. So from here we jump back into the world of \f(CW\*(C`condvars\*(C'\fR, and
we call the \f(CW\*(C`send\*(C'\fR method and pass it our newly assembled set of
collected product info. As I said above, \f(CW\*(C`condvars\*(C'\fR are a way of
wrapping your async operations into a transaction like block, when
code execution encounters a \f(CW\*(C`recv\*(C'\fR, such as in our next line of code:
.PP
.Vb 1
\&  my $all_product_info = $cv\->recv;
.Ve
.PP
the event loop will block until a corresponding \f(CW\*(C`send\*(C'\fR is called on
the \f(CW\*(C`condvar\*(C'\fR. While you are not required to pass arguments to \f(CW\*(C`send\*(C'\fR
it will accept them and the will in turn be the return values of
the corresponding \f(CW\*(C`recv\*(C'\fR, which makes for an incredibly convenient
means of passing data around your asynchronous program.
.PP
It is also worth noting the usage of the \f(CW\*(C`croak\*(C'\fR method on the
\&\f(CW\*(C`condvar\*(C'\fR in the error callback. This is the preferred way of
dealing with exceptions in AnyEvent because it will actually
cause the exception to be thrown from \f(CW\*(C`recv\*(C'\fR and not somewhere
deep within a callback.
.PP
And that is all of it, once \f(CW\*(C`recv\*(C'\fR returns, our program will go
back to normal synchronous operation and we can do whatever it is
we like with \f(CW$all_product_info\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
