.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catmandu::Validator 3"
.TH Catmandu::Validator 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catmandu::Validator \- Namespace for packages that can validate items in Catmandu
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Catmandu::Validator::Simple;
\&
\&    my $validator = Catmandu::Validator::Simple\->new(
\&        handler => sub {
\&            $data = shift;
\&            return "error" unless $data\->{title} =~ m/good title/;
\&            return;
\&        }
\&    );
\&
\&    if ( $validator\->is_valid($hashref) ) {
\&        save_record_in_database($hashref);
\&    } else {
\&        reject_form($validator\->last_errors);
\&    }
\&
\&    my $validator = Catmandu::Validator::Simple\->new(
\&        handler => sub { ...},
\&        error_callback => sub {
\&            my ($data, $errors) = @_;
\&            print "Validation errors for record $data\->{_id}:\en";
\&            print "$_\en" for @{$errors};
\&        }
\&    };
\&
\&    my $validated_arrayref = $validator\->validate($arrayref);
\&
\&    $validator\->validate($iterator, {
\&        after_callback => sub {
\&            my ($record, $errors) = @_;
\&            if ($errors) {
\&                add_to_failure_report($rec, $errors);
\&                #omit the invalid record from the result
\&                return undef;
\&            }
\&            return $rec;
\&        }
\&    })\->each( sub {
\&        my $record = shift;
\&        publish_record($record);
\&    });
.Ve
.PP
See Catmandu::Fix::validate and Catmandu::Fix::Condition::valid to use validators in fixes (Catmandu::Fix).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Catmandu::Validator is a base class for Perl packages that can validate data.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fBnew()\fP"
.IX Subsection "new()"
Create a new Catmandu::Validator.
.SS "new( after_callback => \e&callback )"
.IX Subsection "new( after_callback => &callback )"
The after_callback is called after each record has been validated.
The callback function should take \f(CW$hashref\fR to each data record, and \f(CW$arrayref\fR to list of validation errors
for the record as arguments.
.ie n .SS "new( error_field => $field_name )"
.el .SS "new( error_field => \f(CW$field_name\fP )"
.IX Subsection "new( error_field => $field_name )"
If the error_field parameter is set, then during validation each record that
fails validation will get an extra field added containing an
arrayref to the validation errors. The name of the key will be the
value passed or '_validation_errors' if 1 is passed. By default it is not set.
.SS "is_valid( \e%hash )"
.IX Subsection "is_valid( %hash )"
Validates a single record. Returns 1 success and 0 on failure. Information about the validation errors
can be retrieved with the \*(L"\fBlast_errors()\fR\*(R" method.
.SS "validate( \e%hash )"
.IX Subsection "validate( %hash )"
.ie n .SS "validate( $iterator )"
.el .SS "validate( \f(CW$iterator\fP )"
.IX Subsection "validate( $iterator )"
.SS "validate( \e@array )"
.IX Subsection "validate( @array )"
Validates a single record or multiple records in an iterator or an array. Returns validated records in the same type of
container for multiple records or the record itself for a single record. The default behaviour is to return the records that passed validation unchanged and omit the invalid records.
This behaviour can be changed by setting the \fIafter_callback\fR or the \fIerror_field\fR in the constructor. Returns undef on validation failure for single records.
.SS "\fBlast_errors()\fP"
.IX Subsection "last_errors()"
Returns arrayref of errors from the record that was last validated if that record failed validation
or undef if there were no errors.
.SS "\fBvalid_count()\fP"
.IX Subsection "valid_count()"
Returns the number of valid records from last validate operation.
.SS "\fBinvalid_count()\fP"
.IX Subsection "invalid_count()"
Returns the number of invalid records from the last validate operation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catmandu::Validator::Env and Catmandu::Validator::Simple.
.PP
Catmandu::Iterable
