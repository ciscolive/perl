.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Promises::Cookbook::TIMTOWTDI 3"
.TH Promises::Cookbook::TIMTOWTDI 3 "2020-02-23" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Promises::Cookbook::TIMTOWTDI \- Counter examples to Promises
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
So, like I said before, Promises are a means by which you can more
effectively manage your async operations and avoid callback spaghetti.
But of course this is Perl and therefore there is always another way
to do it. In this section I am going to show a few examples of other
ways you could accomplish the same thing.
.SS "Caveat"
.IX Subsection "Caveat"
Please note that I am specifically illustrating ways to do this which
I feel are inferior or less elegant then Promises. This is not meant
to be a slight on the \s-1API\s0 of other modules at all, I am simply using
these modules to try and illustrate other (perhaps more familiar)
idioms in hopes that it will help people understand Promises.
.PP
I am sure there are other ways to do some of these things and do
them more effectively, and I am fully willing to admit my ignorance
here. I welcome any patches which might illustrate said ignorance, as
I do not claim at all to be an expert in async programming.
.SH "AnyEvent::HTTP"
.IX Header "AnyEvent::HTTP"
So, enough caveating, please consider this (more traditional) version
of our the Promises \s-1SYNOPSIS\s0 example using AnyEvent::HTTP.
.PP
.Vb 1
\&  my $cv = AnyEvent\->condvar;
\&
\&  http_get(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq, sub {
\&      my ($product) = @_;
\&      http_get(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq, sub {
\&          my ($suggestions) = @_;
\&          http_get(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq, sub {
\&              my ($reviews) = @_;
\&              $cv\->send({
\&                  product     => $product,
\&                  suggestions => $suggestions,
\&                  reviews     => $reviews,
\&              })
\&          }),
\&      });
\&  });
\&
\&  my $all_product_info = $cv\->recv;
.Ve
.PP
Not only do we have deeply nested callbacks, but we have an enforced
order of operations. If you wanted to try and avoid that order of
operations, you might end up writing something like this:
.PP
.Vb 3
\&   my $product_cv    = AnyEvent\->condvar;
\&   my $suggestion_cv = AnyEvent\->condvar;
\&   my $review_cv     = AnyEvent\->condvar;
\&
\&   http_get(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq, sub {
\&       my ($product) = @_;
\&       $product_cv\->send( $product );
\&   });
\&
\&   http_get(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq, sub {
\&       my ($suggestions) = @_;
\&       $suggestion_cv\->send( $suggestions );
\&   });
\&
\&   http_get(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq, sub {
\&       my ($reviews) = @_;
\&       $reviews_cv\->send( $reviews )
\&   }),
\&
\&   my $all_product_info = {
\&       product     => $product_cv\->recv,
\&       suggestions => $suggestions_cv\->recv,
\&       reviews     => $reviews_cv\->recv
\&   };
.Ve
.PP
But actually, this doesn't work either, while we do gain something by
allowing the \f(CW\*(C`http_get\*(C'\fR calls to be run in whatever order works best,
we still end up still enforcing some order in the way we call \f(CW\*(C`recv\*(C'\fR
on our three \f(CW\*(C`condvars\*(C'\fR (Oh yeah, and we had to create and manage three
\&\f(CW\*(C`condvars\*(C'\fR as well).
.PP
The following example was submitted to me by James Wright (via \s-1RT\s0 #83992)
as an alternate approach which is non-nested, uses only one condvar, and
has no fixed-order.
.PP
.Vb 2
\&  my $cv = AnyEvent\->condvar;
\&  my ( $product, $suggestions, $reviews ) = ( [], [], [] );
\&
\&  $cv\->begin;
\&  http_get(\*(Aqhttp://rest.api.example.com/\-/product/12345\*(Aq, sub {
\&      ($product) = @_;
\&      $cv\->end;
\&  });
\&
\&  $cv\->begin;
\&  http_get(\*(Aqhttp://rest.api.example.com/\-/product/suggestions?for_sku=12345\*(Aq, sub {
\&      ($suggestions) = @_;
\&      $cv\->end;
\&  });
\&
\&  $cv\->begin;
\&  http_get(\*(Aqhttp://rest.api.example.com/\-/product/reviews?for_sku=12345\*(Aq, sub {
\&      ($reviews) = @_;
\&      $cv\->end;
\&  });
\&
\&  $cv\->cb(sub {
\&      $cv\->send({
\&          product     => $product,
\&          suggestions => $suggestions,
\&          reviews     => $reviews,
\&      });
\&  });
\&
\&  my $all_product_info = $cv\->recv;
.Ve
.PP
The only real issue I have with this approach is the semi-global variable usage
(\f(CW$product\fR, \f(CW$suggestions\fR and \f(CW$reviews\fR), but otherwise it works fine.
.PP
\&\s-1NOTE:\s0 Again, if you can think of a better way to do this that I missed,
please let me know.
.SH "Mojo::UserAgent"
.IX Header "Mojo::UserAgent"
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use Mojo::Base \-strict;
\&    use Mojo::UserAgent;
\&
\&    my $titles;
\&
\&    my $ua = Mojo::UserAgent\->new;
\&    Mojo::IOLoop\->delay(
\&        sub {
\&            my $delay = shift;
\&            $ua\->get(\*(Aqhttp://google.com/\*(Aq, $delay\->begin);
\&            $ua\->get(\*(Aqhttp://yahoo.com/\*(Aq, $delay\->begin);
\&            $ua\->get(\*(Aqhttp://perlmonks.org/\*(Aq, $delay\->begin);
\&        },
\&        sub {
\&            my ($delay, $tx1, $tx2, $tx3) = @_;
\&            $titles = {
\&                google      => $tx1\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text,
\&                yahoo       => $tx2\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text,
\&                perlmonks   => $tx3\->res\->dom\->at(\*(Aqtitle\*(Aq)\->text,
\&            };
\&        },
\&    )\->catch(
\&        sub {
\&            my ($delay, $err) = @_;
\&            warn "failed to download or parse title\en";
\&        }
\&    )\->wait;
\&
\&    say Mojo::Util::dumper($titles);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020, 2019, 2017, 2014, 2012 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
