.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Astro::FITS::Header 3"
.TH Astro::FITS::Header 3 "2020-08-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Astro::FITS::Header \- Object Orientated interface to FITS HDUs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  $header = new Astro::FITS::Header( Cards => \e@array );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Stores information about a \s-1FITS\s0 header block in an object. Takes an hash
with an array reference as an argument. The array should contain a list
of \s-1FITS\s0 header cards as input.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
.IP "\fBnew\fR" 4
.IX Item "new"
Create a new instance from an array of \s-1FITS\s0 header cards.
.Sp
.Vb 1
\&  $item = new Astro::FITS::Header( Cards => \e@header );
.Ve
.Sp
returns a reference to a Header object.  If you pass in no cards,
you get the (required) first \s-1SIMPLE\s0 card for free.
.SS "Accessor Methods"
.IX Subsection "Accessor Methods"
.IP "\fBtiereturnsref\fR" 4
.IX Item "tiereturnsref"
Indicates whether the tied object should return multiple values
as a single string joined by newline characters (false) or
it should return a reference to an array containing all the values.
.Sp
Only affects the tied interface.
.Sp
.Vb 2
\&  tie %keywords, "Astro::FITS::Header", $header, tiereturnsref => 1;
\&  $ref = $keywords{COMMENT};
.Ve
.Sp
Defaults to returning a single string in all cases (for backwards
compatibility)
.IP "\fBsubhdrs\fR" 4
.IX Item "subhdrs"
Set or return the subheaders for a Header object. Arguments must be
given as \f(CW\*(C`Astro::FITS::Header\*(C'\fR objects.
.Sp
.Vb 2
\&    $header\->subhdrs(@hdrs);
\&    @hdrs = $header\->subhdrs;
.Ve
.Sp
This method should be used when you have additional header components
that should be associated with the primary header but they are not
associated with a particular name, just an ordering.
.Sp
\&\s-1FITS\s0 headers that are associated with a name can be stored directly
in the header using an \f(CW\*(C`Astro::FITS::Header::Item\*(C'\fR of type '\s-1HEADER\s0'.
.IP "\fBitem\fR" 4
.IX Item "item"
Returns a FITS::Header:Item object referenced by index, \f(CW\*(C`undef\*(C'\fR if it
does not exist.
.Sp
.Vb 1
\&   $item = $header\->item($index);
.Ve
.IP "\fBget_wcs\fR" 4
.IX Item "get_wcs"
Returns a Starlink::AST FrameSet object representing the \s-1WCS\s0 of the
\&\s-1FITS\s0 Header.
.Sp
.Vb 1
\&   $ast = $header\->get_wcs();
.Ve
.IP "\fBkeyword\fR" 4
.IX Item "keyword"
Returns keyword referenced by index, \f(CW\*(C`undef\*(C'\fR if it does not exist.
.Sp
.Vb 1
\&   $keyword = $header\->keyword($index);
.Ve
.IP "\fBitembyname\fR" 4
.IX Item "itembyname"
Returns an array of Header::Items for the requested keyword if called
in list context, or the first matching Header::Item if called in scalar
context. Returns \f(CW\*(C`undef\*(C'\fR if the keyword does not exist.  The keyword
may be a regular expression created with the \f(CW\*(C`qr\*(C'\fR operator.
.Sp
.Vb 2
\&   @items = $header\->itembyname($keyword);
\&   $item = $header\->itembyname($keyword);
.Ve
.IP "\fBitembytype\fR" 4
.IX Item "itembytype"
Returns an array of Header::Items for the requested type if called in
list context, or the first matching Header::Item if called in scalar
context. See \f(CW\*(C`Astro::FITS::Header::Item\*(C'\fR for a list of allowed types.
.Sp
.Vb 3
\&   @items = $header\->itembytype( "COMMENT" );
\&   @items = $header\->itembytype( "HEADER" );
\&   $item = $header\->itembytype( "INT" );
.Ve
.IP "\fBindex\fR" 4
.IX Item "index"
Returns an array of indices for the requested keyword if called in
list context, or an empty array if it does not exist.  The keyword may
be a regular expression created with the \f(CW\*(C`qr\*(C'\fR operator.
.Sp
.Vb 1
\&   @index = $header\->index($keyword);
.Ve
.Sp
If called in scalar context it returns the first item in the array, or
\&\f(CW\*(C`undef\*(C'\fR if the keyword does not exist.
.Sp
.Vb 1
\&   $index = $header\->index($keyword);
.Ve
.IP "\fBvalue\fR" 4
.IX Item "value"
Returns an array of values for the requested keyword if called in list
context, or an empty array if it does not exist.  The keyword may be
a regular expression created with the \f(CW\*(C`qr\*(C'\fR operator.
.Sp
.Vb 1
\&   @value = $header\->value($keyword);
.Ve
.Sp
If called in scalar context it returns the first item in the array, or
\&\f(CW\*(C`undef\*(C'\fR if the keyword does not exist.
.IP "\fBcomment\fR" 4
.IX Item "comment"
Returns an array of comments for the requested keyword if called
in list context, or an empty array if it does not exist.  The keyword
may be a regular expression created with the \f(CW\*(C`qr\*(C'\fR operator.
.Sp
.Vb 1
\&   @comment = $header\->comment($keyword);
.Ve
.Sp
If called in scalar context it returns the first item in the array, or
\&\f(CW\*(C`undef\*(C'\fR if the keyword does not exist.
.Sp
.Vb 1
\&   $comment = $header\->comment($keyword);
.Ve
.IP "\fBinsert\fR" 4
.IX Item "insert"
Inserts a \s-1FITS\s0 header card object at position \f(CW$index\fR
.Sp
.Vb 1
\&   $header\->insert($index, $item);
.Ve
.Sp
the object \f(CW$item\fR is not copied, multiple inserts of the same object mean
that future modifications to the one instance of the inserted object will
modify all inserted copies.
.Sp
The insert position can be negative.
.IP "\fBreplace\fR" 4
.IX Item "replace"
Replace \s-1FITS\s0 header card at index \f(CW$index\fR with card \f(CW$item\fR
.Sp
.Vb 1
\&   $card = $header\->replace($index, $item);
.Ve
.Sp
returns the replaced card.
.IP "\fBremove\fR" 4
.IX Item "remove"
Removes a \s-1FITS\s0 header card object at position \f(CW$index\fR
.Sp
.Vb 1
\&   $card = $header\->remove($index);
.Ve
.Sp
returns the removed card.
.IP "\fBreplacebyname\fR" 4
.IX Item "replacebyname"
Replace \s-1FITS\s0 header cards with keyword \f(CW$keyword\fR with card \f(CW$item\fR
.Sp
.Vb 1
\&   $card = $header\->replacebyname($keyword, $item);
.Ve
.Sp
returns the replaced card. The keyword may be a regular expression
created with the \f(CW\*(C`qr\*(C'\fR operator.
.IP "\fBremovebyname\fR" 4
.IX Item "removebyname"
Removes a \s-1FITS\s0 header card object by name
.Sp
.Vb 1
\&  @card = $header\->removebyname($keyword);
.Ve
.Sp
returns the removed cards.  The keyword may be a regular expression
created with the \f(CW\*(C`qr\*(C'\fR operator.
.IP "\fBsplice\fR" 4
.IX Item "splice"
Implements a standard splice operation for \s-1FITS\s0 headers
.Sp
.Vb 2
\&   @cards = $header\->splice($offset [,$length [, @list]]);
\&   $last_card = $header\->splice($offset [,$length [, @list]]);
.Ve
.Sp
Removes the \s-1FITS\s0 header cards from the header designated by \f(CW$offset\fR and
\&\f(CW$length\fR, and replaces them with \f(CW@list\fR (if specified) which must be an
array of FITS::Header::Item objects. Returns the cards removed. If offset
is negative, counts from the end of the \s-1FITS\s0 header.
.IP "\fBcards\fR" 4
.IX Item "cards"
Return the object contents as an array of \s-1FITS\s0 cards.
.Sp
.Vb 1
\&  @array = $header\->cards;
.Ve
.IP "\fBsizeof\fR" 4
.IX Item "sizeof"
Returns the highest index in use in the \s-1FITS\s0 header.
To get the total number of header items, add 1.
.Sp
.Vb 1
\&  $number = $header\->sizeof;
.Ve
.IP "\fBallitems\fR" 4
.IX Item "allitems"
Returns the header as an array of FITS::Header:Item objects.
.Sp
.Vb 1
\&   @items = $header\->allitems();
.Ve
.SS "General Methods"
.IX Subsection "General Methods"
.IP "\fBconfigure\fR" 4
.IX Item "configure"
Configures the object, takes an array of \s-1FITS\s0 header cards,
an array of Astro::FITS::Header::Item objects or a simple hash as input.
If you feed in nothing at all, it uses a default array containing
just the \s-1SIMPLE\s0 card required at the top of all \s-1FITS\s0 files.
.Sp
.Vb 3
\&  $header\->configure( Cards => \e@array );
\&  $header\->configure( Items => \e@array );
\&  $header\->configure( Hash => \e%hash );
.Ve
.Sp
Does nothing if the array is not supplied. If the hash scheme is used
and the hash contains the special key of \s-1SUBHEADERS\s0 pointing to an
array of hashes, these will be read as proper sub headers. All other
references in the hash will be ignored. Note that the default key
order will be retained in the object created via the hash.
.IP "\fBmerge_primary\fR" 4
.IX Item "merge_primary"
Given the current header and a set of \f(CW\*(C`Astro::FITS::Header\*(C'\fR objects,
return a merged \s-1FITS\s0 header (with the cards that have the same value
and comment across all headers) along with, for each input, header
objects containing all the header items that differ (including, by
default, keys that are not present in all headers). Only the primary
headers are merged, subheaders are ignored.
.Sp
.Vb 3
\& ($clone) = $headerr\->merge_primary();
\& ($same, @different) = $header\->merge_primary( $fits1, $fits2, ...);
\& ($same, @different) = $header\->merge_primary( \e%options, $fits1, $fits2 );
.Ve
.Sp
\&\f(CW@different\fR can be empty if all headers match (but see the
\&\f(CW\*(C`force_return_diffs\*(C'\fR option) but if any headers are different there
will always be the same number of headers in \f(CW@different\fR as supplied to
the function (including the reference header). A clone of the input header
(stripped of any subheaders) is returned if no comparison headers are
supplied.
.Sp
In scalar context, just returns the merged header.
.Sp
.Vb 1
\&  $merged = $header\->merge_primary( @hdrs );
.Ve
.Sp
The options hash is itself optional. It contains the following keys:
.Sp
.Vb 3
\& merge_unique \- if an item is identical across multiple headers and only
\&                exists in those headers, propogate to the merged header rather
\&                than storing it in the difference headers.
\&
\& force_return_diffs \- return an empty difference object per input header
\&                      even if there are no diffs
.Ve
.IP "\fBfreeze\fR" 4
.IX Item "freeze"
Method to return a blessed reference to the object so that we can store
ths object on disk using Data::Dumper module.
.IP "\fBappend\fR" 4
.IX Item "append"
Append or update a card.
.Sp
.Vb 1
\&  $header\->append( $card );
.Ve
.Sp
This method can take either an Astro::FITS::Header::Item object, an
Astro::FITS::Header object, or a reference to an array of
Astro::FITS::Header::Item objects.
.Sp
In all cases, if the given Astro::FITS::Header::Item keyword exists in
the header, then the value will be overwritten with the one passed to
the method. Otherwise, the card will be appended to the end of the
header.
.Sp
Nothing is returned.
.SS "Operator Overloading"
.IX Subsection "Operator Overloading"
These operators are overloaded:
.ie n .IP "\fB""""\fR" 4
.el .IP "\fB``''\fR" 4
.IX Item """"""
When the object is used in a string context the \s-1FITS\s0 header
block is returned as a single string.
.SS "Private methods"
.IX Subsection "Private methods"
These methods are for internal use only.
.IP "\fB_rebuild_lookup\fR" 4
.IX Item "_rebuild_lookup"
Private function used to rebuild the lookup table after modifying the
header block, its easier to do it this way than go through and add one
to the indices of all header cards following the modifed card.
.SH "TIED INTERFACE"
.IX Header "TIED INTERFACE"
The \f(CW\*(C`FITS::Header\*(C'\fR object can also be tied to a hash:
.PP
.Vb 1
\&   use Astro::FITS::Header;
\&
\&   $header = new Astro::FITS::Header( Cards => \e@array );
\&   tie %hash, "Astro::FITS::Header", $header
\&
\&   $value = $hash{$keyword};
\&   $hash{$keyword} = $value;
\&
\&   print "keyword $keyword is present" if exists $hash{$keyword};
\&
\&   foreach my $key (keys %hash) {
\&      print "$key = $hash{$key}\en";
\&   }
.Ve
.SS "Basic hash translation"
.IX Subsection "Basic hash translation"
Header value type is determined on-the-fly by parsing of the input values.
Anything that parses as a number or a logical is converted to that before
being put in a card (but see below).
.PP
Per-card comment fields can be accessed using the tied interface by specifying
a key name of \*(L"key_COMMENT\*(R". This works because in general \*(L"_COMMENT\*(R" is too
long to be confused with a normal key name.
.PP
.Vb 1
\&  $comment = $hdr{CRPIX1_COMMENT};
.Ve
.PP
will return the comment associated with \s-1CRPIX1\s0 header item. The comment
can be modified in the same way:
.PP
.Vb 1
\&  $hdr{CRPIX1_COMMENT} = "An axis";
.Ve
.PP
You can also modify the comment by slash-delimiting it when setting the
associated keyword:
.PP
.Vb 1
\&  $hdr{CRPIX1} = "34 / Set this field manually";
.Ve
.PP
If you want an actual slash character in your string field you must escape
it with a backslash.  (If you're in double quotes you have to use a double
backslash):
.PP
.Vb 1
\&  $hdr{SLASHSTR} = \*(Aqfoo\e/bar / field contains "foo/bar"\*(Aq;
.Ve
.PP
Keywords are CaSE-inNSEnSiTIvE, unlike normal hash keywords.  All
keywords are translated to upper case internally, per the \s-1FITS\s0 standard.
.PP
Aside from the \s-1SIMPLE\s0 and \s-1END\s0 keywords, which are automagically placed at
the beginning and end of the header respectively, keywords are included
in the header in the order received.  This gives you a modicum of control
over card order, but if you actually care what order they're in, you
probably don't want the tied interface.
.SS "Comment cards"
.IX Subsection "Comment cards"
Comment cards are a special case because they have no normal value and
their comment field is treated as the hash value.  The keywords
\&\*(L"\s-1COMMENT\*(R"\s0 and \*(L"\s-1HISTORY\*(R"\s0 are magic and refer to comment cards; nearly all other
keywords create normal valued cards.  (see \*(L"\s-1SIMPLE\s0 and \s-1END\s0 cards\*(R", below).
.SS "Multi-card values"
.IX Subsection "Multi-card values"
Multiline string values are broken up, one card per line in the
string.  Extra-long string values are handled gracefully: they get
split among multiple cards, with a backslash at the end of each card
image.  They're transparently reassembled when you access the data, so
that there is a strong analogy between multiline string values and multiple
cards.
.PP
In general, appending to hash entries that look like strings does what
you think it should.  In particular, comment cards have a newline
appended automatically on \s-1FETCH,\s0 so that
.PP
.Vb 1
\&  $hash{HISTORY} .= "Added multi\-line string support";
.Ve
.PP
adds a new \s-1HISTORY\s0 comment card, while
.PP
.Vb 1
\&  $hash{TELESCOP} .= " dome B";
.Ve
.PP
only modifies an existing \s-1TELESCOP\s0 card.
.PP
You can make multi-line values by feeding in newline-delimited
strings, or by assigning from an array ref.  If you ask for a tag that
has a multiline value it's always expanded to a multiline string, even
if you fed in an array ref to start with.  That's by design: multiline
string expansion often acts as though you are getting just the first
value back out, because perl string-to-number conversion stops at the
first newline.  So:
.PP
.Vb 2
\&  $hash{CDELT1} = [3,4,5];
\&  print $hash{CDELT1} + 99,"\en$hash{CDELT1}";
.Ve
.PP
prints \*(L"102\en3\en4\en5\*(R", and then
.PP
.Vb 2
\&  $hash{CDELT1}++;
\&  print $hash{CDELT1};
.Ve
.PP
prints \*(L"4\*(R".
.PP
In short, most of the time you get what you want.  But you can always fall
back on the non-tied interface by calling methods like so:
.PP
.Vb 1
\&  ((tied $hash)\->method())
.Ve
.PP
If you prefer to have multi-valued items automagically become array
refs, then you can get that behavior using the \f(CW\*(C`tiereturnsref\*(C'\fR method:
.PP
.Vb 1
\&  tie %keywords, "Astro::FITS::Header", $header, tiereturnsref => 1;
.Ve
.PP
When tiereturnsref is true, multi-valued items will be returned via a
reference to an array (ties do not respect calling context). Note that
if this is configured you will have to test each return value to see
whether it is returning a real value or a reference to an array if you
are not sure whether there will be more than one card with a duplicate
name.
.SS "Type forcing"
.IX Subsection "Type forcing"
Because perl uses behind-the-scenes typing, there is an ambiguity
between strings and numeric and/or logical values: sometimes you want
to create a \s-1STRING\s0 card whose value could parse as a number or as a
logical value, and perl kindly parses it into a number for you.  To
force string evaluation, feed in a trivial array ref:
.PP
.Vb 4
\&  $hash{NUMSTR} = 123;     # generates an INT card containing 123.
\&  $hash{NUMSTR} = "123";   # generates an INT card containing 123.
\&  $hash{NUMSTR} = ["123"]; # generates a STRING card containing "123".
\&  $hash{NUMSTR} = [123];   # generates a STRING card containing "123".
\&
\&  $hash{ALPHA} = "T";      # generates a LOGICAL card containing T.
\&  $hash{ALPHA} = ["T"];    # generates a STRING card containing "T".
.Ve
.PP
Calls to \fBkeys()\fR or \fBeach()\fR will, by default, return the keywords in the order
in which they appear in the header.
.SS "Sub-headers"
.IX Subsection "Sub-headers"
When the key refers to a subheader entry (ie an item of type
\&\*(L"\s-1HEADER\*(R"\s0), a hash reference is returned.  If a hash reference is
stored in a value it is converted to a \f(CW\*(C`Astro::FITS::Header\*(C'\fR object.
.PP
If the special key \*(L"\s-1SUBHEADERS\*(R"\s0 is used, it will return the array of
subheaders, (as stored using the \f(CW\*(C`subhdrs\*(C'\fR method) each of which will
be tied to a hash. Subheaders can be stored using normal array operations.
.SS "\s-1SIMPLE\s0 and \s-1END\s0 cards"
.IX Subsection "SIMPLE and END cards"
No \s-1FITS\s0 interface would becomplete without special cases.
.PP
When you assign to \s-1SIMPLE\s0 or \s-1END,\s0 the tied interface ensures that they
are first or last, respectively, in the deck \*(-- as the \s-1FITS\s0 standard
requires.  Other cards are inserted in between the first and last
elements, in the order that you define them.
.PP
The \s-1SIMPLE\s0 card is forced to \s-1FITS LOGICAL\s0 (boolean) type.  The \s-1FITS\s0
standard forbids you from setting it to F, but you can if you want \*(--
we're not the \s-1FITS\s0 police.
.PP
The \s-1END\s0 card is forced to a null type, so any value you assign to it
will fall on the floor.  If present in the deck, the \s-1END\s0 keyword
always contains the value \*(L" \*(R", which is both more-or-less invisible
when printed and also true \*(-- so you can test the return value to see
if an \s-1END\s0 card is present.
.PP
\&\s-1SIMPLE\s0 and \s-1END\s0 come pre-defined from the constructor.  If for some
nefarious reason you want to remove them you must explicitly do so
with \*(L"delete\*(R" or the appropriate method call from the object
interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\f(CW\*(C`Astro::FITS::Header::Item\*(C'\fR, \f(CW\*(C`Starlink::AST\*(C'\fR,
\&\f(CW\*(C`Astro::FITS::Header::CFITSIO\*(C'\fR, \f(CW\*(C`Astro::FITS::Header::Item::NDF\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2007\-2011 Science and Technology Facilties Council.
Copyright (C) 2001\-2007 Particle Physics and Astronomy Research Council
and portions Copyright (C) 2002 Southwest Research Institute.
All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
.PP
This program is distributed in the hope that it will be useful,but \s-1WITHOUT ANY
WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A
PARTICULAR PURPOSE.\s0 See the \s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, \s-1MA\s0  02111\-1307, \s-1USA\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
Alasdair Allan <aa@astro.ex.ac.uk>,
Tim Jenness <t.jenness@jach.hawaii.edu>,
Craig DeForest <deforest@boulder.swri.edu>,
Jim Lewis <jrl@ast.cam.ac.uk>,
Brad Cavanagh <b.cavanagh@jach.hawaii.edu>
