.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Connector::Multi 3"
.TH Connector::Multi 3 "2020-06-26" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Connector::Multi
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements a Connector that is capable of dealing with dynamically
configured Connector implementations and symlinks.
.PP
The underlying concept is that there is a primary (i.e.: boot) configuration
source that Multi accesses for \fBget()\fR requests. If the request returns a reference
to a \s-1SCALAR,\s0 Multi interprets this as a symbolic link. The content of the
link contains an alias and a target key.
.SH "Examples"
.IX Header "Examples"
.SS "Connector References"
.IX Subsection "Connector References"
In this example, we will be using a \s-1YAML\s0 configuration file that is accessed
via the connector Connector::Proxy::YAML.
.PP
From the programmer's view, the configuration should look something like this:
.PP
.Vb 11
\&  smartcards:
\&    tokens:
\&        token_1:
\&            status: ACTIVATED
\&        token_2:
\&            status: DEACTIVATED
\&    owners:
\&        joe:
\&            tokenid: token_1
\&        bob:
\&            tokenid: token_2
.Ve
.PP
In the above example, calling get('smartcards.tokens.token_1.status') returns
the string '\s-1ACTIVATED\s0'.
.PP
To have the data fetched from an \s-1LDAP\s0 server, we can redirect the
\&'smartcards.tokens' key to the \s-1LDAP\s0 connector using '@' to indicate symlinks.
Our primary configuration source for both tokens and owners would contain
the following entries:
.PP
.Vb 3
\&  smartcards:
\&    tokens@: connector:connectors.ldap\-query\-token
\&    owners@: connector:connectors.ldap\-query\-owners
.Ve
.PP
With the symlink now in the key, Multi must walk down each level itself and
handle the symlink. When 'smartcards.tokens' is reached, it reads the contents
of the symlink, which is an alias to a connector 'ldap\-query\-token'. The
connector configuration is in the 'connectors' namespace of our primary data source.
.PP
.Vb 7
\&  connectors:
\&    ldap\-query\-tokens:
\&      class: Connector::Proxy::Net::LDAP
\&      basedn: ou=smartcards,dc=example,dc=org
\&      uri: ldaps://example.org
\&      bind_dn: uid=user,ou=Directory Users,dc=example,dc=org
\&      password: secret
\&
\&  connectors:
\&    ldap\-query\-owners:
\&      class: Connector::Proxy::Net::LDAP
\&      basedn: ou=people,dc=example,dc=org
\&      uri: ldaps://example.org
\&      bind_dn: uid=user,ou=Directory Users,dc=example,dc=org
\&      password: secret
.Ve
.SS "Builtin Environment Connector"
.IX Subsection "Builtin Environment Connector"
Similar to connector you can define a redirect to read a value from the
environment.
.PP
.Vb 2
\&    node1:
\&        key@: env:OPENPKI_KEY_FROM_ENV
.Ve
.PP
calling get('node1.key') will return the value of the environment variable
`OPENPKI_KEY_FROM_ENV`.
.PP
If the environment variable is not set, undef is returned. Walking over such a
node raises a warning but will silently swallow the remaining path components
and return the value of the node.
.SS "Inline Redirects"
.IX Subsection "Inline Redirects"
It is also possible to reference other parts of the configuration using a
kind of redirect/symlink.
.PP
.Vb 3
\&    node1:
\&       node2:
\&          key@: shared.key1
\&
\&    shared:
\&       key1: secret
.Ve
.PP
The '@' sign indicates a symlink similar to the example given above but
there is no additional keyword in front of the value and the remainder of
the line is treated as an absolute path to read the value from.
.PP
If the path value starts with the path separator (default 'dot'), then the
path is treated as a relative link and each dot means \*(L"one level up\*(R".
.PP
.Vb 3
\&    node1:
\&       node2:
\&          key2@: ..node2a.key
\&
\&       node2a:
\&          key1@: .key
\&          key: secret
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The parameter \s-1BASECONNECTOR\s0 may either be a class instance or
the name of the class, in which case the additional arguments
(e.g.: \s-1LOCATION\s0) are passed to the base connector.
.PP
.Vb 2
\&  use Connector::Proxy::Config::Versioned;
\&  use Connector::Multi;
\&
\&  my $base = Connector::Proxy::Config::Versioned\->new({
\&    LOCATION => $path_to_internal_config_git_repo,
\&  });
\&
\&  my $multi = Connector::Multi\->new( {
\&    BASECONNECTOR => $base,
\&  });
\&
\&  my $tok = $multi\->get(\*(Aqsmartcard.owners.bob.tokenid\*(Aq);
.Ve
.PP
or...
.PP
.Vb 1
\&  use Connector::Multi;
\&
\&  my $multi = Connector::Multi\->new( {
\&    BASECONNECTOR => \*(AqConnector::Proxy::Config::Versioned\*(Aq,
\&    LOCATION => $path_to_internal_config_git_repo,
\&  });
\&
\&  my $tok = $multi\->get(\*(Aqsmartcard.owners.bob.tokenid\*(Aq);
.Ve
.PP
You can also pass the path as an arrayref, where each element can be a path itself
.PP
.Vb 1
\&  my $tok = $multi\->get( [ \*(Aqsmartcard.owners\*(Aq, \*(Aqbob.tokenid\*(Aq ]);
.Ve
.PP
*Preset Connector References*
.PP
If you create your config inside your code you and have a baseconnector that
can handle object references (e.g. Connector::Builtin::Memory), you can
directly set the value of a node to a blessed reference of a Connector class.
.PP
.Vb 3
\&    my $sub = Connector::Proxy::Net::LDAP\->new( {
\&        basedn => "ou=smartcards,dc=example,dc=org"
\&    });
\&
\&    $base\->set(\*(Aqsmartcard.tokens\*(Aq,  $sub )
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
When creating a new instance, the \f(CW\*(C`new()\*(C'\fR constructor accepts the
following options:
.IP "\s-1BASECONNECTOR\s0" 8
.IX Item "BASECONNECTOR"
This is a reference to the Connector instance that Connector::Multi
uses at the base of all \fBget()\fR requests.
.IP "\s-1PREFIX\s0" 8
.IX Item "PREFIX"
You can set a \s-1PREFIX\s0 that is prepended to all path. There is one important
caveat to mention: Any redirects made are relative to the prefix set so you can
use \s-1PREFIX\s0 only if the configuration was prepared to work with it (e.g. to split
differnet domains and switch between them using a \s-1PREFIX\s0).
.Sp
.Vb 1
\&    Example:
\&
\&      branch:
\&        foo@: connector:foobar
\&
\&        foobar:
\&          class: ....
.Ve
.Sp
Without a \s-1PREFIX\s0 set, this will return \*(L"undef\*(R" as the connector is not defined
at \*(L"foobar\*(R".
.Sp
.Vb 1
\&    my $bar = $multi\->get( [ \*(Aqbranch\*(Aq, \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
.Ve
.Sp
This will work and return the result from the connector call using \*(L"bar\*(R" as key:
.Sp
.Vb 5
\&    my $multi = Connector::Multi\->new( {
\&      BASECONNECTOR => $base,
\&      PREFIX => "branch",
\&    });
\&    my $bar = $multi\->get( [ \*(Aqbranch\*(Aq, \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq ]);
.Ve
.Sp
Note: It is \fB\s-1DANGEROUS\s0\fR to use a dynamic \s-1PREFIX\s0 in the \s-1BASECONNECTOR\s0 as
Connector::Multi stores created sub-connectors in a cache using the path as key.
It is possible to change the prefix of the class itself during runtime.
.SH "Supported methods"
.IX Header "Supported methods"
.SS "get, get_list, get_size, get_hash, get_keys, set, get_meta Those are routed to the appropriate connector."
.IX Subsection "get, get_list, get_size, get_hash, get_keys, set, get_meta Those are routed to the appropriate connector."
.SS "get_connector Return the instance of the connector at this node"
.IX Subsection "get_connector Return the instance of the connector at this node"
.SS "get_wrapper Return a wrapper around this node. This is like setting a prefix for all subsequent queries."
.IX Subsection "get_wrapper Return a wrapper around this node. This is like setting a prefix for all subsequent queries."
.Vb 2
\&   my $wrapper = $conn\->get_wrapper(\*(Aqtest.node\*(Aq);
\&   $val = $wrapper\->get(\*(Aqfoo\*(Aq);
.Ve
.PP
Is the same as
    \f(CW$val\fR = \f(CW$conn\fR\->get_wrapper('test.node.foo');
