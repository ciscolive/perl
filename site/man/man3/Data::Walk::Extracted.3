.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Walk::Extracted 3"
.TH Data::Walk::Extracted 3 "2016-08-16" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Walk::Extracted \- An extracted dataref walker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is a contrived example!  For a more functional (complex/useful) example see the
roles in this package.
.PP
.Vb 12
\&        package Data::Walk::MyRole;
\&        use Moose::Role;
\&        requires \*(Aq_process_the_data\*(Aq;
\&        use MooseX::Types::Moose qw(
\&                        Str
\&                        ArrayRef
\&                        HashRef
\&                );
\&        my $mangle_keys = {
\&                Hello_ref => \*(Aqprimary_ref\*(Aq,
\&                World_ref => \*(Aqsecondary_ref\*(Aq,
\&        };
\&
\&        #########1 Public Method      3#########4#########5#########6#########7#########8
\&
\&        sub mangle_data{
\&                my ( $self, $passed_ref ) = @_;
\&                @$passed_ref{ \*(Aqbefore_method\*(Aq, \*(Aqafter_method\*(Aq } =
\&                        ( \*(Aq_mangle_data_before_method\*(Aq, \*(Aq_mangle_data_after_method\*(Aq );
\&                ### Start recursive parsing
\&                $passed_ref = $self\->_process_the_data( $passed_ref, $mangle_keys );
\&                ### End recursive parsing with: $passed_ref
\&                return $passed_ref\->{Hello_ref};
\&        }
\&
\&        #########1 Private Methods    3#########4#########5#########6#########7#########8
\&
\&        ### If you are at the string level merge the two references
\&        sub _mangle_data_before_method{
\&                my ( $self, $passed_ref ) = @_;
\&                if(
\&                        is_Str( $passed_ref\->{primary_ref} ) and
\&                        is_Str( $passed_ref\->{secondary_ref} )          ){
\&                        $passed_ref\->{primary_ref} .= " " . $passed_ref\->{secondary_ref};
\&                }
\&                return $passed_ref;
\&        }
\&
\&        ### Strip the reference layers on the way out
\&        sub _mangle_data_after_method{
\&                my ( $self, $passed_ref ) = @_;
\&                if( is_ArrayRef( $passed_ref\->{primary_ref} ) ){
\&                        $passed_ref\->{primary_ref} = $passed_ref\->{primary_ref}\->[0];
\&                }elsif( is_HashRef( $passed_ref\->{primary_ref} ) ){
\&                        $passed_ref\->{primary_ref} = $passed_ref\->{primary_ref}\->{level};
\&                }
\&                return $passed_ref;
\&        }
\&
\&        package main;
\&        use MooseX::ShortCut::BuildInstance qw( build_instance );
\&        my      $AT_ST = build_instance(
\&                        package         => \*(AqGreeting\*(Aq,
\&                        superclasses    => [ \*(AqData::Walk::Extracted\*(Aq ],
\&                        roles           => [ \*(AqData::Walk::MyRole\*(Aq ],
\&                );
\&        print $AT_ST\->mangle_data( {
\&                        Hello_ref =>{ level =>[ { level =>[ \*(AqHello\*(Aq ] } ] },
\&                        World_ref =>{ level =>[ { level =>[ \*(AqWorld\*(Aq ] } ] },
\&                } ) . "\en";
\&
\&
\&
\&        #################################################################################
\&        #     Output of SYNOPSIS
\&        # 01:Hello World
\&        #################################################################################
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module takes a data reference (or two) and
recursivly <http://en.wikipedia.org/wiki/Recursion_(computer_science)>
travels through it(them).  Where the two references diverge the walker follows the
primary data reference.  At the beginning
and end of each branch or node
in the data the code will attempt to call a method
on the remaining unparsed data.
.SS "Acknowledgement of \s-1MJD\s0"
.IX Subsection "Acknowledgement of MJD"
This is an implementation of the concept of extracted data walking from
Higher-Order-Perl <http://hop.perl.plover.com/book/> Chapter 1 by
Mark Jason Dominus <https://metacpan.org/author/MJD>.  \fIThe book is well worth the
money!\fR  With that said I diverged from \s-1MJD\s0 purity in two ways. This is object oriented
code not functional code. Second, when taking action the code will search for class
methods provided by (your) role rather than acting on passed closures.  There is clearly
some overhead associated with both of these differences.  I made those choices consciously
and if that upsets you do not hassle \s-1MJD\s0!
.SS "What is the unique value of this module?"
.IX Subsection "What is the unique value of this module?"
With the recursive part of data walking extracted the various functionalities desired
when walking the data can be modularized without copying this code.  The Moose
framework also allows diverse and targeted data parsing without dragging along a
kitchen sink <http://en.wiktionary.org/wiki/everything_but_the_kitchen_sink> \s-1API\s0
for every use of this class.
.SS "Extending Data::Walk::Extracted"
.IX Subsection "Extending Data::Walk::Extracted"
\&\fBAll action taken during the data walking must be initiated by implementation of action
methods that do not exist in this class\fR.  It usually also makes sense to build an
initial action method as well.  The initial action method can do any data-preprocessing
that is useful as well as providing the necessary set up for the generic walker.  All
of these elements can be combined with this class using a Moose role
 <https://metacpan.org/module/Moose::Manual::Roles>, by
extending the class <https://metacpan.org/module/Moose::Manual::Classes>, or it can be
joined to the class at run time. See MooseX::ShortCut::BuildInstance
 <https://metacpan.org/module/MooseX::ShortCut::BuildInstance>.  or Moose::Util
 <https://metacpan.org/module/Moose::Util> for more class building information.  See the
parsing flow to understand the details of how the methods are
used.  See methods used to write roles for the available
methods to implement the roles.
.PP
Then, Write some tests for your role! <http://www.perlmonks.org/?node_id=918837>
.SH "Recursive Parsing Flow"
.IX Header "Recursive Parsing Flow"
.SS "Initial data input and scrubbing"
.IX Subsection "Initial data input and scrubbing"
The primary input method added to this class for external use is refered to as
the 'action' method (ex. 'mangle_data').  This action method needs to receive
data and organize it for sending to the start method
 for the generic data walker.
\&\fIRemember if more than one role is added to Data::Walk::Extracted
for a given instance then all methods should be named with consideration for other
(future?) method names.  The '$conversion_ref' allows for muliple uses of the core
data walkers generic functions.  The \f(CI$conversion_ref\fI is not passed deeper into the
recursion flow.\fR
.SS "Assess and implement the before_method"
.IX Subsection "Assess and implement the before_method"
The class next checks for an available 'before_method'.  Using the test;
.PP
.Vb 1
\&        exists $passed_ref\->{before_method};
.Ve
.PP
If the test passes then the next sequence is run.
.PP
.Vb 2
\&        $method = $passed_ref\->{before_method};
\&        $passed_ref = $self\->$method( $passed_ref );
.Ve
.PP
If the \f(CW$passed_ref\fR is modified by the 'before_method' then the recursive parser will
parse the new ref and not the old one.  The before_method can set;
.PP
.Vb 1
\&        $passed_ref\->{skip} = \*(AqYES\*(Aq
.Ve
.PP
Then the flow checks for the need to investigate deeper.
.SS "Test for deeper investigation"
.IX Subsection "Test for deeper investigation"
The code now checks if deeper investigation is required checking both that the 'skip' key
= '\s-1YES\s0' in the \f(CW$passed_ref\fR or if the node is a base ref type.
If either case is true the process jumps to the after method
 otherwise it begins to investigate the next
level.
.SS "Identify node elements"
.IX Subsection "Identify node elements"
If the next level in is not skipped then a list is generated for all paths
in the node. For example a '\s-1HASH\s0' node would generate a list of hash keys for that node.
\&\s-1SCALAR\s0 nodes will generate a list with only one element containing the scalar contents.
\&\s-1UNDEF\s0 nodes will generate an empty list.
.SS "Sort the node as required"
.IX Subsection "Sort the node as required"
If the list should be sorted
then the list is sorted. \fB\s-1ARRAYS\s0 are hard sorted.\fR \fIThis means that the actual items in
the (primary) passed data ref are permanantly sorted.\fR
.SS "Process each element"
.IX Subsection "Process each element"
For each identified element of the node a new \f(CW$data_ref\fR is generated containing data that
represents just that sub element.  The secondary_ref is only constructed if it has a
matching type and element to the primary ref.  Matching for hashrefs is done by key
matching only.  Matching for arrayrefs is done by position exists testing only.  \fINo
position content compare is done!\fR Scalars are matched on content.  The list of items
generated for this element is as follows;
.Sp
.RS 4
\&\fBbefore_method =>\fR \-\->name of before method for this role here<\-\-
.Sp
\&\fBafter_method =>\fR \-\->name of after method for this role here<\-\-
.Sp
\&\fBprimary_ref =>\fR the piece of the primary data ref below this element
.Sp
\&\fBprimary_type =>\fR the lower primary (walker)
ref type
.Sp
\&\fBmatch =>\fR YES|NO (This indicates if the secondary ref meets matching critera)
.Sp
\&\fBskip =>\fR YES|NO Checks the three skip attributes against
the lower primary_ref node.  This can also be set in the 'before_method' upon arrival
at that node.
.Sp
\&\fBsecondary_ref =>\fR if match eq '\s-1YES\s0' then built like the primary ref
.Sp
\&\fBsecondary_type =>\fR if match eq '\s-1YES\s0' then calculated like the primary type
.Sp
\&\fBbranch_ref =>\fR stack trace
.RE
.SS "A position trace is generated"
.IX Subsection "A position trace is generated"
The current node list position is then documented and pushed onto the array at
\&\f(CW$passed_ref\fR\->{branch_ref}.  The array reference stored in branch_ref can be
thought of as the stack trace that documents the node elements directly between the
current position and the initial (or zeroth) level of the parsed primary data_ref.
Past completed branches and future pending branches are not maintained.  Each element
of the branch_ref contains four positions used to describe the node and selections
used to traverse that node level.  The values in each sub position are;
.PP
.Vb 9
\&        [
\&                ref_type, #The node reference type
\&                the list item value or \*(Aq\*(Aq for ARRAYs,
\&                        #key name for hashes, scalar value for scalars
\&                element sequence position (from 0),
\&                        #For hashes this is only relevent if sort_HASH is called
\&                level of the node (from 0),
\&                        \`#The zeroth level is the initial data ref
\&        ]
.Ve
.SS "Going deeper in the data"
.IX Subsection "Going deeper in the data"
The down level ref is then passed as a new data set to be parsed and it starts
at the before_method again.
.SS "Actions on return from recursion"
.IX Subsection "Actions on return from recursion"
When the values are returned from the recursion call the last branch_ref element is
pop <http://perldoc.perl.org/functions/pop.html>ed off and the returned data ref
is used to replace the sub elements of the primary_ref and secondary_ref
associated with that list element in the current level of the \f(CW$passed_ref\fR.  If there are
still pending items in the node element list then the program processes them too
.SS "Assess and implement the after_method"
.IX Subsection "Assess and implement the after_method"
After the node elements have all been processed the class checks for an available
\&'after_method' using the test;
.PP
.Vb 1
\&        exists $passed_ref\->{after_method};
.Ve
.PP
If the test passes then the following sequence is run.
.PP
.Vb 2
\&        $method = $passed_ref\->{after_method};
\&        $passed_ref = $self\->$method( $passed_ref );
.Ve
.PP
If the \f(CW$passed_ref\fR is modified by the 'after_method' then the recursive parser will
parse the new ref and not the old one.
.SS "Go up"
.IX Subsection "Go up"
The updated \f(CW$passed_ref\fR is passed back up to the next level
\&.
.SH "Attributes"
.IX Header "Attributes"
Data passed to \->new when creating an instance.  For modification of these attributes
see Public Methods.  The \->new function will either accept fat
comma lists or a complete hash ref that has the possible attributes as the top keys.
Additionally some attributes that have the following prefixed methods; get_$name, set_$name,
clear_$name, and has_$name can be passed to _process_the_data
 and will be adjusted for just the
run of that method call.  These are called one shot
attributes.  Nested calls to _process_the_data will be tracked and the attribute will
remain in force until the parser returns to the calling 'one shot' level.  Previous
attribute values are restored after the 'one shot' attribute value expires.
.SS "sorted_nodes"
.IX Subsection "sorted_nodes"
.RS 4
\&\fBDefinition:\fR If the primary_type of the \f(CW$element_ref\fR
is a key in this attribute hash ref then the node list is
sorted. If the value of that key is a \s-1CODEREF\s0 then the sort sort
 <http://perldoc.perl.org/functions/sort.html> function will called as follows.
.Sp
.Vb 1
\&        @node_list = sort $coderef @node_list
.Ve
.Sp
\&\fIFor the type '\s-1ARRAY\s0' the node is sorted (permanantly) by the element values.  This
means that if the array contains a list of references it will effectivly sort against
the \s-1ASCII\s0 of the memory pointers.  Additionally the 'secondary_ref' node is not
sorted, so prior alignment may break.  In general \s-1ARRAY\s0 sorts are not recommended.\fR
.Sp
\&\fBDefault\fR {} #Nothing is sorted
.Sp
\&\fBRange\fR This accepts a HashRef.
.Sp
\&\fBExample:\fR
.Sp
.Vb 4
\&        sorted_nodes =>{
\&                ARRAY   => 1,#Will sort the primary_ref only
\&                HASH    => sub{ $b cmp $a }, #reverse sort the keys
\&        }
.Ve
.RE
.SS "skipped_nodes"
.IX Subsection "skipped_nodes"
.RS 4
\&\fBDefinition:\fR If the primary_type of the \f(CW$element_ref\fR
is a key in this attribute hash ref then the 'before_method' and 'after_method' are
run at that node but no parsing is done.
.Sp
\&\fBDefault\fR {} #Nothing is skipped
.Sp
\&\fBRange\fR This accepts a HashRef.
.Sp
\&\fBExample:\fR
.Sp
.Vb 3
\&        sorted_nodes =>{
\&                OBJECT => 1,#skips all object nodes
\&        }
.Ve
.RE
.SS "skip_level"
.IX Subsection "skip_level"
.RS 4
\&\fBDefinition:\fR This attribute is set to skip (or not) node parsing at the set level.
Because the process doesn't start checking until after it enters the data ref
it effectivly ignores a skip_level set to 0 (The base node level).  \fIThe test checks
against the value in last position of the prior trace
array ref + 1\fR.
.Sp
\&\fBDefault\fR undef = Nothing is skipped
.Sp
\&\fBRange\fR This accepts an integer
.RE
.SS "skip_node_tests"
.IX Subsection "skip_node_tests"
.RS 4
\&\fBDefinition:\fR This attribute contains a list of test conditions used to skip
certain targeted nodes.  The test can target an array position, match a hash key, even
restrict the test to only one level.  The test is run against the latest
branch_ref element so it skips the node below the
matching conditions not the node at the matching conditions.  Matching is done with
\&'=~' and so will accept a regex or a string.  The attribute contains an ArrayRef of
ArrayRefs.  Each sub_ref contains the following;
.Sp
.RS 4
\&\fB\f(CB$type\fB\fR \- This is any of the identified
reference node types
.Sp
\&\fB\f(CB$key\fB\fR \- This is either a scalar or regex to use for matching a hash key
.Sp
\&\fB\f(CB$position\fB\fR \- This is used to match an array position.  It can be an integer or '\s-1ANY\s0'
.Sp
\&\fB\f(CB$level\fB\fR \- This restricts the skipping test usage to a specific level only or '\s-1ANY\s0'
.RE
.RE
.RS 4
.Sp
\&\fBExample:\fR
.Sp
.Vb 6
\&        [
\&                [ \*(AqHASH\*(Aq, \*(AqKeyWord\*(Aq, \*(AqANY\*(Aq, \*(AqANY\*(Aq],
\&                # Skip the node below the value of any hash key eq \*(AqKeyword\*(Aq
\&                [ \*(AqARRAY\*(Aq, \*(AqANY\*(Aq, \*(Aq3\*(Aq, \*(Aq4\*(Aq], ],
\&                # Skip the node stored in arrays at position three on level four
\&        ]
.Ve
.Sp
\&\fBRange\fR An infinite number of skip tests added to an array
.Sp
\&\fBDefault\fR [] = no nodes are skipped
.RE
.SS "change_array_size"
.IX Subsection "change_array_size"
.RS 4
\&\fBDefinition:\fR This attribute will not be used by this class directly.  However
the Data::Walk::Prune <https://metacpan.org/module/Data::Walk::Prune#prune_data-args>
role may share it with other roles in the future so it is placed here so there will be
no conflicts.  This is usually used to define whether an array size shinks when an element
is removed.
.Sp
\&\fBDefault\fR 1 (This probably means that the array will shrink when a position is removed)
.Sp
\&\fBRange\fR Boolean values.
.RE
.SS "fixed_primary"
.IX Subsection "fixed_primary"
.RS 4
\&\fBDefinition:\fR This means that no changes made at lower levels will be passed
upwards into the final ref.
.Sp
\&\fBDefault\fR 0 = The primary ref is not fixed (and can be changed) \fI0 \-> effectively
deep clones the portions of the primary ref that are traversed.\fR
.Sp
\&\fBRange\fR Boolean values.
.RE
.SH "Methods"
.IX Header "Methods"
.SS "Methods used to write roles"
.IX Subsection "Methods used to write roles"
These are methods that are not meant to be exposed to the final user of a composed role and
class but are used by the role to excersize the class.
.PP
\fI_process_the_data( \f(CI$passed_ref\fI, \f(CI$conversion_ref\fI )\fR
.IX Subsection "_process_the_data( $passed_ref, $conversion_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is the gate keeper to the recursive parsing of
Data::Walk::Extracted.  This method ensures that the minimum requirements for the recursive
data parser are met.  If needed it will use a conversion ref (also provided by the caller) to
change input hash keys to the generic hash keys used by this class.  This function then
calls the actual recursive function.  For an overview of the recursive steps see the
flow outline.
.Sp
\&\fBAccepts:\fR ( \f(CW$passed_ref\fR, \f(CW$conversion_ref\fR )
.Sp
.RS 4
\&\fB\f(CB$passed_ref\fB\fR this ref contains key value pairs as follows;
.Sp
.RS 4
\&\fBprimary_ref\fR \- a dataref that the walker will walk \- required
.Sp
.RS 4
review the \f(CW$conversion_ref\fR functionality in this function for renaming of this key.
.RE
.RE
.RS 4
.Sp
\&\fBsecondary_ref\fR \- a dataref that is used for comparision while walking. \- optional
.Sp
.RS 4
review the \f(CW$conversion_ref\fR functionality in this function for renaming of this key.
.RE
.RE
.RS 4
.Sp
\&\fBbefore_method\fR \- a method name that will perform some action at the beginning
of each node \- optional
.Sp
\&\fBafter_method\fR \- a method name that will perform some action at the end
of each node \- optional
.Sp
\&\fB[attribute name]\fR \- supported attribute names are
accepted with temporary attribute settings here.  These settings are temporarily set for
a single \*(L"_process_the_data\*(R" call and then the original attribute values are restored.
.RE
.RE
.RS 4
.Sp
\&\fB\f(CB$conversion_ref\fB\fR This allows a public method to accept different key names for the
various keys listed above and then convert them later to the generic terms used by this class.
\&\- optional
.Sp
\&\fBExample\fR
.Sp
.Vb 10
\&        $passed_ref ={
\&                print_ref =>{
\&                        First_key => [
\&                                \*(Aqfirst_value\*(Aq,
\&                                \*(Aqsecond_value\*(Aq
\&                        ],
\&                },
\&                match_ref =>{
\&                        First_key       => \*(Aqsecond_value\*(Aq,
\&                },
\&                before_method   => \*(Aq_print_before_method\*(Aq,
\&                after_method    => \*(Aq_print_after_method\*(Aq,
\&                sorted_nodes    =>{ Array => 1 },#One shot attribute setter
\&        }
\&
\&        $conversion_ref ={
\&                primary_ref     => \*(Aqprint_ref\*(Aq,# generic_name => role_name,
\&                secondary_ref   => \*(Aqmatch_ref\*(Aq,
\&        }
.Ve
.RE
.RE
.RS 4
.Sp
\&\fBReturns:\fR the \f(CW$passed_ref\fR (only) with the key names restored to the ones passed to this
method using the \f(CW$conversion_ref\fR.
.RE
.PP
\fI_build_branch( \f(CI$seed_ref\fI, \f(CI@arg_list\fI )\fR
.IX Subsection "_build_branch( $seed_ref, @arg_list )"
.Sp
.RS 4
\&\fBDefinition:\fR There are times when a role will wish to reconstruct the data branch
that lead from the 'zeroth' node to where the data walker is currently at.  This private
method takes a seed reference and uses data found in the branch ref
 to recursivly append to the front of the seed until a
complete branch to the zeroth node is generated.  \fIThe branch_ref list must be
explicitly passed.\fR
.Sp
\&\fBAccepts:\fR a list of arguments starting with the \f(CW$seed_ref\fR to build from.
The remaining arguments are just the array elements of the 'branch ref'.
.Sp
\&\fBExample:\fR
.Sp
.Vb 4
\&        $ref = $self\->_build_branch(
\&                $seed_ref,
\&                @{ $passed_ref\->{branch_ref}},
\&        );
.Ve
.Sp
\&\fBReturns:\fR a data reference with the current path back to the start pre-pended
to the \f(CW$seed_ref\fR
.RE
.PP
\fI_extracted_ref_type( \f(CI$test_ref\fI )\fR
.IX Subsection "_extracted_ref_type( $test_ref )"
.Sp
.RS 4
\&\fBDefinition:\fR In order to manage data types necessary for this class a data
walker compliant 'Type' tester is provided.  This is necessary to support a few non
perl-standard types not generated in standard perl typing systems.  First, 'undef'
is the \s-1UNDEF\s0 type.  Second, strings and numbers both return as '\s-1SCALAR\s0' (not '' or undef).
\&\fBMuch of the code in this package runs on dispatch tables that are built around these
specific type definitions.\fR
.Sp
\&\fBAccepts:\fR It receives a \f(CW$test_ref\fR that can be undef.
.Sp
\&\fBReturns:\fR a data walker type or it confesses.
.RE
.PP
\fI_get_had_secondary\fR
.IX Subsection "_get_had_secondary"
.Sp
.RS 4
\&\fBDefinition:\fR during the initial processing of data in
_process_the_data the existence
of a passed secondary ref is tested and stored in the attribute '_had_secondary'.  On
occasion a role might need to know if a secondary ref existed at any level if it it is
not represented at the current level.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR True|1 if the secondary ref ever existed
.RE
.PP
\fI_get_current_level\fR
.IX Subsection "_get_current_level"
.Sp
.RS 4
\&\fBDefinition:\fR on occasion you may need for one of the methods to know what
level is currently being parsed.  This will provide that information in integer
format.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR the integer value for the level
.RE
.SS "Public Methods"
.IX Subsection "Public Methods"
\fIadd_sorted_nodes( \s-1NODETYPE\s0 => 1, )\fR
.IX Subsection "add_sorted_nodes( NODETYPE => 1, )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to add nodes to be sorted to the walker by
adjusting the attribute sorted_nodes.
.Sp
\&\fBAccepts:\fR Node key => value pairs where the key is the Node name and the value is
1.  This method can accept multiple key => value pairs.
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIhas_sorted_nodes\fR
.IX Subsection "has_sorted_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method checks if any sorting is turned on in the attribute
sorted_nodes.
.Sp
\&\fBAccepts:\fR Nothing
.Sp
\&\fBReturns:\fR the count of sorted node types listed
.RE
.PP
\fIcheck_sorted_nodes( \s-1NODETYPE\s0 )\fR
.IX Subsection "check_sorted_nodes( NODETYPE )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to see if a node type is sorted by testing the
attribute sorted_nodes.
.Sp
\&\fBAccepts:\fR the name of one node type
.Sp
\&\fBReturns:\fR true if that node is sorted as determined by sorted_nodes
.RE
.PP
\fIclear_sorted_nodes\fR
.IX Subsection "clear_sorted_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method will clear all values in the attribute
sorted_nodes.  \fIand therefore turn off all cleared sorts\fR.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIremove_sorted_node( \s-1NODETYPE1, NODETYPE2,\s0 )\fR
.IX Subsection "remove_sorted_node( NODETYPE1, NODETYPE2, )"
.Sp
.RS 4
\&\fBDefinition:\fR This method will clear the key / value pairs in sorted_nodes
for the listed items.
.Sp
\&\fBAccepts:\fR a list of \s-1NODETYPES\s0 to delete
.Sp
\&\fBReturns:\fR In list context it returns a list of values in the hash for the deleted
keys. In scalar context it returns the value for the last key specified
.RE
.PP
\fIset_sorted_nodes( \f(CI$hashref\fI )\fR
.IX Subsection "set_sorted_nodes( $hashref )"
.Sp
.RS 4
\&\fBDefinition:\fR This method will completely reset the attribute sorted_nodes to
\&\f(CW$hashref\fR.
.Sp
\&\fBAccepts:\fR a hashref of \s-1NODETYPE\s0 keys with the value of 1.
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIget_sorted_nodes\fR
.IX Subsection "get_sorted_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method will return a hashref of the attribute sorted_nodes
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a hashref
.RE
.PP
\fIadd_skipped_nodes( \s-1NODETYPE1\s0 => 1, \s-1NODETYPE2\s0 => 1 )\fR
.IX Subsection "add_skipped_nodes( NODETYPE1 => 1, NODETYPE2 => 1 )"
.Sp
.RS 4
\&\fBDefinition:\fR This method adds additional skip definition(s) to the
skipped_nodes attribute.
.Sp
\&\fBAccepts:\fR a list of key value pairs as used in 'skipped_nodes'
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIhas_skipped_nodes\fR
.IX Subsection "has_skipped_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method checks if any nodes are set to be skipped in the
attribute skipped_nodes.
.Sp
\&\fBAccepts:\fR Nothing
.Sp
\&\fBReturns:\fR the count of skipped node types listed
.RE
.PP
\fIcheck_skipped_node( \f(CI$string\fI )\fR
.IX Subsection "check_skipped_node( $string )"
.Sp
.RS 4
\&\fBDefinition:\fR This method checks if a specific node type is set to be skipped in
the skipped_nodes attribute.
.Sp
\&\fBAccepts:\fR a string
.Sp
\&\fBReturns:\fR Boolean value indicating if the specific \f(CW$string\fR is set
.RE
.PP
\fIremove_skipped_nodes( \s-1NODETYPE1, NODETYPE2\s0 )\fR
.IX Subsection "remove_skipped_nodes( NODETYPE1, NODETYPE2 )"
.Sp
.RS 4
\&\fBDefinition:\fR This method deletes specificily identified node skips from the
skipped_nodes attribute.
.Sp
\&\fBAccepts:\fR a list of \s-1NODETYPES\s0 to delete
.Sp
\&\fBReturns:\fR In list context it returns a list of values in the hash for the deleted
keys. In scalar context it returns the value for the last key specified
.RE
.PP
\fIclear_skipped_nodes\fR
.IX Subsection "clear_skipped_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method clears all data in the skipped_nodes attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIset_skipped_nodes( \f(CI$hashref\fI )\fR
.IX Subsection "set_skipped_nodes( $hashref )"
.Sp
.RS 4
\&\fBDefinition:\fR This method will completely reset the attribute skipped_nodes to
\&\f(CW$hashref\fR.
.Sp
\&\fBAccepts:\fR a hashref of \s-1NODETYPE\s0 keys with the value of 1.
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIget_skipped_nodes\fR
.IX Subsection "get_skipped_nodes"
.Sp
.RS 4
\&\fBDefinition:\fR This method will return a hashref of the attribute skipped_nodes
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR a hashref
.RE
.PP
\fIset_skip_level( \f(CI$int\fI )\fR
.IX Subsection "set_skip_level( $int )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to reset the skip_level
attribute after the instance is created.
.Sp
\&\fBAccepts:\fR an integer (negative numbers and 0 will be ignored)
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fI\f(BIget_skip_level()\fI\fR
.IX Subsection "get_skip_level()"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the current skip_level
attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an integer
.RE
.PP
\fI\f(BIhas_skip_level()\fI\fR
.IX Subsection "has_skip_level()"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to test if the skip_level attribute is set.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$Bool\fR value indicating if the 'skip_level' attribute has been set
.RE
.PP
\fI\f(BIclear_skip_level()\fI\fR
.IX Subsection "clear_skip_level()"
.Sp
.RS 4
\&\fBDefinition:\fR This method clears the skip_level attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing (always successful)
.RE
.PP
\fIset_skip_node_tests( ArrayRef[ArrayRef] )\fR
.IX Subsection "set_skip_node_tests( ArrayRef[ArrayRef] )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to change (completly) the 'skip_node_tests'
attribute after the instance is created.  See skip_node_tests for an example.
.Sp
\&\fBAccepts:\fR an array ref of array refs
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fI\f(BIget_skip_node_tests()\fI\fR
.IX Subsection "get_skip_node_tests()"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the current master list from the
skip_node_tests attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR an array ref of array refs
.RE
.PP
\fI\f(BIhas_skip_node_tests()\fI\fR
.IX Subsection "has_skip_node_tests()"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to test if the skip_node_tests attribute
is set.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR The number of sub array refs there are in the list
.RE
.PP
\fI\f(BIclear_skip_node_tests()\fI\fR
.IX Subsection "clear_skip_node_tests()"
.Sp
.RS 4
\&\fBDefinition:\fR This method clears the skip_node_tests attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing (always successful)
.RE
.PP
\fIadd_skip_node_tests( ArrayRef1, ArrayRef2 )\fR
.IX Subsection "add_skip_node_tests( ArrayRef1, ArrayRef2 )"
.Sp
.RS 4
\&\fBDefinition:\fR This method adds additional skip_node_test definition(s) to the the
skip_node_tests attribute list.
.Sp
\&\fBAccepts:\fR a list of array refs as used in 'skip_node_tests'.  These are 'pushed
onto the existing list.
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIset_change_array_size( \f(CI$bool\fI )\fR
.IX Subsection "set_change_array_size( $bool )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to (re)set the change_array_size attribute
after the instance is created.
.Sp
\&\fBAccepts:\fR a Boolean value
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fI\f(BIget_change_array_size()\fI\fR
.IX Subsection "get_change_array_size()"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the current state of the change_array_size
attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$Bool\fR value representing the state of the 'change_array_size'
attribute
.RE
.PP
\fI\f(BIhas_change_array_size()\fI\fR
.IX Subsection "has_change_array_size()"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to test if the change_array_size
attribute is set.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$Bool\fR value indicating if the 'change_array_size' attribute
has been set
.RE
.PP
\fI\f(BIclear_change_array_size()\fI\fR
.IX Subsection "clear_change_array_size()"
.Sp
.RS 4
\&\fBDefinition:\fR This method clears the change_array_size attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fIset_fixed_primary( \f(CI$bool\fI )\fR
.IX Subsection "set_fixed_primary( $bool )"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to change the fixed_primary attribute
after the instance is created.
.Sp
\&\fBAccepts:\fR a Boolean value
.Sp
\&\fBReturns:\fR nothing
.RE
.PP
\fI\f(BIget_fixed_primary()\fI\fR
.IX Subsection "get_fixed_primary()"
.Sp
.RS 4
\&\fBDefinition:\fR This method returns the current state of the fixed_primary
attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$Bool\fR value representing the state of the 'fixed_primary' attribute
.RE
.PP
\fI\f(BIhas_fixed_primary()\fI\fR
.IX Subsection "has_fixed_primary()"
.Sp
.RS 4
\&\fBDefinition:\fR This method is used to test if the fixed_primary attribute is set.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR \f(CW$Bool\fR value indicating if the 'fixed_primary' attribute has been set
.RE
.PP
\fI\f(BIclear_fixed_primary()\fI\fR
.IX Subsection "clear_fixed_primary()"
.Sp
.RS 4
\&\fBDefinition:\fR This method clears the fixed_primary attribute.
.Sp
\&\fBAccepts:\fR nothing
.Sp
\&\fBReturns:\fR nothing
.RE
.SH "Definitions"
.IX Header "Definitions"
.SS "node"
.IX Subsection "node"
Each branch point of a data reference is considered a node.  The possible paths
deeper into the data structure from the node are followed 'vertically first' in
recursive parsing.  The original top level reference is considered the 'zeroth'
node.
.SS "base node type"
.IX Subsection "base node type"
Recursion 'base' node types are considered
to not have any possible deeper branches.  Currently that list is \s-1SCALAR\s0 and \s-1UNDEF.\s0
.SS "Supported node walking types"
.IX Subsection "Supported node walking types"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.PD 0
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
.IP "\s-1UNDEF\s0" 4
.IX Item "UNDEF"
.PD
\&\fIOther node support\fR
.Sp
Support for Objects is partially implemented and as a consequence '_process_the_data'
won't immediatly die when asked to parse an object.  It will still die but on a
dispatch table call that indicates where there is missing object support, not at the
top of the node.  This allows for some of the skip attributes to
use '\s-1OBJECT\s0' in their definitions.
.SS "Supported one shot attributes"
.IX Subsection "Supported one shot attributes"
explanation
.IP "sorted_nodes" 4
.IX Item "sorted_nodes"
.PD 0
.IP "skipped_nodes" 4
.IX Item "skipped_nodes"
.IP "skip_level" 4
.IX Item "skip_level"
.IP "skip_node_tests" 4
.IX Item "skip_node_tests"
.IP "change_array_size" 4
.IX Item "change_array_size"
.IP "fixed_primary" 4
.IX Item "fixed_primary"
.PD
.SS "Dispatch Tables"
.IX Subsection "Dispatch Tables"
This class uses the role Data::Walk::Extracted::Dispatch
 <https://metacpan.org/module/Data::Walk::Extracted::Dispatch> to implement dispatch
tables.  When there is a decision point, that role is used to make the class
extensible.
.SH "Caveat utilitor"
.IX Header "Caveat utilitor"
This is not an extention of Data::Walk <https://metacpan.org/module/Data::Walk>
.PP
The core class has no external effect.  All output comes from
additions to the class.
.PP
This module uses the 'defined or <http://perldoc.perl.org/perlop.html#Logical-Defined-Or>'
(  //= ) and so requires perl 5.010 or higher.
.PP
This is a Moose <https://metacpan.org/module/Moose::Manual> based data handling class.
Many coders will tell you Moose and data manipulation don't belong together.  They are
most certainly right in speed intensive circumstances.
.PP
Recursive parsing is not a good fit for all data since very deep data structures will
fill up a fair amount of memory!  Meaning that as the module recursively parses through
the levels it leaves behind snapshots of the previous level that allow it to keep
track of it's location.
.PP
The passed data references are effectivly deep cloned during this process.  To leave
the primary_ref pointer intact see fixed_primary
.SH "Build/Install from Source"
.IX Header "Build/Install from Source"
\&\fB1.\fR Download a compressed file with the code
.PP
\&\fB2.\fR Extract the code from the compressed file.  If you are using tar this should work:
.PP
.Vb 1
\&        tar \-zxvf Data\-Walk\-Extracted\-v0.xx.xx.tar.gz
.Ve
.PP
\&\fB3.\fR Change (cd) into the extracted directory
.PP
\&\fB4.\fR Run the following commands
.Sp
.RS 4
(For Windows find what version of make was used to compile your perl)
.Sp
.Vb 1
\&        perl  \-V:make
.Ve
.Sp
(then for Windows substitute the correct make function (ex. s/make/dmake/g))
.RE
.PP
.Vb 1
\&        >perl Makefile.PL
\&
\&        >make
\&
\&        >make test
\&
\&        >make install # As sudo/root
\&
\&        >make clean
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.RS 4
github Data\-Walk\-Extracted/issues <https://github.com/jandrew/Data-Walk-Extracted/issues>
.RE
.SH "TODO"
.IX Header "TODO"
.RS 4
\&\fB1.\fR provide full recursion through Objects
.Sp
\&\fB2.\fR Support recursion through CodeRefs (Closures)
.Sp
\&\fB3.\fR Add a Data::Walk::Diff Role to the package
.Sp
\&\fB4.\fR Add a Data::Walk::Top Role to the package
.Sp
\&\fB5.\fR Add a Data::Walk::Thin Role to the package
.Sp
\&\fB6.\fR Convert test suite to Test2 direct usage
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Jed Lund" 4
.IX Item "Jed Lund"
.PD 0
.IP "jandrew@cpan.org" 4
.IX Item "jandrew@cpan.org"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.PP
This software is copyrighted (c) 2012, 2016 by Jed Lund.
.SH "Dependencies"
.IX Header "Dependencies"
.RS 4
version
.Sp
5.010 <http://perldoc.perl.org/perl5100delta.html> (for use of
defined or <http://perldoc.perl.org/perlop.html#Logical-Defined-Or> //)
.Sp
utf8
.Sp
Class::Inspector
.Sp
Scalar::Util
.Sp
Carp \- confess
.Sp
Moose \- 2.1803
.Sp
MooseX::StrictConstructor
.Sp
MooseX::HasDefaults::RO
.Sp
MooseX::Types::Moose
.Sp
Class::Inspector
.Sp
Scalar::Util \- reftype
.Sp
MooseX::Types::Moose
.Sp
Data::Walk::Extracted::Types
.Sp
Data::Walk::Extracted::Dispatch
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.RS 4
Log::Shiras::Unhide \- Can use to unhide '###InternalExtracteD' tags
.Sp
Log::Shiras::TapWarn \- to manage the output of exposed '###InternalExtracteD' lines
.Sp
Data::Walk
.Sp
Data::Walker
.Sp
Data::Dumper \- Dumper
.Sp
\&\s-1YAML\s0 \- Dump
.Sp
Data::Walk::Print \- available Data::Walk::Extracted Role
.Sp
Data::Walk::Prune \- available Data::Walk::Extracted Role
.Sp
Data::Walk::Graft \- available Data::Walk::Extracted Role
.Sp
Data::Walk::Clone \- available Data::Walk::Extracted Role
.RE
