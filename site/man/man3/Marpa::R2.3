.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2 3"
.TH Marpa::R2 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2 \- Release 2 of Marpa
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&    use Marpa::R2;
\&
\&    my $dsl = <<\*(AqEND_OF_DSL\*(Aq;
\&    :default ::= action => [name,values]
\&    lexeme default = latm => 1
\&
\&    Calculator ::= Expression action => ::first
\&
\&    Factor ::= Number action => ::first
\&    Term ::=
\&        Term \*(Aq*\*(Aq Factor action => do_multiply
\&        | Factor action => ::first
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
\&    Number ~ digits
\&    digits ~ [\ed]+
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    END_OF_DSL
\&
\&    my $grammar = Marpa::R2::Scanless::G\->new( { source => \e$dsl } );
\&    my $input = \*(Aq42 * 1 + 7\*(Aq;
\&    my $value_ref = $grammar\->parse( \e$input, \*(AqMy_Actions\*(Aq );
\&
\&    sub My_Actions::do_add {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 + $t2;
\&    }
\&
\&    sub My_Actions::do_multiply {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 * $t2;
\&    }
.Ve
.SH "Updates"
.IX Header "Updates"
Users should consult Marpa::R2's \*(L"updates\*(R" page,
which contains notes, errata, etc.,
added since the most recent release.
The \*(L"updates\*(R" page is \f(CW\*(C`UPDATES.md\*(C'\fR in the
current repo.
At this point, the link is
<https://github.com/jeffreykegler/Marpa\-\-R2/blob/master/UPDATES.md>.
.SH "Description"
.IX Header "Description"
.SS "Overview"
.IX Subsection "Overview"
Marpa parses any language whose
grammar can be written in \s-1BNF.\s0
That includes recursive grammars,
ambiguous grammars, infinitely ambiguous grammars and
grammars with useless or empty productions.
Marpa does both left\- and right-recursion in linear time \*(--
in fact if a grammar is in any class currently
in practical use, Marpa will parse it in linear time.
.PP
This document centers around a short tutorial
of the Scanless interface (\s-1SLIF\s0).
This is the interface most suitable for beginners.
The \s-1SLIF\s0 is the most suitable interface for most advanced uses as well.
.SH "A simple calculator"
.IX Header "A simple calculator"
The synopsis shows the code for an extremely simple calculator.
It handles only
addition and multiplication of integers.
The sections which follow explain, line by line, how it works.
The explanation will assume that the reader
understands \s-1BNF\s0 and the basics of grammars \*(-- what rules are,
what symbols are, what the start symbol of a grammar is, etc.
.SS "Marpa::R2::Scanless::G::new"
.IX Subsection "Marpa::R2::Scanless::G::new"
.Vb 3
\&    my $dsl = <<\*(AqEND_OF_DSL\*(Aq;
\&    :default ::= action => [name,values]
\&    lexeme default = latm => 1
\&    
\&    Calculator ::= Expression action => ::first
\&
\&    Factor ::= Number action => ::first
\&    Term ::=
\&        Term \*(Aq*\*(Aq Factor action => do_multiply
\&        | Factor action => ::first
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
\&    Number ~ digits
\&    digits ~ [\ed]+
\&    :discard ~ whitespace
\&    whitespace ~ [\es]+
\&    END_OF_DSL
\&
\&    my $grammar = Marpa::R2::Scanless::G\->new( { source => \e$dsl } );
.Ve
.PP
The code first creates a new \s-1SLIF\s0 grammar.
\&\s-1SLIF\s0 grammars are
\&\f(CW\*(C`Marpa::R2::Scanless:G\*(C'\fR objects.
They are created
with the
Marpa::R2::Scanless:G::new
constructor.
The arguments to
Marpa::R2::Scanless::G::new
are references to
hashes of named arguments.
In the key/value pairs of these hashes,
the
hash key
is the
name of the argument,
and the
hash value
is the
value of the named argument.
.PP
In the example, there is only one named argument to the \s-1SLIF\s0 grammar constructor:
\&\f(CW\*(C`source\*(C'\fR.
The value of \f(CW\*(C`source\*(C'\fR must be a reference to a string in the
\&\s-1SLIF\s0's domain-specific language
(\s-1DSL\s0).
In this example, the \s-1DSL\s0 consists of several rules
and pseudo-rules.
.SS "The default pseudo-rule"
.IX Subsection "The default pseudo-rule"
.Vb 2
\&    :default ::= action => [name,values]
\&    lexeme default = latm => 1
.Ve
.PP
These two lines set useful defaults.
The first sets a default semantics,
one which is especially useful for development.
This is a finished script, so the default semantics
is not used much.
We'll talk about this more when we discuss
semantics at the end.
.PP
The second line sets the longest acceptable tokens match (\s-1LATM\s0)
style of lexing,
which is what you'll almost always want.
It is not the default for historical reasons, so your scripts will
almost always start with this line.
.SS "A G1 rule"
.IX Subsection "A G1 rule"
Next follows a G1, or structural rule.
The first G1 rule in a script
will usually be the start rule of the
grammar.
(It is also possible to
specify the start rule
explicitly.)
.PP
Structural rules are the kinds of rules typically seen in \s-1BNF\s0 \*(--
they describe the symbols which provide the structure of the grammar,
but leave out details of whitespace.
The \s-1SLIF\s0 also handles the lexical details in this example.
It does this via L0 rules,
which we will see shortly.
.PP
.Vb 1
\&    Calculator ::= Expression action => ::first
.Ve
.PP
As is normal for \s-1BNF\s0 rules, the first rule consists of 
a left hand side symbol ("\f(CW\*(C`Calculator\*(C'\fR\*(L"),
the \s-1BNF\s0 operator (\*(R"\f(CW\*(C`::=\*(C'\fR\*(L")
and a series of right hand side (\s-1RHS\s0) symbols.
There is always exactly one left hand side (\s-1LHS\s0)
symbol.
There may be any number of \s-1RHS\s0 symbols.
In the case of an empty rule,
the number of \s-1RHS\s0 symbols would be zero.
In this rule, there is one \s-1RHS\s0
symbol, \*(R"\f(CW\*(C`Expression\*(C'\fR".
.PP
The \s-1BNF\s0 operator ("\f(CW\*(C`::=\*(C'\fR\*(L") is what makes this rule
a G1 (structural) rule.
Later we will see lexical rules, which will use
the match operator (\*(R"\f(CW\*(C`~\*(C'\fR").
.PP
After the rule is an adverb:
\&\f(CW\*(C`action => ::first\*(C'\fR.
We'll explain the purpose of the \f(CW\*(C`action\*(C'\fR
adverbs when we discuss
semantics
.PP
The second rule is very similar to the first:
.PP
.Vb 1
\&    Factor ::= Number action => ::first
.Ve
.SS "More complicated G1 rules"
.IX Subsection "More complicated G1 rules"
.Vb 3
\&    Term ::=
\&        Term \*(Aq*\*(Aq Factor action => do_multiply
\&        | Factor action => ::first
.Ve
.PP
This rule says that an \f(CW\*(C`Term\*(C'\fR may be one of two
alternatives:
.IP "\(bu" 4
A \f(CW\*(C`Term\*(C'\fR and a \f(CW\*(C`Factor\*(C'\fR separated by an multiplication operator; or
.IP "\(bu" 4
a \f(CW\*(C`Factor\*(C'\fR.
.PP
Immediately following is another G1 rule defining
a \f(CW\*(C`Term\*(C'\fR.  It is very similar in form
to the one for \f(CW\*(C`Expression\*(C'\fR.
.PP
.Vb 3
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
.Ve
.SS "L0 rules"
.IX Subsection "L0 rules"
The structural rules define the high-level structure of the grammar,
and ignore details of whitespace, comments, etc.
Now we look at how the low-level, lexical issues are handled.
This very simple calculator language does not allow comments,
but it does define whitespace.
.PP
.Vb 2
\&          :discard ~ whitespace
\&          whitespace ~ [\es]+
.Ve
.PP
The \f(CW\*(C`:discard\*(C'\fR rule is a pseudo-rule, which tells Marpa to use whatever
it matches to separate G1 symbols,
but otherwise to ignore it \*(-- to \*(L"discard\*(R" it.
\&\f(CW\*(C`whitespace\*(C'\fR is defined in the next rule as a sequence of one or more spaces.
.PP
Note the match operator ("\f(CW\*(C`~\*(C'\fR") in the rule defining whitespace.
It tells Marpa that this rule is lexical and
should be interpreted exactly as written, character
by character.
.PP
The \f(CW\*(C`whitespace\*(C'\fR rule is a special kind of rule in two respects.
First, its \s-1RHS\s0 is followed by a quantifier ("\f(CW\*(C`+\*(C'\fR\*(L"), which makes it
a sequence rule.
Aside from the quantifier,
sequence rules may only have a single symbol or character class on their \s-1RHS.\s0
The plus quantifier (\*(R"\f(CW\*(C`+\*(C'\fR\*(L") means a sequence of one or more items.
The star quantifier (\*(R"\f(CW\*(C`*\*(C'\fR") is also allowed, and it indicates a sequence of
zero or more items.
.PP
The whitespace items are defined by a character class: \f(CW\*(C`[\es]\*(C'\fR.
Marpa supports the same character classes, and the same character class syntax,
as Perl does.
.PP
The next pair of L0 rules define the \f(CW\*(C`Number\*(C'\fR symbol
.PP
.Vb 2
\&          Number ~ digits
\&          digits ~ [\ed]+
.Ve
.PP
The above two rules say that a \f(CW\*(C`Number\*(C'\fR is a sequence of one or more digits.
\&\f(CW\*(C`Number\*(C'\fR is a lexeme \*(-- a G1 symbol which is defined and recognized at the lexical
(L0) level.
In this example, there are three other lexemes:
\&\f(CW\*(C`whitespace\*(C'\fR, and the addition and multiplication operators.
.PP
We've already looked at
the \f(CW\*(C`whitespace\*(C'\fR lexeme, which will be discarded without being seen by G1.
The addition and multiplication operators were defined with single quoted strings
in the G1 rules.  As a reminder, here's the rule for \f(CW\*(C`Term\*(C'\fR again:
.PP
.Vb 3
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
.Ve
.PP
In the above rule, the single-quoted string \f(CW\*(Aq+\*(Aq\fR implicitly defines a L0 lexeme.
Something similar happens with the \f(CW\*(Aq*\*(Aq\fR string in the rule for a \f(CW\*(C`Term\*(C'\fR.
.PP
The \s-1SLIF\s0's lexer mostly \*(L"does what you mean\*(R".
While the input is being read, it looks for all lexemes defined in the \s-1DSL.\s0
Almost always, you'll want Marpa to look only for tokens that are
actually acceptable to the parse.
Telling Marpa to do so was the purpose of this line:
.PP
.Vb 1
\&    lexeme default = latm => 1
.Ve
.PP
\&\s-1LATM\s0 means \*(L"longest acceptable tokens match\*(R".
(\s-1LATM\s0 is not the default for historical reasons.)
.PP
Among the acceptable tokens,
Marpa looks for longest matches \*(-- if multiple tokens match,
the longest match is the winner.
Marpa tolerates ambiguity,
so one feature special to Marpa is that \s-1LATM\s0 is a longest acceptable \fBtokens\fR match \*(--
if more than one token is longest, all of them are considered in the parse.
The logic of \s-1SLIF\s0 lexing is described with more precision in the
\&\s-1SLIF\s0 overview document.
.SS "Marpa::R2::Scanless::G::parse"
.IX Subsection "Marpa::R2::Scanless::G::parse"
.Vb 2
\&    my $input = \*(Aq42 * 1 + 7\*(Aq;
\&    my $value_ref = $grammar\->parse( \e$input, \*(AqMy_Actions\*(Aq );
.Ve
.PP
To parse a string,
we use 
the \f(CW\*(C`Marpa::R2::Scanless::G::parse()\*(C'\fR method.
\&\f(CW\*(C`Marpa::R2::Scanless::G::parse()\*(C'\fR requires a reference
to a string as its first argument.
Optionally, the second argument is
another string specifying the \*(L"semantics package\*(R".
The "\f(CW\*(C`semantics_package\*(C'\fR"
tells Marpa the name of the Perl package that contains
the closures implementing the semantics for this grammar.
We will talk more about this below.
.SS "Semantics"
.IX Subsection "Semantics"
The value of the parse result, as returned via the \f(CW\*(C`parse()\*(C'\fR method,
is determined by the parse's \fBsemantics\fR.
Marpa's semantics are the traditional ones:
The input is seen as a tree which takes its structure from the G1 rules.
(This is why the G1 rules are called structural.)
The value of the parse results from repeatedly evaluating nodes of this
tree, starting at the bottom, with the results of child nodes made available
to their parent node when the parent node is evaluated.
.PP
Parse trees are usually drawn upside-down
with their root at the top,
and their \*(L"leaves\*(R" at the bottom.
In Marpa::R2's \s-1SLIF,\s0 the \*(L"leaves\*(R" are the symbols
that the G1 (structural) rules share with the L0 (lexical)
rules.
The symbols shared by L0 and G1
are those lexemes which are not
discarded.
In this example, the lexemes visible to G1 are
\&\f(CW\*(C`Number\*(C'\fR and two operators
which are specified
with a quoted string:
"\f(CW\*(C`+\*(C'\fR\*(L"
and
\&\*(R"\f(CW\*(C`*\*(C'\fR".
.PP
Marpa assigns values to the nodes of the tree,
starting with the leaves.
Marpa's \*(L"leaves\*(R" will always be L0 symbols,
and their value by default is the literal
value at their location in the input stream.
In the case of the two operators described
by quoted string,
the value is that quoted string.
That is, the value of '\f(CW\*(C`+\*(C'\fR' is
\&'\f(CW\*(C`+\*(C'\fR',
and the value of '\f(CW\*(C`*\*(C'\fR' is
\&'\f(CW\*(C`*\*(C'\fR'.
The value of \f(CW\*(C`Number\*(C'\fR will be the portion
of the input that matched the \f(CW\*(C`[\ed]+\*(C'\fR
pattern.
.PP
Starting with the values for leaves,
Marpa::R2 moves recursively
\&\*(L"up\*(R" the tree to its root,
assigning a value to each node of the tree
based on the value of its child nodes.
Each non-leaf node corresponds to a G1 rule,
and the children of the non-leaf node
correspond to the \s-1RHS\s0 symbols
of the rule.
When the non-leaf node is valued, its value becomes
the value of its \s-1LHS\s0 symbol,
and this value will become
the value of
a \s-1RHS\s0 symbol of another node with one
exception.
.PP
The one exception, the node with a \s-1LHS\s0 symbol
that does not become a \s-1RHS\s0
symbol,
is the value of the top (or \*(L"root\*(R") node.
The value of the top node becomes the
value of the parse,
and this is the parse result value
to which the \f(CW\*(C`value()\*(C'\fR method
returns a reference.
.PP
.Vb 1
\&    :default ::= action => [name,values]
.Ve
.PP
Each non-leaf node determines its value with an action.
The default pseudo-rule allows you to specify the default action.
(It is a pseudo-rule because its \s-1LHS, "\s0\f(CW\*(C`:default\*(C'\fR", is a pseudo-symbol,
not a real one.)
Often actions are Perl functions, which in this context are
called Perl semantic closures.
.PP
.Vb 1
\&    my $value_ref = $grammar\->parse( \e$input, \*(AqMy_Actions\*(Aq );
.Ve
.PP
When we did the parse,
we used the \f(CW\*(C`semantics_package\*(C'\fR named argument.
The value of the \f(CW\*(C`semantics_package\*(C'\fR argument
specifies the package that is used
to find the Perl semantic closures.
.PP
In this example the default semantics,
as specified by the \f(CW\*(C`default_action\*(C'\fR named argument,
come from a \*(L"array descriptor\*(R" named "\f(CW\*(C`[name,values]\*(C'\fR".
This indicates that, by default, the value of a rule is to be
a reference to an array consisting of the rule's name,
followed by the values of its children.
.PP
In this case,
the semantics is not actually used,
and you would usually change it to something more convenient
for your application.
But "\f(CW\*(C`[name,values]\*(C'\fR" is an excellent starting point when you're
first developing a \s-1DSL\s0 and, since this code is intended as a
template, we've kept it.
For more about array descriptors, see the semantics
document
.PP
The other way we specify semantics in this example
is by using an
\&\f(CW\*(C`action\*(C'\fR adverb
for a \s-1RHS\s0 alternative.
We've seen the \f(CW\*(C`action\*(C'\fR adverb several times,
but skipped over it.
Now it is time to look at it.
.PP
.Vb 6
\&    Term ::=
\&        Term \*(Aq*\*(Aq Factor action => do_multiply
\&        | Factor action => ::first
\&    Expression ::=
\&        Expression \*(Aq+\*(Aq Term action => do_add
\&        | Term action => ::first
.Ve
.PP
The "\f(CW\*(C`::first\*(C'\fR" action indicates that the value of a rule is to be
the value of its first child,
that is, the value corresponding to the first symbol of the rule's \s-1RHS.\s0
(In the case of an empty rule, the value would be a Perl \f(CW\*(C`undef\*(C'\fR).
(The initial double colon indicates a reserved action.)
.PP
The action for the first \s-1RHS\s0 alternative defining \f(CW\*(C`Expression\*(C'\fR is \f(CW\*(C`do_add\*(C'\fR,
and the action for the first \s-1RHS\s0 alternative defining \f(CW\*(C`Term\*(C'\fR is \f(CW\*(C`do_multiply\*(C'\fR.
To implement these actions, we need to \*(L"resolve\*(R" their names \*(--
map the action names into 
the Perl closures which actually carry out the semantics.
.PP
The \f(CW\*(C`semantics_package\*(C'\fR specified the package where we can find the actions:
"\f(CW\*(C`My_Actions\*(C'\fR".
So, to resolve the \f(CW\*(C`do_multiply\*(C'\fR action,
Marpa looks for a closure whose fully qualified name is \f(CW\*(C`My_Actions::do_multiply\*(C'\fR,
which it finds:
.PP
.Vb 4
\&    sub My_Actions::do_multiply {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 * $t2;
\&    }
.Ve
.PP
The \f(CW\*(C`do_add\*(C'\fR action is resolved
to a Perl semantic closure
in much the same way:
.PP
.Vb 4
\&    sub My_Actions::do_add {
\&        my ( undef, $t1, undef, $t2 ) = @_;
\&        return $t1 + $t2;
\&    }
.Ve
.PP
The Perl semantic closures are callbacks.
They are called as each node in a parse tree is evaluated.
.PP
Each Perl semantic closure is called with one or more arguments.
The first argument to a value action is always a per-parse-tree
object, which the callbacks can use as a scratchpad.
In this example, the per-parse-tree object is not used.
The remaining arguments will be the values of the node's \*(L"children\*(R" \*(--
in other words, the values computed for each of its \s-1RHS\s0 symbols, in order.
If the action is for an empty rule,
the per-parse-tree object will be its only argument.
.PP
Every value action is expected to return a value.
With one exception,
this value is passed up to a parent node
as an argument.
The exception is the value for the start rule.
The return value for the start rule becomes
the parse result.
.SH "Tainted data"
.IX Header "Tainted data"
Marpa::R2 exists to allow its input to alter execution in
flexible and powerful ways.
Marpa should not be used with untrusted input.
In Perl' s taint mode, it is a fatal error to use Marpa's \s-1SLIF\s0
interface
with a tainted grammar, a tainted input string,
or tainted token values.
.SH "Threads"
.IX Header "Threads"
When used in a thread-safe Perl, Marpa::R2 should be thread-safe,
with one important restriction:
All Marpa objects that share the same grammar must be created
and used within a single thread.
.PP
This restriction may be lifted someday, but
in practice it does not seem onerous.
Note that 
you can use
the same grammar in different
threads by creating grammars
that are exact
copies of each other,
one grammar per thread.
.SH "The Marpa:: namespace"
.IX Header "The Marpa:: namespace"
The \f(CW\*(C`Marpa::\*(C'\fR top-level namespace is reserved.
For extensions to Marpa,
one appropriate place is the \f(CW\*(C`MarpaX::\*(C'\fR namespace.
This practice helps avoid namespace collisions,
and follows a \s-1CPAN\s0 standard, as exemplified by
the
\&\f(CW\*(C`DBIx::\*(C'\fR
\&\f(CW\*(C`LWPx::\*(C'\fR
and
\&\f(CW\*(C`MooseX::\*(C'\fR
which are for extensions of, respectively,
\&\s-1DBI, LWP\s0 and Moose.
.SH "Other documents"
.IX Header "Other documents"
This document gives a semi-tutorial overview of Marpa's Scanless interface (\s-1SLIF\s0).
For a continuation of this tutorial, which describes how to get finer control
of Marpa and access more of its features,
see
the followup tutorial to this one.
If you are beginner who wants to learn more about Marpa,
you probably want to go next to
the overview of the \s-1SLIF\s0 interface,
and then the pages describing
its \s-1DSL\s0,
its grammar methods,
and
its recognizer methods.
.PP
Marpa has two other interfaces.
The thin
interface
provides direct access to the underlying
Libmarpa C library.
Of the Perl interfaces to Marpa,
the thin interface is the most low-level.
The thin interface offers efficient access to the full power of the
Marpa parse engine,
but it requires the application to do a lot of the work itself.
.PP
Now discouraged,
the named argument inteface (\s-1NAIF\s0)
was Marpa::R2's first interface.
It is a more traditional,
middle level interface which uses Perl calls
instead of a \s-1DSL.\s0
.PP
Marpa::R2::Vocabulary is intended as a quick refresher in
parsing terminology,
emphasizing how the standard terms are used
in the Marpa context.
Marpa's standard semantics are fully described in the
Marpa::R2::Semantics document.
Techniques for tracing and for debugging your Marpa grammars
are described in the
Marpa::R2::Tracing document and the
Marpa::R2::Progress document.
For those with a theoretical bent,
my sources, and other useful references, are described in
Marpa::R2::Advanced::Bibliography.
.SH "Author"
.IX Header "Author"
Jeffrey Kegler
.ie n .SS "Why is it called ""Marpa""?"
.el .SS "Why is it called ``Marpa''?"
.IX Subsection "Why is it called Marpa?"
Marpa is the name of the greatest of the Tibetan \*(L"translators\*(R".
In his time (the 11th century \s-1AD\s0) Indian Buddhism was
at its height.
Marpa's generation of scholars was devoted
to producing Tibetan versions of Buddhism's Sanskrit scriptures.
Marpa became the greatest of them,
and today is known as Marpa Lotsawa: \*(L"Marpa the Translator\*(R".
.SS "Blatant plug"
.IX Subsection "Blatant plug"
Marpa is a character in my novel, \fBThe God Proof\fR.
\&\fBThe God
Proof\fR centers around Kurt Go\*:del's proof of God's existence.
Yes, \fIthat\fR Kurt Go\*:del, and yes, he really did work out a
God Proof (it's in his \fICollected Works\fR, Vol. 3, pp. 403\-404).
\&\fBThe God Proof\fR is available
as a free download (<http://www.lulu.com/content/933192>).
It can be purchased in print form at Amazon.com:
<http://www.amazon.com/God\-Proof\-Jeffrey\-Kegler/dp/1434807355>.
.SH "Support"
.IX Header "Support"
Marpa::R2 comes without warranty.
Support is provided
on a volunteer basis
through the standard mechanisms for \s-1CPAN\s0 modules.
The Support document has details.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
