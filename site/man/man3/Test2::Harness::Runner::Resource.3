.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.41)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test2::Harness::Runner::Resource 3"
.TH Test2::Harness::Runner::Resource 3 "2020-11-03" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test2::Harness::Runner::Resource \- Base class for resource management classes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes you have limited resources that must be shared/divided between tests
that run concurrently. Resource classes give you a way to leverage the \s-1IPC\s0
system used by Test2::Harness to manage resource assignment and recovery.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Here is a resource class that simply assigns an integer to each test. It would
be possible to re-use integers, but since there are infinite integers this
example is kept simple and just always grabs the next one.
.PP
.Vb 3
\&    package Test2::Harness::Runner::Resource::Foo;
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqTest2::Harness::Runner::Resource\*(Aq;
\&
\&    sub available {
\&        my $self = shift;
\&        my ($task) = @_;
\&
\&        # There are an infinite amount of integers, so we always return true
\&        return 1;
\&    }
\&
\&    sub assign {
\&        my $self = shift;
\&        my ($task, $state) = @_;
\&
\&        # Next ID, do not record the state change yet!
\&        my $id = 1 + ($self\->{ID} //= 0);
\&
\&        print "ASSIGN: $id = $task\->{job_id}\en";
\&
\&        # \*(Aqrecord\*(Aq should get whatever we need to record the resource, whatever you
\&        # pass in will become the argument to the record() sub below. This may be a
\&        # scalar, a hash, an array, etc. It will be serialized to JSON before
\&        # record() sees it.
\&        $state\->{record} = $id;
\&
\&        # Pass the resource into the test, this can be done as envronment variables
\&        # and/or arguments to the test (@ARGV).
\&        $state\->{env_vars}\->{FOO_ID} = $id;
\&        push @{$state\->{args}} => $id;
\&
\&        # The return is ignored.
\&        return;
\&    }
\&
\&    sub record {
\&        my $self = shift;
\&        my ($job_id, $record_arg_from_assign) = @_;
\&
\&        # The ID from $state\->{record}\->{$pkg} in assign.
\&        my $id = $record_arg_from_assign;
\&
\&        # Update our internal state to reflect the new ID.
\&        $self\->{ID} = $id;
\&
\&        # Add a mapping of what job ID gets what integer ID.
\&        $self\->{ID_TO_JOB_ID}\->{$id}     = $job_id;
\&        $self\->{JOB_ID_TO_ID}\->{$job_id} = $id;
\&
\&        print "RECORD: $id = $job_id\en";
\&
\&        # The return is ignored
\&    }
\&
\&    sub release {
\&        my $self = shift;
\&        my ($job_id) = @_;
\&
\&        # Clear the internal mapping, the integer ID is now free. Theoretically it
\&        # can be reused, but this example is not that complex.
\&        my $id = delete $self\->{JOB_ID_TO_ID}\->{$job_id};
\&
\&        # This is called for all tests that complete, even if they did not use
\&        # this resource, so we return if the job_id is not applicable.
\&        return unless defined $id;
\&
\&        delete $self\->{ID_TO_JOB_ID}\->{$id};
\&
\&        print "  FREE: $id = $job_id\en";
\&
\&        # The return is ignored
\&    }
\&
\&    sub cleanup {
\&        my $self = shift;
\&
\&        print "CLEANUP!\en";
\&    }
\&
\&    1;
.Ve
.PP
The print statements generated will look like this when running 2 tests concurrently:
.PP
.Vb 10
\&    yath test \-R Foo \-j2 t/testA.t t/testB.t
\&    [...]
\&    (INTERNAL)     ASSIGN: 1 = 4F7CF5F6\-E43F\-11EA\-9199\-24FCBF610F44
\&    (INTERNAL)     RECORD: 1 = 4F7CF5F6\-E43F\-11EA\-9199\-24FCBF610F44
\&    (INTERNAL)     ASSIGN: 2 = E19CD98C\-E436\-11EA\-8469\-8DF0BF610F44
\&    (INTERNAL)     RECORD: 2 = E19CD98C\-E436\-11EA\-8469\-8DF0BF610F44
\&    (INTERNAL)       FREE: 1 = 4F7CF5F6\-E43F\-11EA\-9199\-24FCBF610F44
\&    (INTERNAL)       FREE: 2 = E19CD98C\-E436\-11EA\-8469\-8DF0BF610F44
\&    (INTERNAL)     CLEANUP!
\&    [...]
.Ve
.PP
Depending on the tests run the '\s-1FREE\s0' prints may be out of order.
.SH "WORKFLOW"
.IX Header "WORKFLOW"
.SS "\s-1HOW STATE IS MANAGED\s0"
.IX Subsection "HOW STATE IS MANAGED"
Depending on your preload configuration, yath may have several runners
launching tests. If a runner has nothing to do it will lock the queue and try
to find the next test that should be run. Only 1 of the runners will be in
control of the queue at any given time, but the control of the queue may pass
between runners. To manage this there is a mechanism to record messages that
allow each runner to maintain a copy of the current state.
.SS "\s-1CHECK IF RESOURCES ARE AVAILABLE\s0"
.IX Subsection "CHECK IF RESOURCES ARE AVAILABLE"
Each runner will have an instance of your resource class. When the runner is in
control of the queue, and wants to designate the next test to run, it will
check with the resource classes to make sure the correct resources are
available. To do that it will call \f(CW\*(C`available($task)\*(C'\fR on each resource
instance.
.PP
The \f(CW$task\fR will contain the specification for the test, it is a hashref, and
you \fB\s-1SHOULD NOT\s0\fR modify it. The only key most people care about is the 'file'
key, which has the test file that will be run if resources are available.
.PP
If resources are available, or if the specific file does not need the resource,
the \f(CW\*(C`available()\*(C'\fR method should return true. If the file does need your
resource(s), and none are available, this should return false. If any resource
class returns false it means the test cannot be run yet and the runner will
look for another test to run.
.SS "\s-1ASSIGN A RESOURCE\s0"
.IX Subsection "ASSIGN A RESOURCE"
If the runner has determined the test can be run, and all necessary resources
are available, it will then call \f(CW\*(C`assign($task, $state)\*(C'\fR on all resource class
instances. At this time the resource class should decide what resource(s) to
assign to the class.
.PP
\&\fB\s-1CRITICAL NOTE:\s0\fR the \f(CW\*(C`assing()\*(C'\fR method \fB\s-1MUST NOT\s0\fR alter any internal state
on the resource class instance. State modification must wait for the
\&\f(CW\*(C`record()\*(C'\fR method to be called. This is because the \f(CW\*(C`assign()\*(C'\fR method is only
called in one runner process, the \f(CW\*(C`record()\*(C'\fR method call will happen in every
runner process to insure they all have the same internal state.
.PP
The \fBassign()\fR sub should modify the \f(CW$state\fR hash, which has 3 keys:
.IP "env_vars => {}" 4
.IX Item "env_vars => {}"
Env vars to set for the test
.IP "args => []" 4
.IX Item "args => []"
Arguments to pass to the test
.IP "record => ..." 4
.IX Item "record => ..."
Data needed to record the state change for resource classes. Can be a scalar,
hashref, arrayref, etc. It will be serialized to \s-1JSON\s0 to be passed between
processes.
.SS "\s-1RECORD A RESOURCE\s0"
.IX Subsection "RECORD A RESOURCE"
Once a resource is assigned, a message will be sent to all runner processes
\&\fB\s-1INCLUDING THE ONE THAT DID THE ASSIGN\s0\fR that says it should call
\&\f(CW\*(C`record($job_id, $record_val)\*(C'\fR on your resource class instance. Your resource
class instance must use this to update the state so that once done \s-1ALL\s0
processes will have the proper internal state.
.PP
The \f(CW$record_val\fR is whatever you put into \f(CW\*(C`$state\->{record}\*(C'\fR in the
\&\f(CW\*(C`assign()\*(C'\fR method above.
.SS "\s-1QUEUE MANAGEMENT IS UNLOCKED\s0"
.IX Subsection "QUEUE MANAGEMENT IS UNLOCKED"
Once the above has been done, queue management will be unlocked. You can be
guarenteed that only one process will be run the \f(CW\*(C`available()\*(C'\fR, and
\&\f(CW\*(C`assign()\*(C'\fR sequence at a time, and that they will be called in order, though
\&\f(CW\*(C`assign()\*(C'\fR may not be called if another resource was not available. If
\&\f(CW\*(C`assign()\*(C'\fR is called, you can be guarenteed that all processes, including the
one that called \f(CW\*(C`assign()\*(C'\fR will have their \f(CW\*(C`record()\*(C'\fR called with the proper
argument \fB\s-1BEFORE\s0\fR they try to manage the queue (which is the only place
resources are checked or assigned).
.SS "\s-1RELEASE A RESOURCE\s0"
.IX Subsection "RELEASE A RESOURCE"
Whenever a process that is using a resource exits, the runner that waits on
that process will \fIeventually\fR send an \s-1IPC\s0 message announcing that the job_id
has completed. Every time a job_id completes the \f(CW\*(C`release($job_id)\*(C'\fR method
will be called on your resource class in all runner processes. This allows the
state to be updated to reflect the freed resource.
.PP
You can be guarenteed that any process that locks the queue to run a new
test will eventually see the message. The message may come in during a loop
that is checking for resources, in which case the state will not reflect the
resource being available, however in such cases the loop will end and be
called again later with the message having been receieved. There will be no
deadlock due to a queue manager waiting for the message.
.PP
There are no guarentees about what order resources will be released in.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$res = $class\->new(settings => $settings);" 4
.el .IP "\f(CW$res\fR = \f(CW$class\fR\->new(settings => \f(CW$settings\fR);" 4
.IX Item "$res = $class->new(settings => $settings);"
A default new method, returns a blessed hashref with the settings key set to
the Test2::Harness::Settings instance.
.ie n .IP "$bool = $res\->available(\e%task)" 4
.el .IP "\f(CW$bool\fR = \f(CW$res\fR\->available(\e%task)" 4
.IX Item "$bool = $res->available(%task)"
\&\fB\s-1DO NOT MODIFY ANY INTERNAL STATE IN THIS METHOD\s0\fR
.Sp
\&\fB\s-1DO NOT MODIFY THE TASK HASHREF\s0\fR
.Sp
Return true if the resource is available, or if the task does not require the
resource.
.Sp
Return false if the resource is not available, but is needed.
.Sp
The only key in \f(CW\*(C`\e%task\*(C'\fR hashref that most resources will care about is the
\&\f(CW\*(Aqfile\*(Aq\fR key, which contains the test file to be run.
.ie n .IP "$res\->assign(\e%task, \e%state)" 4
.el .IP "\f(CW$res\fR\->assign(\e%task, \e%state)" 4
.IX Item "$res->assign(%task, %state)"
\&\fB\s-1DO NOT MODIFY THE TASK HASHREF\s0\fR
.Sp
\&\fB\s-1DO NOT MODIFY ANY INTERNAL STATE IN THIS METHOD\s0\fR
.Sp
If the task does not need any resources you may simply return.
.Sp
If resources are needed you should deduce what resources to assign.
.Sp
You should put any data needed to update the internal state of your resource
instance in the \f(CW\*(C`$state\->{record}\*(C'\fR hash key. It \fB\s-1WILL\s0\fR be serialized to
\&\s-1JSON\s0 before being used as an argument to \f(CW\*(C`record()\*(C'\fR.
.Sp
.Vb 1
\&    $state\->{record} = $id;
.Ve
.Sp
If you do not set the 'record' key, or set it to undef, then the \f(CW\*(C`record()\*(C'\fR
method will not be called.
.Sp
If your tests need to know what resources to use, you may set environment
variables and/or command line arguments to pass into the test (\f(CW@ARGV\fR).
.Sp
.Vb 2
\&    $state\->{env_vars}\->{FOO_ID} = $id;
\&    push @{$state\->{args}} => $id;
.Ve
.Sp
The \f(CW\*(C`\e%state\*(C'\fR hashref is used only by your instance, you are free to fully
replace the 'env_vars' and 'args' keys. They will eventually be merged into a
master state along with those of other resources, but this ref is exclusive to
you in this method.
.ie n .IP "$inst\->record($job_id, $record_arg_from_assign)" 4
.el .IP "\f(CW$inst\fR\->record($job_id, \f(CW$record_arg_from_assign\fR)" 4
.IX Item "$inst->record($job_id, $record_arg_from_assign)"
\&\fB\s-1NOTE: THIS MAY BE CALLED IN MUTLIPLE PROCESSES CONCURRENTLY\s0\fR.
.Sp
This will be called in all processes so that your instance can update any
internal state.
.Sp
The \f(CW$job_id\fR variable contains the id for the job to which the resource was
assigned. You should use this to record any internal state. The \f(CW$job_id\fR will be
passed to \f(CW\*(C`release()\*(C'\fR when the job completes and no longer needs the resource.
.Sp
This is intended only for modifying internal state, you should not do anything
in this sub that will explode if it is also done in another process at the same
time with the same arguments. For example creating a database should not be
done here, multiple processes will fight to do the create. The creation, if
necessary should be done in \f(CW\*(C`assign()\*(C'\fR which will be called in only one
process.
.ie n .IP "$inst\->release($job_id)" 4
.el .IP "\f(CW$inst\fR\->release($job_id)" 4
.IX Item "$inst->release($job_id)"
\&\fB\s-1NOTE: THIS MAY BE CALLED IN MUTLIPLE PROCESSES CONCURRENTLY\s0\fR.
.Sp
This will be called for every test job that completes, even if it did not use
this resource. If the job_id did not use the resource you may simply return,
otherwise update the internal state to reflect that the resource is no longer
in use.
.Sp
This is intended only for modifying internal state, you should not do anything
in this sub that will explode if it is also done in another process at the same
time with the same arguments. For example deleting a database should not be
done here, multiple processes will fight to do the delete. \f(CW\*(C`assign()\*(C'\fR is the
only method that will be run in a single process, so if a database needs to be
cleaned before it can be used you should clean it there. Any final cleanup
should be done in \f(CW\*(C`cleanup()\*(C'\fR which will only be called by one process at the
very end.
.ie n .IP "$inst\->\fBcleanup()\fR" 4
.el .IP "\f(CW$inst\fR\->\fBcleanup()\fR" 4
.IX Item "$inst->cleanup()"
This will be called once by the parent runner process just before it exits.
This is your chance to do any final cleanup tasks such as deleting databases
that are no longer going to be used by tests as no more will be run.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Test2\-Harness can be found at
\&\fIhttp://github.com/Test\-More/Test2\-Harness/\fR.
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.SH "AUTHORS"
.IX Header "AUTHORS"
.PD 0
.IP "Chad Granum <exodist@cpan.org>" 4
.IX Item "Chad Granum <exodist@cpan.org>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2020 Chad Granum <exodist7@gmail.com>.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://dev.perl.org/licenses/\fR
