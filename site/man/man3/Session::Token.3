.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Session::Token 3"
.TH Session::Token 3 "2016-08-17" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Session::Token \- Secure, efficient, simple random session token generation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Simple 128\-bit session token"
.IX Subsection "Simple 128-bit session token"
.Vb 2
\&    my $token = Session::Token\->new\->get;
\&    ## 74da9DABOqgoipxqQDdygw
.Ve
.SS "Keep generator around"
.IX Subsection "Keep generator around"
.Vb 1
\&    my $generator = Session::Token\->new;
\&
\&    my $token = $generator\->get;
\&    ## bu4EXqWt5nEeDjTAZcbTKY
\&
\&    my $token2 = $generator\->get;
\&    ## 4Vez56Zc7el5Ggx4PoXCNL
.Ve
.SS "Custom minimum entropy in bits"
.IX Subsection "Custom minimum entropy in bits"
.Vb 2
\&    my $token = Session::Token\->new(entropy => 256)\->get;
\&    ## WdLiluxxZVkPUHsoqnfcQ1YpARuj9Z7or3COA4HNNAv
.Ve
.SS "Custom alphabet and length"
.IX Subsection "Custom alphabet and length"
.Vb 2
\&    my $token = Session::Token\->new(alphabet => \*(AqACGT\*(Aq, length => 100_000_000)\->get;
\&    ## AGTACTTAGCAATCAGCTGGTTCATGGTTGCCCCCATAG...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a secure, efficient, and simple interface for creating session tokens, password reset codes, temporary passwords, random identifiers, and anything else you can think of.
.PP
When a Session::Token object is created, 1024 bytes are read from \f(CW\*(C`/dev/urandom\*(C'\fR (Linux, Solaris, most BSDs), \f(CW\*(C`/dev/arandom\*(C'\fR (some older BSDs), or Crypt::Random::Source::Strong::Win32 (Windows). These bytes are used to seed the \s-1ISAAC\-32\s0 <http://www.burtleburtle.net/bob/rand/isaacafa.html> pseudo random number generator.
.PP
Once a generator is created, you can repeatedly call the \f(CW\*(C`get\*(C'\fR method on the generator object and it will return a new token each time.
.PP
\&\fB\s-1IMPORTANT\s0\fR: If your application calls \f(CW\*(C`fork\*(C'\fR, make sure that any generators are re-created in one of the processes after the fork since forking will duplicate the generator state and both parent and child processes will go on to produce identical tokens (just like perl's rand after it is seeded).
.PP
After the generator context is created, no system calls are used to generate tokens. This is one way that Session::Token helps with efficiency. However, this is only important for certain use cases (generally not web sessions).
.PP
\&\s-1ISAAC\s0 is a cryptographically secure \s-1PRNG\s0 that improves on the well-known \s-1RC4\s0 algorithm in some important areas. For instance, it doesn't have short cycles or initial bias like \s-1RC4\s0 does. A theoretical shortest possible cycle in \s-1ISAAC\s0 is \f(CW\*(C`2**40\*(C'\fR, although no cycles this short have ever been found (and probably don't exist at all). On average, \s-1ISAAC\s0 cycles are \f(CW\*(C`2**8295\*(C'\fR.
.SH "GENERATORS AND URANDOM"
.IX Header "GENERATORS AND URANDOM"
Developers must choose whether a single token generator will be kept around and used to generate all tokens, or if a new Session::Token object will be created every time a token is needed. As mentioned above, this module accesses urandom in its constructor for seeding purposes, but not subsequently while generating tokens.
.PP
Generally speaking the generator should be kept around and re-used. Probably the most important reason for this is that generating a new token from an existing generator cannot fail due to a full file-descriptor table. Creating a new Session::Token object for every token can fail because, as described above, the constructor needs to open \f(CW\*(C`/dev/urandom\*(C'\fR and this will not succeed if all allotted descriptors are in use, or if the read is interrupted by a signal. In these events a perl exception will be thrown.
.PP
Programs that re-use a generator are more likely to be portable to \f(CW\*(C`chroot\*(C'\fRed environments where \f(CW\*(C`/dev/urandom\*(C'\fR may not be present. Finally, accessing urandom frequently is inefficient because it requires making system calls and because (at least on linux) reading from urandom acquires a system-wide kernel lock.
.PP
On the other hand, re-using a generator may be undesirable because servers are typically started immediately after a system reboot and the kernel's randomness pool might be poorly seeded at that point. Similarly, when starting a virtual machine a previously used entropy pool state may be restored. In these cases all subsequently generated tokens will be derived from a weak/predictable seed. For this reason, you might choose to defer creating the generator until the first request actually comes in, periodically re-create the generator object, and/or manually handle seeding in some other way.
.PP
Programs that assume opening \f(CW\*(C`/dev/urandom\*(C'\fR will always succeed can return session tokens based only on the contents of nulled or uninitialised memory. This is not the case with Session::Token since its constructor will always throw an exception if it can't seed itself. Some modern systems provide system calls with fewer failure modes (ie `\fBgetentropy\fR\|(2)` on OpenBSD and `\fBgetrandom\fR\|(2)` on linux). Future versions of Session::Token will likely use these system calls when available.
.SH "CUSTOM ALPHABETS"
.IX Header "CUSTOM ALPHABETS"
Being able to choose exactly which characters appear in your token is sometimes useful. This set of characters is called the \fIalphabet\fR. \fBThe default alphabet size is 62 characters: uppercase letters, lowercase letters, and digits\fR (\f(CW\*(C`a\-zA\-Z0\-9\*(C'\fR).
.PP
For some purposes, base\-62 is a sweet spot. It is more compact than hexadecimal encoding which helps with efficiency because session tokens are usually transferred over the network many times during a session (often uncompressed in \s-1HTTP\s0 headers).
.PP
Also, base\-62 tokens don't use \*(L"wacky\*(R" characters like base\-64 encodings do. These characters sometimes cause encoding/escaping problems (ie when embedded in URLs) and are annoying because often you can't select tokens by double-clicking on them.
.PP
Although the default is base\-62, there are all kinds of reasons for using another alphabet. One example is if your users are reading tokens from a print-out or \s-1SMS\s0 or whatever, you may choose to omit characters like \f(CW\*(C`o\*(C'\fR, \f(CW\*(C`O\*(C'\fR, and \f(CW0\fR that can easily be confused.
.PP
To set a custom alphabet, just pass in either a string or an array of characters to the \f(CW\*(C`alphabet\*(C'\fR parameter of the constructor:
.PP
.Vb 3
\&    Session::Token\->new(alphabet => \*(Aq01\*(Aq)\->get;
\&    Session::Token\->new(alphabet => [\*(Aq0\*(Aq, \*(Aq1\*(Aq])\->get; # same thing
\&    Session::Token\->new(alphabet => [\*(Aqa\*(Aq..\*(Aqz\*(Aq])\->get; # character range
.Ve
.PP
Constructor args can be a hash-ref too:
.PP
.Vb 1
\&    Session::Token\->new({ alphabet => [\*(Aqa\*(Aq..\*(Aqz\*(Aq] })\->get;
.Ve
.SH "ENTROPY"
.IX Header "ENTROPY"
There are two ways to specify the length of tokens. The most primitive is in terms of characters:
.PP
.Vb 2
\&    print Session::Token\->new(length => 5)\->get;
\&    ## \-> wpLH4
.Ve
.PP
But the primary way is to specify their minimum entropy in terms of bits:
.PP
.Vb 2
\&    print Session::Token\->new(entropy => 24)\->get;
\&    ## \-> Fo5SX
.Ve
.PP
In the above example, the resulting token contains at least 24 bits of entropy. Given the default base\-62 alphabet, we can compute the exact entropy of a 5 character token as follows:
.PP
.Vb 2
\&    $ perl \-E \*(Aqsay 5 * log(62)/log(2)\*(Aq
\&    29.7709815519344
.Ve
.PP
So these tokens have about 29.8 bits of entropy. Note that if we removed one character from this token, it would bring it below our desired 24 bits of entropy:
.PP
.Vb 2
\&    $ perl \-E \*(Aqsay 4 * log(62)/log(2)\*(Aq
\&    23.8167852415475
.Ve
.PP
\&\fBThe default minimum entropy is 128 bits.\fR Default tokens are 22 characters long and therefore have about 131 bits of entropy:
.PP
.Vb 2
\&    $ perl \-E \*(Aqsay 22 * log(62)/log(2)\*(Aq
\&    130.992318828511
.Ve
.PP
An interesting observation is that in base\-64 representation, 128\-bit minimum tokens also require 22 characters and that these tokens contain only 1 more bit of entropy.
.PP
Another Session::Token design criterion is that all tokens should be the same length. The default token length is 22 characters and the tokens are always exactly 22 characters (no more, no less). Instead of tokens that are exactly \f(CW\*(C`N\*(C'\fR characters, some libraries that use arbitrary precision arithmetic end up creating tokens of \fIat most\fR \f(CW\*(C`N\*(C'\fR characters.
.PP
A fixed token length is nice because it makes writing matching regular expressions easier, simplifies storage (you never have to store length), causes various log files and things to line up neatly on your screen, and ensures that encrypted tokens won't leak token entropy due to length (see \*(L"\s-1VARIABLE LENGTH TOKENS\*(R"\s0).
.PP
In summary, the default token length of exactly 22 characters is a consequence of these decisions: base\-62 representation, 128 bit minimum token entropy, and fixed token length.
.SH "MOD BIAS"
.IX Header "MOD BIAS"
Some token generation libraries that implement custom alphabets will generate a random value, compute its modulus over the size of an alphabet, and then use this modulus to index into the alphabet to determine an output character.
.PP
Assume we have a uniform random number source that generates values in the set \f(CW\*(C`[0,1,2,3]\*(C'\fR (most PRNGs provide sequences of bits, in other words power\-of\-2 size sets) and wish to use the alphabet \f(CW"abc"\fR.
.PP
If we use the naïve modulus algorithm described above then \f(CW0\fR maps to \f(CW\*(C`a\*(C'\fR, \f(CW1\fR maps to \f(CW\*(C`b\*(C'\fR, \f(CW2\fR maps to \f(CW\*(C`c\*(C'\fR, and \f(CW3\fR \fIalso\fR maps to \f(CW\*(C`a\*(C'\fR. This results in the following biased distribution for each character in the token:
.PP
.Vb 3
\&    P(a) = 2/4 = 1/2
\&    P(b) = 1/4
\&    P(c) = 1/4
.Ve
.PP
Of course in an unbiased distribution, each character would have the same chance:
.PP
.Vb 3
\&    P(a) = 1/3
\&    P(b) = 1/3
\&    P(c) = 1/3
.Ve
.PP
Bias is undesirable because certain tokens are obvious starting points when token guessing and certain other tokens are very unlikely. Tokens that are unbiased are equally likely and therefore there is no obvious starting point with them.
.PP
Session::Token provides unbiased tokens regardless of the size of your alphabet (though see the \*(L"\s-1INTRODUCING BIAS\*(R"\s0 section for a mis-use warning). It does this in the same way that you might simulate producing unbiased random numbers from 1 to 5 given an unbiased 6\-sided die: Re-roll every time a 6 comes up.
.PP
In the above example, Session::Token eliminates bias by only using values of \f(CW0\fR, \f(CW1\fR, and \f(CW2\fR (the \f(CW\*(C`t/no\-mod\-bias.t\*(C'\fR test contains some more notes on this topic).
.PP
Note that mod bias can be made arbitrarily small by increasing the amount of data consumed from a random number generator (provided that arbitrary precision modulus is available). Because this module fundamentally avoids mod bias, it can use each of the 4 bytes from an \s-1ISAAC\-32\s0 word for a separate character (excepting \*(L"re-rolls\*(R").
.SH "EFFICIENCY OF RE-ROLLING"
.IX Header "EFFICIENCY OF RE-ROLLING"
Throwing away a portion of random data in order to avoid mod bias is slightly inefficient. How many bytes from \s-1ISAAC\s0 do we expect to consume for every character in the token? It depends on the size of the alphabet.
.PP
Session::Token masks off each byte using the smallest power of two greater than or equal to the alphabet size minus one so the probability that any particular byte can be used is:
.PP
.Vb 1
\&    P = alphabet_size / next_power_of_two(alphabet_size)
.Ve
.PP
For example, with the default base\-62 alphabet \f(CW\*(C`P\*(C'\fR is \f(CW\*(C`62/64\*(C'\fR.
.PP
In order to find the average number of bytes consumed for each character, calculate the expected value \f(CW\*(C`E\*(C'\fR. There is a probability \f(CW\*(C`P\*(C'\fR that the first byte will be used and therefore only one byte will be consumed, and a probability \f(CW\*(C`1 \- P\*(C'\fR that \f(CW\*(C`1 + E\*(C'\fR bytes will be consumed:
.PP
.Vb 1
\&    E = P*1 + (1 \- P)*(1 + E)
\&
\&    E = P + 1 + E \- P \- P*E
\&
\&    0 = 1 \- P*E
\&
\&    P*E = 1
\&
\&    E = 1/P
.Ve
.PP
So for the default base\-62 alphabet, the average number of bytes consumed for each character in a token is:
.PP
.Vb 1
\&    E = 1/(62/64) = 64/62 ≅ 1.0323
.Ve
.PP
Because of the next power of two masking optimisation described above, \f(CW\*(C`E\*(C'\fR will always be less than \f(CW2\fR. In the worst case scenario of an alphabet with 129 characters, \f(CW\*(C`E\*(C'\fR is roughly \f(CW1.9845\fR.
.PP
This minor inefficiency isn't an issue because the \s-1ISAAC\s0 implementation used is quite fast and this module is very thrifty in how it uses \s-1ISAAC\s0's output.
.SH "INTRODUCING BIAS"
.IX Header "INTRODUCING BIAS"
If your alphabet contains the same character two or more times, this character will be more biased than a character that only occurs once. You should be careful that your alphabets don't repeat in this way if you are trying to create random session tokens.
.PP
However, if you wish to introduce bias this library doesn't try to stop you. (Maybe it should print a warning?)
.PP
.Vb 2
\&    Session::Token\->new(alphabet => \*(Aq0000001\*(Aq, length => 5000)\->get; # don\*(Aqt do this
\&    ## \-> 0000000000010000000110000000000000000000000100...
.Ve
.PP
Due to a limitation discussed below, alphabets larger than 256 aren't currently supported so your bias can't get very granular.
.PP
Aside: If you have a constant-biased output stream like the above example produces then you can re-construct an un-biased bit sequence with the von neumann algorithm. This works by comparing pairs of bits. If the pair consists of identical bits, it is discarded. Otherwise the order of the different bits is used to determine an output bit, ie \f(CW00\fR and \f(CW11\fR are discarded but \f(CW01\fR and \f(CW10\fR are mapped to output bits of \f(CW0\fR and \f(CW1\fR respectively. This only works if the bias in each bit is constant (like all characters in a Session::Token are).
.SH "ALPHABET SIZE LIMITATION"
.IX Header "ALPHABET SIZE LIMITATION"
Due to a limitation in this module's code, alphabets can't be larger than 256 characters. Everywhere the above manual says \*(L"characters\*(R" it actually means bytes. This isn't a Unicode limitation per se, just the maximum size of the alphabet. If you like, you can map tokens onto new alphabets as long as they aren't more than 256 characters long. Here is how to generate a 128\-bit minimum entropy token using the lowercase greek alphabet (note that both forms of lowercase sigma are included which may not be desirable):
.PP
.Vb 4
\&    use utf8;
\&    my $token = Session::Token\->new(alphabet => [map {chr} 0..25])\->get;
\&    $token = join \*(Aq\*(Aq, map {chr} map {ord($_) + ord(\*(Aqα\*(Aq)} split //, $token;
\&    # ρφνδαπξδββφδοςλχτμγσψδψζειετ
.Ve
.PP
Here's an interesting way to generate a uniform random integer between 0 to 999 inclusive:
.PP
.Vb 1
\&    0 + Session::Token\->new(alphabet => [\*(Aq0\*(Aq..\*(Aq9\*(Aq], length => 3)\->get
.Ve
.PP
If you wanted to natively support high code points, there is no point in hard-coding a limitation on the size of Unicode or even the (higher) limitation of perl characters. Instead, arbitrary precision \*(L"characters\*(R" should be supported with bigint. Here's an example of something similar in lisp: isaac.lisp <http://hcsw.org/downloads/isaac.lisp>.
.PP
This module is not however designed to be the ultimate random number generator and at this time I think changing the design as described above would interfere with its goal of being secure, efficient, and simple.
.SH "TOKEN TEMPLATES"
.IX Header "TOKEN TEMPLATES"
String::Random has a method called \f(CW\*(C`randpattern\*(C'\fR where you provide a pattern that serves as a template when creating the token. You define the meaning of 1 or more template characters and each one that occurs in the pattern is replaced by a random character from a corresponding alphabet.
.PP
Andrew Beverley requested this feature for Session::Token and I suggested approximately the following:
.PP
.Vb 1
\&    use Session::Token;
\&
\&    sub token_template {
\&      my (%m) = @_;
\&
\&      %m = map { $_ => Session::Token\->new(alphabet => $m{$_}, length => 1) } keys %m;
\&
\&      return sub {
\&        my $v = shift;
\&        $v =~ s/(.)/exists $m{$1} ? $m{$1}\->get : $1/eg;
\&        return $v;
\&      };
\&    }
.Ve
.PP
In order to use \f(CW\*(C`token_template\*(C'\fR you should pass it key-vaue pairs of the different token characters and the alphabets they represent. It will return a sub that should be passed the template pattern and it will return the resulting random tokens.
.PP
For example, here is how to create \s-1UUID\s0 version 4 <https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29> tokens:
.PP
.Vb 5
\&    sub uuid_v4_generator {
\&      my $t = token_template(
\&            x => [ 0..9, \*(Aqa\*(Aq..\*(Aqf\*(Aq ],
\&            y => [ 8, 9, \*(Aqa\*(Aq, \*(Aqb\*(Aq ],
\&          );
\&
\&      return sub {
\&        return $t\->(\*(Aqxxxxxxxx\-xxxx\-4xxx\-yxxx\-xxxxxxxxxxxx\*(Aq);
\&      }
\&    }
.Ve
.PP
\&\f(CW\*(C`uuid_v4_generator\*(C'\fR returns a generator function that will return tokens of the following form:
.PP
.Vb 5
\&    1b782499\-9913\-4726\-a80a\-25e7b2221a7c
\&    90f85a64\-d826\-43bf\-98e7\-94ba87406bfb
\&    b8b73175\-3cce\-4861\-b43b\-3dec5ed5d641
\&    3afb64ab\-6de3\-4647\-bbff\-eb94dfa7d4b0
\&    447d2001\-2aec\-4d32\-9910\-8c289ae34c48
.Ve
.PP
Note that characters in the pattern which don't have template characters defined (\f(CW\*(C`\-\*(C'\fR and \f(CW4\fR in the above example) are passed through to the output token.
.SH "SEEDING"
.IX Header "SEEDING"
This module is designed to always seed itself from your kernel's secure random number source. You should never need to seed it yourself.
.PP
However if you know what you're doing you can pass in a custom seed as a 1024 byte long string. For example, here is how to create a \*(L"null seeded\*(R" generator:
.PP
.Vb 1
\&    my $gen = Session::Token(seed => "\ex00" x 1024);
.Ve
.PP
This is done in the test-suite to compare against Jenkins' reference \s-1ISAAC\s0 output, but obviously don't do this in regular applications because the generated tokens will be the same every time your program is run.
.PP
One valid reason for manually seeding is if you have some reason to believe that there isn't enough entropy in your kernel's randomness pool and therefore you don't trust \f(CW\*(C`/dev/urandom\*(C'\fR. In this case you should acquire your own seed data from somewhere trustworthy (maybe \f(CW\*(C`/dev/random\*(C'\fR or a previously stored trusted seed).
.SH "VARIABLE LENGTH TOKENS"
.IX Header "VARIABLE LENGTH TOKENS"
As mentioned above, all tokens produced by a Session::Token generator are the same length. If you prefer tokens of variable length, it is possible to post-process the tokens in order to achieve this so long as you keep some things in mind.
.PP
If you randomly truncate tokens created by Session::Token, be careful not to introduce bias. For example, if you choose the length of the token as a uniformly distributed random length between 8 and 10, then the output will be biased towards shorter token sizes. Length 8 tokens should appear less frequently than length 9 or 10 tokens because there are fewer of them.
.PP
Another approach is to eliminate leading characters of a given value in the same way as leading \f(CW0\fRs are commonly eliminated from numeric representations. Although this approach doesn't introduce bias, the tokens \f(CW1\fR and \f(CW01\fR are not distinct so it does not increase token entropy given a fixed maximum token length which is the main reason for preferring variable length tokens. The ideal variable length algorithm would generate both \f(CW1\fR and \f(CW01\fR tokens (with identical frequency of course).
.PP
Implementing unbiased, variable-length tokens would complicate the Session::Token implementation especially since you should still be able to specify minimum entropy variable-length tokens. Minimum entropy is the primary input to Session::Token, not token length. This is the reason that the default token length of \f(CW22\fR isn't hard-coded anywhere in the Session::Token source code (but \f(CW128\fR is).
.PP
The final reason that Session::Token discourages variable length tokens is that they can leak token information through a side-channel. This could occur when a message is encrypted but the length of the original message can be inferred from the encrypted ciphertext.
.SH "BUGS"
.IX Header "BUGS"
Should check for biased alphabets and print warnings.
.PP
Would be cool if it could detect forks and warn or re-seed in the child process (without incurring \f(CW\*(C`getpid\*(C'\fR overhead).
.PP
There is currently no way to extract the seed from a Session::Token object. Note when implementing this: The saved seed must either store the current state of the \s-1ISAAC\s0 round as well as the 1024 byte \f(CW\*(C`randsl\*(C'\fR array or else do some kind of minimum fast forwarding in order to protect against a partially duplicated output-stream bug.
.PP
Doesn't work on perl 5.6 and below due to the use of \f(CW\*(C`:raw\*(C'\fR (thanks \s-1CPAN\s0 testers). It could probably use \f(CW\*(C`binmode\*(C'\fR instead, but meh.
.PP
On windows we use Crypt::Random::Source::Strong::Win32 which has a big dependency tree. We should instead use a slimmer module like Crypt::Random::Seed.
.SH "COMMAND-LINE APP"
.IX Header "COMMAND-LINE APP"
There is a command-line application called App::Session::Token which is a convenience wrapper around Session::Token. You can generate session tokens by running the \f(CW\*(C`session\-token\*(C'\fR binary:
.PP
.Vb 2
\&    $ echo "Your password is \`session\-token\`"
\&    Your password is 8Yom6z4AeB1RXxCGzklJFt
.Ve
.PP
It supports all the options of this module via command line parameters, and multiple session tokens can be generated with the \f(CW\*(C`\-\-num\*(C'\fR (aka \f(CW\*(C`\-n\*(C'\fR) switch. For example:
.PP
.Vb 6
\&    $ session\-token \-\-alphabet ABC \-\-entropy 32 \-\-num 5
\&    BACAACABCCCCAACBBBCAB
\&    BCBACACBBCACCBABABCBA
\&    ABBBCBABBACBBBCBBBCCA
\&    AACCBBBCCAAACBABACABC
\&    CCABCABBCCCAACAAACCAA
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The Session::Token github repo <https://github.com/hoytech/Session-Token>
.PP
App::Session::Token
.PP
Presentation for Toronto Perl Mongers <https://www.youtube.com/watch?v=c2KZBTtrmZE?start=3705>
.PP
There are lots of different modules for generating random data. If the characterisations of any of them below are inaccurate or out-of-date, please file a github issue and I will correct them.
.PP
Like this module, perl's \f(CW\*(C`rand()\*(C'\fR function implements a user-space \s-1PRNG\s0 seeded from \f(CW\*(C`/dev/urandom\*(C'\fR. However, perl's \f(CW\*(C`rand()\*(C'\fR is not secure. Perl doesn't specify a \s-1PRNG\s0 algorithm at all. On linux, whatever it is is seeded with a mere 4 bytes from \f(CW\*(C`/dev/urandom\*(C'\fR.
.PP
Data::Token is the first thing I saw when I looked around on \s-1CPAN.\s0 It has an inflexible and unspecified alphabet. It tries to get its source of unpredictability from UUIDs and then hashes these UUIDs with \s-1SHA\-1. I\s0 think this is bad design because some standard \s-1UUID\s0 formats aren't designed to be unpredictable at all. This is acknowledged in \s-1RFC 4122\s0 section 6: \*(L"Do not assume that UUIDs are hard to guess; they should not be used as security capabilities (identifiers whose mere possession grants access).\*(R" With certain UUIDs, knowing a target's \s-1MAC\s0 address or the rough time the token was issued may help you predict a reduced area of token-space to concentrate guessing attacks upon. I don't know if Data::Token uses these types of UUIDs or the potentially secure \*(L"version 4\*(R" UUIDs, but because this wasn't addressed in the documentation and because of an apparent misapplication of hash functions (if you really had an unpredictable \s-1UUID,\s0 there would be no need to hash), I don't feel good about using this module.
.PP
There are several decent random number generators like Math::Random::Secure and Crypt::URandom but they usually don't implement alphabets and some of them require you open or read from \f(CW\*(C`/dev/urandom\*(C'\fR for every chunk of random bytes. Note that Math::Random::Secure does prevent mod bias in its random integers and could be used to implement unbiased alphabets (slowly).
.PP
String::Random has a neat regexp-like language for specifying random tokens which is more flexible than alphabets. However, it uses perl's \f(CW\*(C`rand()\*(C'\fR and its documentation fails to discuss performance, bias, or security. See the \*(L"\s-1TOKEN TEMPLATES\*(R"\s0 section for a similar feature.
.PP
String::Urandom has alphabets, but it uses the flawed mod algorithm described above and opens \f(CW\*(C`/dev/urandom\*(C'\fR for every token.
.PP
There are other modules like Data::Random, App::Genpass, String::MkPasswd, Crypt::RandPasswd, Crypt::GeneratePassword, and Data::SimplePassword but they use insecure PRNGs such as \f(CW\*(C`rand()\*(C'\fR or mersenne twister, don't adequately deal with bias, and/or don't let you specify generic alphabets.
.PP
Bytes::Random::Secure has alphabets (aka \*(L"bags\*(R"), uses \s-1ISAAC,\s0 and avoids mod bias using the re-roll algorithm. It is much slower than Session::Token (even when using Math::Random::ISAAC::XS) but does support alphabets larger than \f(CW256\fR and might work in environments without \s-1XS.\s0
.PP
Neil Bowers has conducted a 3rd party review <http://neilb.org/reviews/passwords.html> of various token/password generation modules including Session::Token.
.PP
Leo Zovic has created a Common Lisp implementation of session-token <https://github.com/Inaimathi/session-token>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Hoyte, \f(CW\*(C`<doug@hcsw.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2012\-2016 Doug Hoyte.
.PP
This module is licensed under the same terms as perl itself.
.PP
\&\s-1ISAAC\s0 code:
.PP
.Vb 1
\&    By Bob Jenkins.  My random number generator, ISAAC.  Public Domain
.Ve
