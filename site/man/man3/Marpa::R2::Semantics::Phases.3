.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Marpa::R2::Semantics::Phases 3"
.TH Marpa::R2::Semantics::Phases 3 "2020-07-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Marpa::R2::Semantics::Phases \- SLIF recognizer phases
.SH "About this document"
.IX Header "About this document"
This document describes in detail the sequence of events
in the \s-1SLIF\s0 recognizer.
It serves two purposes.
.IP "\(bu" 4
It describes the sequence of events
in the \s-1SLIF\s0 recognizer
in fuller detail
than the other documents do.
.IP "\(bu" 4
It describes the use of more than one parse series.
.PP
Full detail of the sequence of events
inside the \s-1SLIF\s0 recognizer
is not usually necessary.
Applications usually
find that things \*(L"just work\*(R".
But some application \fBdo\fR depend on the details.
These include
.IP "\(bu" 4
applications which make unusual use of side effects in the semantics; and
.IP "\(bu" 4
applications which alter their symbol tables at runtime.
.PP
The semantics has two different modes,
one of which is deprecated.
If the \s-1SLIF\s0 recognizer is created from a grammar
which uses the \s-1SLIF\s0 grammar's
\&\f(CW\*(C`action_object\*(C'\fR
setting,
the \s-1SLIF\s0's semantics will be in \*(L"legacy\*(R" mode.
Otherwise, the \s-1SLIF\s0's semantics will be
in \*(L"standard\*(R" mode.
.PP
Legacy mode is deprecated and should not be used in new
applications.
It is documented in its own section.
Unless otherwise specified,
the other sections of this document assume
that \*(L"standard\*(R" mode is in use.
.SH "Parse trees and parse series"
.IX Header "Parse trees and parse series"
Because Marpa allows ambiguous parsing,
each parse can produce a
a series of zero or more parse trees,
\&\*(-- a \fBparse series\fR.
Each parse tree has its own parse result.
Because the parse may fail,
there may be zero parse
trees in a parse series.
Because a parse may be ambiguous,
there may be more than one parse tree
in a parse series.
.PP
The \s-1SLIF\s0 allows the recognizer to
be run several times on the same
virtual input stream.
Each of these runs is a separate \fBparse series\fR.
Most applications use only
one parse series.
.PP
The call to the
\&\s-1SLIF\s0 recognizer's \f(CW\*(C`read()\*(C'\fR
method
is the
start of the first parse series.
The first parse series continues until there is
a call to the
\&\f(CW\*(C`series_restart()\*(C'\fR
method
or until the recognizer is destroyed.
Each call of the \f(CW\*(C`series_restart()\*(C'\fR method
starts a new parse series.
.PP
Few applications need to use more than
a single parse series.
But they are useful in some specialized
applications.
Starting a new parse series allows the applications
to change some settings
and to extend the input.
Specifically,
.IP "\(bu" 4
Once input is read into a \s-1SLIF\s0 recognizer's
virtual input stream, it is there for the life of the recognizer.
It cannot be \*(L"unread\*(R".
But during the Reading Phase of a new parse series,
a recognizer can extend the virtual input stream,
using the recognizer's 
\&\f(CW\*(C`resume()\*(C'\fR method.
.IP "\(bu" 4
Within a parse series,
the semantics package cannot change.
But you can specify a new semantics package
after starting a new parse series.
.IP "\(bu" 4
Certain other \s-1SLIF\s0 recognizer settings can be
changed
after starting a new parse series.
These include the \s-1SLIF\s0 recognizer's
\&\f(CW\*(C`end\*(C'\fR setting.
For details, see
\&\*(L"Recognizer settings\*(R" in Marpa::R2::Scanless::R.
.SH "SLIF recognizer phases"
.IX Header "SLIF recognizer phases"
A \s-1SLIF\s0 recognizer is always in one of three phases:
.IP "\(bu" 4
The Initial Phase;
.IP "\(bu" 4
a Reading Phase; or
.IP "\(bu" 4
an Evaluation Phase.
.PP
In these documents,
phase and subphase names are capitalized
for clarity.
.PP
Reading and Evaluation Phases
are always part of a parse series.
The Initial Phase is never part of any parse series.
.SH "The Initial Phase"
.IX Header "The Initial Phase"
The \fBInitial Phase\fR of a \s-1SLIF\s0 recognizer
begins when the recognizer is created with the
a call of the \f(CW\*(C`new()\*(C'\fR method.
It ends when
the \f(CW\*(C`read()\*(C'\fR method
is called.
It will also end, of course, if
the recognizer is destroyed,
but most applications will want to
continue into the next phases.
.PP
There is always exactly one Initial Phase for
every recognizer.
The Initial Phase is not part of any parse series.
Very little can happen in the Initial Phase,
but it is possible to change some recognizer settings
using the \f(CW\*(C`set()\*(C'\fR method.
.SH "The Reading Phase"
.IX Header "The Reading Phase"
The Reading Phase starts
when a parse series starts,
that is,
with either a call to the
\&\f(CW\*(C`read()\*(C'\fR
method
or a call to the
\&\f(CW\*(C`series_restart()\*(C'\fR
method.
The Reading Phase ends when the first of the following occurs:
.IP "\(bu" 4
The recognizer is destroyed.
.IP "\(bu" 4
A new parse series is begun
by calling the \f(CW\*(C`series_restart()\*(C'\fR method.
This and the previous case are unusual.
Applications almost always
want to continue the parse series into the Evaluation Phase.
.IP "\(bu" 4
The \f(CW\*(C`value()\*(C'\fR method is called for this \s-1SLIF\s0 recognizer.
This is the most common case.
.PP
The \f(CW\*(C`read()\*(C'\fR method can be called only once for a \s-1SLIF\s0 recognizer.
But, while a Reading Phase continues,
the \f(CW\*(C`resume()\*(C'\fR method may be called multiple times to continue reading
input.
The \f(CW\*(C`resume()\*(C'\fR method should only be called except during the
Reading Phase of a parse series.
.PP
A Reading Phase is always part of a parse series.
There is always exactly one Reading Phase for every parse series.
.SH "The Evaluation Phase"
.IX Header "The Evaluation Phase"
The Evaluation Phase begins with a recognizer's first call
to the \s-1SLIF\s0's \f(CW\*(C`value()\*(C'\fR method.
It ends when the recognizer is destroyed,
or when
the \s-1SLIF\s0's \f(CW\*(C`series_restart()\*(C'\fR method
is called for that recognizer.
If a parse series ends before the \f(CW\*(C`value()\*(C'\fR method is
called, there is no Evaluation Phase.
.PP
The \f(CW\*(C`value()\*(C'\fR method
may be called more than once during the Evaluation Phase.
The second and later calls of
the \f(CW\*(C`value()\*(C'\fR method will return
the result of the next parse tree, if there is one.
When there are no more parse trees,
the \f(CW\*(C`value()\*(C'\fR method will return
a Perl \f(CW\*(C`undef\*(C'\fR.
.PP
If you call
the \f(CW\*(C`resume()\*(C'\fR method
during an Evaluation Phase,
the behavior of
Marpa::R2
is not defined.
You should not do this.
.PP
When it occurs, an Evaluation Phase is always part of a parse series.
But the Evaluation Phase is optional \*(--
a parse series may end without entering into an Evalution Phase.
.PP
The Evaluation Phase has two subphases:
.IP "\(bu" 4
The Parse Tree Setup Subphase.
.IP "\(bu" 4
The Parse Tree Traveral Subphase.
.PP
\&\fBNode Evaluation Time\fR
is the Tree Traversal Subphase, as seen from the point of view of
each rule node.  It is not a separate phase.
.SH "Parse Tree Setup Subphase"
.IX Header "Parse Tree Setup Subphase"
The Parse Tree Setup Subphase
occurs during during the first call
to the \f(CW\*(C`value()\*(C'\fR method of every series.
In the Parse Tree Setup Subphase, the following happens:
.IP "\(bu" 4
The per-parse argument is created.
If a per-parse constructor was found,
it is run at this point, and the per-parse argument is
its return value.
.IP "\(bu" 4
All action names are resolved to
actions \*(--
Perl scalars
or rule evaluation closures.
The rule evaluation closures are not called in the Parse Tree Setup Subphase.
They will be called later,
in the Parse Tree Traversal Subphase.
.PP
Exactly one Parse Tree Setup Subphase occurs
for each parse tree.
.SH "Parse Tree Traversal Subphase"
.IX Header "Parse Tree Traversal Subphase"
During the Parse Tree Traversal Subphase,
the rule evaluation closures are called.
.SH "Legacy mode"
.IX Header "Legacy mode"
If the \s-1SLIF\s0 recognizer is created from a grammar
which uses the
\&\f(CW\*(C`action_object\*(C'\fR
\&\s-1SLIF\s0 grammar setting,
the \s-1SLIF\s0 recognizer will be in \*(L"legacy\*(R" mode.
Legacy mode is deprecated.
It is documented here only for the support of legacy
applications.
.PP
In legacy mode,
there is an additional evaluation subphase,
the Parse Series Setup Subphase,
and tasks performed in standard mode
by the Parse Tree Setup Subphase
are split between the two subphases.
.PP
The Parse Series Setup Subphase
occurs just before
the Parse Tree Setup Subphase,
in the first \f(CW\*(C`value\*(C'\fR method call
of \fBthe first\fR parse series.
It is important to emphasize that
the Parse Series Setup Subphase
occurs \fBonly in the first parse series\fR.
.PP
In legacy mode,
the only task performed by
the Parse Tree Setup Phase is creation
of the per-parse argument.
Action resolution
is performed in the 
the Parse Series Setup Phase.
.PP
One practical implication
of this is that,
in legacy mode,
the semantics package cannot be changed
by starting a new parse series.
Both are decided once and for all
in the Parse Series Setup Subphase,
and
the Parse Series Setup Subphase
occurs only once during the life
cycle of a \s-1SLIF\s0 recognizer.
.PP
The precise timing of semantics
operations is affected by the
changes described above.
These changed timings, in turn,
may affect applications that rely on side
effects of the semantics.
.SH "Copyright and License"
.IX Header "Copyright and License"
.Vb 5
\&  Copyright 2018 Jeffrey Kegler
\&  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
\&  redistribute it and/or modify it under the terms of the GNU Lesser
\&  General Public License as published by the Free Software Foundation,
\&  either version 3 of the License, or (at your option) any later version.
\&
\&  Marpa::R2 is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&  Lesser General Public License for more details.
\&
\&  You should have received a copy of the GNU Lesser
\&  General Public License along with Marpa::R2.  If not, see
\&  http://www.gnu.org/licenses/.
.Ve
