.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "BADVALUES 1"
.TH BADVALUES 1 "2019-12-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::BadValues \- Discussion of bad value support in PDL
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "What are bad values and why should I bother with them?"
.IX Subsection "What are bad values and why should I bother with them?"
Sometimes it's useful to be able to specify a certain value is 'bad' or 
\&'missing'; for example CCDs used in astronomy produce 2D images which are not
perfect since certain areas contain invalid data due to imperfections in the
detector.  Whilst \s-1PDL\s0's powerful index
routines and all the complicated business with dataflow, slices, etc etc mean 
that these regions can be ignored in processing, it's awkward to do. It would
be much easier to be able to say \f(CW\*(C`$c = $x + $y\*(C'\fR and leave all the hassle to 
the computer.
.PP
If you're not interested in this, then you may (rightly) be concerned 
with how this affects the speed of \s-1PDL,\s0 since the overhead of checking for a
bad value at each operation can be large. 
Because of this, the code has been written to be as fast as possible \-
particularly when operating on piddles which do not contain bad values.
In fact, you should notice essentially no speed difference when working 
with piddles which do not contain bad values.
.PP
However, if you do not want bad values, then \s-1PDL\s0's \f(CW\*(C`WITH_BADVAL\*(C'\fR 
configuration option comes to the rescue; if set to 0 or undef, the bad-value 
support is ignored.
About the only time I think you'll need to use this \- I admit, I'm biased ;) \-
is if you have limited disk or memory space, since the size of the code
is increased (see below).
.PP
You may also ask 'well, my computer supports \s-1IEEE\s0 NaN, so I already have this'.
Well, yes and no \- many routines, such as \f(CW\*(C`y=sin(x)\*(C'\fR, will propagate NaN's 
without the user having to code differently, but routines such as \f(CW\*(C`qsort\*(C'\fR, or
finding the median of an array, need to be re-coded to handle bad values.
For floating-point datatypes, \f(CW\*(C`NaN\*(C'\fR and \f(CW\*(C`Inf\*(C'\fR are used to flag bad values
\&\fI\s-1IF\s0\fR the option \f(CW\*(C`BADVAL_USENAN\*(C'\fR is set to 1 in your config file.  Otherwise
special values are used (Default bad values).  I
do not have any benchmarks to see which option is faster.
.PP
There is an experimental feature \f(CW\*(C`BADVAL_PER_PDL\*(C'\fR which, if set,
allows you to have different bad values for separate piddles of the
same type. This currently does not work with the \f(CW\*(C`BADVAL_USENAN\*(C'\fR option;
if both are set then \s-1PDL\s0 will ignore the \f(CW\*(C`BADVAL_USENAN\*(C'\fR value.
.SS "Code increase due to bad values"
.IX Subsection "Code increase due to bad values"
The following comparison is out of date!
.PP
On an i386 machine running Linux and Perl 5.005_03, I measured the 
following sizes (the Slatec code was compiled in, but none of the other 
options: e.g., \s-1FFTW, GSL,\s0 and TriD were):
.IP "\s-1WITH_BADVAL\s0 = 0" 4
.IX Item "WITH_BADVAL = 0"
Size of blib directory after a successful make = \fB4963 kb\fR:
blib/arch = 2485 kb and blib/lib = 1587 kb.
.IP "\s-1WITH_BADVAL\s0 = 1" 4
.IX Item "WITH_BADVAL = 1"
Size of blib directory after a successful make = \fB5723 kb\fR:
blib/arch = 3178 kb and blib/lib = 1613 kb.
.PP
So, the overall increase is \fIonly\fR 15% \- not much to pay for all
the wonders that bad values provides ;)
.PP
The source code used for this test had the vast majority of the core routines 
(eg those in Basic/) converted to use bad values, whilst very few of the 'external' 
routines (i.e. everything else in the \s-1PDL\s0 distribution) had been changed.
.SS "A quick overview"
.IX Subsection "A quick overview"
.Vb 10
\& pdl> p $PDL::Bad::Status
\& 1
\& pdl> $x = sequence(4,3);
\& pdl> p $x
\& [
\&  [ 0  1  2  3]
\&  [ 4  5  6  7]
\&  [ 8  9 10 11]
\& ]
\& pdl> $x = $x\->setbadif( $x % 3 == 2 )
\& pdl> p $x
\& [
\&  [  0   1 BAD   3]
\&  [  4 BAD   6   7]
\&  [BAD   9  10 BAD]
\& ]
\& pdl> $x *= 3
\& pdl> p $x
\& [
\&  [  0   3 BAD   9]
\&  [ 12 BAD  18  21]
\&  [BAD  27  30 BAD]
\& ]
\& pdl> p $x\->sum
\& 120
.Ve
.PP
\&\f(CW\*(C`demo bad\*(C'\fR and \f(CW\*(C`demo bad2\*(C'\fR
within perldl or pdl2 gives a demonstration of some of the things
possible with bad values.  These are also available on \s-1PDL\s0's web-site,
at \fIhttp://pdl.perl.org/demos/\fR.  See PDL::Bad for useful routines for working 
with bad values and \fIt/bad.t\fR to see them in action.
.PP
The intention is to:
.IP "\(bu" 4
not significantly affect \s-1PDL\s0 for users who don't need bad value support
.IP "\(bu" 4
be as fast as possible when bad value support is installed
.PP
If you never want bad value support, then you set \f(CW\*(C`WITH_BADVAL\*(C'\fR to 0 in 
\&\fIperldl.conf\fR; \s-1PDL\s0 then has no bad value support compiled in, so will be as fast
as it used to be.
.PP
However, in most cases, the bad value support has a negligible affect on speed,
so you should set \f(CW\*(C`WITH_CONFIG\*(C'\fR to 1! One exception is if you are low on memory,
since the amount of code produced is larger (but only by about 15% \- see
\&\*(L"Code increase due to bad values\*(R").
.PP
To find out if \s-1PDL\s0 has been compiled with bad value support, look at the values
of either \f(CW$PDL::Config{WITH_BADVAL}\fR or \f(CW$PDL::Bad::Status\fR \- if true then
it has been.
.PP
To find out if a routine supports bad values, use the \f(CW\*(C`badinfo\*(C'\fR command in
perldl or pdl2 or the \f(CW\*(C`\-b\*(C'\fR option to
pdldoc.  This facility is currently a 'proof of concept'
(or, more realistically, a quick hack) so expect it to be rough around the edges.
.PP
Each piddle contains a flag \- accessible via \f(CW\*(C`$pdl\->badflag\*(C'\fR \- to say 
whether there's any bad data present:
.IP "\(bu" 4
If \fBfalse/0\fR, which means there's no bad data here, the code supplied by the 
\&\f(CW\*(C`Code\*(C'\fR option to \f(CW\*(C`pp_def()\*(C'\fR is executed. This means that the speed should be 
very close to that obtained with \f(CW\*(C`WITH_BADVAL=0\*(C'\fR, since the only overhead is 
several accesses to a bit in the piddles state variable.
.IP "\(bu" 4
If \fBtrue/1\fR, then this says there \fI\s-1MAY\s0\fR be bad data in the piddle, so use the
code in the \f(CW\*(C`BadCode\*(C'\fR option (assuming that the \f(CW\*(C`pp_def()\*(C'\fR for this routine 
has been updated to have a BadCode key). 
You get all the advantages of threading, as with the \f(CW\*(C`Code\*(C'\fR option, 
but it will run slower since you are going to have to handle the presence of bad values.
.PP
If you create a piddle, it will have its bad-value flag set to 0. To change 
this, use \f(CW\*(C`$pdl\->badflag($new_bad_status)\*(C'\fR, where \f(CW$new_bad_status\fR can be 0 or 1.
When a routine creates a piddle, its bad-value flag will depend on the input
piddles: unless over-ridden (see the \f(CW\*(C`CopyBadStatusCode\*(C'\fR option to \f(CW\*(C`pp_def\*(C'\fR), the 
bad-value flag will be set true if any of the input piddles contain bad values.
To check that a piddle really contains bad data, use the \f(CW\*(C`check_badflag\*(C'\fR method.
.PP
\&\fI\s-1NOTE\s0\fR: propagation of the badflag
.PP
If you change the badflag of a piddle, this change is propagated to all
the \fIchildren\fR of a piddle, so
.PP
.Vb 8
\&   pdl> $x = zeroes(20,30);
\&   pdl> $y = $x\->slice(\*(Aq0:10,0:10\*(Aq);
\&   pdl> $c = $y\->slice(\*(Aq,(2)\*(Aq);
\&   pdl> print ">>c: ", $c\->badflag, "\en";
\&   >>c: 0
\&   pdl> $x\->badflag(1);
\&   pdl> print ">>c: ", $c\->badflag, "\en";
\&   >>c: 1
.Ve
.PP
\&\fINo\fR change is made to the parents of a piddle, so
.PP
.Vb 5
\&   pdl> print ">>a: ", $x\->badflag, "\en";
\&   >>a: 1
\&   pdl> $c\->badflag(0);
\&   pdl> print ">>a: ", $x\->badflag, "\en";
\&   >>a: 1
.Ve
.PP
Thoughts:
.IP "\(bu" 4
the badflag can \s-1ONLY\s0 be cleared \s-1IF\s0 a piddle has \s-1NO\s0 parents,
and that this change will propagate to all the children of that
piddle. I am not so keen on this anymore (too awkward to code, for
one).
.IP "\(bu" 4
\&\f(CW\*(C`$x\->badflag(1)\*(C'\fR should propagate the badflag to \s-1BOTH\s0 parents and
children.
.PP
This shouldn't be hard to implement (although an initial attempt failed!). 
Does it make sense though? There's also
the issue of what happens if you change the badvalue of a piddle \- should
these propagate to children/parents (yes) or whether you should only be
able to change the badvalue at the 'top' level \- i.e. those piddles which do
not have parents.
.PP
The \f(CW\*(C`orig_badvalue()\*(C'\fR method returns the compile-time value for a given 
datatype. It works on piddles, PDL::Type objects, and numbers \- eg
.PP
.Vb 1
\&  $pdl\->orig_badvalue(), byte\->orig_badvalue(), and orig_badvalue(4).
.Ve
.PP
It also has a horrible name...
.PP
To get the current bad value, use the \f(CW\*(C`badvalue()\*(C'\fR method \- it has the same
syntax as \f(CW\*(C`orig_badvalue()\*(C'\fR.
.PP
To change the current bad value, supply the new number to badvalue \- eg
.PP
.Vb 1
\&  $pdl\->badvalue(2.3), byte\->badvalue(2), badvalue(5,\-3e34).
.Ve
.PP
\&\fINote\fR: the value is silently converted to the correct C type, and
returned \- i.e. \f(CW\*(C`byte\->badvalue(\-26)\*(C'\fR returns 230 on my Linux machine.
It is also a \f(CW\*(C`nop\*(C'\fR for floating-point types when \f(CW\*(C`BADVAL_USENAN\*(C'\fR is true.
.PP
Note that changes to the bad value are \fI\s-1NOT\s0\fR propagated to previously-created
piddles \- they will still have the bad value set, but suddenly the elements
that were bad will become 'good', but containing the old bad value.
See discussion below.  It's not a problem for floating-point types
which use NaN, since you can not change their badvalue.
.SS "Bad values and boolean operators"
.IX Subsection "Bad values and boolean operators"
For those boolean operators in PDL::Ops, evaluation 
on a bad value returns the bad value.  Whilst this means that
.PP
.Vb 1
\& $mask = $img > $thresh;
.Ve
.PP
correctly propagates bad values, it \fIwill\fR cause problems
for checks such as
.PP
.Vb 1
\& do_something() if any( $img > $thresh );
.Ve
.PP
which need to be re-written as something like
.PP
.Vb 1
\& do_something() if any( setbadtoval( ($img > $thresh), 0 ) );
.Ve
.PP
When using one of the 'projection' functions in PDL::Ufunc \- such as 
orover \- 
bad values are skipped over (see the documentation of these
functions for the current (poor) handling of the case when
all elements are bad).
.SS "A bad value for each piddle, and related issues"
.IX Subsection "A bad value for each piddle, and related issues"
An \fBexperimental\fR option \f(CW\*(C`BADVAL_PER_PDL\*(C'\fR has been added to \fIperldl.conf\fR
to allow per-piddle bad values. The documentation has not been updated
to account for this change.
.PP
The following is relevant only for integer types, and for floating-point
types if \f(CW\*(C`BADVAL_USENAN\*(C'\fR was not set when \s-1PDL\s0 was built.
.PP
Currently, there is one bad value for each datatype. The code is written so 
that we could have a separate bad value for each piddle (stored in the 
pdl structure) \- this would then remove the current problem of:
.PP
.Vb 9
\& pdl> $x = byte( 1, 2, byte\->badvalue, 4, 5 );
\& pdl> p $x;
\& [1 2 255 4 5]
\& pdl> $x\->badflag(1)
\& pdl> p $x;
\& [1 2 BAD 4 5]
\& pdl> byte\->badvalue(0);
\& pdl> p $x;
\& [1 2 255 4 5]
.Ve
.PP
ie the bad value in \f(CW$a\fR has lost its \fIbad\fR status using the current 
implementation.  It would almost certainly cause problems elsewhere though!
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
\&\s-1PDL\s0 code just needs to access the \f(CW%PDL::Config\fR
array (e.g. \fIBasic/Bad/bad.pd\fR) to find out whether bad-value support is required.
.PP
A new flag has been added to the state of a piddle \- \f(CW\*(C`PDL_BADVAL\*(C'\fR. If unset, then
the piddle does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for. Thanks to Christian, \f(CW\*(C`badflag()\*(C'\fR \- which 
sets/clears this flag (see \fIBasic/Bad/bad.pd\fR) \- will update \fI\s-1ALL\s0\fR the 
children/grandchildren/etc of a piddle if its state changes (see 
\&\f(CW\*(C`badflag\*(C'\fR in \fIBasic/Bad/bad.pd\fR and
\&\f(CW\*(C`propagate_badflag\*(C'\fR in \fIBasic/Core/Core.xs.PL\fR). 
It's not clear what to do with parents: I can see the reason for propagating a 
\&'set badflag' request to parents, but I think a child should \s-1NOT\s0 be able to clear 
the badflag of a parent. 
There's also the issue of what happens when you change the bad value for a piddle.
.PP
The \f(CW\*(C`pdl_trans\*(C'\fR structure has been extended to include an integer value,
\&\f(CW\*(C`bvalflag\*(C'\fR, which acts as a switch to tell the code whether to handle bad values
or not. This value is set if any of the input piddles have their \f(CW\*(C`PDL_BADVAL\*(C'\fR 
flag set (although this code can be replaced by setting \f(CW\*(C`FindBadStateCode\*(C'\fR in 
pp_def).  The logic of the check is going to get a tad more complicated
if I allow routines to fall back to using the \f(CW\*(C`Code\*(C'\fR section for 
floating-point types (i.e. those routines with \f(CW\*(C`NoBadifNaN => 1\*(C'\fR
when \f(CW\*(C`BADVAL_USENAN\*(C'\fR is true).
.PP
The bad values for the integer types
are now stored in a structure within the Core \s-1PDL\s0 structure
\&\- \f(CW\*(C`PDL.bvals\*(C'\fR (eg \fIBasic/Core/pdlcore.h.PL\fR); see also 
\&\f(CW\*(C`typedef badvals\*(C'\fR in \fIBasic/Core/pdl.h.PL\fR and the
\&\s-1BOOT\s0 code of \fIBasic/Core/Core.xs.PL\fR where the values are initialised to 
(hopefully) sensible values.
See \fIPDL/Bad/bad.pd\fR for read/write routines to the values.
.PP
The addition of the \f(CW\*(C`BADVAL_PER_PDL\*(C'\fR option has resulted in additional
changes to the internals of piddles. These changes are not documented yet.
.SS "Why not make a \s-1PDL\s0 subclass?"
.IX Subsection "Why not make a PDL subclass?"
The support for bad values could have been done as a \s-1PDL\s0 sub-class.
The advantage of this approach would be that you only load in the code 
to handle bad values if you actually want to use them.
The downside is that the code then gets separated: any bug fixes/improvements
have to be done to the code in two different files.  With the present approach
the code is in the same \f(CW\*(C`pp_def\*(C'\fR function (although there is still the problem
that both \f(CW\*(C`Code\*(C'\fR and \f(CW\*(C`BadCode\*(C'\fR sections need updating).
.SS "Default bad values"
.IX Subsection "Default bad values"
The default/original bad values are set to (taken from the Starlink
distribution):
.PP
.Vb 1
\&  #include <limits.h>
\&
\&  PDL_Byte    ==  UCHAR_MAX
\&  PDL_Short   ==   SHRT_MIN
\&  PDL_Ushort  ==  USHRT_MAX
\&  PDL_Long    ==    INT_MIN
.Ve
.PP
If \f(CW\*(C`BADVAL_USENAN == 0\*(C'\fR, then we also have
.PP
.Vb 2
\&  PDL_Float   ==   \-FLT_MAX
\&  PDL_Double  ==   \-DBL_MAX
.Ve
.PP
otherwise all of \f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+Inf\*(C'\fR, and
\&\f(CW\*(C`\-Inf\*(C'\fR are taken to be bad for floating-point types. 
In this case, the bad value can't be changed, unlike the 
integer types.
.SS "How do I change a routine to handle bad values?"
.IX Subsection "How do I change a routine to handle bad values?"
Examples can be found in most of the \fI*.pd\fR files in \fIBasic/\fR (and
hopefully many more places soon!). 
Some of the logic might appear a bit unclear \- that's probably because it
is! Comments appreciated.
.PP
All routines should automatically propagate the bad status flag to output
piddles, unless you declare otherwise.
.PP
If a routine explicitly deals with bad values, you must provide this option
to pp_def:
.PP
.Vb 1
\&   HandleBad => 1
.Ve
.PP
This ensures that the correct variables are initialised for the \f(CW$ISBAD\fR etc
macros. It is also used by the automatic document-creation routines to
provide default information on the bad value support of a routine without
the user having to type it themselves (this is in its early stages).
.PP
To flag a routine as \s-1NOT\s0 handling bad values, use
.PP
.Vb 1
\&   HandleBad => 0
.Ve
.PP
This \fIshould\fR cause the routine to print a warning if it's sent any piddles
with the bad flag set. Primitive's \f(CW\*(C`intover\*(C'\fR has had this set \- since it
would be awkward to convert \- but I've not tried it out to see if it works.
.PP
If you want to handle bad values but not set the state of all the output
piddles, or if it's only one input piddle that's important, then look
at the \s-1PP\s0 rules \f(CW\*(C`NewXSFindBadStatus\*(C'\fR and \f(CW\*(C`NewXSCopyBadStatus\*(C'\fR and the
corresponding \f(CW\*(C`pp_def\*(C'\fR options:
.IP "FindBadStatusCode" 4
.IX Item "FindBadStatusCode"
By default, \f(CW\*(C`FindBadStatusCode\*(C'\fR creates code which sets 
\&\f(CW\*(C`$PRIV(bvalflag)\*(C'\fR depending on the state of the bad flag
of the input piddles: see \f(CW\*(C`findbadstatus\*(C'\fR in \fIBasic/Gen/PP.pm\fR.
User-defined code should also store the value of \f(CW\*(C`bvalflag\*(C'\fR
in the \f(CW\*(C`$BADFLAGCACHE()\*(C'\fR variable.
.IP "CopyBadStatusCode" 4
.IX Item "CopyBadStatusCode"
The default code here is a bit simpler than for \f(CW\*(C`FindBadStatusCode\*(C'\fR:
the bad flag of the output piddles are set if 
\&\f(CW\*(C`$BADFLAGCACHE()\*(C'\fR is true after the code has been
evaluated.  Sometimes \f(CW\*(C`CopyBadStatusCode\*(C'\fR is set to an empty string,
with the responsibility of setting the badflag of the output piddle
left to the \f(CW\*(C`BadCode\*(C'\fR section (e.g. the \f(CW\*(C`xxxover\*(C'\fR routines
in \fIBasic/Primitive/primitive.pd\fR).
.Sp
Prior to \s-1PDL 2.4.3\s0 we used \f(CW\*(C`$PRIV(bvalflag)\*(C'\fR
instead of \f(CW\*(C`$BADFLAGCACHE()\*(C'\fR. This is dangerous since the \f(CW\*(C`$PRIV()\*(C'\fR
structure is not guaranteed to be valid at this point in the
code.
.PP
If you have a routine that you want to be able to use as in-place, look
at the routines in \fIbad.pd\fR (or \fIops.pd\fR)
which use the \f(CW\*(C`in\-place\*(C'\fR option to see how the
bad flag is propagated to children using the \f(CW\*(C`xxxBadStatusCode\*(C'\fR options.
I decided not to automate this as rules would be a
little complex, since not every in-place op will need to propagate the 
badflag (eg unary functions).
.PP
If the option
.PP
.Vb 1
\&   HandleBad => 1
.Ve
.PP
is given, then many things happen.  For integer types, the readdata code 
automatically creates a variable called \f(CW\*(C`<pdl name>_badval\*(C'\fR, 
which contains the bad value for that piddle (see
\&\f(CW\*(C`get_xsdatapdecl()\*(C'\fR in \fIBasic/Gen/PP/PdlParObjs.pm\fR).  However, do not 
hard code this name into your code!
Instead use macros (thanks to Tuomas for the suggestion):
.PP
.Vb 3
\&  \*(Aq$ISBAD(a(n=>1))\*(Aq  expands to \*(Aq$a(n=>1) == a_badval\*(Aq
\&  \*(Aq$ISGOOD(a())\*(Aq                \*(Aq$a()     != a_badval\*(Aq
\&  \*(Aq$SETBAD(bob())\*(Aq              \*(Aq$bob()    = bob_badval\*(Aq
.Ve
.PP
well, the \f(CW\*(C`$a(...)\*(C'\fR is expanded as well. Also, you can use a \f(CW\*(C`$\*(C'\fR before the
pdl name, if you so wish, but it begins to look like line noise \-
eg \f(CW\*(C`$ISGOOD($a())\*(C'\fR.
.PP
If you cache a piddle value in a variable \*(-- eg \f(CW\*(C`index\*(C'\fR in \fIslices.pd\fR \*(--
the following routines are useful:
.PP
.Vb 3
\&   \*(Aq$ISBADVAR(c_var,pdl)\*(Aq       \*(Aqc_var == pdl_badval\*(Aq
\&   \*(Aq$ISGOODVAR(c_var,pdl)\*(Aq      \*(Aqc_var != pdl_badval\*(Aq
\&   \*(Aq$SETBADVAR(c_var,pdl)\*(Aq      \*(Aqc_var  = pdl_badval\*(Aq
.Ve
.PP
The following have been introduced, They may need playing around with to 
improve their use.
.PP
.Vb 3
\&  \*(Aq$PPISBAD(CHILD,[i])          \*(AqCHILD_physdatap[i] == CHILD_badval\*(Aq
\&  \*(Aq$PPISGOOD(CHILD,[i])         \*(AqCHILD_physdatap[i] != CHILD_badval\*(Aq
\&  \*(Aq$PPSETBAD(CHILD,[i])         \*(AqCHILD_physdatap[i]  = CHILD_badval\*(Aq
.Ve
.PP
If \f(CW\*(C`BADVAL_USENAN\*(C'\fR is set, then 
it's a bit different for \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`double\*(C'\fR, where we consider
\&\f(CW\*(C`NaN\*(C'\fR, \f(CW\*(C`+Inf\*(C'\fR, and \f(CW\*(C`\-Inf\*(C'\fR all to be bad. In this case:
.PP
.Vb 3
\&  ISBAD   becomes   finite(piddle) == 0
\&  ISGOOD            finite(piddle) != 0
\&  SETBAD            piddle          = NaN
.Ve
.PP
where the value for NaN is discussed below in
Handling NaN values.
.PP
This all means that you can change
.PP
.Vb 1
\&   Code => \*(Aq$a() = $b() + $c();\*(Aq
.Ve
.PP
to
.PP
.Vb 5
\&   BadCode => \*(Aqif ( $ISBAD(b()) || $ISBAD(c()) ) { 
\&                 $SETBAD(a()); 
\&               } else {
\&                 $a() = $b() + $c();
\&               }\*(Aq
.Ve
.PP
leaving Code as it is. PP::PDLCode will then create a loop something like
.PP
.Vb 5
\&   if ( _\|_trans\->bvalflag ) {
\&        threadloop over BadCode
\&   } else { 
\&        threadloop over Code
\&   }
.Ve
.PP
(it's probably easier to just look at the \fI.xs\fR file to see what goes on).
.SS "Going beyond the Code section"
.IX Subsection "Going beyond the Code section"
Similar to \f(CW\*(C`BadCode\*(C'\fR, there's \f(CW\*(C`BadBackCode\*(C'\fR, and \f(CW\*(C`BadRedoDimsCode\*(C'\fR.
.PP
Handling \f(CW\*(C`EquivCPOffsCode\*(C'\fR is a bit different: under the assumption that the
only access to data is via the \f(CW\*(C`$EQUIVCPOFFS(i,j)\*(C'\fR macro, then we can 
automatically create the 'bad' version of it; see the \f(CW\*(C`[EquivCPOffsCode]\*(C'\fR
and \f(CW\*(C`[Code]\*(C'\fR rules in \s-1PDL::PP\s0.
.SS "Macro access to the bad flag of a piddle"
.IX Subsection "Macro access to the bad flag of a piddle"
Macros have been provided to provide access to the bad-flag status of 
a pdl:
.PP
.Vb 2
\&  \*(Aq$PDLSTATEISBAD(a)\*(Aq    \-> \*(Aq($PDL(a)\->state & PDL_BADVAL) > 0\*(Aq
\&  \*(Aq$PDLSTATEISGOOD(a)\*(Aq      \*(Aq($PDL(a)\->state & PDL_BADVAL) == 0\*(Aq
\&
\&  \*(Aq$PDLSTATESETBAD(a)\*(Aq      \*(Aq$PDL(a)\->state |= PDL_BADVAL\*(Aq
\&  \*(Aq$PDLSTATESETGOOD(a)\*(Aq     \*(Aq$PDL(a)\->state &= ~PDL_BADVAL\*(Aq
.Ve
.PP
For use in \f(CW\*(C`xxxxBadStatusCode\*(C'\fR (+ other stuff that goes into the \s-1INIT:\s0 section)
there are:
.PP
.Vb 2
\&  \*(Aq$SETPDLSTATEBAD(a)\*(Aq       \-> \*(Aqa\->state |= PDL_BADVAL\*(Aq
\&  \*(Aq$SETPDLSTATEGOOD(a)\*(Aq      \-> \*(Aqa\->state &= ~PDL_BADVAL\*(Aq
\&
\&  \*(Aq$ISPDLSTATEBAD(a)\*(Aq        \-> \*(Aq((a\->state & PDL_BADVAL) > 0)\*(Aq
\&  \*(Aq$ISPDLSTATEGOOD(a)\*(Aq       \-> \*(Aq((a\->state & PDL_BADVAL) == 0)\*(Aq
.Ve
.PP
In \s-1PDL 2.4.3\s0 the \f(CW\*(C`$BADFLAGCACHE()\*(C'\fR macro was introduced for use in
\&\f(CW\*(C`FindBadStatusCode\*(C'\fR and \f(CW\*(C`CopyBadStatusCode\*(C'\fR.
.SS "Handling NaN values"
.IX Subsection "Handling NaN values"
There are two issues:
.IP "NaN as the bad value" 4
.IX Item "NaN as the bad value"
which is done.  To select, set \f(CW\*(C`BADVAL_USENAN\*(C'\fR to 1 in perldl.conf;
a value of 0 falls back to treating the floating-point types the
same as the integers.  I need to do some benchmarks to see which is faster,
and whether it's dependent on machines (Linux seems to slow down much
more than my Sparc machine in some very simple tests I did).
.IP "Ignoring BadCode sections" 4
.IX Item "Ignoring BadCode sections"
which is \fInot\fR.
.PP
For \fIsimple\fR routines processing floating-point numbers, we should let
the computer process the bad values (i.e. \f(CW\*(C`NaN\*(C'\fR and \f(CW\*(C`Inf\*(C'\fR values) instead
of using the code in the \f(CW\*(C`BadCode\*(C'\fR section.  Many such routines have
been labeled using \f(CW\*(C`NoBadifNaN => 1\*(C'\fR; however this is currently 
\&\fIignored\fR by \s-1PDL::PP.\s0
.PP
For these routines, we want to use the \f(CW\*(C`Code\*(C'\fR section if
.PP
.Vb 2
\&  the piddle does not have its bad flag set
\&  the datatype is a float or double
.Ve
.PP
otherwise we use the \f(CW\*(C`BadCode\*(C'\fR section.  This is \fI\s-1NOT IMPLEMENTED\s0\fR, as
it will require reasonable hacking of PP::PDLCode!
.PP
There's also the problem of how we handle 'exceptions' \- since \f(CW\*(C`$x = pdl(2) / pdl(0)\*(C'\fR
produces a bad value but doesn't update the badflag value of the piddle. 
Can we catch an exception, or do we have to trap for this
(e.g. search for \f(CW\*(C`exception\*(C'\fR in \fIBasic/Ops/ops.pd\fR)?
.PP
Checking for \f(CW\*(C`Nan\*(C'\fR, and \f(CW\*(C`Inf\*(C'\fR is done by using the \f(CW\*(C`finite()\*(C'\fR
system call.  If you want to set a value to the \f(CW\*(C`NaN\*(C'\fR value, the
following bit of code can be used (this can be found in
both \fIBasic/Core/Core.xs.PL\fR and \fIBasic/Bad/bad.pd\fR):
.PP
.Vb 3
\&  /* for big\-endian machines */
\&  static union { unsigned char _\|_c[4]; float _\|_d; } 
\&        _\|_pdl_nan = { { 0x7f, 0xc0, 0, 0 } };
\&
\&  /* for little\-endian machines */
\&  static union { unsigned char _\|_c[4]; float _\|_d; } 
\&        _\|_pdl_nan = { { 0, 0, 0xc0, 0x7f } };
.Ve
.PP
This approach should probably be replaced by library routines such as
\&\f(CW\*(C`nan("")\*(C'\fR or \f(CW\*(C`atof("NaN")\*(C'\fR.
.PP
To find out whether a particular machine is big endian, use the
routine \f(CW\*(C`PDL::Core::Dev::isbigendian()\*(C'\fR.
.SH "WHAT ABOUT DOCUMENTATION?"
.IX Header "WHAT ABOUT DOCUMENTATION?"
One of the strengths of \s-1PDL\s0 is its on-line documentation. The aim is to use
this system to provide information on how/if a routine supports bad values:
in many cases \f(CW\*(C`pp_def()\*(C'\fR contains all the information anyway, so the 
function-writer doesn't need to do anything at all! For the cases when this is
not sufficient, there's the \f(CW\*(C`BadDoc\*(C'\fR option. For code written at
the Perl level \- i.e. in a .pm file \- use the \f(CW\*(C`=for bad\*(C'\fR pod directive.
.PP
This information will be available via man/pod2man/html documentation. It's also
accessible from the \f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR shells \- using the \f(CW\*(C`badinfo\*(C'\fR command \- and the \f(CW\*(C`pdldoc\*(C'\fR
shell command \- using the \f(CW\*(C`\-b\*(C'\fR option.
.PP
This support is at a very early stage \- i.e. not much thought has gone into it:
comments are welcome; improvements to the code preferred ;) One awkward problem
is for \fI*.pm\fR code: you have to write a \fI*.pm.PL\fR file which only inserts the 
\&\f(CW\*(C`=for bad\*(C'\fR directive (+ text) if bad value support is compiled in. In fact, this
is a pain when handling bad values at the Perl, rather than \s-1PDL::PP,\s0 level: perhaps
I should just scrap the \f(CW\*(C`WITH_BADVAL\*(C'\fR option...
.SH "CURRENT ISSUES"
.IX Header "CURRENT ISSUES"
There are a number of areas that need work, user input, or both!  They are 
mentioned elsewhere in this document, but this is just to make sure they don't get lost.
.SS "Trapping invalid mathematical operations"
.IX Subsection "Trapping invalid mathematical operations"
Should we add exceptions to the functions in \f(CW\*(C`PDL::Ops\*(C'\fR to
set the output bad for out-of-range input values?
.PP
.Vb 1
\& pdl> p log10(pdl(10,100,\-1))
.Ve
.PP
I would like the above to produce \*(L"[1 2 \s-1BAD\s0]\*(R", but this would
slow down operations on \fIall\fR piddles.  
We could check for \f(CW\*(C`NaN\*(C'\fR/\f(CW\*(C`Inf\*(C'\fR values after the operation,
but I doubt that would be any faster.
.SS "Integration with NaN"
.IX Subsection "Integration with NaN"
When \f(CW\*(C`BADVAL_USENAN\*(C'\fR is true, the routines in \f(CW\*(C`PDL::Ops\*(C'\fR should
just fall through to the \f(CW\*(C`Code\*(C'\fR section \- i.e. don't use \f(CW\*(C`BadCode\*(C'\fR \-
for \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`double\*(C'\fR data types.
.SS "Global versus per-piddle bad values"
.IX Subsection "Global versus per-piddle bad values"
I think all that's needed is to change the routines in
\&\f(CW\*(C`Basic/Core/pdlconv.c.PL\*(C'\fR, although there's bound to be complications.
It would also mean that the pdl structure would need to have a
variable to store its bad value, which would mean binary incompatibility
with previous versions of \s-1PDL\s0 with bad value support.
.PP
As of 17 March 2006, \s-1PDL\s0 contains the \fBexperimental\fR \f(CW\*(C`BADVAL_PER_PDL\*(C'\fR
configuration option which, if selected, adds per-piddle bad values.
.SS "Dataflow of the badflag"
.IX Subsection "Dataflow of the badflag"
Currently changes to the bad flag are propagated to the children of a piddle,
but perhaps they should also be passed on to the parents as well. With the
advent of per-piddle bad values we need to consider how to handle changes
to the value used to represent bad items too.
.SH "EVERYTHING ELSE"
.IX Header "EVERYTHING ELSE"
The build process has been affected. The following files are
now created during the build:
.PP
.Vb 5
\&  Basic/Core/pdlcore.h      pdlcore.h.PL
\&             pdlcore.c      pdlcore.c.PL
\&             pdlapi.c       pdlapi.c.PL
\&             Core.xs        Core.xs.PL
\&             Core.pm        Core.pm.PL
.Ve
.PP
Several new files have been added:
.PP
.Vb 1
\&  Basic/Pod/BadValues.pod (i.e. this file)
\&
\&  t/bad.t
\&
\&  Basic/Bad/
\&  Basic/Bad/Makefile.PL
\&            bad.pd
.Ve
.PP
etc
.SH "TODO/SUGGESTIONS"
.IX Header "TODO/SUGGESTIONS"
.IP "\(bu" 4
Look at using per-piddle bad values.  Would mean a change to the pdl structure
(i.e. binary incompatibility) and the routines in \f(CW\*(C`Basic/Core/pdlconv.c.PL\*(C'\fR
would need changing to handle this.  Most other routines \fIshould not\fR
need to be changed ...
.Sp
See the \fBexperimental\fR \f(CW\*(C`BADVAL_PER_PDL\*(C'\fR option.
.IP "\(bu" 4
what to do about \f(CW\*(C`$y = pdl(\-2); $x = log10($y)\*(C'\fR \- \f(CW$x\fR should
be set bad, but it currently isn't.
.IP "\(bu" 4
Allow the operations in PDL::Ops to skip the check for bad values when using
NaN as a bad value and processing a floating-point piddle.
Needs a fair bit of work to PDL::PP::PDLCode.
.IP "\(bu" 4
\&\f(CW\*(C`$pdl\->baddata()\*(C'\fR now updates all the children of this piddle
as well. However, not sure what to do with parents, since:
.Sp
.Vb 2
\&  $y = $x\->slice(); 
\&  $y\->baddata(0)
.Ve
.Sp
doesn't mean that \f(CW$x\fR shouldn't have its badvalue cleared.
however, after
.Sp
.Vb 1
\&  $y\->baddata(1)
.Ve
.Sp
it's sensible to assume that the parents now get flagged as
containing bad values.
.Sp
\&\s-1PERHAPS\s0 you can only clear the bad value flag if you are \s-1NOT\s0
a child of another piddle, whereas if you set the flag then all
children \s-1AND\s0 parents should be set as well?
.Sp
Similarly, if you change the bad value in a piddle, should this
be propagated to parent & children? Or should you only be able to do
this on the 'top\-level' piddle? Nasty...
.IP "\(bu" 4
get some code set up to do benchmarks to see how much things are
slowed down (and to check that I haven't messed things up if
\&\f(CW\*(C`WITH_BADVAL\*(C'\fR is 0/undef).
.IP "\(bu" 4
some of the names aren't appealing \- I'm thinking of \f(CW\*(C`orig_badvalue()\*(C'\fR
in \fIBasic/Bad/bad.pd\fR in particular. Any suggestions appreciated.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Doug Burke (djburke@cpan.org), 2000, 2006.
.PP
The per-piddle bad value support is by Heiko Klein (2006).
.PP
Commercial reproduction of this documentation in a different format
is forbidden.
