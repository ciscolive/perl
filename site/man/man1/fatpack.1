.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FATPACK 1"
.TH FATPACK 1 "2019-02-18" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
fatpack \- Command line frontend for App::FatPacker
.SH "COMMANDS"
.IX Header "COMMANDS"
.SS "pack"
.IX Subsection "pack"
.Vb 1
\&  $ fatpack pack myscript.pl > myscript.packed.pl
.Ve
.PP
A shortcut to do all the work of tracing, collecting packlists,
extracting modules in fatlib, then concatenating into a packed script
\&\- in one shot. If you need more detailed controls for additional
modules, use the following commands separately (see \*(L"\s-1RECIPES\*(R"\s0).
.SS "trace"
.IX Subsection "trace"
.Vb 2
\&  $ fatpack trace [\-\-to=trace\-file|\-\-to\-stderr] [\-\-use=MODULE]
\&      myscript.pl
.Ve
.PP
Compiles myscript.pl (as in \*(L"perl \-c\*(R") and writes out a trace file containing
every module \fBrequire()\fRd during the compilation.
.PP
The trace file is called 'fatpacker.trace' by default; the \-\-to option
overrides this.
.PP
If you pass \-\-to\-stderr fatpack writes the trace to \s-1STDERR\s0 instead.
.PP
You cannot pass both \-\-to and \-\-to\-stderr.
.PP
If the \-\-use option specifies a module (or modules, if used multiple
times) those modules will be additionally included in the trace output.
.SS "packlists-for"
.IX Subsection "packlists-for"
.Vb 1
\&  $ fatpack packlists\-for Module1 Module2 Module3
.Ve
.PP
Searches your perl's \f(CW@INC\fR for .packlist files containing the .pm files for
the modules requested and emits a list of unique packlist files to \s-1STDOUT.\s0
.PP
These packlists will, in a pure cpan-installation environment, be all non-core
distributions required for those modules.
.PP
Unfortunately most vendors strip the .packlist files so if you installed
modules via e.g. apt-get you may be missing those modules; installing your
dependencies into a local::lib first is the preferred workaround.
.SS "tree"
.IX Subsection "tree"
.Vb 1
\&  $ fatpack tree fatlib packlist1 packlist2 packlist3
.Ve
.PP
Takes a list of packlist files and copies their contents into a tree at the
requested location.
.PP
This tree should be sufficient to 'use lib' to make available all modules
provided by the distributions whose packlists were specified.
.SS "file"
.IX Subsection "file"
.Vb 1
\&  $ fatpack file
.Ve
.PP
Recurses into the 'lib' and 'fatlib' directories and bundles all .pm files
found into a \s-1BEGIN\s0 block which adds a virtual \f(CW@INC\fR entry to load these files
from the bundled code rather than disk.
.SH "RECIPES"
.IX Header "RECIPES"
Current basic recipe for packing:
.PP
.Vb 4
\&  $ fatpack trace myscript.pl
\&  $ fatpack packlists\-for \`cat fatpacker.trace\` >packlists
\&  $ fatpack tree \`cat packlists\`
\&  $ fatpack file myscript.pl >myscript.packed.pl
.Ve
.SH "COPYRIGHT, LICENSE, AUTHOR"
.IX Header "COPYRIGHT, LICENSE, AUTHOR"
See the corresponding sections in App::FatPacker.
