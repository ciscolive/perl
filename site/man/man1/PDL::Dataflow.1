.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DATAFLOW 1"
.TH DATAFLOW 1 "2019-12-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Dataflow \-\- description of the dataflow philosophy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        pdl> $x = zeroes(10);
\&        pdl> $y = $x\->slice("2:4:2");
\&        pdl> $y ++;
\&        pdl> print $x;
\&        [0 0 1 0 1 0 0 0 0 0]
.Ve
.SH "WARNING"
.IX Header "WARNING"
Dataflow is very experimental. Many features of it are disabled
for 2.0, particularly families for one-directional
dataflow. If you wish to use one-directional dataflow for
something, please contact the author first and we'll work out
how to make it functional again.
.PP
Two-directional dataflow (which implements \->\fBslice()\fR etc.)
is fully functional, however. Just about any function which
returns some subset of the values in some piddle will make a binding
so that
.PP
.Vb 3
\&        $x = some piddle
\&        $y = $x\->slice("some parts");
\&        $y\->set(3,3,10);
.Ve
.PP
also changes the corresponding element in \f(CW$x\fR. \f(CW$y\fR has become effectively
a window to some sub-elements of \f(CW$x\fR. You can also define your own routines
that do different types of subsets. If you don't want \f(CW$y\fR to be a window
to \f(CW$x\fR, you must do
.PP
.Vb 1
\&        $y = $x\->slice("some parts")\->copy;
.Ve
.PP
The copying turns off all dataflow between the two piddles.
.PP
The difficulties with one-directional
dataflow are related to sequences like
.PP
.Vb 2
\&        $y = $x + 1;
\&        $y ++;
.Ve
.PP
where there are several possible outcomes and the semantics get a little
murky.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dataflow is new to \s-1PDL2.0.\s0 The basic philosophy
behind dataflow is that
.PP
.Vb 7
\&        > $x = pdl 2,3,4;
\&        > $y = $x * 2;
\&        > print $y
\&        [2 3 4]
\&        > $x\->set(0,5);
\&        > print $y;
\&        [10 3 4]
.Ve
.PP
should work. It doesn't. It was considered that doing this
might be too confusing for novices and occasional users of the language.
Therefore, you need to explicitly turn on dataflow, so
.PP
.Vb 4
\&        > $x = pdl 2,3,4;
\&        > $x\->doflow();
\&        > $y = $x * 2;
\&        ...
.Ve
.PP
produces the unexpected result. The rest of this documents
explains various features and details of the dataflow implementation.
.SH "Lazy evaluation"
.IX Header "Lazy evaluation"
When you calculate something like the above
.PP
.Vb 3
\&        > $x = pdl 2,3,4;
\&        > $x\->doflow();
\&        > $y = $x * 2;
.Ve
.PP
nothing will have been calculated at this point. Even the memory for
the contents of \f(CW$y\fR has not been allocated. Only the command
.PP
.Vb 1
\&        > print $y
.Ve
.PP
will actually cause \f(CW$y\fR to be calculated. This is important to bear
in mind when doing performance measurements and benchmarks as well
as when tracking errors.
.PP
There is an explanation for this behaviour: it may save cycles
but more importantly, imagine the following:
.PP
.Vb 7
\&        > $x = pdl 2,3,4;
\&        > $y = pdl 5,6,7;
\&        > $c = $x + $y;
\&        ...
\&        > $x\->resize(4);
\&        > $y\->resize(4);
\&        > print $c;
.Ve
.PP
Now, if \f(CW$c\fR were evaluated between the two resizes, an error condition
of incompatible sizes would occur.
.PP
What happens in the current version is that resizing \f(CW$x\fR raises
a flag in \f(CW$c:\fR \*(L"\s-1PDL_PARENTDIMSCHANGED\*(R"\s0 and \f(CW$y\fR just raises the same flag
again. When \f(CW$c\fR is next evaluated, the flags are checked and it is found
that a recalculation is needed.
.PP
Of course, lazy evaluation can sometimes make debugging more painful
because errors may occur somewhere where you'd not expect them.
A better stack trace for errors is in the works for \s-1PDL,\s0 probably
so that you can toggle a switch \f(CW$PDL::traceevals\fR and get a good trace
of where the error actually was.
.SH "Families"
.IX Header "Families"
This is one of the more intricate concepts of one-directional dataflow.
Consider the following code ($x and \f(CW$y\fR are pdls that have dataflow enabled):
.PP
.Vb 5
\&        $c = $x + $y;
\&        $e = $c + 1;
\&        $d = $c\->diagonal();
\&        $d ++;
\&        $f = $c + 1;
.Ve
.PP
What should \f(CW$e\fR and \f(CW$f\fR contain now? What about when \f(CW$x\fR is changed
and a recalculation is triggered.
.PP
In order to make dataflow work like you'd expect, a rather strange
concept must be introduced: families. Let us make a diagram:
.PP
.Vb 6
\&        a   b
\&         \e /
\&          c
\&         /|
\&        / |
\&       e  d
.Ve
.PP
This is what \s-1PDL\s0 actually has in memory after the first three lines.
When \f(CW$d\fR is changed, we want \f(CW$c\fR to change but we don't want \f(CW$e\fR to change
because it already is on the graph. It may not be clear now why you don't
want it to change but if there were 40 lines of code between the 2nd
and 4th lines, you would. So we need to make a copy of \f(CW$c\fR and \f(CW$d:\fR
.PP
.Vb 6
\&        a   b
\&         \e /
\&          c\*(Aq . . . c
\&         /|        |\e
\&        / |        | \e
\&       e  d\*(Aq . . . d  f
.Ve
.PP
Notice that we primed the original c and d, because they do not correspond
to the objects in \f(CW$c\fR and \f(CW$d\fR any more. Also, notice the dotted lines
between the two objects: when \f(CW$x\fR is changed and this diagram is re-evaluated,
\&\f(CW$c\fR really does get the value of c' with the diagonal incremented.
.PP
To generalize on the above, whenever a piddle is mutated i.e.
when its actual *value* is forcibly changed (not just the reference:
.PP
.Vb 1
\&        $d = $d + 1
.Ve
.PP
would produce a completely different result ($c and \f(CW$d\fR would not be bound
any more whereas
.PP
.Vb 1
\&        $d .= $d + 1
.Ve
.PP
would yield the same as \f(CW$d\fR++), a \*(L"family\*(R" consisting of all other piddles
joined to the mutated piddle by a two-way transformation is created
and all those are copied.
.PP
All slices or transformations that simply select a subset of the original
pdl are two-way. Matrix inverse should be. No arithmetic
operators are.
.SH "Sources"
.IX Header "Sources"
What you were told in the previous section is not quite true:
the behaviour described is not *always* what you want. Sometimes you
would probably like to have a data \*(L"source\*(R":
.PP
.Vb 3
\&        $x = pdl 2,3,4; $y = pdl 5,6,7;
\&        $c = $x + $y;
\&        line($c);
.Ve
.PP
Now, if you know that \f(CW$x\fR is going to change and that you want
its children to change with it, you can declare it into a data source
(\s-1XXX\s0 unimplemented in current version):
.PP
.Vb 1
\&        $x\->datasource(1);
.Ve
.PP
After this, \f(CW$x\fR++ or \f(CW$x\fR .= something will not create a new family
but will alter \f(CW$x\fR and cut its relation with its previous parents.
All its children will follow its current value.
.PP
So if \f(CW$c\fR in the previous section had been declared as a source,
\&\f(CW$e\fR and \f(CW$f\fR would remain equal.
.SH "Binding"
.IX Header "Binding"
A dataflow mechanism would not be very useful without the ability
to bind events onto changed data. Therefore, we provide such a mechanism:
.PP
.Vb 10
\&        > $x = pdl 2,3,4
\&        > $y = $x + 1;
\&        > $c = $y * 2;
\&        > $c\->bind( sub { print "A now: $x, C now: $c\en" } )
\&        > PDL::dowhenidle();
\&        A now: [2,3,4], C now: [6 8 10]
\&        > $x\->set(0,1);
\&        > $x\->set(1,1);
\&        > PDL::dowhenidle();
\&        A now: [1,1,4], C now: [4 4 10]
.Ve
.PP
Notice how the callbacks only get called during PDL::dowhenidle.
An easy way to interface this to Perl event loop mechanisms
(such as Tk) is being planned.
.PP
There are many kinds of uses for this feature: self-updating graphs,
for instance.
.PP
Blah blah blah \s-1XXX\s0 more explanation
.SH "Limitations"
.IX Header "Limitations"
Dataflow as such is a fairly limited addition on top of Perl.
To get a more refined addition, the internals of Perl need to be
hacked a little. A true implementation would enable flow of everything,
including
.IP "data" 12
.IX Item "data"
.PD 0
.IP "data size" 12
.IX Item "data size"
.IP "datatype" 12
.IX Item "datatype"
.IP "operations" 12
.IX Item "operations"
.PD
.PP
At the moment we only have the first two (hey, 50% in a couple of months
is not bad ;) but even this is useful by itself. However, especially
the last one is desirable since it would add the possibility
of flowing closures from place to place and would make many things
more flexible.
.PP
To get the rest working, the internals of dataflow probably need to
be changed to be a more general framework.
.PP
Additionally, it would be nice to be able to flow data in time,
lucid-like (so you could easily define all kinds of signal processing
things).
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright(C) 1997 Tuomas J. Lukka (lukka@fas.harvard.edu).
Redistribution in the same form is allowed provided that the copyright
notice stays intact but reprinting requires
a permission from the author.
