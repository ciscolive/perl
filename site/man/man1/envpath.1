.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ENVPATH 1"
.TH ENVPATH 1 "2003-10-10" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
envpath \- Advanced operations on path variables
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Run this script with the \f(CW\*(C`\-help\*(C'\fR option for usage details.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parses the command line, modifies the specified path variable(s), and
execs the remaining arguments. There are two modes, \fBsimple\fR and
\&\fBadvanced\fR:
.SS "\s-1SIMPLE MODE\s0"
.IX Subsection "SIMPLE MODE"
Simple mode presents an alternative, platform-independent syntax for
specifying paths wherein the path separator is \*(L",\*(R" and environment
variables can be expanded with \f(CW@NAME\fR@. For example
.PP
.Vb 1
\&    envpath PATH=@PATH@,/usr/ucb \-\- printenv PATH
.Ve
.PP
appends \f(CW\*(C`/usr/ucb\*(C'\fR to \f(CW$PATH\fR and execs \fIprintenv \s-1PATH\s0\fR. The \f(CW\*(C`\-\-\*(C'\fR
is optional.
.PP
You can also specify prepending or appending by using \f(CW\*(C`+=\*(C'\fR or \f(CW\*(C`=+\*(C'\fR
respectively:
.PP
.Vb 2
\&    # place /usr/ucb at the front
\&    envpath PATH+=/usr/ucb \-\- printenv PATH
\&
\&    # place /usr/ucb at the back
\&    envpath PATH=+/usr/ucb \-\- printenv PATH
.Ve
.PP
Simple mode requires only this script; it does not require Env::Path
to be installed.
.SS "\s-1ADVANCED MODE\s0"
.IX Subsection "ADVANCED MODE"
Advanced mode basically provides command-line access to the features of
Env::Path (see), which must be installed. The \f(CW\*(C`\-E\*(C'\fR flag selects the
path variable to operate on and other flags specify operations on it.
E.g.
.PP
.Vb 1
\&    envpath \-E MANPATH \-A /tmp \-R /usr/share/man \-N \-U \-\- man ...
.Ve
.PP
would take \s-1MANPATH,\s0 append /tmp to it, remove any references to
\&\f(CW\*(C`/usr/share/man\*(C'\fR, remove any dirs which don't exist (\f(CW\*(C`\-N\*(C'\fR) and
remove redundant entries (\f(CW\*(C`\-U\*(C'\fR) before running \fIman\fR.
.PP
The \-Whence option allows patterns. Thus
.PP
.Vb 1
\&    envpath \-W "cat*"
.Ve
.PP
would find all programs on \s-1PATH\s0 which match cat*.
.SH "CLEARCASE WINKINS"
.IX Header "CLEARCASE WINKINS"
A big part of the motivation for this script was for use with ClearCase
builds; iff you know or care about ClearCase read on. Typically, during
builds (and not just with ClearCase), pathvars such as \s-1PATH, CLASSPATH,\s0
and \s-1LD_LIBRARY_PATH\s0 must be strictly controlled.  One choice is to
force static values of these into the environment during the build
process, another is to simply require/expect users to set their paths
appropriately. Each of these can lead to subtle build or runtime
errors, however, and makes it hard for new users to get up to speed
since their personal environment must be just so.
.PP
Another common choice is to use only full pathnames within the
Makefile, avoiding reliance on search paths at all. This is often the
best way to go but can suppress ClearCase winkins.  For example, say
you're generating ascii files of some type with a binary executable you
just built:
.PP
$(\s-1INCDIR\s0)/foo.h: $(\s-1BINDIR\s0)/foomaker
	$(\s-1BINDIR\s0)/foomaker ...
.PP
The problem with this is that $(\s-1BINDIR\s0) likely contains a platform part
such as 'solaris' or 'hpux', which makes it impossible to wink in the
foo.h file on other platforms even though it's ascii. This same thing
could come up even with a standard pre-built utility that's in
different places on different platforms; \f(CW\*(C`yacc\*(C'\fR, for instance, is in
/usr/bin on Linux and /usr/ccs/bin on Solaris.
.PP
You could modify the path on the fly:
.PP
$(\s-1INCDIR\s0)/foo.h: $(\s-1BINDIR\s0)/foomaker
	PATH=$(\s-1BINDIR\s0)$(\s-1SEP\s0)$$PATH foomaker ...
.PP
but this suffers from the same problem: since $(\s-1BINDIR\s0) and \f(CW$PATH\fR are
expanded literally within the build script they'll suppress winkins.
Here's a solution using \fIenvpath\fR:
.PP
$(\s-1INCDIR\s0)/foo.h: $(\s-1BINDIR\s0)/foomaker
	envpath PATH=@BINDIR@,@PATH@ foomaker ...
.PP
This hides the evaluation of \s-1BINDIR\s0 and \s-1PATH\s0 such that \fIclearmake\fR
never sees anything but the literals, thus clearing the field for
winkins. Of course \fIenvpath\fR is capable of doing more than this, but
it's the original reason it was written.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Boyce <dsbperl \s-1AT\s0 boyski.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2001 David Boyce. All rights reserved.  This Perl
program is free software; you may redistribute and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1), \*(L"perldoc Env::Path\*(R"
