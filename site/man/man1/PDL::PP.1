.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PP 1"
.TH PP 1 "2019-12-08" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::PP \- Generate PDL routines from concise descriptions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
e.g.
.PP
.Vb 11
\&        pp_def(
\&                \*(Aqsumover\*(Aq,
\&                Pars => \*(Aqa(n); [o]b();\*(Aq,
\&                Code => q{
\&                        double tmp=0;
\&                        loop(n) %{
\&                                tmp += $a();
\&                        %}
\&                        $b() = tmp;
\&                },
\&        );
\&
\&        pp_done();
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Here is a quick reference list of the functions provided by \s-1PDL::PP.\s0
.SS "pp_add_boot"
.IX Subsection "pp_add_boot"
Add code to the \s-1BOOT\s0 section of generated \s-1XS\s0 file
.SS "pp_add_exported"
.IX Subsection "pp_add_exported"
Add functions to the list of exported functions
.SS "pp_add_isa"
.IX Subsection "pp_add_isa"
Add entries to the \f(CW@ISA\fR list
.SS "pp_addbegin"
.IX Subsection "pp_addbegin"
Sets code to be added at the top of the generate .pm file
.SS "pp_addhdr"
.IX Subsection "pp_addhdr"
Add code and includes to C section of the generated \s-1XS\s0 file
.SS "pp_addpm"
.IX Subsection "pp_addpm"
Add code to the generated .pm file
.SS "pp_addxs"
.IX Subsection "pp_addxs"
Add extra \s-1XS\s0 code to the generated \s-1XS\s0 file
.SS "pp_beginwrap"
.IX Subsection "pp_beginwrap"
Add BEGIN-block wrapping to code for the generated .pm file
.SS "pp_bless"
.IX Subsection "pp_bless"
Sets the package to which the \s-1XS\s0 code is added (default is \s-1PDL\s0)
.SS "pp_boundscheck"
.IX Subsection "pp_boundscheck"
Control state of \s-1PDL\s0 bounds checking activity
.SS "pp_core_importList"
.IX Subsection "pp_core_importList"
Specify what is imported from PDL::Core
.SS "pp_def"
.IX Subsection "pp_def"
Define a new \s-1PDL\s0 function
.SS "pp_deprecate_module"
.IX Subsection "pp_deprecate_module"
Add runtime and \s-1POD\s0 warnings about a module being deprecated
.SS "pp_done"
.IX Subsection "pp_done"
Mark the end of \s-1PDL::PP\s0 definitions in the file
.SS "pp_export_nothing"
.IX Subsection "pp_export_nothing"
Clear out the export list for your generated module
.SS "pp_line_numbers"
.IX Subsection "pp_line_numbers"
Add line number information to simplify debugging of \s-1PDL::PP\s0 code
.SS "pp_setversion"
.IX Subsection "pp_setversion"
Set the version for .pm and .xs files
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Why do we need \s-1PP\s0? Several reasons: firstly, we want to be able to
generate subroutine code for each of the \s-1PDL\s0 datatypes (PDL_Byte,
PDL_Short, etc).  \s-1AUTOMATICALLY.\s0  Secondly, when referring to slices
of \s-1PDL\s0 arrays in Perl (e.g. \f(CW\*(C`$x\->slice(\*(Aq0:10:2,:\*(Aq)\*(C'\fR or other things such
as transposes) it is nice to be able to do this transparently and to
be able to do this 'in\-place' \- i.e, not to have to make a memory copy
of the section. \s-1PP\s0 handles all the necessary element and offset
arithmetic for you. There are also the notions of threading (repeated
calling of the same routine for multiple slices, see PDL::Indexing)
and dataflow (see PDL::Dataflow) which use of \s-1PP\s0 allows.
.PP
In much of what follows we will assume familiarity of the reader with
the concepts of implicit and explicit threading and index manipulations
within \s-1PDL.\s0 If you have not yet heard of these concepts or are not very
comfortable with them it is time to check PDL::Indexing.
.PP
As you may appreciate from its name \s-1PDL::PP\s0 is a Pre-Processor, i.e.
it expands code via substitutions to make real C\-code. Technically, the
output is \s-1XS\s0 code (see \fIperlxs\fR) but that is very close to C.
.PP
So how do you use \s-1PP\s0? Well for the most part you just write ordinary C
code except for special \s-1PP\s0 constructs which take the form:
.PP
.Vb 1
\&   $something(something else)
.Ve
.PP
or:
.PP
.Vb 3
\&   PPfunction %{
\&     <stuff>
\&   %}
.Ve
.PP
The most important \s-1PP\s0 construct is the form \f(CW\*(C`$array()\*(C'\fR. Consider the very
simple \s-1PP\s0 function to sum the elements of a 1D vector (in fact this is
very similar to the actual code used by 'sumover'):
.PP
.Vb 11
\&   pp_def(\*(Aqsumit\*(Aq,
\&       Pars => \*(Aqa(n);  [o]b();\*(Aq,
\&       Code => q{
\&           double tmp;
\&           tmp = 0;
\&           loop(n) %{
\&               tmp += $a();
\&           %}
\&           $b() = tmp;
\&       }
\&   );
.Ve
.PP
What's going on? The \f(CW\*(C`Pars =>\*(C'\fR line is very important for \s-1PP\s0 \- it
specifies all the arguments and their dimensionality. We call
this the \fIsignature\fR of the \s-1PP\s0 function (compare also the explanations in
PDL::Indexing).  In this case the
routine takes a 1\-D function as input and returns a 0\-D scalar as
output.  The \f(CW\*(C`$a()\*(C'\fR \s-1PP\s0 construct is used to access elements of the array
a(n) for you \- \s-1PP\s0 fills in all the required C code.
.PP
You will notice that we are using the \f(CW\*(C`q{}\*(C'\fR single-quote operator. This is
not an accident. You generally want to use single quotes to denote your
\&\s-1PP\s0 Code sections. \s-1PDL::PP\s0 uses \f(CW\*(C`$var()\*(C'\fR for its parsing and if you don't
use single quotes, Perl will try to interpolate \f(CW\*(C`$var()\*(C'\fR. Also, using the
single quote \f(CW\*(C`q\*(C'\fR operator with curly braces makes it look like you are
creating a code block, which is What You Mean. (Perl is smart enough to look
for nested curly braces and not close the quote until it finds the matching
curly brace, so it's safe to have nested blocks.) Under other circumstances,
such as when you're stitching together a Code block using string
concatenations, it's often easiest to use real single quotes as
.PP
.Vb 1
\& Code => \*(Aqsomething\*(Aq.$interpolatable.\*(Aqsomethingelse;\*(Aq
.Ve
.PP
In the simple case here where all elements are accessed the \s-1PP\s0 construct
\&\f(CW\*(C`loop(n) %{ ... %}\*(C'\fR is used to loop over all elements in dimension \f(CW\*(C`n\*(C'\fR.
Note this feature of \s-1PP: ALL DIMENSIONS ARE SPECIFIED BY NAME.\s0
.PP
This is made clearer if we avoid the \s-1PP\s0 \fBloop()\fR construct
and write the loop explicitly using conventional C:
.PP
.Vb 10
\&   pp_def(\*(Aqsumit\*(Aq,
\&       Pars => \*(Aqa(n);  [o]b();\*(Aq,
\&       Code => q{
\&           PDL_Indx i,n_size;
\&           double tmp;
\&           n_size = $SIZE(n);
\&           tmp = 0;
\&           for(i=0; i<n_size; i++) {
\&               tmp += $a(n=>i);
\&           }
\&           $b() = tmp;
\&       },
\&   );
.Ve
.PP
which does the same as before, but is more long-winded.
You can see to get element \f(CW\*(C`i\*(C'\fR of a() we say \f(CW\*(C`$a(n=>i)\*(C'\fR \- we are
specifying the dimension by name \f(CW\*(C`n\*(C'\fR. In 2D we might say:
.PP
.Vb 4
\&   Pars=>\*(Aqa(m,n);\*(Aq,
\&      ...
\&      tmp += $a(m=>i,n=>j);
\&      ...
.Ve
.PP
The syntax \f(CW\*(C`m=>i\*(C'\fR borrows from Perl hashes, which are in fact
used in the implementation of \s-1PP.\s0 One could also say
\&\f(CW\*(C`$a(n=>j,m=>i)\*(C'\fR as order is not important.
.PP
You can also see in the above example the use of another \s-1PP\s0
construct \- \f(CW$SIZE(n)\fR to get the length of the dimension \f(CW\*(C`n\*(C'\fR.
.PP
It should, however, be noted that you shouldn't write an explicit C\-loop
when you could have used the \s-1PP\s0 \f(CW\*(C`loop\*(C'\fR construct since \s-1PDL::PP\s0 checks
automatically the loop limits for you, usage of \f(CW\*(C`loop\*(C'\fR makes the code more
concise, etc. But there are certainly situations where you need explicit
control of the loop and now you know how to do it ;).
.PP
To revisit 'Why \s-1PP\s0?' \- the above code for \fBsumit()\fR will be
generated for each data-type. It will operate on slices
of arrays 'in\-place'. It will thread automatically \- e.g. if
a 2D array is given it will be called repeatedly for each
1D row (again check PDL::Indexing for the details of threading).
And then b() will be a 1D array of sums of each row.
We could call it with \f(CW$x\fR\->xchg(0,1) to sum the columns instead.
And Dataflow tracing etc. will be available.
.PP
You can see \s-1PP\s0 saves the programmer from writing a lot of
needlessly repetitive C\-code \*(-- in our opinion this is
one of the best features of \s-1PDL\s0 making writing
new C subroutines for \s-1PDL\s0 an amazingly concise exercise. A second reason is
the ability to make \s-1PP\s0 expand your concise code definitions into different
C code based on the needs of the computer architecture in question. Imagine
for example you are lucky to have a supercomputer at your hands; in that
case you want \s-1PDL::PP\s0 certainly to generate code that takes advantage of
the vectorising/parallel computing features of your machine (this a project
for the future). In any case, the bottom line is that your unchanged code
should still expand to working \s-1XS\s0 code even if the internals of \s-1PDL\s0
changed.
.PP
Also, because you are generating the code in an actual Perl script,
there are many fun things that you can do. Let's say that you need
to write both sumit (as above) and multit. With a little bit of creativity,
we can do
.PP
.Vb 10
\&   for({Name => \*(Aqsumit\*(Aq, Init => \*(Aq0\*(Aq, Op => \*(Aq+=\*(Aq},
\&       {Name => \*(Aqmultit\*(Aq, Init => \*(Aq1\*(Aq, Op => \*(Aq*=\*(Aq}) {
\&           pp_def($_\->{Name},
\&                   Pars => \*(Aqa(n);  [o]b();\*(Aq,
\&                   Code => \*(Aq
\&                        double tmp;
\&                        tmp = \*(Aq.$_\->{Init}.\*(Aq;
\&                        loop(n) %{
\&                          tmp \*(Aq.$_\->{Op}.\*(Aq $a();
\&                        %}
\&                        $b() = tmp;
\&           \*(Aq);
\&   }
.Ve
.PP
which defines both the functions easily. Now, if you later need to
change the signature or dimensionality or whatever, you only need
to change one place in your code.
Yeah, sure, your editor does have 'cut and paste' and 'search and replace'
but it's still less bothersome and definitely more difficult to
forget just one place and have strange bugs creep in.
Also, adding 'orit' (bitwise or) later is a one-liner.
.PP
And remember, you really have Perl's full abilities with you \-
you can very easily read any input file and make routines from
the information in that file. For simple cases like the above,
the author (Tjl) currently favors the hash syntax like the above \-
it's not too much more characters than the corresponding array
syntax but much easier to understand and change.
.PP
We should mention here also the ability to get the pointer to the
beginning of the data in memory \- a prerequisite for interfacing
\&\s-1PDL\s0 to some libraries. This is handled with the \f(CW\*(C`$P(var)\*(C'\fR directive,
see below.
.PP
When starting work on a new pp_def'ined function, if you make a mistake, you
will usually find a pile of compiler errors indicating line numbers in the
generated \s-1XS\s0 file. If you know how to read \s-1XS\s0 files (or if you want to learn
the hard way), you could open the generated \s-1XS\s0 file and search for the line
number with the error. However, a recent addition to \s-1PDL::PP\s0 helps report
the correct line number of your errors: \f(CW\*(C`pp_line_numbers\*(C'\fR. Working with the
original summit example, if you had a mis-spelling of tmp in your code, you
could change the (erroneous) code to something like this and the compiler
would give you much more useful information:
.PP
.Vb 11
\&   pp_def(\*(Aqsumit\*(Aq,
\&       Pars => \*(Aqa(n);  [o]b();\*(Aq,
\&       Code => pp_line_numbers(_\|_LINE_\|_, q{
\&           double tmp;
\&           tmp = 0;
\&           loop(n) %{
\&               tmp += $a();
\&           %}
\&           $b() = rmp;
\&       })
\&   );
.Ve
.PP
For the above situation, my compiler tells me:
.PP
.Vb 3
\& ...
\& test.pd:15: error: \*(Aqrmp\*(Aq undeclared (first use in this function)
\& ...
.Ve
.PP
In my example script (called test.pd), line 15 is exactly the line at which
I made my typo: \f(CW\*(C`rmp\*(C'\fR instead of \f(CW\*(C`tmp\*(C'\fR.
.PP
So, after this quick overview of the general flavour of programming
\&\s-1PDL\s0 routines using \s-1PDL::PP\s0 let's summarise in which circumstances you
should actually use this preprocessor/precompiler. You should use \s-1PDL::PP\s0
if you want to
.IP "\(bu" 3
interface \s-1PDL\s0 to some external library
.IP "\(bu" 3
write some algorithm that would be slow if coded in Perl
(this is not as often as you think; take a look at threading
and dataflow first).
.IP "\(bu" 3
be a \s-1PDL\s0 developer (and even then it's not obligatory)
.SH "WARNING"
.IX Header "WARNING"
Because of its architecture, \s-1PDL::PP\s0 can be both flexible and easy to use
on the one hand, yet exuberantly complicated at the same time. Currently,
part of the problem is that error messages are not very informative and if
something goes wrong, you'd better know what you are doing and be able to
hack your way through the internals (or be able to figure out by trial and
error what is wrong with your args to \f(CW\*(C`pp_def\*(C'\fR). Although work is being
done to produce better warnings, do not be afraid to send your questions to
the mailing list if you run into trouble.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Now that you have some idea how to use \f(CW\*(C`pp_def\*(C'\fR to define new \s-1PDL\s0 functions
it is time to explain the general syntax of \f(CW\*(C`pp_def\*(C'\fR.
\&\f(CW\*(C`pp_def\*(C'\fR takes as arguments first the name of the function
you are defining and then a hash list that can contain various keys.
.PP
Based on these keys \s-1PP\s0 generates \s-1XS\s0 code and a .pm file. The function
\&\f(CW\*(C`pp_done\*(C'\fR (see example in the \s-1SYNOPSIS\s0) is used to tell \s-1PDL::PP\s0 that there
are no more definitions in this file and it is time to generate the .xs and
 .pm file.
.PP
As a consequence, there may be several \fBpp_def()\fR calls inside a file (by
convention files with \s-1PP\s0 code have the extension .pd or .pp) but generally
only one \fBpp_done()\fR.
.PP
There are two main different types of usage of \fBpp_def()\fR,
the 'data operation' and 'slice operation' prototypes.
.PP
The 'data operation' is used to take some data, mangle it and
output some other data; this includes for example the '+' operation,
matrix inverse, sumover etc and all the examples we have talked about
in this document so far. Implicit and explicit threading and the creation
of the result are taken care of automatically in those operations. You
can even do dataflow with \f(CW\*(C`sumit\*(C'\fR, \f(CW\*(C`sumover\*(C'\fR, etc
(don't be dismayed if you don't understand the concept of dataflow
in \s-1PDL\s0 very well yet; it is still very much experimental).
.PP
The 'slice operation' is a different kind of operation: in a slice
operation, you are not changing any data, you are defining
correspondences between different elements of two piddles (examples include
the index manipulation/slicing function definitions in the file \fIslices.pd\fR
that is part of the \s-1PDL\s0 distribution; but beware, this is not introductory
level stuff).
.PP
If \s-1PDL\s0 was compiled with support for bad values (i.e. \f(CW\*(C`WITH_BADVAL => 1\*(C'\fR),
then additional keys are required for \f(CW\*(C`pp_def\*(C'\fR, as explained below.
.PP
If you are just interested in communicating with some external
library (for example some linear algebra/matrix library), you'll usually
want the 'data operation' so we are going to discuss that first.
.SH "Data operation"
.IX Header "Data operation"
.SS "A simple example"
.IX Subsection "A simple example"
In the data operation, you must know what dimensions of data
you need. First, an example with scalars:
.PP
.Vb 4
\&        pp_def(\*(Aqadd\*(Aq,
\&                Pars => \*(Aqa(); b(); [o]c();\*(Aq,
\&                Code => \*(Aq$c() = $a() + $b();\*(Aq
\&        );
.Ve
.PP
That looks a little strange but let's dissect it. The first
line is easy: we're defining a routine with the name 'add'.
The second line simply declares our parameters and the parentheses
mean that they are scalars. We call the string that defines our parameters
and their dimensionality the \fIsignature\fR of that function. For its
relevance with regard to threading and index manipulations check the
PDL::Indexing man page.
.PP
The third line is the actual operation. You need to use the
dollar signs and parentheses to refer to your parameters
(this will probably change at some point in the future, once
a good syntax is found).
.PP
These lines are all that is necessary to actually define the function
for \s-1PDL\s0 (well, actually it isn't; you additionally need to write a
Makefile.PL (see below) and build the module (something like 'perl
Makefile.PL; make'); but let's ignore that for the moment). So now you
can do
.PP
.Vb 3
\&        use MyModule;
\&        $x = pdl 2,3,4;
\&        $y = pdl 5;
\&
\&        $c = add($x,$y);
\&        # or
\&        add($x,$y,($c=null)); # Alternative form, useful if $c has been
\&                              # preset to something big, not useful here.
.Ve
.PP
and have threading work correctly (the result is \f(CW$c\fR == [7 8 9]).
.SS "The Pars section: the signature of a \s-1PP\s0 function"
.IX Subsection "The Pars section: the signature of a PP function"
Seeing the above example code you will most probably ask: what is this
strange \f(CW\*(C`$c=null\*(C'\fR syntax in the second call to our new \f(CW\*(C`add\*(C'\fR function? If
you take another look at the definition of \f(CW\*(C`add\*(C'\fR you will notice that
the third argument \f(CW\*(C`c\*(C'\fR is flagged with the qualifier \f(CW\*(C`[o]\*(C'\fR which
tells \s-1PDL::PP\s0 that this is an output argument. So the above call to
add means 'create a new \f(CW$c\fR from scratch with correct dimensions' \-
\&\f(CW\*(C`null\*(C'\fR is a special token for 'empty piddle' (you might ask why we
haven't used the value \f(CW\*(C`undef\*(C'\fR to flag this instead of the \s-1PDL\s0
specific \f(CW\*(C`null\*(C'\fR; we are currently thinking about it ;).
.PP
[This should be explained in some other section of the manual
as well!!]
The reason for having this syntax as an alternative is that if you have
really huge piddles, you can do
.PP
.Vb 6
\&        $c = PDL\->null;
\&        for(some long loop) {
\&                # munge a,b
\&                add($x,$y,$c);
\&                # munge c, put something back to x,y
\&        }
.Ve
.PP
and avoid allocating and deallocating \f(CW$c\fR each time. It is allocated
once at the first \fBadd()\fR and thereafter the memory stays until \f(CW$c\fR is
destroyed.
.PP
If you just say
.PP
.Vb 1
\&  $c =  add($x,$y);
.Ve
.PP
the code generated by \s-1PP\s0 will automatically fill in \f(CW\*(C`$c=null\*(C'\fR
and return
the result. If you want to learn more
about the reasons why \s-1PDL::PP\s0 supports this style where output arguments
are given as last arguments check the
PDL::Indexing man page.
.PP
\&\f(CW\*(C`[o]\*(C'\fR is not the only qualifier a pdl argument can have in the signature.
Another important qualifier is the \f(CW\*(C`[t]\*(C'\fR option which flags a pdl as
temporary.  What does that mean? You tell \s-1PDL::PP\s0 that this pdl is only
used for temporary results in the course of the calculation and you are
not interested in its value after the computation has been completed. But
why should \s-1PDL::PP\s0 want to know about this in the first place?  The reason
is closely related to the concepts of pdl auto creation (you heard
about that above) and implicit threading. If you use implicit threading
the dimensionality of automatically created pdls is actually larger than
that specified in the signature. With \f(CW\*(C`[o]\*(C'\fR flagged pdls will be created
so that they have the additional dimensions as required by the number
of implicit thread dimensions. When creating a temporary pdl, however,
it will always only be made big enough so that it can hold the result
for one iteration in a thread loop, i.e. as large as required by the signature.
So less memory is wasted when you flag a pdl as temporary. Secondly, you
can use output auto creation with temporary pdls even when you are using
explicit threading which is forbidden for normal output pdls flagged with
\&\f(CW\*(C`[o]\*(C'\fR (see PDL::Indexing).
.PP
Here is an example where we use the [t] qualifier. We define the function
\&\f(CW\*(C`callf\*(C'\fR that calls a C routine \f(CW\*(C`f\*(C'\fR which needs a temporary array of the
same size and type as the array \f(CW\*(C`a\*(C'\fR (sorry about the forward reference
for \f(CW$P\fR; it's a pointer access, see below) :
.PP
.Vb 6
\&  pp_def(\*(Aqcallf\*(Aq,
\&        Pars => \*(Aqa(n); [t] tmp(n); [o] b()\*(Aq,
\&        Code => \*(AqPDL_Indx ns = $SIZE(n);
\&                 f($P(a),$P(b),$P(tmp),ns);
\&                \*(Aq
\&  );
.Ve
.SS "Argument dimensions and the signature"
.IX Subsection "Argument dimensions and the signature"
Now we have just talked about dimensions of pdls and the signature. How
are they related? Let's say that we want to add a scalar + the index
number to a vector:
.PP
.Vb 6
\&        pp_def(\*(Aqadd2\*(Aq,
\&                Pars => \*(Aqa(n); b(); [o]c(n);\*(Aq,
\&                Code => \*(Aqloop(n) %{
\&                                $c() = $a() + $b() + n;
\&                         %}\*(Aq
\&        );
.Ve
.PP
There are several points to notice here: first, the \f(CW\*(C`Pars\*(C'\fR
argument now contains the \fIn\fR arguments to show that we have a single
dimensions in \fIa\fR and \fIc\fR. It is important to note that dimensions
are actual entities that are accessed by name so this declares
\&\fIa\fR and \fIc\fR to have the \fBsame\fR first dimensions. In most \s-1PP\s0 definitions
the size of named dimensions will be set from the respective dimensions
of non-output pdls (those with no \f(CW\*(C`[o]\*(C'\fR flag) but sometimes you might
want to set the size of a named dimension explicitly through an integer
parameter. See below in the description of the \f(CW\*(C`OtherPars\*(C'\fR section how
that works.
.SS "Constant argument dimensions in the signature"
.IX Subsection "Constant argument dimensions in the signature"
Suppose you want an output piddle to be created
automatically and you know that on every call its dimension
will have the same size (say 9) regardless of the dimensions
of the input piddles. In this case you use the following
syntax in the Pars section to specify the size of the dimension:
.PP
.Vb 1
\&    \*(Aq [o] y(n=9); \*(Aq
.Ve
.PP
As expected, extra dimensions required by threading will be
created if necessary. If you need to assign a named dimension according
to a more complicated formula (than a constant) you must use the 
\&\f(CW\*(C`RedoDimsCode\*(C'\fR key described below.
.SS "Type conversions and the signature"
.IX Subsection "Type conversions and the signature"
The signature also determines the type conversions that will be performed
when a \s-1PP\s0 function is invoked. So what happens when we invoke one of
our previously defined functions with pdls of different type, e.g.
.PP
.Vb 1
\&  add2($x,$y,($ret=null));
.Ve
.PP
where \f(CW$x\fR is of type \f(CW\*(C`PDL_Float\*(C'\fR and \f(CW$y\fR of type \f(CW\*(C`PDL_Short\*(C'\fR? With the signature
as shown in the definition of \f(CW\*(C`add2\*(C'\fR above the datatype of the operation
(as determined at runtime) is that of the pdl with the 'highest' type
(sequence is byte < short < ushort < long < float < double). In the add2
example the datatype of the operation is float ($x has that datatype). All
pdl arguments are then type converted to that datatype (they are not
converted inplace but a copy with the right type is created if a pdl argument
doesn't have the type of the operation).
Null pdls don't contribute a type
in the determination of the type of the operation.
However, they will be
created with the datatype of the operation; here, for example, \f(CW$ret\fR will be
of type float. You should be aware of these rules when calling \s-1PP\s0 functions
with pdls of different types to take the additional storage and runtime
requirements into account.
.PP
These type conversions are correct for most functions you normally define
with \f(CW\*(C`pp_def\*(C'\fR. However, there are certain cases where slightly modified
type conversion behaviour is desired. For these cases additional qualifiers
in the signature can be used to specify the desired properties with regard
to type conversion. These qualifiers can be combined with those we have
encountered already (the \fIcreation qualifiers\fR \f(CW\*(C`[o]\*(C'\fR and \f(CW\*(C`[t]\*(C'\fR). Let's
go through the list of qualifiers that change type conversion behaviour.
.PP
The most important is the \f(CW\*(C`indx\*(C'\fR qualifier which comes in handy when a
pdl argument represents indices into another pdl. Let's take a look at
an example from \f(CW\*(C`PDL::Ufunc\*(C'\fR:
.PP
.Vb 9
\&   pp_def(\*(Aqmaximum_ind\*(Aq,
\&          Pars => \*(Aqa(n); indx [o] b()\*(Aq,
\&          Code => \*(Aq$GENERIC() cur;
\&                   PDL_Indx curind;
\&                   loop(n) %{
\&                    if (!n || $a() > cur) {cur = $a(); curind = n;}
\&                   %}
\&                   $b() = curind;\*(Aq,
\&   );
.Ve
.PP
The function \f(CW\*(C`maximum_ind\*(C'\fR finds the index of the largest element of
a vector. If you look at the signature you notice that the output
argument \f(CW\*(C`b\*(C'\fR has been declared with the additional \f(CW\*(C`indx\*(C'\fR qualifier.
This has the following consequences for type conversions: regardless of
the type of the input pdl \f(CW\*(C`a\*(C'\fR the output pdl \f(CW\*(C`b\*(C'\fR will be of type
\&\f(CW\*(C`PDL_Indx\*(C'\fR which makes sense since \f(CW\*(C`b\*(C'\fR will represent an index into
\&\f(CW\*(C`a\*(C'\fR.
.PP
Note that 'curind' is declared as type \f(CW\*(C`PDL_Indx\*(C'\fR and not \f(CW\*(C`indx\*(C'\fR.
While most datatype declarations in the 'Pars' section use the same
name as the underlying C type, \f(CW\*(C`indx\*(C'\fR is a type which is sufficient
to handle \s-1PDL\s0 indexing operations.  For 32\-bit installs, it can be
a 32\-bit integer type.  For 64\-bit installs, it will be a 64\-bit integer
type.
.PP
Furthermore, if you call the function with an existing output
pdl \f(CW\*(C`b\*(C'\fR its type will not influence the datatype of the operation (see
above). Hence, even if \f(CW\*(C`a\*(C'\fR is of a smaller type than \f(CW\*(C`b\*(C'\fR it will not
be converted to match the type of \f(CW\*(C`b\*(C'\fR but stays untouched, which saves
memory and \s-1CPU\s0 cycles and is the right thing to do when \f(CW\*(C`b\*(C'\fR represents
indices. Also note that you can use the 'indx' qualifier together with
other qualifiers (the \f(CW\*(C`[o]\*(C'\fR and \f(CW\*(C`[t]\*(C'\fR qualifiers). Order is significant \*(--
type qualifiers precede creation qualifiers (\f(CW\*(C`[o]\*(C'\fR and \f(CW\*(C`[t]\*(C'\fR).
.PP
The above example also demonstrates typical usage of the \f(CW\*(C`$GENERIC()\*(C'\fR
macro.  It expands to the current type in a so called generic
loop. What is a generic loop? As you already heard a \s-1PP\s0 function has a
runtime datatype as determined by the type of the pdl arguments it has
been invoked with.  The \s-1PP\s0 generated \s-1XS\s0 code for this function
therefore contains a switch like \f(CW\*(C`switch (type) {case PDL_Byte: ... case
PDL_Double: ...}\*(C'\fR that selects a case based on the runtime
datatype of the function (it's called a type ``loop''
because there is a loop in \s-1PP\s0 code that generates the cases).
In any case your code is inserted once for each \s-1PDL\s0 type
into this switch statement. The \f(CW\*(C`$GENERIC()\*(C'\fR macro just expands to
the respective type in each copy of your parsed code in this \f(CW\*(C`switch\*(C'\fR
statement, e.g., in the \f(CW\*(C`case PDL_Byte\*(C'\fR section \f(CW\*(C`cur\*(C'\fR will expand to
\&\f(CW\*(C`PDL_Byte\*(C'\fR and so on for the other case statements. I guess you
realise that this is a useful macro to hold values of pdls in some
code.
.PP
There are a couple of other qualifiers with similar effects as \f(CW\*(C`indx\*(C'\fR.
For your convenience there are the \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`double\*(C'\fR qualifiers
with analogous consequences on type conversions as \f(CW\*(C`indx\*(C'\fR. Let's
assume you have a \fIvery\fR large array for which you want to compute
row and column sums with an equivalent of the \f(CW\*(C`sumover\*(C'\fR function.
However, with the normal definition of \f(CW\*(C`sumover\*(C'\fR you might run
into problems when your data is, e.g. of type short. A call like
.PP
.Vb 1
\&  sumover($large_pdl,($sums = null));
.Ve
.PP
will result in \f(CW$sums\fR be of type short and is therefore prone to
overflow errors if \f(CW$large_pdl\fR is a very large array. On the other
hand calling
.PP
.Vb 2
\&  @dims = $large_pdl\->dims; shift @dims;
\&  sumover($large_pdl,($sums = zeroes(double,@dims)));
.Ve
.PP
is not a good alternative either. Now we don't have overflow problems with
\&\f(CW$sums\fR but at the expense of a type conversion of \f(CW$large_pdl\fR to
double, something bad if this is really a large pdl. That's where \f(CW\*(C`double\*(C'\fR
comes in handy:
.PP
.Vb 6
\&  pp_def(\*(Aqsumoverd\*(Aq,
\&         Pars => \*(Aqa(n); double [o] b()\*(Aq,
\&         Code => \*(Aqdouble tmp=0;
\&                  loop(n) %{ tmp += a(); %}
\&                  $b() = tmp;\*(Aq,
\&  );
.Ve
.PP
This gets us around the type conversion and overflow problems. Again,
analogous to the \f(CW\*(C`indx\*(C'\fR qualifier \f(CW\*(C`double\*(C'\fR results in \f(CW\*(C`b\*(C'\fR always being of
type double regardless of the type of \f(CW\*(C`a\*(C'\fR without leading to a
type conversion of \f(CW\*(C`a\*(C'\fR as a side effect.
.PP
Finally, there are the \f(CW\*(C`type+\*(C'\fR qualifiers where type is one of \f(CW\*(C`int\*(C'\fR
or \f(CW\*(C`float\*(C'\fR. What shall that mean. Let's illustrate the \f(CW\*(C`int+\*(C'\fR
qualifier with the actual definition of sumover:
.PP
.Vb 6
\&  pp_def(\*(Aqsumover\*(Aq,
\&         Pars => \*(Aqa(n); int+ [o] b()\*(Aq,
\&         Code => \*(Aq$GENERIC(b) tmp=0;
\&                  loop(n) %{ tmp += a(); %}
\&                  $b() = tmp;\*(Aq,
\&  );
.Ve
.PP
As we had already seen for the \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`float\*(C'\fR and \f(CW\*(C`double\*(C'\fR
qualifiers, a pdl marked with a \f(CW\*(C`type+\*(C'\fR qualifier does not influence
the datatype of the pdl operation. Its meaning is "make this pdl at
least of type \f(CW\*(C`type\*(C'\fR or higher, as required by the type of the
operation". In the sumover example this means that when you call the
function with an \f(CW\*(C`a\*(C'\fR of type PDL_Short the output pdl will be of type
PDL_Long (just as would have been the case with the \f(CW\*(C`int\*(C'\fR
qualifier). This again tries to avoid overflow problems when using
small datatypes (e.g. byte images).  However, when the datatype of the
operation is higher than the type specified in the \f(CW\*(C`type+\*(C'\fR qualifier
\&\f(CW\*(C`b\*(C'\fR will be created with the datatype of the operation, e.g. when
\&\f(CW\*(C`a\*(C'\fR is of type double then \f(CW\*(C`b\*(C'\fR will be double as well. We hope you
agree that this is sensible behaviour for \f(CW\*(C`sumover\*(C'\fR. It should be
obvious how the \f(CW\*(C`float+\*(C'\fR qualifier works by analogy.
It may become necessary to be able to specify a set of alternative
types for the parameters. However, this will probably not be
implemented until someone comes up with a reasonable use for it.
.PP
Note that we now had to specify the \f(CW$GENERIC\fR macro with the name
of the pdl to derive the type from that argument. Why is that? If you
carefully followed our explanations you will have realised that in some
cases \f(CW\*(C`b\*(C'\fR will have a different type than the type of the operation.
Calling the '$GENERIC' macro with \f(CW\*(C`b\*(C'\fR as argument makes sure that
the type will always the same as that of \f(CW\*(C`b\*(C'\fR in that part of the
generic loop.
.PP
This is about all there is to say about the \f(CW\*(C`Pars\*(C'\fR section in a
\&\f(CW\*(C`pp_def\*(C'\fR call. You should remember that this section defines the \fIsignature\fR
of a \s-1PP\s0 defined function, you can use several options to qualify certain
arguments as output and temporary args and all dimensions that you can
later refer to in the \f(CW\*(C`Code\*(C'\fR section are defined by name.
.PP
It is important that you understand the meaning of the signature since
in the latest \s-1PDL\s0 versions you can use it to define threaded functions
from within Perl, i.e. what we call \fIPerl level threading\fR. Please check
PDL::Indexing for details.
.SS "The Code section"
.IX Subsection "The Code section"
The \f(CW\*(C`Code\*(C'\fR section contains the actual \s-1XS\s0 code that will be in the
innermost part of a thread loop (if you don't know what a thread loop is then
you still haven't read PDL::Indexing; do it now ;) after any \s-1PP\s0 macros
(like \f(CW$GENERIC\fR) and \s-1PP\s0 functions have been expanded (like the
\&\f(CW\*(C`loop\*(C'\fR function we are going to explain next).
.PP
Let's quickly reiterate the \f(CW\*(C`sumover\*(C'\fR example:
.PP
.Vb 6
\&  pp_def(\*(Aqsumover\*(Aq,
\&         Pars => \*(Aqa(n); int+ [o] b()\*(Aq,
\&         Code => \*(Aq$GENERIC(b) tmp=0;
\&                  loop(n) %{ tmp += a(); %}
\&                  $b() = tmp;\*(Aq,
\&  );
.Ve
.PP
The \f(CW\*(C`loop\*(C'\fR construct in the \f(CW\*(C`Code\*(C'\fR section also refers to the
dimension name so you don't need to specify any limits: the loop is
correctly sized and everything is done for you, again.
.PP
Next, there is the surprising fact that \f(CW\*(C`$a()\*(C'\fR and \f(CW\*(C`$b()\*(C'\fR do \fBnot\fR
contain the index. This is not necessary because we're looping over
\&\fIn\fR and both variables know which dimensions they have so
they automatically know they're being looped over.
.PP
This feature comes in very handy in many places and makes for
much shorter code. Of course, there are times when you want to
circumvent this; here is a function which make a matrix symmetric
and serves as an example of how to code explicit looping:
.PP
.Vb 12
\&        pp_def(\*(Aqsymm\*(Aq,
\&                Pars => \*(Aqa(n,n); [o]c(n,n);\*(Aq,
\&                Code => \*(Aqloop(n) %{
\&                                int n2;
\&                                for(n2=n; n2<$SIZE(n); n2++) {
\&                                        $c(n0 => n, n1 => n2) =
\&                                        $c(n0 => n2, n1 => n) =
\&                                         $a(n0 => n, n1 => n2);
\&                                }
\&                        %}
\&                \*(Aq
\&        );
.Ve
.PP
Let's dissect what is happening. Firstly, what is this function supposed to
do? From its signature you see that it takes a 2D matrix with equal numbers
of columns and rows and outputs a matrix of the same size. From a given
input matrix \f(CW$a\fR it computes a symmetric output matrix \f(CW$c\fR (symmetric in
the matrix sense that A^T = A where ^T means matrix transpose, or in \s-1PDL\s0
parlance \f(CW$c\fR == \f(CW$c\fR\->xchg(0,1)). It does this by using only the values
on and below the diagonal of \f(CW$a\fR. In the output matrix \f(CW$c\fR all values on
and below the diagonal are the same as those in \f(CW$a\fR while those above the
diagonal are a mirror image of those below the diagonal (above and below
are here interpreted in the way that \s-1PDL\s0 prints 2D pdls). If this explanation
still sounds a bit strange just go ahead, make a little file into which you
write this definition, build the new \s-1PDL\s0 extension (see section on Makefiles
for \s-1PP\s0 code) and try it out with a couple of examples.
.PP
Having explained what the function is supposed to do there are a
couple of points worth noting from the syntactical point of
view. First, we get the size of the dimension named \f(CW\*(C`n\*(C'\fR again by
using the \f(CW$SIZE\fR macro. Second, there are suddenly these funny \f(CW\*(C`n0\*(C'\fR
and \f(CW\*(C`n1\*(C'\fR index names in the code though the signature defines only
the dimension \f(CW\*(C`n\*(C'\fR. Why this? The reason becomes clear when you note
that both the first and second dimension of \f(CW$a\fR and \f(CW$b\fR are named \f(CW\*(C`n\*(C'\fR
in the signature of \f(CW\*(C`symm\*(C'\fR. This tells \s-1PDL::PP\s0 that the first and
second dimension of these arguments should have the same
size. Otherwise the generated function will raise a runtime error.
However, now in an access to \f(CW$a\fR and \f(CW$c\fR \s-1PDL::PP\s0 cannot figure out
which index \f(CW\*(C`n\*(C'\fR refers to any more just from the name of the index.
Therefore, the indices with equal dimension names get numbered from
left to right starting at 0, e.g. in the above example \f(CW\*(C`n0\*(C'\fR refers to
the first dimension of \f(CW$a\fR and \f(CW$c\fR, \f(CW\*(C`n1\*(C'\fR to the second and so on.
.PP
In all examples so far, we have only used the \f(CW\*(C`Pars\*(C'\fR and \f(CW\*(C`Code\*(C'\fR
members of the hash that was passed to \f(CW\*(C`pp_def\*(C'\fR. There are certainly
other keys that are recognised by \s-1PDL::PP\s0 and we will hear about some
of them in the course of this document. Find a (non-exhaustive) list
of keys in Appendix A.  A list of macros and PPfunctions (we have only
encountered some of those in the examples above yet) that are expanded
in values of the hash argument to \f(CW\*(C`pp_def\*(C'\fR is summarised in Appendix
B.
.PP
At this point, it might be appropriate to mention that
\&\s-1PDL::PP\s0 is not a completely static, well designed set of routines (as
Tuomas puts it: \*(L"stop thinking of \s-1PP\s0 as a set of routines carved in
stone\*(R") but rather a collection of things that the \s-1PDL::PP\s0 author
(Tuomas J. Lukka) considered he would have to write often into his \s-1PDL\s0
extension routines. \s-1PP\s0 tries to be expandable so that in the future,
as new needs arise, new common code can be abstracted back into it. If
you want to learn more on why you might want to change \s-1PDL::PP\s0 and how
to do it check the section on \s-1PDL::PP\s0 internals.
.SS "Handling bad values"
.IX Subsection "Handling bad values"
If you do not have bad-value support compiled into \s-1PDL\s0 you can
ignore this section and the related keys: \f(CW\*(C`BadCode\*(C'\fR, \f(CW\*(C`HandleBad\*(C'\fR, ...
(try printing out the value of \f(CW$PDL::Bad::Status\fR \- if it equals 0 
then move straight on).
.PP
There are several keys and macros used when writing code to handle
bad values. The first one is the \f(CW\*(C`HandleBad\*(C'\fR key:
.IP "HandleBad => 0" 4
.IX Item "HandleBad => 0"
This flags a pp-routine as \fI\s-1NOT\s0\fR handling bad values. If this routine
is sent piddles with their \f(CW\*(C`badflag\*(C'\fR set, then a warning message is
printed to \s-1STDOUT\s0 and the piddles are processed as if the value used to
represent bad values is a valid number. The \f(CW\*(C`badflag\*(C'\fR value is
not propagated to the output piddles.
.Sp
An example of when this is used is for \s-1FFT\s0 routines, which generally
do not have a way of ignoring part of the data.
.IP "HandleBad => 1" 4
.IX Item "HandleBad => 1"
This causes \s-1PDL::PP\s0 to write extra code that ensures the BadCode
section is used, and that the \f(CW\*(C`$ISBAD()\*(C'\fR macro (and its brethren)
work.
.IP "HandleBad is not given" 4
.IX Item "HandleBad is not given"
If any of the input piddles have their \f(CW\*(C`badflag\*(C'\fR set, then the
output piddles will have their \f(CW\*(C`badflag\*(C'\fR set, but any supplied
BadCode is ignored.
.PP
The value of \f(CW\*(C`HandleBad\*(C'\fR is used to define the contents of
the \f(CW\*(C`BadDoc\*(C'\fR key, if it is not given.
.PP
To handle bad values, code must be written somewhat differently;
for instance,
.PP
.Vb 1
\& $c() = $a() + $b();
.Ve
.PP
becomes something like
.PP
.Vb 5
\& if ( $a() != BADVAL && $b() != BADVAL ) {
\&    $c() = $a() + $b();
\& } else {
\&    $c() = BADVAL;
\& }
.Ve
.PP
However, we only want the second version if bad values are present in
the input piddles (and that bad-value support is wanted!) \- otherwise 
we actually want the original code. This is where the \f(CW\*(C`BadCode\*(C'\fR
key comes in; you use it to specify the code to execute if bad values
may be present, and \s-1PP\s0 uses both it and the \f(CW\*(C`Code\*(C'\fR section to create
something like:
.PP
.Vb 9
\& if ( bad_values_are_present ) {
\&    fancy_threadloop_stuff {
\&       BadCode
\&    }
\& } else {
\&    fancy_threadloop_stuff {
\&       Code
\&    }
\& }
.Ve
.PP
This approach means that there is virtually no overhead when 
bad values are not present (i.e. the badflag routine
returns 0).
.PP
The C preprocessor symbol \f(CW\*(C`PDL_BAD_CODE\*(C'\fR is defined when the bad code
is compiled, so that you can reduce the amount of code you write.  The
BadCode section can use the same macros and looping constructs as the
Code section.  However, it wouldn't be much use without the following
additional macros:
.ie n .IP "$ISBAD(var)" 4
.el .IP "\f(CW$ISBA\fRD(var)" 4
.IX Item "$ISBAD(var)"
To check whether a piddle's value is bad, use the \f(CW$ISBAD\fR macro:
.Sp
.Vb 1
\& if ( $ISBAD(a()) ) { printf("a() is bad\en"); }
.Ve
.Sp
You can also access given elements of a piddle:
.Sp
.Vb 1
\& if ( $ISBAD(a(n=>l)) ) { printf("element %d of a() is bad\en", l); }
.Ve
.ie n .IP "$ISGOOD(var)" 4
.el .IP "\f(CW$ISGOO\fRD(var)" 4
.IX Item "$ISGOOD(var)"
This is the opposite of the \f(CW$ISBAD\fR macro.
.ie n .IP "$SETBAD(var)" 4
.el .IP "\f(CW$SETBA\fRD(var)" 4
.IX Item "$SETBAD(var)"
For when you want to set an element of a piddle bad.
.ie n .IP "$ISBADVAR(c_var,pdl)" 4
.el .IP "\f(CW$ISBADVA\fRR(c_var,pdl)" 4
.IX Item "$ISBADVAR(c_var,pdl)"
If you have cached the value of a piddle \f(CW\*(C`$a()\*(C'\fR into a c\-variable (\f(CW\*(C`foo\*(C'\fR say),
then to check whether it is bad, use \f(CW\*(C`$ISBADVAR(foo,a)\*(C'\fR.
.ie n .IP "$ISGOODVAR(c_var,pdl)" 4
.el .IP "\f(CW$ISGOODVA\fRR(c_var,pdl)" 4
.IX Item "$ISGOODVAR(c_var,pdl)"
As above, but this time checking that the cached value
isn't bad.
.ie n .IP "$SETBADVAR(c_var,pdl)" 4
.el .IP "\f(CW$SETBADVA\fRR(c_var,pdl)" 4
.IX Item "$SETBADVAR(c_var,pdl)"
To copy the bad value for a piddle into a c variable, use
\&\f(CW\*(C`$SETBADVAR(foo,a)\*(C'\fR.
.PP
\&\fI\s-1TODO:\s0\fR mention \f(CW\*(C`$PPISBAD()\*(C'\fR etc macros.
.PP
Using these macros, the above code could be specified as:
.PP
.Vb 7
\& Code => \*(Aq$c() = $a() + $b();\*(Aq,
\& BadCode => \*(Aq
\&    if ( $ISBAD(a()) || $ISBAD(b()) ) {
\&       $SETBAD(c());
\&    } else {
\&       $c() = $a() + $b();
\&    }\*(Aq,
.Ve
.PP
Since this is Perl, \s-1TMTOWTDI,\s0 so you could also write:
.PP
.Vb 6
\& BadCode => \*(Aq
\&    if ( $ISGOOD(a()) && $ISGOOD(b()) ) {
\&       $c() = $a() + $b();
\&    } else {
\&       $SETBAD(c());
\&    }\*(Aq,
.Ve
.PP
You can reduce code repition using the C \f(CW\*(C`PDL_BAD_CODE\*(C'\fR macro,
using the same code for both of the \f(CW\*(C`Code\*(C'\fR and \f(CW\*(C`BadCode\*(C'\fR sections:
.PP
.Vb 3
\&    #ifdef PDL_BAD_CODE
\&    if ( $ISGOOD(a()) && $ISGOOD(b()) ) {
\&    #endif PDL_BAD_CODE
\&
\&       $c() = $a() + $b();
\&
\&    #ifdef PDL_BAD_CODE
\&    } else {
\&       $SETBAD(c());
\&    }
\&    #endif PDL_BAD_CODE
.Ve
.PP
If you want access to the value of the badflag for a given
piddle, you can use the \s-1PDL STATE\s0 macros:
.ie n .IP "$ISPDLSTATEBAD(pdl)" 4
.el .IP "\f(CW$ISPDLSTATEBA\fRD(pdl)" 4
.IX Item "$ISPDLSTATEBAD(pdl)"
.PD 0
.ie n .IP "$ISPDLSTATEGOOD(pdl)" 4
.el .IP "\f(CW$ISPDLSTATEGOO\fRD(pdl)" 4
.IX Item "$ISPDLSTATEGOOD(pdl)"
.ie n .IP "$SETPDLSTATEBAD(pdl)" 4
.el .IP "\f(CW$SETPDLSTATEBA\fRD(pdl)" 4
.IX Item "$SETPDLSTATEBAD(pdl)"
.ie n .IP "$SETPDLSTATEGOOD(pdl)" 4
.el .IP "\f(CW$SETPDLSTATEGOO\fRD(pdl)" 4
.IX Item "$SETPDLSTATEGOOD(pdl)"
.PD
.PP
\&\fI\s-1TODO:\s0\fR mention the \f(CW\*(C`FindBadStatusCode\*(C'\fR and
\&\f(CW\*(C`CopyBadStatusCode\*(C'\fR options to \f(CW\*(C`pp_def\*(C'\fR, as well as the
\&\f(CW\*(C`BadDoc\*(C'\fR key.
.SS "Interfacing your own/library functions using \s-1PP\s0"
.IX Subsection "Interfacing your own/library functions using PP"
Now, consider the following: you have your own C function
(that may in fact be part of some library you want to interface to \s-1PDL\s0)
which takes as arguments two pointers to vectors of double:
.PP
.Vb 1
\&        void myfunc(int n,double *v1,double *v2);
.Ve
.PP
The correct way of defining the \s-1PDL\s0 function is
.PP
.Vb 5
\&        pp_def(\*(Aqmyfunc\*(Aq,
\&                Pars => \*(Aqa(n); [o]b(n);\*(Aq,
\&                GenericTypes => [\*(AqD\*(Aq],
\&                Code => \*(Aqmyfunc($SIZE(n),$P(a),$P(b));\*(Aq
\&        );
.Ve
.PP
The \f(CW\*(C`$P(\*(C'\fR\fIpar\fR\f(CW\*(C`)\*(C'\fR syntax returns a pointer to the first
element and the other elements are guaranteed to lie after that.
.PP
Notice that here it is possible to make many mistakes. First,
\&\f(CW$SIZE(n)\fR must be used instead of \f(CW\*(C`n\*(C'\fR. Second, you shouldn't put
any loops in this code. Third, here we encounter a new hash key
recognised by \s-1PDL::PP :\s0 the \f(CW\*(C`GenericTypes\*(C'\fR declaration tells \s-1PDL::PP\s0
to \s-1ONLY GENERATE THE TYPELOOP FOP THE LIST OF TYPES SPECIFIED.\s0 In
this case \f(CW\*(C`double\*(C'\fR. This has two advantages. Firstly the size of
the compiled code is reduced vastly, secondly if non-double arguments
are passed to \f(CW\*(C`myfunc()\*(C'\fR \s-1PDL\s0 will automatically convert them to
double before passing to the external C routine and convert them
back afterwards.
.PP
One can also use \f(CW\*(C`Pars\*(C'\fR to qualify the types of individual
arguments. Thus one could also write this as:
.PP
.Vb 4
\&        pp_def(\*(Aqmyfunc\*(Aq,
\&                Pars => \*(Aqdouble a(n); double [o]b(n);\*(Aq,
\&                Code => \*(Aqmyfunc($SIZE(n),$P(a),$P(b));\*(Aq
\&        );
.Ve
.PP
The type specification in \f(CW\*(C`Pars\*(C'\fR exempts the argument from
variation in the typeloop \- rather it is automatically converted
too and from the type specified. This is obviously useful in
a more general example, e.g.:
.PP
.Vb 1
\&        void myfunc(int n,float *v1,long *v2);
\&
\&        pp_def(\*(Aqmyfunc\*(Aq,
\&                Pars => \*(Aqfloat a(n); long [o]b(n);\*(Aq,
\&                GenericTypes => [\*(AqF\*(Aq],
\&                Code => \*(Aqmyfunc($SIZE(n),$P(a),$P(b));\*(Aq
\&        );
.Ve
.PP
Note we still use \f(CW\*(C`GenericTypes\*(C'\fR to reduce the size of the
type loop, obviously \s-1PP\s0 could in principle spot this and do
it automatically though the code has yet to attain that
level of sophistication!
.PP
Finally note when types are converted automatically one \s-1MUST\s0
use the \f(CW\*(C`[o]\*(C'\fR qualifier for output variables or you hard
one changes will get optimised away by \s-1PP\s0!
.PP
If you interface a large library you can automate the interfacing even
further. Perl can help you again(!) in doing this. In many libraries
you have certain calling conventions. This can be exploited. In short,
you can write a little parser (which is really not difficult in Perl) that
then generates the calls to \f(CW\*(C`pp_def\*(C'\fR from parsed descriptions of the
functions in that library. For an example, please check the \fISlatec\fR
interface in the \f(CW\*(C`Lib\*(C'\fR tree of the \s-1PDL\s0 distribution. If you want to check
(during debugging) which calls to \s-1PP\s0 functions your Perl code generated
a little helper package comes in handy which replaces the \s-1PP\s0 functions
by identically named ones that dump their arguments to stdout.
.PP
Just say
.PP
.Vb 1
\&   perl \-MPDL::PP::Dump myfile.pd
.Ve
.PP
to see the calls to \f(CW\*(C`pp_def\*(C'\fR and friends. Try it with \fIops.pd\fR and
\&\fIslatec.pd\fR. If you're interested (or want to enhance it), the source
is in Basic/Gen/PP/Dump.pm
.SS "Other macros and functions in the Code section"
.IX Subsection "Other macros and functions in the Code section"
Macros: So far we have encountered the \f(CW$SIZE\fR, \f(CW$GENERIC\fR and \f(CW$P\fR macros.
Now we are going to quickly explain the other macros that are expanded in the
\&\f(CW\*(C`Code\*(C'\fR section of \s-1PDL::PP\s0 along with examples of their usage.
.ie n .IP "$T" 3
.el .IP "\f(CW$T\fR" 3
.IX Item "$T"
The \f(CW$T\fR macro is used for type switches. This is very useful when you have
to use different external (e.g. library) functions depending on the input
type of arguments. The general syntax is
.Sp
.Vb 1
\&        $Ttypeletters(type_alternatives)
.Ve
.Sp
where \f(CW\*(C`typeletters\*(C'\fR is a permutation of a subset of the letters
\&\f(CW\*(C`BSULFD\*(C'\fR which stand for Byte, Short, Ushort, etc. and
\&\f(CW\*(C`type_alternatives\*(C'\fR are the expansions when the type of the \s-1PP\s0
operation is equal to that indicated by the respective letter. Let's
illustrate this incomprehensible description by an example. Assuming
you have two C functions with prototypes
.Sp
.Vb 2
\&  void float_func(float *in, float *out);
\&  void double_func(double *in, double *out);
.Ve
.Sp
which do basically the same thing but one accepts float and the other
double pointers. You could interface them to \s-1PDL\s0 by defining a generic
function \f(CW\*(C`foofunc\*(C'\fR (which will call the correct function depending
on the type of the transformation):
.Sp
.Vb 5
\&  pp_def(\*(Aqfoofunc\*(Aq,
\&        Pars => \*(Aq a(n); [o] b();\*(Aq,
\&        Code => \*(Aq $TFD(float_func,double_func) ($P(a),$P(b));\*(Aq
\&        GenericTypes => [qw(F D)],
\&  );
.Ve
.Sp
Please note that you can't say
.Sp
.Vb 1
\&       Code => \*(Aq $TFD(float,double)_func ($P(a),$P(b));\*(Aq
.Ve
.Sp
since the \f(CW$T\fR macro expands with trailing spaces, analogously to
C preprocessor macros.
The slightly longer form illustrated above is correct.
If you really want brevity, you can of course do
.Sp
.Vb 2
\&        \*(Aq$TBSULFD(\*(Aq.(join \*(Aq,\*(Aq,map {"long_identifier_name_$_"}
\&                qw/byt short unseigned lounge flotte dubble/).\*(Aq);\*(Aq
.Ve
.ie n .IP "$PP" 3
.el .IP "\f(CW$PP\fR" 3
.IX Item "$PP"
The \f(CW$PP\fR macro is used for a so called \fIphysical pointer access\fR. The
\&\fIphysical\fR refers to some internal optimisations of \s-1PDL\s0 (for those who
are familiar with the \s-1PDL\s0 core we are talking about the vaffine
optimisations). This macro is mainly for internal use and you shouldn't
need to use it in any of your normal code.
.ie n .IP "$COMP (and the ""OtherPars"" section)" 3
.el .IP "\f(CW$COMP\fR (and the \f(CWOtherPars\fR section)" 3
.IX Item "$COMP (and the OtherPars section)"
The \f(CW$COMP\fR macro is used to access non-pdl values in the code section. Its
name is derived from the implementation of transformations in \s-1PDL.\s0 The
variables you can refer to using \f(CW$COMP\fR are members
of the ``compiled'' structure that represents the \s-1PDL\s0 transformation in question
but does not yet contain any information about dimensions
(for further details check PDL::Internals). However, you can treat
\&\f(CW$COMP\fR just as a black box without knowing anything about the
implementation of transformations in \s-1PDL.\s0 So when would you use this
macro? Its main usage is to access values of arguments that are
declared in the \f(CW\*(C`OtherPars\*(C'\fR section of a \f(CW\*(C`pp_def\*(C'\fR definition. But
then you haven't heard about the \f(CW\*(C`OtherPars\*(C'\fR key yet?!  Let's have
another example that illustrates typical usage of both new features:
.Sp
.Vb 6
\&  pp_def(\*(Aqpnmout\*(Aq,
\&        Pars => \*(Aqa(m)\*(Aq,
\&        OtherPars => "char* fd",
\&        GenericTypes => [qw(B U S L)],
\&        Code => \*(AqPerlIO *fp;
\&                 IO *io;
\&
\&               io = GvIO(gv_fetchpv($COMP(fd),FALSE,SVt_PVIO));
\&                 if (!io || !(fp = IoIFP(io)))
\&                        croak("Can\e\*(Aqt figure out FP");
\&
\&                 if (PerlIO_write(fp,$P(a),len) != len)
\&                                croak("Error writing pnm file");
\&  \*(Aq);
.Ve
.Sp
This function is used to write data from a pdl to a file. The file descriptor
is passed as a string into this function. This parameter does not go into
the \f(CW\*(C`Pars\*(C'\fR section since it cannot be usefully treated like a pdl but rather
into the aptly named \f(CW\*(C`OtherPars\*(C'\fR section. Parameters in the \f(CW\*(C`OtherPars\*(C'\fR
section follow those in the \f(CW\*(C`Pars\*(C'\fR section when invoking the function, i.e.
.Sp
.Vb 2
\&   open FILE,">out.dat" or die "couldn\*(Aqt open out.dat";
\&   pnmout($pdl,\*(AqFILE\*(Aq);
.Ve
.Sp
When you want to access this parameter inside the code section you
have to tell \s-1PP\s0 by using the \f(CW$COMP\fR macro, i.e. you write
\&\f(CW\*(C`$COMP(fd)\*(C'\fR as in the example. Otherwise \s-1PP\s0 wouldn't know that the
\&\f(CW\*(C`fd\*(C'\fR you are referring to is the same as that specified in the
\&\f(CW\*(C`OtherPars\*(C'\fR section.
.Sp
Another use for the \f(CW\*(C`OtherPars\*(C'\fR section is to set a named dimension
in the signature. Let's have an example how that is done:
.Sp
.Vb 5
\&  pp_def(\*(Aqsetdim\*(Aq,
\&        Pars => \*(Aq[o] a(n)\*(Aq,
\&        OtherPars => \*(Aqint ns => n\*(Aq,
\&        Code => \*(Aqloop(n) %{ $a() = n; %}\*(Aq,
\&  );
.Ve
.Sp
This says that the named dimension \f(CW\*(C`n\*(C'\fR will be initialised from the
value of the \fIother parameter\fR \f(CW\*(C`ns\*(C'\fR which is of integer type (I guess
you have realised that we use the \f(CW\*(C`CType From => named_dim\*(C'\fR syntax).
Now you can call this function in the usual way:
.Sp
.Vb 3
\&  setdim(($x=null),5);
\&  print $x;
\&    [ 0 1 2 3 4 ]
.Ve
.Sp
Admittedly this function is not very useful but it demonstrates how it
works. If you call the function with an existing pdl and you don't need
to explicitly specify the size of \f(CW\*(C`n\*(C'\fR since \s-1PDL::PP\s0 can figure it out
from the dimensions of the non-null pdl. In that case you just give the
dimension parameter as \f(CW\*(C`\-1\*(C'\fR:
.Sp
.Vb 2
\&  $x = hist($y);
\&  setdim($x,\-1);
.Ve
.Sp
That should do it.
.PP
The only \s-1PP\s0 function that we have used in the examples so far is \f(CW\*(C`loop\*(C'\fR.
Additionally, there are currently two other functions which are recognised
in the \f(CW\*(C`Code\*(C'\fR section:
.IP "threadloop" 2
.IX Item "threadloop"
As we heard above the signature of a \s-1PP\s0 defined function defines the
dimensions of all the pdl arguments involved in a \fIprimitive\fR operation.
However, you often call the functions that you defined with \s-1PP\s0 with pdls
that have more dimensions than those specified in the signature. In this
case the primitive operation is performed on all subslices of appropriate
dimensionality in what is called a \fIthread loop\fR (see also overview above
and PDL::Indexing). Assuming you have some notion of this concept you
will probably appreciate that the operation specified in the code section
should be optimised since this is the tightest loop inside a thread loop.
However, if you revisit the example where we define the \f(CW\*(C`pnmout\*(C'\fR function,
you will quickly realise that looking up the \f(CW\*(C`IO\*(C'\fR file descriptor
in the inner thread loop is not very efficient when writing a pdl with
many rows. A better approach would be to look up the \f(CW\*(C`IO\*(C'\fR descriptor
once outside the thread loop and use its value then inside the tightest
thread loop. This is exactly where the \f(CW\*(C`threadloop\*(C'\fR function comes in
handy. Here is an improved definition of \f(CW\*(C`pnmout\*(C'\fR which uses this
function:
.Sp
.Vb 7
\&  pp_def(\*(Aqpnmout\*(Aq,
\&        Pars => \*(Aqa(m)\*(Aq,
\&        OtherPars => "char* fd",
\&        GenericTypes => [qw(B U S L)],
\&        Code => \*(AqPerlIO *fp;
\&                 IO *io;
\&                 int len;
\&
\&               io = GvIO(gv_fetchpv($COMP(fd),FALSE,SVt_PVIO));
\&                 if (!io || !(fp = IoIFP(io)))
\&                        croak("Can\e\*(Aqt figure out FP");
\&
\&                 len = $SIZE(m) * sizeof($GENERIC());
\&
\&                 threadloop %{
\&                    if (PerlIO_write(fp,$P(a),len) != len)
\&                                croak("Error writing pnm file");
\&                 %}
\&  \*(Aq);
.Ve
.Sp
This works as follows. Normally the C code you write inside the
\&\f(CW\*(C`Code\*(C'\fR section is placed inside a thread loop (i.e. \s-1PP\s0 generates the
appropriate wrapping \s-1XS\s0 code around it). However, when you explicitly
use the \f(CW\*(C`threadloop\*(C'\fR function, \s-1PDL::PP\s0 recognises this and doesn't
wrap your code with an additional thread loop. This has the effect that
code you write outside the thread loop is only executed once per
transformation and just the code with in the surrounding \f(CW\*(C`%{ ... %}\*(C'\fR
pair is placed within the tightest thread loop. This also comes in
handy when you want to perform a decision (or any other code,
especially \s-1CPU\s0 intensive code) only once per thread, i.e.
.Sp
.Vb 10
\&  pp_addhdr(\*(Aq
\&    #define RAW 0
\&    #define ASCII 1
\&  \*(Aq);
\&  pp_def(\*(Aqdo_raworascii\*(Aq,
\&         Pars => \*(Aqa(); b(); [o]c()\*(Aq,
\&         OtherPars => \*(Aqint mode\*(Aq,
\&       Code => \*(Aq switch ($COMP(mode)) {
\&                    case RAW:
\&                        threadloop %{
\&                            /* do raw stuff */
\&                        %}
\&                        break;
\&                    case ASCII:
\&                        threadloop %{
\&                            /* do ASCII stuff */
\&                        %}
\&                        break;
\&                    default:
\&                        croak("unknown mode");
\&                   }\*(Aq
\&   );
.Ve
.IP "types" 2
.IX Item "types"
The types function works similar to the \f(CW$T\fR macro. However, with the
\&\f(CW\*(C`types\*(C'\fR function the code in the following block (delimited by \f(CW\*(C`%{\*(C'\fR
and \f(CW\*(C`%}\*(C'\fR as usual) is executed for all those cases in which the datatype
of the operation is \fIany of\fR the types represented by the letters in the
argument to \f(CW\*(C`type\*(C'\fR, e.g.
.Sp
.Vb 1
\&     Code => \*(Aq...
\&
\&             types(BSUL) %{
\&                 /* do integer type operation */
\&             %}
\&             types(FD) %{
\&                 /* do floating point operation */
\&             %}
\&             ...\*(Aq
.Ve
.SS "The RedoDimsCode Section"
.IX Subsection "The RedoDimsCode Section"
The \f(CW\*(C`RedoDimsCode\*(C'\fR key is an optional key that is used to
compute dimensions of piddles at runtime in case the
standard rules for computing dimensions from the signature
are not sufficient. The contents of the \f(CW\*(C`RedoDimsCode\*(C'\fR entry
is interpreted in the same way that the Code section is
interpreted\*(-- \fIi.e.\fR, \s-1PP\s0 macros are expanded and the result
is interpreted as C code. The purpose of the code is to set
the size of some dimensions that appear in the
signature. Storage allocation and threadloops and so forth
will be set up as if the computed dimension had appeared in
the signature. In your code, you first compute the desired
size of a named dimension in the signature according to
your needs and then assign that value to it via the $\fBSIZE()\fR
macro.
.PP
As an example, consider the following situation. You are
interfacing an external library routine that requires an
temporary array for workspace to be passed as an
argument. Two input data arrays that are passed are \f(CWp(m)\fR
and \f(CWx(n)\fR. The output data array is \f(CWy(n)\fR. The routine
requires a workspace array with a length of n+m*m, and you'd
like the storage created automatically just like it would be
for any piddle flagged with [t] or [o].  What you'd like is to
say something like
.PP
.Vb 2
\& pp_def( "myexternalfunc",
\&  Pars => " p(m);  x(n);  [o] y; [t] work(n+m*m); ", ...
.Ve
.PP
but that won't work, because \s-1PP\s0 can't interpret expressions with arithmetic
in the signature. Instead you write
.PP
.Vb 10
\&  pp_def(
\&      "myexternalfunc",
\&      Pars         => \*(Aq p(m);  x(n);  [o] y(); [t] work(wn); \*(Aq,
\&      RedoDimsCode => \*(Aq
\&        PDL_Indx im = $PDL(p)\->dims[0];
\&        PDL_Indx in = $PDL(x)\->dims[0];
\&        PDL_Indx min = in + im * im;
\&        PDL_Indx inw = $PDL(work)\->dims[0];
\&        $SIZE(wn) = inw >= min ? inw : min;
\&      \*(Aq,
\&      Code => \*(Aq
\&        externalfunc( $P(p), $P(x), $SIZE(m), $SIZE(n), $P(work) );
\&      \*(Aq
\&  );
.Ve
.PP
This code works as follows: The macro \f(CW$PD\fRL(p) expands to a
pointer to the pdl struct for the piddle p.  You don't want
a pointer to the data ( ie \f(CW$P\fR ) in this case, because you
want to access the methods for the piddle on the C
level. You get the first dimension of each of the piddles
and store them in integers. Then you compute the minimum
length the work array can be. If the user sent a piddle
\&\f(CW\*(C`work\*(C'\fR with sufficient storage, then leave it alone. If the
user sent, say a null pdl, or no pdl at all, then the size
of wn will be zero and you reset it to the minimum
value. Before the code in the Code section is executed \s-1PP\s0
will create the proper storage for \f(CW\*(C`work\*(C'\fR if it does not
exist. Note that you only took the first dimension of \f(CW\*(C`p\*(C'\fR
and \f(CW\*(C`x\*(C'\fR because the user may have sent piddles with extra
threading dimensions. Of course, the temporary piddle \f(CW\*(C`work\*(C'\fR (note the
[t] flag) should not be given any thread dimensions anyway.
.PP
You can also use \f(CW\*(C`RedoDimsCode\*(C'\fR to set the dimension of a
piddle flagged with [o]. In this case you set the dimensions
for the named dimension in the signature using $\fBSIZE()\fR as in
the preceding example.  However, because the piddle is
flagged with [o] instead of [t], threading dimensions will
be added if required just as if the size of the dimension
were computed from the signature according to the usual
rules. Here is an example from PDL::Math
.PP
.Vb 3
\& pp_def("polyroots",
\&      Pars => \*(Aqcr(n); ci(n); [o]rr(m); [o]ri(m);\*(Aq,
\&      RedoDimsCode => \*(AqPDL_Indx sn = $PDL(cr)\->dims[0]; $SIZE(m) = sn\-1;\*(Aq,
.Ve
.PP
The input piddles are the real and imaginary parts of
complex coefficients of a polynomial. The output piddles are
real and imaginary parts of the roots. There are \f(CW\*(C`n\*(C'\fR roots
to an \f(CW\*(C`n\*(C'\fRth order polynomial and such a polynomial has
\&\f(CW\*(C`n+1\*(C'\fR coefficients (the zeoreth through the \f(CW\*(C`n\*(C'\fRth). In
this example, threading will work correctly. That is, the
first dimension of the output piddle with have its dimension
adjusted, but other threading dimensions will be assigned
just as if there were no \f(CW\*(C`RedoDimsCode\*(C'\fR.
.ie n .SS "Typemap handling in the ""OtherPars"" section"
.el .SS "Typemap handling in the \f(CWOtherPars\fP section"
.IX Subsection "Typemap handling in the OtherPars section"
The \f(CW\*(C`OtherPars\*(C'\fR section discussed above is very often absolutely
crucial when you interface external libraries with \s-1PDL.\s0 However in
many cases the external libraries either use derived types or
pointers of various types.
.PP
The standard way to handle this in Perl is to use a \f(CW\*(C`typemap\*(C'\fR file.
This is discussed in some detail in perlxs in the standard
Perl documentation. In \s-1PP\s0 the functionality is very similar, so you can
create a \f(CW\*(C`typemap\*(C'\fR file in the directory where your \s-1PP\s0 file resides and
when it is built it is automatically read in to figure out the appropriate
translation between the C type and Perl's built-in type.
.PP
That said, there are a couple of important differences from the general 
handling of types in \s-1XS.\s0 The first, and probably most important, is that
at the moment pointers to types are not allowed in the \f(CW\*(C`OtherPars\*(C'\fR
section. To get around this limitation you must use the \f(CW\*(C`IV\*(C'\fR type
(thanks to Judd Taylor for pointing out that this is necessary for
portability).
.PP
It is probably best to illustrate this with a couple of code-snippets:
.PP
For instance the \f(CW\*(C`gsl_spline_init\*(C'\fR function has the following C 
declaration:
.PP
.Vb 2
\&    int  gsl_spline_init(gsl_spline * spline,
\&          const double xa[], const double ya[], size_t size);
.Ve
.PP
Clearly the \f(CW\*(C`xa\*(C'\fR and \f(CW\*(C`ya\*(C'\fR arrays are candidates for being passed
in as piddles and the \f(CW\*(C`size\*(C'\fR argument is just the length of these
piddles so that can be handled by the \f(CW\*(C`$SIZE()\*(C'\fR macro in \s-1PP.\s0 The
problem is the pointer to the \f(CW\*(C`gsl_spline\*(C'\fR type. The natural solution
would be to write an \f(CW\*(C`OtherPars\*(C'\fR declaration of the form
.PP
.Vb 1
\&    OtherPars => \*(Aqgsl_spline *spl\*(Aq
.Ve
.PP
and write a short \f(CW\*(C`typemap\*(C'\fR file which handled this type. This does
not work at present however! So what you have to do is to go around
the problem slightly (and in some ways this is easier too!):
.PP
The solution is to declare \f(CW\*(C`spline\*(C'\fR in the \f(CW\*(C`OtherPars\*(C'\fR section using
an \*(L"Integer Value\*(R", \f(CW\*(C`IV\*(C'\fR. This hides the nature of the variable from
\&\s-1PP\s0 and you then need to (well to avoid compiler warnings at least!) 
perform a type cast when you use the variable in your code. Thus
\&\f(CW\*(C`OtherPars\*(C'\fR should take the form:
.PP
.Vb 1
\&    OtherPars => \*(AqIV spl\*(Aq
.Ve
.PP
and when you use it in the code you will write
.PP
.Vb 1
\&    INT2PTR(gsl_spline *, $COMP(spl))
.Ve
.PP
where the Perl \s-1API\s0 macro \f(CW\*(C`INT2PTR\*(C'\fR has been used to handle the pointer
cast to avoid compiler warnings and problems for machines with mixed 32bit
and 64bit Perl configurations.  Putting this together as Andres Jordan has
done (with the modification using \f(CW\*(C`IV\*(C'\fR by Judd Taylor) in the
\&\f(CW\*(C`gsl_interp.pd\*(C'\fR in the distribution source you get:
.PP
.Vb 6
\&     pp_def(\*(Aqinit_meat\*(Aq,
\&            Pars => \*(Aqdouble x(n); double y(n);\*(Aq,
\&            OtherPars => \*(AqIV spl\*(Aq,
\&            Code =>\*(Aq
\&         gsl_spline_init,( INT2PTR(gsl_spline *, $COMP(spl)), $P(x),$P(y),$SIZE(n)));\*(Aq
\&    );
.Ve
.PP
where I have removed a macro wrapper call, but that would obscure the
discussion.
.PP
The other minor difference as compared to the standard typemap handling
in Perl, is that the user cannot specify non-standard typemap locations or
typemap filenames using the \f(CW\*(C`TYPEMAPS\*(C'\fR option in MakeMaker... Thus you
can only use a file called \f(CW\*(C`typemap\*(C'\fR and/or the \f(CW\*(C`IV\*(C'\fR trick above.
.SS "Other useful \s-1PP\s0 keys in data operation definitions"
.IX Subsection "Other useful PP keys in data operation definitions"
You have already heard about the \f(CW\*(C`OtherPars\*(C'\fR key. Currently, there are not
many other keys for a data operation that will be useful in normal (whatever
that is) \s-1PP\s0 programming. In fact, it would be interesting to hear about
a case where you think you need more than what is provided at the moment.
Please speak up on one of the \s-1PDL\s0 mailing lists. Most other keys recognised
by \f(CW\*(C`pp_def\*(C'\fR are only really useful for what we call \fIslice operations\fR
(see also above).
.PP
One thing that is strongly being planned is variable number
of arguments, which will be a little tricky.
.PP
An incomplete list of the available keys:
.IP "Inplace" 4
.IX Item "Inplace"
Setting this key marks the routine as working inplace \- ie
the input and output piddles are the same. An example is
\&\f(CW\*(C`$x\->inplace\->sqrt()\*(C'\fR (or \f(CW\*(C`sqrt(inplace($x))\*(C'\fR).
.RS 4
.IP "Inplace => 1" 4
.IX Item "Inplace => 1"
Use when the routine is a unary function, such as \f(CW\*(C`sqrt\*(C'\fR.
.IP "Inplace => ['a']" 4
.IX Item "Inplace => ['a']"
If there are more than one input piddles, specify the name
of the one that can be changed inplace using an array reference.
.IP "Inplace => ['a','b']" 4
.IX Item "Inplace => ['a','b']"
If there are more than one output piddle, specify the name
of the input piddle and output piddle in a 2\-element array
reference. This probably isn't needed, but left in for
completeness.
.RE
.RS 4
.Sp
If bad values are being used, care must be taken to ensure the
propagation of the badflag when inplace is being used;
consider this excerpt from \fIBasic/Bad/bad.pd\fR:
.Sp
.Vb 8
\&  pp_def(\*(Aqreplacebad\*(Aq,HandleBad => 1,
\&    Pars => \*(Aqa(); [o]b();\*(Aq,
\&    OtherPars => \*(Aqdouble newval\*(Aq,
\&    Inplace => 1,
\&    CopyBadStatusCode => 
\&    \*(Aq/* propagate badflag if inplace AND it has changed */
\&     if ( a == b && $ISPDLSTATEBAD(a) )
\&       PDL\->propagate_badflag( b, 0 );
\&
\&     /* always make sure the output is "good" */
\&     $SETPDLSTATEGOOD(b);
\&    \*(Aq,
\&    ...
.Ve
.Sp
Since this routine removes all bad values, then the output piddle had
its bad flag cleared. If run inplace (so \f(CW\*(C`a == b\*(C'\fR), then we have to
tell all the children of \f(CW\*(C`a\*(C'\fR that the bad flag has been cleared (to
save time we make sure that we call \f(CW\*(C`PDL\->propagate_badgflag\*(C'\fR only
if the input piddle had its bad flag set).
.Sp
\&\s-1NOTE:\s0 one idea is that the documentation for the routine could be 
automatically flagged to indicate that it can be executed inplace,
ie something similar to how \f(CW\*(C`HandleBad\*(C'\fR sets \f(CW\*(C`BadDoc\*(C'\fR if it's not 
supplied (it's not an ideal solution).
.RE
.SS "Other \s-1PDL::PP\s0 functions to support concise package definition"
.IX Subsection "Other PDL::PP functions to support concise package definition"
So far, we have described the \f(CW\*(C`pp_def\*(C'\fR and \f(CW\*(C`pp_done\*(C'\fR functions. \s-1PDL::PP\s0
exports a few other functions to aid you in writing concise \s-1PDL\s0 extension
package definitions.
.PP
\fIpp_addhdr\fR
.IX Subsection "pp_addhdr"
.PP
Often when you interface library functions as in the above example
you have to include additional C include files. Since the \s-1XS\s0 file is
generated by \s-1PP\s0 we need some means to make \s-1PP\s0 insert the appropriate
include directives in the right place into the generated \s-1XS\s0 file.
To this end there is the \f(CW\*(C`pp_addhdr\*(C'\fR function. This is also the function
to use when you want to define some C functions for internal use by some
of the \s-1XS\s0 functions (which are mostly functions defined by \f(CW\*(C`pp_def\*(C'\fR).
By including these functions here you make sure that \s-1PDL::PP\s0 inserts your
code before the point where the actual \s-1XS\s0 module section begins and will
therefore be left untouched by xsubpp (cf. \fIperlxs\fR and \fIperlxstut\fR
man pages).
.PP
A typical call would be
.PP
.Vb 4
\&  pp_addhdr(\*(Aq
\&  #include <unistd.h>       /* we need defs of XXXX */
\&  #include "libprotos.h"    /* prototypes of library functions */
\&  #include "mylocaldecs.h"  /* Local decs */
\&
\&  static void do_the real_work(PDL_Byte * in, PDL_Byte * out, int n)
\&  {
\&        /* do some calculations with the data */
\&  }
\&  \*(Aq);
.Ve
.PP
This ensures that all the constants and prototypes you need will be properly
included and that you can use the internal functions defined here in the
\&\f(CW\*(C`pp_def\*(C'\fRs, e.g.:
.PP
.Vb 7
\&  pp_def(\*(Aqbarfoo\*(Aq,
\&         Pars => \*(Aq a(n); [o] b(n)\*(Aq,
\&         GenericTypes => [\*(AqB\*(Aq],
\&         Code => \*(Aq PDL_Indx ns = $SIZE(n);
\&                   do_the_real_work($P(a),$P(b),ns);
\&                 \*(Aq,
\&  );
.Ve
.PP
\fIpp_addpm\fR
.IX Subsection "pp_addpm"
.PP
In many cases the actual \s-1PP\s0 code (meaning the arguments to \f(CW\*(C`pp_def\*(C'\fR
calls) is only part of the package you are currently
implementing. Often there is additional Perl code and \s-1XS\s0 code
you would normally have written into the pm and \s-1XS\s0 files which are now
automatically generated by \s-1PP.\s0 So how to get this stuff into those
dynamically generated files? Fortunately, there are a couple of
functions, generally called \f(CW\*(C`pp_addXXX\*(C'\fR that assist you in doing
this.
.PP
Let's assume you have additional Perl code that should go into the
generated \fBpm\fR\-file. This is easily achieved with the \f(CW\*(C`pp_addpm\*(C'\fR command:
.PP
.Vb 1
\&   pp_addpm(<<\*(AqEOD\*(Aq);
\&
\&   =head1 NAME
\&
\&   PDL::Lib::Mylib \-\- a PDL interface to the Mylib library
\&
\&   =head1 DESCRIPTION
\&
\&   This package implements an interface to the Mylib package with full
\&   threading and indexing support (see L<PDL::Indexing>).
\&
\&   =cut
\&
\&   use PGPLOT;
\&
\&   =head2 use_myfunc
\&        this function applies the myfunc operation to all the
\&        elements of the input pdl regardless of dimensions
\&        and returns the sum of the result
\&   =cut
\&
\&   sub use_myfunc {
\&        my $pdl = shift;
\&
\&        myfunc($pdl\->clump(\-1),($res=null));
\&
\&        return $res\->sum;
\&   }
\&
\&   EOD
.Ve
.PP
\fIpp_add_exported\fR
.IX Subsection "pp_add_exported"
.PP
You have probably got the idea. In some cases you also want to export
your additional functions. To avoid getting into trouble with \s-1PP\s0 which
also messes around with the \f(CW@EXPORT\fR array you just tell \s-1PP\s0 to add
your functions to the list of exported functions:
.PP
.Vb 1
\&  pp_add_exported(\*(Aquse_myfunc gethynx\*(Aq);
.Ve
.PP
\fIpp_add_isa\fR
.IX Subsection "pp_add_isa"
.PP
The \f(CW\*(C`pp_add_isa\*(C'\fR command works like the the \f(CW\*(C`pp_add_exported\*(C'\fR function. 
The arguments to \f(CW\*(C`pp_add_isa\*(C'\fR are added the \f(CW@ISA\fR list, e.g.
.PP
.Vb 1
\&  pp_add_isa(\*(Aq Some::Other::Class \*(Aq);
.Ve
.PP
\fIpp_bless\fR
.IX Subsection "pp_bless"
.PP
If your pp_def routines are to be used as object methods use
\&\f(CW\*(C`pp_bless\*(C'\fR to specify the package (i.e. class) to which
your \fIpp_def\fRed methods will be added. For example,
\&\f(CW\*(C`pp_bless(\*(AqPDL::MyClass\*(Aq)\*(C'\fR. The default is \f(CW\*(C`PDL\*(C'\fR if this is
omitted.
.PP
\fIpp_addxs\fR
.IX Subsection "pp_addxs"
.PP
Sometimes you want to add extra \s-1XS\s0 code of your own
(that is generally not involved with any threading/indexing issues
but supplies some other functionality you want to access from the Perl
side) to the generated \s-1XS\s0 file, for example
.PP
.Vb 1
\&  pp_addxs(\*(Aq\*(Aq,\*(Aq
\&
\&  # Determine endianness of machine
\&
\&  int
\&  isbigendian()
\&     CODE:
\&       unsigned short i;
\&       PDL_Byte *b;
\&
\&       i = 42; b = (PDL_Byte*) (void*) &i;
\&
\&       if (*b == 42)
\&          RETVAL = 0;
\&       else if (*(b+1) == 42)
\&          RETVAL = 1;
\&       else
\&          croak("Impossible \- machine is neither big nor little endian!!\en");
\&       OUTPUT:
\&         RETVAL
\&  \*(Aq);
.Ve
.PP
Especially \f(CW\*(C`pp_add_exported\*(C'\fR and \f(CW\*(C`pp_addxs\*(C'\fR should be used with care. \s-1PP\s0 uses
PDL::Exporter, hence letting \s-1PP\s0 export your function means that they get added
to the standard list of function exported by default (the list defined by the
export tag ``:Func''). If you use \f(CW\*(C`pp_addxs\*(C'\fR you shouldn't try to do anything
that involves threading or indexing directly. \s-1PP\s0 is much better at generating
the appropriate code from your definitions.
.PP
\fIpp_add_boot\fR
.IX Subsection "pp_add_boot"
.PP
Finally, you may want to add some code to the \s-1BOOT\s0 section of the \s-1XS\s0 file
(if you don't know what that is check \fIperlxs\fR). This is easily done
with the \f(CW\*(C`pp_add_boot\*(C'\fR command:
.PP
.Vb 2
\&  pp_add_boot(<<EOB);
\&        descrip = mylib_initialize(KEEP_OPEN);
\&
\&        if (descrip == NULL)
\&           croak("Can\*(Aqt initialize library");
\&
\&        GlobalStruc\->descrip = descrip;
\&        GlobalStruc\->maxfiles = 200;
\&  EOB
.Ve
.PP
\fIpp_export_nothing\fR
.IX Subsection "pp_export_nothing"
.PP
By default, \s-1PP\s0.pm puts all subs defined using the pp_def function into the output .pm
file's \s-1EXPORT\s0 list. This can create problems if you are creating a subclassed
object where you don't want any methods exported. (i.e. the methods will only
be called using the \f(CW$object\fR\->method syntax).
.PP
For these cases you can call \fBpp_export_nothing()\fR to clear out the export list. Example (At 
the end of the .pd file):
.PP
.Vb 2
\&  pp_export_nothing();
\&  pp_done();
.Ve
.PP
\fIpp_core_importList\fR
.IX Subsection "pp_core_importList"
.PP
By default, \s-1PP\s0.pm puts the 'use Core;' line into the output .pm file. This imports Core's
exported names into the current namespace, which can create 
problems if you are over-riding one of Core's methods in the current file.
You end up getting messages like \*(L"Warning: sub sumover redefined in file
subclass.pm\*(R" when running the program.
.PP
For these cases the pp_core_importList can be used to change what is imported from Core.pm. 
For example:
.PP
.Vb 1
\&  pp_core_importList(\*(Aq()\*(Aq)
.Ve
.PP
This would result in
.PP
.Vb 1
\&  use Core();
.Ve
.PP
being generated in the output .pm file. This would result in no names being imported
from Core.pm. Similarly, calling
.PP
.Vb 1
\&  pp_core_importList(\*(Aq qw/ barf /\*(Aq)
.Ve
.PP
would result in
.PP
.Vb 1
\&  use Core qw/ barf/;
.Ve
.PP
being generated in the output .pm file. This would result in just 'barf'
being imported from Core.pm.
.PP
\fIpp_setversion\fR
.IX Subsection "pp_setversion"
.PP
I am pretty sure that this allows you to simultaneously set the .pm and
\&.xs files' versions, thus avoiding unnecessary version-skew between the
two. To use this, simply have the following line at some point in your
\&.pd file:
.PP
.Vb 1
\& pp_setversion(\*(Aq0.0.3\*(Aq);
.Ve
.PP
However, don't use this if you use Module::Build::PDL. See that
module's documentation for details.
.PP
\fIpp_deprecate_module\fR
.IX Subsection "pp_deprecate_module"
.PP
If a particular module is deemed obsolete, this function can be used to mark it
as deprecated. This has the effect of emitting a warning when a user tries to
\&\f(CW\*(C`use\*(C'\fR the module. The generated \s-1POD\s0 for this module also carries a deprecation
notice. The replacement module can be passed as an argument like this:
.PP
.Vb 1
\& pp_deprecate_module( infavor => "PDL::NewNonDeprecatedModule" );
.Ve
.PP
Note that function affects \fIonly\fR the runtime warning and the \s-1POD.\s0
.ie n .SH "Making your PP function ""private"""
.el .SH "Making your PP function ``private''"
.IX Header "Making your PP function private"
Let's say that you have a function in your module called PDL::foo that
uses the \s-1PP\s0 function \f(CW\*(C`bar_pp\*(C'\fR to do the heavy lifting. But you don't
want to advertise that \f(CW\*(C`bar_pp\*(C'\fR exists. To do this, you must move your
\&\s-1PP\s0 function to the top of your module file, then call
.PP
.Vb 1
\& pp_export_nothing()
.Ve
.PP
to clear the \f(CW\*(C`EXPORT\*(C'\fR list. To ensure that no documentation (even the
default \s-1PP\s0 docs) is generated, set
.PP
.Vb 1
\& Doc => undef
.Ve
.PP
and to prevent the function from being added to the symbol table, set
.PP
.Vb 1
\& PMFunc => \*(Aq\*(Aq
.Ve
.PP
in your pp_def declaration (see Image2D.pd for an example). This will
effectively make your \s-1PP\s0 function \*(L"private.\*(R" However, it is \fIalways\fR
accessible via PDL::bar_pp due to Perl's module design. But making
it private will cause the user to go very far out of his or her way
to use it, so he or she shoulders the consequences!
.SH "Slice operation"
.IX Header "Slice operation"
The slice operation section of this manual is provided using
dataflow and lazy evaluation: when you need it, ask Tjl to write it.
a delivery in a week from when I receive the email is 95% probable and
two week delivery is 99% probable.
.PP
And anyway, the slice operations require a much more intimate knowledge
of \s-1PDL\s0 internals than the data operations. Furthermore, the complexity
of the issues involved is considerably higher than that in the average
data operation. If you would like to convince yourself of this fact
take a look at the \fIBasic/Slices/slices.pd\fR file in the \s-1PDL\s0
distribution :\-). Nevertheless,
functions generated using the slice operations are at the heart of the
index manipulation and dataflow capabilities of \s-1PDL.\s0
.PP
Also, there are a lot of dirty issues with virtual piddles and
vaffines which we shall entirely skip here.
.SS "Slices and bad values"
.IX Subsection "Slices and bad values"
Slice operations need to be able to handle bad values (if support
is compiled into \s-1PDL\s0). The easiest thing to do is look at
\&\fIBasic/Slices/slices.pd\fR to see how this works.
.PP
Along with \f(CW\*(C`BadCode\*(C'\fR, there are also the \f(CW\*(C`BadBackCode\*(C'\fR and 
\&\f(CW\*(C`BadRedoDimsCode\*(C'\fR keys for \f(CW\*(C`pp_def\*(C'\fR. However, any
\&\f(CW\*(C`EquivCPOffsCode\*(C'\fR should \fInot\fR need changing, since 
any changes are absorbed into the definition of the
\&\f(CW\*(C`$EQUIVCPOFFS()\*(C'\fR macro (i.e. it is handled automatically
by \s-1PDL::PP\s0).
.SS "A few notes on writing a slicing routine..."
.IX Subsection "A few notes on writing a slicing routine..."
The following few paragraphs describe writing of a new slicing routine
('range'); any errors are \s-1CED\s0's. (\-\-CED 26\-Aug\-2002)
.ie n .SH "Handling of ""warn"" and ""barf"" in PP Code"
.el .SH "Handling of \f(CWwarn\fP and \f(CWbarf\fP in PP Code"
.IX Header "Handling of warn and barf in PP Code"
For printing warning messages or aborting/dieing, you can call \f(CW\*(C`warn\*(C'\fR or \f(CW\*(C`barf\*(C'\fR from \s-1PP\s0 code.
However, you should be aware that these calls have been redefined using C preprocessor
macros to \f(CW\*(C`PDL\->barf\*(C'\fR and \f(CW\*(C`PDL\->warn\*(C'\fR. These redefinitions are in place to keep
you from inadvertently calling perl's \f(CW\*(C`warn\*(C'\fR or \f(CW\*(C`barf\*(C'\fR directly, which can cause segfaults during
pthreading (i.e. processor multi-threading).
.PP
\&\s-1PDL\s0's own versions of \f(CW\*(C`barf\*(C'\fR and \f(CW\*(C`warn\*(C'\fR will queue-up warning or barf messages until after pthreading
is completed, and then call the perl versions of these routines.
.PP
See PDL::ParallelCPU for more information on pthreading.
.SH "USEFUL ROUTINES"
.IX Header "USEFUL ROUTINES"
The \s-1PDL\s0 \f(CW\*(C`Core\*(C'\fR structure, defined in \fIBasic/Core/pdlcore.h.PL\fR, contains
pointers to a number of routines that may be useful to you.  The majority
of these routines deal with manipulating piddles, but some are more general:
.IP "\s-1PDL\-\s0>qsort_B( PDL_Byte *xx, PDL_Indx a, PDL_Indx b )" 4
.IX Item "PDL->qsort_B( PDL_Byte *xx, PDL_Indx a, PDL_Indx b )"
Sort the array \f(CW\*(C`xx\*(C'\fR between the indices \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`b\*(C'\fR.
There are also versions for the other \s-1PDL\s0 datatypes,
with postfix \f(CW\*(C`_S\*(C'\fR, \f(CW\*(C`_U\*(C'\fR, \f(CW\*(C`_L\*(C'\fR, \f(CW\*(C`_N\*(C'\fR, \f(CW\*(C`_Q\*(C'\fR, \f(CW\*(C`_F\*(C'\fR, and \f(CW\*(C`_D\*(C'\fR.
Any module using this must ensure that \f(CW\*(C`PDL::Ufunc\*(C'\fR
is loaded.
.IP "\s-1PDL\-\s0>qsort_ind_B( PDL_Byte *xx, PDL_Indx *ix, PDL_Indx a, PDL_Indx b )" 4
.IX Item "PDL->qsort_ind_B( PDL_Byte *xx, PDL_Indx *ix, PDL_Indx a, PDL_Indx b )"
As for \f(CW\*(C`PDL\->qsort_B\*(C'\fR, but this time sorting the indices
rather than the data.
.PP
The routine \f(CW\*(C`med2d\*(C'\fR in \fILib/Image2D/image2d.pd\fR shows how such routines are 
used.
.SH "MAKEFILES FOR PP FILES"
.IX Header "MAKEFILES FOR PP FILES"
If you are going to generate a package from your \s-1PP\s0 file (typical file
extensions are \f(CW\*(C`.pd\*(C'\fR or \f(CW\*(C`.pp\*(C'\fR for the files containing \s-1PP\s0 code) it
is easiest and safest to leave generation of the appropriate commands
to the Makefile. In the following we will outline the typical format
of a Perl Makefile to automatically build and install your package
from a description in a \s-1PP\s0 file. Most of the rules to build the xs, pm
and other required files from the \s-1PP\s0 file are already predefined in
the PDL::Core::Dev package. We just have to tell MakeMaker to use
it.
.PP
In most cases you can define your Makefile like
.PP
.Vb 1
\&  # Makefile.PL for a package defined by PP code.
\&
\&  use PDL::Core::Dev;            # Pick up development utilities
\&  use ExtUtils::MakeMaker;
\&
\&  $package = ["mylib.pd",Mylib,PDL::Lib::Mylib];
\&  %hash = pdlpp_stdargs($package);
\&  $hash{OBJECT} .= \*(Aq additional_Ccode$(OBJ_EXT) \*(Aq;
\&  $hash{clean}\->{FILES} .= \*(Aq todelete_Ccode$(OBJ_EXT) \*(Aq;
\&  $hash{\*(AqVERSION_FROM\*(Aq} = \*(Aqmylib.pd\*(Aq;
\&  WriteMakefile(%hash);
\&
\&  sub MY::postamble { pdlpp_postamble($package); }
.Ve
.PP
Here, the list in \f(CW$package\fR is: first: \s-1PP\s0 source file name,
then the prefix for the produced files and finally the whole package name.
You can modify the hash in whatever way you like but it would be reasonable
to stay within some limits so that your package will continue to work
with later versions of \s-1PDL.\s0
.PP
If you don't want to use prepackaged arguments,
here is a generic \fIMakefile.PL\fR that you can adapt for your own
needs:
.PP
.Vb 1
\&  # Makefile.PL for a package defined by PP code.
\&
\&  use PDL::Core::Dev;            # Pick up development utilities
\&  use ExtUtils::MakeMaker;
\&
\&  WriteMakefile(
\&   \*(AqNAME\*(Aq       => \*(AqPDL::Lib::Mylib\*(Aq,
\&   \*(AqVERSION_FROM\*(Aq       => \*(Aqmylib.pd\*(Aq,
\&   \*(AqTYPEMAPS\*(Aq     => [&PDL_TYPEMAP()],
\&   \*(AqOBJECT\*(Aq       => \*(Aqmylib$(OBJ_EXT) additional_Ccode$(OBJ_EXT)\*(Aq,
\&   \*(AqPM\*(Aq         => { \*(AqMylib.pm\*(Aq            => \*(Aq$(INST_LIBDIR)/Mylib.pm\*(Aq},
\&   \*(AqINC\*(Aq          => &PDL_INCLUDE(), # add include dirs as required by your lib
\&   \*(AqLIBS\*(Aq         => [\*(Aq\*(Aq],   # add link directives as necessary
\&   \*(Aqclean\*(Aq        => {\*(AqFILES\*(Aq  =>
\&                          \*(AqMylib.pm Mylib.xs Mylib$(OBJ_EXT)
\&                          additional_Ccode$(OBJ_EXT)\*(Aq},
\&  );
\&
\&  # Add genpp rule; this will invoke PDL::PP on our PP file
\&  # the argument is an array reference where the array has three string elements:
\&  #   arg1: name of the source file that contains the PP code
\&  #   arg2: basename of the xs and pm files to be generated
\&  #   arg3: name of the package that is to be generated
\&  sub MY::postamble { pdlpp_postamble(["mylib.pd",Mylib,PDL::Lib::Mylib]); }
.Ve
.PP
To make life even easier PDL::Core::Dev defines the function \f(CW\*(C`pdlpp_stdargs\*(C'\fR
that returns a hash with default values that can be passed (either
directly or after appropriate modification) to a call to WriteMakefile.
Currently, \f(CW\*(C`pdlpp_stdargs\*(C'\fR returns a hash where the keys are filled in
as follows:
.PP
.Vb 10
\&        (
\&         \*(AqNAME\*(Aq         => $mod,
\&         \*(AqTYPEMAPS\*(Aq     => [&PDL_TYPEMAP()],
\&         \*(AqOBJECT\*(Aq       => "$pref\e$(OBJ_EXT)",
\&         PM     => {"$pref.pm" => "\e$(INST_LIBDIR)/$pref.pm"},
\&         MAN3PODS => {"$src" => "\e$(INST_MAN3DIR)/$mod.\e$(MAN3EXT)"},
\&         \*(AqINC\*(Aq          => &PDL_INCLUDE(),
\&         \*(AqLIBS\*(Aq         => [\*(Aq\*(Aq],
\&         \*(Aqclean\*(Aq        => {\*(AqFILES\*(Aq  => "$pref.xs $pref.pm $pref\e$(OBJ_EXT)"},
\&        )
.Ve
.PP
Here, \f(CW$src\fR is the name of the source file with \s-1PP\s0 code, \f(CW$pref\fR the
prefix for the generated .pm and .xs files and \f(CW$mod\fR the name of the
extension module to generate.
.SH "INTERNALS"
.IX Header "INTERNALS"
The internals of the current version consist of a large
table which gives the rules according to which things are translated
and the subs which implement these rules.
.PP
Later on, it would be good to make the table modifiable by the user
so that different things may be tried.
.PP
[Meta comment: here will hopefully be more in the future; currently,
your best bet will be to read the source code :\-( or ask on the list
(try the latter first) ]
.SH "Appendix A: Some keys recognised by PDL::PP"
.IX Header "Appendix A: Some keys recognised by PDL::PP"
Unless otherwise specified, the arguments are strings. Keys marked with
(bad) are only used if bad-value support is compiled into \s-1PDL.\s0
.IP "Pars" 4
.IX Item "Pars"
define the signature of your function
.IP "OtherPars" 4
.IX Item "OtherPars"
arguments which are not pdls. Default: nothing. This is a semi-colon
separated list of arguments, e.g.,
\&\f(CW\*(C`OtherPars=>\*(Aqint k; double value; char* fd\*(Aq\*(C'\fR. See \f(CW$COMP(x)\fR and
also the same entry in Appendix B.
.IP "Code" 4
.IX Item "Code"
the actual code that implements the functionality; several \s-1PP\s0 macros and
\&\s-1PP\s0 functions are recognised in the string value
.IP "HandleBad (bad)" 4
.IX Item "HandleBad (bad)"
If set to 1, the routine is assumed to support bad values and the code in
the BadCode key is used if bad values are present;
it also sets things up so that the \f(CW\*(C`$ISBAD()\*(C'\fR etc macros can be used.
If set to 0, cause the routine to print a warning if any of the input piddles 
have their bad flag set.
.IP "BadCode (bad)" 4
.IX Item "BadCode (bad)"
Give the code to be used if bad values may be present in the input piddles.
Only used if \f(CW\*(C`HandleBad => 1\*(C'\fR.
.IP "GenericTypes" 4
.IX Item "GenericTypes"
An array reference. The array may contain any subset of the one-character
strings `B', `S', `U', `L', `Q', `F' and `D', which specify which types
your operation will accept. The meaning of each type is:
.Sp
.Vb 8
\& B \- signed byte (i.e. signed char)
\& S \- signed short (two\-byte integer)
\& U \- unsigned short
\& L \- signed long (four\-byte integer, int on 32 bit systems)
\& N \- signed integer for indexing piddle elements (platform & Perl\-dependent size)
\& Q \- signed long long (eight byte integer)
\& F \- float
\& D \- double
.Ve
.Sp
This is very useful (and important!) when interfacing an external library.
Default: [qw/B S U L N Q F D/]
.IP "Inplace" 4
.IX Item "Inplace"
Mark a function as being able to work inplace.
.Sp
.Vb 3
\& Inplace => 1          if  Pars => \*(Aqa(); [o]b();\*(Aq
\& Inplace => [\*(Aqa\*(Aq]      if  Pars => \*(Aqa(); b(); [o]c();\*(Aq
\& Inplace => [\*(Aqa\*(Aq,\*(Aqb\*(Aq]  if  Pars => \*(Aqa(); b(); [o]c(); [o]d();\*(Aq
.Ve
.Sp
If bad values are being used, care must be taken to ensure the
propagation of the badflag when inplace is being used;
for instance see the code for \f(CW\*(C`replacebad\*(C'\fR in \fIBasic/Bad/bad.pd\fR.
.IP "Doc" 4
.IX Item "Doc"
Used to specify a documentation string in Pod format. See PDL::Doc
for information on \s-1PDL\s0 documentation conventions. Note: in
the special case where the \s-1PP\s0 'Doc' string is one line this is
implicitly used for the quick reference \s-1AND\s0 the documentation!
.Sp
If the Doc field is omitted \s-1PP\s0 will generate default documentation
(after all it knows about the Signature).
.Sp
If you really want the function \s-1NOT\s0 to be documented in any way at this point
(e.g. for an internal routine, or because you are doing it elsewhere in the
code) explicitly specify \f(CW\*(C`Doc=>undef\*(C'\fR.
.IP "BadDoc (bad)" 4
.IX Item "BadDoc (bad)"
Contains the text returned by the \f(CW\*(C`badinfo\*(C'\fR command (in \f(CW\*(C`perldl\*(C'\fR) or
the \f(CW\*(C`\-b\*(C'\fR switch to the \f(CW\*(C`pdldoc\*(C'\fR shell script. In many cases, you will
not need to specify this, since the information can be automatically
created by \s-1PDL::PP.\s0 However, as befits computer-generated text, it's
rather stilted; it may be much better to do it yourself!
.IP "NoPthread" 4
.IX Item "NoPthread"
Optional flag to indicate the \s-1PDL\s0 function should \fBnot\fR use processor threads (i.e.
pthreads or \s-1POSIX\s0 threads) to split up work across multiple \s-1CPU\s0 cores. This option
is typically set to 1 if the underlying \s-1PDL\s0 function is not threadsafe. If this option
isn't present, then the function is assumed to be threadsafe. This option only
applies if \s-1PDL\s0 has been compiled with \s-1POSIX\s0 threads enabled.
.IP "PMCode" 4
.IX Item "PMCode"
\&\s-1PDL\s0 functions allow you to pass in a piddle into which you want the output
saved. This is handy because you can allocate an output piddle once and
reuse it many times; the alternative would be for \s-1PDL\s0 to create a new piddle
each time, which may waste compute cycles or, more likely, \s-1RAM.\s0 This added
flexibility comes at the cost of more complexity: \s-1PDL::PP\s0 has to write
functions that are smart enough to count the arguments passed to it and
create new piddles on the fly, but only if you want them.
.Sp
\&\s-1PDL::PP\s0 is smart enough to do that, but there are restrictions on argument
order and the like. If you want a more flexible function, you can write your
own Perl-side wrapper and specify it in the PMCode key. The string that you
supply must (should) define a Perl function with a name that matches what you
gave to pp_def in the first place. When you wish to eventually invoke the
PP-generated function, you will need to supply all piddles in the exact
order specified in the signature: output piddles are not optional, and the
PP-generated function will not return anything. The obfuscated name that you
will call is _<funcname>_int.
.Sp
I believe this documentation needs further clarification, but this will have
to do. :\-(
.IP "PMFunc" 4
.IX Item "PMFunc"
When pp_def generates functions, it typically defines them in the \s-1PDL\s0
package. Then, in the .pm file that it generates for your module, it
typically adds a line that essentially copies that function into your current
package's symbol table with code that looks like this:
.Sp
.Vb 1
\& *func_name = \e&PDL::func_name;
.Ve
.Sp
It's a little bit smarter than that (it knows when to wrap that sort of
thing in a \s-1BEGIN\s0 block, for example, and if you specified something different
for pp_bless), but that's the gist of it. If you don't care to import the
function into your current package's symbol table, you can specify
.Sp
.Vb 1
\& PMFunc => \*(Aq\*(Aq,
.Ve
.Sp
PMFunc has no other side-effects, so you could use it to insert arbitrary
Perl code into your module if you like. However, you should use pp_addpm
if you want to add Perl code to your module.
.SH "Appendix B: PP macros and functions"
.IX Header "Appendix B: PP macros and functions"
.SS "Macros"
.IX Subsection "Macros"
Macros labeled by (bad) are only used if bad-value support is compiled into
\&\s-1PDL.\s0
.IP "$\fIvariablename_from_sig\fR()" 7
.IX Item "$variablename_from_sig()"
access a pdl (by its name) that was specified in the signature
.ie n .IP "$COMP(x)" 7
.el .IP "\f(CW$COM\fRP(x)" 7
.IX Item "$COMP(x)"
access a value in the private data structure of this transformation (mainly
used to use an argument that is specified in the \f(CW\*(C`OtherPars\*(C'\fR section)
.ie n .IP "$SIZE(n)" 7
.el .IP "\f(CW$SIZ\fRE(n)" 7
.IX Item "$SIZE(n)"
replaced at runtime by the actual size of a \fInamed\fR dimension (as specified
in the \fIsignature\fR)
.IP "$\fBGENERIC()\fR" 7
.IX Item "$GENERIC()"
replaced by the C type that is equal to the runtime type of the operation
.IP "$P(a)" 7
.IX Item "$P(a)"
a pointer access to the \s-1PDL\s0 named \f(CW\*(C`a\*(C'\fR in the signature. Useful for
interfacing to C functions
.ie n .IP "$PP(a)" 7
.el .IP "\f(CW$P\fRP(a)" 7
.IX Item "$PP(a)"
a physical pointer access to pdl \f(CW\*(C`a\*(C'\fR; mainly for internal use
.ie n .IP "$TXXX(Alternative,Alternative)" 7
.el .IP "\f(CW$TXX\fRX(Alternative,Alternative)" 7
.IX Item "$TXXX(Alternative,Alternative)"
expansion alternatives according to runtime type of operation,
where \s-1XXX\s0 is some string that is matched by \f(CW\*(C`/[BSULNQFD+]/\*(C'\fR.
.ie n .IP "$PDL(a)" 7
.el .IP "\f(CW$PD\fRL(a)" 7
.IX Item "$PDL(a)"
return a pointer to the pdl data structure (pdl *) of piddle \f(CW\*(C`a\*(C'\fR
.ie n .IP "$ISBAD(a()) (bad)" 7
.el .IP "\f(CW$ISBA\fRD(a()) (bad)" 7
.IX Item "$ISBAD(a()) (bad)"
returns true if the value stored in \f(CW\*(C`a()\*(C'\fR equals the bad value
for this piddle. 
Requires \f(CW\*(C`HandleBad\*(C'\fR being set to 1.
.ie n .IP "$ISGOOD(a()) (bad)" 7
.el .IP "\f(CW$ISGOO\fRD(a()) (bad)" 7
.IX Item "$ISGOOD(a()) (bad)"
returns true if the value stored in \f(CW\*(C`a()\*(C'\fR does not equal the bad value
for this piddle.
Requires \f(CW\*(C`HandleBad\*(C'\fR being set to 1.
.ie n .IP "$SETBAD(a()) (bad)" 7
.el .IP "\f(CW$SETBA\fRD(a()) (bad)" 7
.IX Item "$SETBAD(a()) (bad)"
Sets \f(CW\*(C`a()\*(C'\fR to equal the bad value for this piddle.
Requires \f(CW\*(C`HandleBad\*(C'\fR being set to 1.
.SS "functions"
.IX Subsection "functions"
.ie n .IP """loop(DIMS) %{ ... %}""" 3
.el .IP "\f(CWloop(DIMS) %{ ... %}\fR" 3
.IX Item "loop(DIMS) %{ ... %}"
loop over named dimensions; limits are generated automatically by \s-1PP\s0
.ie n .IP """threadloop %{ ... %}""" 3
.el .IP "\f(CWthreadloop %{ ... %}\fR" 3
.IX Item "threadloop %{ ... %}"
enclose following code in a thread loop
.ie n .IP """types(TYPES) %{ ... %}""" 3
.el .IP "\f(CWtypes(TYPES) %{ ... %}\fR" 3
.IX Item "types(TYPES) %{ ... %}"
execute following code if type of operation is any of \f(CW\*(C`TYPES\*(C'\fR
.SH "Appendix C: Functions imported by PDL::PP"
.IX Header "Appendix C: Functions imported by PDL::PP"
A number of functions are imported when you \f(CW\*(C`use PDL::PP\*(C'\fR. These include
functions that control the generated C or \s-1XS\s0 code, functions that control
the generated Perl code, and functions that manipulate the packages and
symbol tables into which the code is created.
.SS "Generating C and \s-1XS\s0 Code"
.IX Subsection "Generating C and XS Code"
\&\s-1PDL::PP\s0's main purpose is to make it easy for you to wrap the threading
engine around your own C code, but you can do some other things, too.
.IP "pp_def" 4
.IX Item "pp_def"
Used to wrap the threading engine around your C code. Virtually all of this
document discusses the use of pp_def.
.IP "pp_done" 4
.IX Item "pp_done"
Indicates you are done with \s-1PDL::PP\s0 and that it should generate its .xs
and .pm files based upon the other pp_* functions that you have called.
This function takes no arguments.
.IP "pp_addxs" 4
.IX Item "pp_addxs"
This lets you add \s-1XS\s0 code to your .xs file. This is useful if you want to
create Perl-accessible functions that invoke C code but cannot or should not
invoke the threading engine. \s-1XS\s0 is the standard means by which you wrap
Perl-accessible C code. You can learn more at perlxs.
.IP "pp_add_boot" 4
.IX Item "pp_add_boot"
This function adds whatever string you pass to the \s-1XS BOOT\s0 section. The \s-1BOOT\s0
section is C code that gets called by Perl when your module is loaded and is
useful for automatic initialization. You can learn more about \s-1XS\s0 and the \s-1BOOT\s0
section at perlxs.
.IP "pp_addhdr" 4
.IX Item "pp_addhdr"
Adds pure-C code to your \s-1XS\s0 file. \s-1XS\s0 files are structured such that pure C
code must come before \s-1XS\s0 specifications. This allows you to specify such
C code.
.IP "pp_boundscheck" 4
.IX Item "pp_boundscheck"
\&\s-1PDL\s0 normally checks the bounds of your accesses before making them. You can
turn that on or off at runtime by setting MyPackage::set_boundscheck. This
function allows you to remove that runtime flexibility and \fBnever\fR do bounds
checking. It also returns the current boundschecking status if called
without any argumens.
.Sp
\&\s-1NOTE: I\s0 have not found anything about bounds checking in other documentation.
That needs to be addressed.
.SS "Generating Perl Code"
.IX Subsection "Generating Perl Code"
Many functions imported when you use \s-1PDL::PP\s0 allow you to modify the
contents of the generated .pm file. In addition to pp_def and pp_done,
the role of these functions is primarily to add code to various parts of
your generated .pm file.
.IP "pp_addpm" 4
.IX Item "pp_addpm"
Adds Perl code to the generated .pm file. \s-1PDL::PP\s0 actually keeps track of
three different sections of generated code: the Top, the Middle, and the
Bottom. You can add Perl code to the Middle section using the one-argument
form, where the argument is the Perl code you want to supply. In the
two-argument form, the first argument is an anonymous hash with only
one key that specifies where to put the second argument, which is the string
that you want to add to the .pm file. The hash is one of these three:
.Sp
.Vb 3
\& {At => \*(AqTop\*(Aq}
\& {At => \*(AqMiddle\*(Aq}
\& {At => \*(AqBot\*(Aq}
.Ve
.Sp
For example:
.Sp
.Vb 1
\& pp_addpm({At => \*(AqBot\*(Aq}, <<POD);
\& 
\& =head1 Some documentation
\& 
\& I know I\*(Aqm typing this in the middle of my file, but it\*(Aqll go at
\& the bottom.
\& 
\& =cut
\& 
\& POD
.Ve
.Sp
Warning: If, in the middle of your .pd file, you put documentation meant for
the bottom of your pod, you will thoroughly confuse \s-1CPAN.\s0 On the other hand,
if in the middle of your .pd file, you add some Perl code destined for the
bottom or top of your .pm file, you only have yourself to confuse. :\-)
.IP "pp_beginwrap" 4
.IX Item "pp_beginwrap"
Adds BEGIN-block wrapping. Certain declarations can be wrapped in \s-1BEGIN\s0
blocks, though the default behavior is to have no such wrapping.
.IP "pp_addbegin" 4
.IX Item "pp_addbegin"
Sets code to be added to the top of your .pm file, even above code that you
specify with \f(CW\*(C`pp_addpm({At => \*(AqTop\*(Aq}, ...)\*(C'\fR. Unlike pp_addpm, calling
this overwrites whatever was there before. Generally, you probably shouldn't
use it.
.SS "Tracking Line Numbers"
.IX Subsection "Tracking Line Numbers"
When you get compile errors, either from your C\-like code or your Perl
code, it can help to make those errors back to the line numbers in the source
file at which the error occurred.
.IP "pp_line_numbers" 4
.IX Item "pp_line_numbers"
Takes a line number and a (usually long) string of code. The line number
should indicate the line at which the quote begins. This is usually Perl's
\&\f(CW\*(C`_\|_LINE_\|_\*(C'\fR literal, unless you are using heredocs, in which case it is
\&\f(CW\*(C`_\|_LINE_\|_ + 1\*(C'\fR. The returned string has #line directives interspersed to
help the compiler report errors on the proper line.
.SS "Modifying the Symbol Table and Export Behavior"
.IX Subsection "Modifying the Symbol Table and Export Behavior"
\&\s-1PDL::PP\s0 usually exports all functions generated using pp_def, and usually
installs them into the \s-1PDL\s0 symbol table. However, you can modify this
behavior with these functions.
.IP "pp_bless" 4
.IX Item "pp_bless"
Sets the package (symbol table) to which the \s-1XS\s0 code is added. The default
is \s-1PDL,\s0 which is generally what you want. If you use the default blessing
and you create a function myfunc, then you can do the following:
.Sp
.Vb 2
\& $piddle\->myfunc(<args>);
\& PDL::myfunc($piddle, <args>);
.Ve
.Sp
On the other hand, if you bless your functions into another package, you
cannot invoke them as \s-1PDL\s0 methods, and must invoke them as:
.Sp
.Vb 1
\& MyPackage::myfunc($piddle, <args>);
.Ve
.Sp
Of course, you could always use the PMFunc key to add your function to the
\&\s-1PDL\s0 symbol table, but why do that?
.IP "pp_add_isa" 4
.IX Item "pp_add_isa"
Adds to the list of modules from which your \fBmodule\fR inherits. The default
list is
.Sp
.Vb 1
\& qw(PDL::Exporter DynaLoader)
.Ve
.IP "pp_core_importlist" 4
.IX Item "pp_core_importlist"
At the top of your generated .pm file is a line that looks like this:
.Sp
.Vb 1
\& use PDL::Core;
.Ve
.Sp
You can modify that by specifying a string to pp_core_importlist. For
example,
.Sp
.Vb 1
\& pp_core_importlist(\*(Aq::Blarg\*(Aq);
.Ve
.Sp
will result in
.Sp
.Vb 1
\& use PDL::Core::Blarg;
.Ve
.Sp
You can use this, for example, to add a list of symbols to import from
PDL::Core. For example:
.Sp
.Vb 1
\& pp_core_importlist(" \*(Aq:Internal\*(Aq");
.Ve
.Sp
will lead to the following use statement:
.Sp
.Vb 1
\& use PDL::Core \*(Aq:Internal\*(Aq;
.Ve
.IP "pp_setversion" 4
.IX Item "pp_setversion"
Sets your module's version. The version must be consistent between the .xs
and the .pm file, and is used to ensure that your Perl's libraries do not
suffer from version skew.
.IP "pp_add_exported" 4
.IX Item "pp_add_exported"
Adds to the export list whatever names you give it.  Functions created using
pp_def are automatically added to the list. This function is useful if you
define any Perl functions using pp_addpm or pp_addxs that you want exported
as well.
.IP "pp_export_nothing" 4
.IX Item "pp_export_nothing"
This resets the list of exported symbols to nothing. This is probably better
called \f(CW\*(C`pp_export_clear\*(C'\fR, since you can add exported symbols after calling
\&\f(CW\*(C`pp_export_nothing\*(C'\fR. When called just before calling pp_done, this ensures
that your module does not export anything, for example, if you only want
programmers to use your functions as methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fI\s-1PDL\s0\fR
.PP
For the concepts of threading and slicing check PDL::Indexing.
.PP
PDL::Internals
.PP
PDL::BadValues for information on bad values
.PP
\&\fIperlxs\fR, \fIperlxstut\fR
.SH "CURRENTLY UNDOCUMENTED"
.IX Header "CURRENTLY UNDOCUMENTED"
Almost everything having to do with \*(L"Slice operation\*(R". This includes much of the following (each entry is followed by a guess/description of where it is used or defined):
.IP "\s-1MACROS\s0" 3
.IX Item "MACROS"
$\fBCDIM()\fR
.Sp
$\fBCHILD()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBCHILD_P()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBCHILD_PTR()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBCOPYDIMS()\fR
.Sp
$\fBCOPYINDS()\fR
.Sp
$\fBCROAK()\fR
    \fBPDL::PP::Rule::Substitute::dosubst_private()\fR
.Sp
$\fBDOCOMPDIMS()\fR
    Used in slices.pd, defined where?
.Sp
$\fBDOPRIVDIMS()\fR
    Used in slices.pd, defined where?
    Code comes from PDL::PP::CType::get_malloc, which is called by PDL::PP::CType::get_copy, which is called by PDL::PP::CopyOtherPars, PDL::PP::NT2Copies_\|_, and PDL::PP::make_incsize_copy.  But none of those three at first glance seem to have anything to do with \f(CW$DOPRIVDIMS\fR
.Sp
$\fBEQUIVCPOFFS()\fR
.Sp
$\fBEQUIVCPTRUNC()\fR
.Sp
$\fBPARENT()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBPARENT_P()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBPARENT_PTR()\fR
    PDL::PP::Rule::Substitute::Usual
.Sp
$\fBPDIM()\fR
.Sp
$\fBPRIV()\fR
    \fBPDL::PP::Rule::Substitute::dosubst_private()\fR
.Sp
$\fBRESIZE()\fR
.Sp
$\fBSETDELTATHREADIDS()\fR
    PDL::PP::Rule::MakeComp
.Sp
$\fBSETDIMS()\fR
    PDL::PP::Rule::MakeComp
.Sp
$\fBSETNDIMS()\fR
    PDL::PP::Rule::MakeComp
.Sp
$\fBSETREVERSIBLE()\fR
    \fBPDL::PP::Rule::Substitute::dosubst_private()\fR
.IP "Keys" 3
.IX Item "Keys"
AffinePriv
.Sp
BackCode
.Sp
BadBackCode
.Sp
CallCopy
.Sp
Comp (related to $\fBCOMP()\fR?)
.Sp
DefaultFlow
.Sp
EquivCDimExpr
.Sp
EquivCPOffsCode
.Sp
EquivDimCheck
.Sp
EquivPDimExpr
.Sp
FTypes (see comment in this \s-1POD\s0's source file between NoPthread and PMCode.)
.Sp
GlobalNew
.Sp
Identity
.Sp
MakeComp
.Sp
NoPdlThread
.Sp
P2Child
.Sp
ParentInds
.Sp
Priv
.Sp
ReadDataFuncName
.Sp
RedoDims (related to RedoDimsCode ?)
.Sp
Reversible
.Sp
WriteBckDataFuncName
.Sp
XCHGOnly
.SH "BUGS"
.IX Header "BUGS"
Although \s-1PDL::PP\s0 is quite flexible and thoroughly used, there are surely
bugs. First amongst them: this documentation needs a thorough revision.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright(C) 1997 Tuomas J. Lukka (lukka@fas.harvard.edu), Karl
Glaazebrook (kgb@aaocbn1.aao.GOV.AU) and Christian Soeller
(c.soeller@auckland.ac.nz). All rights reserved.
Documentation updates Copyright(C) 2011 David Mertens
(dcmertens.perl@gmail.com). This documentation is licensed under the same
terms as Perl itself.
